(* Parameter Eps_i "174b78e53fc239e8c2aab4ab5a996a27e3e5741e88070dad186e05fb13f275e5" *)
Parameter Eps_i : (set->prop)->set.
Axiom Eps_i_ax : forall P:set->prop, forall x:set, P x -> P (Eps_i P).
Definition True : prop := forall p:prop, p -> p.
Definition False : prop := forall p:prop, p.
Definition not : prop -> prop := fun A:prop => A -> False.
(* Unicode ~ "00ac" *)
Prefix ~ 700 := not.
Definition and : prop -> prop -> prop := fun A B:prop => forall p:prop, (A -> B -> p) -> p.
(* Unicode /\ "2227" *)
Infix /\ 780 left := and.
Definition or : prop -> prop -> prop := fun A B:prop => forall p:prop, (A -> p) -> (B -> p) -> p.
(* Unicode \/ "2228" *)
Infix \/ 785 left := or.
Definition iff : prop -> prop -> prop := fun A B:prop => and (A -> B) (B -> A).
(* Unicode <-> "2194" *)
Infix <-> 805 := iff.
Section Eq.
Variable A:SType.
Definition eq : A->A->prop := fun x y:A => forall Q:A->A->prop, Q x y -> Q y x.
Definition neq : A->A->prop := fun x y:A => ~ eq x y.
End Eq.
Infix = 502 := eq.
(* Unicode <> "2260" *)
Infix <> 502 := neq.
Section FE.
Variable A B : SType.
Axiom func_ext : forall f g : A -> B , (forall x : A , f x = g x) -> f = g.
End FE.
Section Ex.
Variable A:SType.
Definition ex : (A->prop)->prop := fun Q:A->prop => forall P:prop, (forall x:A, Q x -> P) -> P.
End Ex.
(* Unicode exists "2203" *)
Binder+ exists , := ex.
Axiom prop_ext : forall p q:prop, iff p q -> p = q.
Parameter In:set->set->prop.
Definition Subq : set -> set -> prop := fun A B => forall x :e A, x :e B.
Axiom set_ext : forall X Y:set, X c= Y -> Y c= X -> X = Y.
Axiom In_ind : forall P:set->prop, (forall X:set, (forall x :e X, P x) -> P X) -> forall X:set, P X.
Binder+ exists , := ex; and.
Parameter Empty : set.
Axiom EmptyAx : ~exists x:set, x :e Empty.
(* Unicode Union "22C3" *)
Parameter Union : set->set.
Axiom UnionEq : forall X x, x :e Union X <-> exists Y, x :e Y /\ Y :e X.
(* Unicode Power "1D4AB" *)
Parameter Power : set->set.
Axiom PowerEq : forall X Y:set, Y :e Power X <-> Y c= X.
Parameter Repl : set -> (set -> set) -> set.
Notation Repl Repl.
Axiom ReplEq : forall A:set, forall F:set->set, forall y:set, y :e {F x|x :e A} <-> exists x :e A, y = F x.
Definition TransSet : set->prop := fun U:set => forall x :e U, x c= U.
Definition Union_closed : set->prop := fun U:set => forall X:set, X :e U -> Union X :e U.
Definition Power_closed : set->prop := fun U:set => forall X:set, X :e U -> Power X :e U.
Definition Repl_closed : set->prop := fun U:set => forall X:set, X :e U -> forall F:set->set,
   (forall x:set, x :e X -> F x :e U) -> {F x|x :e X} :e U.
Definition ZF_closed : set->prop := fun U:set =>
   Union_closed U
/\ Power_closed U
/\ Repl_closed U.
Parameter UnivOf : set->set.
Axiom UnivOf_In : forall N:set, N :e UnivOf N.
Axiom UnivOf_TransSet : forall N:set, TransSet (UnivOf N).
Axiom UnivOf_ZF_closed : forall N:set, ZF_closed (UnivOf N).
Axiom UnivOf_Min : forall N U:set, N :e U
  -> TransSet U
  -> ZF_closed U
  -> UnivOf N c= U.

Theorem andI : forall (A B : prop), A -> B -> A /\ B.
exact (fun A B a b P H => H a b).
Qed.

Theorem orIL : forall (A B : prop), A -> A \/ B.
exact (fun A B a P H1 H2 => H1 a).
Qed.

Theorem orIR : forall (A B : prop), B -> A \/ B.
exact (fun A B b P H1 H2 => H2 b).
Qed.

Theorem iffI : forall A B:prop, (A -> B) -> (B -> A) -> (A <-> B).
exact (fun A B => andI (A -> B) (B -> A)).
Qed.

Theorem pred_ext : forall P Q:set -> prop, (forall x, P x <-> Q x) -> P = Q.
let P Q. assume H1. apply func_ext set prop.
let x. apply prop_ext.
prove P x <-> Q x. exact H1 x.
Qed.

Definition nIn : set->set->prop :=
fun x X => ~In x X.
(* Unicode /:e "2209" *)
Infix /:e 502 := nIn.

Theorem EmptyE : forall x:set, x /:e Empty.
let x. assume H.
apply EmptyAx.
witness x. exact H.
Qed.

Theorem PowerI : forall X Y:set, Y c= X -> Y :e Power X.
let X Y. apply PowerEq X Y. exact (fun _ H => H).
Qed.

Theorem Subq_Empty : forall X:set, Empty c= X.
exact (fun (X x : set) (H : x :e Empty) => EmptyE x H (x :e X)).
Qed.

Theorem Empty_In_Power : forall X:set, Empty :e Power X.
exact (fun X : set => PowerI X Empty (Subq_Empty X)).
Qed.


Theorem xm : forall P:prop, P \/ ~P.
let P:prop.
set p1 := fun x : set => x = Empty \/ P.
set p2 := fun x : set => x <> Empty \/ P.
claim L1:p1 Empty.
{ prove (Empty = Empty \/ P). apply orIL. exact (fun q H => H). }
claim L2: (Eps_i p1) = Empty \/ P.
{ exact (Eps_i_ax p1 Empty L1). }
claim L3:p2 (Power Empty).
{ prove ~(Power Empty = Empty) \/ P. apply orIL.
  assume H1: Power Empty = Empty.
  apply EmptyE Empty.
  prove Empty :e Empty.
  rewrite <- H1 at 2. apply Empty_In_Power.
}
claim L4: Eps_i p2 <> Empty \/ P.
{ exact (Eps_i_ax p2 (Power Empty) L3). }
apply L2.
- assume H1: Eps_i p1 = Empty.
  apply L4.
  + assume H2: Eps_i p2 <> Empty.
    prove P \/ ~ P.
    apply orIR.
    prove ~ P.
    assume H3 : P.
    claim L5:p1 = p2.
    { apply pred_ext. let x. apply iffI.
      - assume H4.
        prove (~(x = Empty) \/ P).
        apply orIR.
        prove P.
        exact H3.
      - assume H4.
        prove (x = Empty \/ P).
        apply orIR.
        prove P.
        exact H3.
    }
    apply H2. rewrite <- L5. exact H1.
  + assume H2:P.
    prove P \/ ~ P.
    apply orIL.
    prove P.
    exact H2.
- assume H1:P.
    prove P \/ ~ P.
    apply orIL.
    prove P.
    exact H1.
Qed.

Theorem FalseE : False -> forall p:prop, p.
exact (fun H => H).
Qed.

Theorem andEL : forall (A B : prop), A /\ B -> A.
exact (fun A B H => H A (fun a b => a)).
Qed.

Theorem andER : forall (A B : prop), A /\ B -> B.
exact (fun A B H => H B (fun a b => b)).
Qed.

Section PropN.
Variable P1 P2 P3:prop.

Theorem and3I : P1 -> P2 -> P3 -> P1 /\ P2 /\ P3.
exact (fun H1 H2 H3 => andI (P1 /\ P2) P3 (andI P1 P2 H1 H2) H3).
Qed.

Theorem and3E : P1 /\ P2 /\ P3 -> (forall p:prop, (P1 -> P2 -> P3 -> p) -> p).
exact (fun u p H => u p (fun u u3 => u p (fun u1 u2 => H u1 u2 u3))).
Qed.

Theorem or3I1 : P1 -> P1 \/ P2 \/ P3.
exact (fun u => orIL (P1 \/ P2) P3 (orIL P1 P2 u)).
Qed.

Theorem or3I2 : P2 -> P1 \/ P2 \/ P3.
exact (fun u => orIL (P1 \/ P2) P3 (orIR P1 P2 u)).
Qed.

Theorem or3I3 : P3 -> P1 \/ P2 \/ P3.
exact (orIR (P1 \/ P2) P3).
Qed.

Theorem or3E : P1 \/ P2 \/ P3 -> (forall p:prop, (P1 -> p) -> (P2 -> p) -> (P3 -> p) -> p).
exact (fun u p H1 H2 H3 => u p (fun u => u p H1 H2) H3).
Qed.

Variable P4:prop.

Theorem and4I : P1 -> P2 -> P3 -> P4 -> P1 /\ P2 /\ P3 /\ P4.
exact (fun H1 H2 H3 H4 => andI (P1 /\ P2 /\ P3) P4 (and3I H1 H2 H3) H4).
Qed.

Variable P5:prop.

Theorem and5I : P1 -> P2 -> P3 -> P4 -> P5 -> P1 /\ P2 /\ P3 /\ P4 /\ P5.
exact (fun H1 H2 H3 H4 H5 => andI (P1 /\ P2 /\ P3 /\ P4) P5 (and4I H1 H2 H3 H4) H5).
Qed.

Variable P6:prop.

Theorem and6I: P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6.
exact (fun H1 H2 H3 H4 H5 H6 => andI (P1 /\ P2 /\ P3 /\ P4 /\ P5) P6 (and5I H1 H2 H3 H4 H5) H6).
Qed.

Variable P7:prop.

Theorem and7I: P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P7 -> P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6 /\ P7.
exact (fun H1 H2 H3 H4 H5 H6 H7 => andI (P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6) P7 (and6I H1 H2 H3 H4 H5 H6) H7).
Qed.

End PropN.

Theorem not_or_and_demorgan : forall A B:prop, ~(A \/ B) -> ~A /\ ~B.
let A B.
assume u : ~(A \/ B).
apply andI.
- prove ~A. assume a:A. exact (u (orIL A B a)).
- prove ~B. assume b:B. exact (u (orIR A B b)).
Qed.

Theorem not_ex_all_demorgan_i : forall P:set->prop, (~exists x, P x) -> forall x, ~P x.
let P. assume H1. let x. assume H2. apply H1.
witness x.
exact H2.
Qed.

Theorem iffEL : forall A B:prop, (A <-> B) -> A -> B.
exact (fun A B => andEL (A -> B) (B -> A)).
Qed.

Theorem iffER : forall A B:prop, (A <-> B) -> B -> A.
exact (fun A B => andER (A -> B) (B -> A)).
Qed.

Theorem iff_refl : forall A:prop, A <-> A.
exact (fun A:prop => andI (A -> A) (A -> A) (fun H : A => H) (fun H : A => H)).
Qed.

Theorem iff_sym : forall A B:prop, (A <-> B) -> (B <-> A).
let A B.
assume H1: (A -> B) /\ (B -> A).
apply H1.
assume H2: A -> B.
assume H3: B -> A.
exact iffI B A H3 H2.
Qed.

Theorem iff_trans : forall A B C: prop, (A <-> B) -> (B <-> C) -> (A <-> C).
let A B C.
assume H1: A <-> B.
assume H2: B <-> C.
apply H1.
assume H3: A -> B.
assume H4: B -> A.
apply H2.
assume H5: B -> C.
assume H6: C -> B.
exact (iffI A C (fun H => H5 (H3 H)) (fun H => H4 (H6 H))).
Qed.

Theorem eq_i_tra : forall x y z, x = y -> y = z -> x = z.
let x y z. assume H1 H2. rewrite <- H2. exact H1.
Qed.

Theorem neq_i_sym: forall x y, x <> y -> y <> x.
let x y. assume H1 H2. apply H1. symmetry. exact H2.
Qed.

Theorem Eps_i_ex : forall P:set -> prop, (exists x, P x) -> P (Eps_i P).
let P. assume H1. apply H1.
let x. assume H2.
exact Eps_i_ax P x H2.
Qed.

Theorem prop_ext_2 : forall p q:prop, (p -> q) -> (q -> p) -> p = q.
let p q. assume H1 H2. apply prop_ext. apply iffI.
- exact H1.
- exact H2.
Qed.

Theorem Subq_ref : forall X:set, X c= X.
exact (fun (X x : set) (H : x :e X) => H).
Qed.

Theorem Subq_tra : forall X Y Z:set, X c= Y -> Y c= Z -> X c= Z.
exact (fun (X Y Z : set) (H1 : X c= Y) (H2 : Y c= Z) (x : set) (H : x :e X) => (H2 x (H1 x H))).
Qed.

Theorem Empty_Subq_eq : forall X:set, X c= Empty -> X = Empty.
let X.
assume H1: X c= Empty.
apply set_ext.
- exact H1.
- exact (Subq_Empty X).
Qed.

Theorem Empty_eq : forall X:set, (forall x, x /:e X) -> X = Empty.
let X.
assume H1: forall x, x /:e X.
apply Empty_Subq_eq.
let x.
assume H2: x :e X.
prove False.
exact (H1 x H2).
Qed.

Theorem UnionI : forall X x Y:set, x :e Y -> Y :e X -> x :e Union X.
let X x Y.
assume H1: x :e Y.
assume H2: Y :e X.
apply UnionEq X x.
assume _ H3. apply H3.
prove exists Y:set, x :e Y /\ Y :e X.
witness Y.
apply andI.
- exact H1.
- exact H2.
Qed.

Theorem UnionE : forall X x:set, x :e Union X -> exists Y:set, x :e Y /\ Y :e X.
exact (fun X x : set => iffEL (x :e Union X) (exists Y:set, x :e Y /\ Y :e X) (UnionEq X x)).
Qed.

Theorem UnionE_impred : forall X x:set, x :e Union X -> forall p:prop, (forall Y:set, x :e Y -> Y :e X -> p) -> p.
let X x. assume H1.
let p. assume Hp.
apply UnionE X x H1.
let x. assume H2. apply H2.
exact Hp x.
Qed.

Theorem PowerE : forall X Y:set, Y :e Power X -> Y c= X.
let X Y. apply PowerEq X Y. exact (fun H _ => H).
Qed.

Theorem Self_In_Power : forall X:set, X :e Power X.
exact (fun X : set => PowerI X X (Subq_ref X)).
Qed.

Theorem dneg : forall P:prop, ~~P -> P.
let P. assume H1.
apply xm P.
- exact (fun H => H).
- assume H2: ~P.
  prove False.
  exact H1 H2.
Qed.

Theorem not_all_ex_demorgan_i : forall P:set->prop, ~(forall x, P x) -> exists x, ~P x.
let P.
assume u:~forall x, P x.
apply dneg.
assume v:~exists x, ~P x.
apply u. let x. apply dneg.
assume w:~P x. 
exact (not_ex_all_demorgan_i (fun x => ~P x) v x w).
Qed.

Theorem eq_or_nand : or = (fun (x y:prop) => ~(~x /\ ~y)).
apply func_ext prop (prop -> prop).
let x. apply func_ext prop prop.
let y. apply prop_ext_2.
- assume H1: x \/ y.
  assume H2: ~x /\ ~y.
  apply H2. assume H3 H4. exact (H1 False H3 H4).
- assume H1:~(~x /\ ~y).
  apply (xm x).
  + assume H2: x. apply orIL. exact H2.
  + assume H2: ~x. apply (xm y).
    * assume H3: y. apply orIR. exact H3.
    * assume H3: ~y. apply H1. exact (andI (~x) (~y) H2 H3).
Qed.

(* Parameter exactly1of2 "3578b0d6a7b318714bc5ea889c6a38cf27f08eaccfab7edbde3cb7a350cf2d9b" "163602f90de012a7426ee39176523ca58bc964ccde619b652cb448bd678f7e21" *)
Definition exactly1of2 : prop->prop->prop := fun A B:prop =>
A /\ ~B \/ ~A /\ B.

Theorem exactly1of2_I1 : forall A B:prop, A -> ~B -> exactly1of2 A B.
let A B.
assume HA: A.
assume HB: ~B.
prove A /\ ~B \/ ~A /\ B.
apply orIL.
prove A /\ ~B.
exact (andI A (~B) HA HB).
Qed.

Theorem exactly1of2_I2 : forall A B:prop, ~A -> B -> exactly1of2 A B.
let A B.
assume HA: ~A.
assume HB: B.
prove A /\ ~B \/ ~A /\ B.
apply orIR.
prove ~A /\ B.
exact (andI (~A) B HA HB).
Qed.

Theorem exactly1of2_E : forall A B:prop, exactly1of2 A B ->
forall p:prop,
(A -> ~B -> p) ->
(~A -> B -> p) ->
p.
let A B.
assume H1: exactly1of2 A B.
let p.
assume H2 : A -> ~B -> p.
assume H3 : ~A -> B -> p.
apply (H1 p).
- exact (fun H4 : A /\ ~B => H4 p H2).
- exact (fun H4 : ~A /\ B => H4 p H3).
Qed.

Theorem exactly1of2_or : forall A B:prop, exactly1of2 A B -> A \/ B.
let A B.
assume H1: exactly1of2 A B.
apply (exactly1of2_E A B H1 (A \/ B)).
- exact (fun (HA : A) (_ : ~B) => orIL A B HA).
- exact (fun (_ : ~A) (HB : B) => orIR A B HB).
Qed.

Theorem ReplI : forall A:set, forall F:set->set, forall x:set, x :e A -> F x :e {F x|x :e A}.
let A F x. assume H1.
apply ReplEq A F (F x).
assume _ H2. apply H2.
prove exists x' :e A, F x = F x'.
witness x. apply andI.
- exact H1.
- exact (fun q H => H).
Qed.

Theorem ReplE : forall A:set, forall F:set->set, forall y:set, y :e {F x|x :e A} -> exists x :e A, y = F x.
let A F y. apply ReplEq A F y. exact (fun H _ => H).
Qed.

Theorem ReplE_impred : forall A:set, forall F:set->set, forall y:set, y :e {F x|x :e A} -> forall p:prop, (forall x:set, x :e A -> y = F x -> p) -> p.
let A F y. assume H1.
apply ReplE A F y H1.
let x. assume H2. apply H2.
assume H3 H4.
let p. assume Hp.
exact Hp x H3 H4.
Qed.

Theorem ReplE' : forall X, forall f:set -> set, forall p:set -> prop, (forall x :e X, p (f x)) -> forall y :e {f x|x :e X}, p y.
let X f p. assume H1. let y. assume Hy.
apply ReplE_impred X f y Hy.
let x. assume Hx: x :e X. assume Hx2: y = f x.
prove p y. rewrite Hx2. exact H1 x Hx.
Qed.

Theorem Repl_Empty : forall F:set -> set, {F x|x :e Empty} = Empty.
let F. apply (Empty_eq {F x|x :e Empty}).
let y.
assume H1: y :e {F x|x :e Empty}.
apply (ReplE_impred Empty F y H1).
let x.
assume H2: x :e Empty.
assume _.
exact (EmptyE x H2).
Qed.

Theorem ReplEq_ext_sub : forall X, forall F G:set -> set, (forall x :e X, F x = G x) -> {F x|x :e X} c= {G x|x :e X}.
let X F G.
assume H1: forall x :e X, F x = G x.
let y. assume Hy: y :e {F x|x :e X}.
apply ReplE_impred X F y Hy.
let x. assume Hx: x :e X.
assume H2: y = F x.
prove y :e {G x|x :e X}.
rewrite H2.
prove F x :e {G x|x :e X}.
rewrite H1 x Hx.
prove G x :e {G x|x :e X}.
apply ReplI. exact Hx.
Qed.

Theorem ReplEq_ext : forall X, forall F G:set -> set, (forall x :e X, F x = G x) -> {F x|x :e X} = {G x|x :e X}.
let X F G.
assume H1: forall x :e X, F x = G x.
apply set_ext.
- exact ReplEq_ext_sub X F G H1.
- apply ReplEq_ext_sub X G F.
  let x. assume Hx. symmetry. exact H1 x Hx.
Qed.

Theorem Repl_inv_eq : forall P:set -> prop, forall f g:set -> set,
    (forall x, P x -> g (f x) = x)
 -> forall X, (forall x :e X, P x) -> {g y|y :e {f x|x :e X}} = X.
let P f g. assume H1. let X. assume HX.
apply set_ext.
- let w. assume Hw: w :e {g y|y :e {f x|x :e X}}.
  apply ReplE_impred {f x|x :e X} g w Hw.
  let y. assume Hy: y :e {f x|x :e X}.
  assume Hwy: w = g y.
  apply ReplE_impred X f y Hy.
  let x. assume Hx: x :e X.
  assume Hyx: y = f x.
  prove w :e X. rewrite Hwy. rewrite Hyx.
  prove g (f x) :e X.
  rewrite H1 x (HX x Hx).
  exact Hx.
- let x. assume Hx: x :e X.
  rewrite <- H1 x (HX x Hx).
  prove g (f x) :e {g y|y :e {f x|x :e X}}.
  apply ReplI.
  prove f x :e {f x|x :e X}.
  apply ReplI. exact Hx.
Qed.

Theorem Repl_invol_eq : forall P:set -> prop, forall f:set -> set,
    (forall x, P x -> f (f x) = x)
 -> forall X, (forall x :e X, P x) -> {f y|y :e {f x|x :e X}} = X.
let P f. assume H1.
exact Repl_inv_eq P f f H1.
Qed.

(* Parameter If_i "8c8f550868df4fdc93407b979afa60092db4b1bb96087bc3c2f17fadf3f35cbf" "b8ff52f838d0ff97beb955ee0b26fad79602e1529f8a2854bda0ecd4193a8a3c" *)
Definition If_i : prop->set->set->set := (fun p x y => Eps_i (fun z:set => p /\ z = x \/ ~p /\ z = y)).
Notation IfThenElse If_i.

Theorem If_i_correct : forall p:prop, forall x y:set,
p /\ (if p then x else y) = x \/ ~p /\ (if p then x else y) = y.
let p x y.
apply (xm p).
- assume H1: p.
  claim L1: p /\ x = x \/ ~p /\ x = y.
  {
    apply orIL. apply andI.
    - exact H1.
    - reflexivity.
  }
  exact (Eps_i_ax (fun z : set => p /\ z = x \/ ~ p /\ z = y) x L1).
- assume H1: ~p.
  claim L1: p /\ y = x \/ ~p /\ y = y.
  {
    apply orIR. apply andI.
    - exact H1.
    - reflexivity.
  }
  exact (Eps_i_ax (fun z : set => p /\ z = x \/ ~ p /\ z = y) y L1).
Qed.

Theorem If_i_0 : forall p:prop, forall x y:set,
~ p -> (if p then x else y) = y.
let p x y.
assume H1: ~p.
apply (If_i_correct p x y).
- assume H2: p /\ (if p then x else y) = x.
  exact (H1 (andEL p ((if p then x else y) = x) H2) ((if p then x else y) = y)).
- assume H2: ~p /\ (if p then x else y) = y.
  exact (andER (~p) ((if p then x else y) = y) H2).
Qed.

Theorem If_i_1 : forall p:prop, forall x y:set,
p -> (if p then x else y) = x.
let p x y.
assume H1: p.
apply (If_i_correct p x y).
- assume H2: p /\ (if p then x else y) = x.
  exact (andER p ((if p then x else y) = x) H2).
- assume H2: ~p /\ (if p then x else y) = y.
  exact (andEL (~p) ((if p then x else y) = y) H2 H1 ((if p then x else y) = x)).
Qed.

Theorem If_i_or : forall p:prop, forall x y:set, (if p then x else y) = x \/ (if p then x else y) = y.
let p x y.
apply (xm p).
- assume H1: p. apply orIL. exact (If_i_1 p x y H1).
- assume H1: ~p. apply orIR. exact (If_i_0 p x y H1).
Qed.

(* Parameter UPair "80aea0a41bb8a47c7340fe8af33487887119c29240a470e920d3f6642b91990d" "74243828e4e6c9c0b467551f19c2ddaebf843f72e2437cc2dea41d079a31107f" *)
Definition UPair : set->set->set :=
fun y z => {if Empty :e X then y else z | X :e Power (Power Empty)}.
Notation SetEnum2 UPair.

Theorem UPairE :
forall x y z:set, x :e {y,z} -> x = y \/ x = z.
let x y z.
assume H1: x :e {y,z}.
apply (ReplE (Power (Power Empty)) (fun X => if Empty :e X then y else z) x H1).
let X.
assume H2: X :e Power (Power Empty) /\ x = if Empty :e X then y else z.
claim L1: x = if Empty :e X then y else z.
{ exact (andER (X :e Power (Power Empty)) (x = if Empty :e X then y else z) H2). }
apply (If_i_or (Empty :e X) y z).
- assume H3: (if Empty :e X then y else z) = y.
  apply orIL.
  prove x = y.
  rewrite <- H3. exact L1.
- assume H3: (if Empty :e X then y else z) = z.
  apply orIR.
  prove x = z.
  rewrite <- H3. exact L1.
Qed.

Theorem UPairI1 : forall y z:set, y :e {y,z}.
let y z.
prove y :e {y,z}.
rewrite <- (If_i_1 (Empty :e Power Empty) y z (Empty_In_Power Empty)) at 1.
prove (if Empty :e Power Empty then y else z) :e {y,z}.
prove (if Empty :e Power Empty then y else z) :e {if Empty :e X then y else z | X :e Power (Power Empty)}.
apply (ReplI (Power (Power Empty)) (fun X : set => if (Empty :e X) then y else z) (Power Empty)).
prove Power Empty :e Power (Power Empty).
exact (Self_In_Power (Power Empty)).
Qed.

Theorem UPairI2 : forall y z:set, z :e {y,z}.
let y z.
prove z :e {y,z}.
rewrite <- (If_i_0 (Empty :e Empty) y z (EmptyE Empty)) at 1.
prove (if Empty :e Empty then y else z) :e {y,z}.
prove (if Empty :e Empty then y else z) :e {if Empty :e X then y else z | X :e Power (Power Empty)}.
apply (ReplI (Power (Power Empty)) (fun X : set => if (Empty :e X) then y else z) Empty).
prove Empty :e Power (Power Empty).
exact (Empty_In_Power (Power Empty)).
Qed.

(* Parameter Sing "158bae29452f8cbf276df6f8db2be0a5d20290e15eca88ffe1e7b41d211d41d7" "bd01a809e97149be7e091bf7cbb44e0c2084c018911c24e159f585455d8e6bd0" *)
Definition Sing : set -> set := fun x => {x,x}.
Notation SetEnum1 Sing.

Theorem SingI : forall x:set, x :e {x}. 
exact (fun x : set => UPairI1 x x).
Qed.

Theorem SingE : forall x y:set, y :e {x} -> y = x. 
exact (fun x y H => UPairE y x x H (y = x) (fun H => H) (fun H => H)).
Qed.

(* Parameter binunion "0a445311c45f0eb3ba2217c35ecb47f122b2301b2b80124922fbf03a5c4d223e" "5e1ac4ac93257583d0e9e17d6d048ff7c0d6ccc1a69875b2a505a2d4da305784" *)
Definition binunion : set -> set -> set := fun X Y => Union {X,Y}.
(* Unicode :\/: "222a" *)
Infix :\/: 345 left := binunion.

Theorem binunionI1 : forall X Y z:set, z :e X -> z :e X :\/: Y.
let X Y z.
assume H1: z :e X.
prove z :e X :\/: Y.
prove z :e Union {X,Y}.
apply (UnionI {X,Y} z X).
- prove z :e X. exact H1.
- prove X :e {X,Y}. exact (UPairI1 X Y).
Qed.

Theorem binunionI2 : forall X Y z:set, z :e Y -> z :e X :\/: Y.
let X Y z.
assume H1: z :e Y.
prove z :e X :\/: Y.
prove z :e Union {X,Y}.
apply (UnionI {X,Y} z Y).
- prove z :e Y. exact H1.
- prove Y :e {X,Y}. exact (UPairI2 X Y).
Qed.

Theorem binunionE : forall X Y z:set, z :e X :\/: Y -> z :e X \/ z :e Y.
let X Y z.
assume H1: z :e X :\/: Y.
prove z :e X \/ z :e Y.
apply (UnionE_impred {X,Y} z H1).
let Z.
assume H2: z :e Z.
assume H3: Z :e {X,Y}.
apply (UPairE Z X Y H3).
- assume H4: Z = X.
  apply orIL.
  prove z :e X.
  rewrite <- H4.
  prove z :e Z.
  exact H2.
- assume H4: Z = Y.
  apply orIR.
  prove z :e Y.
  rewrite <- H4.
  prove z :e Z.
  exact H2.
Qed.

Theorem binunionE' : forall X Y z, forall p:prop, (z :e X -> p) -> (z :e Y -> p) -> (z :e X :\/: Y -> p).
let X Y z p. assume H1 H2 Hz.
apply binunionE X Y z Hz.
- assume H3: z :e X. exact H1 H3.
- assume H3: z :e Y. exact H2 H3.
Qed.

Theorem binunion_asso:forall X Y Z:set, X :\/: (Y :\/: Z) = (X :\/: Y) :\/: Z.
let X Y Z. apply set_ext.
- let w. assume H1: w :e X :\/: (Y :\/: Z).
  prove w :e (X :\/: Y) :\/: Z.
  apply (binunionE X (Y :\/: Z) w H1).
  + assume H2: w :e X.
    apply binunionI1. apply binunionI1. exact H2.
  + assume H2: w :e Y :\/: Z.
    apply (binunionE Y Z w H2).
    * assume H3: w :e Y.
      apply binunionI1. apply binunionI2. exact H3.
    * assume H3: w :e Z.
      apply binunionI2. exact H3.
- let w. assume H1: w :e (X :\/: Y) :\/: Z.
  prove w :e X :\/: (Y :\/: Z).
  apply (binunionE (X :\/: Y) Z w H1).
  + assume H2: w :e X :\/: Y.
    apply (binunionE X Y w H2).
    * assume H3: w :e X.
      apply binunionI1. exact H3.
    * assume H3: w :e Y.
      apply binunionI2. apply binunionI1. exact H3.
  + assume H2: w :e Z.
    apply binunionI2. apply binunionI2. exact H2.
Qed.

Theorem binunion_com_Subq:forall X Y:set, X :\/: Y c= Y :\/: X.
let X Y w. assume H1: w :e X :\/: Y.
prove w :e Y :\/: X.
apply (binunionE X Y w H1).
- assume H2: w :e X. apply binunionI2. exact H2.
- assume H2: w :e Y. apply binunionI1. exact H2.
Qed.

Theorem binunion_com:forall X Y:set, X :\/: Y = Y :\/: X.
let X Y. apply set_ext.
- exact (binunion_com_Subq X Y).
- exact (binunion_com_Subq Y X).
Qed.

Theorem binunion_idl:forall X:set, Empty :\/: X = X.
let X. apply set_ext.
- let x. assume H1: x :e Empty :\/: X.
  apply (binunionE Empty X x H1).
  + assume H2: x :e Empty. prove False. exact (EmptyE x H2).
  + assume H2: x :e X. exact H2.
- let x. assume H2: x :e X. prove x :e Empty :\/: X. apply binunionI2. exact H2.
Qed.

Theorem binunion_idr:forall X:set, X :\/: Empty = X.
let X.
rewrite (binunion_com X Empty).
exact (binunion_idl X).
Qed.

Theorem binunion_Subq_1: forall X Y:set, X c= X :\/: Y.
exact binunionI1.
Qed.

Theorem binunion_Subq_2: forall X Y:set, Y c= X :\/: Y.
exact binunionI2.
Qed.

Theorem binunion_Subq_min: forall X Y Z:set, X c= Z -> Y c= Z -> X :\/: Y c= Z.
let X Y Z.
assume H1: X c= Z.
assume H2: Y c= Z.
let w.
assume H3: w :e X :\/: Y.
apply (binunionE X Y w H3).
- assume H4: w :e X. exact (H1 w H4).
- assume H4: w :e Y. exact (H2 w H4).
Qed.

Theorem Subq_binunion_eq:forall X Y, (X c= Y) = (X :\/: Y = Y).
let X Y. apply prop_ext_2.
- assume H1: X c= Y.
  prove X :\/: Y = Y.
  apply set_ext.
  + prove X :\/: Y c= Y. apply (binunion_Subq_min X Y Y).
    * prove X c= Y. exact H1.
    * prove Y c= Y. exact (Subq_ref Y).
  + prove Y c= X :\/: Y. exact (binunion_Subq_2 X Y).
- assume H1: X :\/: Y = Y.
  prove X c= Y.
  rewrite <- H1.
  prove X c= X :\/: Y.
  exact (binunion_Subq_1 X Y).
Qed.

Definition SetAdjoin : set->set->set := fun X y => X :\/: {y}.
Notation SetEnum Empty Sing UPair SetAdjoin.
(* Parameter famunion "d772b0f5d472e1ef525c5f8bd11cf6a4faed2e76d4eacfa455f4d65cc24ec792" "b3e3bf86a58af5d468d398d3acad61ccc50261f43c856a68f8594967a06ec07a" *)
Definition famunion:set->(set->set)->set
:= fun X F => Union {F x|x :e X}.
(* Unicode \/_ "22C3" *)
(* Subscript \/_ *)
Binder \/_ , := famunion.

Theorem famunionI:forall X:set, forall F:(set->set), forall x y:set, x :e X -> y :e F x -> y :e \/_ x :e X, F x.
exact (fun X F x y H1 H2 => UnionI (Repl X F) y (F x) H2 (ReplI X F x H1)).
Qed.

Theorem famunionE:forall X:set, forall F:(set->set), forall y:set, y :e (\/_ x :e X, F x) -> exists x :e X, y :e F x.
let X F y.
assume H1: y :e (\/_ x :e X, F x).
prove exists x :e X, y :e F x.
apply (UnionE_impred {F x|x :e X} y H1).
let Y.
assume H2: y :e Y.
assume H3: Y :e {F x|x :e X}.
apply (ReplE_impred X F Y H3).
let x.
assume H4: x :e X.
assume H5: Y = F x.
witness x.
prove x :e X /\ y :e F x.
apply andI.
- exact H4.
- prove y :e F x.
  rewrite <- H5.
  exact H2.
Qed.

Theorem famunionE_impred : forall X : set , forall F : (set -> set) , forall y : set , y :e (\/_ x :e X , F x) -> forall p:prop, (forall x, x :e X -> y :e F x -> p) -> p.
let X F y. assume Hy.
let p. assume Hp.
apply famunionE X F y Hy.
let x. assume H1. apply H1.
exact Hp x.
Qed.

Theorem famunion_Empty: forall F:set -> set, (\/_ x :e Empty, F x) = Empty.
let F. apply Empty_Subq_eq.
let y. assume Hy: y :e \/_ x :e Empty, F x.
apply famunionE_impred Empty F y Hy.
let x. assume Hx: x :e Empty. prove False. exact EmptyE x Hx.
Qed.

Theorem famunion_Subq: forall X, forall f g:set -> set, (forall x :e X, f x c= g x) -> famunion X f c= famunion X g.
let X f g. assume Hfg.
let y. assume Hy. apply famunionE_impred X f y Hy.
let x. assume Hx.
assume H1: y :e f x.
apply famunionI X g x y Hx.
prove y :e g x.
exact Hfg x Hx y H1.
Qed.

Theorem famunion_ext: forall X, forall f g:set -> set, (forall x :e X, f x = g x) -> famunion X f = famunion X g.
let X f g. assume Hfg.
apply set_ext.
- apply famunion_Subq.
  let x. assume Hx. rewrite Hfg x Hx. apply Subq_ref.
- apply famunion_Subq.
  let x. assume Hx. rewrite Hfg x Hx. apply Subq_ref.
Qed.

Section SepSec.
Variable X:set.
Variable P:set->prop.
Let z : set := Eps_i (fun z => z :e X /\ P z).
Let F:set->set := fun x => if P x then x else z.
(* Parameter Sep "f7e63d81e8f98ac9bc7864e0b01f93952ef3b0cbf9777abab27bcbd743b6b079" "f336a4ec8d55185095e45a638507748bac5384e04e0c48d008e4f6a9653e9c44" *)
Definition Sep:set
:= if (exists z :e X, P z) then {F x|x :e X} else Empty.
End SepSec.
Notation Sep Sep.

Theorem SepI:forall X:set, forall P:(set->prop), forall x:set, x :e X -> P x -> x :e {x :e X|P x}.
let X P x.
set z : set := Eps_i (fun z => z :e X /\ P z).
set F : set->set := fun x => if P x then x else z.
assume H1: x :e X.
assume H2: P x.
claim L1: exists z :e X, P z.
{
  witness x. apply andI.
  - exact H1.
  - exact H2.
}
prove x :e {x :e X|P x}.
prove x :e if (exists z :e X, P z) then {F x|x :e X} else Empty.
(*** Note:
 Making L2 a claim and then rewriting with it succeeds, but rewrite (If_i_1 (exists z :e X, P z) {F x|x :e X} Empty L1) fails.
 The reason is that when the proposition proved by (If_i_1 (exists z :e X, P z) {F x|x :e X} Empty L1) is
 extracted by the code, the F x will be beta reduced to be if P x then x else z. After this beta reduction, the left hand side of the
 equation does not match the right hand side of the claim x :e if (exists z :e X, P z) then {F x|x :e X} else Empty.
 This is an example of how one must be careful using the apply and rewrite tactics and must sometimes give these
 kinds of explicit annotations, i.e., proving a beta-eta-delta equivalent claim.
 ***)
claim L2: (if (exists z :e X, P z) then {F x|x :e X} else Empty) = {F x|x :e X}.
{
  exact (If_i_1 (exists z :e X, P z) {F x|x :e X} Empty L1).
}
rewrite L2.
prove x :e {F x|x :e X}.
claim L3: F x = x.
{
  prove (if P x then x else z) = x.
  exact (If_i_1 (P x) x z H2).
}
rewrite <- L3.
prove F x :e {F x|x :e X}.
exact (ReplI X F x H1).
Qed.

Theorem SepE:forall X:set, forall P:(set->prop), forall x:set, x :e {x :e X|P x} -> x :e X /\ P x.
let X P x.
set z : set := Eps_i (fun z => z :e X /\ P z).
set F : set->set := fun x => if P x then x else z.
apply (xm (exists z :e X, P z)).
- assume H1: exists z :e X, P z.
  prove (x :e (if (exists z :e X, P z) then {F x|x :e X} else Empty) -> x :e X /\ P x).
  claim L1: (if (exists z :e X, P z) then {F x|x :e X} else Empty) = {F x|x :e X}.
  {
    exact (If_i_1 (exists z :e X, P z) {F x|x :e X} Empty H1).
  }
  rewrite L1.
  prove x :e {F x|x :e X} -> x :e X /\ P x.
  assume H2: x :e {F x|x :e X}.
  apply (ReplE_impred X F x H2).
  let y.
  assume H3: y :e X.
  assume H4: x = F y.
  prove x :e X /\ P x.
  apply (xm (P y)).
  + assume H5: P y.
    claim L2: x = y.
    {
      rewrite <- (If_i_1 (P y) y z H5).
      exact H4.
    }
    rewrite L2.
    prove y :e X /\ P y.
    apply andI.
    * exact H3.
    * exact H5.
  + assume H5: ~P y.
    claim L2: x = z.
    {
      rewrite <- (If_i_0 (P y) y z H5).
      exact H4.
    }
    rewrite L2.
    prove z :e X /\ P z.
    exact (Eps_i_ex (fun z => z :e X /\ P z) H1).
- assume H1: ~exists z :e X, P z.
  prove (x :e (if (exists z :e X, P z) then {F x|x :e X} else Empty) -> x :e X /\ P x).
  claim L1: (if (exists z :e X, P z) then {F x|x :e X} else Empty) = Empty.
  { exact (If_i_0 (exists z :e X, P z) {F x|x :e X} Empty H1). }
  rewrite L1.
  prove x :e Empty -> x :e X /\ P x.
  assume H2: x :e Empty.
  prove False.
  exact (EmptyE x H2).
Qed.

Theorem SepE1:forall X:set, forall P:(set->prop), forall x:set, x :e {x :e X|P x} -> x :e X.
exact (fun X P x H => SepE X P x H (x :e X) (fun H _ => H)).
Qed.

Theorem SepE2:forall X:set, forall P:(set->prop), forall x:set, x :e {x :e X|P x} -> P x.
exact (fun X P x H => SepE X P x H (P x) (fun _ H => H)).
Qed.

Theorem Sep_Empty: forall P:set -> prop, {x :e Empty|P x} = Empty.
let P. apply Empty_eq.
let x. assume Hx.
exact EmptyE x (SepE1 Empty P x Hx).
Qed.

Theorem Sep_Subq : forall X:set, forall P:set->prop, {x :e X|P x} c= X.
exact SepE1.
Qed.

Theorem Sep_In_Power : forall X:set, forall P:set->prop, {x :e X|P x} :e Power X.
exact (fun X P => PowerI X (Sep X P) (Sep_Subq X P)).
Qed.

(* Parameter ReplSep "f627d20f1b21063483a5b96e4e2704bac09415a75fed6806a2587ce257f1f2fd" "ec807b205da3293041239ff9552e2912636525180ddecb3a2b285b91b53f70d8" *)
Definition ReplSep : set->(set->prop)->(set->set)->set := fun X P F => {F x|x :e {z :e X|P z}}.
Notation ReplSep ReplSep.

Theorem ReplSepI: forall X:set, forall P:set->prop, forall F:set->set, forall x:set, x :e X -> P x -> F x :e {F x|x :e X, P x}.
exact (fun X P F x u v => ReplI (Sep X P) F x (SepI X P x u v)).
Qed.

Theorem ReplSepE:forall X:set, forall P:set->prop, forall F:set->set, forall y:set, y :e {F x|x :e X, P x} -> exists x:set, x :e X /\ P x /\ y = F x.
let X P F y.
assume H1: y :e {F x|x :e {z :e X|P z}}.
apply (ReplE {z :e X|P z} F y H1).
let x.
assume H2: x :e {z :e X|P z} /\ y = F x.
apply H2.
assume H3: x :e {z :e X|P z}.
assume H4: y = F x.
apply (SepE X P x H3).
assume H5: x :e X.
assume H6: P x.
witness x.
apply and3I.
- exact H5.
- exact H6.
- exact H4.
Qed.

Theorem ReplSepE_impred: forall X:set, forall P:set->prop, forall F:set->set, forall y:set, y :e {F x|x :e X, P x} -> forall p:prop, (forall x :e X, P x -> y = F x -> p) -> p.
let X P F y.
assume H1: y :e {F x|x :e X, P x}.
let p.
assume H2: forall x :e X, P x -> y = F x -> p.
prove p.
apply ReplSepE X P F y H1.
let x. assume H3. apply H3. assume H3. apply H3.
exact H2 x.
Qed.

(* Parameter binintersect "8cf6b1f490ef8eb37db39c526ab9d7c756e98b0eb12143156198f1956deb5036" "b2abd2e5215c0170efe42d2fa0fb8a62cdafe2c8fbd0d37ca14e3497e54ba729" *)
Definition binintersect:set->set->set
:= fun X Y => {x :e X |x :e Y}.
(* Unicode :/\: "2229" *)
Infix :/\: 340 left := binintersect.

Theorem binintersectI:forall X Y z, z :e X -> z :e Y -> z :e X :/\: Y.
exact (fun X Y z H1 H2 => SepI X (fun x:set => x :e Y) z H1 H2).
Qed.

Theorem binintersectE:forall X Y z, z :e X :/\: Y -> z :e X /\ z :e Y.
exact (fun X Y z H1 => SepE X (fun x:set => x :e Y) z H1).
Qed.

Theorem binintersectE1:forall X Y z, z :e X :/\: Y -> z :e X.
exact (fun X Y z H1 => SepE1 X (fun x:set => x :e Y) z H1).
Qed.

Theorem binintersectE2:forall X Y z, z :e X :/\: Y -> z :e Y.
exact (fun X Y z H1 => SepE2 X (fun x:set => x :e Y) z H1).
Qed.

Theorem binintersect_Subq_1:forall X Y:set, X :/\: Y c= X.
exact binintersectE1.
Qed.

Theorem binintersect_Subq_2:forall X Y:set, X :/\: Y c= Y.
exact binintersectE2.
Qed.

Theorem binintersect_Subq_eq_1 : forall X Y, X c= Y -> X :/\: Y = X.
let X Y.
assume H1: X c= Y.
apply set_ext.
- apply binintersect_Subq_1.
- let x. assume H2: x :e X.
  apply binintersectI.
  + exact H2.
  + apply H1. exact H2.
Qed.

Theorem binintersect_Subq_max:forall X Y Z:set, Z c= X -> Z c= Y -> Z c= X :/\: Y.
let X Y Z.
assume H1: Z c= X.
assume H2: Z c= Y.
let w.
assume H3: w :e Z.
apply (binintersectI X Y w).
- prove w :e X. exact (H1 w H3).
- prove w :e Y. exact (H2 w H3).
Qed.

Theorem binintersect_com_Subq: forall X Y:set, X :/\: Y c= Y :/\: X.
let X Y. apply (binintersect_Subq_max Y X (X :/\: Y)).
- prove X :/\: Y c= Y. apply binintersect_Subq_2.
- prove X :/\: Y c= X. apply binintersect_Subq_1.
Qed.

Theorem binintersect_com: forall X Y:set, X :/\: Y = Y :/\: X.
let X Y. apply set_ext.
- exact (binintersect_com_Subq X Y).
- exact (binintersect_com_Subq Y X).
Qed.

(* Parameter setminus "cc569397a7e47880ecd75c888fb7c5512aee4bcb1e7f6bd2c5f80cccd368c060" "c68e5a1f5f57bc5b6e12b423f8c24b51b48bcc32149a86fc2c30a969a15d8881" *)
Definition setminus:set->set->set
:= fun X Y => Sep X (fun x => x /:e Y).
(* Unicode :\: "2216" *)
Infix :\: 350 := setminus.

Theorem setminusI:forall X Y z, (z :e X) -> (z /:e Y) -> z :e X :\: Y.
exact (fun X Y z H1 H2 => SepI X (fun x:set => x /:e Y) z H1 H2).
Qed.

Theorem setminusE:forall X Y z, (z :e X :\: Y) -> z :e X /\ z /:e Y.
exact (fun X Y z H => SepE X (fun x:set => x /:e Y) z H).
Qed.

Theorem setminusE1:forall X Y z, (z :e X :\: Y) -> z :e X.
exact (fun X Y z H => SepE1 X (fun x:set => x /:e Y) z H).
Qed.

Theorem setminusE2:forall X Y z, (z :e X :\: Y) -> z /:e Y.
exact (fun X Y z H => SepE2 X (fun x:set => x /:e Y) z H).
Qed.

Theorem setminus_Subq:forall X Y:set, X :\: Y c= X.
exact setminusE1.
Qed.

Theorem setminus_In_Power : forall A U, A :\: U :e Power A.
let A U. apply PowerI. apply setminus_Subq.
Qed.

Theorem binunion_remove1_eq: forall X, forall x :e X, X = (X :\: {x}) :\/: {x}.
let X x.
assume Hx: x :e X.
apply set_ext.
- let y. assume Hy: y :e X.
  prove y :e (X :\: {x}) :\/: {x}.
  apply xm (y :e {x}).
  + assume H1: y :e {x}.
    apply binunionI2. exact H1.
  + assume H1: y /:e {x}.
    apply binunionI1. apply setminusI.
    * exact Hy.
    * exact H1.
- let y. assume Hy: y :e (X :\: {x}) :\/: {x}.
  apply binunionE (X :\: {x}) {x} y Hy.
  + assume H1: y :e X :\: {x}.
    prove y :e X.
    exact setminusE1 X {x} y H1.
  + assume H1: y :e {x}.
    prove y :e X.
    rewrite SingE x y H1.
    prove x :e X.
    exact Hx.
Qed.

Theorem In_irref : forall x, x /:e x.
apply In_ind.
prove (forall X:set, (forall x:set, x :e X -> x /:e x) -> X /:e X).
let X.
assume IH: forall x : set, x :e X -> x /:e x.
assume H: X :e X.
exact IH X H H.
Qed.

Theorem In_no2cycle : forall x y, x :e y -> y :e x -> False.
apply In_ind.
let x.
assume IH: forall z, z :e x -> forall y, z :e y -> y :e z -> False.
let y.
assume H1: x :e y.
assume H2: y :e x.
exact IH y H2 x H2 H1.
Qed.

(* Parameter ordsucc "9db634daee7fc36315ddda5f5f694934869921e9c5f55e8b25c91c0a07c5cbec" "65d8837d7b0172ae830bed36c8407fcd41b7d875033d2284eb2df245b42295a6" *)
Definition ordsucc : set->set := fun x:set => x :\/: {x}.

Theorem ordsuccI1 : forall x:set, x c= ordsucc x.
let x.
exact (fun (y : set) (H1 : y :e x) => binunionI1 x {x} y H1).
Qed.

Theorem ordsuccI2 : forall x:set, x :e ordsucc x.
exact (fun x : set => binunionI2 x {x} x (SingI x)).
Qed.

Theorem ordsuccE : forall x y:set, y :e ordsucc x -> y :e x \/ y = x.
let x y.
assume H1: y :e x :\/: {x}.
apply (binunionE x {x} y H1).
- assume H2: y :e x. apply orIL. exact H2.
- assume H2: y :e {x}. apply orIR. exact (SingE x y H2).
Qed.

Notation Nat Empty ordsucc.

Theorem neq_0_ordsucc : forall a:set, 0 <> ordsucc a.
let a. prove ~(0 = ordsucc a).
assume H1: 0 = ordsucc a.
claim L1: a :e ordsucc a -> False.
{ rewrite <- H1. exact (EmptyE a). }
exact (L1 (ordsuccI2 a)).
Qed.

Theorem neq_ordsucc_0 : forall a:set, ordsucc a <> 0.
let a. exact neq_i_sym 0 (ordsucc a) (neq_0_ordsucc a).
Qed.

Theorem ordsucc_inj : forall a b:set, ordsucc a = ordsucc b -> a = b.
let a b.
assume H1: ordsucc a = ordsucc b.
claim L1: a :e ordsucc b.
{
  rewrite <- H1.
  exact (ordsuccI2 a).
}
apply (ordsuccE b a L1).
- assume H2: a :e b.
  claim L2: b :e ordsucc a.
  {
    rewrite H1.
    exact (ordsuccI2 b).
  }
  apply (ordsuccE a b L2).
  + assume H3: b :e a. prove False. exact (In_no2cycle a b H2 H3).
  + assume H3: b = a. symmetry. exact H3.
- assume H2: a = b. exact H2.
Qed.

Theorem In_0_1 : 0 :e 1.
exact (ordsuccI2 0).
Qed.

Theorem In_0_2 : 0 :e 2.
exact (ordsuccI1 1 0 In_0_1).
Qed.

Theorem In_1_2 : 1 :e 2.
exact (ordsuccI2 1).
Qed.

Definition nat_p : set->prop := fun n:set => forall p:set->prop, p 0 -> (forall x:set, p x -> p (ordsucc x)) -> p n.

Theorem nat_0 : nat_p 0.
exact (fun p H _ => H).
Qed.

Theorem nat_ordsucc : forall n:set, nat_p n -> nat_p (ordsucc n).
exact (fun n H1 p H2 H3 => H3 n (H1 p H2 H3)).
Qed.

Theorem nat_1 : nat_p 1.
exact (nat_ordsucc 0 nat_0).
Qed.

Theorem nat_2 : nat_p 2.
exact (nat_ordsucc 1 nat_1).
Qed.

Theorem nat_0_in_ordsucc : forall n, nat_p n -> 0 :e ordsucc n.
let n.
assume H1.
apply H1 (fun n => 0 :e ordsucc n).
- prove 0 :e ordsucc 0.
  exact In_0_1.
- let n.
  assume IH: 0 :e ordsucc n.
  prove 0 :e ordsucc (ordsucc n).
  exact (ordsuccI1 (ordsucc n) 0 IH).
Qed.

Theorem nat_ordsucc_in_ordsucc : forall n, nat_p n -> forall m :e n, ordsucc m :e ordsucc n.
let n.
assume H1.
apply (H1 (fun n => forall m :e n, ordsucc m :e ordsucc n)).
- prove forall m :e 0, ordsucc m :e ordsucc 0.
  let m.
  assume Hm: m :e 0.
  prove False.
  exact (EmptyE m Hm).
- let n.
  assume IH: forall m :e n, ordsucc m :e ordsucc n.
  prove forall m :e ordsucc n, ordsucc m :e ordsucc (ordsucc n).
  let m.
  assume H2: m :e ordsucc n.
  prove ordsucc m :e ordsucc (ordsucc n).
  apply (ordsuccE n m H2).
  + assume H3: m :e n.
    claim L1: ordsucc m :e ordsucc n.
    { exact (IH m H3). }
    exact (ordsuccI1 (ordsucc n) (ordsucc m) L1).
  + assume H3: m = n.
    rewrite H3.
    prove ordsucc n :e ordsucc (ordsucc n).
    exact (ordsuccI2 (ordsucc n)).
Qed.

Theorem nat_ind : forall p:set->prop, p 0 -> (forall n, nat_p n -> p n -> p (ordsucc n)) -> forall n, nat_p n -> p n.
let p.
assume H1: p 0.
assume H2: forall n, nat_p n -> p n -> p (ordsucc n).
claim L1: nat_p 0 /\ p 0.
{ exact (andI (nat_p 0) (p 0) nat_0 H1). }
claim L2: forall n, nat_p n /\ p n -> nat_p (ordsucc n) /\ p (ordsucc n).
{ let n.
  assume H3: nat_p n /\ p n.
  apply H3.
  assume H4: nat_p n.
  assume H5: p n.
  apply andI.
  - prove nat_p (ordsucc n).
    exact (nat_ordsucc n H4).
  - prove p (ordsucc n).
    exact (H2 n H4 H5).
}
let n.
assume H3.
claim L3: nat_p n /\ p n.
{ exact (H3 (fun n => nat_p n /\ p n) L1 L2). }
exact (andER (nat_p n) (p n) L3).
Qed.

Theorem nat_complete_ind : forall p:set->prop, (forall n, nat_p n -> (forall m :e n, p m) -> p n) -> forall n, nat_p n -> p n.
let p.
assume H1: forall n, nat_p n -> (forall m :e n, p m) -> p n.
claim L1: forall n:set, nat_p n -> forall m :e n, p m.
{ apply nat_ind.
  - prove forall m :e 0, p m.
    let m.
    assume Hm: m :e 0.
    prove False.
    exact (EmptyE m Hm).
  - let n.
    assume Hn: nat_p n.
    assume IHn: forall m :e n, p m.
    prove forall m :e ordsucc n, p m.
    let m.
    assume Hm: m :e ordsucc n.
    prove p m.
    apply (ordsuccE n m Hm).
    + assume H2: m :e n.
      exact (IHn m H2).
    + assume H2: m = n.
      prove p m.
      rewrite H2.
      prove p n.
      exact (H1 n Hn IHn).
}
prove forall n, nat_p n -> p n.
exact (fun n Hn => H1 n Hn (L1 n Hn)).
Qed.

Theorem nat_inv_impred : forall p:set->prop, p 0 -> (forall n, nat_p n -> p (ordsucc n)) -> forall n, nat_p n -> p n.
let p. assume H1 H2. exact nat_ind p H1 (fun n H _ => H2 n H).
Qed.

Theorem nat_inv : forall n, nat_p n -> n = 0 \/ exists x, nat_p x /\ n = ordsucc x.
apply nat_inv_impred.
- apply orIL. reflexivity.
- let n. assume Hn. apply orIR. witness n. apply andI.
  + exact Hn.
  + reflexivity.
Qed.

Theorem nat_p_trans : forall n, nat_p n -> forall m :e n, nat_p m.
apply nat_ind.
- prove forall m :e 0, nat_p m.
  let m.
  assume Hm: m :e 0.
  prove False.
  exact (EmptyE m Hm).
- let n.
  assume Hn: nat_p n.
  assume IHn: forall m :e n, nat_p m.
  prove forall m :e ordsucc n, nat_p m.
  let m.
  assume Hm: m :e ordsucc n.
  apply (ordsuccE n m Hm).
  + assume H1: m :e n.
    exact (IHn m H1).
  + assume H1: m = n.
    rewrite H1.
    exact Hn.
Qed.

Theorem nat_trans : forall n, nat_p n -> forall m :e n, m c= n.
apply nat_ind.
- prove forall m :e 0, m c= 0.
  let m.
  assume Hm: m :e 0.
  prove False.
  exact (EmptyE m Hm).
- let n.
  assume Hn: nat_p n.
  assume IHn: forall m :e n, m c= n.
  prove forall m :e ordsucc n, m c= ordsucc n.
  let m.
  assume Hm: m :e ordsucc n.
  apply (ordsuccE n m Hm).
  + assume H1: m :e n.
    prove m c= ordsucc n.
    apply (Subq_tra m n (ordsucc n)).
    * exact (IHn m H1).
    * exact (ordsuccI1 n).
  + assume H1: m = n.
    prove m c= ordsucc n.
    rewrite H1.
    prove n c= ordsucc n.
    exact (ordsuccI1 n).
Qed.

Theorem nat_ordsucc_trans : forall n, nat_p n -> forall m :e ordsucc n, m c= n.
let n.
assume Hn: nat_p n.
let m.
assume Hm: m :e ordsucc n.
let k.
assume Hk: k :e m.
prove k :e n.
apply (ordsuccE n m Hm).
- assume H1: m :e n.
  exact nat_trans n Hn m H1 k Hk.
- assume H1: m = n.
  rewrite <- H1.
  exact Hk.
Qed.

Definition surj : set->set->(set->set)->prop :=
  fun X Y f =>
  (forall u :e X, f u :e Y)
  /\
  (forall w :e Y, exists u :e X, f u = w).

Theorem form100_63_surjCantor: forall A:set, forall f:set -> set, ~surj A (Power A) f.
let A f. assume H. apply H.
assume H1: forall u :e A, f u :e Power A.
assume H2: forall w :e Power A, exists u :e A, f u = w.
set D := {x :e A|x /:e f x}.
claim L1: D :e Power A.
{ exact Sep_In_Power A (fun x => x /:e f x). }
apply H2 D L1.
let d. assume H. apply H.
assume Hd: d :e A.
assume HfdD: f d = D.
claim L2: d /:e D.
{ assume H3: d :e D.
  apply SepE2 A (fun x => x /:e f x) d H3.
  prove d :e f d.
  rewrite HfdD.
  prove d :e D.
  exact H3.
}
apply L2.
prove d :e D.
apply SepI.
- prove d :e A. exact Hd.
- prove d /:e f d. rewrite HfdD. exact L2.
Qed.

Definition inj : set->set->(set->set)->prop :=
  fun X Y f =>
  (forall u :e X, f u :e Y)
  /\
  (forall u v :e X, f u = f v -> u = v).

Theorem form100_63_injCantor: forall A:set, forall f:set -> set, ~inj (Power A) A f.
let A f. assume H. apply H.
assume H1: forall X :e Power A, f X :e A.
assume H2: forall X Y :e Power A, f X = f Y -> X = Y.
set D := {f X | X :e Power A, f X /:e X}.
claim L1: D :e Power A.
{ apply PowerI.
  let n. assume H3: n :e D.
  apply ReplSepE_impred (Power A) (fun X => f X /:e X) f n H3.
  let X. assume HX: X :e Power A.
  assume H4: f X /:e X.
  assume H5: n = f X.
  prove n :e A. rewrite H5. apply H1. exact HX.
}
claim L2: f D /:e D.
{ assume H3: f D :e D.
  apply ReplSepE_impred (Power A) (fun X => f X /:e X) f (f D) H3.
  let X. assume HX: X :e Power A.
  assume H4: f X /:e X.
  assume H5: f D = f X.
  claim L2a: D = X.
  { exact H2 D L1 X HX H5. }
  apply H4. rewrite <- L2a. exact H3.
}
apply L2.
prove f D :e D.
apply ReplSepI.
- prove D :e Power A. exact L1.
- prove f D /:e D. exact L2.
Qed.

Theorem injI : forall X Y, forall f:set -> set, (forall x :e X, f x :e Y) -> (forall x z :e X, f x = f z -> x = z) -> inj X Y f.
let X Y f. assume H1 H2.
prove (forall x :e X, f x :e Y) /\ (forall x z :e X, f x = f z -> x = z).
apply andI.
- exact H1.
- exact H2.
Qed.

Theorem inj_comp : forall X Y Z:set, forall f g:set->set, inj X Y f -> inj Y Z g -> inj X Z (fun x => g (f x)).
let X Y Z f g.
assume Hf.
assume Hg.
apply Hf.
assume Hf1 Hf2.
apply Hg.
assume Hg1 Hg2.
apply injI.
- let u. assume Hu: u :e X. exact (Hg1 (f u) (Hf1 u Hu)).
- let u. assume Hu: u :e X. let v. assume Hv: v :e X.
  assume H1: g (f u) = g (f v).
  prove u = v.
  apply Hf2 u Hu v Hv.
  prove f u = f v.
  apply Hg2 (f u) (Hf1 u Hu) (f v) (Hf1 v Hv).
  prove g (f u) = g (f v).
  exact H1.
Qed.

Definition bij : set->set->(set->set)->prop :=
  fun X Y f =>
  (forall u :e X, f u :e Y)
  /\
  (forall u v :e X, f u = f v -> u = v)
  /\
  (forall w :e Y, exists u :e X, f u = w).

Theorem bijI : forall X Y, forall f:set -> set,
    (forall u :e X, f u :e Y)
 -> (forall u v :e X, f u = f v -> u = v)
 -> (forall w :e Y, exists u :e X, f u = w)
 -> bij X Y f.
let X Y f. assume Hf1 Hf2 Hf3.
prove (forall u :e X, f u :e Y)
   /\ (forall u v :e X, f u = f v -> u = v)
   /\ (forall w :e Y, exists u :e X, f u = w).
apply and3I.
- exact Hf1.
- exact Hf2.
- exact Hf3.
Qed.

Theorem bijE : forall X Y, forall f:set -> set,
    bij X Y f
 -> forall p:prop,
      ((forall u :e X, f u :e Y)
    -> (forall u v :e X, f u = f v -> u = v)
    -> (forall w :e Y, exists u :e X, f u = w)
    -> p)
   -> p.
let X Y f. assume Hf. let p. assume Hp.
apply Hf. assume Hf. apply Hf.
assume Hf1 Hf2 Hf3.
exact Hp Hf1 Hf2 Hf3.
Qed.

Theorem bij_inj : forall X Y, forall f:set -> set, bij X Y f -> inj X Y f.
let X Y f. assume H1. apply H1. assume H1 _. exact H1.
Qed.

Theorem bij_id : forall X, bij X X (fun x => x).
let X.
prove (forall u :e X, u :e X) /\ (forall u v :e X, u = v -> u = v) /\ (forall w :e X, exists u :e X, u = w).
apply and3I.
- exact (fun u Hu => Hu).
- exact (fun u Hu v Hv H1 => H1).
- let w. assume Hw. witness w. apply andI.
  + exact Hw.
  + reflexivity.
Qed.

Theorem bij_comp : forall X Y Z:set, forall f g:set->set, bij X Y f -> bij Y Z g -> bij X Z (fun x => g (f x)).
let X Y Z f g.
assume Hf. apply Hf. assume Hf12 Hf3. apply Hf12. assume Hf1 Hf2.
assume Hg. apply Hg. assume Hg12 Hg3. apply Hg12. assume Hg1 Hg2.
prove (forall u :e X, g (f u) :e Z)
  /\
  (forall u v :e X, g (f u) = g (f v) -> u = v)
  /\
  (forall w :e Z, exists u :e X, g (f u) = w).
apply and3I.
- let u. assume Hu: u :e X. exact (Hg1 (f u) (Hf1 u Hu)).
- let u. assume Hu: u :e X. let v. assume Hv: v :e X.
  assume H1: g (f u) = g (f v).
  prove u = v.
  apply Hf2 u Hu v Hv.
  prove f u = f v.
  apply Hg2 (f u) (Hf1 u Hu) (f v) (Hf1 v Hv).
  prove g (f u) = g (f v).
  exact H1.
- let w. assume Hw: w :e Z. apply Hg3 w Hw.
  let y. assume Hy12. apply Hy12.
  assume Hy1: y :e Y. assume Hy2: g y = w.
  apply Hf3 y Hy1.
  let u. assume Hu12. apply Hu12.
  assume Hu1: u :e X. assume Hu2: f u = y.
  prove exists u :e X, g (f u) = w.
  witness u.
  apply andI.
  + exact Hu1.
  + rewrite Hu2. exact Hy2.
Qed.

Theorem bij_surj : forall X Y, forall f:set -> set, bij X Y f -> surj X Y f.
let X Y f. assume H1. apply H1. assume H1. apply H1.
assume H1 _ H2.
prove (forall u :e X, f u :e Y)
   /\ (forall w :e Y, exists u :e X, f u = w).
apply andI.
- exact H1.
- exact H2.
Qed.

Definition inv : set -> (set -> set) -> set -> set := fun X f => fun y:set => Eps_i (fun x => x :e X /\ f x = y).

Theorem surj_rinv : forall X Y, forall f:set->set, (forall w :e Y, exists u :e X, f u = w) -> forall y :e Y, inv X f y :e X /\ f (inv X f y) = y.
let X Y f. assume H1.
let y. assume Hy: y :e Y.
apply H1 y Hy.
let x.
assume H2.
exact Eps_i_ax (fun x => x :e X /\ f x = y) x H2.
Qed.

Theorem inj_linv : forall X, forall f:set->set, (forall u v :e X, f u = f v -> u = v) -> forall x :e X, inv X f (f x) = x.
let X f.
assume H1.
let x. assume Hx.
claim L1: inv X f (f x) :e X /\ f (inv X f (f x)) = f x.
{ apply Eps_i_ax (fun x' => x' :e X /\ f x' = f x) x.
  apply andI.
  - exact Hx.
  - reflexivity.
}
apply L1.
assume H2 H3.
exact H1 (inv X f (f x)) H2 x Hx H3.
Qed.

Theorem bij_inv : forall X Y, forall f:set->set, bij X Y f -> bij Y X (inv X f).
let X Y f.
assume H1. apply H1.
assume H2. apply H2.
assume H3: forall u :e X, f u :e Y.
assume H4: forall u v :e X, f u = f v -> u = v.
assume H5: forall w :e Y, exists u :e X, f u = w.
set g : set->set := fun y => Eps_i (fun x => x :e X /\ f x = y).
claim L1: forall y :e Y, g y :e X /\ f (g y) = y.
{ exact surj_rinv X Y f H5. }
prove (forall u :e Y, g u :e X)
      /\
      (forall u v :e Y, g u = g v -> u = v)
      /\
      (forall w :e X, exists u :e Y, g u = w).
apply and3I.
- prove forall u :e Y, g u :e X.
  let u. assume Hu. apply L1 u Hu. assume H _. exact H.
- prove forall u v :e Y, g u = g v -> u = v.
  let u. assume Hu. let v. assume Hv H6.
  prove u = v.
  apply L1 u Hu.
  assume H7: g u :e X.
  assume H8: f (g u) = u.
  apply L1 v Hv.
  assume H9: g v :e X.
  assume H10: f (g v) = v.
  rewrite <- H8.
  rewrite <- H10.
  rewrite <- H6.
  reflexivity.
- prove forall w :e X, exists u :e Y, g u = w.
  let w. assume Hw.
  claim Lfw: f w :e Y.
  { exact H3 w Hw. }
  witness f w.
  apply andI.
  + exact Lfw.
  + exact inj_linv X f H4 w Hw.
Qed.

Definition atleastp : set -> set -> prop
 := fun X Y : set => exists f : set -> set, inj X Y f.

Theorem atleastp_tra: forall X Y Z, atleastp X Y -> atleastp Y Z -> atleastp X Z.
admit.
Qed.

Theorem Subq_atleastp : forall X Y, X c= Y -> atleastp X Y.
admit.
Qed.

Definition equip : set -> set -> prop
 := fun X Y : set => exists f : set -> set, bij X Y f.

Theorem equip_atleastp: forall X Y, equip X Y -> atleastp X Y.
admit.
Qed.

Theorem equip_ref : forall X, equip X X.
admit.
Qed.

Theorem equip_sym : forall X Y, equip X Y -> equip Y X.
admit.
Qed.

Theorem equip_tra : forall X Y Z, equip X Y -> equip Y Z -> equip X Z.
admit.
Qed.

Theorem equip_0_Empty : forall X, equip X 0 -> X = 0.
admit.
Qed.

Theorem equip_adjoin_ordsucc : forall N X y, y /:e X -> equip N X -> equip (ordsucc N) (X :\/: {y}).
admit.
Qed.

Theorem equip_ordsucc_remove1: forall X N, forall x :e X, equip X (ordsucc N) -> equip (X :\: {x}) N.
admit.
Qed.

Section SchroederBernstein.

Theorem KnasterTarski_set: forall A, forall F:set->set,
    (forall U :e Power A, F U :e Power A)
 -> (forall U V :e Power A, U c= V -> F U c= F V)
 -> exists Y :e Power A, F Y = Y.
admit.
Qed.

Theorem image_In_Power : forall A B, forall f:set -> set, (forall x :e A, f x :e B) -> forall U :e Power A, {f x|x :e U} :e Power B.
admit.
Qed.

Theorem image_monotone : forall f:set -> set, forall U V, U c= V -> {f x|x :e U} c= {f x|x :e V}.
admit.
Qed.

Theorem setminus_antimonotone : forall A U V, U c= V -> A :\: V c= A :\: U.
admit.
Qed.

Theorem SchroederBernstein: forall A B, forall f g:set -> set, inj A B f -> inj B A g -> equip A B.
admit.
Qed.

Theorem atleastp_antisym_equip: forall A B, atleastp A B -> atleastp B A -> equip A B.
admit.
Qed.

End SchroederBernstein.

Section PigeonHole.

Theorem PigeonHole_nat : forall n, nat_p n -> forall f:set -> set, (forall i :e ordsucc n, f i :e n) -> ~(forall i j :e ordsucc n, f i = f j -> i = j).
admit.
Qed.

Theorem Pigeonhole_not_atleastp_ordsucc : forall n, nat_p n -> ~atleastp (ordsucc n) n.
admit.
Qed.

End PigeonHole.

Theorem Union_ordsucc_eq : forall n, nat_p n -> Union (ordsucc n) = n.
admit.
Qed.

Theorem cases_1: forall i :e 1, forall p:set->prop, p 0 -> p i.
admit.
Qed.

Theorem cases_2: forall i :e 2, forall p:set->prop, p 0 -> p 1 -> p i.
admit.
Qed.

Theorem neq_0_1 : 0 <> 1.
admit.
Qed.

Theorem neq_1_0 : 1 <> 0.
admit.
Qed.

Theorem neq_0_2 : 0 <> 2.
admit.
Qed.

Theorem neq_2_0 : 2 <> 0.
admit.
Qed.

Definition ordinal : set->prop := fun (alpha:set) => TransSet alpha /\ forall beta :e alpha, TransSet beta.

Theorem ordinal_TransSet : forall alpha:set, ordinal alpha -> TransSet alpha.
admit.
Qed.

Theorem ordinal_Empty : ordinal Empty.
admit.
Qed.

Theorem ordinal_Hered : forall alpha:set, ordinal alpha -> forall beta :e alpha, ordinal beta.
admit.
Qed.

Theorem TransSet_ordsucc : forall X:set, TransSet X -> TransSet (ordsucc X).
admit.
Qed.

Theorem ordinal_ordsucc : forall alpha:set, ordinal alpha -> ordinal (ordsucc alpha).
admit.
Qed.

Theorem nat_p_ordinal : forall n:set, nat_p n -> ordinal n.
admit.
Qed.

Theorem ordinal_1 : ordinal 1.
admit.
Qed.

Theorem ordinal_2 : ordinal 2.
admit.
Qed.

Theorem TransSet_ordsucc_In_Subq : forall X:set, TransSet X -> forall x :e X, ordsucc x c= X.
admit.
Qed.

Theorem ordinal_ordsucc_In_Subq : forall alpha, ordinal alpha -> forall beta :e alpha, ordsucc beta c= alpha.
admit.
Qed.

Theorem ordinal_trichotomy_or : forall alpha beta:set, ordinal alpha -> ordinal beta -> alpha :e beta \/ alpha = beta \/ beta :e alpha.
admit.
Qed.    

Theorem ordinal_trichotomy_or_impred : forall alpha beta:set, ordinal alpha -> ordinal beta -> forall p:prop, (alpha :e beta -> p) -> (alpha = beta -> p) -> (beta :e alpha -> p) -> p.
admit.
Qed.

Theorem ordinal_In_Or_Subq : forall alpha beta, ordinal alpha -> ordinal beta -> alpha :e beta \/ beta c= alpha.
admit.
Qed.

Theorem ordinal_linear : forall alpha beta, ordinal alpha -> ordinal beta -> alpha c= beta \/ beta c= alpha.
admit.
Qed.

Theorem ordinal_ordsucc_In_eq : forall alpha beta, ordinal alpha -> beta :e alpha -> ordsucc beta :e alpha \/ alpha = ordsucc beta.
admit.
Qed.

Theorem ordinal_lim_or_succ : forall alpha, ordinal alpha -> (forall beta :e alpha, ordsucc beta :e alpha) \/ (exists beta :e alpha, alpha = ordsucc beta).
admit.
Qed.

Theorem ordinal_ordsucc_In : forall alpha, ordinal alpha -> forall beta :e alpha, ordsucc beta :e ordsucc alpha.
admit.
Qed.

Theorem ordinal_famunion : forall X, forall F:set -> set, (forall x :e X, ordinal (F x)) -> ordinal (\/_ x :e X, F x).
admit.
Qed.

Theorem ordinal_binintersect : forall alpha beta, ordinal alpha -> ordinal beta -> ordinal (alpha :/\: beta).
admit.
Qed.

Theorem ordinal_binunion : forall alpha beta, ordinal alpha -> ordinal beta -> ordinal (alpha :\/: beta).
admit.
Qed.

Theorem ordinal_ind : forall p:set->prop, 
(forall alpha, ordinal alpha -> (forall beta :e alpha, p beta) -> p alpha)
->
forall alpha, ordinal alpha -> p alpha.
admit.
Qed.

Theorem least_ordinal_ex : forall p:set -> prop, (exists alpha, ordinal alpha /\ p alpha) -> exists alpha, ordinal alpha /\ p alpha /\ forall beta :e alpha, ~p beta.
admit.
Qed.

Theorem equip_Sing_1 : forall x, equip {x} 1.
admit.
Qed.

Theorem TransSet_In_ordsucc_Subq : forall x y, TransSet y -> x :e ordsucc y -> x c= y.
admit.
Qed.

Theorem exandE_i : forall P Q:set -> prop, (exists x, P x /\ Q x) -> forall r:prop, (forall x, P x -> Q x -> r) -> r.
admit.
Qed.

Theorem exandE_ii : forall P Q:(set -> set) -> prop, (exists x:set -> set, P x /\ Q x) -> forall p:prop, (forall x:set -> set, P x -> Q x -> p) -> p.
admit.
Qed.

Theorem exandE_iii : forall P Q:(set -> set -> set) -> prop, (exists x:set -> set -> set, P x /\ Q x) -> forall p:prop, (forall x:set -> set -> set, P x -> Q x -> p) -> p.
admit.
Qed.

Theorem exandE_iiii : forall P Q:(set -> set -> set -> set) -> prop, (exists x:set -> set -> set -> set, P x /\ Q x) -> forall p:prop, (forall x:set -> set -> set -> set, P x -> Q x -> p) -> p.
admit.
Qed.

Section Descr_ii.
Variable P : (set -> set) -> prop.
(* Parameter Descr_ii "a6e81668bfd1db6e6eb6a13bf66094509af176d9d0daccda274aa6582f6dcd7c" "3bae39e9880bbf5d70538d82bbb05caf44c2c11484d80d06dee0589d6f75178c" *)
Definition Descr_ii : set -> set := fun x:set => Eps_i (fun y => forall h:set -> set, P h -> h x = y).
Hypothesis Pex: exists f:set -> set, P f.
Hypothesis Puniq: forall f g:set -> set, P f -> P g -> f = g.

Theorem Descr_ii_prop : P Descr_ii.
admit.
Qed.

End Descr_ii.
Section Descr_iii.
Variable P : (set -> set -> set) -> prop.
(* Parameter Descr_iii "dc42f3fe5d0c55512ef81fe5d2ad0ff27c1052a6814b1b27f5a5dcb6d86240bf" "ca5fc17a582fdd4350456951ccbb37275637ba6c06694213083ed9434fe3d545" *)
Definition Descr_iii : set -> set -> set := fun x y:set => Eps_i (fun z => forall h:set -> set -> set, P h -> h x y = z).
Hypothesis Pex: exists f:set -> set -> set, P f.
Hypothesis Puniq: forall f g:set -> set -> set, P f -> P g -> f = g.

Theorem Descr_iii_prop : P Descr_iii.
admit.
Qed.

End Descr_iii.
Section Descr_Vo1.
Variable P : Vo 1 -> prop.
(* Parameter Descr_Vo1 "322bf09a1711d51a4512e112e1767cb2616a7708dc89d7312c8064cfee6e3315" "615c0ac7fca2b62596ed34285f29a77b39225d1deed75d43b7ae87c33ba37083" *)
Definition Descr_Vo1 : Vo 1 := fun x:set => forall h:set -> prop, P h -> h x.
Hypothesis Pex: exists f:Vo 1, P f.
Hypothesis Puniq: forall f g:Vo 1, P f -> P g -> f = g.

Theorem Descr_Vo1_prop : P Descr_Vo1.
admit.
Qed.

End Descr_Vo1.
Section If_ii.
Variable p:prop.
Variable f g:set -> set.
(* Parameter If_ii "e76df3235104afd8b513a92c00d3cc56d71dd961510bf955a508d9c2713c3f29" "17057f3db7be61b4e6bd237e7b37125096af29c45cb784bb9cc29b1d52333779" *)
Definition If_ii : set -> set := fun x => if p then f x else g x.

Theorem If_ii_1 : p -> If_ii = f.
admit.
Qed.

Theorem If_ii_0 : ~p -> If_ii = g.
admit.
Qed.

End If_ii.
Section If_iii.
Variable p:prop.
Variable f g:set -> set -> set.
(* Parameter If_iii "53034f33cbed012c3c6db42812d3964f65a258627a765f5bede719198af1d1ca" "3314762dce5a2e94b7e9e468173b047dd4a9fac6ee2c5f553c6ea15e9c8b7542" *)
Definition If_iii : set -> set -> set := fun x y => if p then f x y else g x y.

Theorem If_iii_1 : p -> If_iii = f.
admit.
Qed.

Theorem If_iii_0 : ~p -> If_iii = g.
admit.
Qed.

End If_iii.
Section EpsilonRec_i.
Variable F:set -> (set -> set) -> set.
Definition In_rec_i_G : set -> set -> prop :=
fun X Y =>
forall R:set->set->prop,
(forall X:set, forall f:set->set, (forall x :e X, R x (f x)) -> R X (F X f)) ->
R X Y.
(* Parameter In_rec_i "f97da687c51f5a332ff57562bd465232bc70c9165b0afe0a54e6440fc4962a9f" "fac413e747a57408ad38b3855d3cde8673f86206e95ccdadff2b5babaf0c219e" *)
Definition In_rec_i : set -> set := fun X => Eps_i (In_rec_i_G X).

Theorem In_rec_i_G_c : forall X:set, forall f:set->set, (forall x :e X, In_rec_i_G x (f x)) -> In_rec_i_G X (F X f).
admit.
Qed.

Theorem In_rec_i_G_inv : forall X:set, forall Y:set, In_rec_i_G X Y -> exists f:set->set, (forall x :e X, In_rec_i_G x (f x)) /\ Y = F X f.
admit.
Qed.

Hypothesis Fr:forall X:set, forall g h:set -> set, (forall x :e X, g x = h x) -> F X g = F X h.

Theorem In_rec_i_G_f : forall X:set, forall Y Z:set, In_rec_i_G X Y -> In_rec_i_G X Z -> Y = Z.
admit.
Qed.

Theorem In_rec_i_G_In_rec_i : forall X:set, In_rec_i_G X (In_rec_i X).
admit.
Qed.

Theorem In_rec_i_G_In_rec_i_d : forall X:set, In_rec_i_G X (F X In_rec_i).
admit.
Qed.

Theorem In_rec_i_eq : forall X:set, In_rec_i X = F X In_rec_i.
admit.
Qed.

End EpsilonRec_i.
Section EpsilonRec_ii.
Variable F:set -> (set -> (set -> set)) -> (set -> set).
Definition In_rec_G_ii : set -> (set -> set) -> prop :=
fun X Y =>
forall R:set->(set -> set)->prop,
(forall X:set, forall f:set->(set -> set), (forall x :e X, R x (f x)) -> R X (F X f)) ->
R X Y.
(* Parameter In_rec_ii "4d137cad40b107eb0fc2c707372525f1279575e6cadb4ebc129108161af3cedb" "f3c9abbc5074c0d68e744893a170de526469426a5e95400ae7fc81f74f412f7e" *)
Definition In_rec_ii : set -> (set -> set) := fun X => Descr_ii (In_rec_G_ii X).

Theorem In_rec_G_ii_c : forall X:set, forall f:set->(set -> set), (forall x :e X, In_rec_G_ii x (f x)) -> In_rec_G_ii X (F X f).
admit.
Qed.

Theorem In_rec_G_ii_inv : forall X:set, forall Y:(set -> set), In_rec_G_ii X Y -> exists f:set->(set -> set), (forall x :e X, In_rec_G_ii x (f x)) /\ Y = F X f.
admit.
Qed.

Hypothesis Fr:forall X:set, forall g h:set -> (set -> set), (forall x :e X, g x = h x) -> F X g = F X h.

Theorem In_rec_G_ii_f : forall X:set, forall Y Z:(set -> set), In_rec_G_ii X Y -> In_rec_G_ii X Z -> Y = Z.
admit.
Qed.

Theorem In_rec_G_ii_In_rec_ii : forall X:set, In_rec_G_ii X (In_rec_ii X).
admit.
Qed.

Theorem In_rec_G_ii_In_rec_ii_d : forall X:set, In_rec_G_ii X (F X In_rec_ii).
admit.
Qed.

Theorem In_rec_ii_eq : forall X:set, In_rec_ii X = F X In_rec_ii.
admit.
Qed.

End EpsilonRec_ii.
Section EpsilonRec_iii.
Variable F:set -> (set -> (set -> set -> set)) -> (set -> set -> set).
Definition In_rec_G_iii : set -> (set -> set -> set) -> prop :=
fun X Y =>
forall R:set->(set -> set -> set)->prop,
(forall X:set, forall f:set->(set -> set -> set), (forall x :e X, R x (f x)) -> R X (F X f)) ->
R X Y.
(* Parameter In_rec_iii "222f1b8dcfb0d2e33cc4b232e87cbcdfe5c4a2bdc5326011eb70c6c9aeefa556" "9b3a85b85e8269209d0ca8bf18ef658e56f967161bf5b7da5e193d24d345dd06" *)
Definition In_rec_iii : set -> (set -> set -> set) := fun X => Descr_iii (In_rec_G_iii X).

Theorem In_rec_G_iii_c : forall X:set, forall f:set->(set -> set -> set), (forall x :e X, In_rec_G_iii x (f x)) -> In_rec_G_iii X (F X f).
admit.
Qed.

Theorem In_rec_G_iii_inv : forall X:set, forall Y:(set -> set -> set), In_rec_G_iii X Y -> exists f:set->(set -> set -> set), (forall x :e X, In_rec_G_iii x (f x)) /\ Y = F X f.
admit.
Qed.

Hypothesis Fr:forall X:set, forall g h:set -> (set -> set -> set), (forall x :e X, g x = h x) -> F X g = F X h.

Theorem In_rec_G_iii_f : forall X:set, forall Y Z:(set -> set -> set), In_rec_G_iii X Y -> In_rec_G_iii X Z -> Y = Z.
admit.
Qed.

Theorem In_rec_G_iii_In_rec_iii : forall X:set, In_rec_G_iii X (In_rec_iii X).
admit.
Qed.

Theorem In_rec_G_iii_In_rec_iii_d : forall X:set, In_rec_G_iii X (F X In_rec_iii).
admit.
Qed.

Theorem In_rec_iii_eq : forall X:set, In_rec_iii X = F X In_rec_iii.
admit.
Qed.

End EpsilonRec_iii.
Section NatRec.
Variable z:set.
Variable f:set->set->set.
Let F : set->(set->set)->set := fun n g => if Union n :e n then f (Union n) (g (Union n)) else z.
Definition nat_primrec : set->set := In_rec_i F.

Theorem nat_primrec_r : forall X:set, forall g h:set -> set, (forall x :e X, g x = h x) -> F X g = F X h.
admit.
Qed.

Theorem nat_primrec_0 : nat_primrec 0 = z.
admit.
Qed.

Theorem nat_primrec_S : forall n:set, nat_p n -> nat_primrec (ordsucc n) = f n (nat_primrec n).
admit.
Qed.

End NatRec.

Section NatAdd.

Definition add_nat : set->set->set := fun n m:set => nat_primrec n (fun _ r => ordsucc r) m.
Infix + 360 right := add_nat.

Theorem add_nat_0R : forall n:set, n + 0 = n.
admit.
Qed.

Theorem add_nat_SR : forall n m:set, nat_p m -> n + ordsucc m = ordsucc (n + m).
admit.
Qed.

Theorem add_nat_p : forall n:set, nat_p n -> forall m:set, nat_p m -> nat_p (n + m).
admit.
Qed.

Theorem add_nat_1_1_2 : 1 + 1 = 2.
admit.
Qed.

Theorem add_nat_asso : forall n:set, nat_p n -> forall m:set, nat_p m -> forall k:set, nat_p k -> (n+m)+k = n+(m+k).
admit.
Qed.

Theorem add_nat_0L : forall m:set, nat_p m -> 0+m = m.
admit.
Qed.

Theorem add_nat_SL : forall n:set, nat_p n -> forall m:set, nat_p m -> ordsucc n + m = ordsucc (n+m).
admit.
Qed.

Theorem add_nat_com : forall n:set, nat_p n -> forall m:set, nat_p m -> n + m = m + n.
admit.
Qed.

Theorem add_nat_In_R: forall m, nat_p m -> forall k :e m, forall n, nat_p n -> k + n :e m + n.
admit.
Qed.

Theorem add_nat_In_L: forall n, nat_p n -> forall m, nat_p m -> forall k :e m, n + k :e n + m.
admit.
Qed.

Theorem add_nat_Subq_R: forall k, nat_p k -> forall m, nat_p m -> k c= m -> forall n, nat_p n -> k + n c= m + n.
admit.
Qed.

Theorem add_nat_Subq_L: forall n, nat_p n -> forall k, nat_p k -> forall m, nat_p m -> k c= m -> n + k c= n + m.
admit.
Qed.

Theorem add_nat_Subq_R' : forall m, nat_p m -> forall n, nat_p n -> m c= m + n.
admit.
Qed.

Theorem nat_Subq_add_ex: forall n, nat_p n -> forall m, nat_p m -> n c= m -> exists k, nat_p k /\ m = k + n.
admit.
Qed.

Theorem add_nat_cancel_R : forall k, nat_p k -> forall m, nat_p m -> forall n, nat_p n -> k + n = m + n -> k = m.
admit.
Qed.

End NatAdd.

Section NatMul.

Infix + 360 right := add_nat.

Definition mul_nat : set->set->set := fun n m:set => nat_primrec 0 (fun _ r => n + r) m.
Infix * 355 right := mul_nat.

Theorem mul_nat_0R : forall n:set, n * 0 = 0.
admit.
Qed.

Theorem mul_nat_SR : forall n m, nat_p m -> n * ordsucc m = n + n * m.
admit.
Qed.

Theorem mul_nat_1R: forall n, n * 1 = n.
admit.
Qed.

Theorem mul_nat_p : forall n:set, nat_p n -> forall m:set, nat_p m -> nat_p (n * m).
admit.
Qed.

Theorem mul_nat_0L : forall m:set, nat_p m -> 0 * m = 0.
admit.
Qed.

Theorem mul_nat_SL : forall n:set, nat_p n -> forall m:set, nat_p m -> ordsucc n * m = n * m + m.
admit.
Qed.

Theorem mul_nat_com : forall n:set, nat_p n -> forall m:set, nat_p m -> n * m = m * n.
admit.
Qed.

Theorem mul_add_nat_distrL : forall n:set, nat_p n -> forall m:set, nat_p m -> forall k:set, nat_p k -> n * (m + k) = n * m + n * k.
admit.
Qed.

Theorem mul_nat_asso : forall n:set, nat_p n -> forall m:set, nat_p m -> forall k:set, nat_p k -> (n*m)*k = n*(m*k).
admit.
Qed.

Theorem mul_nat_Subq_R : forall m n, nat_p m -> nat_p n -> m c= n -> forall k, nat_p k -> m * k c= n * k.
admit.
Qed.

Theorem mul_nat_Subq_L : forall m n, nat_p m -> nat_p n -> m c= n -> forall k, nat_p k -> k * m c= k * n.
admit.
Qed.

Theorem mul_nat_0_or_Subq: forall m, nat_p m -> forall n, nat_p n -> n = 0 \/ m c= m * n.
admit.
Qed.

(** If m times n = 0 for naturals m and n, then one must be 0. **)
Theorem mul_nat_0_inv : forall m, nat_p m -> forall n, nat_p n -> m * n = 0 -> m = 0 \/ n = 0.
admit.
Qed.

Theorem mul_nat_0m_1n_In: forall m, nat_p m -> forall n, nat_p n -> 0 :e m -> 1 :e n -> m :e m * n.
admit.
Qed.

Theorem nat_le1_cases: forall m, nat_p m -> m c= 1 -> m = 0 \/ m = 1.
admit.
Qed.

Definition Pi_nat : (set -> set) -> set -> set := fun f n =>
  nat_primrec 1 (fun i r => r * f i) n.

Theorem Pi_nat_0: forall f:set -> set, Pi_nat f 0 = 1.
admit.
Qed.

Theorem Pi_nat_S: forall f:set -> set, forall n, nat_p n -> Pi_nat f (ordsucc n) = Pi_nat f n * f n.
admit.
Qed.

Theorem Pi_nat_p: forall f:set -> set,
 forall n, nat_p n ->
     (forall i :e n, nat_p (f i))
  -> nat_p (Pi_nat f n).
admit.
Qed.

Theorem Pi_nat_0_inv: forall f:set->set,
  forall n, nat_p n ->
      (forall i :e n, nat_p (f i))
   -> Pi_nat f n = 0
   -> (exists i :e n, f i = 0).
admit.
Qed.

Definition exp_nat : set->set->set := fun n m:set => nat_primrec 1 (fun _ r => n * r) m.

Infix ^ 342 right := exp_nat.

Theorem exp_nat_0 : forall n, n ^ 0 = 1.
admit.
Qed.

Theorem exp_nat_S : forall n m, nat_p m -> n ^ (ordsucc m) = n * n ^ m.
admit.
Qed.

Theorem exp_nat_p : forall n, nat_p n -> forall m, nat_p m -> nat_p (n ^ m).
admit.
Qed.

Theorem exp_nat_1 : forall n, n ^ 1 = n.
admit.
Qed.

End NatMul.

Section form100_52.

Infix + 360 right := add_nat.
Infix * 355 right := mul_nat.
Infix ^ 342 right := exp_nat.

Theorem Subq_Sing0_1 : {0} c= 1.
admit.
Qed.

Theorem Subq_1_Sing0 : 1 c= {0}.
admit.
Qed.

Theorem eq_1_Sing0 : 1 = {0}.
admit.
Qed.

Theorem Power_0_Sing_0 : Power 0 = {0}.
admit.
Qed.

Theorem equip_finite_Power: forall n, nat_p n -> forall X,
  equip X n -> equip (Power X) (2 ^ n).
admit.
Qed.

End form100_52.

Theorem ZF_closed_E : forall U, ZF_closed U ->
 forall p:prop,
 (Union_closed U ->
  Power_closed U ->
  Repl_closed U -> p)
 -> p.
admit.
Qed.

Theorem ZF_Union_closed : forall U, ZF_closed U ->
  forall X :e U, Union X :e U.
admit.
Qed.

Theorem ZF_Power_closed : forall U, ZF_closed U ->
  forall X :e U, Power X :e U.
admit.
Qed.

Theorem ZF_Repl_closed : forall U, ZF_closed U ->
  forall X :e U, forall F:set->set, (forall x :e X, F x :e U) -> {F x|x:eX} :e U.
admit.
Qed.

Theorem ZF_UPair_closed : forall U, ZF_closed U ->
  forall x y :e U, {x,y} :e U.
admit.
Qed.

Theorem ZF_Sing_closed : forall U, ZF_closed U ->
  forall x :e U, {x} :e U.
admit.
Qed.

Theorem ZF_binunion_closed : forall U, ZF_closed U ->
  forall X Y :e U, (X :\/: Y) :e U.
admit.
Qed.

Theorem ZF_ordsucc_closed : forall U, ZF_closed U ->
  forall x :e U, ordsucc x :e U.
admit.
Qed.

Theorem nat_p_UnivOf_Empty : forall n:set, nat_p n -> n :e UnivOf Empty.
admit.
Qed.

(* Unicode omega "3c9" *)
(* Parameter omega "39cdf86d83c7136517f803d29d0c748ea45a274ccbf9b8488f9cda3e21f4b47c" "6fc30ac8f2153537e397b9ff2d9c981f80c151a73f96cf9d56ae2ee27dfd1eb2" *)
Definition omega : set := {n :e UnivOf Empty|nat_p n}.

Theorem omega_nat_p : forall n :e omega, nat_p n.
admit.
Qed.

Theorem nat_p_omega : forall n:set, nat_p n -> n :e omega.
admit.
Qed.

Theorem omega_ordsucc : forall n :e omega, ordsucc n :e omega.
admit.
Qed.

Theorem form100_22_v2: forall f:set -> set, ~inj (Power omega) omega f.
admit.
Qed.

Theorem form100_22_v3: forall g:set -> set, ~surj omega (Power omega) g.
admit.
Qed.

Theorem form100_22_v1: ~equip omega (Power omega).
admit.
Qed.

Theorem omega_TransSet : TransSet omega.
admit.
Qed.

Theorem omega_ordinal : ordinal omega.
admit.
Qed.

Theorem ordsucc_omega_ordinal: ordinal (ordsucc omega).
admit.
Qed.

Definition finite : set -> prop := fun X => exists n :e omega, equip X n.

Theorem nat_finite: forall n, nat_p n -> finite n.
admit.
Qed.

Theorem finite_ind : forall p:set -> prop,
    p Empty
 -> (forall X y, finite X -> y /:e X -> p X -> p (X :\/: {y}))
 -> forall X, finite X -> p X.
admit.
Qed.

Theorem finite_Empty: finite 0.
admit.
Qed.

Theorem Sing_finite: forall x, finite {x}.
admit.
Qed.

Theorem adjoin_finite: forall X y, finite X -> finite (X :\/: {y}).
admit.
Qed.

Theorem binunion_finite: forall X, finite X -> forall Y, finite Y -> finite (X :\/: Y).
admit.
Qed.

Theorem famunion_nat_finite : forall X:set -> set, forall n, nat_p n -> (forall i :e n, finite (X i)) -> finite (\/_ i :e n, X i).
admit.
Qed.

Theorem Subq_finite : forall X, finite X -> forall Y, Y c= X -> finite Y.
admit.
Qed.

Definition infinite : set -> prop := fun A => ~finite A.

Section InfinitePrimes.

Infix + 360 right := add_nat.
Infix * 355 right := mul_nat.

Definition divides_nat : set -> set -> prop :=
  fun m n => m :e omega /\ n :e omega /\ exists k :e omega, m * k = n.

Theorem divides_nat_ref: forall n, nat_p n -> divides_nat n n.
admit.
Qed.

Theorem divides_nat_tra: forall k m n, divides_nat k m -> divides_nat m n -> divides_nat k n.
admit.
Qed.

Definition prime_nat : set -> prop :=
  fun n => n :e omega /\ 1 :e n /\ forall k :e omega, divides_nat k n -> k = 1 \/ k = n.

Theorem divides_nat_mulR: forall m n :e omega, divides_nat m (m * n).
admit.
Qed.

Theorem divides_nat_mulL: forall m n :e omega, divides_nat n (m * n).
admit.
Qed.

Theorem Pi_nat_divides: forall f:set->set,
  forall n, nat_p n ->
      (forall i :e n, nat_p (f i))
   -> (forall i :e n, divides_nat (f i) (Pi_nat f n)).
admit.
Qed.

Definition composite_nat : set -> prop :=
  fun n => n :e omega /\ exists k m :e omega, 1 :e k /\ 1 :e m /\ k * m = n.

Theorem prime_nat_or_composite_nat: forall n :e omega, 1 :e n -> prime_nat n \/ composite_nat n.
admit.
Qed.

Theorem prime_nat_divisor_ex: forall n, nat_p n -> 1 :e n -> exists p, prime_nat p /\ divides_nat p n.
admit.
Qed.

Theorem nat_1In_not_divides_ordsucc: forall m n, 1 :e m -> divides_nat m n -> ~divides_nat m (ordsucc n).
admit.
Qed.

Definition primes : set := {n :e omega|prime_nat n}.

Theorem form100_11_infinite_primes: infinite primes.
admit.
Qed.

End InfinitePrimes.

Section InfiniteRamsey.

Infix + 360 right := add_nat.

Theorem atleastp_omega_infinite: forall X, atleastp omega X -> infinite X.
admit.
Qed.

Theorem infinite_remove1: forall X, infinite X -> forall y, infinite (X :\: {y}).
admit.
Qed.

Theorem infinite_Finite_Subq_ex: forall X, infinite X ->
  forall n, nat_p n -> exists Y c= X, equip Y n.
admit.
Qed.

Theorem infiniteRamsey_lem: forall X, forall f g f':set -> set,
    infinite X
 -> (forall Z c= X, infinite Z -> f Z c= Z /\ infinite (f Z))
 -> (forall Z c= X, infinite Z -> g Z :e Z /\ g Z /:e f Z)
 -> f' 0 = f X
 -> (forall m, nat_p m -> f' (ordsucc m) = f (f' m))
 -> (forall m, nat_p m -> f' m c= X /\ infinite (f' m))
 /\ (forall m m' :e omega, m c= m' -> f' m' c= f' m)
 /\ (forall m m' :e omega, g (f' m) = g (f' m') -> m = m').
admit.
Qed.

Theorem infiniteRamsey: forall c, nat_p c -> forall n, nat_p n ->
  forall X, infinite X -> forall C:set -> set,
    (forall Y c= X, equip Y n -> C Y :e c)
 -> exists H c= X, exists i :e c, infinite H /\ forall Y c= H, equip Y n -> C Y = i.
admit.
Qed.

End InfiniteRamsey.

(*** Injection of set into itself that will correspond to x |-> (1,x) after pairing is defined. ***)
Definition Inj1 : set -> set := In_rec_i (fun X f => {0} :\/: {f x|x :e X}).

Theorem Inj1_eq : forall X:set, Inj1 X = {0} :\/: {Inj1 x|x :e X}.
admit.
Qed.

Theorem Inj1I1 : forall X:set, 0 :e Inj1 X.
admit.
Qed.

Theorem Inj1I2 : forall X x:set, x :e X -> Inj1 x :e Inj1 X.
admit.
Qed.

Theorem Inj1E : forall X y:set, y :e Inj1 X -> y = 0 \/ exists x :e X, y = Inj1 x.
admit.
Qed.

Theorem Inj1NE1 : forall x:set, Inj1 x <> 0.
admit.
Qed.

Theorem Inj1NE2 : forall x:set, Inj1 x /:e {0}.
admit.
Qed.

(*** Injection of set into itself that will correspond to x |-> (0,x) after pairing is defined. ***)
Definition Inj0 : set -> set := fun X => {Inj1 x|x :e X}.

Theorem Inj0I : forall X x:set, x :e X -> Inj1 x :e Inj0 X.
admit.
Qed.

Theorem Inj0E : forall X y:set, y :e Inj0 X -> exists x:set, x :e X /\ y = Inj1 x.
admit.
Qed.

(*** Unj : Left inverse of Inj1 and Inj0 ***)
Definition Unj : set -> set := In_rec_i (fun X f => {f x|x :e X :\: {0}}).

Theorem Unj_eq : forall X:set, Unj X = {Unj x|x :e X :\: {0}}.
admit.
Qed.

Theorem Unj_Inj1_eq : forall X:set, Unj (Inj1 X) = X.
admit.
Qed.

Theorem Inj1_inj : forall X Y:set, Inj1 X = Inj1 Y -> X = Y.
admit.
Qed.

Theorem Unj_Inj0_eq : forall X:set, Unj (Inj0 X) = X.
admit.
Qed.

Theorem Inj0_inj : forall X Y:set, Inj0 X = Inj0 Y -> X = Y.
admit.
Qed.

Theorem Inj0_0 : Inj0 0 = 0.
admit.
Qed.

Theorem Inj0_Inj1_neq : forall X Y:set, Inj0 X <> Inj1 Y.
admit.
Qed.

(*** setsum ***)
Definition setsum : set -> set -> set := fun X Y => {Inj0 x|x :e X} :\/: {Inj1 y|y :e Y}.
(* Unicode :+: "002b" *)
Infix :+: 450 left := setsum.

Theorem Inj0_setsum : forall X Y x:set, x :e X -> Inj0 x :e X :+: Y.
admit.
Qed.

Theorem Inj1_setsum : forall X Y y:set, y :e Y -> Inj1 y :e X :+: Y.
admit.
Qed.

Theorem setsum_Inj_inv : forall X Y z:set, z :e X :+: Y -> (exists x :e X, z = Inj0 x) \/ (exists y :e Y, z = Inj1 y).
admit.
Qed.

Theorem Inj0_setsum_0L : forall X:set, 0 :+: X = Inj0 X.
admit.
Qed.

Theorem Inj1_setsum_1L : forall X:set, 1 :+: X = Inj1 X.
admit.
Qed.

Section pair_setsum.
Let pair := setsum.
Definition proj0 : set -> set := fun Z => {Unj z|z :e Z, exists x:set, Inj0 x = z}.
Definition proj1 : set -> set := fun Z => {Unj z|z :e Z, exists y:set, Inj1 y = z}.

Theorem Inj0_pair_0_eq : Inj0 = pair 0.
admit.
Qed.

Theorem Inj1_pair_1_eq : Inj1 = pair 1.
admit.
Qed.

Theorem pairI0 : forall X Y x, x :e X -> pair 0 x :e pair X Y.
admit.
Qed.

Theorem pairI1 : forall X Y y, y :e Y -> pair 1 y :e pair X Y.
admit.
Qed.

Theorem pairE : forall X Y z, z :e pair X Y -> (exists x :e X, z = pair 0 x) \/ (exists y :e Y, z = pair 1 y).
admit.
Qed.

Theorem pairE0 : forall X Y x, pair 0 x :e pair X Y -> x :e X.
admit.
Qed.

Theorem pairE1 : forall X Y y, pair 1 y :e pair X Y -> y :e Y.
admit.
Qed.

Theorem proj0I : forall w u:set, pair 0 u :e w -> u :e proj0 w.
admit.
Qed.

Theorem proj0E : forall w u:set, u :e proj0 w -> pair 0 u :e w.
admit.
Qed.

Theorem proj1I : forall w u:set, pair 1 u :e w -> u :e proj1 w.
admit.
Qed.

Theorem proj1E : forall w u:set, u :e proj1 w -> pair 1 u :e w.
admit.
Qed.

Theorem proj0_pair_eq : forall X Y:set, proj0 (pair X Y) = X.
admit.
Qed.

Theorem proj1_pair_eq : forall X Y:set, proj1 (pair X Y) = Y.
admit.
Qed.

Opaque add_nat mul_nat omega ordsucc setminus binintersect ReplSep Sep famunion binunion Sing UPair exactly1of2 If_i If_ii If_iii Descr_Vo1 Descr_iii Descr_ii inv In_rec_i In_rec_ii In_rec_iii.

(*** Sigma X Y = {(x,y) | x in X, y in Y x} ***)
Definition Sigma : set -> (set -> set) -> set :=
fun X Y => \/_ x :e X, {pair x y|y :e Y x}.
(* Unicode Sigma_ "2211" *)
Binder+ Sigma_ , := Sigma.

Theorem Sigma_eta_proj0_proj1 : forall X:set, forall Y:set -> set, forall z :e (Sigma_ x :e X, Y x), pair (proj0 z) (proj1 z) = z /\ proj0 z :e X /\ proj1 z :e Y (proj0 z).
admit.
Qed.

Theorem proj0_Sigma : forall X:set, forall Y:set -> set, forall z:set, z :e (Sigma_ x :e X, Y x) -> proj0 z :e X.
admit.
Qed.

Theorem proj1_Sigma : forall X:set, forall Y:set -> set, forall z:set, z :e (Sigma_ x :e X, Y x) -> proj1 z :e Y (proj0 z).
admit.
Qed.

Theorem pair_Sigma : forall X:set, forall Y:set -> set, forall x :e X, forall y :e Y x, pair x y :e Sigma_ x :e X, Y x.
admit.
Qed.

Theorem pair_Sigma_E1 : forall X:set, forall Y:set->set, forall x y:set, pair x y :e (Sigma_ x :e X, Y x) -> y :e Y x.
admit.
Qed.

Theorem Sigma_E : forall X:set, forall Y:set->set, forall z:set, z :e (Sigma_ x :e X, Y x) -> exists x :e X, exists y :e Y x, z = pair x y.
admit.
Qed.

Definition setprod : set->set->set := fun X Y:set => Sigma_ x :e X, Y.
(* Unicode :*: "2a2f" *)
Infix :*: 440 left := setprod.
(*** lam X F = {(x,y) | x :e X, y :e F x} = \/_{x :e X} {(x,y) | y :e (F x)} = Sigma X F ***)
Let lam : set -> (set -> set) -> set := Sigma.
(***  ap f x = {proj1 z | z :e f,  exists y, z = pair x y}} ***)
Definition ap : set -> set -> set := fun f x => {proj1 z|z :e f, exists y:set, z = pair x y}.
Notation SetImplicitOp ap.
Notation SetLam Sigma.

Theorem lamI : forall X:set, forall F:set->set, forall x :e X, forall y :e F x, pair x y :e fun x :e X => F x.
admit.
Qed.

Theorem lamE : forall X:set, forall F:set->set, forall z:set, z :e (fun x :e X => F x) -> exists x :e X, exists y :e F x, z = pair x y.
admit.
Qed.

Theorem apI : forall f x y, pair x y :e f -> y :e f x.
admit.
Qed.

Theorem apE : forall f x y, y :e f x -> pair x y :e f.
admit.
Qed.

Theorem beta : forall X:set, forall F:set -> set, forall x:set, x :e X -> (fun x :e X => F x) x = F x.
admit.
Qed.

Theorem proj0_ap_0 : forall u, proj0 u = u 0.
admit.
Qed.

Theorem proj1_ap_1 : forall u, proj1 u = u 1.
admit.
Qed.

Theorem pair_ap_0 : forall x y:set, (pair x y) 0 = x.
admit.
Qed.

Theorem pair_ap_1 : forall x y:set, (pair x y) 1 = y.
admit.
Qed.

Theorem ap0_Sigma : forall X:set, forall Y:set -> set, forall z:set, z :e (Sigma_ x :e X, Y x) -> (z 0) :e X.
admit.
Qed.

Theorem ap1_Sigma : forall X:set, forall Y:set -> set, forall z:set, z :e (Sigma_ x :e X, Y x) -> (z 1) :e (Y (z 0)).
admit.
Qed.

Definition pair_p:set->prop
:= fun u:set => pair (u 0) (u 1) = u.

Theorem pair_p_I : forall x y, pair_p (pair x y).
admit.
Qed.

Theorem Subq_2_UPair01 : 2 c= {0,1}.
admit.
Qed.

Theorem tuple_pair : forall x y:set, pair x y = (x,y).
admit.
Qed.

Definition Pi : set -> (set -> set) -> set := fun X Y => {f :e Power (Sigma_ x :e X, Union (Y x)) | forall x :e X, f x :e Y x}.
(* Unicode Pi_ "220f" *)
Binder+ Pi_ , := Pi.

Theorem PiI : forall X:set, forall Y:set->set, forall f:set,
    (forall u :e f, pair_p u /\ u 0 :e X) -> (forall x :e X, f x :e Y x) -> f :e Pi_ x :e X, Y x.
admit.
Qed.

Theorem lam_Pi : forall X:set, forall Y:set -> set, forall F:set -> set,
 (forall x :e X, F x :e Y x) -> (fun x :e X => F x) :e (Pi_ x :e X, Y x).
admit.
Qed.

Theorem ap_Pi : forall X:set, forall Y:set -> set, forall f:set, forall x:set, f :e (Pi_ x :e X, Y x) -> x :e X -> f x :e Y x.
admit.
Qed.

Definition setexp : set->set->set := fun X Y:set => Pi_ y :e Y, X.
(* Superscript :^: *)
Infix :^: 430 left := setexp.

Theorem pair_tuple_fun : pair = (fun x y => (x,y)).
admit.
Qed.

Section Tuples.
Variable x0 x1: set.

Theorem tuple_2_0_eq: (x0,x1) 0 = x0.
admit.
Qed.

Theorem tuple_2_1_eq: (x0,x1) 1 = x1.
admit.
Qed.

End Tuples.

Theorem ReplEq_setprod_ext : forall X Y, forall F G:set -> set -> set, (forall x :e X, forall y :e Y, F x y = G x y) -> {F (w 0) (w 1)|w :e X :*: Y} = {G (w 0) (w 1)|w :e X :*: Y}.
admit.
Qed.

Theorem lamI2 : forall X, forall F:set->set, forall x :e X, forall y :e F x, (x,y) :e fun x :e X => F x.
admit.
Qed.

Theorem tuple_2_Sigma : forall X:set, forall Y:set -> set, forall x :e X, forall y :e Y x, (x,y) :e Sigma_ x :e X, Y x.
admit.
Qed.

Theorem tuple_2_setprod : forall X:set, forall Y:set, forall x :e X, forall y :e Y, (x,y) :e X :*: Y.
admit.
Qed.

End pair_setsum.
(* Unicode Sigma_ "2211" *)
Binder+ Sigma_ , := Sigma.
(* Unicode :*: "2a2f" *)
Infix :*: 440 left := setprod.
(* Unicode Pi_ "220f" *)
Binder+ Pi_ , := Pi.
(* Superscript :^: *)
Infix :^: 430 left := setexp.
(* Parameter DescrR_i_io_1 "1f005fdad5c6f98763a15a5e5539088f5d43b7d1be866b0b204fda1ce9ed9248" "1d3fd4a14ef05bd43f5c147d7966cf05fd2fed808eea94f56380454b9a6044b2" *)
Definition DescrR_i_io_1 : (set->(set->prop)->prop) -> set := fun R => Eps_i (fun x => (exists y:set -> prop, R x y) /\ (forall y z:set -> prop, R x y -> R x z -> y = z)).
(* Parameter DescrR_i_io_2 "28d8599686476258c12dcc5fc5f5974335febd7d5259e1a8e5918b7f9b91ca03" "768eb2ad186988375e6055394e36e90c81323954b8a44eb08816fb7a84db2272" *)
Definition DescrR_i_io_2 : (set->(set->prop)->prop) -> set->prop := fun R => Descr_Vo1 (fun y => R (DescrR_i_io_1 R) y).

Theorem DescrR_i_io_12 : forall R:set->(set->prop)->prop, (exists x, (exists y:set->prop, R x y) /\ (forall y z:set -> prop, R x y -> R x z -> y = z)) -> R (DescrR_i_io_1 R) (DescrR_i_io_2 R).
admit.
Qed.

(** Conway describes this way of formalizing in ZF in an appendix to Part Zero of his book,
    but rejects formalization in favor of "Mathematician's Liberation."
 **)
Definition PNoEq_ : set -> (set -> prop) -> (set -> prop) -> prop
 := fun alpha p q => forall beta :e alpha, p beta <-> q beta.

Theorem PNoEq_ref_ : forall alpha, forall p:set -> prop, PNoEq_ alpha p p.
admit.
Qed.

Theorem PNoEq_sym_ : forall alpha, forall p q:set -> prop, PNoEq_ alpha p q -> PNoEq_ alpha q p.
admit.
Qed.

Theorem PNoEq_tra_ : forall alpha, forall p q r:set -> prop, PNoEq_ alpha p q -> PNoEq_ alpha q r -> PNoEq_ alpha p r.
admit.
Qed.

Theorem PNoEq_antimon_ : forall p q:set -> prop, forall alpha, ordinal alpha -> forall beta :e alpha, PNoEq_ alpha p q -> PNoEq_ beta p q.
admit.
Qed.

Definition PNoLt_ : set -> (set -> prop) -> (set -> prop) -> prop
 := fun alpha p q => exists beta :e alpha, PNoEq_ beta p q /\ ~p beta /\ q beta.

Theorem PNoLt_E_ : forall alpha, forall p q:set -> prop, PNoLt_ alpha p q ->
  forall R:prop, (forall beta, beta :e alpha -> PNoEq_ beta p q -> ~p beta -> q beta -> R) -> R.
admit.
Qed.

Theorem PNoLt_irref_ : forall alpha, forall p:set -> prop, ~PNoLt_ alpha p p.
admit.
Qed.

Theorem PNoLt_mon_ : forall p q:set -> prop, forall alpha, ordinal alpha -> forall beta :e alpha, PNoLt_ beta p q -> PNoLt_ alpha p q.
admit.
Qed.

Theorem PNoLt_trichotomy_or_ : forall p q:set -> prop, forall alpha, ordinal alpha
  -> PNoLt_ alpha p q \/ PNoEq_ alpha p q \/ PNoLt_ alpha q p.
admit.
Qed.

(* Parameter PNoLt "2336eb45d48549dd8a6a128edc17a8761fd9043c180691483bcf16e1acc9f00a" "8f57a05ce4764eff8bc94b278352b6755f1a46566cd7220a5488a4a595a47189" *)
Definition PNoLt : set -> (set -> prop) -> set -> (set -> prop) -> prop
 := fun alpha p beta q =>
        PNoLt_ (alpha :/\: beta) p q
     \/ alpha :e beta /\ PNoEq_ alpha p q /\ q alpha
     \/ beta :e alpha /\ PNoEq_ beta p q /\ ~p beta.

Theorem PNoLtI1 : forall alpha beta, forall p q:set -> prop,
  PNoLt_ (alpha :/\: beta) p q -> PNoLt alpha p beta q.
admit.
Qed.

Theorem PNoLtI2 : forall alpha beta, forall p q:set -> prop,
  alpha :e beta -> PNoEq_ alpha p q -> q alpha -> PNoLt alpha p beta q.
admit.
Qed.

Theorem PNoLtI3 : forall alpha beta, forall p q:set -> prop,
  beta :e alpha -> PNoEq_ beta p q -> ~p beta -> PNoLt alpha p beta q.
admit.
Qed.

Theorem PNoLtE : forall alpha beta, forall p q:set -> prop,
  PNoLt alpha p beta q ->
  forall R:prop,
      (PNoLt_ (alpha :/\: beta) p q -> R)
   -> (alpha :e beta -> PNoEq_ alpha p q -> q alpha -> R)
   -> (beta :e alpha -> PNoEq_ beta p q -> ~p beta -> R)
   -> R.
admit.
Qed.

Theorem PNoLt_irref : forall alpha, forall p:set -> prop, ~PNoLt alpha p alpha p.
admit.
Qed.

Theorem PNoLt_trichotomy_or : forall alpha beta, forall p q:set -> prop,
 ordinal alpha -> ordinal beta ->
 PNoLt alpha p beta q \/ alpha = beta /\ PNoEq_ alpha p q \/ PNoLt beta q alpha p.
admit.
Qed.

Theorem PNoLtEq_tra : forall alpha beta, ordinal alpha -> ordinal beta -> forall p q r:set -> prop, PNoLt alpha p beta q -> PNoEq_ beta q r -> PNoLt alpha p beta r.
admit.
Qed.

Theorem PNoEqLt_tra : forall alpha beta, ordinal alpha -> ordinal beta -> forall p q r:set -> prop, PNoEq_ alpha p q -> PNoLt alpha q beta r -> PNoLt alpha p beta r.
admit.
Qed.

Theorem PNoLt_tra : forall alpha beta gamma, ordinal alpha -> ordinal beta -> ordinal gamma -> forall p q r:set -> prop, PNoLt alpha p beta q -> PNoLt beta q gamma r -> PNoLt alpha p gamma r.
admit.
Qed.

Definition PNoLe : set -> (set -> prop) -> set -> (set -> prop) -> prop
   := fun alpha p beta q => PNoLt alpha p beta q \/ alpha = beta /\ PNoEq_ alpha p q.

Theorem PNoLeI1 : forall alpha beta, forall p q:set -> prop,
   PNoLt alpha p beta q -> PNoLe alpha p beta q.
admit.
Qed.

Theorem PNoLeI2 : forall alpha, forall p q:set -> prop,
   PNoEq_ alpha p q -> PNoLe alpha p alpha q.
admit.
Qed.

Theorem PNoLe_ref : forall alpha, forall p:set -> prop, PNoLe alpha p alpha p.
admit.
Qed.

Theorem PNoLe_antisym : forall alpha beta, ordinal alpha -> ordinal beta ->
 forall p q:set -> prop,
 PNoLe alpha p beta q -> PNoLe beta q alpha p -> alpha = beta /\ PNoEq_ alpha p q.
admit.
Qed.

Theorem PNoLtLe_tra : forall alpha beta gamma, ordinal alpha -> ordinal beta -> ordinal gamma -> forall p q r:set -> prop, PNoLt alpha p beta q -> PNoLe beta q gamma r -> PNoLt alpha p gamma r.
admit.
Qed.

Theorem PNoLeLt_tra : forall alpha beta gamma, ordinal alpha -> ordinal beta -> ordinal gamma -> forall p q r:set -> prop, PNoLe alpha p beta q -> PNoLt beta q gamma r -> PNoLt alpha p gamma r.
admit.
Qed.

Theorem PNoEqLe_tra : forall alpha beta, ordinal alpha -> ordinal beta -> forall p q r:set -> prop, PNoEq_ alpha p q -> PNoLe alpha q beta r -> PNoLe alpha p beta r.
admit.
Qed.

Theorem PNoLe_tra : forall alpha beta gamma, ordinal alpha -> ordinal beta -> ordinal gamma -> forall p q r:set -> prop, PNoLe alpha p beta q -> PNoLe beta q gamma r -> PNoLe alpha p gamma r.
admit.
Qed.

Definition PNo_downc : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
 := fun L alpha p => exists beta, ordinal beta /\ exists q:set -> prop, L beta q /\ PNoLe alpha p beta q.
Definition PNo_upc : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
 := fun R alpha p => exists beta, ordinal beta /\ exists q:set -> prop, R beta q /\ PNoLe beta q alpha p.

Theorem PNoLe_downc : forall L:set -> (set -> prop) -> prop, forall alpha beta, forall p q:set -> prop,
  ordinal alpha -> ordinal beta ->
  PNo_downc L alpha p -> PNoLe beta q alpha p -> PNo_downc L beta q.
admit.
Qed.

Theorem PNo_downc_ref : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, L alpha p -> PNo_downc L alpha p.
admit.
Qed.

Theorem PNo_upc_ref : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, R alpha p -> PNo_upc R alpha p.
admit.
Qed.

Theorem PNoLe_upc : forall R:set -> (set -> prop) -> prop, forall alpha beta, forall p q:set -> prop,
  ordinal alpha -> ordinal beta ->
  PNo_upc R alpha p -> PNoLe alpha p beta q -> PNo_upc R beta q.
admit.
Qed.

Definition PNoLt_pwise : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> prop
  := fun L R => forall gamma, ordinal gamma -> forall p:set -> prop, L gamma p -> forall delta, ordinal delta -> forall q:set -> prop, R delta q -> PNoLt gamma p delta q.

Theorem PNoLt_pwise_downc_upc : forall L R:set -> (set -> prop) -> prop,
    PNoLt_pwise L R -> PNoLt_pwise (PNo_downc L) (PNo_upc R).
admit.
Qed.

Definition PNo_rel_strict_upperbd : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L alpha p =>
       forall beta :e alpha, forall q:set -> prop, PNo_downc L beta q -> PNoLt beta q alpha p.
Definition PNo_rel_strict_lowerbd : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun R alpha p =>
       forall beta :e alpha, forall q:set -> prop, PNo_upc R beta q -> PNoLt alpha p beta q.
Definition PNo_rel_strict_imv : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R alpha p => PNo_rel_strict_upperbd L alpha p /\ PNo_rel_strict_lowerbd R alpha p.

Theorem PNoEq_rel_strict_upperbd : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_rel_strict_upperbd L alpha p -> PNo_rel_strict_upperbd L alpha q.
admit.
Qed.

Theorem PNo_rel_strict_upperbd_antimon : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, forall beta :e alpha,
  PNo_rel_strict_upperbd L alpha p -> PNo_rel_strict_upperbd L beta p.
admit.
Qed.

Theorem PNoEq_rel_strict_lowerbd : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_rel_strict_lowerbd R alpha p -> PNo_rel_strict_lowerbd R alpha q.
admit.
Qed.

Theorem PNo_rel_strict_lowerbd_antimon : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, forall beta :e alpha,
  PNo_rel_strict_lowerbd R alpha p -> PNo_rel_strict_lowerbd R beta p.
admit.
Qed.

Theorem PNoEq_rel_strict_imv : forall L R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_imv L R alpha q.
admit.
Qed.

Theorem PNo_rel_strict_imv_antimon : forall L R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, forall beta :e alpha,
  PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_imv L R beta p.
admit.
Qed.

Definition PNo_rel_strict_uniq_imv : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R alpha p => PNo_rel_strict_imv L R alpha p /\ forall q:set -> prop, PNo_rel_strict_imv L R alpha q -> PNoEq_ alpha p q.
Definition PNo_rel_strict_split_imv : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R alpha p =>
         PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta /\ delta <> alpha)
      /\ PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta \/ delta = alpha).

Theorem PNo_extend0_eq : forall alpha, forall p:set -> prop, PNoEq_ alpha p (fun delta => p delta /\ delta <> alpha).
admit.
Qed.

Theorem PNo_extend1_eq : forall alpha, forall p:set -> prop, PNoEq_ alpha p (fun delta => p delta \/ delta = alpha).
admit.
Qed.

Theorem PNo_rel_imv_ex : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha ->
      (exists p:set -> prop, PNo_rel_strict_uniq_imv L R alpha p)
   \/ (exists tau :e alpha, exists p:set -> prop, PNo_rel_strict_split_imv L R tau p).
admit.
Qed.

Definition PNo_lenbdd : set -> (set -> (set -> prop) -> prop) -> prop
  := fun alpha L => forall beta, forall p:set -> prop, L beta p -> beta :e alpha.

Theorem PNo_lenbdd_strict_imv_extend0 : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha -> PNo_lenbdd alpha L -> PNo_lenbdd alpha R ->
  forall p:set -> prop,
  PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta /\ delta <> alpha).
admit.
Qed.

Theorem PNo_lenbdd_strict_imv_extend1 : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha -> PNo_lenbdd alpha L -> PNo_lenbdd alpha R ->
  forall p:set -> prop,
  PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta \/ delta = alpha).
admit.
Qed.

Theorem PNo_lenbdd_strict_imv_split : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha -> PNo_lenbdd alpha L -> PNo_lenbdd alpha R ->
  forall p:set -> prop,
  PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_split_imv L R alpha p.
admit.
Qed.

Theorem PNo_rel_imv_bdd_ex : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> exists beta :e ordsucc alpha,
      exists p:set -> prop, PNo_rel_strict_split_imv L R beta p.
admit.
Qed.

Definition PNo_strict_upperbd : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L alpha p =>
       forall beta, ordinal beta -> forall q:set -> prop, L beta q -> PNoLt beta q alpha p.
Definition PNo_strict_lowerbd : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun R alpha p =>
       forall beta, ordinal beta -> forall q:set -> prop, R beta q -> PNoLt alpha p beta q.
Definition PNo_strict_imv : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R alpha p => PNo_strict_upperbd L alpha p /\ PNo_strict_lowerbd R alpha p.

Theorem PNoEq_strict_upperbd : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_strict_upperbd L alpha p -> PNo_strict_upperbd L alpha q.
admit.
Qed.

Theorem PNoEq_strict_lowerbd : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_strict_lowerbd R alpha p -> PNo_strict_lowerbd R alpha q.
admit.
Qed.

Theorem PNoEq_strict_imv : forall L R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_strict_imv L R alpha p -> PNo_strict_imv L R alpha q.
admit.
Qed.

Theorem PNo_strict_upperbd_imp_rel_strict_upperbd : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha ->
  forall beta :e ordsucc alpha, forall p:set -> prop,
   PNo_strict_upperbd L alpha p -> PNo_rel_strict_upperbd L beta p.
admit.
Qed.

Theorem PNo_strict_lowerbd_imp_rel_strict_lowerbd : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha ->
  forall beta :e ordsucc alpha, forall p:set -> prop,
   PNo_strict_lowerbd R alpha p -> PNo_rel_strict_lowerbd R beta p.
admit.
Qed.

Theorem PNo_strict_imv_imp_rel_strict_imv : forall L R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha ->
  forall beta :e ordsucc alpha, forall p:set -> prop,
   PNo_strict_imv L R alpha p -> PNo_rel_strict_imv L R beta p.
admit.
Qed.

Theorem PNo_rel_split_imv_imp_strict_imv : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha -> forall p:set -> prop,
       PNo_rel_strict_split_imv L R alpha p
    -> PNo_strict_imv L R alpha p.
admit.
Qed.

Theorem PNo_lenbdd_strict_imv_ex : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> exists beta :e ordsucc alpha,
      exists p:set -> prop, PNo_strict_imv L R beta p.
admit.
Qed.

Definition PNo_least_rep : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R beta p => ordinal beta
       /\ PNo_strict_imv L R beta p
       /\ forall gamma :e beta,
           forall q:set -> prop, ~PNo_strict_imv L R gamma q.
Definition PNo_least_rep2 : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R beta p => PNo_least_rep L R beta p /\ forall x, x /:e beta -> ~p x.

Theorem PNo_strict_imv_pred_eq : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha -> forall p q:set -> prop,
     PNo_least_rep L R alpha p
  -> PNo_strict_imv L R alpha q
  -> forall beta :e alpha, p beta <-> q beta.
admit.
Qed.

Theorem PNo_lenbdd_least_rep2_exuniq2 : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> exists beta,
        (exists p:set -> prop, PNo_least_rep2 L R beta p)
     /\ (forall p q:set -> prop, PNo_least_rep2 L R beta p -> PNo_least_rep2 L R beta q -> p = q).
admit.
Qed.

(* Parameter PNo_bd "1b39e85278dd9e820e7b6258957386ac55934d784aa3702c57a28ec807453b01" "ed76e76de9b58e621daa601cca73b4159a437ba0e73114924cb92ec8044f2aa2" *)
Definition PNo_bd : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set
 := fun L R => DescrR_i_io_1 (PNo_least_rep2 L R).
(* Parameter PNo_pred "be07c39b18a3aa93f066f4c064fee3941ec27cfd07a4728b6209135c77ce5704" "b2d51dcfccb9527e9551b0d0c47d891c9031a1d4ee87bba5a9ae5215025d107a" *)
Definition PNo_pred : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> prop
 := fun L R => DescrR_i_io_2 (PNo_least_rep2 L R).

Theorem PNo_bd_pred_lem : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> PNo_least_rep2 L R (PNo_bd L R) (PNo_pred L R).
admit.
Qed.

Theorem PNo_bd_pred : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> PNo_least_rep L R (PNo_bd L R) (PNo_pred L R).
admit.
Qed.

Theorem PNo_bd_In : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> PNo_bd L R :e ordsucc alpha.
admit.
Qed.

Opaque Sigma Pi ap PNo_pred PNo_bd PNoLt DescrR_i_io_1 DescrR_i_io_2.

Section TaggedSets.
Let tag : set -> set := fun alpha => SetAdjoin alpha {1}.
Postfix ' 100 := tag.

Theorem not_TransSet_Sing1 : ~TransSet {1}.
admit.
Qed.

Theorem not_ordinal_Sing1 : ~ordinal {1}.
admit.
Qed.

Theorem tagged_not_ordinal : forall y, ~ordinal (y ').
admit.
Qed.

Theorem tagged_notin_ordinal : forall alpha y, ordinal alpha -> (y ') /:e alpha.
admit.
Qed.

Theorem tagged_eqE_Subq : forall alpha beta, ordinal alpha -> alpha ' = beta ' -> alpha c= beta.
admit.
Qed.

Theorem tagged_eqE_eq : forall alpha beta, ordinal alpha -> ordinal beta -> alpha ' = beta ' -> alpha = beta.
admit.
Qed.

Theorem tagged_ReplE : forall alpha beta, ordinal alpha -> ordinal beta -> beta ' :e {gamma '|gamma :e alpha} -> beta :e alpha.
admit.
Qed.

Theorem ordinal_notin_tagged_Repl : forall alpha Y, ordinal alpha -> alpha /:e {y '|y :e Y}.
admit.
Qed.

Definition SNoElts_ : set -> set := fun alpha => alpha :\/: {beta '|beta :e alpha}.

Theorem SNoElts_mon : forall alpha beta, alpha c= beta -> SNoElts_ alpha c= SNoElts_ beta.
admit.
Qed.

Definition SNo_ : set -> set -> prop := fun alpha x =>
    x c= SNoElts_ alpha
 /\ forall beta :e alpha, exactly1of2 (beta ' :e x) (beta :e x).
Definition PSNo : set -> (set -> prop) -> set :=
  fun alpha p => {beta :e alpha|p beta} :\/: {beta '|beta :e alpha, ~p beta}.

Theorem PNoEq_PSNo : forall alpha, ordinal alpha -> forall p:set -> prop, PNoEq_ alpha (fun beta => beta :e PSNo alpha p) p.
admit.
Qed.

Theorem SNo_PSNo : forall alpha, ordinal alpha -> forall p:set -> prop, SNo_ alpha (PSNo alpha p).
admit.
Qed.

Theorem SNo_PSNo_eta_ : forall alpha x, ordinal alpha -> SNo_ alpha x -> x = PSNo alpha (fun beta => beta :e x).
admit.
Qed.

(* Parameter SNo "87d7604c7ea9a2ae0537066afb358a94e6ac0cd80ba277e6b064422035a620cf" "11faa7a742daf8e4f9aaf08e90b175467e22d0e6ad3ed089af1be90cfc17314b" *)
Definition SNo : set -> prop := fun x => exists alpha, ordinal alpha /\ SNo_ alpha x.

Theorem SNo_SNo : forall alpha, ordinal alpha -> forall z, SNo_ alpha z -> SNo z.
admit.
Qed.

(* Parameter SNoLev "bf1decfd8f4025a2271f2a64d1290eae65933d0f2f0f04b89520449195f1aeb8" "293b77d05dab711767d698fb4484aab2a884304256765be0733e6bd5348119e8" *)
Definition SNoLev : set -> set := fun x => Eps_i (fun alpha => ordinal alpha /\ SNo_ alpha x).

Theorem SNoLev_uniq_Subq : forall x alpha beta, ordinal alpha -> ordinal beta -> SNo_ alpha x -> SNo_ beta x -> alpha c= beta.
admit.
Qed.

Theorem SNoLev_uniq : forall x alpha beta, ordinal alpha -> ordinal beta -> SNo_ alpha x -> SNo_ beta x -> alpha = beta.
admit.
Qed.

Theorem SNoLev_prop : forall x, SNo x -> ordinal (SNoLev x) /\ SNo_ (SNoLev x) x.
admit.
Qed.

Theorem SNoLev_ordinal : forall x, SNo x -> ordinal (SNoLev x).
admit.
Qed.

Theorem SNoLev_ : forall x, SNo x -> SNo_ (SNoLev x) x.
admit.
Qed.

Theorem SNo_PSNo_eta : forall x, SNo x -> x = PSNo (SNoLev x) (fun beta => beta :e x).
admit.
Qed.

Theorem SNoLev_PSNo : forall alpha, ordinal alpha -> forall p:set -> prop, SNoLev (PSNo alpha p) = alpha.
admit.
Qed.

Theorem SNo_Subq : forall x y, SNo x -> SNo y -> SNoLev x c= SNoLev y -> (forall alpha :e SNoLev x, alpha :e x <-> alpha :e y) -> x c= y.
admit.
Qed.

Definition SNoEq_ : set -> set -> set -> prop
 := fun alpha x y => PNoEq_ alpha (fun beta => beta :e x) (fun beta => beta :e y).

Theorem SNoEq_I : forall alpha x y, (forall beta :e alpha, beta :e x <-> beta :e y) -> SNoEq_ alpha x y.
admit.
Qed.

Theorem SNo_eq : forall x y, SNo x -> SNo y -> SNoLev x = SNoLev y -> SNoEq_ (SNoLev x) x y -> x = y.
admit.
Qed.

End TaggedSets.
Definition SNoLt : set -> set -> prop :=
  fun x y => PNoLt (SNoLev x) (fun beta => beta :e x) (SNoLev y) (fun beta => beta :e y).
Infix < 490 := SNoLt.
Definition SNoLe : set -> set -> prop :=
  fun x y => PNoLe (SNoLev x) (fun beta => beta :e x) (SNoLev y) (fun beta => beta :e y).
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.

Theorem SNoLtLe : forall x y, x < y -> x <= y.
admit.
Qed.

Theorem SNoLeE : forall x y, SNo x -> SNo y -> x <= y -> x < y \/ x = y.
admit.
Qed.

Theorem SNoEq_sym_ : forall alpha x y, SNoEq_ alpha x y -> SNoEq_ alpha y x.
admit.
Qed.

Theorem SNoEq_tra_ : forall alpha x y z, SNoEq_ alpha x y -> SNoEq_ alpha y z -> SNoEq_ alpha x z.
admit.
Qed.

Theorem SNoLtE : forall x y, SNo x -> SNo y -> x < y ->
 forall p:prop,
    (forall z, SNo z -> SNoLev z :e SNoLev x :/\: SNoLev y -> SNoEq_ (SNoLev z) z x -> SNoEq_ (SNoLev z) z y -> x < z -> z < y -> SNoLev z /:e x -> SNoLev z :e y -> p)
 -> (SNoLev x :e SNoLev y -> SNoEq_ (SNoLev x) x y -> SNoLev x :e y -> p)
 -> (SNoLev y :e SNoLev x -> SNoEq_ (SNoLev y) x y -> SNoLev y /:e x -> p)
 -> p.
admit.
Qed.

(** The analogous thm to PNoLtI1 can be recovered by SNoLt_tra (transitivity) and SNoLtI2 and SNoLtI3. **)
Theorem SNoLtI2 : forall x y,
     SNoLev x :e SNoLev y
  -> SNoEq_ (SNoLev x) x y
  -> SNoLev x :e y
  -> x < y.
admit.
Qed.

Theorem SNoLtI3 : forall x y,
     SNoLev y :e SNoLev x
  -> SNoEq_ (SNoLev y) x y
  -> SNoLev y /:e x
  -> x < y.
admit.
Qed.

Theorem SNoLt_irref : forall x, ~SNoLt x x.
admit.
Qed.

Theorem SNoLt_trichotomy_or : forall x y, SNo x -> SNo y -> x < y \/ x = y \/ y < x.
admit.
Qed.

Theorem SNoLt_trichotomy_or_impred : forall x y, SNo x -> SNo y ->
  forall p:prop,
      (x < y -> p)
   -> (x = y -> p)
   -> (y < x -> p)
   -> p.
admit.
Qed.

Theorem SNoLt_tra : forall x y z, SNo x -> SNo y -> SNo z -> x < y -> y < z -> x < z.
admit.
Qed.

Theorem SNoLe_ref : forall x, SNoLe x x.
admit.
Qed.

Theorem SNoLe_antisym : forall x y, SNo x -> SNo y -> x <= y -> y <= x -> x = y.
admit.
Qed.

Theorem SNoLtLe_tra : forall x y z, SNo x -> SNo y -> SNo z -> x < y -> y <= z -> x < z.
admit.
Qed.

Theorem SNoLeLt_tra : forall x y z, SNo x -> SNo y -> SNo z -> x <= y -> y < z -> x < z.
admit.
Qed.

Theorem SNoLe_tra : forall x y z, SNo x -> SNo y -> SNo z -> x <= y -> y <= z -> x <= z.
admit.
Qed.

Theorem SNoLtLe_or : forall x y, SNo x -> SNo y -> x < y \/ y <= x.
admit.
Qed.

Theorem SNoLt_PSNo_PNoLt : forall alpha beta, forall p q:set -> prop,
 ordinal alpha -> ordinal beta ->
 PSNo alpha p < PSNo beta q -> PNoLt alpha p beta q.
admit.
Qed.

Theorem PNoLt_SNoLt_PSNo : forall alpha beta, forall p q:set -> prop,
 ordinal alpha -> ordinal beta ->
 PNoLt alpha p beta q -> PSNo alpha p < PSNo beta q.
admit.
Qed.

Definition SNoCut : set -> set -> set :=
  fun L R => PSNo (PNo_bd (fun alpha p => ordinal alpha /\ PSNo alpha p :e L) (fun alpha p => ordinal alpha /\ PSNo alpha p :e R)) (PNo_pred (fun alpha p => ordinal alpha /\ PSNo alpha p :e L) (fun alpha p => ordinal alpha /\ PSNo alpha p :e R)).
Definition SNoCutP : set -> set -> prop :=
 fun L R =>
      (forall x :e L, SNo x)
   /\ (forall y :e R, SNo y)
   /\ (forall x :e L, forall y :e R, x < y).

Theorem SNoCutP_SNoCut : forall L R, SNoCutP L R
 -> SNo (SNoCut L R)
 /\ SNoLev (SNoCut L R) :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y)))
 /\ (forall x :e L, x < SNoCut L R)
 /\ (forall y :e R, SNoCut L R < y)
 /\ (forall z, SNo z -> (forall x :e L, x < z) -> (forall y :e R, z < y) -> SNoLev (SNoCut L R) c= SNoLev z /\ SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) z).
admit.
Qed.

Theorem SNoCutP_SNoCut_impred : forall L R, SNoCutP L R
 -> forall p:prop,
      (SNo (SNoCut L R)
    -> SNoLev (SNoCut L R) :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y)))
    -> (forall x :e L, x < SNoCut L R)
    -> (forall y :e R, SNoCut L R < y)
    -> (forall z, SNo z -> (forall x :e L, x < z) -> (forall y :e R, z < y) -> SNoLev (SNoCut L R) c= SNoLev z /\ SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) z)
    -> p)
   -> p.
admit.
Qed.

Theorem SNoCutP_L_0: forall L, (forall x :e L, SNo x) -> SNoCutP L 0.
admit.
Qed.

Theorem SNoCutP_0_0: SNoCutP 0 0.
admit.
Qed.

Definition SNoS_ : set -> set := fun alpha => {x :e Power (SNoElts_ alpha)|exists beta :e alpha, SNo_ beta x}.

Theorem SNoS_E : forall alpha, ordinal alpha -> forall x :e SNoS_ alpha, exists beta :e alpha, SNo_ beta x.
admit.
Qed.

Section TaggedSets2.
Let tag : set -> set := fun alpha => SetAdjoin alpha {1}.
Postfix ' 100 := tag.

Theorem SNoS_I : forall alpha, ordinal alpha -> forall x, forall beta :e alpha, SNo_ beta x -> x :e SNoS_ alpha.
admit.
Qed.

Theorem SNoS_I2 : forall x y, SNo x -> SNo y -> SNoLev x :e SNoLev y -> x :e SNoS_ (SNoLev y).
admit.
Qed.  

Theorem SNoS_Subq : forall alpha beta, ordinal alpha -> ordinal beta -> alpha c= beta -> SNoS_ alpha c= SNoS_ beta.
admit.
Qed.

Theorem SNoLev_uniq2 : forall alpha, ordinal alpha -> forall x, SNo_ alpha x -> SNoLev x = alpha.
admit.
Qed.

Theorem SNoS_E2 : forall alpha, ordinal alpha -> forall x :e SNoS_ alpha,
 forall p:prop,
     (SNoLev x :e alpha -> ordinal (SNoLev x) -> SNo x -> SNo_ (SNoLev x) x -> p)
  -> p.
admit.
Qed.

Theorem SNoS_In_neq : forall w, SNo w -> forall x :e SNoS_ (SNoLev w), x <> w.
admit.
Qed.

Theorem SNoS_SNoLev : forall z, SNo z -> z :e SNoS_ (ordsucc (SNoLev z)).
admit.
Qed.

Definition SNoL : set -> set := fun z => {x :e SNoS_ (SNoLev z) | x < z}.
Definition SNoR : set -> set := fun z => {y :e SNoS_ (SNoLev z) | z < y}.

Theorem SNoCutP_SNoL_SNoR: forall z, SNo z -> SNoCutP (SNoL z) (SNoR z).
admit.
Qed.

Theorem SNoL_E : forall x, SNo x -> forall w :e SNoL x,
  forall p:prop,
       (SNo w -> SNoLev w :e SNoLev x -> w < x -> p)
    -> p.
admit.
Qed.

Theorem SNoR_E : forall x, SNo x -> forall z :e SNoR x,
  forall p:prop,
       (SNo z -> SNoLev z :e SNoLev x -> x < z -> p)
    -> p.
admit.
Qed.

Theorem SNoL_SNoS_ : forall z, SNoL z c= SNoS_ (SNoLev z).
admit.
Qed.

Theorem SNoR_SNoS_ : forall z, SNoR z c= SNoS_ (SNoLev z).
admit.
Qed.

Theorem SNoL_SNoS : forall x, SNo x -> forall w :e SNoL x, w :e SNoS_ (SNoLev x).
admit.
Qed.

Theorem SNoR_SNoS : forall x, SNo x -> forall z :e SNoR x, z :e SNoS_ (SNoLev x).
admit.
Qed.

Theorem SNoL_I : forall z, SNo z -> forall x, SNo x -> SNoLev x :e SNoLev z -> x < z -> x :e SNoL z.
admit.
Qed.

Theorem SNoR_I : forall z, SNo z -> forall y, SNo y -> SNoLev y :e SNoLev z -> z < y -> y :e SNoR z.
admit.
Qed.

Theorem SNo_eta : forall z, SNo z -> z = SNoCut (SNoL z) (SNoR z).
admit.
Qed.

Theorem SNoCutP_SNo_SNoCut : forall L R, SNoCutP L R -> SNo (SNoCut L R).
admit.
Qed.

Theorem SNoCutP_SNoCut_L : forall L R, SNoCutP L R -> forall x :e L, x < SNoCut L R.
admit.
Qed.

Theorem SNoCutP_SNoCut_R : forall L R, SNoCutP L R -> forall y :e R, SNoCut L R < y.
admit.
Qed.

Theorem SNoCutP_SNoCut_fst : forall L R, SNoCutP L R ->
 forall z, SNo z
   -> (forall x :e L, x < z)
   -> (forall y :e R, z < y)
   -> SNoLev (SNoCut L R) c= SNoLev z
   /\ SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) z.
admit.
Qed.

Theorem SNoCut_Le : forall L1 R1 L2 R2, SNoCutP L1 R1 -> SNoCutP L2 R2
  -> (forall w :e L1, w < SNoCut L2 R2)
  -> (forall z :e R2, SNoCut L1 R1 < z)
  -> SNoCut L1 R1 <= SNoCut L2 R2.
admit.
Qed.

Theorem SNoCut_ext : forall L1 R1 L2 R2, SNoCutP L1 R1 -> SNoCutP L2 R2
  -> (forall w :e L1, w < SNoCut L2 R2)
  -> (forall z :e R1, SNoCut L2 R2 < z)
  -> (forall w :e L2, w < SNoCut L1 R1)
  -> (forall z :e R2, SNoCut L1 R1 < z)
  -> SNoCut L1 R1 = SNoCut L2 R2.
admit.
Qed.

Theorem SNoLt_SNoL_or_SNoR_impred: forall x y, SNo x -> SNo y -> x < y ->
 forall p:prop,
    (forall z :e SNoL y, z :e SNoR x -> p)
 -> (x :e SNoL y -> p)
 -> (y :e SNoR x -> p)
 -> p.
admit.
Qed.

Theorem SNoL_or_SNoR_impred: forall x y, SNo x -> SNo y ->
 forall p:prop,
    (x = y -> p)
 -> (forall z :e SNoL y, z :e SNoR x -> p)
 -> (x :e SNoL y -> p)
 -> (y :e SNoR x -> p)
 -> (forall z :e SNoR y, z :e SNoL x -> p)
 -> (x :e SNoR y -> p)
 -> (y :e SNoL x -> p)
 -> p.
admit.
Qed.

Theorem SNoL_SNoCutP_ex: forall L R, SNoCutP L R -> forall w :e SNoL (SNoCut L R), exists w' :e L, w <= w'.
admit.
Qed.

Theorem SNoR_SNoCutP_ex: forall L R, SNoCutP L R -> forall z :e SNoR (SNoCut L R), exists z' :e R, z' <= z.
admit.
Qed.

Theorem ordinal_SNo_ : forall alpha, ordinal alpha -> SNo_ alpha alpha.
admit.
Qed.

Theorem ordinal_SNo : forall alpha, ordinal alpha -> SNo alpha.
admit.
Qed.

Theorem ordinal_SNoLev : forall alpha, ordinal alpha -> SNoLev alpha = alpha.
admit.
Qed.

Theorem ordinal_SNoLev_max : forall alpha, ordinal alpha -> forall z, SNo z -> SNoLev z :e alpha -> z < alpha.
admit.
Qed.

Theorem ordinal_SNoL : forall alpha, ordinal alpha -> SNoL alpha = SNoS_ alpha.
admit.
Qed.

Theorem ordinal_SNoR : forall alpha, ordinal alpha -> SNoR alpha = Empty.
admit.
Qed.

Theorem nat_p_SNo: forall n, nat_p n -> SNo n.
admit.
Qed.

Theorem omega_SNo: forall n :e omega, SNo n.
admit.
Qed.

Theorem omega_SNoS_omega : omega c= SNoS_ omega.
admit.
Qed.

Theorem ordinal_In_SNoLt : forall alpha, ordinal alpha -> forall beta :e alpha, beta < alpha.
admit.
Qed.

Theorem ordinal_SNoLev_max_2 : forall alpha, ordinal alpha -> forall z, SNo z -> SNoLev z :e ordsucc alpha -> z <= alpha.
admit.
Qed.

Theorem ordinal_Subq_SNoLe : forall alpha beta, ordinal alpha -> ordinal beta -> alpha c= beta -> alpha <= beta.
admit.
Qed.

Theorem ordinal_SNoLt_In : forall alpha beta, ordinal alpha -> ordinal beta -> alpha < beta -> alpha :e beta.
admit.
Qed.

Theorem omega_nonneg : forall m :e omega, 0 <= m.
admit.
Qed.

Theorem SNo_0 : SNo 0.
admit.
Qed.

Theorem SNo_1 : SNo 1.
admit.
Qed.

Theorem SNo_2 : SNo 2.
admit.
Qed.

Theorem SNoLev_0 : SNoLev 0 = 0.
admit.
Qed.

Theorem SNoCut_0_0: SNoCut 0 0 = 0.
admit.
Qed.

Theorem SNoL_0 : SNoL 0 = 0.
admit.
Qed.

Theorem SNoR_0 : SNoR 0 = 0.
admit.
Qed.

Theorem SNoL_1 : SNoL 1 = 1.
admit.
Qed.

Theorem SNoR_1 : SNoR 1 = 0.
admit.
Qed.

Theorem SNo_max_SNoLev : forall x, SNo x -> (forall y :e SNoS_ (SNoLev x), y < x) -> SNoLev x = x.
admit.
Qed.

Theorem SNo_max_ordinal : forall x, SNo x -> (forall y :e SNoS_ (SNoLev x), y < x) -> ordinal x.
admit.
Qed.

Theorem pos_low_eq_one : forall x, SNo x -> 0 < x -> SNoLev x c= 1 -> x = 1.
admit.
Qed.

Definition SNo_extend0 : set -> set := fun x => PSNo (ordsucc (SNoLev x)) (fun delta => delta :e x /\ delta <> SNoLev x).
Definition SNo_extend1 : set -> set := fun x => PSNo (ordsucc (SNoLev x)) (fun delta => delta :e x \/ delta = SNoLev x).

Theorem SNo_extend0_SNo_ : forall x, SNo x -> SNo_ (ordsucc (SNoLev x)) (SNo_extend0 x).
admit.
Qed.

Theorem SNo_extend1_SNo_ : forall x, SNo x -> SNo_ (ordsucc (SNoLev x)) (SNo_extend1 x).
admit.
Qed.

Theorem SNo_extend0_SNo : forall x, SNo x -> SNo (SNo_extend0 x).
admit.
Qed.

Theorem SNo_extend1_SNo : forall x, SNo x -> SNo (SNo_extend1 x).
admit.
Qed.

Theorem SNo_extend0_SNoLev : forall x, SNo x -> SNoLev (SNo_extend0 x) = ordsucc (SNoLev x).
admit.
Qed.

Theorem SNo_extend1_SNoLev : forall x, SNo x -> SNoLev (SNo_extend1 x) = ordsucc (SNoLev x).
admit.
Qed.

Theorem SNo_extend0_nIn : forall x, SNo x -> SNoLev x /:e SNo_extend0 x.
admit.
Qed.

Theorem SNo_extend1_In : forall x, SNo x -> SNoLev x :e SNo_extend1 x.
admit.
Qed.

Theorem SNo_extend0_SNoEq : forall x, SNo x -> SNoEq_ (SNoLev x) (SNo_extend0 x) x.
admit.
Qed.

Theorem SNo_extend1_SNoEq : forall x, SNo x -> SNoEq_ (SNoLev x) (SNo_extend1 x) x.
admit.
Qed.

Theorem SNoLev_0_eq_0 : forall x, SNo x -> SNoLev x = 0 -> x = 0.
admit.
Qed.

(** eps_ n is the Surreal Number 1/2^n, without needing to define division or exponents first **)
Definition eps_ : set -> set := fun n => {0} :\/: {(ordsucc m) ' | m :e n}.

Theorem eps_ordinal_In_eq_0 : forall n alpha, ordinal alpha -> alpha :e eps_ n -> alpha = 0.
admit.
Qed.

Theorem eps_0_1 : eps_ 0 = 1.
admit.
Qed.

Theorem SNo__eps_ : forall n :e omega, SNo_ (ordsucc n) (eps_ n).
admit.
Qed.

Theorem SNo_eps_ : forall n :e omega, SNo (eps_ n).
admit.
Qed.

Theorem SNo_eps_1 : SNo (eps_ 1).
admit.
Qed.

Theorem SNoLev_eps_ : forall n :e omega, SNoLev (eps_ n) = ordsucc n.
admit.
Qed.

Theorem SNo_eps_SNoS_omega : forall n :e omega, eps_ n :e SNoS_ omega.
admit.
Qed.

Theorem SNo_eps_decr : forall n :e omega, forall m :e n, eps_ n < eps_ m.
admit.
Qed.

Theorem SNo_eps_pos : forall n :e omega, 0 < eps_ n.
admit.
Qed.

Theorem SNo_pos_eps_Lt : forall n, nat_p n -> forall x :e SNoS_ (ordsucc n), 0 < x -> eps_ n < x.
admit.
Qed.

Theorem SNo_pos_eps_Le : forall n, nat_p n -> forall x :e SNoS_ (ordsucc (ordsucc n)), 0 < x -> eps_ n <= x.
admit.
Qed.

Theorem eps_SNo_eq : forall n, nat_p n -> forall x :e SNoS_ (ordsucc n), 0 < x -> SNoEq_ (SNoLev x) (eps_ n) x -> exists m :e n, x = eps_ m.
admit.
Qed.

Theorem eps_SNoCutP : forall n :e omega, SNoCutP {0} {eps_ m|m :e n}.
admit.
Qed.

Theorem eps_SNoCut : forall n :e omega, eps_ n = SNoCut {0} {eps_ m|m :e n}.
admit.
Qed.

End TaggedSets2.

Theorem SNo_etaE : forall z, SNo z ->
  forall p:prop,
     (forall L R, SNoCutP L R
       -> (forall x :e L, SNoLev x :e SNoLev z)
       -> (forall y :e R, SNoLev y :e SNoLev z)
       -> z = SNoCut L R
       -> p)
   -> p.
admit.
Qed.

(*** surreal induction ***)
Theorem SNo_ind : forall P:set -> prop,
  (forall L R, SNoCutP L R
   -> (forall x :e L, P x)
   -> (forall y :e R, P y)
   -> P (SNoCut L R))
 -> forall z, SNo z -> P z.
admit.
Qed.

(*** surreal recursion ***)
Section SurrealRecI.
Variable F:set -> (set -> set) -> set.
Let default : set := Eps_i (fun _ => True).
Let G : set -> (set -> set -> set) -> set -> set
  := fun alpha g =>
       If_ii
          (ordinal alpha)
          (fun z:set => if z :e SNoS_ (ordsucc alpha) then
                           F z (fun w => g (SNoLev w) w)
                        else
                           default)
          (fun z:set => default).
(* Parameter SNo_rec_i "352082c509ab97c1757375f37a2ac62ed806c7b39944c98161720a584364bfaf" "be45dfaed6c479503a967f3834400c4fd18a8a567c8887787251ed89579f7be3" *)
Definition SNo_rec_i : set -> set
 := fun z => In_rec_ii G (SNoLev z) z.
Hypothesis Fr: forall z, SNo z ->
   forall g h:set -> set, (forall w :e SNoS_ (SNoLev z), g w = h w)
     -> F z g = F z h.

Theorem SNo_rec_i_eq : forall z, SNo z -> SNo_rec_i z = F z SNo_rec_i.
admit.
Qed.

End SurrealRecI.
Section SurrealRecII.
Variable F:set -> (set -> (set -> set)) -> (set -> set).
Let default : (set -> set) := Descr_ii (fun _ => True).
Let G : set -> (set -> set -> (set -> set)) -> set -> (set -> set)
  := fun alpha g =>
       If_iii
          (ordinal alpha)
          (fun z:set => If_ii (z :e SNoS_ (ordsucc alpha))
                              (F z (fun w => g (SNoLev w) w))
                              default)
          (fun z:set => default).
(* Parameter SNo_rec_ii "030b1b3db48f720b8db18b1192717cad8f204fff5fff81201b9a2414f5036417" "e148e62186e718374accb69cda703e3440725cca8832aed55c0b32731f7401ab" *)
Definition SNo_rec_ii : set -> (set -> set)
 := fun z => In_rec_iii G (SNoLev z) z.
Hypothesis Fr: forall z, SNo z ->
   forall g h:set -> (set -> set), (forall w :e SNoS_ (SNoLev z), g w = h w)
     -> F z g = F z h.

Theorem SNo_rec_ii_eq : forall z, SNo z -> SNo_rec_ii z = F z SNo_rec_ii.
admit.
Qed.

End SurrealRecII.
Section SurrealRec2.
Variable F:set -> set -> (set -> set -> set) -> set.
Let G:set -> (set -> set -> set) -> set -> (set -> set) -> set
  := fun w f z g => F w z (fun x y => if x = w then g y else f x y).
Let H:set -> (set -> set -> set) -> set -> set
  := fun w f z => if SNo z then SNo_rec_i (G w f) z else Empty.
(* Parameter SNo_rec2 "9c6267051fa817eed39b404ea37e7913b3571fe071763da2ebc1baa56b4b77f5" "7d10ab58310ebefb7f8bf63883310aa10fc2535f53bb48db513a868bc02ec028" *)
Definition SNo_rec2 : set -> set -> set
  := SNo_rec_ii H.
Hypothesis Fr: forall w, SNo w -> forall z, SNo z ->
   forall g h:set -> set -> set,
        (forall x :e SNoS_ (SNoLev w), forall y, SNo y -> g x y = h x y)
     -> (forall y :e SNoS_ (SNoLev z), g w y = h w y)
     -> F w z g = F w z h.

Theorem SNo_rec2_G_prop : forall w, SNo w -> forall f k:set -> set -> set,
    (forall x :e SNoS_ (SNoLev w), f x = k x)
 -> forall z, SNo z ->
    forall g h:set -> set, (forall u :e SNoS_ (SNoLev z), g u = h u)
 -> G w f z g = G w k z h.
admit.
Qed.

Theorem SNo_rec2_eq_1 : forall w, SNo w -> forall f:set -> set -> set,
  forall z, SNo z ->
   SNo_rec_i (G w f) z = G w f z (SNo_rec_i (G w f)).
admit.
Qed.

Theorem SNo_rec2_eq : forall w, SNo w -> forall z, SNo z ->
   SNo_rec2 w z = F w z SNo_rec2.
admit.
Qed.

End SurrealRec2.

Theorem SNo_ordinal_ind : forall P:set -> prop,
  (forall alpha, ordinal alpha -> forall x :e SNoS_ alpha, P x)
  ->
  (forall x, SNo x -> P x).
admit.
Qed.

Theorem SNo_ordinal_ind2 : forall P:set -> set -> prop,
  (forall alpha, ordinal alpha ->
   forall beta, ordinal beta ->
   forall x :e SNoS_ alpha, forall y :e SNoS_ beta, P x y)
  ->
  (forall x y, SNo x -> SNo y -> P x y).
admit.
Qed.

Theorem SNo_ordinal_ind3 : forall P:set -> set -> set -> prop,
  (forall alpha, ordinal alpha ->
   forall beta, ordinal beta ->
   forall gamma, ordinal gamma ->
   forall x :e SNoS_ alpha, forall y :e SNoS_ beta, forall z :e SNoS_ gamma, P x y z)
  ->
  (forall x y z, SNo x -> SNo y -> SNo z -> P x y z).
admit.
Qed.

Theorem SNoLev_ind : forall P:set -> prop,
  (forall x, SNo x -> (forall w :e SNoS_ (SNoLev x), P w) -> P x)
  ->
  (forall x, SNo x -> P x).
admit.
Qed.

Theorem SNoLev_ind2 : forall P:set -> set -> prop,
  (forall x y, SNo x -> SNo y
    -> (forall w :e SNoS_ (SNoLev x), P w y)
    -> (forall z :e SNoS_ (SNoLev y), P x z)
    -> (forall w :e SNoS_ (SNoLev x), forall z :e SNoS_ (SNoLev y), P w z)
    -> P x y)
-> forall x y, SNo x -> SNo y -> P x y.
admit.
Qed.

Theorem SNoLev_ind3 : forall P:set -> set -> set -> prop,
  (forall x y z, SNo x -> SNo y -> SNo z
    -> (forall u :e SNoS_ (SNoLev x), P u y z)
    -> (forall v :e SNoS_ (SNoLev y), P x v z)
    -> (forall w :e SNoS_ (SNoLev z), P x y w)
    -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), P u v z)
    -> (forall u :e SNoS_ (SNoLev x), forall w :e SNoS_ (SNoLev z), P u y w)
    -> (forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), P x v w)
    -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), P u v w)
    -> P x y z)
 -> forall x y z, SNo x -> SNo y -> SNo z -> P x y z.
admit.
Qed.

Theorem SNo_omega : SNo omega.
admit.
Qed.

Theorem SNoLt_0_1 : 0 < 1.
admit.
Qed.

Theorem SNoLt_0_2 : 0 < 2.
admit.
Qed.

Theorem SNoLt_1_2 : 1 < 2.
admit.
Qed.

Theorem restr_SNo_ : forall x, SNo x -> forall alpha :e SNoLev x, SNo_ alpha (x :/\: SNoElts_ alpha).
admit.
Qed.

Theorem restr_SNo : forall x, SNo x -> forall alpha :e SNoLev x, SNo (x :/\: SNoElts_ alpha).
admit.
Qed.

Theorem restr_SNoLev : forall x, SNo x -> forall alpha :e SNoLev x, SNoLev (x :/\: SNoElts_ alpha) = alpha.
admit.
Qed.

Theorem restr_SNoEq : forall x, SNo x -> forall alpha :e SNoLev x, SNoEq_ alpha (x :/\: SNoElts_ alpha) x.
admit.
Qed.

Theorem SNo_extend0_restr_eq : forall x, SNo x -> x = SNo_extend0 x :/\: SNoElts_ (SNoLev x).
admit.
Qed.

Theorem SNo_extend1_restr_eq : forall x, SNo x -> x = SNo_extend1 x :/\: SNoElts_ (SNoLev x).
admit.
Qed.

Opaque eps_ SNo_rec2 SNo_rec_ii SNo_rec_i SNoLev SNo.

Section SurrealMinus.
(* Parameter minus_SNo "6d39c64862ac40c95c6f5e4ed5f02bb019279bfb0cda8c9bbe0e1b813b1e876c" "268a6c1da15b8fe97d37be85147bc7767b27098cdae193faac127195e8824808" *)
Definition minus_SNo : set -> set
  := SNo_rec_i (fun x m => SNoCut {m z|z :e SNoR x} {m w|w :e SNoL x}).
Prefix - 358 := minus_SNo.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.

Theorem minus_SNo_eq : forall x, SNo x -> - x = SNoCut {- z|z :e SNoR x} {- w|w :e SNoL x}.
admit.
Qed.

Theorem minus_SNo_prop1 : forall x, SNo x -> SNo (- x) /\ (forall u :e SNoL x, - x < - u) /\ (forall u :e SNoR x, - u < - x) /\ SNoCutP {- z|z :e SNoR x} {- w|w :e SNoL x}.
admit.
Qed.

Theorem SNo_minus_SNo : forall x, SNo x -> SNo (- x).
admit.
Qed.

Theorem minus_SNo_Lt_contra : forall x y, SNo x -> SNo y -> x < y -> - y < - x.
admit.
Qed.

Theorem minus_SNo_Le_contra : forall x y, SNo x -> SNo y -> x <= y -> - y <= - x.
admit.
Qed.

Theorem minus_SNo_SNoCutP : forall x, SNo x -> SNoCutP {- z|z :e SNoR x} {- w|w :e SNoL x}.
admit.
Qed.

Theorem minus_SNo_SNoCutP_gen : forall L R, SNoCutP L R -> SNoCutP {- z|z :e R} {- w|w :e L}.
admit.
Qed.

Theorem minus_SNo_Lev_lem1 : forall alpha, ordinal alpha -> forall x :e SNoS_ alpha, SNoLev (- x) c= SNoLev x.
admit.
Qed.

Theorem minus_SNo_Lev_lem2 : forall x, SNo x -> SNoLev (- x) c= SNoLev x.
admit.
Qed.

Theorem minus_SNo_invol : forall x, SNo x -> - - x = x.
admit.
Qed.

Theorem minus_SNo_Lev : forall x, SNo x -> SNoLev (- x) = SNoLev x.
admit.
Qed.

Theorem minus_SNo_SNo_ : forall alpha, ordinal alpha -> forall x, SNo_ alpha x -> SNo_ alpha (- x).
admit.
Qed.

Theorem minus_SNo_SNoS_ : forall alpha, ordinal alpha -> forall x, x :e SNoS_ alpha -> - x :e SNoS_ alpha.
admit.
Qed.

Theorem minus_SNoCut_eq_lem : forall v, SNo v -> forall L R, SNoCutP L R -> v = SNoCut L R -> - v = SNoCut {- z|z :e R} {- w|w :e L}.
admit.
Qed.

Theorem minus_SNoCut_eq : forall L R, SNoCutP L R -> - SNoCut L R = SNoCut {- z|z :e R} {- w|w :e L}.
admit.
Qed.

Theorem minus_SNo_Lt_contra1 : forall x y, SNo x -> SNo y -> -x < y -> - y < x.
admit.
Qed.

Theorem minus_SNo_Lt_contra2 : forall x y, SNo x -> SNo y -> x < -y -> y < - x.
admit.
Qed.

Theorem mordinal_SNoLev_min_2 : forall alpha, ordinal alpha -> forall z, SNo z -> SNoLev z :e ordsucc alpha -> - alpha <= z.
admit.
Qed.

Theorem minus_SNo_SNoS_omega : forall x :e SNoS_ omega, - x :e SNoS_ omega.
admit.
Qed.

Theorem SNoL_minus_SNoR: forall x, SNo x -> SNoL (- x) = {- w|w :e SNoR x}.
admit.
Qed.

End SurrealMinus.
Opaque minus_SNo.
Section SurrealAdd.
Prefix - 358 := minus_SNo.
(* Parameter add_SNo "29b9b279a7a5b776b777d842e678a4acaf3b85b17a0223605e4cc68025e9b2a7" "127d043261bd13d57aaeb99e7d2c02cae2bd0698c0d689b03e69f1ac89b3c2c6" *)
Definition add_SNo : set -> set -> set
  := SNo_rec2 (fun x y a => SNoCut ({a w y|w :e SNoL x} :\/: {a x w|w :e SNoL y}) ({a z y|z :e SNoR x} :\/: {a x z|z :e SNoR y})).
Infix + 360 right := add_SNo.

Theorem add_SNo_eq : forall x, SNo x -> forall y, SNo y ->
    x + y = SNoCut ({w + y|w :e SNoL x} :\/: {x + w|w :e SNoL y}) ({z + y|z :e SNoR x} :\/: {x + z|z :e SNoR y}).
admit.
Qed.

Theorem add_SNo_prop1 : forall x y, SNo x -> SNo y ->
    SNo (x + y)
 /\ (forall u :e SNoL x, u + y < x + y)
 /\ (forall u :e SNoR x, x + y < u + y)
 /\ (forall u :e SNoL y, x + u < x + y)
 /\ (forall u :e SNoR y, x + y < x + u)
 /\ SNoCutP ({w + y|w :e SNoL x} :\/: {x + w|w :e SNoL y}) ({z + y|z :e SNoR x} :\/: {x + z|z :e SNoR y}).
admit.
Qed.

Theorem SNo_add_SNo : forall x y, SNo x -> SNo y -> SNo (x + y).
admit.
Qed.

Theorem SNo_add_SNo_3 : forall x y z, SNo x -> SNo y -> SNo z -> SNo (x + y + z).
admit.
Qed.

Theorem SNo_add_SNo_3c : forall x y z, SNo x -> SNo y -> SNo z -> SNo (x + y + - z).
admit.
Qed.

Theorem SNo_add_SNo_4 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> SNo (x + y + z + w).
admit.
Qed.

Theorem add_SNo_Lt1 : forall x y z, SNo x -> SNo y -> SNo z -> x < z -> x + y < z + y.
admit.
Qed.

Theorem add_SNo_Le1 : forall x y z, SNo x -> SNo y -> SNo z -> x <= z -> x + y <= z + y.
admit.
Qed.

Theorem add_SNo_Lt2 : forall x y z, SNo x -> SNo y -> SNo z -> y < z -> x + y < x + z.
admit.
Qed.

Theorem add_SNo_Le2 : forall x y z, SNo x -> SNo y -> SNo z -> y <= z -> x + y <= x + z.
admit.
Qed.

Theorem add_SNo_Lt3a : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x < z -> y <= w -> x + y < z + w.
admit.
Qed.

Theorem add_SNo_Lt3b : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x <= z -> y < w -> x + y < z + w.
admit.
Qed.

Theorem add_SNo_Lt3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x < z -> y < w -> x + y < z + w.
admit.
Qed.

Theorem add_SNo_Le3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x <= z -> y <= w -> x + y <= z + w.
admit.
Qed.

Theorem add_SNo_SNoCutP : forall x y, SNo x -> SNo y -> SNoCutP ({w + y|w :e SNoL x} :\/: {x + w|w :e SNoL y}) ({z + y|z :e SNoR x} :\/: {x + z|z :e SNoR y}).
admit.
Qed.

Theorem add_SNo_com : forall x y, SNo x -> SNo y -> x + y = y + x.
admit.
Qed.

Theorem add_SNo_0L : forall x, SNo x -> 0 + x = x.
admit.
Qed.

Theorem add_SNo_0R : forall x, SNo x -> x + 0 = x.
admit.
Qed.

Theorem add_SNo_minus_SNo_linv : forall x, SNo x -> -x+x = 0.
admit.
Qed.

Theorem add_SNo_minus_SNo_rinv : forall x, SNo x -> x + -x = 0.
admit.
Qed.

Theorem add_SNo_ordinal_SNoCutP : forall alpha, ordinal alpha -> forall beta, ordinal beta -> SNoCutP ({x + beta | x :e SNoS_ alpha} :\/: {alpha + x | x :e SNoS_ beta}) Empty.
admit.
Qed.

Theorem add_SNo_ordinal_eq : forall alpha, ordinal alpha -> forall beta, ordinal beta -> alpha + beta = SNoCut ({x + beta | x :e SNoS_ alpha} :\/: {alpha + x | x :e SNoS_ beta}) Empty.
admit.
Qed.

Theorem add_SNo_ordinal_ordinal : forall alpha, ordinal alpha -> forall beta, ordinal beta -> ordinal (alpha + beta).
admit.
Qed.

Theorem add_SNo_ordinal_SL : forall alpha, ordinal alpha -> forall beta, ordinal beta -> ordsucc alpha + beta = ordsucc (alpha + beta).
admit.
Qed.

Theorem add_SNo_ordinal_SR : forall alpha, ordinal alpha -> forall beta, ordinal beta -> alpha + ordsucc beta = ordsucc (alpha + beta).
admit.
Qed.

Theorem add_SNo_ordinal_InL : forall alpha, ordinal alpha -> forall beta, ordinal beta -> forall gamma :e alpha, gamma + beta :e alpha + beta.
admit.
Qed.

Theorem add_SNo_ordinal_InR : forall alpha, ordinal alpha -> forall beta, ordinal beta -> forall gamma :e beta, alpha + gamma :e alpha + beta.
admit.
Qed.

Theorem add_nat_add_SNo : forall n m :e omega, add_nat n m = n + m.
admit.
Qed.

Theorem add_SNo_In_omega : forall n m :e omega, n + m :e omega.
admit.
Qed.

Theorem add_SNo_1_1_2 : 1 + 1 = 2.
admit.
Qed.

Theorem add_SNo_SNoL_interpolate : forall x y, SNo x -> SNo y -> forall u :e SNoL (x + y), (exists v :e SNoL x, u <= v + y) \/ (exists v :e SNoL y, u <= x + v).
admit.
Qed.

Theorem add_SNo_SNoR_interpolate : forall x y, SNo x -> SNo y -> forall u :e SNoR (x + y), (exists v :e SNoR x, v + y <= u) \/ (exists v :e SNoR y, x + v <= u).
admit.
Qed.

Theorem add_SNo_assoc : forall x y z, SNo x -> SNo y -> SNo z -> x + (y + z) = (x + y) + z.
admit.
Qed.

Theorem add_SNo_minus_R2 : forall x y, SNo x -> SNo y -> (x + y) + - y = x.
admit.
Qed.

Theorem add_SNo_minus_R2' : forall x y, SNo x -> SNo y -> (x + - y) + y = x.
admit.
Qed.

Theorem add_SNo_minus_L2 : forall x y, SNo x -> SNo y -> - x + (x + y) = y.
admit.
Qed.

Theorem add_SNo_minus_L2' : forall x y, SNo x -> SNo y -> x + (- x + y) = y.
admit.
Qed.

Theorem add_SNo_cancel_L : forall x y z, SNo x -> SNo y -> SNo z -> x + y = x + z -> y = z.
admit.
Qed.

Theorem add_SNo_cancel_R : forall x y z, SNo x -> SNo y -> SNo z -> x + y = z + y -> x = z.
admit.
Qed.

Theorem minus_SNo_0 : - 0 = 0.
admit.
Qed.

Theorem minus_add_SNo_distr : forall x y, SNo x -> SNo y -> -(x+y) = (-x) + (-y).
admit.
Qed.

Theorem minus_add_SNo_distr_3 : forall x y z, SNo x -> SNo y -> SNo z -> -(x + y + z) = -x + - y + -z.
admit.
Qed.

Theorem add_SNo_Lev_bd : forall x y, SNo x -> SNo y -> SNoLev (x + y) c= SNoLev x + SNoLev y.
admit.
Qed.

Theorem add_SNo_SNoS_omega : forall x y :e SNoS_ omega, x + y :e SNoS_ omega.
admit.
Qed.

Theorem add_SNo_Lt1_cancel : forall x y z, SNo x -> SNo y -> SNo z -> x + y < z + y -> x < z.
admit.
Qed.

Theorem add_SNo_Lt2_cancel : forall x y z, SNo x -> SNo y -> SNo z -> x + y < x + z -> y < z.
admit.
Qed.

Theorem add_SNo_Le1_cancel : forall x y z, SNo x -> SNo y -> SNo z -> x + y <= z + y -> x <= z.
admit.
Qed.

Theorem add_SNo_assoc_4 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w
  -> x + y + z + w = (x + y + z) + w.
admit.
Qed.

Theorem add_SNo_com_3_0_1 : forall x y z, SNo x -> SNo y -> SNo z
  -> x + y + z = y + x + z.
admit.
Qed.

Theorem add_SNo_com_3b_1_2 : forall x y z, SNo x -> SNo y -> SNo z
  -> (x + y) + z = (x + z) + y.
admit.
Qed.

Theorem add_SNo_com_4_inner_mid : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w
  -> (x + y) + (z + w) = (x + z) + (y + w).
admit.
Qed.

Theorem add_SNo_rotate_3_1 : forall x y z, SNo x -> SNo y -> SNo z ->
  x + y + z = z + x + y.
admit.
Qed.

Theorem add_SNo_rotate_4_1 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w ->
  x + y + z + w = w + x + y + z.
admit.
Qed.

Theorem add_SNo_rotate_5_1 : forall x y z w v, SNo x -> SNo y -> SNo z -> SNo w -> SNo v ->
  x + y + z + w + v = v + x + y + z + w.
admit.
Qed.

Theorem add_SNo_rotate_5_2 : forall x y z w v, SNo x -> SNo y -> SNo z -> SNo w -> SNo v ->
  x + y + z + w + v = w + v + x + y + z.
admit.
Qed.

Theorem add_SNo_minus_SNo_prop2 : forall x y, SNo x -> SNo y -> x + - x + y = y.
admit.
Qed.

Theorem add_SNo_minus_SNo_prop3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> (x + y + z) + (- z + w) = x + y + w.
admit.
Qed.

Theorem add_SNo_minus_SNo_prop5 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> (x + y + - z) + (z + w) = x + y + w.
admit.
Qed.

Theorem add_SNo_minus_Lt1 : forall x y z, SNo x -> SNo y -> SNo z -> x + - y < z -> x < z + y.
admit.
Qed.

Theorem add_SNo_minus_Lt2 : forall x y z, SNo x -> SNo y -> SNo z -> z < x + - y -> z + y < x.
admit.
Qed.

Theorem add_SNo_minus_Lt1b : forall x y z, SNo x -> SNo y -> SNo z -> x < z + y -> x + - y < z.
admit.
Qed.

Theorem add_SNo_minus_Lt2b : forall x y z, SNo x -> SNo y -> SNo z -> z + y < x -> z < x + - y.
admit.
Qed.

Theorem add_SNo_minus_Lt1b3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x + y < w + z -> x + y + - z < w.
admit.
Qed.

Theorem add_SNo_minus_Lt2b3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> w + z < x + y -> w < x + y + - z.
admit.
Qed.

Theorem add_SNo_minus_Lt_lem : forall x y z u v w, SNo x -> SNo y -> SNo z -> SNo u -> SNo v -> SNo w ->
  x + y + w < u + v + z ->
  x + y + - z < u + v + - w.
admit.
Qed.

Theorem add_SNo_minus_Le2 : forall x y z, SNo x -> SNo y -> SNo z -> z <= x + - y -> z + y <= x.
admit.
Qed.

Theorem add_SNo_minus_Le2b : forall x y z, SNo x -> SNo y -> SNo z -> z + y <= x -> z <= x + - y.
admit.
Qed.

Theorem add_SNo_Lt_subprop2 : forall x y z w u v, SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo v
  -> x + u < z + v
  -> y + v < w + u
  -> x + y < z + w.
admit.
Qed.

Theorem add_SNo_Lt_subprop3a : forall x y z w u a, SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo a
  -> x + z < w + a
  -> y + a < u
  -> x + y + z < w + u.
admit.
Qed.

Theorem add_SNo_Lt_subprop3b : forall x y w u v a, SNo x -> SNo y -> SNo w -> SNo u -> SNo v -> SNo a
  -> x + a < w + v
  -> y < a + u
  -> x + y < w + u + v.
admit.
Qed.

Theorem add_SNo_Lt_subprop3c : forall x y z w u a b c, SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo a -> SNo b -> SNo c
 -> x + a < b + c
 -> y + c < u
 -> b + z < w + a
 -> x + y + z < w + u.
admit.
Qed.

Theorem add_SNo_Lt_subprop3d : forall x y w u v a b c, SNo x -> SNo y -> SNo w -> SNo u -> SNo v -> SNo a -> SNo b -> SNo c
 -> x + a < b + v
 -> y < c + u
 -> b + c < w + a
 -> x + y < w + u + v.
admit.
Qed.

Theorem ordinal_ordsucc_SNo_eq : forall alpha, ordinal alpha -> ordsucc alpha = 1 + alpha.
admit.
Qed.

Theorem add_SNo_3a_2b: forall x y z w u, SNo x -> SNo y -> SNo z -> SNo w -> SNo u
 -> (x + y + z) + (w + u) = (u + y + z) + (w + x).
admit.
Qed.

Theorem add_SNo_1_ordsucc : forall n :e omega, n + 1 = ordsucc n.
admit.
Qed.

Theorem add_SNo_eps_Lt : forall x, SNo x -> forall n :e omega, x < x + eps_ n.
admit.
Qed.

Theorem add_SNo_eps_Lt' : forall x y, SNo x -> SNo y -> forall n :e omega, x < y -> x < y + eps_ n.
admit.
Qed.

Theorem SNoLt_minus_pos : forall x y, SNo x -> SNo y -> x < y -> 0 < y + - x.
admit.
Qed.

Theorem add_SNo_omega_In_cases: forall m, forall n :e omega, forall k, nat_p k -> m :e n + k -> m :e n \/ m + - n :e k.
admit.
Qed.

Theorem add_SNo_Lt4 : forall x y z w u v, SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo v -> x < w -> y < u -> z < v -> x + y + z < w + u + v.
admit.
Qed.

Theorem add_SNo_3_3_3_Lt1 : forall x y z w u, SNo x -> SNo y -> SNo z -> SNo w -> SNo u ->
  x + y < z + w -> x + y + u < z + w + u.
admit.
Qed.

Theorem add_SNo_3_2_3_Lt1 : forall x y z w u, SNo x -> SNo y -> SNo z -> SNo w -> SNo u ->
  y + x < z + w -> x + u + y < z + w + u.
admit.
Qed.

Theorem add_SNo_minus_Lt12b3: forall x y z w u v,
    SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo v
 -> x + y + v < w + u + z
 -> x + y + - z < w + u + - v.
admit.
Qed.

Theorem add_SNo_minus_Le1b : forall x y z, SNo x -> SNo y -> SNo z -> x <= z + y -> x + - y <= z.
admit.
Qed.

Theorem add_SNo_minus_Le1b3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x + y <= w + z -> x + y + - z <= w.
admit.
Qed.

Theorem add_SNo_minus_Le12b3: forall x y z w u v,
    SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo v
 -> x + y + v <= w + u + z
 -> x + y + - z <= w + u + - v.
admit.
Qed.

End SurrealAdd.

Opaque add_SNo.

Section SurrealAbs.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
(* Parameter abs_SNo "9f9389c36823b2e0124a7fe367eb786d080772b5171a5d059b10c47361cef0ef" "34f6dccfd6f62ca020248cdfbd473fcb15d8d9c5c55d1ec7c5ab6284006ff40f" *)
Definition abs_SNo : set -> set := fun x => if 0 <= x then x else - x.

Theorem nonneg_abs_SNo : forall x, 0 <= x -> abs_SNo x = x.
admit.
Qed.

Theorem not_nonneg_abs_SNo : forall x, ~(0 <= x) -> abs_SNo x = - x.
admit.
Qed.

Theorem pos_abs_SNo : forall x, 0 < x -> abs_SNo x = x.
admit.
Qed.

Theorem neg_abs_SNo : forall x, SNo x -> x < 0 -> abs_SNo x = - x.
admit.
Qed.

Theorem SNo_abs_SNo : forall x, SNo x -> SNo (abs_SNo x).
admit.
Qed.

Theorem abs_SNo_minus: forall x, SNo x -> abs_SNo (- x) = abs_SNo x.
admit.
Qed.

Theorem abs_SNo_dist_swap: forall x y, SNo x -> SNo y -> abs_SNo (x + - y) = abs_SNo (y + - x).
admit.
Qed.

End SurrealAbs.

Opaque abs_SNo.

Section SurrealMul.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
(* Parameter mul_SNo "f56bf39b8eea93d7f63da529dedb477ae1ab1255c645c47d8915623f364f2d6b" "48d05483e628cb37379dd5d279684d471d85c642fe63533c3ad520b84b18df9d" *)
Definition mul_SNo : set -> set -> set
  := SNo_rec2
      (fun x y m =>
        SNoCut ({m (w 0) y + m x (w 1) + - m (w 0) (w 1)|w :e SNoL x :*: SNoL y}
                  :\/:
                {m (z 0) y + m x (z 1) + - m (z 0) (z 1)|z :e SNoR x :*: SNoR y})
               ({m (w 0) y + m x (w 1) + - m (w 0) (w 1)|w :e SNoL x :*: SNoR y}
                  :\/:
                {m (z 0) y + m x (z 1) + - m (z 0) (z 1)|z :e SNoR x :*: SNoL y})).

Infix * 355 right := mul_SNo.

Theorem mul_SNo_eq : forall x, SNo x -> forall y, SNo y ->
   x * y
      = SNoCut ({(w 0) * y + x * (w 1) + - (w 0) * (w 1)|w :e SNoL x :*: SNoL y}
                  :\/:
                {(z 0) * y + x * (z 1) + - (z 0) * (z 1)|z :e SNoR x :*: SNoR y})
               ({(w 0) * y + x * (w 1) + - (w 0) * (w 1)|w :e SNoL x :*: SNoR y}
                  :\/:
                {(z 0) * y + x * (z 1) + - (z 0) * (z 1)|z :e SNoR x :*: SNoL y}).
admit.
Qed.

Theorem mul_SNo_eq_2 : forall x y, SNo x -> SNo y ->
  forall p:prop,
    (forall L R,
         (forall u, u :e L ->
           (forall q:prop,
                (forall w0 :e SNoL x, forall w1 :e SNoL y, u = w0 * y + x * w1 + - w0 * w1 -> q)
             -> (forall z0 :e SNoR x, forall z1 :e SNoR y, u = z0 * y + x * z1 + - z0 * z1 -> q)
             -> q))
      -> (forall w0 :e SNoL x, forall w1 :e SNoL y, w0 * y + x * w1 + - w0 * w1 :e L)
      -> (forall z0 :e SNoR x, forall z1 :e SNoR y, z0 * y + x * z1 + - z0 * z1 :e L)
      -> (forall u, u :e R ->
           (forall q:prop,
                (forall w0 :e SNoL x, forall z1 :e SNoR y, u = w0 * y + x * z1 + - w0 * z1 -> q)
             -> (forall z0 :e SNoR x, forall w1 :e SNoL y, u = z0 * y + x * w1 + - z0 * w1 -> q)
             -> q))
      -> (forall w0 :e SNoL x, forall z1 :e SNoR y, w0 * y + x * z1 + - w0 * z1 :e R)
      -> (forall z0 :e SNoR x, forall w1 :e SNoL y, z0 * y + x * w1 + - z0 * w1 :e R)
      -> x * y = SNoCut L R
      -> p)
   -> p.
admit.
Qed.

Theorem mul_SNo_prop_1 : forall x, SNo x -> forall y, SNo y ->
 forall p:prop,
    (SNo (x * y)
  -> (forall u :e SNoL x, forall v :e SNoL y, u * y + x * v < x * y + u * v)
  -> (forall u :e SNoR x, forall v :e SNoR y, u * y + x * v < x * y + u * v)
  -> (forall u :e SNoL x, forall v :e SNoR y, x * y + u * v < u * y + x * v)
  -> (forall u :e SNoR x, forall v :e SNoL y, x * y + u * v < u * y + x * v)
  -> p)
 -> p.
admit.
Qed.

Theorem SNo_mul_SNo : forall x y, SNo x -> SNo y -> SNo (x * y).
admit.
Qed.

Theorem SNo_mul_SNo_lem : forall x y u v, SNo x -> SNo y -> SNo u -> SNo v -> SNo (u * y + x * v + - (u * v)).
admit.
Qed.

Theorem SNo_mul_SNo_3 : forall x y z, SNo x -> SNo y -> SNo z -> SNo (x * y * z).
admit.
Qed.

Theorem mul_SNo_eq_3 : forall x y, SNo x -> SNo y ->
  forall p:prop,
    (forall L R, SNoCutP L R
       -> (forall u, u :e L ->
           (forall q:prop,
                (forall w0 :e SNoL x, forall w1 :e SNoL y, u = w0 * y + x * w1 + - w0 * w1 -> q)
             -> (forall z0 :e SNoR x, forall z1 :e SNoR y, u = z0 * y + x * z1 + - z0 * z1 -> q)
             -> q))
      -> (forall w0 :e SNoL x, forall w1 :e SNoL y, w0 * y + x * w1 + - w0 * w1 :e L)
      -> (forall z0 :e SNoR x, forall z1 :e SNoR y, z0 * y + x * z1 + - z0 * z1 :e L)
      -> (forall u, u :e R ->
           (forall q:prop,
                (forall w0 :e SNoL x, forall z1 :e SNoR y, u = w0 * y + x * z1 + - w0 * z1 -> q)
             -> (forall z0 :e SNoR x, forall w1 :e SNoL y, u = z0 * y + x * w1 + - z0 * w1 -> q)
             -> q))
      -> (forall w0 :e SNoL x, forall z1 :e SNoR y, w0 * y + x * z1 + - w0 * z1 :e R)
      -> (forall z0 :e SNoR x, forall w1 :e SNoL y, z0 * y + x * w1 + - z0 * w1 :e R)
      -> x * y = SNoCut L R
      -> p)
   -> p.
admit.
Qed.

Theorem mul_SNo_Lt : forall x y u v, SNo x -> SNo y -> SNo u -> SNo v
 -> u < x -> v < y -> u * y + x * v < x * y + u * v.
admit.
Qed.

Theorem mul_SNo_Le : forall x y u v, SNo x -> SNo y -> SNo u -> SNo v
 -> u <= x -> v <= y -> u * y + x * v <= x * y + u * v.
admit.
Qed.

Theorem mul_SNo_SNoL_interpolate : forall x y, SNo x -> SNo y -> forall u :e SNoL (x * y),
 (exists v :e SNoL x, exists w :e SNoL y, u + v * w <= v * y + x * w)
 \/
 (exists v :e SNoR x, exists w :e SNoR y, u + v * w <= v * y + x * w).
admit.
Qed.

Theorem mul_SNo_SNoL_interpolate_impred : forall x y, SNo x -> SNo y -> forall u :e SNoL (x * y),
 forall p:prop,
      (forall v :e SNoL x, forall w :e SNoL y, u + v * w <= v * y + x * w -> p)
   -> (forall v :e SNoR x, forall w :e SNoR y, u + v * w <= v * y + x * w -> p)
   -> p.
admit.
Qed.  

Theorem mul_SNo_SNoR_interpolate : forall x y, SNo x -> SNo y -> forall u :e SNoR (x * y),
 (exists v :e SNoL x, exists w :e SNoR y, v * y + x * w <= u + v * w)
 \/
 (exists v :e SNoR x, exists w :e SNoL y, v * y + x * w <= u + v * w).
admit.
Qed.

Theorem mul_SNo_SNoR_interpolate_impred : forall x y, SNo x -> SNo y -> forall u :e SNoR (x * y),
 forall p:prop,
     (forall v :e SNoL x, forall w :e SNoR y, v * y + x * w <= u + v * w -> p)
  -> (forall v :e SNoR x, forall w :e SNoL y, v * y + x * w <= u + v * w -> p)
  -> p.
admit.
Qed.

(** This could be useful for proving L c= L', L = L', R c= R' or R = R'
    when corresponding conditions hold. **)
Theorem mul_SNo_Subq_lem : forall x y X Y Z W,
  forall U U',
      (forall u, u :e U ->
         (forall q:prop,
                (forall w0 :e X, forall w1 :e Y, u = w0 * y + x * w1 + - w0 * w1 -> q)
             -> (forall z0 :e Z, forall z1 :e W, u = z0 * y + x * z1 + - z0 * z1 -> q)
             -> q))
   -> (forall w0 :e X, forall w1 :e Y, w0 * y + x * w1 + - w0 * w1 :e U')
   -> (forall w0 :e Z, forall w1 :e W, w0 * y + x * w1 + - w0 * w1 :e U')
   -> U c= U'.
admit.
Qed.

(** Part of Conway Chapter 2 Theorem 7 **)
Theorem mul_SNo_zeroR : forall x, SNo x -> x * 0 = 0.
admit.
Qed.

Theorem mul_SNo_oneR : forall x, SNo x -> x * 1 = x.
admit.
Qed.

Theorem mul_SNo_com : forall x y, SNo x -> SNo y -> x * y = y * x.
admit.
Qed.

Theorem mul_SNo_minus_distrL : forall x y, SNo x -> SNo y -> (- x) * y = - x * y.
admit.
Qed.

Theorem mul_SNo_minus_distrR: forall x y, SNo x -> SNo y -> x * (- y) = - (x * y).
admit.
Qed.

Theorem mul_SNo_distrR : forall x y z, SNo x -> SNo y -> SNo z
  -> (x + y) * z = x * z + y * z.
admit.
Qed.

Theorem mul_SNo_distrL : forall x y z, SNo x -> SNo y -> SNo z
  -> x * (y + z) = x * y + x * z.
admit.
Qed.

Section mul_SNo_assoc_lems.
Variable M:set -> set -> set.
Infix * 355 right := M.
Hypothesis SNo_M : forall x y, SNo x -> SNo y -> SNo (x * y).
Hypothesis DL: forall x y z, SNo x -> SNo y -> SNo z -> x * (y + z) = x * y + x * z.
Hypothesis DR: forall x y z, SNo x -> SNo y -> SNo z -> (x + y) * z = x * z + y * z.
Hypothesis IL: forall x y, SNo x -> SNo y -> forall u :e SNoL (x * y),
 forall p:prop,
      (forall v :e SNoL x, forall w :e SNoL y, u + v * w <= v * y + x * w -> p)
   -> (forall v :e SNoR x, forall w :e SNoR y, u + v * w <= v * y + x * w -> p)
   -> p.
Hypothesis IR: forall x y, SNo x -> SNo y -> forall u :e SNoR (x * y),
 forall p:prop,
     (forall v :e SNoL x, forall w :e SNoR y, v * y + x * w <= u + v * w -> p)
  -> (forall v :e SNoR x, forall w :e SNoL y, v * y + x * w <= u + v * w -> p)
  -> p.
Hypothesis M_Lt: forall x y u v, SNo x -> SNo y -> SNo u -> SNo v
 -> u < x -> v < y -> u * y + x * v < x * y + u * v.
Hypothesis M_Le: forall x y u v, SNo x -> SNo y -> SNo u -> SNo v
 -> u <= x -> v <= y -> u * y + x * v <= x * y + u * v.

Theorem mul_SNo_assoc_lem1 : forall x y z, SNo x -> SNo y -> SNo z
 -> (forall u :e SNoS_ (SNoLev x), u * (y * z) = (u * y) * z)
 -> (forall v :e SNoS_ (SNoLev y), x * (v * z) = (x * v) * z)
 -> (forall w :e SNoS_ (SNoLev z), x * (y * w) = (x * y) * w)
 -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), u * (v * z) = (u * v) * z)
 -> (forall u :e SNoS_ (SNoLev x), forall w :e SNoS_ (SNoLev z), u * (y * w) = (u * y) * w)
 -> (forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), x * (v * w) = (x * v) * w)
 -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), u * (v * w) = (u * v) * w)
 -> forall L,
    (forall u :e L,
     forall q:prop,
         (forall v :e SNoL x, forall w :e SNoL (y * z), u = v * (y * z) + x * w + - v * w -> q)
      -> (forall v :e SNoR x, forall w :e SNoR (y * z), u = v * (y * z) + x * w + - v * w -> q)
      -> q)
 -> forall u :e L, u < (x * y) * z.
admit.
Qed.

Theorem mul_SNo_assoc_lem2 : forall x y z, SNo x -> SNo y -> SNo z
 -> (forall u :e SNoS_ (SNoLev x), u * (y * z) = (u * y) * z)
 -> (forall v :e SNoS_ (SNoLev y), x * (v * z) = (x * v) * z)
 -> (forall w :e SNoS_ (SNoLev z), x * (y * w) = (x * y) * w)
 -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), u * (v * z) = (u * v) * z)
 -> (forall u :e SNoS_ (SNoLev x), forall w :e SNoS_ (SNoLev z), u * (y * w) = (u * y) * w)
 -> (forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), x * (v * w) = (x * v) * w)
 -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), u * (v * w) = (u * v) * w)
 -> forall R,
    (forall u :e R,
     forall q:prop,
         (forall v :e SNoL x, forall w :e SNoR (y * z), u = v * (y * z) + x * w + - v * w -> q)
      -> (forall v :e SNoR x, forall w :e SNoL (y * z), u = v * (y * z) + x * w + - v * w -> q)
      -> q)
 -> forall u :e R, (x * y) * z < u.
admit.
Qed.

End mul_SNo_assoc_lems.

Theorem mul_SNo_assoc : forall x y z, SNo x -> SNo y -> SNo z
  -> x * (y * z) = (x * y) * z.
admit.
Qed.

Theorem mul_nat_mul_SNo : forall n m :e omega, mul_nat n m = n * m.
admit.
Qed.

Theorem mul_SNo_In_omega : forall n m :e omega, n * m :e omega.
admit.
Qed.

Theorem mul_SNo_zeroL : forall x, SNo x -> 0 * x = 0.
admit.
Qed.

Theorem mul_SNo_oneL : forall x, SNo x -> 1 * x = x.
admit.
Qed.

Theorem mul_SNo_rotate_3_1 : forall x y z, SNo x -> SNo y -> SNo z ->
  x * y * z = z * x * y.
admit.
Qed.

Theorem pos_mul_SNo_Lt : forall x y z, SNo x -> 0 < x -> SNo y -> SNo z -> y < z -> x * y < x * z.
admit.
Qed.

Theorem nonneg_mul_SNo_Le : forall x y z, SNo x -> 0 <= x -> SNo y -> SNo z -> y <= z -> x * y <= x * z.
admit.
Qed.

Theorem neg_mul_SNo_Lt : forall x y z, SNo x -> x < 0 -> SNo y -> SNo z -> z < y -> x * y < x * z.
admit.
Qed.

Theorem pos_mul_SNo_Lt' : forall x y z, SNo x -> SNo y -> SNo z -> 0 < z -> x < y -> x * z < y * z.
admit.
Qed.

Theorem mul_SNo_Lt1_pos_Lt : forall x y, SNo x -> SNo y -> x < 1 -> 0 < y -> x * y < y.
admit.
Qed.

Theorem nonneg_mul_SNo_Le' : forall x y z, SNo x -> SNo y -> SNo z -> 0 <= z -> x <= y -> x * z <= y * z.
admit.
Qed.

Theorem mul_SNo_Le1_nonneg_Le : forall x y, SNo x -> SNo y -> x <= 1 -> 0 <= y -> x * y <= y.
admit.
Qed.

Theorem pos_mul_SNo_Lt2 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> 0 < x -> 0 < y -> x < z -> y < w -> x * y < z * w.
admit.
Qed.

Theorem nonneg_mul_SNo_Le2 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> 0 <= x -> 0 <= y -> x <= z -> y <= w -> x * y <= z * w.
admit.
Qed.

Theorem mul_SNo_pos_pos: forall x y, SNo x -> SNo y -> 0 < x -> 0 < y -> 0 < x * y.
admit.
Qed.

Theorem mul_SNo_pos_neg: forall x y, SNo x -> SNo y -> 0 < x -> y < 0 -> x * y < 0.
admit.
Qed.

Theorem mul_SNo_neg_pos: forall x y, SNo x -> SNo y -> x < 0 -> 0 < y -> x * y < 0.
admit.
Qed.

Theorem mul_SNo_neg_neg: forall x y, SNo x -> SNo y -> x < 0 -> y < 0 -> 0 < x * y.
admit.
Qed.

Theorem mul_SNo_nonneg_nonneg: forall x y, SNo x -> SNo y -> 0 <= x -> 0 <= y -> 0 <= x * y.
admit.
Qed.

Theorem mul_SNo_nonpos_pos: forall x y, SNo x -> SNo y -> x <= 0 -> 0 < y -> x * y <= 0.
admit.
Qed.

Theorem mul_SNo_nonpos_neg: forall x y, SNo x -> SNo y -> x <= 0 -> y < 0 -> 0 <= x * y.
admit.
Qed.

Theorem nonpos_mul_SNo_Le : forall x y z, SNo x -> x <= 0 -> SNo y -> SNo z -> z <= y -> x * y <= x * z.
admit.
Qed.

Theorem SNo_zero_or_sqr_pos : forall x, SNo x -> x = 0 \/ 0 < x * x.
admit.
Qed.

Theorem SNo_pos_sqr_uniq: forall x y, SNo x -> SNo y -> 0 < x -> 0 < y -> x * x = y * y -> x = y.
admit.
Qed.

Theorem SNo_nonneg_sqr_uniq: forall x y, SNo x -> SNo y -> 0 <= x -> 0 <= y -> x * x = y * y -> x = y.
admit.
Qed.

Theorem SNo_foil: forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> (x + y) * (z + w) = x * z + x * w + y * z + y * w.
admit.
Qed.

Theorem mul_SNo_minus_minus: forall x y, SNo x -> SNo y -> (- x) * (- y) = x * y.
admit.
Qed.

Theorem mul_SNo_com_3_0_1 : forall x y z, SNo x -> SNo y -> SNo z
  -> x * y * z = y * x * z.
admit.
Qed.

Theorem mul_SNo_com_3b_1_2 : forall x y z, SNo x -> SNo y -> SNo z
  -> (x * y) * z = (x * z) * y.
admit.
Qed.

Theorem mul_SNo_com_4_inner_mid : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w
  -> (x * y) * (z * w) = (x * z) * (y * w).
admit.
Qed.

Theorem SNo_foil_mm: forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> (x + - y) * (z + - w) = x * z + - x * w + - y * z + y * w.
admit.
Qed.

Theorem mul_SNo_nonzero_cancel: forall x y z, SNo x -> x <> 0 -> SNo y -> SNo z -> x * y = x * z -> y = z.
admit.
Qed.

Theorem mul_SNoCutP_lem : forall Lx Rx Ly Ry x y,
    SNoCutP Lx Rx
 -> SNoCutP Ly Ry
 -> x = SNoCut Lx Rx
 -> y = SNoCut Ly Ry
 -> SNoCutP ({w 0 * y + x * w 1 + - w 0 * w 1|w :e Lx :*: Ly}
              :\/:
             {z 0 * y + x * z 1 + - z 0 * z 1|z :e Rx :*: Ry})
            ({w 0 * y + x * w 1 + - w 0 * w 1|w :e Lx :*: Ry}
              :\/:
             {z 0 * y + x * z 1 + - z 0 * z 1|z :e Rx :*: Ly})
 /\ x * y
  = SNoCut ({w 0 * y + x * w 1 + - w 0 * w 1|w :e Lx :*: Ly}
             :\/:
            {z 0 * y + x * z 1 + - z 0 * z 1|z :e Rx :*: Ry})
           ({w 0 * y + x * w 1 + - w 0 * w 1|w :e Lx :*: Ry}
             :\/:
            {z 0 * y + x * z 1 + - z 0 * z 1|z :e Rx :*: Ly})
 /\ forall q:prop,
     (forall LxLy' RxRy' LxRy' RxLy',
         (forall u :e LxLy', forall p:prop, (forall w :e Lx, forall w' :e Ly, SNo w -> SNo w' -> w < x -> w' < y -> u = w * y + x * w' + - w * w' -> p) -> p)
      -> (forall w :e Lx, forall w' :e Ly, w * y + x * w' + - w * w' :e LxLy')
      -> (forall u :e RxRy', forall p:prop, (forall z :e Rx, forall z' :e Ry, SNo z -> SNo z' -> x < z -> y < z' -> u = z * y + x * z' + - z * z' -> p) -> p)
      -> (forall z :e Rx, forall z' :e Ry, z * y + x * z' + - z * z' :e RxRy')
      -> (forall u :e LxRy', forall p:prop, (forall w :e Lx, forall z :e Ry, SNo w -> SNo z -> w < x -> y < z -> u = w * y + x * z + - w * z -> p) -> p)
      -> (forall w :e Lx, forall z :e Ry, w * y + x * z + - w * z :e LxRy')
      -> (forall u :e RxLy', forall p:prop, (forall z :e Rx, forall w :e Ly, SNo z -> SNo w -> x < z -> w < y -> u = z * y + x * w + - z * w -> p) -> p)
      -> (forall z :e Rx, forall w :e Ly, z * y + x * w + - z * w :e RxLy')
      -> SNoCutP (LxLy' :\/: RxRy') (LxRy' :\/: RxLy')
      -> x * y = SNoCut (LxLy' :\/: RxRy') (LxRy' :\/: RxLy')
      -> q)
    -> q.
admit.
Qed.

Theorem mul_SNoCut_abs : forall Lx Rx Ly Ry x y,
    SNoCutP Lx Rx
 -> SNoCutP Ly Ry
 -> x = SNoCut Lx Rx
 -> y = SNoCut Ly Ry
 -> forall q:prop,
     (forall LxLy' RxRy' LxRy' RxLy',
         (forall u :e LxLy', forall p:prop, (forall w :e Lx, forall w' :e Ly, SNo w -> SNo w' -> w < x -> w' < y -> u = w * y + x * w' + - w * w' -> p) -> p)
      -> (forall w :e Lx, forall w' :e Ly, w * y + x * w' + - w * w' :e LxLy')
      -> (forall u :e RxRy', forall p:prop, (forall z :e Rx, forall z' :e Ry, SNo z -> SNo z' -> x < z -> y < z' -> u = z * y + x * z' + - z * z' -> p) -> p)
      -> (forall z :e Rx, forall z' :e Ry, z * y + x * z' + - z * z' :e RxRy')
      -> (forall u :e LxRy', forall p:prop, (forall w :e Lx, forall z :e Ry, SNo w -> SNo z -> w < x -> y < z -> u = w * y + x * z + - w * z -> p) -> p)
      -> (forall w :e Lx, forall z :e Ry, w * y + x * z + - w * z :e LxRy')
      -> (forall u :e RxLy', forall p:prop, (forall z :e Rx, forall w :e Ly, SNo z -> SNo w -> x < z -> w < y -> u = z * y + x * w + - z * w -> p) -> p)
      -> (forall z :e Rx, forall w :e Ly, z * y + x * w + - z * w :e RxLy')
      -> SNoCutP (LxLy' :\/: RxRy') (LxRy' :\/: RxLy')
      -> x * y = SNoCut (LxLy' :\/: RxRy') (LxRy' :\/: RxLy')
      -> q)
    -> q.
admit.
Qed.

Theorem mul_SNo_SNoCut_SNoL_interpolate : forall Lx Rx Ly Ry,
    SNoCutP Lx Rx -> SNoCutP Ly Ry
 -> forall x y, x = SNoCut Lx Rx -> y = SNoCut Ly Ry
 -> forall u :e SNoL (x * y),
 (exists v :e Lx, exists w :e Ly, u + v * w <= v * y + x * w)
 \/
 (exists v :e Rx, exists w :e Ry, u + v * w <= v * y + x * w).
admit.
Qed.

Theorem mul_SNo_SNoCut_SNoL_interpolate_impred : forall Lx Rx Ly Ry,
    SNoCutP Lx Rx -> SNoCutP Ly Ry
 -> forall x y, x = SNoCut Lx Rx -> y = SNoCut Ly Ry
 -> forall u :e SNoL (x * y),
    forall p:prop,
        (forall v :e Lx, forall w :e Ly, u + v * w <= v * y + x * w -> p)
     -> (forall v :e Rx, forall w :e Ry, u + v * w <= v * y + x * w -> p)
     -> p.
admit.
Qed.

Theorem mul_SNo_SNoCut_SNoR_interpolate : forall Lx Rx Ly Ry,
    SNoCutP Lx Rx -> SNoCutP Ly Ry
 -> forall x y, x = SNoCut Lx Rx -> y = SNoCut Ly Ry
 -> forall u :e SNoR (x * y),
 (exists v :e Lx, exists w :e Ry, v * y + x * w <= u + v * w)
 \/
 (exists v :e Rx, exists w :e Ly, v * y + x * w <= u + v * w).
admit.
Qed.

Theorem mul_SNo_SNoCut_SNoR_interpolate_impred : forall Lx Rx Ly Ry,
    SNoCutP Lx Rx -> SNoCutP Ly Ry
 -> forall x y, x = SNoCut Lx Rx -> y = SNoCut Ly Ry
 -> forall u :e SNoR (x * y),
    forall p:prop,
        (forall v :e Lx, forall w :e Ry, v * y + x * w <= u + v * w -> p)
     -> (forall v :e Rx, forall w :e Ly, v * y + x * w <= u + v * w -> p)
     -> p.
admit.
Qed.

Theorem nonpos_nonneg_0 : forall m n :e omega, m = - n -> m = 0 /\ n = 0.
admit.
Qed.

Theorem mul_minus_SNo_distrR: forall x y, SNo x -> SNo y -> x * (- y) = - (x * y).
admit.
Qed.

End SurrealMul.

Opaque mul_SNo.

Section Int.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.

Definition int : set := omega :\/: {- n|n :e omega}.

Theorem int_SNo_cases : forall p:set -> prop,
    (forall n :e omega, p n)
 -> (forall n :e omega, p (- n))
 -> forall x :e int, p x.
admit.
Qed.

Theorem int_3_cases: forall n :e int, forall p:prop,
    (forall m :e omega, n = - ordsucc m -> p)
 -> (n = 0 -> p)
 -> (forall m :e omega, n = ordsucc m -> p)
 -> p.
admit.
Qed.

Theorem int_SNo : forall x :e int, SNo x.
admit.
Qed.

Theorem Subq_omega_int : omega c= int.
admit.
Qed.

Theorem int_minus_SNo_omega : forall n :e omega, - n :e int.
admit.
Qed.

Theorem int_add_SNo_lem: forall n :e omega, forall m, nat_p m -> - n + m :e int.
admit.
Qed.

Theorem int_add_SNo: forall x y :e int, x + y :e int.
admit.
Qed.

Theorem int_minus_SNo: forall x :e int, - x :e int.
admit.
Qed.

Theorem int_mul_SNo: forall x y :e int, x * y :e int.
admit.
Qed.

Theorem nonneg_int_nat_p: forall n :e int, 0 <= n -> nat_p n.
admit.
Qed.

End Int.

Section BezoutAndGCD.

Infix + 360 right := add_nat.
Infix * 355 right := mul_nat.

Theorem quotient_remainder_nat: forall n :e omega :\: {0}, forall m, nat_p m -> exists q :e omega, exists r :e n, m = q * n + r.
admit.
Qed.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix ^ 342 right := exp_SNo_nat.
Infix < 490 := SNoLt.
Infix <= 490 := SNoLe.

Theorem mul_SNo_nonpos_nonneg: forall x y, SNo x -> SNo y -> x <= 0 -> 0 <= y -> x * y <= 0.
admit.
Qed.

Theorem ordinal_0_In_ordsucc: forall alpha, ordinal alpha -> 0 :e ordsucc alpha.
admit.
Qed.

Theorem ordinal_ordsucc_pos: forall alpha, ordinal alpha -> 0 < ordsucc alpha.
admit.
Qed.

Theorem quotient_remainder_int: forall n :e omega :\: {0}, forall m :e int, exists q :e int, exists r :e n, m = q * n + r.
admit.
Qed.

Definition divides_int : set -> set -> prop := fun m n => m :e int /\ n :e int /\ exists k :e int, m * k = n.

Theorem divides_int_ref: forall n :e int, divides_int n n.
admit.
Qed.

Theorem divides_int_0: forall n :e int, divides_int n 0.
admit.
Qed.

Theorem divides_int_add_SNo: forall m n k, divides_int m n -> divides_int m k -> divides_int m (n + k).
admit.
Qed.

Theorem divides_int_mul_SNo: forall m n m' n', divides_int m m' -> divides_int n n' -> divides_int (m * n) (m' * n').
admit.
Qed.

Theorem divides_nat_divides_int: forall m n, divides_nat m n -> divides_int m n.
admit.
Qed.

Theorem divides_int_divides_nat: forall m n :e omega, divides_int m n -> divides_nat m n.
admit.
Qed.

Theorem divides_int_minus_SNo: forall m n, divides_int m n -> divides_int m (- n).
admit.
Qed.

Theorem divides_int_mul_SNo_L: forall m n, forall k :e int, divides_int m n -> divides_int m (n * k).
admit.
Qed.

Theorem divides_int_mul_SNo_R: forall m n, forall k :e int, divides_int m n -> divides_int m (k * n).
admit.
Qed.

Theorem divides_int_1: forall n :e int, divides_int 1 n.
admit.
Qed.

Theorem divides_int_pos_Le: forall m n, divides_int m n -> 0 < n -> m <= n.
admit.
Qed.

Definition gcd_reln : set -> set -> set -> prop := fun m n d => divides_int d m /\ divides_int d n /\ forall d', divides_int d' m -> divides_int d' n -> d' <= d.

Theorem gcd_reln_uniq: forall a b c d, gcd_reln a b c -> gcd_reln a b d -> c = d.
admit.
Qed.

Definition int_lin_comb : set -> set -> set -> prop := fun a b c => a :e int /\ b :e int /\ c :e int /\ exists m n :e int, m * a + n * b = c.

Theorem int_lin_comb_I: forall a b c :e int, (exists m n :e int, m * a + n * b = c) -> int_lin_comb a b c.
admit.
Qed.

Theorem int_lin_comb_E: forall a b c, int_lin_comb a b c ->
  forall p:prop,
       (a :e int -> b :e int -> c :e int -> forall m n :e int, m * a + n * b = c -> p)
    -> p.
admit.
Qed.

Theorem int_lin_comb_E1: forall a b c, int_lin_comb a b c -> a :e int.
admit.
Qed.

Theorem int_lin_comb_E2: forall a b c, int_lin_comb a b c -> b :e int.
admit.
Qed.

Theorem int_lin_comb_E3: forall a b c, int_lin_comb a b c -> c :e int.
admit.
Qed.

Theorem int_lin_comb_E4: forall a b c, int_lin_comb a b c ->
  forall p:prop,
       (forall m n :e int, m * a + n * b = c -> p)
    -> p.
admit.
Qed.

Theorem least_pos_int_lin_comb_ex: forall a b :e int, ~(a = 0 /\ b = 0) -> exists c, int_lin_comb a b c /\ 0 < c /\ forall c', int_lin_comb a b c' -> 0 < c' -> c <= c'.
admit.
Qed.

Theorem int_lin_comb_sym: forall a b d,
     int_lin_comb a b d
  -> int_lin_comb b a d.
admit.
Qed.
  
Theorem least_pos_int_lin_comb_divides_int: forall a b d,
     int_lin_comb a b d
  -> 0 < d
  -> (forall c, int_lin_comb a b c -> 0 < c -> d <= c)
  -> divides_int d a.
admit.
Qed.

Theorem least_pos_int_lin_comb_gcd: forall a b d,
     int_lin_comb a b d
  -> 0 < d
  -> (forall c, int_lin_comb a b c -> 0 < c -> d <= c)
  -> gcd_reln a b d.
admit.
Qed.

Theorem BezoutThm: forall a b :e int, ~(a = 0 /\ b = 0) ->
  forall d, gcd_reln a b d <-> int_lin_comb a b d /\ 0 < d /\ forall d', int_lin_comb a b d' -> 0 < d' -> d <= d'.
admit.
Qed.

Theorem gcd_id: forall m :e omega :\: {0}, gcd_reln m m m.
admit.
Qed.

Theorem gcd_0: forall m :e omega :\: {0}, gcd_reln 0 m m.
admit.
Qed.

Theorem gcd_sym: forall m n d, gcd_reln m n d -> gcd_reln n m d.
admit.
Qed.

Theorem gcd_minus: forall m n d, gcd_reln m n d -> gcd_reln m (- n) d.
admit.
Qed.

Theorem euclidean_algorithm_prop_1: forall m n d, n :e int -> gcd_reln m (n + - m) d -> gcd_reln m n d.
admit.
Qed.

Theorem euclidean_algorithm:
     (forall m :e omega :\: {0}, gcd_reln m m m)
  /\ (forall m :e omega :\: {0}, gcd_reln 0 m m)
  /\ (forall m :e omega :\: {0}, gcd_reln m 0 m)
  /\ (forall m n :e omega, m < n
          -> forall d, gcd_reln m (n + - m) d
                    -> gcd_reln m n d)
  /\ (forall m n :e omega, n < m
          -> forall d, gcd_reln n m d
                    -> gcd_reln m n d)
  /\ (forall m :e omega, forall n :e int, n < 0
          -> forall d, gcd_reln m (- n) d
                    -> gcd_reln m n d)
  /\ (forall m n :e int, m < 0
          -> forall d, gcd_reln (- m) n d
                    -> gcd_reln m n d).
admit.
Qed.

Theorem Euclid_lemma: forall p, prime_nat p -> forall a b :e int, divides_int p (a * b) -> divides_int p a \/ divides_int p b.
admit.
Qed.

End BezoutAndGCD.

Section PrimeFactorization.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix ^ 342 right := exp_SNo_nat.
Infix < 490 := SNoLt.
Infix <= 490 := SNoLe.

Theorem prime_not_divides_int_1: forall p, prime_nat p -> ~divides_int p 1.
admit.
Qed.

Definition Pi_SNo : (set -> set) -> set -> set := fun f n =>
  nat_primrec 1 (fun i r => r * f i) n.

Theorem Pi_SNo_0: forall f:set -> set, Pi_SNo f 0 = 1.
admit.
Qed.

Theorem Pi_SNo_S: forall f:set -> set, forall n, nat_p n -> Pi_SNo f (ordsucc n) = Pi_SNo f n * f n.
admit.
Qed.

Theorem Pi_SNo_In_omega: forall f:set -> set,
 forall n, nat_p n ->
     (forall i :e n, f i :e omega)
  -> Pi_SNo f n :e omega.
admit.
Qed.

Theorem Pi_SNo_In_int: forall f:set -> set,
 forall n, nat_p n ->
     (forall i :e n, f i :e int)
  -> Pi_SNo f n :e int.
admit.
Qed.

Theorem divides_int_prime_nat_eq: forall p q, prime_nat p -> prime_nat q -> divides_int p q -> p = q.
admit.
Qed.

Theorem Euclid_lemma_Pi_SNo: forall f:set->set,
  forall p, prime_nat p ->
  forall n, nat_p n ->
      (forall i :e n, f i :e int)
   -> divides_int p (Pi_SNo f n)
   -> exists i :e n, divides_int p (f i).
admit.
Qed.

Theorem divides_nat_mul_SNo_R: forall m n :e omega, divides_nat m (m * n).
admit.
Qed.

Theorem divides_nat_mul_SNo_L: forall m n :e omega, divides_nat n (m * n).
admit.
Qed.

Theorem Pi_SNo_divides: forall f:set->set,
  forall n, nat_p n ->
      (forall i :e n, f i :e omega)
   -> (forall i :e n, divides_nat (f i) (Pi_SNo f n)).
admit.
Qed.

Definition nonincrfinseq : (set -> prop) -> set -> (set -> set) -> prop := fun A n f => forall i :e n, A (f i) /\ forall j :e i, f i <= f j.

Theorem Pi_SNo_eq: forall f g:set->set,
  forall m, nat_p m
   -> (forall i :e m, f i = g i)
   -> Pi_SNo f m = Pi_SNo g m.
admit.
Qed.

Theorem prime_factorization_ex_uniq: forall n, nat_p n -> 0 :e n ->
  exists k :e omega, exists f:set -> set, nonincrfinseq prime_nat k f /\ Pi_SNo f k = n
    /\ forall k' :e omega, forall f':set -> set, nonincrfinseq prime_nat k' f' -> Pi_SNo f' k' = n
         -> k' = k /\ forall i :e k, f' i = f i.
admit.
Qed.

End PrimeFactorization.

Section SurrealExp.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Definition exp_SNo_nat : set->set->set := fun n m:set => nat_primrec 1 (fun _ r => n * r) m.
Infix ^ 342 right := exp_SNo_nat.

Theorem exp_SNo_nat_0 : forall x, SNo x -> x ^ 0 = 1.
admit.
Qed.

Theorem exp_SNo_nat_S : forall x, SNo x -> forall n, nat_p n -> x ^ (ordsucc n) = x * x ^ n.
admit.
Qed.

Theorem exp_SNo_nat_1: forall x, SNo x -> x ^ 1 = x.
admit.
Qed.

Theorem SNo_exp_SNo_nat : forall x, SNo x -> forall n, nat_p n -> SNo (x ^ n).
admit.
Qed.

Theorem nat_exp_SNo_nat : forall x, nat_p x -> forall n, nat_p n -> nat_p (x ^ n).
admit.
Qed.

Theorem eps_ordsucc_half_add : forall n, nat_p n -> eps_ (ordsucc n) + eps_ (ordsucc n) = eps_ n.
admit.
Qed.

Theorem eps_1_half_eq1 : eps_ 1 + eps_ 1 = 1.
admit.
Qed.

Theorem eps_1_half_eq2 : 2 * eps_ 1 = 1.
admit.
Qed.

Theorem double_eps_1 : forall x y z, SNo x -> SNo y -> SNo z -> x + x = y + z -> x = eps_ 1 * (y + z).
admit.
Qed.

Theorem exp_SNo_1_bd: forall x, SNo x -> 1 <= x -> forall n, nat_p n -> 1 <= x ^ n.
admit.
Qed.

Theorem exp_SNo_2_bd: forall n, nat_p n -> n < 2 ^ n.
admit.
Qed.

Theorem mul_SNo_eps_power_2: forall n, nat_p n -> eps_ n * 2 ^ n = 1.
admit.
Qed.

Theorem eps_bd_1 : forall n :e omega, eps_ n <= 1.
admit.
Qed.

Theorem mul_SNo_eps_power_2': forall n, nat_p n -> 2 ^ n * eps_ n = 1.
admit.
Qed.

Theorem exp_SNo_nat_mul_add : forall x, SNo x -> forall m, nat_p m -> forall n, nat_p n -> x ^ m * x ^ n = x ^ (m + n).
admit.
Qed.

Theorem exp_SNo_nat_mul_add' : forall x, SNo x -> forall m n :e omega, x ^ m * x ^ n = x ^ (m + n).
admit.
Qed.

Theorem exp_SNo_nat_pos : forall x, SNo x -> 0 < x -> forall n, nat_p n -> 0 < x ^ n.
admit.
Qed.

Theorem mul_SNo_eps_eps_add_SNo: forall m n :e omega, eps_ m * eps_ n = eps_ (m + n).
admit.
Qed.

Theorem SNoS_omega_Lev_equip : forall n, nat_p n -> equip {x :e SNoS_ omega|SNoLev x = n} (2 ^ n).
admit.
Qed.

Theorem SNoS_finite : forall n :e omega, finite (SNoS_ n).
admit.
Qed.

Theorem SNoS_omega_SNoL_finite : forall x :e SNoS_ omega, finite (SNoL x).
admit.
Qed.

Theorem SNoS_omega_SNoR_finite : forall x :e SNoS_ omega, finite (SNoR x).
admit.
Qed.

End SurrealExp.

Opaque exp_SNo_nat.

Section SNoMaxMin.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix ^ 342 right := exp_SNo_nat.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.
Definition SNo_max_of : set -> set -> prop := fun X x => x :e X /\ SNo x /\ forall y :e X, SNo y -> y <= x.
Definition SNo_min_of : set -> set -> prop := fun X x => x :e X /\ SNo x /\ forall y :e X, SNo y -> x <= y.

Theorem minus_SNo_max_min : forall X y, (forall x :e X, SNo x) -> SNo_max_of X y -> SNo_min_of {- x|x :e X} (- y).
admit.
Qed.

Theorem minus_SNo_max_min' : forall X y, (forall x :e X, SNo x) -> SNo_max_of {- x|x :e X} y -> SNo_min_of X (- y).
admit.
Qed.

Theorem minus_SNo_min_max : forall X y, (forall x :e X, SNo x) -> SNo_min_of X y -> SNo_max_of {- x|x :e X} (- y).
admit.
Qed.

Theorem double_SNo_max_1 : forall x y, SNo x -> SNo_max_of (SNoL x) y -> forall z, SNo z -> x < z -> y + z < x + x -> exists w :e SNoR z, y + w = x + x.
admit.
Qed.

Theorem double_SNo_min_1 : forall x y, SNo x -> SNo_min_of (SNoR x) y -> forall z, SNo z -> z < x -> x + x < y + z -> exists w :e SNoL z, y + w = x + x.
admit.
Qed.

Theorem finite_max_exists : forall X, (forall x :e X, SNo x) -> finite X -> X <> 0 -> exists x, SNo_max_of X x.
admit.
Qed.

Theorem finite_min_exists : forall X, (forall x :e X, SNo x) -> finite X -> X <> 0 -> exists x, SNo_min_of X x.
admit.
Qed.

Theorem SNoS_omega_SNoL_max_exists : forall x :e SNoS_ omega, SNoL x = 0 \/ exists y, SNo_max_of (SNoL x) y.
admit.
Qed.

Theorem SNoS_omega_SNoR_min_exists : forall x :e SNoS_ omega, SNoR x = 0 \/ exists y, SNo_min_of (SNoR x) y.
admit.
Qed.

End SNoMaxMin.

Section DiadicRationals.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.
Infix ^ 342 right := exp_SNo_nat.

Theorem nonneg_diadic_rational_p_SNoS_omega: forall k :e omega, forall n, nat_p n -> eps_ k * n :e SNoS_ omega.
admit.
Qed.

Definition diadic_rational_p : set -> prop := fun x => exists k :e omega, exists m :e int, x = eps_ k * m.

Theorem diadic_rational_p_SNoS_omega: forall x, diadic_rational_p x -> x :e SNoS_ omega.
admit.
Qed.

Theorem int_diadic_rational_p : forall m :e int, diadic_rational_p m.
admit.
Qed.

Theorem omega_diadic_rational_p : forall m :e omega, diadic_rational_p m.
admit.
Qed.

Theorem eps_diadic_rational_p : forall k :e omega, diadic_rational_p (eps_ k).
admit.
Qed.

Theorem minus_SNo_diadic_rational_p : forall x, diadic_rational_p x -> diadic_rational_p (- x).
admit.
Qed.

Theorem mul_SNo_diadic_rational_p : forall x y, diadic_rational_p x -> diadic_rational_p y -> diadic_rational_p (x * y).
admit.
Qed.

Theorem add_SNo_diadic_rational_p : forall x y, diadic_rational_p x -> diadic_rational_p y -> diadic_rational_p (x + y).
admit.
Qed.

Theorem SNoS_omega_diadic_rational_p_lem: forall n, nat_p n -> forall x, SNo x -> SNoLev x = n -> diadic_rational_p x.
admit.
Qed.

Theorem SNoS_omega_diadic_rational_p: forall x :e SNoS_ omega, diadic_rational_p x.
admit.
Qed.

Theorem mul_SNo_SNoS_omega : forall x y :e SNoS_ omega, x * y :e SNoS_ omega.
admit.
Qed.

End DiadicRationals.

Opaque int.

Section SurrealDiv.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.
Infix ^ 342 right := exp_SNo_nat.
Definition SNoL_pos : set -> set := fun x => {w :e SNoL x|0 < w}.

Theorem SNo_recip_pos_pos: forall x xi, SNo x -> SNo xi -> 0 < x -> x * xi = 1 -> 0 < xi.
admit.
Qed.

Theorem SNo_recip_lem1: forall x x' x'i y y', SNo x -> 0 < x -> x' :e SNoL_pos x -> SNo x'i -> x' * x'i = 1 -> SNo y -> x * y < 1 -> SNo y' -> 1 + - x * y' = (1 + - x * y) * (x' + - x) * x'i -> 1 < x * y'.
admit.
Qed.

Theorem SNo_recip_lem2: forall x x' x'i y y', SNo x -> 0 < x -> x' :e SNoL_pos x -> SNo x'i -> x' * x'i = 1 -> SNo y -> 1 < x * y -> SNo y' -> 1 + - x * y' = (1 + - x * y) * (x' + - x) * x'i -> x * y' < 1.
admit.
Qed.

Theorem SNo_recip_lem3: forall x x' x'i y y', SNo x -> 0 < x -> x' :e SNoR x -> SNo x'i -> x' * x'i = 1 -> SNo y -> x * y < 1 -> SNo y' -> 1 + - x * y' = (1 + - x * y) * (x' + - x) * x'i -> x * y' < 1.
admit.
Qed.

Theorem SNo_recip_lem4: forall x x' x'i y y', SNo x -> 0 < x -> x' :e SNoR x -> SNo x'i -> x' * x'i = 1 -> SNo y -> 1 < x * y -> SNo y' -> 1 + - x * y' = (1 + - x * y) * (x' + - x) * x'i -> 1 < x * y'.
admit.
Qed.

Definition SNo_recipauxset : set -> set -> set -> (set -> set) -> set := fun Y x X g => \/_ y :e Y, {(1 + (x' + - x) * y) * g x'|x' :e X}.

Theorem SNo_recipauxset_I: forall Y x X, forall g:set -> set,
 forall y :e Y, forall x' :e X, (1 + (x' + - x) * y) * g x' :e SNo_recipauxset Y x X g.
admit.
Qed.

Theorem SNo_recipauxset_E : forall Y x X, forall g:set -> set, forall z :e SNo_recipauxset Y x X g, forall p:prop, (forall y :e Y, forall x' :e X, z = (1 + (x' + - x) * y) * g x' -> p) -> p.
admit.
Qed.

Theorem SNo_recipauxset_ext: forall Y x X, forall g h:set -> set, (forall x' :e X, g x' = h x') -> SNo_recipauxset Y x X g = SNo_recipauxset Y x X h.
admit.
Qed.

Definition SNo_recipaux : set -> (set -> set) -> set -> set :=
 fun x g =>
  nat_primrec ({0},0)
   (fun k p => (p 0 :\/: SNo_recipauxset (p 0) x (SNoR x) g
                    :\/: SNo_recipauxset (p 1) x (SNoL_pos x) g,
                p 1 :\/: SNo_recipauxset (p 0) x (SNoL_pos x) g
                    :\/: SNo_recipauxset (p 1) x (SNoR x) g)).

Theorem SNo_recipaux_0: forall x, forall g:set -> set, SNo_recipaux x g 0 = ({0},0).
admit.
Qed.

Theorem SNo_recipaux_S: forall x, forall g:set -> set, forall n, nat_p n ->
   SNo_recipaux x g (ordsucc n)
 = (SNo_recipaux x g n 0 :\/: SNo_recipauxset (SNo_recipaux x g n 0) x (SNoR x) g
        :\/: SNo_recipauxset (SNo_recipaux x g n 1) x (SNoL_pos x) g,
    SNo_recipaux x g n 1 :\/: SNo_recipauxset (SNo_recipaux x g n 0) x (SNoL_pos x) g
        :\/: SNo_recipauxset (SNo_recipaux x g n 1) x (SNoR x) g).
admit.
Qed.

Theorem SNo_recipaux_lem1: forall x, SNo x -> 0 < x ->
 forall g:set -> set,
    (forall x' :e SNoS_ (SNoLev x), 0 < x' -> SNo (g x') /\ x' * g x' = 1)
 -> forall k, nat_p k ->
         (forall y :e SNo_recipaux x g k 0, SNo y /\ x * y < 1)
      /\ (forall y :e SNo_recipaux x g k 1, SNo y /\ 1 < x * y).
admit.
Qed.

Theorem SNo_recipaux_lem2: forall x, SNo x -> 0 < x ->
 forall g:set -> set,
    (forall x' :e SNoS_ (SNoLev x), 0 < x' -> SNo (g x') /\ x' * g x' = 1)
 -> SNoCutP (\/_ k :e omega, SNo_recipaux x g k 0) (\/_ k :e omega, SNo_recipaux x g k 1).
admit.
Qed.

Theorem SNo_recipaux_ext: forall x, SNo x -> forall g h:set -> set, (forall x' :e SNoS_ (SNoLev x), g x' = h x') -> forall k, nat_p k -> SNo_recipaux x g k = SNo_recipaux x h k.
admit.
Qed.

Section recip_SNo_pos.
Let G : set -> (set -> set) -> set := fun x g => SNoCut (\/_ k :e omega, SNo_recipaux x g k 0) (\/_ k :e omega, SNo_recipaux x g k 1).
Definition recip_SNo_pos : set -> set := SNo_rec_i G.

Theorem recip_SNo_pos_eq: forall x, SNo x -> recip_SNo_pos x = G x recip_SNo_pos.
admit.
Qed.

Theorem recip_SNo_pos_prop1: forall x, SNo x -> 0 < x -> SNo (recip_SNo_pos x) /\ x * recip_SNo_pos x = 1.
admit.
Qed.

Theorem SNo_recip_SNo_pos: forall x, SNo x -> 0 < x -> SNo (recip_SNo_pos x).
admit.
Qed.

Theorem recip_SNo_pos_invR: forall x, SNo x -> 0 < x -> x * recip_SNo_pos x = 1.
admit.
Qed.

Theorem recip_SNo_pos_is_pos: forall x, SNo x -> 0 < x -> 0 < recip_SNo_pos x.
admit.
Qed.

Theorem recip_SNo_pos_invol: forall x, SNo x -> 0 < x -> recip_SNo_pos (recip_SNo_pos x) = x.
admit.
Qed.

Theorem recip_SNo_pos_eps_: forall n, nat_p n -> recip_SNo_pos (eps_ n) = 2 ^ n.
admit.
Qed.

Theorem recip_SNo_pos_pow_2: forall n, nat_p n -> recip_SNo_pos (2 ^ n) = eps_ n.
admit.
Qed.

Theorem recip_SNo_pos_2: recip_SNo_pos 2 = eps_ 1.
admit.
Qed.

End recip_SNo_pos.
Definition recip_SNo : set -> set := fun x => if 0 < x then recip_SNo_pos x else if x < 0 then - recip_SNo_pos (- x) else 0.

Theorem recip_SNo_poscase: forall x, 0 < x -> recip_SNo x = recip_SNo_pos x.
admit.
Qed.

Theorem recip_SNo_negcase: forall x, SNo x -> x < 0 -> recip_SNo x = - recip_SNo_pos (- x).
admit.
Qed.

Theorem recip_SNo_0: recip_SNo 0 = 0.
admit.
Qed.

Theorem SNo_recip_SNo: forall x, SNo x -> SNo (recip_SNo x).
admit.
Qed.

Theorem recip_SNo_invR: forall x, SNo x -> x <> 0 -> x * recip_SNo x = 1.
admit.
Qed.

Theorem recip_SNo_invL: forall x, SNo x -> x <> 0 -> recip_SNo x * x = 1.
admit.
Qed.

Theorem mul_SNo_nonzero_cancel_L: forall x y z, SNo x -> x <> 0 -> SNo y -> SNo z -> x * y = x * z -> y = z.
admit.
Qed.

Theorem recip_SNo_pow_2 : forall n, nat_p n -> recip_SNo (2 ^ n) = eps_ n.
admit.
Qed.

Theorem recip_SNo_of_pos_is_pos: forall x, SNo x -> 0 < x -> 0 < recip_SNo x.
admit.
Qed.

Definition div_SNo : set -> set -> set := fun x y => x * recip_SNo y.

Infix :/: 353 := div_SNo.

Theorem SNo_div_SNo: forall x y, SNo x -> SNo y -> SNo (x :/: y).
admit.
Qed.

Theorem div_SNo_0_num: forall x, SNo x -> 0 :/: x = 0.
admit.
Qed.

Theorem div_SNo_0_denum: forall x, SNo x -> x :/: 0 = 0.
admit.
Qed.

Theorem mul_div_SNo_invL: forall x y, SNo x -> SNo y -> y <> 0 -> (x :/: y) * y = x.
admit.
Qed.

Theorem mul_div_SNo_invR: forall x y, SNo x -> SNo y -> y <> 0 -> y * (x :/: y) = x.
admit.
Qed.

Theorem mul_div_SNo_R: forall x y z, SNo x -> SNo y -> SNo z -> (x :/: y) * z = (x * z) :/: y.
admit.
Qed.

Theorem mul_div_SNo_L: forall x y z, SNo x -> SNo y -> SNo z -> z * (x :/: y) = (z * x) :/: y.
admit.
Qed.

Theorem div_mul_SNo_invL: forall x y, SNo x -> SNo y -> y <> 0 -> (x * y) :/: y = x.
admit.
Qed.

Theorem div_div_SNo: forall x y z, SNo x -> SNo y -> SNo z -> (x :/: y) :/: z = x :/: (y * z).
admit.
Qed.

Theorem mul_div_SNo_both: forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> (x :/: y) * (z :/: w) = (x * z) :/: (y * w).
admit.
Qed.

Theorem recip_SNo_pos_pos: forall x, SNo x -> 0 < x -> 0 < recip_SNo_pos x.
admit.
Qed.

Theorem div_SNo_pos_pos: forall x y, SNo x -> SNo y -> 0 < x -> 0 < y -> 0 < x :/: y.
admit.
Qed.

Theorem div_SNo_neg_pos: forall x y, SNo x -> SNo y -> x < 0 -> 0 < y -> x :/: y < 0.
admit.
Qed.

Theorem div_SNo_pos_LtL : forall x y z, SNo x -> SNo y -> SNo z -> 0 < y -> x < z * y -> x :/: y < z.
admit.
Qed.

Theorem div_SNo_pos_LtR : forall x y z, SNo x -> SNo y -> SNo z -> 0 < y -> z * y < x -> z < x :/: y.
admit.
Qed.

Theorem div_SNo_pos_LtL' : forall x y z, SNo x -> SNo y -> SNo z -> 0 < y -> x :/: y < z -> x < z * y.
admit.
Qed.

Theorem div_SNo_pos_LtR' : forall x y z, SNo x -> SNo y -> SNo z -> 0 < y -> z < x :/: y -> z * y < x.
admit.
Qed.

Theorem mul_div_SNo_nonzero_eq: forall x y z, SNo x -> SNo y -> SNo z -> y <> 0 -> x = y * z -> x :/: y = z.
admit.
Qed.

End SurrealDiv.

Opaque recip_SNo_pos recip_SNo.

Section Reals.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix :/: 353 := div_SNo.
Infix ^ 342 right := exp_SNo_nat.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.

Theorem SNoS_omega_drat_intvl : forall x :e SNoS_ omega,
  forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k.
admit.
Qed.

Theorem SNoS_ordsucc_omega_bdd_above : forall x :e SNoS_ (ordsucc omega), x < omega -> exists N :e omega, x < N.
admit.
Qed.

Theorem SNoS_ordsucc_omega_bdd_below : forall x :e SNoS_ (ordsucc omega), - omega < x -> exists N :e omega, - N < x.
admit.
Qed.

Theorem SNoS_ordsucc_omega_bdd_drat_intvl : forall x :e SNoS_ (ordsucc omega),
    - omega < x -> x < omega
 -> forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k.
admit.
Qed.

Definition real : set := {x :e SNoS_ (ordsucc omega)| x <> omega /\ x <> - omega /\ (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)}.

Theorem real_I : forall x :e SNoS_ (ordsucc omega),
    x <> omega
 -> x <> - omega
 -> (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
 -> x :e real.
admit.
Qed.

Theorem real_E : forall x :e real,
 forall p:prop,
      (SNo x
    -> SNoLev x :e ordsucc omega
    -> x :e SNoS_ (ordsucc omega)
    -> - omega < x
    -> x < omega
    -> (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
    -> (forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k)
    -> p)
   -> p.
admit.
Qed.

Theorem real_SNo : forall x :e real, SNo x.
admit.
Qed.

Theorem real_SNoS_omega_prop : forall x :e real, forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x.
admit.
Qed.

Theorem SNoS_omega_real : SNoS_ omega c= real.
admit.
Qed.

Theorem real_0 : 0 :e real.
admit.
Qed.

Theorem real_1 : 1 :e real.
admit.
Qed.

Theorem SNoLev_In_real_SNoS_omega : forall x :e real, forall w, SNo w -> SNoLev w :e SNoLev x -> w :e SNoS_ omega.
admit.
Qed.

Theorem real_SNoCut_SNoS_omega: forall L R c= SNoS_ omega, SNoCutP L R
 -> L <> 0
 -> R <> 0
 -> (forall w :e L, exists w' :e L, w < w')
 -> (forall z :e R, exists z' :e R, z' < z)
 -> SNoCut L R :e real.
admit.
Qed.

Theorem real_SNoCut: forall L R c= real, SNoCutP L R
 -> L <> 0
 -> R <> 0
 -> (forall w :e L, exists w' :e L, w < w')
 -> (forall z :e R, exists z' :e R, z' < z)
 -> SNoCut L R :e real.
admit.
Qed.

Theorem minus_SNo_prereal_1 : forall x, SNo x ->
    (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
 -> (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - - x) < eps_ k) -> q = - x).
admit.
Qed.

Theorem minus_SNo_prereal_2 : forall x, SNo x ->
    (forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k)
 -> (forall k :e omega, exists q :e SNoS_ omega, q < - x /\ - x < q + eps_ k).
admit.
Qed.

Theorem SNo_prereal_incr_lower_pos: forall x, SNo x -> 0 < x
 -> (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
 -> (forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k)
 -> forall k :e omega,
     forall p:prop,
         (forall q :e SNoS_ omega, 0 < q -> q < x -> x < q + eps_ k -> p)
      -> p.
admit.
Qed.

Theorem real_minus_SNo : forall x :e real, - x :e real.
admit.
Qed.

Theorem SNo_prereal_incr_lower_approx: forall x, SNo x ->
    (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
 -> (forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k)
 -> exists f :e SNoS_ omega :^: omega,
       forall n :e omega, f n < x /\ x < f n + eps_ n
                       /\ forall i :e n, f i < f n.
admit.
Qed.

Theorem SNo_prereal_decr_upper_approx: forall x, SNo x ->
    (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
 -> (forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k)
 -> exists g :e SNoS_ omega :^: omega,
       forall n :e omega, g n + - eps_ n < x /\ x < g n
                       /\ forall i :e n, g n < g i.
admit.
Qed.

Theorem SNoCutP_SNoCut_lim : forall lambda, ordinal lambda
 -> (forall alpha :e lambda, ordsucc alpha :e lambda)
 -> forall L R c= SNoS_ lambda, SNoCutP L R
 -> SNoLev (SNoCut L R) :e ordsucc lambda.
admit.
Qed.

Theorem SNoCutP_SNoCut_omega : forall L R c= SNoS_ omega, SNoCutP L R
 -> SNoLev (SNoCut L R) :e ordsucc omega.
admit.
Qed.

Theorem SNo_approx_real_lem:
  forall f g :e SNoS_ omega :^: omega,
     (forall n m :e omega, f n < g m)
  -> forall p:prop,
         (SNoCutP {f n|n :e omega} {g n|n :e omega}
       -> SNo (SNoCut {f n|n :e omega} {g n|n :e omega})
       -> SNoLev (SNoCut {f n|n :e omega} {g n|n :e omega}) :e ordsucc omega
       -> SNoCut {f n|n :e omega} {g n|n :e omega} :e SNoS_ (ordsucc omega)
       -> (forall n :e omega, f n < SNoCut {f n|n :e omega} {g n|n :e omega})
       -> (forall n :e omega, SNoCut {f n|n :e omega} {g n|n :e omega} < g n)
       -> p)
      -> p.
admit.
Qed.

Theorem SNo_approx_real: forall x, SNo x ->
 forall f g :e SNoS_ omega :^: omega,
     (forall n :e omega, f n < x)
  -> (forall n :e omega, x < f n + eps_ n)
  -> (forall n :e omega, forall i :e n, f i < f n)
  -> (forall n :e omega, x < g n)
  -> (forall n :e omega, forall i :e n, g n < g i)
  -> x = SNoCut {f n|n :e omega} {g n|n :e omega}
  -> x :e real.
admit.
Qed.

Theorem SNo_approx_real_rep : forall x :e real,
 forall p:prop,
     (forall f g :e SNoS_ omega :^: omega,
           (forall n :e omega, f n < x)
        -> (forall n :e omega, x < f n + eps_ n)
        -> (forall n :e omega, forall i :e n, f i < f n)
        -> (forall n :e omega, g n + - eps_ n < x)
        -> (forall n :e omega, x < g n)
        -> (forall n :e omega, forall i :e n, g n < g i)
        -> SNoCutP {f n|n :e omega} {g n|n :e omega}
        -> x = SNoCut {f n|n :e omega} {g n|n :e omega}
        -> p)
  -> p.
admit.
Qed.

Theorem real_add_SNo : forall x y :e real, x + y :e real.
admit.
Qed.

Theorem SNoS_ordsucc_omega_bdd_eps_pos : forall x :e SNoS_ (ordsucc omega), 0 < x -> x < omega -> exists N :e omega, eps_ N * x < 1.
admit.
Qed.

Theorem real_mul_SNo_pos : forall x y :e real, 0 < x -> 0 < y -> x * y :e real.
admit.
Qed.

Theorem real_mul_SNo : forall x y :e real, x * y :e real.
admit.
Qed.

Theorem nonneg_real_nat_interval: forall x :e real, 0 <= x -> exists n :e omega, n <= x /\ x < ordsucc n.
admit.
Qed.

Theorem pos_real_left_approx_double: forall x :e real, 0 < x
 -> x <> 2 -> (forall m :e omega, x <> eps_ m)
 -> exists w :e SNoL_pos x, x < 2 * w.
admit.
Qed.

Theorem real_recip_SNo_lem1: forall x, SNo x -> x :e real -> 0 < x ->
    recip_SNo_pos x :e real
 /\ forall k, nat_p k ->
         (SNo_recipaux x recip_SNo_pos k 0 c= real)
      /\ (SNo_recipaux x recip_SNo_pos k 1 c= real).
admit.
Qed.

Theorem real_recip_SNo_pos: forall x :e real, 0 < x -> recip_SNo_pos x :e real.
admit.
Qed.

Theorem real_recip_SNo: forall x :e real, recip_SNo x :e real.
admit.
Qed.

Theorem real_div_SNo: forall x y :e real, x :/: y :e real.
admit.
Qed.

End Reals.

Opaque real.

Section even_odd.

Infix + 360 right := add_nat.
Infix * 355 right := mul_nat.

Theorem nat_le2_cases: forall m, nat_p m -> m c= 2 -> m = 0 \/ m = 1 \/ m = 2.
admit.
Qed.

Theorem prime_nat_2_lem: forall m, nat_p m -> forall n, nat_p n -> m * n = 2 -> m = 1 \/ m = 2.
admit.
Qed.

Theorem prime_nat_2: prime_nat 2.
admit.
Qed.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.

Theorem not_eq_2m_2n1: forall m n :e int, 2 * m <> 2 * n + 1.
admit.
Qed.

End even_odd.

Section form100_22b.

Let tag : set -> set := fun alpha => SetAdjoin alpha {1}.
Postfix ' 100 := tag.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.

Theorem atleastp_SNoS_ordsucc_omega_Power_omega: atleastp (SNoS_ (ordsucc omega)) (Power omega).
admit.
Qed.

Theorem Repl_finite: forall f:set -> set, forall X, finite X -> finite {f x|x :e X}.
admit.
Qed.

Theorem infinite_bigger: forall X c= omega, infinite X -> forall m :e omega, exists n :e X, m :e n.
admit.
Qed.

Theorem equip_real_Power_omega: equip real (Power omega).
admit.
Qed.

Theorem form100_22_real_uncountable_atleastp: ~atleastp real omega.
admit.
Qed.

Theorem form100_22_real_uncountable_equip: ~equip real omega.
admit.
Qed.

Theorem form100_22_real_uncountable: atleastp omega real /\ ~equip real omega.
admit.
Qed.

End form100_22b.

Section rational.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix ^ 342 right := exp_SNo_nat.
Infix :/: 353 := div_SNo.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.

Definition rational : set := {x :e real | exists m :e int, exists n :e omega :\: {0}, x = m :/: n}.

End rational.

Section form100_3.

(** The Denumerability of the Rational Numbers **)

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix :/: 353 := div_SNo.
Infix ^ 342 right := exp_SNo_nat.

Theorem Subq_int_SNoS_omega: int c= SNoS_ omega.
admit.
Qed.

Theorem Subq_SNoS_omega_rational: SNoS_ omega c= rational.
admit.
Qed.

Theorem Subq_rational_real: rational c= real.
admit.
Qed.

Theorem rational_minus_SNo: forall q :e rational, - q :e rational.
admit.
Qed.

Definition nat_pair : set -> set -> set := fun m n => 2 ^ m * (2 * n + 1).

Theorem nat_pair_In_omega: forall m n :e omega, nat_pair m n :e omega.
admit.
Qed.

Theorem nat_pair_0: forall m n m' n' :e omega, nat_pair m n = nat_pair m' n' -> m = m'.
admit.
Qed.

Theorem nat_pair_1: forall m n m' n' :e omega, nat_pair m n = nat_pair m' n' -> n = n'.
admit.
Qed.

Theorem form100_3: equip omega rational.
admit.
Qed.

End form100_3.

Section SurrealSqrt.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix :/: 353 := div_SNo.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.
Infix ^ 342 right := exp_SNo_nat.
Definition SNoL_nonneg : set -> set := fun x => {w :e SNoL x|0 <= w}.

Theorem SNoL_nonneg_0: SNoL_nonneg 0 = 0.
admit.
Qed.

Theorem SNoL_nonneg_1: SNoL_nonneg 1 = 1.
admit.
Qed.

Definition SNo_sqrtauxset : set -> set -> set -> set := fun Y Z x => \/_ y :e Y, {(x + y * z) :/: (y + z)|z :e Z, 0 < y + z}.

Theorem SNo_sqrtauxset_I : forall Y Z x,
 forall y :e Y, forall z :e Z, 0 < y + z -> (x + y * z) :/: (y + z) :e SNo_sqrtauxset Y Z x.
admit.
Qed.

Theorem SNo_sqrtauxset_E : forall Y Z x,
 forall u :e SNo_sqrtauxset Y Z x, forall p:prop,
     (forall y :e Y, forall z :e Z, 0 < y + z -> u = (x + y * z) :/: (y + z) -> p)
  -> p.
admit.
Qed.

Theorem SNo_sqrtauxset_0: forall Z x, SNo_sqrtauxset 0 Z x = 0.
admit.
Qed.

Theorem SNo_sqrtauxset_0': forall Y x, SNo_sqrtauxset Y 0 x = 0.
admit.
Qed.

Definition SNo_sqrtaux : set -> (set -> set) -> set -> set :=
 fun x g =>
  nat_primrec ({g w|w :e SNoL_nonneg x},{g z|z :e SNoR x})
   (fun k p => (p 0 :\/: SNo_sqrtauxset (p 0) (p 1) x,
                p 1 :\/: SNo_sqrtauxset (p 0) (p 0) x
                    :\/: SNo_sqrtauxset (p 1) (p 1) x)).

Theorem SNo_sqrtaux_0: forall x, forall g:set -> set, SNo_sqrtaux x g 0 = ({g w|w :e SNoL_nonneg x},{g z|z :e SNoR x}).
admit.
Qed.

Theorem SNo_sqrtaux_S: forall x, forall g:set -> set, forall n, nat_p n
 -> SNo_sqrtaux x g (ordsucc n)
  = (SNo_sqrtaux x g n 0
       :\/: SNo_sqrtauxset (SNo_sqrtaux x g n 0) (SNo_sqrtaux x g n 1) x,
     SNo_sqrtaux x g n 1
       :\/: SNo_sqrtauxset (SNo_sqrtaux x g n 0) (SNo_sqrtaux x g n 0) x
       :\/: SNo_sqrtauxset (SNo_sqrtaux x g n 1) (SNo_sqrtaux x g n 1) x).
admit.
Qed.

Theorem SNo_sqrtaux_mon_lem: forall x, forall g:set -> set,
  forall m, nat_p m -> forall n, nat_p n
   -> SNo_sqrtaux x g m 0 c= SNo_sqrtaux x g (add_nat m n) 0
   /\ SNo_sqrtaux x g m 1 c= SNo_sqrtaux x g (add_nat m n) 1.
admit.
Qed.

Theorem SNo_sqrtaux_mon: forall x, forall g:set -> set,
  forall m, nat_p m -> forall n, nat_p n -> m c= n
   -> SNo_sqrtaux x g m 0 c= SNo_sqrtaux x g n 0
   /\ SNo_sqrtaux x g m 1 c= SNo_sqrtaux x g n 1.
admit.
Qed.

Theorem SNo_sqrtaux_ext: forall x, SNo x -> forall g h:set -> set, (forall x' :e SNoS_ (SNoLev x), g x' = h x') -> forall k, nat_p k -> SNo_sqrtaux x g k = SNo_sqrtaux x h k.
admit.
Qed.

Section sqrt_SNo_nonneg.
Let G : set -> (set -> set) -> set := fun x g => SNoCut (\/_ k :e omega, SNo_sqrtaux x g k 0) (\/_ k :e omega, SNo_sqrtaux x g k 1).
Definition sqrt_SNo_nonneg : set -> set := SNo_rec_i G.

Theorem sqrt_SNo_nonneg_eq: forall x, SNo x -> sqrt_SNo_nonneg x = G x sqrt_SNo_nonneg.
admit.
Qed.

Theorem sqrt_SNo_nonneg_prop1a: forall x, SNo x -> 0 <= x ->
    (forall w :e SNoS_ (SNoLev x), 0 <= w -> SNo (sqrt_SNo_nonneg w) /\ 0 <= sqrt_SNo_nonneg w /\ sqrt_SNo_nonneg w * sqrt_SNo_nonneg w = w)
 -> forall k, nat_p k ->
              (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 0, SNo y /\ 0 <= y /\ y * y < x)
           /\ (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 1, SNo y /\ 0 <= y /\ x < y * y).
admit.
Qed.

Theorem sqrt_SNo_nonneg_prop1b: forall x, SNo x -> 0 <= x
 -> (forall k, nat_p k ->
              (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 0, SNo y /\ 0 <= y /\ y * y < x)
           /\ (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 1, SNo y /\ 0 <= y /\ x < y * y))
 -> SNoCutP (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0) (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1).
admit.
Qed.

Theorem sqrt_SNo_nonneg_prop1c: forall x, SNo x -> 0 <= x ->
    SNoCutP (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0) (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1)
 -> (forall z :e (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1), forall p:prop, (SNo z -> 0 <= z -> x < z * z -> p) -> p)
 -> 0 <= G x sqrt_SNo_nonneg.
admit.
Qed.

Theorem sqrt_SNo_nonneg_prop1d: forall x, SNo x -> 0 <= x
  -> (forall w :e SNoS_ (SNoLev x), 0 <= w -> SNo (sqrt_SNo_nonneg w) /\ 0 <= sqrt_SNo_nonneg w /\ sqrt_SNo_nonneg w * sqrt_SNo_nonneg w = w)
  -> SNoCutP (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0) (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1)
  -> 0 <= G x sqrt_SNo_nonneg
  -> G x sqrt_SNo_nonneg * G x sqrt_SNo_nonneg < x
  -> False.
admit.
Qed.

Theorem sqrt_SNo_nonneg_prop1e: forall x, SNo x -> 0 <= x
  -> (forall w :e SNoS_ (SNoLev x), 0 <= w -> SNo (sqrt_SNo_nonneg w) /\ 0 <= sqrt_SNo_nonneg w /\ sqrt_SNo_nonneg w * sqrt_SNo_nonneg w = w)
  -> SNoCutP (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0) (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1)
  -> 0 <= G x sqrt_SNo_nonneg
  -> x < G x sqrt_SNo_nonneg * G x sqrt_SNo_nonneg
  -> False.
admit.
Qed.

Theorem sqrt_SNo_nonneg_prop1: forall x, SNo x -> 0 <= x -> SNo (sqrt_SNo_nonneg x) /\ 0 <= sqrt_SNo_nonneg x /\ sqrt_SNo_nonneg x * sqrt_SNo_nonneg x = x.
admit.
Qed.

End sqrt_SNo_nonneg.

Theorem SNo_sqrtaux_0_1_prop: forall x, SNo x -> 0 <= x ->
  forall k, nat_p k ->
      (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 0, SNo y /\ 0 <= y /\ y * y < x)
   /\ (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 1, SNo y /\ 0 <= y /\ x < y * y).
admit.
Qed.

Theorem SNo_sqrtaux_0_prop: forall x, SNo x -> 0 <= x ->
  forall k, nat_p k ->
  forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 0, SNo y /\ 0 <= y /\ y * y < x.
admit.
Qed.

Theorem SNo_sqrtaux_1_prop: forall x, SNo x -> 0 <= x ->
  forall k, nat_p k ->
  forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 1, SNo y /\ 0 <= y /\ x < y * y.
admit.
Qed.

Theorem SNo_sqrt_SNo_SNoCutP: forall x, SNo x -> 0 <= x ->
  SNoCutP (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0)
          (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1).
admit.
Qed.

Theorem SNo_sqrt_SNo_nonneg: forall x, SNo x -> 0 <= x -> SNo (sqrt_SNo_nonneg x).
admit.
Qed.

Theorem sqrt_SNo_nonneg_nonneg: forall x, SNo x -> 0 <= x -> 0 <= sqrt_SNo_nonneg x.
admit.
Qed.

Theorem sqrt_SNo_nonneg_sqr: forall x, SNo x -> 0 <= x -> sqrt_SNo_nonneg x * sqrt_SNo_nonneg x = x.
admit.
Qed.

Theorem sqrt_SNo_nonneg_0 : sqrt_SNo_nonneg 0 = 0.
admit.
Qed.

Theorem sqrt_SNo_nonneg_1 : sqrt_SNo_nonneg 1 = 1.
admit.
Qed.

Theorem sqrt_SNo_nonneg_0inL0: forall x, SNo x -> 0 <= x -> 0 :e SNoLev x -> 0 :e SNo_sqrtaux x sqrt_SNo_nonneg 0 0.
admit.
Qed.

Theorem sqrt_SNo_nonneg_Lnonempty: forall x, SNo x -> 0 <= x -> 0 :e SNoLev x -> (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0) <> 0.
admit.
Qed.

Theorem sqrt_SNo_nonneg_Rnonempty: forall x, SNo x -> 0 <= x -> 1 :e SNoLev x -> (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1) <> 0.
admit.
Qed.

Theorem SNo_sqrtauxset_real: forall Y Z x, Y c= real -> Z c= real -> x :e real -> SNo_sqrtauxset Y Z x c= real.
admit.
Qed.

Theorem SNo_sqrtauxset_real_nonneg: forall Y Z x, Y c= {w :e real|0 <= w} -> Z c= {z :e real|0 <= z} -> x :e real -> 0 <= x -> SNo_sqrtauxset Y Z x c= {w :e real|0 <= w}.
admit.
Qed.

Theorem sqrt_SNo_nonneg_SNoS_omega: forall x :e SNoS_ omega, 0 <= x -> sqrt_SNo_nonneg x :e real.
admit.
Qed.

Theorem sqrt_SNo_nonneg_real: forall x :e real, 0 <= x -> sqrt_SNo_nonneg x :e real.
admit.
Qed.

End SurrealSqrt.
Opaque sqrt_SNo_nonneg.

Section form100_1.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix :/: 353 := div_SNo.

Theorem divides_int_div_SNo_int: forall m n, divides_int m n -> n :/: m :e int.
admit.
Qed.

(** If m times m = 2 times n times n for naturals m and n, then n = 0. **)
Theorem form100_1_lem1 : forall m, nat_p m -> forall n, nat_p n -> m * m = 2 * n * n -> n = 0.
admit.
Qed.

(** There are no nonzero naturals m and n such that m times m = 2 times n times n. **)
Theorem form100_1_lem2 : forall m :e omega, forall n :e omega :\: 1, m * m <> 2 * n * n.
admit.
Qed.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix :/: 353 := div_SNo.

Theorem sqrt_2_irrational: sqrt_SNo_nonneg 2 :e real :\: rational.
admit.
Qed.

End form100_1.

Section Topology.

(** from 12 Topological Spaces: definition of topology on X **)
(** LATEX VERSION: A topology on a set X is a collection T of subsets of X such that  and X are in T, arbitrary unions of subcollections of T lie in T, and finite intersections of elements of T lie in T. **)
(** SUSPICIOUS DEFINITION: This is a left-associated conjunction; later proofs must destruct it as ((((A /\ B) /\ C) /\ D) /\ E). **)
Definition topology_on : set -> set -> prop := fun X T =>
  T c= Power X
/\ Empty :e T
/\ X :e T
/\ (forall UFam :e Power T, Union UFam :e T)
/\ (forall U :e T, forall V :e T, U :/\: V :e T).

(** Helper: extract T c= Power X from topology_on **)
Theorem topology_sub_Power : forall X T:set,
  topology_on X T -> T c= Power X.
let X T.
assume HTx: topology_on X T.
prove T c= Power X.
(** topology_on X T = ((((T c= Power X /\ Empty :e T) /\ X :e T) /\ Union axiom) /\ Intersection axiom) **)
claim H1: (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) /\ (forall U :e T, forall V :e T, U :/\: V :e T).
{ exact HTx. }
claim H2: ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T).
{ exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T))
               (forall U :e T, forall V :e T, U :/\: V :e T)
               H1). }
claim H3: (T c= Power X /\ Empty :e T) /\ X :e T.
{ exact (andEL ((T c= Power X /\ Empty :e T) /\ X :e T)
               (forall UFam :e Power T, Union UFam :e T)
               H2). }
claim H4: T c= Power X /\ Empty :e T.
{ exact (andEL (T c= Power X /\ Empty :e T) (X :e T) H3). }
exact (andEL (T c= Power X) (Empty :e T) H4).
Qed.

(** from 12: definition of open sets in a topology **)
(** LATEX VERSION: If X has topology T, a subset U of X is open exactly when U is an element of T. **)
(** SUSPICIOUS DEFINITION: `open_in X T U` bundles the hypothesis `topology_on X T`; this is convenient but means open cannot be stated independently of already knowing T is a topology. **)
Definition open_in : set -> set -> set -> prop := fun X T U =>
  topology_on X T /\ U :e T.

(** Helper: extract topology_on from open_in **)
Theorem open_in_topology : forall X T U:set,
  open_in X T U -> topology_on X T.
let X T U.
assume H: open_in X T U.
exact (andEL (topology_on X T) (U :e T) H).
Qed.

(** Helper: extract membership from open_in **)
Theorem open_in_elem : forall X T U:set,
  open_in X T U -> U :e T.
let X T U.
assume H: open_in X T U.
exact (andER (topology_on X T) (U :e T) H).
Qed.

(** Helper: introduction rule for open_in **)
Theorem open_inI : forall X T U:set,
  topology_on X T -> U :e T -> open_in X T U.
let X T U.
assume HT: topology_on X T.
assume HU: U :e T.
exact (andI (topology_on X T) (U :e T) HT HU).
Qed.

(** Helper: Open set is a subset of X **)
Theorem open_in_subset : forall X T U:set,
  open_in X T U -> U c= X.
let X T U.
assume HU: open_in X T U.
prove U c= X.
claim HTx: topology_on X T.
{ exact (open_in_topology X T U HU). }
claim HUT: U :e T.
{ exact (open_in_elem X T U HU). }
claim HUPower: U :e Power X.
{ exact ((topology_sub_Power X T HTx) U HUT). }
exact (PowerE X U HUPower).
Qed.

(** Helper: Elements of topology are subsets of X **)
Theorem topology_elem_subset : forall X T U:set,
  topology_on X T -> U :e T -> U c= X.
let X T U.
assume HTx: topology_on X T.
assume HU: U :e T.
prove U c= X.
claim HUPower: U :e Power X.
{ exact ((topology_sub_Power X T HTx) U HU). }
exact (PowerE X U HUPower).
Qed.

(** Helper: Empty is in every topology **)
Theorem topology_has_empty : forall X T:set,
  topology_on X T -> Empty :e T.
let X T.
assume HTx: topology_on X T.
prove Empty :e T.
(** topology_on X T = ((((T c= Power X /\ Empty :e T) /\ X :e T) /\ Union axiom) /\ Intersection axiom) **)
claim H1: (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) /\ (forall U :e T, forall V :e T, U :/\: V :e T).
{ exact HTx. }
claim H2: ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T).
{ exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) (forall U :e T, forall V :e T, U :/\: V :e T) H1). }
claim H3: (T c= Power X /\ Empty :e T) /\ X :e T.
{ exact (andEL ((T c= Power X /\ Empty :e T) /\ X :e T) (forall UFam :e Power T, Union UFam :e T) H2). }
claim H4: T c= Power X /\ Empty :e T.
{ exact (andEL (T c= Power X /\ Empty :e T) (X :e T) H3). }
exact (andER (T c= Power X) (Empty :e T) H4).
Qed.

(** Helper: X is in every topology on X **)
Theorem topology_has_X : forall X T:set,
  topology_on X T -> X :e T.
let X T.
assume HTx: topology_on X T.
prove X :e T.
(** topology_on X T = ((((T c= Power X /\ Empty :e T) /\ X :e T) /\ Union axiom) /\ Intersection axiom) **)
claim H1: (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) /\ (forall U :e T, forall V :e T, U :/\: V :e T).
{ exact HTx. }
claim H2: ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T).
{ exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) (forall U :e T, forall V :e T, U :/\: V :e T) H1). }
claim H3: (T c= Power X /\ Empty :e T) /\ X :e T.
{ exact (andEL ((T c= Power X /\ Empty :e T) /\ X :e T) (forall UFam :e Power T, Union UFam :e T) H2). }
exact (andER (T c= Power X /\ Empty :e T) (X :e T) H3).
Qed.

(** Helper: topology is a family of subsets **)
Theorem topology_subset_axiom : forall X T:set,
  topology_on X T -> T c= Power X.
let X T.
assume HTx: topology_on X T.
prove T c= Power X.
claim H0: ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T).
{ exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) (forall U :e T, forall V :e T, U :/\: V :e T) HTx). }
claim H1: (T c= Power X /\ Empty :e T) /\ X :e T.
{ exact (andEL ((T c= Power X /\ Empty :e T) /\ X :e T) (forall UFam :e Power T, Union UFam :e T) H0). }
claim H2: T c= Power X /\ Empty :e T.
{ exact (andEL (T c= Power X /\ Empty :e T) (X :e T) H1). }
exact (andEL (T c= Power X) (Empty :e T) H2).
Qed.

(** Helper: Union of family in topology stays in topology **)
Theorem topology_union_closed : forall X T UFam:set,
  topology_on X T -> UFam c= T -> Union UFam :e T.
let X T UFam.
assume HTx: topology_on X T.
assume HUFam: UFam c= T.
prove Union UFam :e T.
(** Extract union axiom from topology_on **)
claim H1: (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam0 :e Power T, Union UFam0 :e T)) /\ (forall U :e T, forall V :e T, U :/\: V :e T).
{ exact HTx. }
claim H2: ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam0 :e Power T, Union UFam0 :e T).
{ exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam0 :e Power T, Union UFam0 :e T)) (forall U :e T, forall V :e T, U :/\: V :e T) H1). }
claim HUnionAxiom: forall UFam0 :e Power T, Union UFam0 :e T.
{ exact (andER (((T c= Power X /\ Empty :e T) /\ X :e T)) (forall UFam0 :e Power T, Union UFam0 :e T) H2). }
claim HUFamPower: UFam :e Power T.
{ exact (PowerI T UFam HUFam). }
exact (HUnionAxiom UFam HUFamPower).
Qed.

(** Helper: Union axiom using Power membership **)
Theorem topology_union_closed_pow : forall X T UFam:set,
  topology_on X T -> UFam :e Power T -> Union UFam :e T.
let X T UFam.
assume HTx: topology_on X T.
assume HUFamPow: UFam :e Power T.
prove Union UFam :e T.
claim HUFamSub: UFam c= T.
{ exact (PowerE T UFam HUFamPow). }
exact (topology_union_closed X T UFam HTx HUFamSub).
Qed.

(** Helper: union axiom extracted **)
Theorem topology_union_axiom : forall X T:set,
  topology_on X T ->
  forall UFam :e Power T, Union UFam :e T.
let X T.
assume HTx: topology_on X T.
prove forall UFam :e Power T, Union UFam :e T.
let UFam. assume HUFamPow: UFam :e Power T.
exact (topology_union_closed_pow X T UFam HTx HUFamPow).
Qed.

(** Helper: Binary intersection in topology stays in topology **)
Theorem topology_binintersect_closed : forall X T U V:set,
  topology_on X T -> U :e T -> V :e T -> U :/\: V :e T.
let X T U V.
assume HTx: topology_on X T.
assume HU: U :e T.
assume HV: V :e T.
prove U :/\: V :e T.
(** Extract intersection axiom from topology_on **)
claim HIntersectAxiom: forall U0 :e T, forall V0 :e T, U0 :/\: V0 :e T.
{ exact (andER ((((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T))) (forall U0 :e T, forall V0 :e T, U0 :/\: V0 :e T) HTx). }
exact (HIntersectAxiom U HU V HV).
Qed.

(** Helper: intersection axiom extracted **)
Theorem topology_binintersect_axiom : forall X T:set,
  topology_on X T ->
  forall U :e T, forall V :e T, U :/\: V :e T.
let X T.
assume HTx: topology_on X T.
prove forall U :e T, forall V :e T, U :/\: V :e T.
let U. assume HU: U :e T.
let V. assume HV: V :e T.
exact (topology_binintersect_closed X T U V HTx HU HV).
Qed.

(** Helper: Empty set is open in any topology **)
Theorem Empty_is_open : forall X T:set,
  topology_on X T -> open_in X T Empty.
let X T.
assume HTx: topology_on X T.
prove open_in X T Empty.
prove topology_on X T /\ Empty :e T.
apply andI.
- exact HTx.
- exact (topology_has_empty X T HTx).
Qed.

(** Helper: X is open in its own topology **)
Theorem X_is_open : forall X T:set,
  topology_on X T -> open_in X T X.
let X T.
assume HTx: topology_on X T.
prove open_in X T X.
prove topology_on X T /\ X :e T.
apply andI.
- exact HTx.
- exact (topology_has_X X T HTx).
Qed.

(** Helper: Union of open sets is open **)
Theorem union_open : forall X T UFam:set,
  topology_on X T ->
  (forall U :e UFam, open_in X T U) ->
  open_in X T (Union UFam).
let X T UFam.
assume HTx: topology_on X T.
assume HUFam: forall U :e UFam, open_in X T U.
prove open_in X T (Union UFam).
prove topology_on X T /\ Union UFam :e T.
apply andI.
- exact HTx.
- prove Union UFam :e T.
  claim HUFamsub: UFam c= T.
  { let U. assume HUin: U :e UFam.
    claim HUopen: open_in X T U.
    { exact (HUFam U HUin). }
    exact (andER (topology_on X T) (U :e T) HUopen).
  }
  exact (topology_union_closed X T UFam HTx HUFamsub).
Qed.

(** Helper: Binary intersection of open sets is open **)
Theorem binintersect_open : forall X T U V:set,
  open_in X T U ->
  open_in X T V ->
  open_in X T (U :/\: V).
let X T U V.
assume HU: open_in X T U.
assume HV: open_in X T V.
prove open_in X T (U :/\: V).
claim HTx: topology_on X T.
{ exact (andEL (topology_on X T) (U :e T) HU). }
claim HUinT: U :e T.
{ exact (andER (topology_on X T) (U :e T) HU). }
claim HVinT: V :e T.
{ exact (andER (topology_on X T) (V :e T) HV). }
prove topology_on X T /\ U :/\: V :e T.
apply andI.
- exact HTx.
- exact (topology_binintersect_closed X T U V HTx HUinT HVinT).
  Qed.

(** from 12: closed set as complement of open set **)
(** LATEX VERSION: A set C is closed in X (with topology T) if there exists an open set UT whose complement in X equals C. **)
(** SUSPICIOUS DEFINITION: This is packaged with an explicit subset condition `C c= X` and an existential complement witness; later closure lemmas must unpack that witness carefully. **)
Definition closed_in : set -> set -> set -> prop := fun X T C =>
  topology_on X T /\ (C c= X /\ exists U :e T, C = X :\: U).

(** Helper: extract topology_on from closed_in **)
Theorem closed_in_topology : forall X T C:set,
  closed_in X T C -> topology_on X T.
let X T C.
assume H: closed_in X T C.
exact (andEL (topology_on X T) (C c= X /\ exists U :e T, C = X :\: U) H).
Qed.

(** Helper: extract the complement-witness package from closed_in **)
Theorem closed_in_package : forall X T C:set,
  closed_in X T C -> C c= X /\ exists U :e T, C = X :\: U.
let X T C.
assume H: closed_in X T C.
exact (andER (topology_on X T) (C c= X /\ exists U :e T, C = X :\: U) H).
Qed.

(** Helper: introduction rule for closed_in **)
Theorem closed_inI : forall X T C:set,
  topology_on X T ->
  C c= X ->
  (exists U :e T, C = X :\: U) ->
  closed_in X T C.
let X T C.
assume HT: topology_on X T.
assume HCsub: C c= X.
assume Hex: exists U :e T, C = X :\: U.
exact (andI (topology_on X T) (C c= X /\ exists U :e T, C = X :\: U)
            HT
            (andI (C c= X) (exists U :e T, C = X :\: U) HCsub Hex)).
Qed.

(** Helper: pairing belongs to setprod via Sigma encoding **)
Theorem tuple_2_setprod_by_pair_Sigma : forall X Y:set, forall x y:set,
  x :e X -> y :e Y -> (x,y) :e setprod X Y.
let X Y x y.
assume Hx: x :e X.
assume Hy: y :e Y.
prove (x,y) :e setprod X Y.
rewrite <- (tuple_pair x y) at 1.
exact (pair_Sigma X (fun _ : set => Y) x Hx y Hy).
Qed.

(** Helper: extract existence of open complement witness from closed_in **)
Theorem closed_in_exists_open_complement : forall X T C:set,
  closed_in X T C -> exists U :e T, C = X :\: U.
let X T C.
assume H: closed_in X T C.
claim Hpack: C c= X /\ exists U :e T, C = X :\: U.
{ exact (closed_in_package X T C H). }
exact (andER (C c= X) (exists U :e T, C = X :\: U) Hpack).
Qed.

(** Helper: Closed set is a subset of X **)
Theorem closed_in_subset : forall X T C:set,
  closed_in X T C -> C c= X.
let X T C.
assume HC: closed_in X T C.
prove C c= X.
exact (andEL (C c= X) (exists U :e T, C = X :\: U) (closed_in_package X T C HC)).
Qed.

(** from 12: complement of open set is closed **)
(** LATEX VERSION: If U is open in topology T on X, then X\\U is closed in that topology. **)
Theorem closed_of_open_complement : forall X T U:set, topology_on X T -> U :e T -> closed_in X T (X :\: U).
let X. let T. let U.
assume Htop HU.
prove closed_in X T (X :\: U).
apply (closed_inI X T (X :\: U)).
- exact Htop.
- exact (setminus_Subq X U).
- witness U.
  apply andI.
  * exact HU.
  * reflexivity.
Qed.

(** Helper: X is closed in any topology **)
Theorem X_is_closed : forall X T:set,
  topology_on X T -> closed_in X T X.
let X T.
assume HTx: topology_on X T.
prove closed_in X T X.
apply (closed_inI X T X).
- exact HTx.
- exact (Subq_ref X).
- witness Empty.
  apply andI.
  * exact (topology_has_empty X T HTx).
  * prove X = X :\: Empty.
    apply set_ext.
    { let x. assume Hx: x :e X.
      prove x :e X :\: Empty.
      apply setminusI.
      - exact Hx.
      - assume H: x :e Empty.
        exact (EmptyE x H).
    }
    { let x. assume Hx: x :e X :\: Empty.
      exact (setminusE1 X Empty x Hx).
    }
Qed.

(** Helper: Empty is closed in any topology **)
Theorem Empty_is_closed : forall X T:set,
  topology_on X T -> closed_in X T Empty.
let X T.
assume HTx: topology_on X T.
prove closed_in X T Empty.
apply (closed_inI X T Empty).
- exact HTx.
- exact (Subq_Empty X).
- witness X.
  apply andI.
  * exact (topology_has_X X T HTx).
  * prove Empty = X :\: X.
    apply set_ext.
    { exact (Subq_Empty (X :\: X)). }
    { let x. assume Hx: x :e X :\: X.
      claim HxX: x :e X.
      { exact (setminusE1 X X x Hx). }
      claim HxnotX: x /:e X.
      { exact (setminusE2 X X x Hx). }
      apply FalseE.
      exact (HxnotX HxX).
    }
Qed.

(** Helper: Complement of closed set is open **)
Theorem open_of_closed_complement : forall X T C:set,
  closed_in X T C -> open_in X T (X :\: C).
let X T C.
assume HC: closed_in X T C.
prove open_in X T (X :\: C).
claim HTx: topology_on X T.
{ exact (closed_in_topology X T C HC). }
claim HCex: exists U :e T, C = X :\: U.
{ exact (closed_in_exists_open_complement X T C HC). }
apply HCex.
let U. assume HU: U :e T /\ C = X :\: U.
claim HUinT: U :e T.
{ exact (andEL (U :e T) (C = X :\: U) HU). }
claim HCeq: C = X :\: U.
{ exact (andER (U :e T) (C = X :\: U) HU). }
claim HUsubX: U c= X.
{ exact (topology_elem_subset X T U HTx HUinT). }
claim HXCe: X :\: C = U.
{ rewrite HCeq.
  prove X :\: (X :\: U) = U.
  apply set_ext.
  - let x. assume Hx: x :e X :\: (X :\: U).
    prove x :e U.
    claim HxX: x :e X.
    { exact (setminusE1 X (X :\: U) x Hx). }
    claim HxnotXU: x /:e X :\: U.
    { exact (setminusE2 X (X :\: U) x Hx). }
    apply (xm (x :e U)).
    + assume HxU: x :e U.
      exact HxU.
    + assume HxnotU: x /:e U.
      claim HxXU: x :e X :\: U.
      { apply setminusI.
        - exact HxX.
        - exact HxnotU.
      }
      apply FalseE.
      exact (HxnotXU HxXU).
  - let x. assume Hx: x :e U.
    prove x :e X :\: (X :\: U).
    claim HxX: x :e X.
    { exact (HUsubX x Hx). }
    apply setminusI.
    + exact HxX.
    + assume HxXU: x :e X :\: U.
      claim HxnotU: x /:e U.
      { exact (setminusE2 X U x HxXU). }
      exact (HxnotU Hx).
}
apply (open_inI X T (X :\: C) HTx).
rewrite HXCe.
exact HUinT.
Qed.

(** Helper: binary union is union of a pair **)
Theorem binunion_eq_Union_pair : forall X Y:set, X :\/: Y = Union {X,Y}.
let X Y.
apply set_ext.
- let z. assume Hz: z :e X :\/: Y.
  prove z :e Union {X,Y}.
  apply (binunionE X Y z Hz).
  - assume HzX: z :e X.
    apply (UnionI {X,Y} z X).
    + exact HzX.
    + exact (UPairI1 X Y).
  - assume HzY: z :e Y.
    apply (UnionI {X,Y} z Y).
    + exact HzY.
    + exact (UPairI2 X Y).
- let z. assume Hz: z :e Union {X,Y}.
  prove z :e X :\/: Y.
  apply (UnionE_impred {X,Y} z Hz).
  let Z.
  assume HzZ: z :e Z.
  assume HZ: Z :e {X,Y}.
  claim Hor: Z = X \/ Z = Y.
  { exact (UPairE Z X Y HZ). }
  apply Hor.
  - assume HZX: Z = X.
    claim HzX: z :e X.
    { rewrite <- HZX. exact HzZ. }
    exact (binunionI1 X Y z HzX).
  - assume HZY: Z = Y.
    claim HzY: z :e Y.
    { rewrite <- HZY. exact HzZ. }
    exact (binunionI2 X Y z HzY).
Qed.

(** Helper: binary union of members of a topology is in the topology **)
(** LATEX VERSION: Since U  V is the union of the pair {U,V}, any topology is closed under binary unions. **)
Theorem topology_binunion_closed : forall X T U V:set,
  topology_on X T -> U :e T -> V :e T -> U :\/: V :e T.
let X T U V.
assume HTx: topology_on X T.
assume HU: U :e T.
assume HV: V :e T.
prove U :\/: V :e T.
claim Hpairsub: {U,V} c= T.
{ let W. assume HW: W :e {U,V}.
  claim Hor: W = U \/ W = V.
  { exact (UPairE W U V HW). }
  apply Hor.
  - assume HWU: W = U.
    rewrite HWU. exact HU.
  - assume HWV: W = V.
    rewrite HWV. exact HV.
}
claim HUnionPair: Union {U,V} :e T.
{ exact (topology_union_closed X T {U,V} HTx Hpairsub). }
rewrite (binunion_eq_Union_pair U V).
exact HUnionPair.
Qed.

(** Helper: binary union of open sets is open **)
(** LATEX VERSION: The union of two open sets is open. **)
Theorem binunion_open : forall X T U V:set,
  open_in X T U ->
  open_in X T V ->
  open_in X T (U :\/: V).
let X T U V.
assume HU: open_in X T U.
assume HV: open_in X T V.
prove open_in X T (U :\/: V).
claim HTx: topology_on X T.
{ exact (andEL (topology_on X T) (U :e T) HU). }
claim HUinT: U :e T.
{ exact (andER (topology_on X T) (U :e T) HU). }
claim HVinT: V :e T.
{ exact (andER (topology_on X T) (V :e T) HV). }
prove topology_on X T /\ (U :\/: V) :e T.
apply andI.
- exact HTx.
- exact (topology_binunion_closed X T U V HTx HUinT HVinT).
Qed.

(** from 12: "finer than" / "coarser than" topologies **)
(** LATEX VERSION: Given topologies T and T' on X, T' is finer than T if T'  T; T is coarser than T'; the topologies are comparable if one contains the other. **)
Definition finer_than : set -> set -> prop := fun T' T => T c= T'.

(** LATEX VERSION: Coarser is the reverse inclusion: T' is coarser than T when T'  T. **)
Definition coarser_than : set -> set -> prop := fun T' T => T' c= T.


(** from 12 Example 2: discrete topology **)
(** LATEX VERSION: Example 2 defines the discrete topology on X as the collection of all subsets of X. **)
Definition discrete_topology : set -> set := fun X => Power X.

(** from 12: indiscrete/trivial topology **)
(** LATEX VERSION: The indiscrete (trivial) topology on X consists only of X and . **)
Definition indiscrete_topology : set -> set := fun X => {Empty, X}.

(** from 12 Example 3: finite complement topology **)
(** LATEX VERSION: Example 3 defines T_f = { U  X | X\\U is finite or U =  }, the finite complement topology. **)
Definition finite_complement_topology : set -> set :=
  fun X => {U :e Power X | finite (X :\: U) \/ U = Empty}.

(** helper: countable set: admits an injection into omega (at most countable) **)
(** LATEX VERSION: A set is countable if it admits an injection into  (at most countable). **)
(** NOTE: `atleastp X omega` is used here in the sense there exists an injection from X into omega (cardinality at most omega). **)
(** SUSPICIOUS DEFINITION: This is at most countable (injects into omega), not countably infinite (equip omega). Later statements must use the intended meaning consistently. **)
Definition countable : set -> prop := fun X => atleastp X omega.

(** LATEX VERSION: Every finite set is countable. **)
Theorem finite_countable : forall X:set, finite X -> countable X.
let X. assume Hfin.
apply Hfin.
let n. assume Hpair: n :e omega /\ equip X n.
claim Hn : n :e omega.
{ exact (andEL (n :e omega) (equip X n) Hpair). }
claim Heq : equip X n.
{ exact (andER (n :e omega) (equip X n) Hpair). }
claim Hn_sub : n c= omega.
{ exact (omega_TransSet n Hn). }
claim Hcount_n : atleastp n omega.
{ exact (Subq_atleastp n omega Hn_sub). }
claim Hcount_X : atleastp X n.
{ exact (equip_atleastp X n Heq). }
exact (atleastp_tra X n omega Hcount_X Hcount_n).
Qed.

(** Helper: Empty is countable **)
Theorem countable_Empty : countable Empty.
exact (Subq_atleastp Empty omega (Subq_Empty omega)).
Qed.

(** Helper: Subset of countable set is countable **)
Theorem Subq_countable : forall X Y:set, countable Y -> X c= Y -> countable X.
let X Y. assume HcountY HsubXY.
prove atleastp X omega.
apply atleastp_tra X Y omega.
- exact (Subq_atleastp X Y HsubXY).
- exact HcountY.
Qed.

(** Helper: intersection of a countable set with any set is countable **)
(** LATEX VERSION: Any subset of a countable set is countable; in particular XY is countable if X is countable. **)
Theorem binintersect_countable_left : forall X Y:set,
  countable X -> countable (X :/\: Y).
let X Y.
assume HcountX: countable X.
prove countable (X :/\: Y).
apply (Subq_countable (X :/\: Y) X HcountX).
exact (binintersect_Subq_1 X Y).
Qed.

(** Helper: set difference of a countable set is countable **)
(** LATEX VERSION: X\\A is countable if X is countable. **)
Theorem setminus_countable : forall X A:set,
  countable X -> countable (X :\: A).
let X A.
assume HcountX: countable X.
prove countable (X :\: A).
apply (Subq_countable (X :\: A) X HcountX).
exact (setminus_Subq X A).
Qed.

(** Helper: Union of two countable sets is countable **)
(** NOTE: This requires some form of choice or construction **)
Theorem binunion_countable : forall X Y:set, countable X -> countable Y -> countable (X :\/: Y).
let X Y.
assume HcountX: countable X.
assume HcountY: countable Y.
prove countable (X :\/: Y).
prove exists h : set -> set, inj (X :\/: Y) omega h.
apply HcountX.
let f : set -> set.
assume Hf: inj X omega f.
apply HcountY.
let g : set -> set.
assume Hg: inj Y omega g.
set h : set -> set := (fun u:set => if u :e X then nat_pair 0 (f u) else nat_pair 1 (g u)).
witness h.
prove inj (X :\/: Y) omega h.
apply (injI (X :\/: Y) omega h).
- (** h maps union into omega **)
  let u. assume Hu: u :e X :\/: Y.
  prove h u :e omega.
  claim HuXY: u :e X \/ u :e Y.
  { exact (binunionE X Y u Hu). }
  apply (xm (u :e X)).
  * assume HuX: u :e X.
    claim Hfmap: forall a :e X, f a :e omega.
    { exact (andEL (forall a :e X, f a :e omega)
                   (forall a b :e X, f a = f b -> a = b)
                   Hf). }
    claim Hu0: 0 :e omega.
    { exact (nat_p_omega 0 nat_0). }
    claim Hfu: f u :e omega.
    { exact (Hfmap u HuX). }
    claim Hp: nat_pair 0 (f u) :e omega.
    { exact (nat_pair_In_omega 0 Hu0 (f u) Hfu). }
	    claim Hhu_def: h u = if u :e X then nat_pair 0 (f u) else nat_pair 1 (g u).
	    { reflexivity. }
	    rewrite Hhu_def.
	    rewrite (If_i_1 (u :e X) (nat_pair 0 (f u)) (nat_pair 1 (g u)) HuX).
	    exact Hp.
  * assume HnotuX: ~(u :e X).
    claim Hug: u :e Y.
    { apply (HuXY (u :e Y)).
      - assume HuX: u :e X.
        apply FalseE.
        exact (HnotuX HuX).
      - assume HuY: u :e Y.
        exact HuY. }
    claim Hgmap: forall a :e Y, g a :e omega.
    { exact (andEL (forall a :e Y, g a :e omega)
                   (forall a b :e Y, g a = g b -> a = b)
                   Hg). }
    claim Hu1: 1 :e omega.
    { exact (nat_p_omega 1 nat_1). }
    claim Hgu: g u :e omega.
    { exact (Hgmap u Hug). }
    claim Hp: nat_pair 1 (g u) :e omega.
    { exact (nat_pair_In_omega 1 Hu1 (g u) Hgu). }
	    claim Hhu_def: h u = if u :e X then nat_pair 0 (f u) else nat_pair 1 (g u).
	    { reflexivity. }
	    rewrite Hhu_def.
	    rewrite (If_i_0 (u :e X) (nat_pair 0 (f u)) (nat_pair 1 (g u)) HnotuX).
	    exact Hp.
- (** h is injective on union **)
  let u. assume Hu: u :e X :\/: Y.
  let v. assume Hv: v :e X :\/: Y.
  assume Heq: h u = h v.
  prove u = v.
  claim HuXY: u :e X \/ u :e Y.
  { exact (binunionE X Y u Hu). }
  claim HvXY: v :e X \/ v :e Y.
  { exact (binunionE X Y v Hv). }
  claim Hfmap: forall a :e X, f a :e omega.
  { exact (andEL (forall a :e X, f a :e omega)
                 (forall a b :e X, f a = f b -> a = b)
                 Hf). }
  claim Hfinj: forall a b :e X, f a = f b -> a = b.
  { exact (andER (forall a :e X, f a :e omega)
                 (forall a b :e X, f a = f b -> a = b)
                 Hf). }
  claim Hgmap: forall a :e Y, g a :e omega.
  { exact (andEL (forall a :e Y, g a :e omega)
                 (forall a b :e Y, g a = g b -> a = b)
                 Hg). }
  claim Hginj: forall a b :e Y, g a = g b -> a = b.
  { exact (andER (forall a :e Y, g a :e omega)
                 (forall a b :e Y, g a = g b -> a = b)
                 Hg). }
  apply (xm (u :e X)).
  * assume HuX: u :e X.
    apply (xm (v :e X)).
    + assume HvX: v :e X.
      claim Hu0: 0 :e omega.
      { exact (nat_p_omega 0 nat_0). }
      claim Hfu: f u :e omega.
      { exact (Hfmap u HuX). }
      claim Hfv: f v :e omega.
      { exact (Hfmap v HvX). }
      claim Hhueq: h u = nat_pair 0 (f u).
      { claim Hhu_def: h u = if u :e X then nat_pair 0 (f u) else nat_pair 1 (g u).
        { reflexivity. }
        rewrite Hhu_def.
        rewrite (If_i_1 (u :e X) (nat_pair 0 (f u)) (nat_pair 1 (g u)) HuX).
        reflexivity. }
      claim Hhveq: h v = nat_pair 0 (f v).
      { claim Hhv_def: h v = if v :e X then nat_pair 0 (f v) else nat_pair 1 (g v).
        { reflexivity. }
        rewrite Hhv_def.
        rewrite (If_i_1 (v :e X) (nat_pair 0 (f v)) (nat_pair 1 (g v)) HvX).
        reflexivity. }
      claim Hpair: nat_pair 0 (f u) = nat_pair 0 (f v).
      { rewrite <- Hhueq.
        rewrite <- Hhveq.
        exact Heq. }
      claim HfuEq: f u = f v.
      { exact (nat_pair_1 0 Hu0 (f u) Hfu 0 Hu0 (f v) Hfv Hpair). }
      exact (Hfinj u HuX v HvX HfuEq).
    + assume HnotvX: ~(v :e X).
      claim HvY: v :e Y.
      { apply (HvXY (v :e Y)).
        - assume HvX: v :e X.
          apply FalseE.
          exact (HnotvX HvX).
        - assume HvY: v :e Y.
          exact HvY. }
      claim Hu0: 0 :e omega.
      { exact (nat_p_omega 0 nat_0). }
      claim Hu1: 1 :e omega.
      { exact (nat_p_omega 1 nat_1). }
      claim Hfu: f u :e omega.
      { exact (Hfmap u HuX). }
      claim Hgv: g v :e omega.
      { exact (Hgmap v HvY). }
      claim Hhueq: h u = nat_pair 0 (f u).
      { claim Hhu_def: h u = if u :e X then nat_pair 0 (f u) else nat_pair 1 (g u).
        { reflexivity. }
        rewrite Hhu_def.
        rewrite (If_i_1 (u :e X) (nat_pair 0 (f u)) (nat_pair 1 (g u)) HuX).
        reflexivity. }
      claim Hhveq: h v = nat_pair 1 (g v).
      { claim Hhv_def: h v = if v :e X then nat_pair 0 (f v) else nat_pair 1 (g v).
        { reflexivity. }
        rewrite Hhv_def.
        rewrite (If_i_0 (v :e X) (nat_pair 0 (f v)) (nat_pair 1 (g v)) HnotvX).
        reflexivity. }
      claim Hpair: nat_pair 0 (f u) = nat_pair 1 (g v).
      { rewrite <- Hhueq.
        rewrite <- Hhveq.
        exact Heq. }
      claim H01: 0 = 1.
      { exact (nat_pair_0 0 Hu0 (f u) Hfu 1 Hu1 (g v) Hgv Hpair). }
      apply FalseE.
      exact (neq_0_1 H01).
  * assume HnotuX: ~(u :e X).
    claim HuY: u :e Y.
    { apply (HuXY (u :e Y)).
      - assume HuX: u :e X.
        apply FalseE.
        exact (HnotuX HuX).
      - assume HuY: u :e Y.
        exact HuY. }
    apply (xm (v :e X)).
    + assume HvX: v :e X.
      claim Hu0: 0 :e omega.
      { exact (nat_p_omega 0 nat_0). }
      claim Hu1: 1 :e omega.
      { exact (nat_p_omega 1 nat_1). }
      claim Hfv: f v :e omega.
      { exact (Hfmap v HvX). }
      claim Hgu: g u :e omega.
      { exact (Hgmap u HuY). }
      claim Hhueq: h u = nat_pair 1 (g u).
      { claim Hhu_def: h u = if u :e X then nat_pair 0 (f u) else nat_pair 1 (g u).
        { reflexivity. }
        rewrite Hhu_def.
        rewrite (If_i_0 (u :e X) (nat_pair 0 (f u)) (nat_pair 1 (g u)) HnotuX).
        reflexivity. }
      claim Hhveq: h v = nat_pair 0 (f v).
      { claim Hhv_def: h v = if v :e X then nat_pair 0 (f v) else nat_pair 1 (g v).
        { reflexivity. }
        rewrite Hhv_def.
        rewrite (If_i_1 (v :e X) (nat_pair 0 (f v)) (nat_pair 1 (g v)) HvX).
        reflexivity. }
      claim Hpair: nat_pair 1 (g u) = nat_pair 0 (f v).
      { rewrite <- Hhueq.
        rewrite <- Hhveq.
        exact Heq. }
      claim H10: 1 = 0.
      { exact (nat_pair_0 1 Hu1 (g u) Hgu 0 Hu0 (f v) Hfv Hpair). }
      claim H01: 0 = 1.
      { symmetry. exact H10. }
      apply FalseE.
      exact (neq_0_1 H01).
    + assume HnotvX: ~(v :e X).
      claim HvY: v :e Y.
      { apply (HvXY (v :e Y)).
        - assume HvX: v :e X.
          apply FalseE.
          exact (HnotvX HvX).
        - assume HvY: v :e Y.
          exact HvY. }
      claim Hu1: 1 :e omega.
      { exact (nat_p_omega 1 nat_1). }
      claim Hgu: g u :e omega.
      { exact (Hgmap u HuY). }
      claim Hgv: g v :e omega.
      { exact (Hgmap v HvY). }
      claim Hhueq: h u = nat_pair 1 (g u).
      { claim Hhu_def: h u = if u :e X then nat_pair 0 (f u) else nat_pair 1 (g u).
        { reflexivity. }
        rewrite Hhu_def.
        rewrite (If_i_0 (u :e X) (nat_pair 0 (f u)) (nat_pair 1 (g u)) HnotuX).
        reflexivity. }
      claim Hhveq: h v = nat_pair 1 (g v).
      { claim Hhv_def: h v = if v :e X then nat_pair 0 (f v) else nat_pair 1 (g v).
        { reflexivity. }
        rewrite Hhv_def.
        rewrite (If_i_0 (v :e X) (nat_pair 0 (f v)) (nat_pair 1 (g v)) HnotvX).
        reflexivity. }
      claim Hpair: nat_pair 1 (g u) = nat_pair 1 (g v).
      { rewrite <- Hhueq.
        rewrite <- Hhveq.
        exact Heq. }
      claim HguEq: g u = g v.
      { exact (nat_pair_1 1 Hu1 (g u) Hgu 1 Hu1 (g v) Hgv Hpair). }
      exact (Hginj u HuY v HvY HguEq).
Qed.

(** Helper: dependent sum of countables is countable **)
(** LATEX VERSION: A countable union of countable sets is countable, encoded as a dependent sum with nat-pairing. **)
Theorem Sigma_countable : forall X:set, countable X ->
  forall Y:set->set, (forall x:set, x :e X -> countable (Y x)) ->
  countable (Sigma_ x :e X, Y x).
let X.
assume HX: countable X.
let Y.
assume HY: forall x:set, x :e X -> countable (Y x).
prove countable (Sigma_ x :e X, Y x).
prove exists h : set -> set, inj (Sigma_ x :e X, Y x) omega h.
apply HX.
let f : set -> set.
assume Hf: inj X omega f.
set graph : set -> (set -> set) -> set := fun A g => {(a, g a) | a :e A}.
set app : set -> set -> set := fun g a => Eps_i (fun n => (a,n) :e g).
set G : set -> set := fun x =>
  Eps_i (fun g => exists hx : set->set, inj (Y x) omega hx /\ g = graph (Y x) hx).
set h : set -> set := fun z =>
  nat_pair (f (proj0 z)) (app (G (proj0 z)) (proj1 z)).
witness h.

(** Helper: evaluating a graph built by Repl gives the original value **)
claim graph_app : forall A:set, forall g:set->set, forall a:set,
  a :e A -> app (graph A g) a = g a.
{ let A g a.
  assume Ha: a :e A.
  prove app (graph A g) a = g a.
  prove Eps_i (fun n => (a,n) :e graph A g) = g a.
  claim H1: (a, g a) :e graph A g.
  { exact (ReplI A (fun a0:set => (a0, g a0)) a Ha). }
  claim H2: (a, Eps_i (fun n => (a,n) :e graph A g)) :e graph A g.
  { exact (Eps_i_ax (fun n => (a,n) :e graph A g) (g a) H1). }
  apply (ReplE_impred A (fun a0:set => (a0, g a0)) (a, Eps_i (fun n => (a,n) :e graph A g)) H2).
  let a0.
  assume Ha0: a0 :e A.
  assume Heq: (a, Eps_i (fun n => (a,n) :e graph A g)) = (a0, g a0).
  claim Ha_eq: a = a0.
  { rewrite <- (tuple_2_0_eq a (Eps_i (fun n => (a,n) :e graph A g))).
    rewrite <- (tuple_2_0_eq a0 (g a0)).
    rewrite Heq.
    reflexivity. }
  claim Hn_eq: Eps_i (fun n => (a,n) :e graph A g) = g a0.
  { rewrite <- (tuple_2_1_eq a (Eps_i (fun n => (a,n) :e graph A g))) at 1.
    rewrite <- (tuple_2_1_eq a0 (g a0)) at 1.
    rewrite Heq.
    reflexivity. }
  rewrite Hn_eq.
  rewrite <- Ha_eq.
  reflexivity. }

(** Helper: graph evaluation under set equality **)
claim graph_app_eq : forall A:set, forall g:set->set, forall G0 a:set,
  a :e A -> G0 = graph A g -> app G0 a = g a.
{ let A g G0 a.
  assume Ha: a :e A.
  assume Heq: G0 = graph A g.
  prove app G0 a = g a.
  prove Eps_i (fun n => (a,n) :e G0) = g a.
  claim H1: (a, g a) :e G0.
  { rewrite Heq.
    exact (ReplI A (fun a0:set => (a0, g a0)) a Ha). }
  claim H2: (a, Eps_i (fun n => (a,n) :e G0)) :e G0.
  { exact (Eps_i_ax (fun n => (a,n) :e G0) (g a) H1). }
  claim H2g: (a, Eps_i (fun n => (a,n) :e G0)) :e graph A g.
  { rewrite <- Heq.
    exact H2. }
  apply (ReplE_impred A (fun a0:set => (a0, g a0)) (a, Eps_i (fun n => (a,n) :e G0)) H2g).
  let a0.
  assume Ha0: a0 :e A.
  assume Heq2: (a, Eps_i (fun n => (a,n) :e G0)) = (a0, g a0).
  claim Ha_eq: a = a0.
  { rewrite <- (tuple_2_0_eq a (Eps_i (fun n => (a,n) :e G0))).
    rewrite <- (tuple_2_0_eq a0 (g a0)).
    rewrite Heq2.
    reflexivity. }
  claim Hn_eq: Eps_i (fun n => (a,n) :e G0) = g a0.
  { rewrite <- (tuple_2_1_eq a (Eps_i (fun n => (a,n) :e G0))) at 1.
    rewrite <- (tuple_2_1_eq a0 (g a0)) at 1.
    rewrite Heq2.
    reflexivity. }
  rewrite Hn_eq.
  rewrite <- Ha_eq.
  reflexivity. }

apply (injI (Sigma_ x :e X, Y x) omega h).
- let z.
  assume Hz: z :e Sigma_ x :e X, Y x.
  prove h z :e omega.
  claim Hz0: proj0 z :e X.
  { exact (proj0_Sigma X Y z Hz). }
  claim Hz1: proj1 z :e Y (proj0 z).
  { exact (proj1_Sigma X Y z Hz). }
  claim Hfmap: forall a :e X, f a :e omega.
  { exact (andEL (forall a :e X, f a :e omega)
                 (forall a b :e X, f a = f b -> a = b)
                 Hf). }
  claim Hfz: f (proj0 z) :e omega.
  { exact (Hfmap (proj0 z) Hz0). }
  set x0 := proj0 z.
  claim HcountY: countable (Y x0).
  { exact (HY x0 Hz0). }
  apply HcountY.
  let hx : set->set.
  assume Hhx: inj (Y x0) omega hx.
  claim HPw: exists hx0 : set->set, inj (Y x0) omega hx0 /\ graph (Y x0) hx = graph (Y x0) hx0.
  { witness hx.
    apply andI.
    - exact Hhx.
    - reflexivity. }
  claim HGdef: G x0 = Eps_i (fun g => exists hx0 : set->set, inj (Y x0) omega hx0 /\ g = graph (Y x0) hx0).
  { reflexivity. }
  claim HQG: exists hx0 : set->set, inj (Y x0) omega hx0 /\ G x0 = graph (Y x0) hx0.
  { rewrite HGdef.
    exact (Eps_i_ax (fun g => exists hx0 : set->set, inj (Y x0) omega hx0 /\ g = graph (Y x0) hx0)
                    (graph (Y x0) hx)
                    HPw). }
  apply HQG.
  let hx0 : set->set.
  assume Hhx0pair.
  apply Hhx0pair.
  assume Hhx0 HGeq.
  claim Hhx0map: forall u :e Y x0, hx0 u :e omega.
  { exact (andEL (forall u :e Y x0, hx0 u :e omega)
                 (forall u v :e Y x0, hx0 u = hx0 v -> u = v)
                 Hhx0). }
  claim Hhy: hx0 (proj1 z) :e omega.
  { exact (Hhx0map (proj1 z) Hz1). }
  claim Happ: app (G x0) (proj1 z) = hx0 (proj1 z).
  { exact (graph_app_eq (Y x0) hx0 (G x0) (proj1 z) Hz1 HGeq). }
  claim Hhdef: h z = nat_pair (f (proj0 z)) (app (G (proj0 z)) (proj1 z)).
  { reflexivity. }
  rewrite Hhdef.
  rewrite Happ.
  exact (nat_pair_In_omega (f (proj0 z)) Hfz (hx0 (proj1 z)) Hhy).
- let z1.
  assume Hz1: z1 :e Sigma_ x :e X, Y x.
  let z2.
  assume Hz2: z2 :e Sigma_ x :e X, Y x.
  assume Heq: h z1 = h z2.
  prove z1 = z2.
  claim Hz10: proj0 z1 :e X.
  { exact (proj0_Sigma X Y z1 Hz1). }
  claim Hz20: proj0 z2 :e X.
  { exact (proj0_Sigma X Y z2 Hz2). }
  claim Hz11: proj1 z1 :e Y (proj0 z1).
  { exact (proj1_Sigma X Y z1 Hz1). }
  claim Hz21: proj1 z2 :e Y (proj0 z2).
  { exact (proj1_Sigma X Y z2 Hz2). }
  claim Hfmap: forall a :e X, f a :e omega.
  { exact (andEL (forall a :e X, f a :e omega)
                 (forall a b :e X, f a = f b -> a = b)
                 Hf). }
  claim Hfinj: forall a b :e X, f a = f b -> a = b.
  { exact (andER (forall a :e X, f a :e omega)
                 (forall a b :e X, f a = f b -> a = b)
                 Hf). }
  claim Hfz1: f (proj0 z1) :e omega.
  { exact (Hfmap (proj0 z1) Hz10). }
  claim Hfz2: f (proj0 z2) :e omega.
  { exact (Hfmap (proj0 z2) Hz20). }
  claim Hhy1: app (G (proj0 z1)) (proj1 z1) :e omega.
  { set x1 := proj0 z1.
    claim HcountY: countable (Y x1).
    { exact (HY x1 Hz10). }
    apply HcountY.
    let hx : set->set.
    assume Hhx: inj (Y x1) omega hx.
    claim HPw: exists hx0 : set->set, inj (Y x1) omega hx0 /\ graph (Y x1) hx = graph (Y x1) hx0.
    { witness hx.
      apply andI.
      - exact Hhx.
      - reflexivity. }
    claim HGdef: G x1 = Eps_i (fun g => exists hx0 : set->set, inj (Y x1) omega hx0 /\ g = graph (Y x1) hx0).
    { reflexivity. }
    claim HQG: exists hx0 : set->set, inj (Y x1) omega hx0 /\ G x1 = graph (Y x1) hx0.
	    { rewrite HGdef.
	      exact (Eps_i_ax (fun g => exists hx0 : set->set, inj (Y x1) omega hx0 /\ g = graph (Y x1) hx0)
	                      (graph (Y x1) hx)
	                      HPw). }
	    apply HQG.
	    let hx0 : set->set.
	    assume Hhx0pair.
	    apply Hhx0pair.
	    assume Hhx0 HGeq.
	    claim Hhx0map: forall u :e Y x1, hx0 u :e omega.
	    { exact (andEL (forall u :e Y x1, hx0 u :e omega)
	                   (forall u v :e Y x1, hx0 u = hx0 v -> u = v)
	                   Hhx0). }
	    claim Hhy: hx0 (proj1 z1) :e omega.
	    { exact (Hhx0map (proj1 z1) Hz11). }
	    claim Happ: app (G x1) (proj1 z1) = hx0 (proj1 z1).
	    { exact (graph_app_eq (Y x1) hx0 (G x1) (proj1 z1) Hz11 HGeq). }
	    rewrite Happ.
	    exact Hhy. }
  claim Hhy2: app (G (proj0 z2)) (proj1 z2) :e omega.
  { set x2 := proj0 z2.
    claim HcountY: countable (Y x2).
    { exact (HY x2 Hz20). }
	    apply HcountY.
	    let hx : set->set.
	    assume Hhx: inj (Y x2) omega hx.
	    claim HPw: exists hx0 : set->set, inj (Y x2) omega hx0 /\ graph (Y x2) hx = graph (Y x2) hx0.
	    { witness hx.
	      apply andI.
	      - exact Hhx.
	      - reflexivity. }
	    claim HGdef: G x2 = Eps_i (fun g => exists hx0 : set->set, inj (Y x2) omega hx0 /\ g = graph (Y x2) hx0).
	    { reflexivity. }
	    claim HQG: exists hx0 : set->set, inj (Y x2) omega hx0 /\ G x2 = graph (Y x2) hx0.
		    { rewrite HGdef.
		      exact (Eps_i_ax (fun g => exists hx0 : set->set, inj (Y x2) omega hx0 /\ g = graph (Y x2) hx0)
		                      (graph (Y x2) hx)
		                      HPw). }
		    apply HQG.
		    let hx0 : set->set.
		    assume Hhx0pair.
		    apply Hhx0pair.
		    assume Hhx0 HGeq.
	    claim Hhx0map: forall u :e Y x2, hx0 u :e omega.
	    { exact (andEL (forall u :e Y x2, hx0 u :e omega)
	                   (forall u v :e Y x2, hx0 u = hx0 v -> u = v)
	                   Hhx0). }
	    claim Hhy: hx0 (proj1 z2) :e omega.
	    { exact (Hhx0map (proj1 z2) Hz21). }
	    claim Happ: app (G x2) (proj1 z2) = hx0 (proj1 z2).
	    { exact (graph_app_eq (Y x2) hx0 (G x2) (proj1 z2) Hz21 HGeq). }
	    rewrite Happ.
	    exact Hhy. }
  claim Hhdef1: h z1 = nat_pair (f (proj0 z1)) (app (G (proj0 z1)) (proj1 z1)).
  { reflexivity. }
  claim Hhdef2: h z2 = nat_pair (f (proj0 z2)) (app (G (proj0 z2)) (proj1 z2)).
  { reflexivity. }
  claim Hpair: nat_pair (f (proj0 z1)) (app (G (proj0 z1)) (proj1 z1))
              = nat_pair (f (proj0 z2)) (app (G (proj0 z2)) (proj1 z2)).
  { rewrite <- Hhdef1.
    rewrite <- Hhdef2.
    exact Heq. }
  claim Hxeq: proj0 z1 = proj0 z2.
  { claim Hf0: f (proj0 z1) = f (proj0 z2).
    { exact (nat_pair_0 (f (proj0 z1)) Hfz1 (app (G (proj0 z1)) (proj1 z1)) Hhy1
                        (f (proj0 z2)) Hfz2 (app (G (proj0 z2)) (proj1 z2)) Hhy2
                        Hpair). }
    exact (Hfinj (proj0 z1) Hz10 (proj0 z2) Hz20 Hf0). }
  set x := proj0 z1.
  claim HxX: x :e X.
  { exact Hz10. }
  claim Hz2x: proj0 z2 = x.
  { symmetry. exact Hxeq. }
  claim Hy21': proj1 z2 :e Y x.
  { rewrite <- Hz2x.
    exact Hz21. }
  claim Hy11': proj1 z1 :e Y x.
  { claim Hxdef: x = proj0 z1.
    { reflexivity. }
    rewrite Hxdef.
    exact Hz11. }
  claim HcountY: countable (Y x).
  { exact (HY x HxX). }
  apply HcountY.
  let hx : set->set.
  assume Hhx: inj (Y x) omega hx.
  claim HPw: exists hx0 : set->set, inj (Y x) omega hx0 /\ graph (Y x) hx = graph (Y x) hx0.
  { witness hx.
    apply andI.
    - exact Hhx.
    - reflexivity. }
  claim HGdef: G x = Eps_i (fun g => exists hx0 : set->set, inj (Y x) omega hx0 /\ g = graph (Y x) hx0).
  { reflexivity. }
  claim HQG: exists hx0 : set->set, inj (Y x) omega hx0 /\ G x = graph (Y x) hx0.
  { rewrite HGdef.
    exact (Eps_i_ax (fun g => exists hx0 : set->set, inj (Y x) omega hx0 /\ g = graph (Y x) hx0)
                    (graph (Y x) hx)
                    HPw). }
  apply HQG.
  let hx0 : set->set.
  assume Hhx0pair.
  apply Hhx0pair.
  assume Hhx0 HGeq.
  claim Hhx0inj: forall u v :e Y x, hx0 u = hx0 v -> u = v.
  { exact (andER (forall u :e Y x, hx0 u :e omega)
                 (forall u v :e Y x, hx0 u = hx0 v -> u = v)
                 Hhx0). }
  claim Happ1: app (G x) (proj1 z1) = hx0 (proj1 z1).
  { exact (graph_app_eq (Y x) hx0 (G x) (proj1 z1) Hy11' HGeq). }
  claim Happ2: app (G x) (proj1 z2) = hx0 (proj1 z2).
  { exact (graph_app_eq (Y x) hx0 (G x) (proj1 z2) Hy21' HGeq). }
  claim Hn_eq: app (G x) (proj1 z1) = app (G x) (proj1 z2).
  { claim Hn0: app (G (proj0 z1)) (proj1 z1) = app (G (proj0 z2)) (proj1 z2).
    { exact (nat_pair_1 (f (proj0 z1)) Hfz1 (app (G (proj0 z1)) (proj1 z1)) Hhy1
                        (f (proj0 z2)) Hfz2 (app (G (proj0 z2)) (proj1 z2)) Hhy2
                        Hpair). }
    claim Hxdef: x = proj0 z1.
    { reflexivity. }
    rewrite Hxdef.
    rewrite Hxeq at 2.
    exact Hn0. }
  claim Hhx0eq: hx0 (proj1 z1) = hx0 (proj1 z2).
  { rewrite <- Happ1.
    rewrite <- Happ2.
    exact Hn_eq. }
  claim Hyeq: proj1 z1 = proj1 z2.
  { exact (Hhx0inj (proj1 z1) Hy11' (proj1 z2) Hy21' Hhx0eq). }
  apply (Sigma_eta_proj0_proj1 X Y z1 Hz1).
  assume Heta1core Heta1Y.
  apply Heta1core.
  assume Heta1 Heta1X.
  apply (Sigma_eta_proj0_proj1 X Y z2 Hz2).
  assume Heta2core Heta2Y.
  apply Heta2core.
  assume Heta2 Heta2X.
  rewrite <- Heta1.
  rewrite <- Heta2.
  rewrite Hxeq.
  rewrite Hyeq.
  reflexivity.
Qed.

(** Helper: product of two countable sets is countable **)
(** LATEX VERSION: If X and Y are countable then XY is countable via nat-pairing of injections. **)
Theorem setprod_countable : forall X Y:set, countable X -> countable Y -> countable (X :*: Y).
let X Y.
assume HX: countable X.
assume HY: countable Y.
prove countable (X :*: Y).
prove exists h : set -> set, inj (X :*: Y) omega h.
apply HX.
let f : set -> set.
assume Hf: inj X omega f.
apply HY.
let g : set -> set.
assume Hg: inj Y omega g.
set Yc : set -> set := fun _ => Y.
set h : set -> set := fun z => nat_pair (f (proj0 z)) (g (proj1 z)).
witness h.
apply (injI (X :*: Y) omega h).
- let z. assume Hz: z :e X :*: Y.
  prove h z :e omega.
  claim Hz0: proj0 z :e X.
  { exact (proj0_Sigma X Yc z Hz). }
  claim Hz1: proj1 z :e Y.
  { exact (proj1_Sigma X Yc z Hz). }
  claim Hfmap: forall a :e X, f a :e omega.
  { exact (andEL (forall a :e X, f a :e omega)
                 (forall a b :e X, f a = f b -> a = b)
                 Hf). }
  claim Hgmap: forall b :e Y, g b :e omega.
  { exact (andEL (forall b :e Y, g b :e omega)
                 (forall b1 b2 :e Y, g b1 = g b2 -> b1 = b2)
                 Hg). }
  claim Hfz: f (proj0 z) :e omega.
  { exact (Hfmap (proj0 z) Hz0). }
  claim Hgz: g (proj1 z) :e omega.
  { exact (Hgmap (proj1 z) Hz1). }
  claim Hhdef: h z = nat_pair (f (proj0 z)) (g (proj1 z)).
  { reflexivity. }
  rewrite Hhdef.
  exact (nat_pair_In_omega (f (proj0 z)) Hfz (g (proj1 z)) Hgz).
- let z1. assume Hz1: z1 :e X :*: Y.
  let z2. assume Hz2: z2 :e X :*: Y.
  assume Hhz: h z1 = h z2.
  prove z1 = z2.
  apply (Sigma_E X Yc z1 Hz1).
  let x1. assume Hx1pair.
  apply Hx1pair.
  assume Hx1X Hexy1.
  apply Hexy1.
  let y1. assume Hy1pair.
  apply Hy1pair.
  assume Hy1Y Hz1eq.
  apply (Sigma_E X Yc z2 Hz2).
  let x2. assume Hx2pair.
  apply Hx2pair.
  assume Hx2X Hexy2.
  apply Hexy2.
  let y2. assume Hy2pair.
  apply Hy2pair.
  assume Hy2Y Hz2eq.
  claim Hfmap: forall a :e X, f a :e omega.
  { exact (andEL (forall a :e X, f a :e omega)
                 (forall a b :e X, f a = f b -> a = b)
                 Hf). }
  claim Hgmap: forall b :e Y, g b :e omega.
  { exact (andEL (forall b :e Y, g b :e omega)
                 (forall b1 b2 :e Y, g b1 = g b2 -> b1 = b2)
                 Hg). }
  claim Hfinj: forall a b :e X, f a = f b -> a = b.
  { exact (andER (forall a :e X, f a :e omega)
                 (forall a b :e X, f a = f b -> a = b)
                 Hf). }
  claim Hginj: forall b1 b2 :e Y, g b1 = g b2 -> b1 = b2.
  { exact (andER (forall b :e Y, g b :e omega)
                 (forall b1 b2 :e Y, g b1 = g b2 -> b1 = b2)
                 Hg). }
	  claim Hproj01: proj0 z1 = x1.
	  { rewrite (proj0_ap_0 z1).
	    rewrite Hz1eq.
	    exact (pair_ap_0 x1 y1). }
	  claim Hproj11: proj1 z1 = y1.
	  { rewrite (proj1_ap_1 z1).
	    rewrite Hz1eq.
	    exact (pair_ap_1 x1 y1). }
	  claim Hproj02: proj0 z2 = x2.
	  { rewrite (proj0_ap_0 z2).
	    rewrite Hz2eq.
	    exact (pair_ap_0 x2 y2). }
	  claim Hproj12: proj1 z2 = y2.
	  { rewrite (proj1_ap_1 z2).
	    rewrite Hz2eq.
	    exact (pair_ap_1 x2 y2). }
  claim Hh1: h z1 = nat_pair (f x1) (g y1).
  { claim Hhdef: h z1 = nat_pair (f (proj0 z1)) (g (proj1 z1)).
    { reflexivity. }
    rewrite Hhdef.
    rewrite Hproj01.
    rewrite Hproj11.
    reflexivity. }
  claim Hh2: h z2 = nat_pair (f x2) (g y2).
  { claim Hhdef: h z2 = nat_pair (f (proj0 z2)) (g (proj1 z2)).
    { reflexivity. }
    rewrite Hhdef.
    rewrite Hproj02.
    rewrite Hproj12.
    reflexivity. }
  claim Hpair: nat_pair (f x1) (g y1) = nat_pair (f x2) (g y2).
  { rewrite <- Hh1. rewrite <- Hh2. exact Hhz. }
  claim Hf1: f x1 :e omega.
  { exact (Hfmap x1 Hx1X). }
  claim Hf2: f x2 :e omega.
  { exact (Hfmap x2 Hx2X). }
  claim Hg1: g y1 :e omega.
  { exact (Hgmap y1 Hy1Y). }
  claim Hg2: g y2 :e omega.
  { exact (Hgmap y2 Hy2Y). }
  claim Heqf: f x1 = f x2.
  { exact (nat_pair_0 (f x1) Hf1 (g y1) Hg1
                      (f x2) Hf2 (g y2) Hg2
                      Hpair). }
  claim Heqx: x1 = x2.
  { exact (Hfinj x1 Hx1X x2 Hx2X Heqf). }
  claim Heqg: g y1 = g y2.
  { exact (nat_pair_1 (f x1) Hf1 (g y1) Hg1
                      (f x2) Hf2 (g y2) Hg2
                      Hpair). }
	  claim Heqy: y1 = y2.
	  { exact (Hginj y1 Hy1Y y2 Hy2Y Heqg). }
  rewrite Hz1eq.
  rewrite Hz2eq.
  rewrite Heqx.
  rewrite Heqy.
  reflexivity.
Qed.

(** Helper: Union of a family preserves Power set membership **)
Theorem Union_Power : forall X Fam:set,
  Fam c= Power X -> Union Fam c= X.
let X Fam.
assume HFam: Fam c= Power X.
prove Union Fam c= X.
let x. assume Hx: x :e Union Fam.
prove x :e X.
apply (UnionE_impred Fam x Hx).
let U. assume HxU: x :e U. assume HU: U :e Fam.
claim HUPower: U :e Power X.
{ exact (HFam U HU). }
claim HUsub: U c= X.
{ exact (PowerE X U HUPower). }
exact (HUsub x HxU).
Qed.

(** Helper: Binary intersection of Power set members is in Power set **)
Theorem binintersect_Power : forall X U V:set,
  U :e Power X -> V :e Power X -> U :/\: V :e Power X.
let X U V.
assume HU: U :e Power X.
assume HV: V :e Power X.
prove U :/\: V :e Power X.
apply PowerI.
let x. assume Hx: x :e U :/\: V.
prove x :e X.
claim HxU: x :e U.
{ exact (binintersectE1 U V x Hx). }
claim HUsub: U c= X.
{ exact (PowerE X U HU). }
exact (HUsub x HxU).
Qed.

(** Helper: Setminus with subset is in Power set **)
Theorem setminus_Power : forall X U:set,
  U :e Power X -> X :\: U :e Power X.
let X U.
assume HU: U :e Power X.
prove X :\: U :e Power X.
apply PowerI.
let x. assume Hx: x :e X :\: U.
prove x :e X.
exact (setminusE1 X U x Hx).
Qed.

(** from 12 Example 4: countable complement topology **)
(** LATEX VERSION: Example 4 defines T_c = { U  X | X\\U is countable or U =  }, the countable complement topology. **)
Definition countable_complement_topology : set -> set :=
  fun X => {U :e Power X | countable (X :\: U) \/ U = Empty}.

(** from 12 Example 4: countable complement topology is a topology **)
(** LATEX VERSION: The countable complement collection T_c on X is a topology: , X are open; arbitrary unions and finite intersections remain in T_c. **)
Theorem countable_complement_topology_on : forall X, topology_on X (countable_complement_topology X).
let X.
claim HEmptyOpen : Empty :e countable_complement_topology X.
{ exact (SepI (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty)
              Empty (Empty_In_Power X)
              (orIR (countable (X :\: Empty)) (Empty = Empty) (fun P H => H))). }
prove countable_complement_topology X c= Power X
/\ Empty :e countable_complement_topology X
/\ X :e countable_complement_topology X
/\ (forall UFam :e Power (countable_complement_topology X), Union UFam :e countable_complement_topology X)
/\ (forall U :e countable_complement_topology X, forall V :e countable_complement_topology X, U :/\: V :e countable_complement_topology X).
apply andI.
- prove (countable_complement_topology X c= Power X /\ Empty :e countable_complement_topology X) /\ X :e countable_complement_topology X /\ (forall UFam :e Power (countable_complement_topology X), Union UFam :e countable_complement_topology X).
  apply andI.
  * prove countable_complement_topology X c= Power X /\ Empty :e countable_complement_topology X /\ X :e countable_complement_topology X.
    apply andI.
    { prove countable_complement_topology X c= Power X /\ Empty :e countable_complement_topology X.
      apply andI.
      - let U. assume HU: U :e countable_complement_topology X.
        exact (SepE1 (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty) U HU).
      - exact HEmptyOpen.
    }
    { claim Hdiff_empty : X :\: X = Empty.
      { apply Empty_Subq_eq.
        let x. assume Hx.
        claim HxX : x :e X.
        { exact (setminusE1 X X x Hx). }
        claim Hxnot : x /:e X.
        { exact (setminusE2 X X x Hx). }
        apply FalseE.
        exact (Hxnot HxX).
      }
      claim HcountDiff : countable (X :\: X).
      { rewrite Hdiff_empty. exact countable_Empty. }
      exact (SepI (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty)
                  X (Self_In_Power X)
                  (orIL (countable (X :\: X)) (X = Empty) HcountDiff)).
    }
  * prove forall UFam :e Power (countable_complement_topology X), Union UFam :e countable_complement_topology X.
    let UFam. assume Hfam: UFam :e Power (countable_complement_topology X).
    claim Hsub : UFam c= countable_complement_topology X.
    { exact (PowerE (countable_complement_topology X) UFam Hfam). }
    apply xm (exists U:set, U :e UFam /\ countable (X :\: U)).
    - assume Hex: exists U:set, U :e UFam /\ countable (X :\: U).
      claim HUnionInPower : Union UFam :e Power X.
      { apply PowerI X (Union UFam).
        let x. assume HxUnion.
        apply UnionE_impred UFam x HxUnion.
        let U. assume HxU HUin.
        claim HUinPow : U :e Power X.
        { exact (SepE1 (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty) U (Hsub U HUin)). }
        claim HUsubX : U c= X.
        { exact (PowerE X U HUinPow). }
        exact (HUsubX x HxU).
      }
      claim HUnionPred : countable (X :\: Union UFam) \/ Union UFam = Empty.
      { apply orIL.
        apply Hex.
        let U. assume HUdata. apply HUdata.
        assume HUin.
        assume HUcount.
        prove countable (X :\: Union UFam).
        claim Hsubset : X :\: Union UFam c= X :\: U.
        { let x. assume Hx.
          claim HxX : x :e X.
          { exact (setminusE1 X (Union UFam) x Hx). }
          claim HnotUnion : x /:e Union UFam.
          { exact (setminusE2 X (Union UFam) x Hx). }
          claim HnotU : x /:e U.
          { assume HxU.
            apply HnotUnion.
            exact (UnionI UFam x U HxU HUin).
          }
          apply setminusI.
          - exact HxX.
          - exact HnotU.
        }
        exact (Subq_countable (X :\: Union UFam) (X :\: U) HUcount Hsubset).
      }
      exact (SepI (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty)
                  (Union UFam) HUnionInPower HUnionPred).
    - assume Hnone: ~exists U:set, U :e UFam /\ countable (X :\: U).
      claim HUnionEmpty : Union UFam = Empty.
      { apply Empty_Subq_eq.
        let x. assume HxUnion.
        apply UnionE_impred UFam x HxUnion.
        let U. assume HxU HUin.
        claim HUdata : countable (X :\: U) \/ U = Empty.
        { exact (SepE2 (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty) U (Hsub U HUin)). }
        apply HUdata (x :e Empty).
        - assume HUcount.
          apply FalseE.
          apply Hnone.
          witness U.
          apply andI.
          + exact HUin.
          + exact HUcount.
        - assume HUempty : U = Empty.
          rewrite <- HUempty.
          exact HxU.
      }
      rewrite HUnionEmpty.
      exact HEmptyOpen.
- prove forall U :e countable_complement_topology X, forall V :e countable_complement_topology X, U :/\: V :e countable_complement_topology X.
  let U. assume HU: U :e countable_complement_topology X.
  let V. assume HV: V :e countable_complement_topology X.
  claim HUdata : countable (X :\: U) \/ U = Empty.
  { exact (SepE2 (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty) U HU). }
  claim HVdata : countable (X :\: V) \/ V = Empty.
  { exact (SepE2 (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty) V HV). }
  apply HUdata (U :/\: V :e countable_complement_topology X).
  * assume HUcount.
    apply HVdata (U :/\: V :e countable_complement_topology X).
    { assume HVcount.
      claim HcapInPower : U :/\: V :e Power X.
      { claim HUsub : U c= X.
        { exact (PowerE X U (SepE1 (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty) U HU)). }
        apply PowerI X (U :/\: V).
        let x. assume HxCap.
        apply binintersectE U V x HxCap.
        assume HxU HxV.
        exact (HUsub x HxU).
      }
      claim HcapPred : countable (X :\: (U :/\: V)) \/ U :/\: V = Empty.
      { apply orIL.
        claim HcountUnion : countable ((X :\: U) :\/: (X :\: V)).
        { exact (binunion_countable (X :\: U) (X :\: V) HUcount HVcount). }
        claim Hsubset : X :\: (U :/\: V) c= (X :\: U) :\/: (X :\: V).
        { let x. assume Hx.
          claim HxX : x :e X.
          { exact (setminusE1 X (U :/\: V) x Hx). }
          claim HnotCap : x /:e U :/\: V.
          { exact (setminusE2 X (U :/\: V) x Hx). }
          apply xm (x :e U).
          - assume HxU.
            claim HnotV : x /:e V.
            { assume HxV.
              apply HnotCap.
              exact (binintersectI U V x HxU HxV).
            }
            apply binunionI2 (X :\: U) (X :\: V).
            apply setminusI X V x HxX HnotV.
          - assume HnotU.
            apply binunionI1 (X :\: U) (X :\: V).
            apply setminusI X U x HxX HnotU.
        }
        exact (Subq_countable (X :\: (U :/\: V)) ((X :\: U) :\/: (X :\: V)) HcountUnion Hsubset).
      }
      exact (SepI (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty)
                  (U :/\: V) HcapInPower HcapPred).
    }
    { assume HVempty : V = Empty.
      claim Hcap_empty : U :/\: V = Empty.
      { rewrite HVempty.
        apply Empty_Subq_eq.
        exact (binintersect_Subq_2 U Empty).
      }
      rewrite Hcap_empty.
      exact HEmptyOpen.
    }
  * assume HUempty : U = Empty.
    claim Hcap_empty : U :/\: V = Empty.
    { rewrite HUempty.
      apply Empty_Subq_eq.
      exact (binintersect_Subq_1 Empty V).
    }
    rewrite Hcap_empty.
    exact HEmptyOpen.
Qed.

(** from 12: discrete topology is a topology **)
(** LATEX VERSION: The discrete topology on any set X satisfies the axioms of a topology. **)
Theorem discrete_topology_on : forall X, topology_on X (discrete_topology X).
let X.
prove Power X c= Power X
/\ Empty :e Power X
/\ X :e Power X
/\ (forall UFam :e Power (Power X), Union UFam :e Power X)
/\ (forall U :e Power X, forall V :e Power X, U :/\: V :e Power X).
apply andI.
- prove ((Power X c= Power X /\ Empty :e Power X) /\ X :e Power X /\ (forall UFam :e Power (Power X), Union UFam :e Power X)).
  apply andI.
  * prove Power X c= Power X /\ Empty :e Power X /\ X :e Power X.
    apply andI.
    { prove Power X c= Power X /\ Empty :e Power X.
      apply andI.
      - exact (Subq_ref (Power X)).
      - apply Empty_In_Power.
    }
    { apply PowerI. exact (Subq_ref X). }
  * prove forall UFam :e Power (Power X), Union UFam :e Power X.
    let UFam. assume Hfam: UFam :e Power (Power X).
    apply PowerI X (Union UFam).
    let x. assume HxUnion: x :e Union UFam.
    apply UnionE_impred UFam x HxUnion.
    let U. assume HUinx: x :e U. assume HUinFam: U :e UFam.
    claim HFamSub: UFam c= Power X.
    { exact (iffEL (UFam :e Power (Power X)) (UFam c= Power X) (PowerEq (Power X) UFam) Hfam). }
    claim HUinPower: U :e Power X.
    { exact HFamSub U HUinFam. }
    claim HUsub : U c= X.
    { exact (iffEL (U :e Power X) (U c= X) (PowerEq X U) HUinPower). }
    exact (HUsub x HUinx).
- prove forall U :e Power X, forall V :e Power X, U :/\: V :e Power X.
  let U. assume HU: U :e Power X.
  let V. assume HV: V :e Power X.
  apply PowerI X (U :/\: V).
  let x. assume Hxcap: x :e U :/\: V.
  apply binintersectE U V x Hxcap.
  assume HxU HxV.
  claim HUsub: U c= X.
  { exact (iffEL (U :e Power X) (U c= X) (PowerEq X U) HU). }
  exact (HUsub x HxU).
Qed.

(** from 12: indiscrete topology is a topology **)
(** LATEX VERSION: The trivial/indiscrete topology {, X} on any set X satisfies the topology axioms. **)
Theorem indiscrete_topology_on : forall X, topology_on X (indiscrete_topology X).
let X.
prove indiscrete_topology X c= Power X
/\ Empty :e indiscrete_topology X
/\ X :e indiscrete_topology X
/\ (forall UFam :e Power (indiscrete_topology X), Union UFam :e indiscrete_topology X)
/\ (forall U :e indiscrete_topology X, forall V :e indiscrete_topology X, U :/\: V :e indiscrete_topology X).
apply andI.
- prove (indiscrete_topology X c= Power X /\ Empty :e indiscrete_topology X) /\ X :e indiscrete_topology X /\ (forall UFam :e Power (indiscrete_topology X), Union UFam :e indiscrete_topology X).
  apply andI.
  * prove indiscrete_topology X c= Power X /\ Empty :e indiscrete_topology X /\ X :e indiscrete_topology X.
    apply andI.
    { prove indiscrete_topology X c= Power X /\ Empty :e indiscrete_topology X.
      apply andI.
      - let U. assume HU: U :e indiscrete_topology X.
        apply UPairE U Empty X HU.
        + assume HUe: U = Empty. rewrite HUe. exact (Empty_In_Power X).
        + assume HUX: U = X. rewrite HUX. exact (Self_In_Power X).
      - exact (UPairI1 Empty X).
    }
    { exact (UPairI2 Empty X). }
  * prove forall UFam :e Power (indiscrete_topology X), Union UFam :e indiscrete_topology X.
    let UFam. assume Hfam: UFam :e Power (indiscrete_topology X).
    claim Hsub : UFam c= indiscrete_topology X.
    { exact (PowerE (indiscrete_topology X) UFam Hfam). }
    apply xm (exists U:set, U :e UFam /\ U = X).
    - assume Hex: exists U:set, U :e UFam /\ U = X.
      claim HUnion_sub : Union UFam c= X.
      { let x. assume HxUnion.
        apply UnionE_impred UFam x HxUnion.
        let U. assume HxU HUin.
        claim HUtop : U :e indiscrete_topology X.
        { exact (Hsub U HUin). }
        apply UPairE U Empty X HUtop.
        - assume HUe: U = Empty.
          claim HxEmpty : x :e Empty.
          { rewrite <- HUe. exact HxU. }
          exact (EmptyE x HxEmpty (x :e X)).
        - assume HUX: U = X.
          rewrite <- HUX.
          exact HxU.
      }
      claim HX_sub : X c= Union UFam.
      { let x. assume HxX.
        apply Hex.
        let U. assume HUinpair : U :e UFam /\ U = X.
        claim HUin : U :e UFam.
        { exact (andEL (U :e UFam) (U = X) HUinpair). }
        claim HUeq : U = X.
        { exact (andER (U :e UFam) (U = X) HUinpair). }
        claim HxU : x :e U.
        { rewrite HUeq. exact HxX. }
        apply UnionI UFam x U HxU HUin.
      }
      claim HUnion_eq : Union UFam = X.
      { apply set_ext.
        - exact HUnion_sub.
        - exact HX_sub.
      }
      rewrite HUnion_eq.
      exact (UPairI2 Empty X).
    - assume Hnone: ~exists U:set, U :e UFam /\ U = X.
      claim HUnion_empty : Union UFam = Empty.
      { apply Empty_Subq_eq.
        let x. assume HxUnion.
        apply UnionE_impred UFam x HxUnion.
        let U. assume HxU HUin.
        claim HUtop : U :e indiscrete_topology X.
        { exact (Hsub U HUin). }
        apply UPairE U Empty X HUtop.
        - assume HUe: U = Empty.
          claim HxEmpty : x :e Empty.
          { rewrite <- HUe. exact HxU. }
          exact HxEmpty.
        - assume HUX: U = X.
          apply FalseE.
          apply Hnone.
          witness U.
          apply andI.
          + exact HUin.
          + exact HUX.
      }
      rewrite HUnion_empty. exact (UPairI1 Empty X).
- prove forall U :e indiscrete_topology X, forall V :e indiscrete_topology X, U :/\: V :e indiscrete_topology X.
  let U. assume HU: U :e indiscrete_topology X.
  let V. assume HV: V :e indiscrete_topology X.
  apply UPairE U Empty X HU.
  * assume HUe: U = Empty.
    claim Hcap : U :/\: V = Empty.
    { rewrite HUe.
      apply Empty_Subq_eq.
      exact (binintersect_Subq_1 Empty V).
    }
    rewrite Hcap. exact (UPairI1 Empty X).
  * assume HUX: U = X.
    apply UPairE V Empty X HV.
    { assume HVe: V = Empty.
      claim Hcap : U :/\: V = Empty.
      { rewrite HVe.
        apply Empty_Subq_eq.
        exact (binintersect_Subq_2 U Empty).
      }
      rewrite Hcap. exact (UPairI1 Empty X).
    }
    { assume HVX: V = X.
      claim Hcap : U :/\: V = X.
      { apply set_ext.
        - rewrite HUX. rewrite HVX. exact (binintersect_Subq_1 X X).
        - let x. assume HxX.
          rewrite HUX. rewrite HVX.
          exact (binintersectI X X x HxX HxX).
      }
      rewrite Hcap. exact (UPairI2 Empty X).
    }
Qed.

(** from 12 Example 3: finite complement topology is a topology **)
(** LATEX VERSION: The finite complement collection T_f on X is a topology: , X are open; arbitrary unions and finite intersections remain in T_f. **)
Theorem finite_complement_topology_on : forall X, topology_on X (finite_complement_topology X).
let X.
claim HEmptyOpen : Empty :e finite_complement_topology X.
{ exact (SepI (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) Empty (Empty_In_Power X) (orIR (finite (X :\: Empty)) (Empty = Empty) (fun P H => H))). }
prove finite_complement_topology X c= Power X
/\ Empty :e finite_complement_topology X
/\ X :e finite_complement_topology X
/\ (forall UFam :e Power (finite_complement_topology X), Union UFam :e finite_complement_topology X)
/\ (forall U :e finite_complement_topology X, forall V :e finite_complement_topology X, U :/\: V :e finite_complement_topology X).
apply andI.
- prove (finite_complement_topology X c= Power X /\ Empty :e finite_complement_topology X) /\ X :e finite_complement_topology X /\ (forall UFam :e Power (finite_complement_topology X), Union UFam :e finite_complement_topology X).
  apply andI.
  * prove finite_complement_topology X c= Power X /\ Empty :e finite_complement_topology X /\ X :e finite_complement_topology X.
    apply andI.
    { prove finite_complement_topology X c= Power X /\ Empty :e finite_complement_topology X.
      apply andI.
      - let U. assume HU: U :e finite_complement_topology X.
        exact (SepE1 (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) U HU).
      - exact (SepI (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) Empty (Empty_In_Power X) (orIR (finite (X :\: Empty)) (Empty = Empty) (fun P H => H))).
    }
    { claim Hdiff_empty : X :\: X = Empty.
      { apply Empty_Subq_eq.
        let x. assume Hx.
        claim HxX : x :e X.
        { exact (setminusE1 X X x Hx). }
        claim Hxnot : x /:e X.
        { exact (setminusE2 X X x Hx). }
        apply FalseE.
        exact (Hxnot HxX).
      }
      claim HfinDiff : finite (X :\: X).
      { rewrite Hdiff_empty. exact finite_Empty. }
      exact (SepI (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) X (Self_In_Power X) (orIL (finite (X :\: X)) (X = Empty) HfinDiff)).
    }
  * prove forall UFam :e Power (finite_complement_topology X), Union UFam :e finite_complement_topology X.
    let UFam. assume Hfam: UFam :e Power (finite_complement_topology X).
    claim Hsub : UFam c= finite_complement_topology X.
    { exact (PowerE (finite_complement_topology X) UFam Hfam). }
    apply xm (exists U:set, U :e UFam /\ finite (X :\: U)).
    - assume Hex: exists U:set, U :e UFam /\ finite (X :\: U).
      claim HUnionInPower : Union UFam :e Power X.
      { apply PowerI X (Union UFam).
        let x. assume HxUnion.
        apply UnionE_impred UFam x HxUnion.
        let U. assume HxU HUin.
        claim HUinPow : U :e Power X.
        { exact (SepE1 (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) U (Hsub U HUin)). }
        claim HUsub : U c= X.
        { exact (PowerE X U HUinPow). }
        exact (HUsub x HxU).
      }
      claim HUnionPred : finite (X :\: Union UFam) \/ Union UFam = Empty.
      { apply orIL.
        apply Hex.
        let U. assume Hpair : U :e UFam /\ finite (X :\: U).
        claim HUin : U :e UFam.
        { exact (andEL (U :e UFam) (finite (X :\: U)) Hpair). }
        claim HUfin : finite (X :\: U).
        { exact (andER (U :e UFam) (finite (X :\: U)) Hpair). }
        claim Hsubset : X :\: Union UFam c= X :\: U.
        { let x. assume Hx.
          claim HxX : x :e X.
          { exact (setminusE1 X (Union UFam) x Hx). }
          claim HnotUnion : x /:e Union UFam.
          { exact (setminusE2 X (Union UFam) x Hx). }
          claim HnotU : x /:e U.
          { assume HxU.
            apply HnotUnion.
            apply UnionI UFam x U HxU HUin.
          }
          apply setminusI X U x HxX HnotU.
        }
        exact (Subq_finite (X :\: U) HUfin (X :\: Union UFam) Hsubset).
      }
      exact (SepI (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) (Union UFam) HUnionInPower HUnionPred).
    - assume Hnone: ~exists U:set, U :e UFam /\ finite (X :\: U).
      claim HUnionEmpty : Union UFam = Empty.
      { apply Empty_Subq_eq.
        let x. assume HxUnion.
        apply UnionE_impred UFam x HxUnion.
        let U. assume HxU HUin.
        claim HUdata : finite (X :\: U) \/ U = Empty.
        { exact (SepE2 (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) U (Hsub U HUin)). }
        apply HUdata (x :e Empty).
        - assume HUfin.
          apply FalseE.
          apply Hnone.
          witness U.
          apply andI.
          + exact HUin.
          + exact HUfin.
        - assume HUempty : U = Empty.
          rewrite <- HUempty.
          exact HxU.
      }
      rewrite HUnionEmpty.
      exact HEmptyOpen.
- prove forall U :e finite_complement_topology X, forall V :e finite_complement_topology X, U :/\: V :e finite_complement_topology X.
  let U. assume HU: U :e finite_complement_topology X.
  let V. assume HV: V :e finite_complement_topology X.
  claim HUdata : finite (X :\: U) \/ U = Empty.
  { exact (SepE2 (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) U HU). }
  claim HVdata : finite (X :\: V) \/ V = Empty.
  { exact (SepE2 (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) V HV). }
  apply HUdata (U :/\: V :e finite_complement_topology X).
  * assume HUfin.
    apply HVdata (U :/\: V :e finite_complement_topology X).
    { assume HVfin.
      claim HcapInPower : U :/\: V :e Power X.
      { claim HUsub : U c= X.
        { exact (PowerE X U (SepE1 (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) U HU)). }
        apply PowerI X (U :/\: V).
        let x. assume HxCap.
        apply binintersectE U V x HxCap.
        assume HxU HxV.
        exact (HUsub x HxU).
      }
      claim HcapPred : finite (X :\: (U :/\: V)) \/ U :/\: V = Empty.
      { apply orIL.
        claim HfinUnion : finite ((X :\: U) :\/: (X :\: V)).
        { exact (binunion_finite (X :\: U) HUfin (X :\: V) HVfin). }
        claim Hsubset : X :\: (U :/\: V) c= (X :\: U) :\/: (X :\: V).
        { let x. assume Hx.
          claim HxX : x :e X.
          { exact (setminusE1 X (U :/\: V) x Hx). }
          claim HnotCap : x /:e U :/\: V.
          { exact (setminusE2 X (U :/\: V) x Hx). }
          apply xm (x :e U).
          - assume HxU.
            claim HnotV : x /:e V.
            { assume HxV.
              apply HnotCap.
              exact (binintersectI U V x HxU HxV).
            }
            apply binunionI2 (X :\: U) (X :\: V).
            apply setminusI X V x HxX HnotV.
          - assume HnotU.
            apply binunionI1 (X :\: U) (X :\: V).
            apply setminusI X U x HxX HnotU.
        }
        exact (Subq_finite ((X :\: U) :\/: (X :\: V)) HfinUnion (X :\: (U :/\: V)) Hsubset).
      }
      exact (SepI (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) (U :/\: V) HcapInPower HcapPred).
    }
    { assume HVempty : V = Empty.
      claim Hcap_empty : U :/\: V = Empty.
      { rewrite HVempty.
        apply Empty_Subq_eq.
        exact (binintersect_Subq_2 U Empty).
      }
      rewrite Hcap_empty.
      exact HEmptyOpen.
    }
  * assume HUempty : U = Empty.
    claim Hcap_empty : U :/\: V = Empty.
    { rewrite HUempty.
      apply Empty_Subq_eq.
      exact (binintersect_Subq_1 Empty V).
    }
    rewrite Hcap_empty.
    exact HEmptyOpen.
Qed.

(** from 12: finer_than reflexive **)
(** LATEX VERSION: Any topology is finer than itself. **)
Theorem finer_than_refl : forall T:set, finer_than T T.
let T.
exact (Subq_ref T).
Qed.

(** from 12: finer_than transitive **)
(** LATEX VERSION: Finer-than is transitive: if T'' finer than T' and T' finer than T, then T'' finer than T. **)
Theorem finer_than_trans : forall A B C:set, finer_than B A -> finer_than C B -> finer_than C A.
let A B C.
assume H1: finer_than B A.
assume H2: finer_than C B.
exact (Subq_tra A B C H1 H2).
Qed.

(** from 12: equivalence of finer/coarser phrasing **)
(** LATEX VERSION: Saying T' is finer than T is equivalent to saying T is coarser than T'. **)
Theorem finer_coarser_dual : forall T T':set, finer_than T' T -> coarser_than T T'.
let T T'.
assume H.
exact H.
Qed.

(** from 12: comparability of topologies **)
(** LATEX VERSION: Two topologies are comparable if one contains the other. **)
(** SUSPICIOUS DEFINITION: This is defined for arbitrary families `T1,T2`; it does not assert either is a topology on any `X` unless added separately. **)
Definition comparable_topologies : set -> set -> prop := fun T1 T2 =>
  finer_than T1 T2 \/ finer_than T2 T1.

(** from 12: equality of topologies **)
(** LATEX VERSION: Topology equality on X means both are topologies on X and have identical collections of opens. **)
(** SUSPICIOUS DEFINITION: This is literal set equality `T1 = T2` bundled with `topology_on` assumptions; statements using this should not confuse it with extensional same open sets without equality, but in this development sets are extensional anyway. **)
Definition topology_eq : set -> set -> set -> prop := fun X T1 T2 =>
  topology_on X T1 /\ topology_on X T2 /\ T1 = T2.

(** from 12: symmetry of topology equality **)
(** LATEX VERSION: Equality of topologies is symmetric. **)
Theorem topology_eq_sym : forall X T1 T2:set, topology_eq X T1 T2 -> topology_eq X T2 T1.
let X T1 T2. assume H.
claim Hpair: topology_on X T1 /\ topology_on X T2.
{ exact (andEL (topology_on X T1 /\ topology_on X T2) (T1 = T2) H). }
claim Heq: T1 = T2.
{ exact (andER (topology_on X T1 /\ topology_on X T2) (T1 = T2) H). }
claim HT1: topology_on X T1.
{ exact (andEL (topology_on X T1) (topology_on X T2) Hpair). }
claim HT2: topology_on X T2.
{ exact (andER (topology_on X T1) (topology_on X T2) Hpair). }
prove topology_on X T2 /\ topology_on X T1 /\ T2 = T1.
apply andI.
- apply andI.
  + exact HT2.
  + exact HT1.
- rewrite <- Heq. reflexivity.
Qed.

(** from 12: transitivity of topology equality **)
(** LATEX VERSION: Equality of topologies is transitive. **)
Theorem topology_eq_trans : forall X T1 T2 T3:set, topology_eq X T1 T2 -> topology_eq X T2 T3 -> topology_eq X T1 T3.
let X T1 T2 T3.
assume H12 H23.
claim H12pair: topology_on X T1 /\ topology_on X T2.
{ exact (andEL (topology_on X T1 /\ topology_on X T2) (T1 = T2) H12). }
claim H12eq: T1 = T2.
{ exact (andER (topology_on X T1 /\ topology_on X T2) (T1 = T2) H12). }
claim HT1: topology_on X T1.
{ exact (andEL (topology_on X T1) (topology_on X T2) H12pair). }
claim HT2: topology_on X T2.
{ exact (andER (topology_on X T1) (topology_on X T2) H12pair). }
claim H23pair: topology_on X T2 /\ topology_on X T3.
{ exact (andEL (topology_on X T2 /\ topology_on X T3) (T2 = T3) H23). }
claim H23eq: T2 = T3.
{ exact (andER (topology_on X T2 /\ topology_on X T3) (T2 = T3) H23). }
claim HT3: topology_on X T3.
{ exact (andER (topology_on X T2) (topology_on X T3) H23pair). }
prove topology_on X T1 /\ topology_on X T3 /\ T1 = T3.
apply andI.
- apply andI.
  + exact HT1.
  + exact HT3.
- rewrite H12eq. rewrite H23eq. reflexivity.
Qed.

(** from 12: reflexivity of topology equality **)
(** LATEX VERSION: Any topology equals itself (with the requisite topology_on hypotheses). **)
Theorem topology_eq_refl : forall X T:set, topology_on X T -> topology_eq X T T.
let X T. assume HT.
prove topology_on X T /\ topology_on X T /\ T = T.
apply andI.
- apply andI.
  + exact HT.
  + exact HT.
- reflexivity.
Qed.

(** from 12: strict fineness/coarseness **)
(** LATEX VERSION: T' is strictly finer than T if T'T and not conversely; strictly coarser is the dual. **)
(** SUSPICIOUS DEFINITION: This is stated for arbitrary sets of subsets; it does not require `T` or `T'` to satisfy `topology_on` unless added separately. **)
Definition strictly_finer_than : set -> set -> prop := fun T' T => finer_than T' T /\ ~finer_than T T'.

Definition strictly_coarser_than : set -> set -> prop := fun T' T => coarser_than T' T /\ ~coarser_than T T'.

(** from 12 examples: auxiliary aliases **)
(** LATEX VERSION: Alternate notation: discrete topology and trivial (indiscrete) topology. **)
Definition discrete_topology_alt : set -> set := discrete_topology.
Definition trivial_topology : set -> set := indiscrete_topology.

(** from 12: finer_than between topologies on same X **)
(** LATEX VERSION: A notion of T' finer than T together with both being topologies on X. **)
(** SUSPICIOUS DEFINITION: This bundles `topology_on` hypotheses; in proofs it is easy to accidentally use only the inclusion `finer_than T' T` without carrying those hypotheses along. **)
Definition finer_than_topology : set -> set -> set -> prop := fun X T' T =>
  topology_on X T' /\ topology_on X T /\ finer_than T' T.

(** from 12: finer/coarser equivalence **)
(** LATEX VERSION: Finer-than and coarser-than are logically equivalent statements with reversed arguments. **)
Theorem finer_than_def : forall T T':set, finer_than T' T <-> coarser_than T T'.
let T T'.
apply iffI.
- assume H. exact H.
- assume H. exact H.
Qed.

(** from 12: discrete topology is the finest **)
(** LATEX VERSION: The discrete topology on X is finer than any other topology on X. **)
Theorem discrete_topology_finest : forall X T:set,
  topology_on X T -> finer_than (discrete_topology X) T.
let X T. assume HT.
exact (topology_sub_Power X T HT).
Qed.

(** from 12: indiscrete topology is the coarsest **)
(** LATEX VERSION: The indiscrete topology on X is coarser than any other topology on X. **)
Theorem indiscrete_topology_coarsest : forall X T:set,
  topology_on X T -> coarser_than (indiscrete_topology X) T.
let X T. assume HT.
claim Hempty : Empty :e T.
{ exact (topology_has_empty X T HT). }
claim HX : X :e T.
{ exact (topology_has_X X T HT). }
let U. assume HU : U :e indiscrete_topology X.
apply UPairE U Empty X HU.
- assume HUempty : U = Empty. rewrite HUempty. exact Hempty.
- assume HUX : U = X. rewrite HUX. exact HX.
Qed.

(** from 12: every subset is open in discrete topology **)
(** LATEX VERSION: In the discrete topology on X, every subset UX is open. **)
Theorem discrete_open_all : forall X U:set, U c= X -> U :e discrete_topology X.
let X U. assume HUsub.
apply PowerI X U HUsub.
Qed.

(** from 12: opens in indiscrete topology are Empty or X **)
(** LATEX VERSION: In the indiscrete topology, the only open sets are  and X. **)
Theorem indiscrete_open_iff : forall X U:set,
  U :e indiscrete_topology X <-> (U = Empty \/ U = X).
let X U.
apply iffI.
- assume HU. exact (UPairE U Empty X HU).
- assume Hcases : U = Empty \/ U = X.
  claim HUempty_branch : U = Empty -> U :e indiscrete_topology X.
  { assume HUE : U = Empty. rewrite HUE. exact (UPairI1 Empty X). }
  claim HUx_branch : U = X -> U :e indiscrete_topology X.
  { assume HUX : U = X. rewrite HUX. exact (UPairI2 Empty X). }
  exact (Hcases (U :e indiscrete_topology X) HUempty_branch HUx_branch).
Qed.

(** from 12 Example 3: finite complement openness criterion **)
(** LATEX VERSION: In the finite complement topology, an open set U satisfies that X\\U is finite or U=. **)
Theorem finite_complement_topology_open_criterion : forall X U:set,
  open_in X (finite_complement_topology X) U ->
  finite (X :\: U) \/ U = Empty.
let X U. assume Hopen.
claim HUin : U :e finite_complement_topology X.
{ exact (andER (topology_on X (finite_complement_topology X)) (U :e finite_complement_topology X) Hopen). }
exact (SepE2 (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) U HUin).
Qed.

(** from 12 Example 3: Empty is open in finite complement topology **)
(** LATEX VERSION:  is an open set in the finite complement topology. **)
Theorem finite_complement_topology_contains_empty : forall X:set,
  Empty :e finite_complement_topology X.
let X.
exact (SepI (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) Empty (Empty_In_Power X) (orIR (finite (X :\: Empty)) (Empty = Empty) (fun P H => H))).
Qed.

(** from 12 Example 3: X is open in finite complement topology **)
(** LATEX VERSION: X itself is open in the finite complement topology. **)
Theorem finite_complement_topology_contains_full : forall X:set,
  X :e finite_complement_topology X.
let X.
claim Hdiff_empty : X :\: X = Empty.
{ apply Empty_Subq_eq.
  let x. assume Hx.
  claim Hxin : x :e X.
  { exact (setminusE1 X X x Hx). }
  claim Hxnot : x /:e X.
  { exact (setminusE2 X X x Hx). }
  apply FalseE.
  exact (Hxnot Hxin).
}
claim HfinDiff : finite (X :\: X).
{ rewrite Hdiff_empty. exact finite_Empty. }
exact (SepI (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) X (Self_In_Power X) (orIL (finite (X :\: X)) (X = Empty) HfinDiff)).
Qed.

(** from 12 Example 4: openness via countable complement **) 
(** LATEX VERSION: In the countable complement topology, an open set U has X\\U countable or U=. **)
Theorem countable_complement_topology_open_iff : forall X U:set,
  open_in X (countable_complement_topology X) U ->
  countable (X :\: U) \/ U = Empty.
let X U. assume Hopen.
claim HUin : U :e countable_complement_topology X.
{ exact (andER (topology_on X (countable_complement_topology X)) (U :e countable_complement_topology X) Hopen). }
exact (SepE2 (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty) U HUin).
Qed.

(** from 12 Example 4: Empty is open in countable complement topology **)
(** LATEX VERSION:  is open in the countable complement topology. **)
Theorem countable_complement_topology_contains_empty : forall X:set,
  Empty :e countable_complement_topology X.
let X.
exact (SepI (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty) Empty (Empty_In_Power X) (orIR (countable (X :\: Empty)) (Empty = Empty) (fun P H => H))).
Qed.

(** from 12 Example 4: X is open in countable complement topology **) 
(** LATEX VERSION: X is open in the countable complement topology. **)
Theorem countable_complement_topology_contains_full : forall X:set,
  X :e countable_complement_topology X.
let X.
claim Hdiff_empty : X :\: X = Empty.
{ apply Empty_Subq_eq.
  let x. assume Hx.
  claim HxX : x :e X.
  { exact (setminusE1 X X x Hx). }
  claim Hxnot : x /:e X.
  { exact (setminusE2 X X x Hx). }
  apply FalseE.
  exact (Hxnot HxX).
}
claim HcountDiff : countable (X :\: X).
{ rewrite Hdiff_empty. exact (Subq_atleastp Empty omega (Subq_Empty omega)). }
exact (SepI (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty) X (Self_In_Power X) (orIL (countable (X :\: X)) (X = Empty) HcountDiff)).
Qed.

(** from 12 Example comparison: countable vs finite complement **)
(** LATEX VERSION: The countable complement topology is finer than the finite complement topology. **)
Theorem countable_complement_finer_than_finite_complement : forall X:set,
  finer_than (countable_complement_topology X) (finite_complement_topology X).
let X.
prove finite_complement_topology X c= countable_complement_topology X.
let U. assume HU: U :e finite_complement_topology X.
claim HUinPow : U :e Power X.
{ exact (SepE1 (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) U HU). }
claim HUdata : finite (X :\: U) \/ U = Empty.
{ exact (SepE2 (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) U HU). }
claim HUpred : countable (X :\: U) \/ U = Empty.
{ apply HUdata (countable (X :\: U) \/ U = Empty).
  - assume HUfin : finite (X :\: U).
    apply orIL.
    exact (finite_countable (X :\: U) HUfin).
  - assume HUemp : U = Empty.
    apply orIR.
    exact HUemp.
}
exact (SepI (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty) U HUinPow HUpred).
Qed.

(** from 12 examples: finite complement coarser than discrete **)
(** LATEX VERSION: The finite complement topology is coarser than the discrete topology. **)
Theorem finite_complement_coarser_than_discrete : forall X:set,
  coarser_than (finite_complement_topology X) (discrete_topology X).
let X.
prove finite_complement_topology X c= discrete_topology X.
let U. assume HU.
exact (SepE1 (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) U HU).
Qed.

(** from 12 examples: indiscrete coarser than countable complement **) 
(** LATEX VERSION: The indiscrete topology is coarser than the countable complement topology. **)
Theorem indiscrete_coarser_than_countable_complement : forall X:set,
  coarser_than (indiscrete_topology X) (countable_complement_topology X).
let X.
prove indiscrete_topology X c= countable_complement_topology X.
let U. assume HU: U :e indiscrete_topology X.
apply UPairE U Empty X HU.
- assume HUempty: U = Empty. rewrite HUempty. exact (countable_complement_topology_contains_empty X).
- assume HUX: U = X. rewrite HUX. exact (countable_complement_topology_contains_full X).
Qed.

(** from 12: fineness via set inclusion of topologies **)
(** LATEX VERSION: A restatement of fineness between topologies on X as inclusion of their open sets. **)
Definition finer_than_topology_by_inclusion : set -> set -> set -> prop := finer_than_topology.

(** from 12: fineness via inclusion characterization **)
(** LATEX VERSION: The earlier fineness notion between topologies on X is equivalent to plain inclusion of their open sets. **)
Theorem finer_than_topology_by_inclusion_eq : forall X T' T:set,
  finer_than_topology X T' T <-> finer_than_topology_by_inclusion X T' T.
let X T' T.
apply iffI.
- assume H. exact H.
- assume H. exact H.
Qed.

(** from 12 axiom: arbitrary unions of opens are open **)
(** LATEX VERSION: In any topology, the union of any subfamily of open sets is open. **)
Theorem lemma_union_of_topology_family_open : forall X T UFam:set,
  topology_on X T ->
  UFam :e Power T ->
  Union UFam :e T.
let X T UFam. assume HT Hfam.
claim Hchunk1 : ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam' :e Power T, Union UFam' :e T).
{ exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam' :e Power T, Union UFam' :e T)) (forall U :e T, forall V :e T, U :/\: V :e T) HT). }
claim Hunion_axiom : forall UFam' :e Power T, Union UFam' :e T.
{ exact (andER ((T c= Power X /\ Empty :e T) /\ X :e T) (forall UFam' :e Power T, Union UFam' :e T) Hchunk1). }
exact (Hunion_axiom UFam Hfam).
Qed.

(** from 12 axiom: finite intersections of opens are open **)
(** LATEX VERSION: In any topology, the intersection of two open sets is open (and hence any finite intersection). **)
Theorem lemma_intersection_two_open : forall X T U V:set,
  topology_on X T ->
  U :e T -> V :e T ->
  U :/\: V :e T.
let X T U V. assume HT HU HV.
exact (topology_binintersect_closed X T U V HT HU HV).
Qed.

(** from 12: alternative naming for topological space **)
(** LATEX VERSION: Using notation topological_space X T for topology_on X T and open_set_family/open_set for opens. **)
(** NOTE: `open_set` is defined as an alias of `open_in` to avoid duplicate bookkeeping. **)
Definition topological_space : set -> set -> prop := topology_on.

Definition open_set_family : set -> set -> set := fun _ T => T.

Definition open_set : set -> set -> set -> prop := open_in.

(** from 13 Definition: basis for a topology **) 
(** LATEX VERSION: A basis on X is a collection BP(X) such that every xX lies in some bB and intersections around a point refine to another basis element. **)
(** SUSPICIOUS DEFINITION: This is a left-associated conjunction; proofs must destruct it as (A /\ B) /\ C, not A /\ (B /\ C). **)
Definition basis_on : set -> set -> prop := fun X B =>
  B c= Power X
  /\ (forall x :e X, exists b :e B, x :e b)
  /\ (forall b1 :e B, forall b2 :e B, forall x:set,
        x :e b1 -> x :e b2 ->
        exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2).

(** Helper: extract B c= Power X from basis_on **)
Theorem basis_on_sub_Power : forall X B:set,
  basis_on X B -> B c= Power X.
let X B.
assume H: basis_on X B.
set A := B c= Power X.
set Bcov := (forall x :e X, exists b :e B, x :e b).
set Bref := (forall b1 :e B, forall b2 :e B, forall x:set,
              x :e b1 -> x :e b2 ->
              exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2).
claim Hab: A /\ Bcov.
{ exact (andEL (A /\ Bcov) Bref H). }
exact (andEL A Bcov Hab).
Qed.

(** Helper: extract cover property from basis_on **)
Theorem basis_on_cover : forall X B:set,
  basis_on X B -> forall x :e X, exists b :e B, x :e b.
let X B.
assume H: basis_on X B.
set A := B c= Power X.
set Bcov := (forall x :e X, exists b :e B, x :e b).
set Bref := (forall b1 :e B, forall b2 :e B, forall x:set,
              x :e b1 -> x :e b2 ->
              exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2).
claim Hab: A /\ Bcov.
{ exact (andEL (A /\ Bcov) Bref H). }
exact (andER A Bcov Hab).
Qed.

(** Helper: extract refinement property from basis_on **)
Theorem basis_on_refine : forall X B:set,
  basis_on X B ->
  forall b1 :e B, forall b2 :e B, forall x:set,
    x :e b1 -> x :e b2 ->
    exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2.
let X B.
assume H: basis_on X B.
set A := B c= Power X.
set Bcov := (forall x :e X, exists b :e B, x :e b).
set Bref := (forall b1 :e B, forall b2 :e B, forall x:set,
              x :e b1 -> x :e b2 ->
              exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2).
exact (andER (A /\ Bcov) Bref H).
Qed.

(** from 13 Definition: topology generated by a basis **)
(** LATEX VERSION: The topology generated by basis B on X consists of all UX such that every xU lies in some bB with bU. **)
(** SUSPICIOUS DEFINITION: Membership is encoded by a local basis refinement condition; later set ext proofs often need to rewrite this definition and then destruct nested existentials carefully. **)
Definition generated_topology : set -> set -> set := fun X B =>
  {U :e Power X | forall x :e U, exists b :e B, x :e b /\ b c= U}.

(** Helper: Basis elements are subsets of X **)
Theorem basis_elem_subset : forall X B b:set,
  basis_on X B -> b :e B -> b c= X.
let X B b.
assume HB: basis_on X B.
assume Hb: b :e B.
prove b c= X.
(** basis_on X B = (B c= Power X) /\ (coverage /\ intersection property) **)
(** Left-associative: ((B c= Power X) /\ coverage) /\ intersection **)
claim H1: (B c= Power X /\ (forall x :e X, exists b0 :e B, x :e b0)) /\ (forall b1 :e B, forall b2 :e B, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2).
{ exact HB. }
claim H2: B c= Power X /\ (forall x :e X, exists b0 :e B, x :e b0).
{ exact (andEL (B c= Power X /\ (forall x :e X, exists b0 :e B, x :e b0)) (forall b1 :e B, forall b2 :e B, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2) H1). }
claim HBPower: B c= Power X.
{ exact (andEL (B c= Power X) (forall x :e X, exists b0 :e B, x :e b0) H2). }
claim HbPower: b :e Power X.
{ exact (HBPower b Hb). }
exact (PowerE X b HbPower).
Qed.

(** Helper: Basis elements are in generated topology **)
Theorem basis_in_generated : forall X B b:set,
  basis_on X B -> b :e B -> b :e generated_topology X B.
let X B b.
assume HB: basis_on X B.
assume Hb: b :e B.
prove b :e generated_topology X B.
(** generated_topology X B = {U :e Power X | forall x :e U, exists b0 :e B, x :e b0 /\ b0 c= U} **)
(** Need: b :e Power X and forall x :e b, exists b0 :e B, x :e b0 /\ b0 c= b **)
claim HbPower: b :e Power X.
{ claim HbsubX: b c= X.
  { exact (basis_elem_subset X B b HB Hb). }
  exact (PowerI X b HbsubX). }
claim HbCond: forall x :e b, exists b0 :e B, x :e b0 /\ b0 c= b.
{ let x. assume Hx: x :e b.
  (** Use b itself as the witness **)
  witness b.
  apply andI.
  - exact Hb.
  - apply andI.
    + exact Hx.
    + apply Subq_ref. }
exact (SepI (Power X) (fun U => forall x :e U, exists b0 :e B, x :e b0 /\ b0 c= U) b HbPower HbCond).
Qed.

(** Helper: Elements of generated topology are subsets of X **)
Theorem generated_topology_subset : forall X B U:set,
  U :e generated_topology X B -> U c= X.
let X B U.
assume HU: U :e generated_topology X B.
prove U c= X.
(** generated_topology X B = {U :e Power X | ...} **)
claim HUPower: U :e Power X.
{ exact (SepE1 (Power X) (fun U0 => forall x :e U0, exists b :e B, x :e b /\ b c= U0) U HU). }
exact (PowerE X U HUPower).
Qed.

(** from 13: generated family is a topology **) 
(** LATEX VERSION: The collection generated by a basis indeed satisfies the topology axioms. **)
Theorem lemma_topology_from_basis : forall X B:set,
  basis_on X B ->
  topology_on X (generated_topology X B).
let X B. assume HBasis.
claim HBleft : B c= Power X /\ (forall x :e X, exists b :e B, x :e b).
{ exact (andEL (B c= Power X /\ (forall x :e X, exists b :e B, x :e b))
               (forall b1 :e B, forall b2 :e B, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2)
               HBasis). }
claim HBint : forall b1 :e B, forall b2 :e B, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2.
{ exact (andER (B c= Power X /\ (forall x :e X, exists b :e B, x :e b))
               (forall b1 :e B, forall b2 :e B, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2)
               HBasis). }
claim HBsub : B c= Power X.
{ exact (andEL (B c= Power X) (forall x :e X, exists b :e B, x :e b) HBleft). }
claim HBcov : forall x :e X, exists b :e B, x :e b.
{ exact (andER (B c= Power X) (forall x :e X, exists b :e B, x :e b) HBleft). }
claim proofA : generated_topology X B c= Power X.
{ let U. assume HU: U :e generated_topology X B.
  exact (SepE1 (Power X) (fun U0 : set => forall x :e U0, exists b :e B, x :e b /\ b c= U0) U HU). }
claim proofB : Empty :e generated_topology X B.
{ exact (SepI (Power X) (fun U0 : set => forall x :e U0, exists b :e B, x :e b /\ b c= U0) Empty (Empty_In_Power X) (fun x HxEmpty => EmptyE x HxEmpty (exists b :e B, x :e b /\ b c= Empty))). }
claim proofC : X :e generated_topology X B.
  { claim HXprop : forall x :e X, exists b :e B, x :e b /\ b c= X.
    { let x. assume HxX.
      claim Hexb : exists b :e B, x :e b.
      { exact (HBcov x HxX). }
      apply Hexb.
      let b. assume Hbpair.
      claim HbB : b :e B.
      { exact (andEL (b :e B) (x :e b) Hbpair). }
      claim Hxb : x :e b.
      { exact (andER (b :e B) (x :e b) Hbpair). }
      claim HbsubX : b c= X.
      { exact (PowerE X b (HBsub b HbB)). }
      witness b.
      apply andI.
      - exact HbB.
      - apply andI.
        * exact Hxb.
        * exact HbsubX. }
  exact (SepI (Power X) (fun U0 : set => forall x :e U0, exists b :e B, x :e b /\ b c= U0) X (Self_In_Power X) HXprop). }
claim proofD : forall UFam :e Power (generated_topology X B), Union UFam :e generated_topology X B.
{ let UFam. assume Hfam: UFam :e Power (generated_topology X B).
  claim HsubFam : UFam c= generated_topology X B.
  { exact (PowerE (generated_topology X B) UFam Hfam). }
  claim HPowUnion : Union UFam :e Power X.
  { apply PowerI X (Union UFam).
    let x. assume HxUnion.
    apply UnionE_impred UFam x HxUnion.
    let U. assume HxU HUin.
    claim HUtop : U :e generated_topology X B.
    { exact (HsubFam U HUin). }
    claim HUsubX : U c= X.
    { exact (PowerE X U (SepE1 (Power X) (fun U0 : set => forall x0 :e U0, exists b :e B, x0 :e b /\ b c= U0) U HUtop)). }
    exact (HUsubX x HxU). }
  claim HUnionProp : forall x :e Union UFam, exists b :e B, x :e b /\ b c= Union UFam.
  { let x. assume HxUnion.
    apply UnionE_impred UFam x HxUnion.
    let U. assume HxU HUin.
    claim HUtop : U :e generated_topology X B.
    { exact (HsubFam U HUin). }
    claim HUprop : forall x0 :e U, exists b :e B, x0 :e b /\ b c= U.
    { exact (SepE2 (Power X) (fun U0 : set => forall x0 :e U0, exists b :e B, x0 :e b /\ b c= U0) U HUtop). }
    claim Hexb : exists b :e B, x :e b /\ b c= U.
    { exact (HUprop x HxU). }
    apply Hexb.
    let b. assume Hbpair.
    claim HbB : b :e B.
    { exact (andEL (b :e B) (x :e b /\ b c= U) Hbpair). }
    claim Hbprop : x :e b /\ b c= U.
    { exact (andER (b :e B) (x :e b /\ b c= U) Hbpair). }
    claim Hxb : x :e b.
    { exact (andEL (x :e b) (b c= U) Hbprop). }
    claim HbSubU : b c= U.
    { exact (andER (x :e b) (b c= U) Hbprop). }
    witness b.
    apply andI.
    - exact HbB.
    - apply andI.
      * exact Hxb.
      * let y. assume Hyb.
        apply UnionI UFam y U (HbSubU y Hyb) HUin. }
  exact (SepI (Power X) (fun U0 : set => forall x :e U0, exists b :e B, x :e b /\ b c= U0) (Union UFam) HPowUnion HUnionProp). }
claim proofE : forall U :e generated_topology X B, forall V :e generated_topology X B, U :/\: V :e generated_topology X B.
{ let U. assume HUtop.
  let V. assume HVtop.
  claim HUprop : forall x0 :e U, exists b :e B, x0 :e b /\ b c= U.
  { exact (SepE2 (Power X) (fun U0 : set => forall x0 :e U0, exists b :e B, x0 :e b /\ b c= U0) U HUtop). }
  claim HVprop : forall x0 :e V, exists b :e B, x0 :e b /\ b c= V.
  { exact (SepE2 (Power X) (fun U0 : set => forall x0 :e U0, exists b :e B, x0 :e b /\ b c= U0) V HVtop). }
  claim HUsubX : U c= X.
  { exact (PowerE X U (SepE1 (Power X) (fun U0 : set => forall x0 :e U0, exists b :e B, x0 :e b /\ b c= U0) U HUtop)). }
  claim HPowCap : U :/\: V :e Power X.
  { apply PowerI X (U :/\: V).
    let x. assume HxCap.
    apply binintersectE U V x HxCap.
    assume HxU HxV.
    exact (HUsubX x HxU). }
  claim HCapProp : forall x :e U :/\: V, exists b :e B, x :e b /\ b c= U :/\: V.
  { let x. assume HxCap.
    apply binintersectE U V x HxCap.
    assume HxU HxV.
    claim Hexb1 : exists b1 :e B, x :e b1 /\ b1 c= U.
    { exact (HUprop x HxU). }
    claim Hexb2 : exists b2 :e B, x :e b2 /\ b2 c= V.
    { exact (HVprop x HxV). }
    apply Hexb1.
    let b1. assume Hbpair1.
    claim Hb1 : b1 :e B.
    { exact (andEL (b1 :e B) (x :e b1 /\ b1 c= U) Hbpair1). }
    claim Hb1prop : x :e b1 /\ b1 c= U.
    { exact (andER (b1 :e B) (x :e b1 /\ b1 c= U) Hbpair1). }
    claim Hb1x : x :e b1.
    { exact (andEL (x :e b1) (b1 c= U) Hb1prop). }
    claim Hb1Sub : b1 c= U.
    { exact (andER (x :e b1) (b1 c= U) Hb1prop). }
    apply Hexb2.
    let b2. assume Hbpair2.
    claim Hb2 : b2 :e B.
    { exact (andEL (b2 :e B) (x :e b2 /\ b2 c= V) Hbpair2). }
    claim Hb2prop : x :e b2 /\ b2 c= V.
    { exact (andER (b2 :e B) (x :e b2 /\ b2 c= V) Hbpair2). }
    claim Hb2x : x :e b2.
    { exact (andEL (x :e b2) (b2 c= V) Hb2prop). }
    claim Hb2Sub : b2 c= V.
    { exact (andER (x :e b2) (b2 c= V) Hb2prop). }
    claim Hexb3 : exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2.
    { exact (HBint b1 Hb1 b2 Hb2 x Hb1x Hb2x). }
    apply Hexb3.
    let b3. assume Hbpair3.
    claim Hb3 : b3 :e B.
    { exact (andEL (b3 :e B) (x :e b3 /\ b3 c= b1 :/\: b2) Hbpair3). }
    claim Hb3prop : x :e b3 /\ b3 c= b1 :/\: b2.
    { exact (andER (b3 :e B) (x :e b3 /\ b3 c= b1 :/\: b2) Hbpair3). }
    claim HxB3 : x :e b3.
    { exact (andEL (x :e b3) (b3 c= b1 :/\: b2) Hb3prop). }
    claim Hb3Sub : b3 c= b1 :/\: b2.
  { exact (andER (x :e b3) (b3 c= b1 :/\: b2) Hb3prop). }
    witness b3.
    apply andI.
    - exact Hb3.
    - apply andI.
      * exact HxB3.
      * let y. assume Hyb3.
        claim Hy_in_b1b2 : y :e b1 :/\: b2.
        { exact (Hb3Sub y Hyb3). }
        apply binintersectE b1 b2 y Hy_in_b1b2.
        assume Hyb1 Hyb2.
        apply binintersectI U V y (Hb1Sub y Hyb1) (Hb2Sub y Hyb2). }
  exact (SepI (Power X) (fun U0 : set => forall x0 :e U0, exists b :e B, x0 :e b /\ b c= U0) (U :/\: V) HPowCap HCapProp). }
prove generated_topology X B c= Power X
/\ Empty :e generated_topology X B
/\ X :e generated_topology X B
/\ (forall UFam :e Power (generated_topology X B), Union UFam :e generated_topology X B)
/\ (forall U :e generated_topology X B, forall V :e generated_topology X B, U :/\: V :e generated_topology X B).
  apply andI.
- apply andI.
  * apply andI.
    { apply andI.
      - exact proofA.
      - exact proofB. }
    { exact proofC. }
  * exact proofD.
- exact proofE.
Qed.

(** from 13: basis elements belong to generated topology **) 
(** LATEX VERSION: Every basis element bB is itself open in the topology generated by B. **)
Theorem generated_topology_contains_basis : forall X B:set,
  basis_on X B -> forall b:set, b :e B -> b :e generated_topology X B.
let X B. assume HBasis.
claim HBsub : B c= Power X.
{ exact (andEL (B c= Power X) (forall x :e X, exists b :e B, x :e b) (andEL (B c= Power X /\ (forall x :e X, exists b :e B, x :e b))
               (forall b1 :e B, forall b2 :e B, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2)
               HBasis)). }
claim HBint : forall b1 :e B, forall b2 :e B, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2.
{ exact (andER (B c= Power X /\ (forall x :e X, exists b :e B, x :e b))
               (forall b1 :e B, forall b2 :e B, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2)
               HBasis). }
let b0. assume Hb0.
claim Hb0_subX : b0 c= X.
{ exact (PowerE X b0 (HBsub b0 Hb0)). }
claim Hb0prop : forall x :e b0, exists b :e B, x :e b /\ b c= b0.
{ let x. assume Hxb0.
  claim Hexb3 : exists b3 :e B, x :e b3 /\ b3 c= b0 :/\: b0.
  { exact (HBint b0 Hb0 b0 Hb0 x Hxb0 Hxb0). }
  apply Hexb3.
  let b3. assume Hb3pair.
  claim Hb3 : b3 :e B.
  { exact (andEL (b3 :e B) (x :e b3 /\ b3 c= b0 :/\: b0) Hb3pair). }
  claim Hb3prop : x :e b3 /\ b3 c= b0 :/\: b0.
  { exact (andER (b3 :e B) (x :e b3 /\ b3 c= b0 :/\: b0) Hb3pair). }
  claim Hxb3 : x :e b3.
  { exact (andEL (x :e b3) (b3 c= b0 :/\: b0) Hb3prop). }
  claim Hb3sub_inter : b3 c= b0 :/\: b0.
  { exact (andER (x :e b3) (b3 c= b0 :/\: b0) Hb3prop). }
  claim Hb3subb0 : b3 c= b0.
  { let y. assume Hyb3.
    claim Hycap : y :e b0 :/\: b0.
    { exact (Hb3sub_inter y Hyb3). }
    apply binintersectE b0 b0 y Hycap.
    assume Hy1 Hy2.
    exact Hy1. }
  witness b3.
  apply andI.
  - exact Hb3.
  - apply andI.
    * exact Hxb3.
    * exact Hb3subb0. }
exact (SepI (Power X) (fun U0 : set => forall x :e U0, exists b :e B, x :e b /\ b c= U0) b0 (PowerI X b0 Hb0_subX) Hb0prop).
Qed.

(** from 13: shorthand for basis generating topology **) 
(** LATEX VERSION: basis_generates X B T abbreviates B is a basis on X and the generated topology equals T. **)
Definition basis_generates : set -> set -> set -> prop := fun X B T =>
  basis_on X B /\ generated_topology X B = T.

(** from 13: shorthand that a family refines all opens **) 
(** LATEX VERSION: basis_refines X B T means T is a topology on X and every x in any UT lies in some bB with bU. **)
Definition basis_refines : set -> set -> set -> prop := fun X B T =>
  topology_on X T /\ (forall U :e T, forall x :e U, exists b :e B, x :e b /\ b c= U).

(** from 13: generated topology characterization **) 
(** LATEX VERSION: Characterization of generated_topology as the comprehension of subsets UX with the basis neighborhood property. **)
Theorem lemma_generated_topology_characterization : forall X B:set,
  basis_on X B ->
  generated_topology X B
  = {U :e Power X | forall x :e U, exists b :e B, x :e b /\ b c= U}.
let X B. assume HBasis.
reflexivity.
Qed.

(** from 13 Lemma 13.1: open sets are unions of basis elements **) 
(** LATEX VERSION: Lemma 13.1: For a basis B on X, every open set is a union of elements of B. **)
Theorem open_sets_as_unions_of_basis : forall X B:set,
  basis_on X B ->
  forall U:set, open_in X (generated_topology X B) U ->
    exists Fam :e Power B, Union Fam = U.
let X B. assume HBasis.
claim HBsub : B c= Power X.
{ exact (andEL (B c= Power X) (forall x :e X, exists b :e B, x :e b)
               (andEL (B c= Power X /\ (forall x :e X, exists b :e B, x :e b))
                     (forall b1 :e B, forall b2 :e B, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2)
                     HBasis)). }
let U. assume HUopen.
claim HUtop : U :e generated_topology X B.
{ exact (andER (topology_on X (generated_topology X B)) (U :e generated_topology X B) HUopen). }
claim HUprop : forall x :e U, exists b :e B, x :e b /\ b c= U.
{ exact (SepE2 (Power X) (fun U0 : set => forall x0 :e U0, exists b :e B, x0 :e b /\ b c= U0) U HUtop). }
set Fam : set := {b :e B|b c= U}.
claim HFamPow : Fam :e Power B.
{ apply PowerI B Fam.
  let b. assume HbFam.
  exact (SepE1 B (fun b0 : set => b0 c= U) b HbFam). }
claim HUnion_eq : Union Fam = U.
{ apply set_ext.
  - let x. assume HxUnion.
    apply UnionE_impred Fam x HxUnion.
    let b. assume Hxb HbFam.
    claim HbsubU : b c= U.
    { exact (SepE2 B (fun b0 : set => b0 c= U) b HbFam). }
    exact (HbsubU x Hxb).
  - let x. assume HxU.
    claim Hexb : exists b :e B, x :e b /\ b c= U.
    { exact (HUprop x HxU). }
    apply Hexb.
    let b. assume Hbpair.
    claim HbB : b :e B.
    { exact (andEL (b :e B) (x :e b /\ b c= U) Hbpair). }
    claim Hbprop : x :e b /\ b c= U.
    { exact (andER (b :e B) (x :e b /\ b c= U) Hbpair). }
    claim Hxb : x :e b.
    { exact (andEL (x :e b) (b c= U) Hbprop). }
    claim HbsubU : b c= U.
    { exact (andER (x :e b) (b c= U) Hbprop). }
    claim HbFam : b :e Fam.
    { exact (SepI B (fun b0 : set => b0 c= U) b HbB HbsubU). }
    exact (UnionI Fam x b Hxb HbFam). }
witness Fam.
apply andI.
- exact HFamPow.
- exact HUnion_eq.
Qed.

(** from 13 Lemma 13.1 converse direction **) 
(** LATEX VERSION: Conversely, any union of basis elements is open in the topology generated by the basis. **)
Theorem basis_generates_open_sets : forall X B:set,
  basis_on X B ->
  forall U:set, (exists Fam :e Power B, Union Fam = U) ->
    open_in X (generated_topology X B) U.
let X B. assume HBasis.
claim HBsub : B c= Power X.
{ exact (andEL (B c= Power X) (forall x :e X, exists b :e B, x :e b)
               (andEL (B c= Power X /\ (forall x :e X, exists b :e B, x :e b))
                     (forall b1 :e B, forall b2 :e B, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2)
                     HBasis)). }
let U. assume Hex.
claim HUGen : U :e generated_topology X B.
{ apply Hex.
  let Fam. assume HFampair.
  claim HFamPow : Fam :e Power B.
  { exact (andEL (Fam :e Power B) (Union Fam = U) HFampair). }
  claim HUnionEq : Union Fam = U.
  { exact (andER (Fam :e Power B) (Union Fam = U) HFampair). }
  claim HFamSubB : Fam c= B.
  { exact (PowerE B Fam HFamPow). }
  claim HFamSubX : Fam c= Power X.
  { let b. assume HbFam.
    claim HbB : b :e B.
    { exact (HFamSubB b HbFam). }
    exact (HBsub b HbB). }
  claim HUnionSubX : Union Fam c= X.
  { let x. assume HxUnion.
    apply UnionE_impred Fam x HxUnion.
    let b. assume Hxb HbFam.
    claim HbSubX : b c= X.
    { exact (PowerE X b (HFamSubX b HbFam)). }
    exact (HbSubX x Hxb). }
  claim HUnionSubU : Union Fam c= U.
  { rewrite HUnionEq.
    exact (Subq_ref U). }
  claim HUsubUnion : U c= Union Fam.
  { rewrite <- HUnionEq.
    exact (Subq_ref (Union Fam)). }
  claim HUsubX : U c= X.
  { exact (Subq_tra U (Union Fam) X HUsubUnion HUnionSubX). }
  claim HUpropU : forall x :e U, exists b :e B, x :e b /\ b c= U.
  { let x. assume HxU.
    claim HxUnion : x :e Union Fam.
    { exact (HUsubUnion x HxU). }
    apply UnionE_impred Fam x HxUnion.
    let b. assume Hxb HbFam.
    claim HbB : b :e B.
    { exact (HFamSubB b HbFam). }
    claim HbSubUnion : b c= Union Fam.
    { let y. assume Hyb.
      exact (UnionI Fam y b Hyb HbFam). }
    claim HbSubU : b c= U.
    { exact (Subq_tra b (Union Fam) U HbSubUnion HUnionSubU). }
    witness b.
    apply andI.
    - exact HbB.
    - apply andI.
      * exact Hxb.
      * exact HbSubU. }
  exact (SepI (Power X) (fun U0 : set => forall x0 :e U0, exists b0 :e B, x0 :e b0 /\ b0 c= U0) U (PowerI X U HUsubX) HUpropU). }
exact (andI (topology_on X (generated_topology X B)) (U :e generated_topology X B) (lemma_topology_from_basis X B HBasis) HUGen).
Qed.

(** from 13 Lemma 13.1 corollary **) 
(** LATEX VERSION: Corollary: For U open in topology generated by B, U equals the union of all basis elements contained in U. **)
Theorem open_as_union_of_basis_elements : forall X B:set,
  basis_on X B ->
  forall U:set, open_in X (generated_topology X B) U ->
    U = Union {b :e B|b c= U}.
let X B. assume HBasis.
let U. assume HUopen.
claim HUtop : U :e generated_topology X B.
{ exact (andER (topology_on X (generated_topology X B)) (U :e generated_topology X B) HUopen). }
claim HUprop : forall x :e U, exists b :e B, x :e b /\ b c= U.
{ exact (SepE2 (Power X) (fun U0 : set => forall x0 :e U0, exists b :e B, x0 :e b /\ b c= U0) U HUtop). }
set Fam : set := {b :e B|b c= U}.
apply set_ext.
- let x. assume HxU.
  claim Hexb : exists b :e B, x :e b /\ b c= U.
  { exact (HUprop x HxU). }
  apply Hexb.
  let b. assume Hbpair.
  claim HbB : b :e B.
  { exact (andEL (b :e B) (x :e b /\ b c= U) Hbpair). }
  claim Hbprop : x :e b /\ b c= U.
  { exact (andER (b :e B) (x :e b /\ b c= U) Hbpair). }
  claim Hxb : x :e b.
  { exact (andEL (x :e b) (b c= U) Hbprop). }
  claim HbsubU : b c= U.
  { exact (andER (x :e b) (b c= U) Hbprop). }
  claim HbFam : b :e Fam.
  { exact (SepI B (fun b0 : set => b0 c= U) b HbB HbsubU). }
  exact (UnionI Fam x b Hxb HbFam).
- let x. assume HxUnion.
  apply UnionE_impred Fam x HxUnion.
  let b. assume Hxb HbFam.
  claim HbsubU : b c= U.
  { exact (SepE2 B (fun b0 : set => b0 c= U) b HbFam). }
  exact (HbsubU x Hxb).
Qed.

(** from 13 Lemma 13.2: extracting a basis from an open refinement condition **) 
(** LATEX VERSION: Lemma 13.2: If every open set of topology T on X is locally contained in some element of CT, then C is a basis and generates T. **)
Theorem basis_refines_topology : forall X T C:set,
  topology_on X T ->
  (forall c :e C, c :e T) ->
  (forall U :e T, forall x :e U, exists Cx :e C, x :e Cx /\ Cx c= U) ->
  basis_on X C /\ generated_topology X C = T.
let X T C. assume Htop HCsub Href.
claim Hleft : ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T).
{ exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T))
               (forall U :e T, forall V :e T, U :/\: V :e T)
               Htop). }
claim Hcore : (T c= Power X /\ Empty :e T) /\ X :e T.
{ exact (andEL ((T c= Power X /\ Empty :e T) /\ X :e T)
               (forall UFam :e Power T, Union UFam :e T)
               Hleft). }
claim HTPowEmpty : T c= Power X /\ Empty :e T.
{ exact (andEL (T c= Power X /\ Empty :e T) (X :e T) Hcore). }
claim HTsubPow : T c= Power X.
{ exact (andEL (T c= Power X) (Empty :e T) HTPowEmpty). }
claim HXT : X :e T.
{ exact (andER (T c= Power X /\ Empty :e T) (X :e T) Hcore). }
claim HUnionClosed : forall UFam :e Power T, Union UFam :e T.
{ exact (andER ((T c= Power X /\ Empty :e T) /\ X :e T) (forall UFam :e Power T, Union UFam :e T) Hleft). }
claim HInterClosed : forall U :e T, forall V :e T, U :/\: V :e T.
{ exact (andER (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T))
               (forall U :e T, forall V :e T, U :/\: V :e T)
               Htop). }
claim HBasis : basis_on X C.
{ prove (C c= Power X
         /\ (forall x :e X, exists c :e C, x :e c)
         /\ (forall b1 :e C, forall b2 :e C, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e C, x :e b3 /\ b3 c= b1 :/\: b2)).
  apply andI.
  - apply andI.
    * let c. assume HcC.
      exact (HTsubPow c (HCsub c HcC)).
    * let x. assume HxX.
      claim Hex : exists c :e C, x :e c /\ c c= X.
      { exact (Href X HXT x HxX). }
      apply Hex.
      let c. assume Hpair.
      claim HcC : c :e C.
      { exact (andEL (c :e C) (x :e c /\ c c= X) Hpair). }
      claim Hcprop : x :e c /\ c c= X.
      { exact (andER (c :e C) (x :e c /\ c c= X) Hpair). }
      claim Hxc : x :e c.
      { exact (andEL (x :e c) (c c= X) Hcprop). }
      witness c.
      apply andI.
      - exact HcC.
      - exact Hxc.
  - let c1. assume Hc1C.
    let c2. assume Hc2C.
    let x. assume Hxc1 Hxc2.
    claim Hc1T : c1 :e T.
    { exact (HCsub c1 Hc1C). }
    claim Hc2T : c2 :e T.
    { exact (HCsub c2 Hc2C). }
    claim HcapT : c1 :/\: c2 :e T.
    { exact (HInterClosed c1 Hc1T c2 Hc2T). }
    claim HxCap : x :e c1 :/\: c2.
    { exact (binintersectI c1 c2 x Hxc1 Hxc2). }
    claim Hex : exists c3 :e C, x :e c3 /\ c3 c= c1 :/\: c2.
    { exact (Href (c1 :/\: c2) HcapT x HxCap). }
    exact Hex. }
claim Hgen_sub_T : generated_topology X C c= T.
{ let U. assume HUgen : U :e generated_topology X C.
  claim HUsubX : U c= X.
  { exact (PowerE X U (SepE1 (Power X)
                            (fun U0 : set => forall x0 :e U0, exists b0 :e C, x0 :e b0 /\ b0 c= U0)
                            U HUgen)). }
  claim HUprop : forall x :e U, exists c :e C, x :e c /\ c c= U.
  { exact (SepE2 (Power X)
                 (fun U0 : set => forall x0 :e U0, exists b0 :e C, x0 :e b0 /\ b0 c= U0)
                 U HUgen). }
  set Fam : set := {c :e C|c c= U}.
  claim HFamSubC : Fam c= C.
  { let c. assume HcFam.
    exact (SepE1 C (fun c0 : set => c0 c= U) c HcFam). }
  claim HFamSubT : Fam c= T.
  { let c. assume HcFam.
    claim HcC : c :e C.
    { exact (HFamSubC c HcFam). }
    exact (HCsub c HcC). }
  claim HFamPowT : Fam :e Power T.
  { exact (PowerI T Fam HFamSubT). }
  claim HUnionSubU : Union Fam c= U.
  { let x. assume HxUnion.
    apply UnionE_impred Fam x HxUnion.
    let c. assume Hxc HcFam.
    claim Hcprop : c c= U.
    { exact (SepE2 C (fun c0 : set => c0 c= U) c HcFam). }
    exact (Hcprop x Hxc). }
  claim HUsubUnion : U c= Union Fam.
  { let x. assume HxU.
    claim Hex : exists c :e C, x :e c /\ c c= U.
    { exact (HUprop x HxU). }
    apply Hex.
    let c. assume Hcpair.
    claim HcC : c :e C.
    { exact (andEL (c :e C) (x :e c /\ c c= U) Hcpair). }
    claim Hcprop : x :e c /\ c c= U.
    { exact (andER (c :e C) (x :e c /\ c c= U) Hcpair). }
    claim Hxc : x :e c.
    { exact (andEL (x :e c) (c c= U) Hcprop). }
    claim HcsubU : c c= U.
    { exact (andER (x :e c) (c c= U) Hcprop). }
    claim HcFam : c :e Fam.
    { exact (SepI C (fun c0 : set => c0 c= U) c HcC HcsubU). }
    exact (UnionI Fam x c Hxc HcFam). }
  claim HUnionEqU : Union Fam = U.
  { apply set_ext.
    - let x. assume HxUnion.
      exact (HUnionSubU x HxUnion).
    - let x. assume HxU.
      exact (HUsubUnion x HxU). }
  claim HUnionInT : Union Fam :e T.
  { exact (HUnionClosed Fam HFamPowT). }
  rewrite <- HUnionEqU.
  exact HUnionInT. }
claim HT_sub_gen : T c= generated_topology X C.
{ let U. assume HU : U :e T.
  claim HUsubX : U c= X.
  { exact (PowerE X U (HTsubPow U HU)). }
  claim HUprop : forall x :e U, exists c :e C, x :e c /\ c c= U.
  { let x. assume HxU.
    exact (Href U HU x HxU). }
  exact (SepI (Power X)
              (fun U0 : set => forall x0 :e U0, exists b0 :e C, x0 :e b0 /\ b0 c= U0)
              U
              (PowerI X U HUsubX)
              HUprop). }
claim HEqual : generated_topology X C = T.
{ apply set_ext.
  - let U. assume HUgen.
    exact (Hgen_sub_T U HUgen).
  - let U. assume HU.
    exact (HT_sub_gen U HU). }
apply andI.
- exact HBasis.
- exact HEqual.
Qed.

(** from 13 Lemma 13.2 (alias): open refinement family yields a basis **) 
(** LATEX VERSION: Rephrasing Lemma 13.2: a subcollection C of opens that locally refines every open is a basis generating T. **)
Theorem lemma13_2_basis_from_open_subcollection : forall X T C:set,
  topology_on X T ->
  (forall c :e C, c :e T) ->
  (forall U :e T, forall x :e U, exists c :e C, x :e c /\ c c= U) ->
  basis_on X C /\ generated_topology X C = T.
let X T C. assume Htop HCsub Href.
exact (basis_refines_topology X T C Htop HCsub Href).
Qed.

(** from 13: criterion for fineness via bases **) 
(** LATEX VERSION: Lemma 13.3 ( direction): If every basis element of B around x contains a basis element of B at x, then the topology from B is finer than that from B. **)
Theorem finer_via_basis : forall X B B':set,
  basis_on X B -> basis_on X B' ->
  (forall x :e X, forall b:set, b :e B -> x :e b ->
      exists b' :e B', x :e b' /\ b' c= b) ->
  finer_than (generated_topology X B') (generated_topology X B).
let X B B'. assume HB HB' Hcond.
claim HT : topology_on X (generated_topology X B).
{ exact (lemma_topology_from_basis X B HB). }
claim HRefProp : forall U :e generated_topology X B, forall x :e U, exists b' :e B', x :e b' /\ b' c= U.
{ let U. assume HU : U :e generated_topology X B.
  let x. assume HxU.
  claim HUsubX : U c= X.
  { exact (PowerE X U (SepE1 (Power X)
                             (fun U0 : set => forall x0 :e U0, exists b :e B, x0 :e b /\ b c= U0)
                             U HU)). }
  claim HxX : x :e X.
  { exact (HUsubX x HxU). }
  claim HUprop : forall x0 :e U, exists b :e B, x0 :e b /\ b c= U.
  { exact (SepE2 (Power X)
                 (fun U0 : set => forall x0 :e U0, exists b :e B, x0 :e b /\ b c= U0)
                 U HU). }
  claim Hexb : exists b :e B, x :e b /\ b c= U.
  { exact (HUprop x HxU). }
  apply Hexb.
  let b. assume Hbpair.
  claim HbB : b :e B.
  { exact (andEL (b :e B) (x :e b /\ b c= U) Hbpair). }
  claim Hbprop : x :e b /\ b c= U.
  { exact (andER (b :e B) (x :e b /\ b c= U) Hbpair). }
  claim Hxb : x :e b.
  { exact (andEL (x :e b) (b c= U) Hbprop). }
  claim HbsubU : b c= U.
  { exact (andER (x :e b) (b c= U) Hbprop). }
  claim Hexb' : exists b' :e B', x :e b' /\ b' c= b.
  { exact (Hcond x HxX b HbB Hxb). }
  apply Hexb'.
  let b'. assume Hb'pair.
  claim Hb'B : b' :e B'.
  { exact (andEL (b' :e B') (x :e b' /\ b' c= b) Hb'pair). }
  claim Hb'prop : x :e b' /\ b' c= b.
  { exact (andER (b' :e B') (x :e b' /\ b' c= b) Hb'pair). }
  claim Hxb' : x :e b'.
  { exact (andEL (x :e b') (b' c= b) Hb'prop). }
  claim Hb'subb : b' c= b.
  { exact (andER (x :e b') (b' c= b) Hb'prop). }
  witness b'.
  apply andI.
  - exact Hb'B.
  - apply andI.
    * exact Hxb'.
    * exact (Subq_tra b' b U Hb'subb HbsubU). }
prove generated_topology X B c= generated_topology X B'.
  let U. assume HU.
  claim HUsubX : U c= X.
  { exact (PowerE X U (SepE1 (Power X)
                             (fun U0 : set => forall x0 :e U0, exists b0 :e B, x0 :e b0 /\ b0 c= U0)
                             U HU)). }
  claim HUprop : forall x :e U, exists b' :e B', x :e b' /\ b' c= U.
  { exact (HRefProp U HU). }
  exact (SepI (Power X)
              (fun U0 : set => forall x0 :e U0, exists b0 :e B', x0 :e b0 /\ b0 c= U0)
              U
              (PowerI X U HUsubX)
              HUprop).
Qed.

(** from 13 Lemma 13.3: basis inclusion criterion for fineness **) 
(** LATEX VERSION: Lemma 13.3: T(B) finer than T(B) iff each basis element of B has for every xb some bB with xbb. **)
Theorem basis_finer_equiv_condition : forall X B B':set,
  basis_on X B -> basis_on X B' ->
  ((forall x :e X, forall b :e B, x :e b -> exists b' :e B', x :e b' /\ b' c= b) <->
  finer_than (generated_topology X B') (generated_topology X B)).
let X B B'. assume HB HB'.
apply iffI.
- assume Hcond.
  exact (finer_via_basis X B B' HB HB' Hcond).
- assume Hfiner.
  let x. assume HxX. let b. assume HbB Hxb.
  claim HbGen : b :e generated_topology X B.
  { exact (generated_topology_contains_basis X B HB b HbB). }
  claim HbGen' : b :e generated_topology X B'.
  { exact (Hfiner b HbGen). }
  claim Hbprop : forall x0 :e b, exists b' :e B', x0 :e b' /\ b' c= b.
  { exact (SepE2 (Power X)
                 (fun U0 : set => forall x0 :e U0, exists b0 :e B', x0 :e b0 /\ b0 c= U0)
                 b HbGen'). }
  exact (Hbprop x Hxb).
Qed.

(** from 13 Lemma 13.3 (direction): generated topology is minimal containing basis **) 
(** LATEX VERSION: If T is a topology on X containing every basis element of B, then T is finer than the topology generated by B. **)
Theorem generated_topology_finer : forall X B T:set,
  basis_on X B -> topology_on X T ->
  (forall b :e B, b :e T) ->
  finer_than T (generated_topology X B).
let X B T. assume HBasis HT HBsub.
claim HUnionClosed : forall Fam :e Power T, Union Fam :e T.
{ exact (andER ((T c= Power X /\ Empty :e T) /\ X :e T) (forall Fam :e Power T, Union Fam :e T)
               (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall Fam :e Power T, Union Fam :e T))
                      (forall U :e T, forall V :e T, U :/\: V :e T)
                      HT)). }
prove generated_topology X B c= T.
  let U. assume HU.
  claim HUsubX : U c= X.
  { exact (PowerE X U (SepE1 (Power X)
                             (fun U0 : set => forall x0 :e U0, exists b0 :e B, x0 :e b0 /\ b0 c= U0)
                             U HU)). }
  claim HUprop : forall x :e U, exists b :e B, x :e b /\ b c= U.
  { exact (SepE2 (Power X)
                 (fun U0 : set => forall x0 :e U0, exists b0 :e B, x0 :e b0 /\ b0 c= U0)
                 U HU). }
  set Fam : set := {b :e B|b c= U}.
  claim HFamPowB : Fam :e Power B.
  { apply PowerI B Fam.
    let b. assume HbFam.
    exact (SepE1 B (fun b0 : set => b0 c= U) b HbFam). }
  claim HUnionEq : Union Fam = U.
  { apply set_ext.
    - let x. assume HxUnion.
      apply UnionE_impred Fam x HxUnion.
      let b. assume Hxb HbFam.
      claim HbsubU : b c= U.
      { exact (SepE2 B (fun b0 : set => b0 c= U) b HbFam). }
      exact (HbsubU x Hxb).
    - let x. assume HxU.
      claim Hexb : exists b :e B, x :e b /\ b c= U.
      { exact (HUprop x HxU). }
      apply Hexb.
      let b. assume Hbpair.
      claim HbB : b :e B.
      { exact (andEL (b :e B) (x :e b /\ b c= U) Hbpair). }
      claim Hbprop : x :e b /\ b c= U.
      { exact (andER (b :e B) (x :e b /\ b c= U) Hbpair). }
      claim Hxb : x :e b.
      { exact (andEL (x :e b) (b c= U) Hbprop). }
      claim HbsubU : b c= U.
      { exact (andER (x :e b) (b c= U) Hbprop). }
      claim HbT : b :e T.
      { exact (HBsub b HbB). }
      claim HbFam : b :e Fam.
      { exact (SepI B (fun b0 : set => b0 c= U) b HbB HbsubU). }
      exact (UnionI Fam x b Hxb HbFam). }
  claim HFamPowT : Fam :e Power T.
  { apply PowerI T Fam.
    let b. assume HbFam.
    claim HbB : b :e B.
    { exact (SepE1 B (fun b0 : set => b0 c= U) b HbFam). }
    exact (HBsub b HbB). }
  claim HUnionT : Union Fam :e T.
  { exact (HUnionClosed Fam HFamPowT). }
  rewrite <- HUnionEq.
  exact HUnionT.
Qed.

(** from 13 Lemma 13.3 (direction): generated topology is smallest with given basis **) 
(** LATEX VERSION: Restates previous direction: the topology generated by B is the smallest topology containing B. **)
Theorem topology_generated_by_basis_is_smallest : forall X B T:set,
  basis_on X B -> topology_on X T ->
  (forall b :e B, b :e T) ->
  finer_than T (generated_topology X B).
let X B T. assume HBasis HT HBsub.
exact (generated_topology_finer X B T HBasis HT HBsub).
Qed.

(** from 13 Lemma 13.4: generated topology equals unions of basis elements **) 
(** LATEX VERSION: Lemma 13.4: The topology generated by B consists exactly of unions of subfamilies of B. **)
Theorem union_of_basis_equals_open :
  forall X B:set, basis_on X B ->
  generated_topology X B = {Union Fam | Fam :e Power B}.
let X B. assume HBasis.
apply set_ext.
- let U. assume HU.
  claim HUopen : open_in X (generated_topology X B) U.
  { exact (andI (topology_on X (generated_topology X B))
                 (U :e generated_topology X B)
                 (lemma_topology_from_basis X B HBasis)
                 HU). }
  claim HexFam : exists Fam :e Power B, Union Fam = U.
  { exact (open_sets_as_unions_of_basis X B HBasis U HUopen). }
  apply HexFam.
  let Fam. assume HFampair.
  claim HFamPow : Fam :e Power B.
  { exact (andEL (Fam :e Power B) (Union Fam = U) HFampair). }
  claim HUnion : Union Fam = U.
  { exact (andER (Fam :e Power B) (Union Fam = U) HFampair). }
  claim HUnionFam : Union Fam :e {Union Fam0 | Fam0 :e Power B}.
  { exact (ReplI (Power B) (fun Fam0 : set => Union Fam0) Fam HFamPow). }
  rewrite <- HUnion.
  exact HUnionFam.
- let U. assume HUUnion.
  claim HexFamPowRaw : exists Fam :e Power B, U = Union Fam.
  { exact (ReplE (Power B) (fun Fam0 : set => Union Fam0) U HUUnion). }
  claim HexFamPow : exists Fam :e Power B, Union Fam = U.
  { apply HexFamPowRaw.
    let Fam. assume HFamPair.
    claim HFamPow : Fam :e Power B.
    { exact (andEL (Fam :e Power B) (U = Union Fam) HFamPair). }
    claim HUnion : U = Union Fam.
    { exact (andER (Fam :e Power B) (U = Union Fam) HFamPair). }
    witness Fam.
    apply andI.
    - exact HFamPow.
    - rewrite <- HUnion.
      reflexivity. }
  claim HUopen : open_in X (generated_topology X B) U.
  { exact (basis_generates_open_sets X B HBasis U HexFamPow). }
  exact (andER (topology_on X (generated_topology X B))
               (U :e generated_topology X B)
               HUopen).
Qed.

(** from 13 Example 3: singleton basis **) 
(** LATEX VERSION: Example 3: the collection of all one-point subsets of X forms a basis. **)
(** FIXED: Use `{x}` directly rather than `{x,x}`. **)
Definition singleton_basis : set -> set := fun X => {{x}|x :e X}.

(** from 13 Example 3: singleton collection forms a basis **) 
(** LATEX VERSION: The collection of singletons on X satisfies the two basis axioms. **)
Theorem singleton_basis_is_basis : forall X:set, basis_on X (singleton_basis X).
let X.
prove ((singleton_basis X c= Power X
        /\ (forall x :e X, exists b :e singleton_basis X, x :e b))
       /\ (forall b1 :e singleton_basis X, forall b2 :e singleton_basis X, forall x:set,
              x :e b1 -> x :e b2 ->
              exists b3 :e singleton_basis X, x :e b3 /\ b3 c= b1 :/\: b2)).
  apply andI.
  - apply andI.
	  * prove singleton_basis X c= Power X.
	    let s. assume Hs.
	    apply (ReplE_impred X (fun x0 : set => {x0}) s Hs).
	    let x. assume HxX Hseq.
	    rewrite Hseq.
	    apply PowerI.
	    let y. assume Hy: y :e {x}.
	    claim Hyx: y = x.
	    { exact (SingE x y Hy). }
	    rewrite Hyx.
	    exact HxX.
	  * prove forall x :e X, exists b :e singleton_basis X, x :e b.
	    let x. assume HxX.
	    witness {x}.
	    apply andI.
	    * exact (ReplI X (fun x0 : set => {x0}) x HxX).
	    * exact (SingI x).
	 - prove forall b1 :e singleton_basis X, forall b2 :e singleton_basis X, forall x:set,
	            x :e b1 -> x :e b2 ->
	            exists b3 :e singleton_basis X, x :e b3 /\ b3 c= b1 :/\: b2.
	   let b1. assume Hb1.
	   let b2. assume Hb2.
	   let x. assume Hx1 Hx2.
	   apply (ReplE_impred X (fun x0 : set => {x0}) b1 Hb1).
	   let x1. assume Hx1X Hb1eq.
	   apply (ReplE_impred X (fun x0 : set => {x0}) b2 Hb2).
	   let x2. assume Hx2X Hb2eq.
	   claim Hx1in : x :e {x1}.
	   { rewrite <- Hb1eq. exact Hx1. }
	   claim Hx2in : x :e {x2}.
	   { rewrite <- Hb2eq. exact Hx2. }
	   claim Hx_eq_x1 : x = x1.
	   { exact (SingE x1 x Hx1in). }
	   claim Hx_eq_x2 : x = x2.
	   { exact (SingE x2 x Hx2in). }
	   claim HxX : x :e X.
	   { rewrite Hx_eq_x1. exact Hx1X. }
	   witness {x}.
	   apply andI.
	   - exact (ReplI X (fun x0 : set => {x0}) x HxX).
	    - apply andI.
	      + exact (SingI x).
	      + prove {x} c= b1 :/\: b2.
	       let y. assume Hy.
	       claim Hyx: y = x.
	       { exact (SingE x y Hy). }
	       rewrite Hyx.
	       exact (binintersectI b1 b2 x Hx1 Hx2).
Qed.

(** from 13 Example 3: topology generated by singletons is discrete **) 
(** LATEX VERSION: The topology generated by the singleton basis is the discrete topology on X. **)
Theorem generated_topology_singletons_discrete : forall X:set,
  generated_topology X (singleton_basis X) = discrete_topology X.
let X.
apply set_ext.
- let U. assume HUgen.
  exact (SepE1 (Power X)
               (fun U0 : set => forall x0 :e U0, exists b :e singleton_basis X, x0 :e b /\ b c= U0)
               U HUgen).
- let U. assume HUinPow : U :e Power X.
  claim HUsubX : U c= X.
  { exact (PowerE X U HUinPow). }
  claim HUprop : forall x :e U, exists b :e singleton_basis X, x :e b /\ b c= U.
{ let x. assume HxU.
  witness {x}.
  apply andI.
  - exact (ReplI X (fun x0 : set => {x0}) x (HUsubX x HxU)).
  - apply andI.
    * exact (SingI x).
    * let y. assume Hy.
      claim Hyx: y = x.
      { exact (SingE x y Hy). }
      rewrite Hyx.
      exact HxU. }
  exact (SepI (Power X)
              (fun U0 : set => forall x0 :e U0, exists b :e singleton_basis X, x0 :e b /\ b c= U0)
              U
              HUinPow
              HUprop).
Qed.

(** Misleading "OrderedPair" definition eliminated. Cartesian products use setprod (defined at line 2717). Individual ordered pairs use tuple notation (x,y). **)

(** ambient real line **) 
Definition R : set := real.

(** rational numbers as subset of reals **)
(** LATEX VERSION: The rationals  as a subset of . **)
(** FIXED: Now uses proper rational definition from line 6202. rational = {x :e real | exists m :e int, exists n :e omega\\{0}, x = m/n}. **)
Definition Q : set := rational.

(** ordering relation on the reals **) 
Definition Rlt : set -> set -> prop := fun a b =>
  a :e R /\ b :e R /\ a < b.

(** helper: non-strict order on the reals by negating strict order **)
(** LATEX VERSION: Write a  b for not(b < a) in the ambient strict order on . **)
(** SUSPICIOUS DEFINITION: This defines `a <= b` as `~(b < a)`, not as `a=b \/ a<b`; later uses rely on the trichotomy properties of `<` on reals. **)
Definition Rle : set -> set -> prop := fun a b =>
  a :e R /\ b :e R /\ ~(Rlt b a).

(** helper introduction rule for Rle **)
Theorem RleI : forall a b:set, a :e R -> b :e R -> ~(Rlt b a) -> Rle a b.
let a b. assume Ha Hb Hnlt.
prove a :e R /\ b :e R /\ ~(Rlt b a).
apply andI.
- apply andI.
  + exact Ha.
  + exact Hb.
- exact Hnlt.
Qed.

(** helper elimination rules for Rle **)
Theorem RleE_left : forall a b:set, Rle a b -> a :e R.
let a b. assume H.
exact (andEL (a :e R) (b :e R) (andEL (a :e R /\ b :e R) (~(Rlt b a)) H)).
Qed.

(** helper elimination rules for Rle **)
Theorem RleE_right : forall a b:set, Rle a b -> b :e R.
let a b. assume H.
exact (andER (a :e R) (b :e R) (andEL (a :e R /\ b :e R) (~(Rlt b a)) H)).
Qed.

(** helper elimination rules for Rle **)
Theorem RleE_nlt : forall a b:set, Rle a b -> ~(Rlt b a).
let a b. assume H.
exact (andER (a :e R /\ b :e R) (~(Rlt b a)) H).
Qed.

(** from 13 Example 4: helper introduction rule for Rlt **)
(** LATEX VERSION: We use the usual convention a<b implies a and b are reals and a<b. **)
Theorem RltI : forall a b:set, a :e R -> b :e R -> a < b -> Rlt a b.
let a b. assume Ha Hb Hab.
prove a :e R /\ b :e R /\ a < b.
apply andI.
- apply andI.
  + exact Ha.
  + exact Hb.
- exact Hab.
Qed.

(** from 13 Example 4: helper elimination rules for Rlt **)
(** LATEX VERSION: If Rlt a b then a and b are reals and a<b. **)
Theorem RltE_left : forall a b:set, Rlt a b -> a :e R.
let a b. assume H.
exact (andEL (a :e R) (b :e R) (andEL (a :e R /\ b :e R) (a < b) H)).
Qed.

(** from 13 Example 4: helper elimination rules for Rlt **)
(** LATEX VERSION: If Rlt a b then a and b are reals and a<b. **)
Theorem RltE_right : forall a b:set, Rlt a b -> b :e R.
let a b. assume H.
exact (andER (a :e R) (b :e R) (andEL (a :e R /\ b :e R) (a < b) H)).
Qed.

(** from 13 Example 4: helper elimination rules for Rlt **)
(** LATEX VERSION: If Rlt a b then a and b are reals and a<b. **)
Theorem RltE_lt : forall a b:set, Rlt a b -> a < b.
let a b. assume H.
exact (andER (a :e R /\ b :e R) (a < b) H).
Qed.

(** helper: transitivity of Rlt **)
(** LATEX VERSION: If a<b and b<c then a<c. **)
Theorem Rlt_tra : forall a b c:set, Rlt a b -> Rlt b c -> Rlt a c.
let a b c. assume Hab Hbc.
claim HaR : a :e R.
{ exact (RltE_left a b Hab). }
claim HbR : b :e R.
{ exact (RltE_right a b Hab). }
claim HcR : c :e R.
{ exact (RltE_right b c Hbc). }
claim Hablt : a < b.
{ exact (RltE_lt a b Hab). }
claim Hbclt : b < c.
{ exact (RltE_lt b c Hbc). }
claim HaS : SNo a.
{ exact (real_SNo a HaR). }
claim HbS : SNo b.
{ exact (real_SNo b HbR). }
claim HcS : SNo c.
{ exact (real_SNo c HcR). }
claim Haclt : a < c.
{ exact (SNoLt_tra a b c HaS HbS HcS Hablt Hbclt). }
exact (RltI a c HaR HcR Haclt).
Qed.

(** from 13 Example 4: Rlt is irreflexive **)
(** LATEX VERSION: We use that a<a is impossible. **)
Theorem not_Rlt_refl : forall a:set, a :e R -> ~(Rlt a a).
let a. assume Ha.
assume Haa.
claim Hlt : a < a.
{ exact (RltE_lt a a Haa). }
exact ((SNoLt_irref a) Hlt).
Qed.

(** helper: asymmetry of Rlt **)
(** LATEX VERSION: If a<b then not(b<a). **)
Theorem not_Rlt_sym : forall a b:set, Rlt a b -> ~(Rlt b a).
let a b. assume Hab.
assume Hba.
claim Haa: Rlt a a.
{ exact (Rlt_tra a b a Hab Hba). }
exact (not_Rlt_refl a (RltE_left a b Hab) Haa).
Qed.

(** helper: strict order implies non-strict order **)
Theorem Rlt_implies_Rle : forall a b:set, Rlt a b -> Rle a b.
let a b. assume Hab.
apply (RleI a b (RltE_left a b Hab) (RltE_right a b Hab)).
exact (not_Rlt_sym a b Hab).
Qed.

(** helper: reflexivity of Rle **)
(** LATEX VERSION: a  a. **)
Theorem Rle_refl : forall a:set, a :e R -> Rle a a.
let a. assume Ha.
apply (RleI a a Ha Ha).
exact (not_Rlt_refl a Ha).
Qed.

(** helper for 13 Example 4: 0 < 1 in Rlt form **)
(** LATEX VERSION: We use 0<1 in the usual order on R. **)
Theorem Rlt_0_1 : Rlt 0 1.
exact (RltI 0 1 real_0 real_1 SNoLt_0_1).
Qed.

(** from 13 Example 4: -1 is less than 0 in  **)
(** LATEX VERSION: We use that -1 < 0. **)
Theorem minus_1_lt_0 : minus_SNo 1 < 0.
claim H01 : 0 < 1.
{ exact SNoLt_0_1. }
claim Hm1ltm0 : minus_SNo 1 < minus_SNo 0.
{ exact (minus_SNo_Lt_contra 0 1 SNo_0 SNo_1 H01). }
rewrite <- (minus_SNo_0) at 2.
exact Hm1ltm0.
Qed.

(** from 13 Example 4: circular vs rectangular region bases **)
(** LATEX VERSION: Example 4: circular regions and axis-parallel rectangular regions in  both form bases generating the same topology. **)
(** FIXED: EuclidPlane is now correctly RR (Cartesian product) since setprod = setprod. **)
Definition EuclidPlane : set := setprod R R.
(** Coordinate selectors for points in EuclidPlane. **)
Definition R2_xcoord : set -> set := fun p => p 0.
Definition R2_ycoord : set -> set := fun p => p 1.

(** from 13 Example 4: coordinates of a point in RR are real **)
(** LATEX VERSION: If p   then its coordinates lie in . **)
Theorem EuclidPlane_xcoord_in_R : forall p:set, p :e EuclidPlane -> R2_xcoord p :e R.
let p. assume Hp.
prove p 0 :e R.
exact (ap0_Sigma R (fun _ : set => R) p Hp).
Qed.

(** from 13 Example 4: coordinates of a point in RR are real **)
(** LATEX VERSION: If p   then its coordinates lie in . **)
Theorem EuclidPlane_ycoord_in_R : forall p:set, p :e EuclidPlane -> R2_ycoord p :e R.
let p. assume Hp.
prove p 1 :e R.
claim Hp1 : p 1 :e (fun _ : set => R) (p 0).
{ exact (ap1_Sigma R (fun _ : set => R) p Hp). }
exact Hp1.
Qed.

(** from 13 Example 4: coordinate selectors on tuples **)
(** LATEX VERSION: For a point (x,y), the coordinate maps return x and y. **)
Theorem R2_xcoord_tuple : forall x y:set, R2_xcoord (x,y) = x.
let x y.
prove (x,y) 0 = x.
rewrite <- (tuple_pair x y).
exact (pair_ap_0 x y).
Qed.

(** from 13 Example 4: coordinate selectors on tuples **)
(** LATEX VERSION: For a point (x,y), the coordinate maps return x and y. **)
Theorem R2_ycoord_tuple : forall x y:set, R2_ycoord (x,y) = y.
let x y.
prove (x,y) 1 = y.
rewrite <- (tuple_pair x y).
exact (pair_ap_1 x y).
Qed.

(** helper: equality of ordered pairs is coordinatewise **)
(** LATEX VERSION: If (x1,y1) = (x2,y2) then x1=x2 and y1=y2. **)
Theorem tuple_eq_coords : forall x1 y1 x2 y2:set,
  (x1,y1) = (x2,y2) -> x1 = x2 /\ y1 = y2.
let x1 y1 x2 y2. assume Heq.
apply andI.
- prove x1 = x2.
  claim Hproj0: (x1,y1) 0 = (x2,y2) 0.
  { rewrite Heq. reflexivity. }
  claim Hx1: (x1,y1) 0 = x1.
  { exact (tuple_2_0_eq x1 y1). }
  claim Hx2: (x2,y2) 0 = x2.
  { exact (tuple_2_0_eq x2 y2). }
  rewrite <- Hx1.
  rewrite <- Hx2.
  exact Hproj0.
- prove y1 = y2.
  claim Hproj1: (x1,y1) 1 = (x2,y2) 1.
  { rewrite Heq. reflexivity. }
  claim Hy1: (x1,y1) 1 = y1.
  { exact (tuple_2_1_eq x1 y1). }
  claim Hy2: (x2,y2) 1 = y2.
  { exact (tuple_2_1_eq x2 y2). }
  rewrite <- Hy1.
  rewrite <- Hy2.
  exact Hproj1.
Qed.

(** helper: equality of ordered pairs from coordinate equalities **)
(** LATEX VERSION: If x1=x2 and y1=y2 then (x1,y1)=(x2,y2). **)
Theorem tuple_coords_eq : forall x1 y1 x2 y2:set,
  x1 = x2 -> y1 = y2 -> (x1,y1) = (x2,y2).
let x1 y1 x2 y2.
assume Hx: x1 = x2.
assume Hy: y1 = y2.
rewrite Hx.
rewrite Hy.
reflexivity.
Qed.

(** helper: equality of ordered pairs from coordinate equalities **)
(** LATEX VERSION: If x1=x2 and y1=y2 then (x1,y1)=(x2,y2). **)
Theorem coords_eq_tuple : forall x1 y1 x2 y2:set,
  x1 = x2 -> y1 = y2 -> (x1,y1) = (x2,y2).
let x1 y1 x2 y2.
assume Hx: x1 = x2.
assume Hy: y1 = y2.
rewrite <- (tuple_pair x1 y1) at 1.
rewrite <- (tuple_pair x2 y2).
rewrite Hx.
rewrite Hy.
reflexivity.
Qed.

(** helper: eta law for points in EuclidPlane **)
(** LATEX VERSION: Every point p in RR is equal to the ordered pair of its coordinates. **)
Theorem EuclidPlane_eta : forall p:set, p :e EuclidPlane -> (R2_xcoord p, R2_ycoord p) = p.
let p. assume Hp.
prove (R2_xcoord p, R2_ycoord p) = p.
apply (Sigma_E R (fun _ : set => R) p Hp).
let x.
assume Hx_pair.
apply Hx_pair.
assume HxR Hexy.
apply Hexy.
let y.
assume Hy_pair.
apply Hy_pair.
assume HyR Hpeq.
claim HeqT: p = (x,y).
{ prove p = (x,y).
  rewrite <- (tuple_pair x y).
  exact Hpeq. }
rewrite HeqT.
rewrite (R2_xcoord_tuple x y).
rewrite (R2_ycoord_tuple x y).
reflexivity.
Qed.

(** from 13 Example 4: equality of points in RR is coordinatewise **)
(** LATEX VERSION: If (x1,y1) = (x2,y2) then x1=x2 and y1=y2. **)
Theorem tuple_eq_coords_R2 : forall x1 y1 x2 y2:set,
  (x1,y1) = (x2,y2) -> x1 = x2 /\ y1 = y2.
let x1 y1 x2 y2. assume Heq.
apply andI.
- prove x1 = x2.
  rewrite <- (R2_xcoord_tuple x1 y1).
  rewrite <- (R2_xcoord_tuple x2 y2).
  rewrite Heq.
  reflexivity.
- prove y1 = y2.
  rewrite <- (R2_ycoord_tuple x1 y1).
  rewrite <- (R2_ycoord_tuple x2 y2).
  rewrite Heq.
  reflexivity.
Qed.

(** Euclidean distance in : sqrt((x1-x2)^2 + (y1-y2)^2), implemented using pre-topology surreal/real operations. **)
Definition distance_R2 : set -> set -> set := fun p c =>
  sqrt_SNo_nonneg
    (add_SNo
      (mul_SNo (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c)))
              (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c))))
      (mul_SNo (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c)))
              (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c))))).

(** from 13 Example 4: distance is real-valued **)
(** LATEX VERSION: For points p,c in RR, the distance d(p,c) is a real number. **)
Theorem distance_R2_in_R : forall p c:set, p :e EuclidPlane -> c :e EuclidPlane -> distance_R2 p c :e R.
let p c. assume Hp Hc.
(** coordinates are real **)
claim Hp0R : R2_xcoord p :e R.
{ exact (EuclidPlane_xcoord_in_R p Hp). }
claim Hp1R : R2_ycoord p :e R.
{ exact (EuclidPlane_ycoord_in_R p Hp). }
claim Hc0R : R2_xcoord c :e R.
{ exact (EuclidPlane_xcoord_in_R c Hc). }
claim Hc1R : R2_ycoord c :e R.
{ exact (EuclidPlane_ycoord_in_R c Hc). }
(** differences in R **)
set dx := add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c)).
set dy := add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c)).
claim Hmx : minus_SNo (R2_xcoord c) :e R.
{ exact (real_minus_SNo (R2_xcoord c) Hc0R). }
claim Hmy : minus_SNo (R2_ycoord c) :e R.
{ exact (real_minus_SNo (R2_ycoord c) Hc1R). }
claim HdxR : dx :e R.
{ exact (real_add_SNo (R2_xcoord p) Hp0R (minus_SNo (R2_xcoord c)) Hmx). }
claim HdyR : dy :e R.
{ exact (real_add_SNo (R2_ycoord p) Hp1R (minus_SNo (R2_ycoord c)) Hmy). }
(** squares and sum in R **)
set dx2 := mul_SNo dx dx.
set dy2 := mul_SNo dy dy.
claim Hdx2def : dx2 = mul_SNo dx dx.
{ reflexivity. }
claim Hdy2def : dy2 = mul_SNo dy dy.
{ reflexivity. }
claim Hdx2R : dx2 :e R.
{ exact (real_mul_SNo dx HdxR dx HdxR). }
claim Hdy2R : dy2 :e R.
{ exact (real_mul_SNo dy HdyR dy HdyR). }
set sum := add_SNo dx2 dy2.
claim Hsumdef : sum = add_SNo dx2 dy2.
{ reflexivity. }
claim HsumR : sum :e R.
{ exact (real_add_SNo dx2 Hdx2R dy2 Hdy2R). }
(** nonnegativity of squares and of the sum **)
claim HdxS : SNo dx.
{ exact (real_SNo dx HdxR). }
claim HdyS : SNo dy.
{ exact (real_SNo dy HdyR). }
claim Hdx2S : SNo dx2.
{ exact (real_SNo dx2 Hdx2R). }
claim Hdy2S : SNo dy2.
{ exact (real_SNo dy2 Hdy2R). }
claim Hdx2nonneg : 0 <= dx2.
{ claim H0or : dx = 0 \/ 0 < (mul_SNo dx dx).
  { exact (SNo_zero_or_sqr_pos dx HdxS). }
  apply H0or.
  - assume Hdx0 : dx = 0.
    rewrite Hdx2def.
    rewrite Hdx0.
    rewrite (mul_SNo_zeroL 0 SNo_0).
    exact (SNoLe_ref 0).
  - assume Hpos : 0 < (mul_SNo dx dx).
    rewrite Hdx2def.
    exact (SNoLtLe 0 (mul_SNo dx dx) Hpos).
}
claim Hdy2nonneg : 0 <= dy2.
{ claim H0or : dy = 0 \/ 0 < (mul_SNo dy dy).
  { exact (SNo_zero_or_sqr_pos dy HdyS). }
  apply H0or.
  - assume Hdy0 : dy = 0.
    rewrite Hdy2def.
    rewrite Hdy0.
    rewrite (mul_SNo_zeroL 0 SNo_0).
    exact (SNoLe_ref 0).
  - assume Hpos : 0 < (mul_SNo dy dy).
    rewrite Hdy2def.
    exact (SNoLtLe 0 (mul_SNo dy dy) Hpos).
}
claim HsumNonneg : 0 <= sum.
{ rewrite Hsumdef.
  rewrite <- (add_SNo_0L 0 SNo_0) at 1.
  exact (add_SNo_Le3 0 0 dx2 dy2 SNo_0 SNo_0 Hdx2S Hdy2S Hdx2nonneg Hdy2nonneg).
}
(** unfold distance_R2 and apply sqrt real lemma **)
claim Hdef : distance_R2 p c = sqrt_SNo_nonneg sum.
{ reflexivity. }
rewrite Hdef.
exact (sqrt_SNo_nonneg_real sum HsumR HsumNonneg).
Qed.

(** from 13 Example 4: distance is nonnegative **)
(** LATEX VERSION: The distance function takes nonnegative values. **)
Theorem distance_R2_nonneg : forall p c:set, p :e EuclidPlane -> c :e EuclidPlane -> 0 <= distance_R2 p c.
let p c. assume Hp Hc.
(** coordinates are real **)
claim Hp0R : R2_xcoord p :e R.
{ exact (EuclidPlane_xcoord_in_R p Hp). }
claim Hp1R : R2_ycoord p :e R.
{ exact (EuclidPlane_ycoord_in_R p Hp). }
claim Hc0R : R2_xcoord c :e R.
{ exact (EuclidPlane_xcoord_in_R c Hc). }
claim Hc1R : R2_ycoord c :e R.
{ exact (EuclidPlane_ycoord_in_R c Hc). }
(** differences **)
set dx := add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c)).
set dy := add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c)).
claim Hmx : minus_SNo (R2_xcoord c) :e R.
{ exact (real_minus_SNo (R2_xcoord c) Hc0R). }
claim Hmy : minus_SNo (R2_ycoord c) :e R.
{ exact (real_minus_SNo (R2_ycoord c) Hc1R). }
claim HdxR : dx :e R.
{ exact (real_add_SNo (R2_xcoord p) Hp0R (minus_SNo (R2_xcoord c)) Hmx). }
claim HdyR : dy :e R.
{ exact (real_add_SNo (R2_ycoord p) Hp1R (minus_SNo (R2_ycoord c)) Hmy). }
(** squares and sum **)
set dx2 := mul_SNo dx dx.
set dy2 := mul_SNo dy dy.
claim Hdx2R : dx2 :e R.
{ exact (real_mul_SNo dx HdxR dx HdxR). }
claim Hdy2R : dy2 :e R.
{ exact (real_mul_SNo dy HdyR dy HdyR). }
set sum := add_SNo dx2 dy2.
claim HsumR : sum :e R.
{ exact (real_add_SNo dx2 Hdx2R dy2 Hdy2R). }
claim HdxS : SNo dx.
{ exact (real_SNo dx HdxR). }
claim HdyS : SNo dy.
{ exact (real_SNo dy HdyR). }
claim Hdx2S : SNo dx2.
{ exact (real_SNo dx2 Hdx2R). }
claim Hdy2S : SNo dy2.
{ exact (real_SNo dy2 Hdy2R). }
claim HsumS : SNo sum.
{ exact (real_SNo sum HsumR). }
(** nonnegativity of squares and of the sum **)
claim Hdx2nonneg : 0 <= dx2.
{ claim H0or : dx = 0 \/ 0 < (mul_SNo dx dx).
  { exact (SNo_zero_or_sqr_pos dx HdxS). }
  apply H0or.
  - assume Hdx0 : dx = 0.
    rewrite Hdx0.
    rewrite (mul_SNo_zeroL 0 SNo_0).
    exact (SNoLe_ref 0).
  - assume Hpos : 0 < (mul_SNo dx dx).
    exact (SNoLtLe 0 (mul_SNo dx dx) Hpos).
}
claim Hdy2nonneg : 0 <= dy2.
{ claim H0or : dy = 0 \/ 0 < (mul_SNo dy dy).
  { exact (SNo_zero_or_sqr_pos dy HdyS). }
  apply H0or.
  - assume Hdy0 : dy = 0.
    rewrite Hdy0.
    rewrite (mul_SNo_zeroL 0 SNo_0).
    exact (SNoLe_ref 0).
  - assume Hpos : 0 < (mul_SNo dy dy).
    exact (SNoLtLe 0 (mul_SNo dy dy) Hpos).
}
claim HsumNonneg : 0 <= sum.
{ rewrite <- (add_SNo_0L 0 SNo_0) at 1.
  exact (add_SNo_Le3 0 0 dx2 dy2 SNo_0 SNo_0 Hdx2S Hdy2S Hdx2nonneg Hdy2nonneg).
}
(** conclude using sqrt nonnegativity **)
claim Hdef : distance_R2 p c = sqrt_SNo_nonneg sum.
{ reflexivity. }
rewrite Hdef.
exact (sqrt_SNo_nonneg_nonneg sum HsumS HsumNonneg).
Qed.

(** from 13 Example 4: squared distance formula **)
(** LATEX VERSION: d(p,c) squared equals (xp-xc) squared plus (yp-yc) squared. **)
Theorem distance_R2_sqr : forall p c:set, p :e EuclidPlane -> c :e EuclidPlane ->
  mul_SNo (distance_R2 p c) (distance_R2 p c)
  = add_SNo
      (mul_SNo (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c)))
              (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c))))
      (mul_SNo (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c)))
              (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c)))).
let p c. assume Hp Hc.
(** establish that the sum under the square root is surreal and nonnegative **)
claim Hp0R : R2_xcoord p :e R.
{ exact (EuclidPlane_xcoord_in_R p Hp). }
claim Hp1R : R2_ycoord p :e R.
{ exact (EuclidPlane_ycoord_in_R p Hp). }
claim Hc0R : R2_xcoord c :e R.
{ exact (EuclidPlane_xcoord_in_R c Hc). }
claim Hc1R : R2_ycoord c :e R.
{ exact (EuclidPlane_ycoord_in_R c Hc). }
set dx := add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c)).
set dy := add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c)).
claim Hmx : minus_SNo (R2_xcoord c) :e R.
{ exact (real_minus_SNo (R2_xcoord c) Hc0R). }
claim Hmy : minus_SNo (R2_ycoord c) :e R.
{ exact (real_minus_SNo (R2_ycoord c) Hc1R). }
claim HdxR : dx :e R.
{ exact (real_add_SNo (R2_xcoord p) Hp0R (minus_SNo (R2_xcoord c)) Hmx). }
claim HdyR : dy :e R.
{ exact (real_add_SNo (R2_ycoord p) Hp1R (minus_SNo (R2_ycoord c)) Hmy). }
set dx2 := mul_SNo dx dx.
set dy2 := mul_SNo dy dy.
claim Hdx2R : dx2 :e R.
{ exact (real_mul_SNo dx HdxR dx HdxR). }
claim Hdy2R : dy2 :e R.
{ exact (real_mul_SNo dy HdyR dy HdyR). }
set sum := add_SNo dx2 dy2.
claim HsumR : sum :e R.
{ exact (real_add_SNo dx2 Hdx2R dy2 Hdy2R). }
claim HsumS : SNo sum.
{ exact (real_SNo sum HsumR). }
claim HdxS : SNo dx.
{ exact (real_SNo dx HdxR). }
claim HdyS : SNo dy.
{ exact (real_SNo dy HdyR). }
claim Hdx2S : SNo dx2.
{ exact (real_SNo dx2 Hdx2R). }
claim Hdy2S : SNo dy2.
{ exact (real_SNo dy2 Hdy2R). }
claim Hdx2nonneg : 0 <= dx2.
{ claim H0or : dx = 0 \/ 0 < (mul_SNo dx dx).
  { exact (SNo_zero_or_sqr_pos dx HdxS). }
  apply H0or.
  - assume Hdx0 : dx = 0.
    rewrite Hdx0.
    rewrite (mul_SNo_zeroL 0 SNo_0).
    exact (SNoLe_ref 0).
  - assume Hpos : 0 < (mul_SNo dx dx).
    exact (SNoLtLe 0 (mul_SNo dx dx) Hpos).
}
claim Hdy2nonneg : 0 <= dy2.
{ claim H0or : dy = 0 \/ 0 < (mul_SNo dy dy).
  { exact (SNo_zero_or_sqr_pos dy HdyS). }
  apply H0or.
  - assume Hdy0 : dy = 0.
    rewrite Hdy0.
    rewrite (mul_SNo_zeroL 0 SNo_0).
    exact (SNoLe_ref 0).
  - assume Hpos : 0 < (mul_SNo dy dy).
    exact (SNoLtLe 0 (mul_SNo dy dy) Hpos).
}
claim HsumNonneg : 0 <= sum.
{ rewrite <- (add_SNo_0L 0 SNo_0) at 1.
  exact (add_SNo_Le3 0 0 dx2 dy2 SNo_0 SNo_0 Hdx2S Hdy2S Hdx2nonneg Hdy2nonneg).
}
(** unfold distance_R2 and use the square root squaring lemma **)
claim Hdef : distance_R2 p c = sqrt_SNo_nonneg sum.
{ reflexivity. }
rewrite Hdef.
rewrite (sqrt_SNo_nonneg_sqr sum HsumS HsumNonneg).
(** unfold sum, dx2, dy2 **)
reflexivity.
Qed.

(** from 13 Example 4: distance from a point to itself is 0 **)
(** LATEX VERSION: d(p,p) = 0. **)
Theorem distance_R2_refl_0 : forall p:set, p :e EuclidPlane -> distance_R2 p p = 0.
let p. assume Hp.
claim Hp0R : R2_xcoord p :e R.
{ exact (EuclidPlane_xcoord_in_R p Hp). }
claim Hp1R : R2_ycoord p :e R.
{ exact (EuclidPlane_ycoord_in_R p Hp). }
claim Hp0S : SNo (R2_xcoord p).
{ exact (real_SNo (R2_xcoord p) Hp0R). }
claim Hp1S : SNo (R2_ycoord p).
{ exact (real_SNo (R2_ycoord p) Hp1R). }
claim Hdx : add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord p)) = 0.
{ exact (add_SNo_minus_SNo_rinv (R2_xcoord p) Hp0S). }
claim Hdy : add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord p)) = 0.
{ exact (add_SNo_minus_SNo_rinv (R2_ycoord p) Hp1S). }
claim Hdx2 : mul_SNo (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord p)))
                     (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord p))) = 0.
{ rewrite Hdx.
  exact (mul_SNo_zeroR 0 SNo_0). }
claim Hdy2 : mul_SNo (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord p)))
                     (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord p))) = 0.
{ rewrite Hdy.
  exact (mul_SNo_zeroR 0 SNo_0). }
claim Hsum : add_SNo (mul_SNo (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord p)))
                              (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord p))))
                     (mul_SNo (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord p)))
                              (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord p)))) = 0.
{ rewrite Hdx2.
  rewrite Hdy2.
  exact (add_SNo_0L 0 SNo_0). }
claim Hdef : distance_R2 p p =
  sqrt_SNo_nonneg
    (add_SNo
      (mul_SNo (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord p)))
              (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord p))))
      (mul_SNo (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord p)))
              (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord p))))).
{ reflexivity. }
rewrite Hdef.
rewrite Hsum.
rewrite sqrt_SNo_nonneg_0.
reflexivity.
Qed.

(** from 13 Example 4: symmetry of Euclidean distance in R^2 **)
(** LATEX VERSION: The distance function satisfies d(p,c)=d(c,p). **)
Theorem distance_R2_sym : forall p c:set, p :e EuclidPlane -> c :e EuclidPlane -> distance_R2 p c = distance_R2 c p.
let p c. assume Hp Hc.
(** Coordinate realness and SNo-ness **)
set xp := R2_xcoord p.
set yp := R2_ycoord p.
set xc := R2_xcoord c.
set yc := R2_ycoord c.
claim HxpR : xp :e R.
{ exact (EuclidPlane_xcoord_in_R p Hp). }
claim HypR : yp :e R.
{ exact (EuclidPlane_ycoord_in_R p Hp). }
claim HxcR : xc :e R.
{ exact (EuclidPlane_xcoord_in_R c Hc). }
claim HycR : yc :e R.
{ exact (EuclidPlane_ycoord_in_R c Hc). }
claim HxpS : SNo xp.
{ exact (real_SNo xp HxpR). }
claim HypS : SNo yp.
{ exact (real_SNo yp HypR). }
claim HxcS : SNo xc.
{ exact (real_SNo xc HxcR). }
claim HycS : SNo yc.
{ exact (real_SNo yc HycR). }
claim HmxpR : minus_SNo xp :e R.
{ exact (real_minus_SNo xp HxpR). }
claim HmypR : minus_SNo yp :e R.
{ exact (real_minus_SNo yp HypR). }
claim HmxcR : minus_SNo xc :e R.
{ exact (real_minus_SNo xc HxcR). }
claim HmycR : minus_SNo yc :e R.
{ exact (real_minus_SNo yc HycR). }
claim HmxpS : SNo (minus_SNo xp).
{ exact (real_SNo (minus_SNo xp) HmxpR). }
claim HmypS : SNo (minus_SNo yp).
{ exact (real_SNo (minus_SNo yp) HmypR). }
claim HmxcS : SNo (minus_SNo xc).
{ exact (real_SNo (minus_SNo xc) HmxcR). }
claim HmycS : SNo (minus_SNo yc).
{ exact (real_SNo (minus_SNo yc) HmycR). }

(** Show the swapped coordinate differences are negatives of the original ones **)
claim Hswapx : add_SNo xc (minus_SNo xp) = minus_SNo (add_SNo xp (minus_SNo xc)).
{ claim Hneg : minus_SNo (add_SNo xp (minus_SNo xc)) = add_SNo (minus_SNo xp) (minus_SNo (minus_SNo xc)).
  { exact (minus_add_SNo_distr xp (minus_SNo xc) HxpS HmxcS). }
  claim Hinv : minus_SNo (minus_SNo xc) = xc.
  { exact (minus_SNo_invol xc HxcS). }
  claim Hneg2 : minus_SNo (add_SNo xp (minus_SNo xc)) = add_SNo (minus_SNo xp) xc.
  { rewrite <- Hinv at 2.
    exact Hneg. }
  claim Hcom : add_SNo (minus_SNo xp) xc = add_SNo xc (minus_SNo xp).
  { exact (add_SNo_com (minus_SNo xp) xc HmxpS HxcS). }
  prove add_SNo xc (minus_SNo xp) = minus_SNo (add_SNo xp (minus_SNo xc)).
  rewrite <- Hcom.
  rewrite <- Hneg2.
  reflexivity. }

claim Hswapy : add_SNo yc (minus_SNo yp) = minus_SNo (add_SNo yp (minus_SNo yc)).
{ claim Hneg : minus_SNo (add_SNo yp (minus_SNo yc)) = add_SNo (minus_SNo yp) (minus_SNo (minus_SNo yc)).
  { exact (minus_add_SNo_distr yp (minus_SNo yc) HypS HmycS). }
  claim Hinv : minus_SNo (minus_SNo yc) = yc.
  { exact (minus_SNo_invol yc HycS). }
  claim Hneg2 : minus_SNo (add_SNo yp (minus_SNo yc)) = add_SNo (minus_SNo yp) yc.
  { rewrite <- Hinv at 2.
    exact Hneg. }
  claim Hcom : add_SNo (minus_SNo yp) yc = add_SNo yc (minus_SNo yp).
  { exact (add_SNo_com (minus_SNo yp) yc HmypS HycS). }
  prove add_SNo yc (minus_SNo yp) = minus_SNo (add_SNo yp (minus_SNo yc)).
  rewrite <- Hcom.
  rewrite <- Hneg2.
  reflexivity. }

(** SNo-ness of the original differences **)
claim HdxR : add_SNo xp (minus_SNo xc) :e R.
{ exact (real_add_SNo xp HxpR (minus_SNo xc) HmxcR). }
claim HdyR : add_SNo yp (minus_SNo yc) :e R.
{ exact (real_add_SNo yp HypR (minus_SNo yc) HmycR). }
claim HdxS : SNo (add_SNo xp (minus_SNo xc)).
{ exact (real_SNo (add_SNo xp (minus_SNo xc)) HdxR). }
claim HdyS : SNo (add_SNo yp (minus_SNo yc)).
{ exact (real_SNo (add_SNo yp (minus_SNo yc)) HdyR). }

(** Square terms are equal after swapping p and c **)
claim Hsqx :
  mul_SNo (add_SNo xc (minus_SNo xp)) (add_SNo xc (minus_SNo xp))
  = mul_SNo (add_SNo xp (minus_SNo xc)) (add_SNo xp (minus_SNo xc)).
{ rewrite Hswapx.
  rewrite (mul_SNo_minus_minus (add_SNo xp (minus_SNo xc)) (add_SNo xp (minus_SNo xc)) HdxS HdxS).
  reflexivity. }
claim Hsqy :
  mul_SNo (add_SNo yc (minus_SNo yp)) (add_SNo yc (minus_SNo yp))
  = mul_SNo (add_SNo yp (minus_SNo yc)) (add_SNo yp (minus_SNo yc)).
{ rewrite Hswapy.
  rewrite (mul_SNo_minus_minus (add_SNo yp (minus_SNo yc)) (add_SNo yp (minus_SNo yc)) HdyS HdyS).
  reflexivity. }

(** Expand both sides to the same sqrt expression **)
claim Hdefpc : distance_R2 p c =
  sqrt_SNo_nonneg
    (add_SNo
      (mul_SNo (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c)))
              (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c))))
      (mul_SNo (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c)))
              (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c))))).
{ reflexivity. }
claim Hdefcp : distance_R2 c p =
  sqrt_SNo_nonneg
    (add_SNo
      (mul_SNo (add_SNo (R2_xcoord c) (minus_SNo (R2_xcoord p)))
              (add_SNo (R2_xcoord c) (minus_SNo (R2_xcoord p))))
      (mul_SNo (add_SNo (R2_ycoord c) (minus_SNo (R2_ycoord p)))
              (add_SNo (R2_ycoord c) (minus_SNo (R2_ycoord p))))).
{ reflexivity. }
rewrite Hdefpc.
rewrite Hdefcp.
rewrite Hsqx.
rewrite Hsqy.
reflexivity.
Qed.

(** from 13 Example 4: circular region basis elements in EuclidPlane **)
(** LATEX VERSION: Circular regions: sets of the form {p in R^2 | d(p,c) < r} with c in R^2 and 0<r. **)
Definition circular_regions : set :=
  {U :e Power EuclidPlane |
     exists c:set, exists r:set,
       c :e EuclidPlane /\ Rlt 0 r /\
       U = {p :e EuclidPlane|Rlt (distance_R2 p c) r}}.

(** helper for 13 Example 4: introduce a circular region from center and radius **)
(** LATEX VERSION: If cR^2 and 0<r then {pR^2|d(p,c)<r} is a circular region. **)
Theorem circular_regionI : forall c r:set,
  c :e EuclidPlane ->
  Rlt 0 r ->
  {p :e EuclidPlane|Rlt (distance_R2 p c) r} :e circular_regions.
let c r. assume Hc Hr.
prove {p :e EuclidPlane|Rlt (distance_R2 p c) r} :e circular_regions.
claim HPow : {p :e EuclidPlane|Rlt (distance_R2 p c) r} :e Power EuclidPlane.
{ apply PowerI EuclidPlane {p :e EuclidPlane|Rlt (distance_R2 p c) r}.
  let p. assume Hp.
  exact (SepE1 EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 c) r) p Hp). }
claim HPred :
  exists c0:set, exists r0:set,
    c0 :e EuclidPlane /\ Rlt 0 r0 /\
    {p :e EuclidPlane|Rlt (distance_R2 p c) r} = {p :e EuclidPlane|Rlt (distance_R2 p c0) r0}.
{ witness c. witness r.
  apply andI.
  - apply andI.
    + exact Hc.
    + exact Hr.
  - reflexivity. }
exact (SepI (Power EuclidPlane)
            (fun U0 : set =>
              exists c0:set, exists r0:set,
                c0 :e EuclidPlane /\ Rlt 0 r0 /\
                U0 = {p :e EuclidPlane|Rlt (distance_R2 p c0) r0})
            {p :e EuclidPlane|Rlt (distance_R2 p c) r}
            HPow
            HPred).
Qed.

(** from 13 Example 4: rectangular region basis elements in EuclidPlane **)
(** LATEX VERSION: Rectangular regions: axis-parallel rectangles (a,b)x(c,d) in R^2 described by inequalities on coordinates. **)
Definition rectangular_regions : set :=
  {U :e Power EuclidPlane |
     exists a b c d:set, a :e R /\ b :e R /\ c :e R /\ d :e R /\ Rlt a b /\ Rlt c d /\
       U = {p :e EuclidPlane|
              exists x y:set, p = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d}}.

(** helper for 13 Example 4: introduce a rectangular region from endpoints **)
(** LATEX VERSION: If a<b and c<d then {(x,y)R^2|a<x<b and c<y<d} is a rectangular region. **)
Theorem rectangular_regionI : forall a b c d:set,
  a :e R -> b :e R -> c :e R -> d :e R ->
  Rlt a b -> Rlt c d ->
  {p :e EuclidPlane|exists x y:set, p = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d}
    :e rectangular_regions.
let a b c d. assume Ha Hb Hc Hd Hab Hcd.
prove {p :e EuclidPlane|exists x y:set, p = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d} :e rectangular_regions.
claim HPow :
  {p :e EuclidPlane|exists x y:set, p = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d}
    :e Power EuclidPlane.
{ apply PowerI EuclidPlane {p :e EuclidPlane|exists x y:set, p = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d}.
  let p. assume Hp.
  exact (SepE1 EuclidPlane
              (fun p0 : set => exists x y:set, p0 = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d)
              p
              Hp). }
claim HPred :
  exists a0 b0 c0 d0:set,
    a0 :e R /\ b0 :e R /\ c0 :e R /\ d0 :e R /\ Rlt a0 b0 /\ Rlt c0 d0 /\
      {p :e EuclidPlane|exists x y:set, p = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d}
        = {p :e EuclidPlane|exists x y:set, p = (x,y) /\ Rlt a0 x /\ Rlt x b0 /\ Rlt c0 y /\ Rlt y d0}.
{ witness a. witness b. witness c. witness d.
  apply andI.
  - (** a:eR /\ b:eR /\ c:eR /\ d:eR /\ Rlt a b /\ Rlt c d **)
    apply andI.
    + (** a:eR /\ b:eR /\ c:eR /\ d:eR /\ Rlt a b **)
      apply andI.
      * (** a:eR /\ b:eR /\ c:eR /\ d:eR **)
        apply andI.
        { (** a:eR /\ b:eR /\ c:eR **)
          apply andI.
          - (** a:eR /\ b:eR **)
            apply andI.
            + exact Ha.
            + exact Hb.
          - exact Hc.
        }
        { exact Hd. }
      * exact Hab.
    + exact Hcd.
  - reflexivity. }
exact (SepI (Power EuclidPlane)
            (fun U0 : set =>
              exists a0 b0 c0 d0:set, a0 :e R /\ b0 :e R /\ c0 :e R /\ d0 :e R /\ Rlt a0 b0 /\ Rlt c0 d0 /\
                U0 = {p :e EuclidPlane|exists x y:set, p = (x,y) /\ Rlt a0 x /\ Rlt x b0 /\ Rlt c0 y /\ Rlt y d0})
            {p :e EuclidPlane|exists x y:set, p = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d}
            HPow
            HPred).
Qed.

(** helper for 13 Example 4: two-ball refinement around a point **)
(** LATEX VERSION: If x lies in two open balls B(c1,r1) and B(c2,r2), then there is a smaller ball B(x,r3) contained in their intersection. **)
(** SUSPICIOUS DEFINITION: The intended proof needs a triangle inequality for distance_R2 and a monotonicity fact for sqrt; those are not yet available near this point, so this lemma is currently admitted. **)
Theorem ball_refine_two_balls :
  forall x c1 c2 r1 r2:set,
    x :e EuclidPlane ->
    c1 :e EuclidPlane ->
    c2 :e EuclidPlane ->
    Rlt 0 r1 ->
    Rlt 0 r2 ->
    Rlt (distance_R2 x c1) r1 ->
    Rlt (distance_R2 x c2) r2 ->
    exists r3:set,
      Rlt 0 r3 /\
      (forall p:set,
        p :e EuclidPlane ->
        Rlt (distance_R2 p x) r3 ->
        Rlt (distance_R2 p c1) r1 /\ Rlt (distance_R2 p c2) r2).
let x c1 c2 r1 r2.
assume Hx: x :e EuclidPlane.
assume Hc1: c1 :e EuclidPlane.
assume Hc2: c2 :e EuclidPlane.
assume Hr1: Rlt 0 r1.
assume Hr2: Rlt 0 r2.
assume Hx1: Rlt (distance_R2 x c1) r1.
assume Hx2: Rlt (distance_R2 x c2) r2.
admit.
Qed.

(** helper for 13 Example 4: rectangle inside a ball around a center **)
(** LATEX VERSION: Every point x in a ball B(c,r0) has a rectangular neighborhood contained in B(c,r0). **)
(** SUSPICIOUS DEFINITION: This also depends on estimates relating coordinate bounds to distance_R2, currently not derived. **)
Theorem rectangle_inside_ball :
  forall x c r0:set,
    x :e EuclidPlane ->
    c :e EuclidPlane ->
    Rlt 0 r0 ->
    Rlt (distance_R2 x c) r0 ->
    exists r :e rectangular_regions,
      x :e r /\ r c= {p :e EuclidPlane|Rlt (distance_R2 p c) r0}.
let x c r0.
assume Hx: x :e EuclidPlane.
assume Hc: c :e EuclidPlane.
assume Hr0: Rlt 0 r0.
assume Hxc: Rlt (distance_R2 x c) r0.
admit.
Qed.

(** helper for 13 Example 4: ball inside a rectangle around a point **)
(** LATEX VERSION: Every point x in a rectangle has a circular neighborhood contained in it. **)
(** SUSPICIOUS DEFINITION: This needs a bound abs(dx) <= distance_R2 and similar for dy, which is not yet proved here. **)
Theorem ball_inside_rectangle :
  forall b x:set,
    b :e rectangular_regions ->
    x :e EuclidPlane ->
    x :e b ->
    exists r3:set,
      Rlt 0 r3 /\
      (forall p:set, p :e EuclidPlane -> Rlt (distance_R2 p x) r3 -> p :e b).
let b x.
assume Hb: b :e rectangular_regions.
assume HxE: x :e EuclidPlane.
assume Hxb: x :e b.
admit.
Qed.

(** from 13 Example 4: circular regions form a basis on EuclidPlane **)
(** LATEX VERSION: The family of circular regions is a basis for a topology on R^2. **)
Theorem circular_regions_basis_plane : basis_on EuclidPlane circular_regions.
prove basis_on EuclidPlane circular_regions.
(** basis_on has three clauses: subset, cover, intersection refinement **)
prove circular_regions c= Power EuclidPlane
  /\ (forall x :e EuclidPlane, exists b :e circular_regions, x :e b)
  /\ (forall b1 :e circular_regions, forall b2 :e circular_regions, forall x:set,
        x :e b1 -> x :e b2 ->
        exists b3 :e circular_regions, x :e b3 /\ b3 c= b1 :/\: b2).
apply andI.
- apply andI.
  + let U. assume HU: U :e circular_regions.
    prove U :e Power EuclidPlane.
    exact (SepE1 (Power EuclidPlane)
                 (fun U0 : set => exists c:set, exists r:set,
                   c :e EuclidPlane /\ Rlt 0 r /\
                   U0 = {p :e EuclidPlane|Rlt (distance_R2 p c) r})
                 U
                 HU).
  + prove forall x :e EuclidPlane, exists b :e circular_regions, x :e b.
    let x. assume Hx.
    witness {p :e EuclidPlane|Rlt (distance_R2 p x) 1}.
    apply andI.
    * prove {p :e EuclidPlane|Rlt (distance_R2 p x) 1} :e circular_regions.
      exact (circular_regionI x 1 Hx Rlt_0_1).
    * claim Hlt : Rlt (distance_R2 x x) 1.
      { rewrite (distance_R2_refl_0 x Hx).
        claim HR : 0 :e R /\ 1 :e R /\ 0 < 1.
        { apply andI.
          - apply andI.
            + exact real_0.
            + exact real_1.
          - exact SNoLt_0_1. }
        exact HR. }
      exact (SepI EuclidPlane
                  (fun p0 : set => Rlt (distance_R2 p0 x) 1)
                  x
                  Hx
                  Hlt).
	- (** intersection refinement for circular regions **)
	  let b1. assume Hb1 : b1 :e circular_regions.
	  let b2. assume Hb2 : b2 :e circular_regions.
	  let x. assume Hx1 : x :e b1. assume Hx2 : x :e b2.
	  prove exists b3 :e circular_regions, x :e b3 /\ b3 c= b1 :/\: b2.
	  claim Hb1prop :
	    exists c1:set, exists r1:set,
	      c1 :e EuclidPlane /\ Rlt 0 r1 /\
	      b1 = {p :e EuclidPlane|Rlt (distance_R2 p c1) r1}.
	  { exact (SepE2 (Power EuclidPlane)
	                 (fun U0 : set => exists c:set, exists r:set,
	                   c :e EuclidPlane /\ Rlt 0 r /\
	                   U0 = {p :e EuclidPlane|Rlt (distance_R2 p c) r})
	                 b1
	                 Hb1). }
	  claim Hb2prop :
	    exists c2:set, exists r2:set,
	      c2 :e EuclidPlane /\ Rlt 0 r2 /\
	      b2 = {p :e EuclidPlane|Rlt (distance_R2 p c2) r2}.
	  { exact (SepE2 (Power EuclidPlane)
	                 (fun U0 : set => exists c:set, exists r:set,
	                   c :e EuclidPlane /\ Rlt 0 r /\
	                   U0 = {p :e EuclidPlane|Rlt (distance_R2 p c) r})
	                 b2
	                 Hb2). }
	  apply Hb1prop.
	  let c1. assume Hb1prop2.
	  apply Hb1prop2.
	  let r1. assume Hb1core.
	  apply Hb2prop.
	  let c2. assume Hb2prop2.
		  apply Hb2prop2.
		  let r2. assume Hb2core.
		  claim Hc1r1 : c1 :e EuclidPlane /\ Rlt 0 r1.
		  { exact (andEL (c1 :e EuclidPlane /\ Rlt 0 r1)
		                (b1 = {p :e EuclidPlane|Rlt (distance_R2 p c1) r1})
		                Hb1core). }
		  claim Hc1 : c1 :e EuclidPlane.
		  { exact (andEL (c1 :e EuclidPlane) (Rlt 0 r1) Hc1r1). }
		  claim Hr1 : Rlt 0 r1.
		  { exact (andER (c1 :e EuclidPlane) (Rlt 0 r1) Hc1r1). }
		  claim Hb1eq : b1 = {p :e EuclidPlane|Rlt (distance_R2 p c1) r1}.
		  { exact (andER (c1 :e EuclidPlane /\ Rlt 0 r1)
		                (b1 = {p :e EuclidPlane|Rlt (distance_R2 p c1) r1})
		                Hb1core). }
		  claim Hc2r2 : c2 :e EuclidPlane /\ Rlt 0 r2.
		  { exact (andEL (c2 :e EuclidPlane /\ Rlt 0 r2)
		                (b2 = {p :e EuclidPlane|Rlt (distance_R2 p c2) r2})
		                Hb2core). }
		  claim Hc2 : c2 :e EuclidPlane.
		  { exact (andEL (c2 :e EuclidPlane) (Rlt 0 r2) Hc2r2). }
		  claim Hr2 : Rlt 0 r2.
		  { exact (andER (c2 :e EuclidPlane) (Rlt 0 r2) Hc2r2). }
		  claim Hb2eq : b2 = {p :e EuclidPlane|Rlt (distance_R2 p c2) r2}.
		  { exact (andER (c2 :e EuclidPlane /\ Rlt 0 r2)
		                (b2 = {p :e EuclidPlane|Rlt (distance_R2 p c2) r2})
		                Hb2core). }
	  claim Hx1' : x :e {p :e EuclidPlane|Rlt (distance_R2 p c1) r1}.
	  { rewrite <- Hb1eq. exact Hx1. }
	  claim Hx2' : x :e {p :e EuclidPlane|Rlt (distance_R2 p c2) r2}.
	  { rewrite <- Hb2eq. exact Hx2. }
	  claim HxEuclid : x :e EuclidPlane.
	  { exact (SepE1 EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 c1) r1) x Hx1'). }
	  claim Hxball1 : Rlt (distance_R2 x c1) r1.
	  { exact (SepE2 EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 c1) r1) x Hx1'). }
	  claim Hxball2 : Rlt (distance_R2 x c2) r2.
	  { exact (SepE2 EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 c2) r2) x Hx2'). }

		  (** Metric refinement lemma for EuclidPlane balls around x **)
			  apply (ball_refine_two_balls x c1 c2 r1 r2 HxEuclid Hc1 Hc2 Hr1 Hr2 Hxball1 Hxball2).
			  let r3. assume Hrefine2.
	  claim Hr3 : Rlt 0 r3.
	  { exact (andEL (Rlt 0 r3)
	                (forall p:set, p :e EuclidPlane -> Rlt (distance_R2 p x) r3 -> Rlt (distance_R2 p c1) r1 /\ Rlt (distance_R2 p c2) r2)
	                Hrefine2). }
	  claim HrefineP :
	    forall p:set, p :e EuclidPlane -> Rlt (distance_R2 p x) r3 -> Rlt (distance_R2 p c1) r1 /\ Rlt (distance_R2 p c2) r2.
	  { exact (andER (Rlt 0 r3)
	                (forall p:set, p :e EuclidPlane -> Rlt (distance_R2 p x) r3 -> Rlt (distance_R2 p c1) r1 /\ Rlt (distance_R2 p c2) r2)
	                Hrefine2). }

		  set b3 := {p :e EuclidPlane|Rlt (distance_R2 p x) r3}.
		  witness b3.
		  apply andI.
		  - prove b3 :e circular_regions.
		    claim Hb3def : b3 = {p :e EuclidPlane|Rlt (distance_R2 p x) r3}.
		    { reflexivity. }
		    rewrite Hb3def.
		    exact (circular_regionI x r3 HxEuclid Hr3).
		  - apply andI.
	    + prove x :e b3.
	      claim Hdx : Rlt (distance_R2 x x) r3.
	      { rewrite (distance_R2_refl_0 x HxEuclid).
	        exact Hr3. }
	      exact (SepI EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 x) r3) x HxEuclid Hdx).
	    + prove b3 c= b1 :/\: b2.
	      let p. assume Hp3 : p :e b3.
	      prove p :e b1 :/\: b2.
	      claim HpE : p :e EuclidPlane.
	      { exact (SepE1 EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 x) r3) p Hp3). }
	      claim Hpball : Rlt (distance_R2 p x) r3.
	      { exact (SepE2 EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 x) r3) p Hp3). }
	      claim Hboth : Rlt (distance_R2 p c1) r1 /\ Rlt (distance_R2 p c2) r2.
	      { exact (HrefineP p HpE Hpball). }
	      claim Hpball1 : Rlt (distance_R2 p c1) r1.
	      { exact (andEL (Rlt (distance_R2 p c1) r1) (Rlt (distance_R2 p c2) r2) Hboth). }
	      claim Hpball2 : Rlt (distance_R2 p c2) r2.
	      { exact (andER (Rlt (distance_R2 p c1) r1) (Rlt (distance_R2 p c2) r2) Hboth). }
	      claim Hpb1 : p :e b1.
	      { rewrite Hb1eq.
	        exact (SepI EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 c1) r1) p HpE Hpball1). }
	      claim Hpb2 : p :e b2.
	      { rewrite Hb2eq.
	        exact (SepI EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 c2) r2) p HpE Hpball2). }
	      exact (binintersectI b1 b2 p Hpb1 Hpb2).
Qed.

(** from 13 Example 4: rectangular regions form a basis on EuclidPlane **)
(** LATEX VERSION: The family of axis-parallel open rectangles is a basis for a topology on R^2. **)
Theorem rectangular_regions_basis_plane : basis_on EuclidPlane rectangular_regions.
prove basis_on EuclidPlane rectangular_regions.
prove rectangular_regions c= Power EuclidPlane
  /\ (forall x :e EuclidPlane, exists b :e rectangular_regions, x :e b)
  /\ (forall b1 :e rectangular_regions, forall b2 :e rectangular_regions, forall x:set,
        x :e b1 -> x :e b2 ->
        exists b3 :e rectangular_regions, x :e b3 /\ b3 c= b1 :/\: b2).
apply andI.
- apply andI.
  + let U. assume HU: U :e rectangular_regions.
    prove U :e Power EuclidPlane.
    exact (SepE1 (Power EuclidPlane)
                 (fun U0 : set =>
                   exists a b c d:set, a :e R /\ b :e R /\ c :e R /\ d :e R /\ Rlt a b /\ Rlt c d /\
                     U0 = {p :e EuclidPlane|
                            exists x y:set, p = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d})
	                 U
	                 HU).
	  + prove forall p :e EuclidPlane, exists b :e rectangular_regions, p :e b.
	    let p. assume Hp : p :e EuclidPlane.
	    apply (Sigma_E R (fun _ : set => R) p Hp).
	    let x. assume Hx_pair.
	    apply Hx_pair.
	    assume HxR Hexy.
	    apply Hexy.
	    let y. assume Hy_pair.
	    apply Hy_pair.
	    assume HyR Hpeq.
	    set a := add_SNo x (minus_SNo 1).
	    set b := add_SNo x 1.
	    set c := add_SNo y (minus_SNo 1).
	    set d := add_SNo y 1.
	    set U := {p0 :e EuclidPlane|
	                exists x0:set, exists y0:set,
	                  p0 = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b /\ Rlt c y0 /\ Rlt y0 d}.
	    witness U.
		    apply andI.
		    - prove U :e rectangular_regions.
		      claim HxS : SNo x.
		      { exact (real_SNo x HxR). }
		      claim HyS : SNo y.
		      { exact (real_SNo y HyR). }
	      claim Hm1R : minus_SNo 1 :e R.
	      { exact (real_minus_SNo 1 real_1). }
	      claim Hm1S : SNo (minus_SNo 1).
	      { exact (real_SNo (minus_SNo 1) Hm1R). }
	      claim HaR : a :e R.
	      { exact (real_add_SNo x HxR (minus_SNo 1) Hm1R). }
	      claim HbR : b :e R.
	      { exact (real_add_SNo x HxR 1 real_1). }
	      claim HcR : c :e R.
	      { exact (real_add_SNo y HyR (minus_SNo 1) Hm1R). }
	      claim HdR : d :e R.
	      { exact (real_add_SNo y HyR 1 real_1). }
	      claim Hm1lt1 : minus_SNo 1 < 1.
	      { exact (SNoLt_tra (minus_SNo 1) 0 1 Hm1S SNo_0 SNo_1 minus_1_lt_0 SNoLt_0_1). }
	      claim Hablt : a < b.
	      { exact (add_SNo_Lt2 x (minus_SNo 1) 1 HxS Hm1S SNo_1 Hm1lt1). }
	      claim Hcdlt : c < d.
	      { exact (add_SNo_Lt2 y (minus_SNo 1) 1 HyS Hm1S SNo_1 Hm1lt1). }
		      claim HabRlt : Rlt a b.
		      { exact (RltI a b HaR HbR Hablt). }
		      claim HcdRlt : Rlt c d.
		      { exact (RltI c d HcR HdR Hcdlt). }
		      claim HUdef :
		        U = {p0 :e EuclidPlane|
		               exists x0:set, exists y0:set,
		                 p0 = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b /\ Rlt c y0 /\ Rlt y0 d}.
		      { reflexivity. }
		      rewrite HUdef.
		      exact (rectangular_regionI a b c d HaR HbR HcR HdR HabRlt HcdRlt).
	    - prove p :e U.
	      claim Hptup : p = (x,y).
	      { rewrite Hpeq. exact (tuple_pair x y). }
	      claim HaR : a :e R.
	      { exact (real_add_SNo x HxR (minus_SNo 1) (real_minus_SNo 1 real_1)). }
	      claim HbR : b :e R.
	      { exact (real_add_SNo x HxR 1 real_1). }
	      claim HcR : c :e R.
	      { exact (real_add_SNo y HyR (minus_SNo 1) (real_minus_SNo 1 real_1)). }
	      claim HdR : d :e R.
	      { exact (real_add_SNo y HyR 1 real_1). }
	      claim HxS : SNo x.
	      { exact (real_SNo x HxR). }
	      claim HyS : SNo y.
	      { exact (real_SNo y HyR). }
	      claim Hm1S : SNo (minus_SNo 1).
	      { exact (real_SNo (minus_SNo 1) (real_minus_SNo 1 real_1)). }
	      claim Hx0eq : add_SNo x 0 = x.
	      { exact (add_SNo_0R x HxS). }
	      claim Hy0eq : add_SNo y 0 = y.
	      { exact (add_SNo_0R y HyS). }
      claim Haxlt0 : add_SNo x (minus_SNo 1) < add_SNo x 0.
      { exact (add_SNo_Lt2 x (minus_SNo 1) 0 HxS Hm1S SNo_0 minus_1_lt_0). }
      claim Haxlt : a < x.
      { rewrite <- Hx0eq at 2. exact Haxlt0. }
      claim Hxltb0 : add_SNo x 0 < add_SNo x 1.
      { exact (add_SNo_Lt2 x 0 1 HxS SNo_0 SNo_1 SNoLt_0_1). }
      claim Hxltb : x < b.
      { rewrite <- Hx0eq at 1. exact Hxltb0. }
      claim Hcylt0 : add_SNo y (minus_SNo 1) < add_SNo y 0.
      { exact (add_SNo_Lt2 y (minus_SNo 1) 0 HyS Hm1S SNo_0 minus_1_lt_0). }
      claim Hcylt : c < y.
      { rewrite <- Hy0eq at 2. exact Hcylt0. }
      claim HyLtd0 : add_SNo y 0 < add_SNo y 1.
      { exact (add_SNo_Lt2 y 0 1 HyS SNo_0 SNo_1 SNoLt_0_1). }
      claim HyLtd : y < d.
      { rewrite <- Hy0eq at 1. exact HyLtd0. }
	      claim HaRltx : Rlt a x.
	      { exact (RltI a x HaR HxR Haxlt). }
	      claim HxRltb : Rlt x b.
	      { exact (RltI x b HxR HbR Hxltb). }
	      claim HcRlty : Rlt c y.
	      { exact (RltI c y HcR HyR Hcylt). }
	      claim HyRltd : Rlt y d.
	      { exact (RltI y d HyR HdR HyLtd). }
	      claim Hpred :
	        exists x0:set, exists y0:set,
	          p = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b /\ Rlt c y0 /\ Rlt y0 d.
	      { witness x. witness y.
	        claim H1 : p = (x,y) /\ Rlt a x.
	        { exact (andI (p = (x,y)) (Rlt a x) Hptup HaRltx). }
	        claim H12 : (p = (x,y) /\ Rlt a x) /\ Rlt x b.
	        { exact (andI (p = (x,y) /\ Rlt a x) (Rlt x b) H1 HxRltb). }
	        claim H123 : ((p = (x,y) /\ Rlt a x) /\ Rlt x b) /\ Rlt c y.
	        { exact (andI ((p = (x,y) /\ Rlt a x) /\ Rlt x b) (Rlt c y) H12 HcRlty). }
	        exact (andI (((p = (x,y) /\ Rlt a x) /\ Rlt x b) /\ Rlt c y)
	                   (Rlt y d)
	                   H123
	                   HyRltd). }
	      exact (SepI EuclidPlane
	                  (fun p1 : set =>
	                    exists x0:set, exists y0:set,
	                      p1 = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b /\ Rlt c y0 /\ Rlt y0 d)
	                  p
	                  Hp
	                  Hpred).
  - let b1. assume Hb1 : b1 :e rectangular_regions.
    let b2. assume Hb2 : b2 :e rectangular_regions.
    let p. assume Hp1 : p :e b1. assume Hp2 : p :e b2.
    prove exists b3 :e rectangular_regions, p :e b3 /\ b3 c= b1 :/\: b2.
    (** Unpack b1 as a rectangle with parameters a1,b1x,c1,d1 **)
    claim Hb1prop :
      exists a1:set, exists b1x:set, exists c1:set, exists d1:set,
        a1 :e R /\ b1x :e R /\ c1 :e R /\ d1 :e R /\ Rlt a1 b1x /\ Rlt c1 d1 /\
          b1 = {q :e EuclidPlane|
                  exists x0:set, exists y0:set,
                    q = (x0,y0) /\ Rlt a1 x0 /\ Rlt x0 b1x /\ Rlt c1 y0 /\ Rlt y0 d1}.
    { exact (SepE2 (Power EuclidPlane)
                   (fun U0 : set =>
                     exists a b c d:set, a :e R /\ b :e R /\ c :e R /\ d :e R /\ Rlt a b /\ Rlt c d /\
                       U0 = {p1 :e EuclidPlane|
                              exists x0:set, exists y0:set,
                                p1 = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b /\ Rlt c y0 /\ Rlt y0 d})
                   b1
                   Hb1). }
    apply Hb1prop.
    let a1. assume Hb1prop2.
    apply Hb1prop2.
    let b1x. assume Hb1prop3.
    apply Hb1prop3.
    let c1. assume Hb1prop4.
    apply Hb1prop4.
    let d1. assume Hb1core.
    (** Unpack b2 similarly **)
    claim Hb2prop :
      exists a2:set, exists b2x:set, exists c2:set, exists d2:set,
        a2 :e R /\ b2x :e R /\ c2 :e R /\ d2 :e R /\ Rlt a2 b2x /\ Rlt c2 d2 /\
          b2 = {q :e EuclidPlane|
                  exists x0:set, exists y0:set,
                    q = (x0,y0) /\ Rlt a2 x0 /\ Rlt x0 b2x /\ Rlt c2 y0 /\ Rlt y0 d2}.
    { exact (SepE2 (Power EuclidPlane)
                   (fun U0 : set =>
                     exists a b c d:set, a :e R /\ b :e R /\ c :e R /\ d :e R /\ Rlt a b /\ Rlt c d /\
                       U0 = {p1 :e EuclidPlane|
                              exists x0:set, exists y0:set,
                                p1 = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b /\ Rlt c y0 /\ Rlt y0 d})
                   b2
                   Hb2). }
    apply Hb2prop.
    let a2. assume Hb2prop2.
    apply Hb2prop2.
    let b2x. assume Hb2prop3.
    apply Hb2prop3.
    let c2. assume Hb2prop4.
    apply Hb2prop4.
    let d2. assume Hb2core.
    (** Extract equations and point coordinates from membership hypotheses Hp1 and Hp2 **)
    claim Hb1eq :
      b1 = {q :e EuclidPlane|
              exists x0:set, exists y0:set,
                q = (x0,y0) /\ Rlt a1 x0 /\ Rlt x0 b1x /\ Rlt c1 y0 /\ Rlt y0 d1}.
    { exact (andER (a1 :e R /\ b1x :e R /\ c1 :e R /\ d1 :e R /\ Rlt a1 b1x /\ Rlt c1 d1)
                  (b1 = {q :e EuclidPlane|
                          exists x0:set, exists y0:set,
                            q = (x0,y0) /\ Rlt a1 x0 /\ Rlt x0 b1x /\ Rlt c1 y0 /\ Rlt y0 d1})
                  Hb1core). }
    claim Hb2eq :
      b2 = {q :e EuclidPlane|
              exists x0:set, exists y0:set,
                q = (x0,y0) /\ Rlt a2 x0 /\ Rlt x0 b2x /\ Rlt c2 y0 /\ Rlt y0 d2}.
    { exact (andER (a2 :e R /\ b2x :e R /\ c2 :e R /\ d2 :e R /\ Rlt a2 b2x /\ Rlt c2 d2)
                  (b2 = {q :e EuclidPlane|
                          exists x0:set, exists y0:set,
                            q = (x0,y0) /\ Rlt a2 x0 /\ Rlt x0 b2x /\ Rlt c2 y0 /\ Rlt y0 d2})
                  Hb2core). }
    claim Hp1' : p :e {q :e EuclidPlane|
                        exists x0:set, exists y0:set,
                          q = (x0,y0) /\ Rlt a1 x0 /\ Rlt x0 b1x /\ Rlt c1 y0 /\ Rlt y0 d1}.
    { rewrite <- Hb1eq. exact Hp1. }
    claim Hp2' : p :e {q :e EuclidPlane|
                        exists x0:set, exists y0:set,
                          q = (x0,y0) /\ Rlt a2 x0 /\ Rlt x0 b2x /\ Rlt c2 y0 /\ Rlt y0 d2}.
    { rewrite <- Hb2eq. exact Hp2. }
    claim Hp1coords :
      exists x1:set, exists y1:set,
        p = (x1,y1) /\ Rlt a1 x1 /\ Rlt x1 b1x /\ Rlt c1 y1 /\ Rlt y1 d1.
    { exact (SepE2 EuclidPlane
                   (fun q : set =>
                     exists x0:set, exists y0:set,
                       q = (x0,y0) /\ Rlt a1 x0 /\ Rlt x0 b1x /\ Rlt c1 y0 /\ Rlt y0 d1)
                   p
                   Hp1'). }
    claim Hp2coords :
      exists x2:set, exists y2:set,
        p = (x2,y2) /\ Rlt a2 x2 /\ Rlt x2 b2x /\ Rlt c2 y2 /\ Rlt y2 d2.
    { exact (SepE2 EuclidPlane
                   (fun q : set =>
                     exists x0:set, exists y0:set,
                       q = (x0,y0) /\ Rlt a2 x0 /\ Rlt x0 b2x /\ Rlt c2 y0 /\ Rlt y0 d2)
                   p
                   Hp2'). }
    (** Reduce to the usual coordinate inequalities at p **)
    apply Hp1coords.
    let x1. assume Hp1coords2.
    apply Hp1coords2.
    let y1. assume Hp1ineq.
    apply Hp2coords.
    let x2. assume Hp2coords2.
    apply Hp2coords2.
    let y2. assume Hp2ineq.
    (** Identify x1=x2 and y1=y2 via tuple equality **)
    claim Hp_tup1 : p = (x1,y1).
    { claim H1 : (((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x) /\ Rlt c1 y1).
      { exact (andEL (((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x) /\ Rlt c1 y1)
                    (Rlt y1 d1)
                    Hp1ineq). }
      claim H2 : ((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x).
      { exact (andEL ((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x)
                    (Rlt c1 y1)
                    H1). }
      claim H3 : (p = (x1,y1) /\ Rlt a1 x1).
      { exact (andEL (p = (x1,y1) /\ Rlt a1 x1)
                    (Rlt x1 b1x)
                    H2). }
      exact (andEL (p = (x1,y1)) (Rlt a1 x1) H3). }
    claim Hp_tup2 : p = (x2,y2).
    { claim H1 : (((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x) /\ Rlt c2 y2).
      { exact (andEL (((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x) /\ Rlt c2 y2)
                    (Rlt y2 d2)
                    Hp2ineq). }
      claim H2 : ((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x).
      { exact (andEL ((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x)
                    (Rlt c2 y2)
                    H1). }
      claim H3 : (p = (x2,y2) /\ Rlt a2 x2).
      { exact (andEL (p = (x2,y2) /\ Rlt a2 x2)
                    (Rlt x2 b2x)
                    H2). }
      exact (andEL (p = (x2,y2)) (Rlt a2 x2) H3). }
    claim Heq12 : (x1,y1) = (x2,y2).
    { rewrite <- Hp_tup1. rewrite <- Hp_tup2. reflexivity. }
    claim Hcoords : x1 = x2 /\ y1 = y2.
    { exact (tuple_eq_coords_R2 x1 y1 x2 y2 Heq12). }
    (** At this point we have x1,y1 and inequalities from both rectangles; the remaining task is to pick new endpoints a3,b3,c3,d3 giving a rectangle around (x1,y1) contained in the intersection. **)
    claim Hx1eq : x1 = x2.
    { exact (andEL (x1 = x2) (y1 = y2) Hcoords). }
    claim Hy1eq : y1 = y2.
    { exact (andER (x1 = x2) (y1 = y2) Hcoords). }

    (** Extract coordinate inequalities for p from Hp1ineq and Hp2ineq **)
    claim Ha1x1 : Rlt a1 x1.
    { claim H1 : (((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x) /\ Rlt c1 y1).
      { exact (andEL (((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x) /\ Rlt c1 y1)
                    (Rlt y1 d1)
                    Hp1ineq). }
      claim H2 : ((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x).
      { exact (andEL ((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x)
                    (Rlt c1 y1)
                    H1). }
      claim H3 : (p = (x1,y1) /\ Rlt a1 x1).
      { exact (andEL (p = (x1,y1) /\ Rlt a1 x1)
                    (Rlt x1 b1x)
                    H2). }
      exact (andER (p = (x1,y1)) (Rlt a1 x1) H3). }
    claim Hx1b1 : Rlt x1 b1x.
    { claim H1 : (((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x) /\ Rlt c1 y1).
      { exact (andEL (((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x) /\ Rlt c1 y1)
                    (Rlt y1 d1)
                    Hp1ineq). }
      claim H2 : ((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x).
      { exact (andEL ((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x)
                    (Rlt c1 y1)
                    H1). }
      exact (andER (p = (x1,y1) /\ Rlt a1 x1) (Rlt x1 b1x) H2). }
    claim Hc1y1 : Rlt c1 y1.
    { claim H1 : (((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x) /\ Rlt c1 y1).
      { exact (andEL (((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x) /\ Rlt c1 y1)
                    (Rlt y1 d1)
                    Hp1ineq). }
      exact (andER ((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x) (Rlt c1 y1) H1). }
    claim Hy1d1 : Rlt y1 d1.
    { exact (andER (((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x) /\ Rlt c1 y1) (Rlt y1 d1) Hp1ineq). }

    claim Ha2x2 : Rlt a2 x2.
    { claim H1 : (((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x) /\ Rlt c2 y2).
      { exact (andEL (((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x) /\ Rlt c2 y2)
                    (Rlt y2 d2)
                    Hp2ineq). }
      claim H2 : ((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x).
      { exact (andEL ((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x)
                    (Rlt c2 y2)
                    H1). }
      claim H3 : (p = (x2,y2) /\ Rlt a2 x2).
      { exact (andEL (p = (x2,y2) /\ Rlt a2 x2)
                    (Rlt x2 b2x)
                    H2). }
      exact (andER (p = (x2,y2)) (Rlt a2 x2) H3). }
    claim Hx2b2 : Rlt x2 b2x.
    { claim H1 : (((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x) /\ Rlt c2 y2).
      { exact (andEL (((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x) /\ Rlt c2 y2)
                    (Rlt y2 d2)
                    Hp2ineq). }
      claim H2 : ((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x).
      { exact (andEL ((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x)
                    (Rlt c2 y2)
                    H1). }
      exact (andER (p = (x2,y2) /\ Rlt a2 x2) (Rlt x2 b2x) H2). }
    claim Hc2y2 : Rlt c2 y2.
    { claim H1 : (((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x) /\ Rlt c2 y2).
      { exact (andEL (((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x) /\ Rlt c2 y2)
                    (Rlt y2 d2)
                    Hp2ineq). }
      exact (andER ((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x) (Rlt c2 y2) H1). }
    claim Hy2d2 : Rlt y2 d2.
    { exact (andER (((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x) /\ Rlt c2 y2) (Rlt y2 d2) Hp2ineq). }

    (** Rewrite the second rectangle inequalities to x1,y1 **)
    claim Ha2x1 : Rlt a2 x1.
    { rewrite Hx1eq. exact Ha2x2. }
    claim Hx1b2 : Rlt x1 b2x.
    { rewrite Hx1eq at 1. exact Hx2b2. }
    claim Hc2y1 : Rlt c2 y1.
    { rewrite Hy1eq. exact Hc2y2. }
    claim Hy1d2 : Rlt y1 d2.
    { rewrite Hy1eq at 1. exact Hy2d2. }

    (** Define endpoints as max/min choices using if-then-else **)
    set a3 := if a1 < a2 then a2 else a1.
    set b3x := if b1x < b2x then b1x else b2x.
    set c3 := if c1 < c2 then c2 else c1.
    set d3 := if d1 < d2 then d1 else d2.

    claim Ha3def : a3 = if a1 < a2 then a2 else a1.
    { reflexivity. }
    claim Hb3def : b3x = if b1x < b2x then b1x else b2x.
    { reflexivity. }
    claim Hc3def : c3 = if c1 < c2 then c2 else c1.
    { reflexivity. }
    claim Hd3def : d3 = if d1 < d2 then d1 else d2.
    { reflexivity. }

    (** Extract endpoint realness once from Hb1core and Hb2core **)
    claim Hb1params :
      a1 :e R /\ b1x :e R /\ c1 :e R /\ d1 :e R /\ Rlt a1 b1x /\ Rlt c1 d1.
    { exact (andEL (a1 :e R /\ b1x :e R /\ c1 :e R /\ d1 :e R /\ Rlt a1 b1x /\ Rlt c1 d1)
                  (b1 = {q :e EuclidPlane|
                          exists x0:set, exists y0:set,
                            q = (x0,y0) /\ Rlt a1 x0 /\ Rlt x0 b1x /\ Rlt c1 y0 /\ Rlt y0 d1})
                  Hb1core). }
    claim Hb2params :
      a2 :e R /\ b2x :e R /\ c2 :e R /\ d2 :e R /\ Rlt a2 b2x /\ Rlt c2 d2.
    { exact (andEL (a2 :e R /\ b2x :e R /\ c2 :e R /\ d2 :e R /\ Rlt a2 b2x /\ Rlt c2 d2)
                  (b2 = {q :e EuclidPlane|
                          exists x0:set, exists y0:set,
                            q = (x0,y0) /\ Rlt a2 x0 /\ Rlt x0 b2x /\ Rlt c2 y0 /\ Rlt y0 d2})
                  Hb2core). }

    claim Hb1left : ((((a1 :e R /\ b1x :e R) /\ c1 :e R) /\ d1 :e R) /\ Rlt a1 b1x).
    { exact (andEL ((((a1 :e R /\ b1x :e R) /\ c1 :e R) /\ d1 :e R) /\ Rlt a1 b1x)
                  (Rlt c1 d1)
                  Hb1params). }
    claim Hb2left : ((((a2 :e R /\ b2x :e R) /\ c2 :e R) /\ d2 :e R) /\ Rlt a2 b2x).
    { exact (andEL ((((a2 :e R /\ b2x :e R) /\ c2 :e R) /\ d2 :e R) /\ Rlt a2 b2x)
                  (Rlt c2 d2)
                  Hb2params). }

    claim Ha1b1x_c1_d1 : (((a1 :e R /\ b1x :e R) /\ c1 :e R) /\ d1 :e R).
    { exact (andEL (((a1 :e R /\ b1x :e R) /\ c1 :e R) /\ d1 :e R)
                  (Rlt a1 b1x)
                  Hb1left). }
    claim Ha2b2x_c2_d2 : (((a2 :e R /\ b2x :e R) /\ c2 :e R) /\ d2 :e R).
    { exact (andEL (((a2 :e R /\ b2x :e R) /\ c2 :e R) /\ d2 :e R)
                  (Rlt a2 b2x)
                  Hb2left). }

    claim Ha1b1x_c1 : ((a1 :e R /\ b1x :e R) /\ c1 :e R).
    { exact (andEL ((a1 :e R /\ b1x :e R) /\ c1 :e R)
                  (d1 :e R)
                  Ha1b1x_c1_d1). }
    claim Ha2b2x_c2 : ((a2 :e R /\ b2x :e R) /\ c2 :e R).
    { exact (andEL ((a2 :e R /\ b2x :e R) /\ c2 :e R)
                  (d2 :e R)
                  Ha2b2x_c2_d2). }

    claim Ha1b1x : a1 :e R /\ b1x :e R.
    { exact (andEL (a1 :e R /\ b1x :e R) (c1 :e R) Ha1b1x_c1). }
    claim Ha2b2x : a2 :e R /\ b2x :e R.
    { exact (andEL (a2 :e R /\ b2x :e R) (c2 :e R) Ha2b2x_c2). }

    claim Ha1R : a1 :e R.
    { exact (andEL (a1 :e R) (b1x :e R) Ha1b1x). }
    claim Hb1xR : b1x :e R.
    { exact (andER (a1 :e R) (b1x :e R) Ha1b1x). }
    claim Hc1R : c1 :e R.
    { exact (andER (a1 :e R /\ b1x :e R) (c1 :e R) Ha1b1x_c1). }
    claim Hd1R : d1 :e R.
    { exact (andER ((a1 :e R /\ b1x :e R) /\ c1 :e R) (d1 :e R) Ha1b1x_c1_d1). }

    claim Ha2R : a2 :e R.
    { exact (andEL (a2 :e R) (b2x :e R) Ha2b2x). }
    claim Hb2xR : b2x :e R.
    { exact (andER (a2 :e R) (b2x :e R) Ha2b2x). }
    claim Hc2R : c2 :e R.
    { exact (andER (a2 :e R /\ b2x :e R) (c2 :e R) Ha2b2x_c2). }
    claim Hd2R : d2 :e R.
    { exact (andER ((a2 :e R /\ b2x :e R) /\ c2 :e R) (d2 :e R) Ha2b2x_c2_d2). }

    (** Show the chosen endpoints are real numbers **)
    claim Ha3R : a3 :e R.
    { rewrite Ha3def.
      apply (xm (a1 < a2)).
      - assume Hlt. rewrite (If_i_1 (a1 < a2) a2 a1 Hlt). exact Ha2R.
      - assume Hnlt. rewrite (If_i_0 (a1 < a2) a2 a1 Hnlt). exact Ha1R. }
    claim Hb3xR : b3x :e R.
    { rewrite Hb3def.
      apply (xm (b1x < b2x)).
      - assume Hlt. rewrite (If_i_1 (b1x < b2x) b1x b2x Hlt). exact Hb1xR.
      - assume Hnlt. rewrite (If_i_0 (b1x < b2x) b1x b2x Hnlt). exact Hb2xR. }
    claim Hc3R : c3 :e R.
    { rewrite Hc3def.
      apply (xm (c1 < c2)).
      - assume Hlt. rewrite (If_i_1 (c1 < c2) c2 c1 Hlt). exact Hc2R.
      - assume Hnlt. rewrite (If_i_0 (c1 < c2) c2 c1 Hnlt). exact Hc1R. }
    claim Hd3R : d3 :e R.
    { rewrite Hd3def.
      apply (xm (d1 < d2)).
      - assume Hlt. rewrite (If_i_1 (d1 < d2) d1 d2 Hlt). exact Hd1R.
      - assume Hnlt. rewrite (If_i_0 (d1 < d2) d1 d2 Hnlt). exact Hd2R. }

    (** Show x1,y1 are between the chosen endpoints **)
    claim Hax3 : Rlt a3 x1.
    { rewrite Ha3def.
      apply (xm (a1 < a2)).
      - assume Hlt. rewrite (If_i_1 (a1 < a2) a2 a1 Hlt). exact Ha2x1.
      - assume Hnlt. rewrite (If_i_0 (a1 < a2) a2 a1 Hnlt). exact Ha1x1. }
    claim Hxb3 : Rlt x1 b3x.
    { rewrite Hb3def.
      apply (xm (b1x < b2x)).
      - assume Hlt. rewrite (If_i_1 (b1x < b2x) b1x b2x Hlt). exact Hx1b1.
      - assume Hnlt. rewrite (If_i_0 (b1x < b2x) b1x b2x Hnlt). exact Hx1b2. }
    claim Hcy3 : Rlt c3 y1.
    { rewrite Hc3def.
      apply (xm (c1 < c2)).
      - assume Hlt. rewrite (If_i_1 (c1 < c2) c2 c1 Hlt). exact Hc2y1.
      - assume Hnlt. rewrite (If_i_0 (c1 < c2) c2 c1 Hnlt). exact Hc1y1. }
    claim Hyd3 : Rlt y1 d3.
    { rewrite Hd3def.
      apply (xm (d1 < d2)).
      - assume Hlt. rewrite (If_i_1 (d1 < d2) d1 d2 Hlt). exact Hy1d1.
      - assume Hnlt. rewrite (If_i_0 (d1 < d2) d1 d2 Hnlt). exact Hy1d2. }

    (** Define the rectangle b3rect with these endpoints **)
    set b3rect := {q :e EuclidPlane|
                     exists x0:set, exists y0:set,
                       q = (x0,y0) /\ Rlt a3 x0 /\ Rlt x0 b3x /\ Rlt c3 y0 /\ Rlt y0 d3}.

    witness b3rect.
    apply andI.
    - (** b3rect in rectangular_regions **)
      claim Hb3pow : b3rect :e Power EuclidPlane.
      { apply PowerI EuclidPlane b3rect.
        let q. assume Hq : q :e b3rect.
        exact (SepE1 EuclidPlane
                     (fun q0 : set =>
                       exists x0:set, exists y0:set,
                         q0 = (x0,y0) /\ Rlt a3 x0 /\ Rlt x0 b3x /\ Rlt c3 y0 /\ Rlt y0 d3)
                     q
                     Hq). }
      claim Hab3 : Rlt a3 b3x.
      { exact (Rlt_tra a3 x1 b3x Hax3 Hxb3). }
      claim Hcd3 : Rlt c3 d3.
      { exact (Rlt_tra c3 y1 d3 Hcy3 Hyd3). }
      claim Hprop :
        exists a0:set, exists b0:set, exists c0:set, exists d0:set,
          a0 :e R /\ b0 :e R /\ c0 :e R /\ d0 :e R /\ Rlt a0 b0 /\ Rlt c0 d0 /\
            b3rect = {p1 :e EuclidPlane|
                       exists x0:set, exists y0:set,
                         p1 = (x0,y0) /\ Rlt a0 x0 /\ Rlt x0 b0 /\ Rlt c0 y0 /\ Rlt y0 d0}.
      { witness a3. witness b3x. witness c3. witness d3.
        claim H1 : a3 :e R /\ b3x :e R.
        { apply andI.
          - exact Ha3R.
          - exact Hb3xR. }
        claim H12 : (a3 :e R /\ b3x :e R) /\ c3 :e R.
        { exact (andI (a3 :e R /\ b3x :e R) (c3 :e R) H1 Hc3R). }
        claim H123 : ((a3 :e R /\ b3x :e R) /\ c3 :e R) /\ d3 :e R.
        { exact (andI ((a3 :e R /\ b3x :e R) /\ c3 :e R) (d3 :e R) H12 Hd3R). }
        claim H1234 : (((a3 :e R /\ b3x :e R) /\ c3 :e R) /\ d3 :e R) /\ Rlt a3 b3x.
        { exact (andI (((a3 :e R /\ b3x :e R) /\ c3 :e R) /\ d3 :e R) (Rlt a3 b3x) H123 Hab3). }
        claim H12345 : ((((a3 :e R /\ b3x :e R) /\ c3 :e R) /\ d3 :e R) /\ Rlt a3 b3x) /\ Rlt c3 d3.
        { exact (andI ((((a3 :e R /\ b3x :e R) /\ c3 :e R) /\ d3 :e R) /\ Rlt a3 b3x) (Rlt c3 d3) H1234 Hcd3). }
        apply andI.
        - exact H12345.
        - reflexivity. }
      exact (SepI (Power EuclidPlane)
                  (fun U0 : set =>
                    exists a b c d:set, a :e R /\ b :e R /\ c :e R /\ d :e R /\ Rlt a b /\ Rlt c d /\
                      U0 = {p1 :e EuclidPlane|
                             exists x0:set, exists y0:set,
                               p1 = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b /\ Rlt c y0 /\ Rlt y0 d})
                  b3rect
                  Hb3pow
                  Hprop).
    - apply andI.
      + (** p is in b3rect **)
        claim HpEuclid : p :e EuclidPlane.
        { exact (SepE1 EuclidPlane
                     (fun q : set =>
                       exists x0:set, exists y0:set,
                         q = (x0,y0) /\ Rlt a1 x0 /\ Rlt x0 b1x /\ Rlt c1 y0 /\ Rlt y0 d1)
                     p
                     Hp1'). }
        claim Hpred :
          exists x0:set, exists y0:set,
            p = (x0,y0) /\ Rlt a3 x0 /\ Rlt x0 b3x /\ Rlt c3 y0 /\ Rlt y0 d3.
        { witness x1. witness y1.
          claim H1 : p = (x1,y1) /\ Rlt a3 x1.
          { exact (andI (p = (x1,y1)) (Rlt a3 x1) Hp_tup1 Hax3). }
          claim H12 : (p = (x1,y1) /\ Rlt a3 x1) /\ Rlt x1 b3x.
          { exact (andI (p = (x1,y1) /\ Rlt a3 x1) (Rlt x1 b3x) H1 Hxb3). }
          claim H123 : ((p = (x1,y1) /\ Rlt a3 x1) /\ Rlt x1 b3x) /\ Rlt c3 y1.
          { exact (andI ((p = (x1,y1) /\ Rlt a3 x1) /\ Rlt x1 b3x) (Rlt c3 y1) H12 Hcy3). }
          exact (andI (((p = (x1,y1) /\ Rlt a3 x1) /\ Rlt x1 b3x) /\ Rlt c3 y1) (Rlt y1 d3) H123 Hyd3). }
        exact (SepI EuclidPlane
                    (fun q : set =>
                      exists x0:set, exists y0:set,
                        q = (x0,y0) /\ Rlt a3 x0 /\ Rlt x0 b3x /\ Rlt c3 y0 /\ Rlt y0 d3)
                    p
                    HpEuclid
                    Hpred).
      + (** b3rect is contained in b1  b2 **)
        let q. assume Hq : q :e b3rect.
        prove q :e b1 :/\: b2.
        claim HqEuclid : q :e EuclidPlane.
        { exact (SepE1 EuclidPlane
                     (fun q0 : set =>
                       exists x0:set, exists y0:set,
                         q0 = (x0,y0) /\ Rlt a3 x0 /\ Rlt x0 b3x /\ Rlt c3 y0 /\ Rlt y0 d3)
                     q
                     Hq). }
        claim Hqcoords :
          exists xq:set, exists yq:set,
            q = (xq,yq) /\ Rlt a3 xq /\ Rlt xq b3x /\ Rlt c3 yq /\ Rlt yq d3.
        { exact (SepE2 EuclidPlane
                       (fun q0 : set =>
                         exists x0:set, exists y0:set,
                           q0 = (x0,y0) /\ Rlt a3 x0 /\ Rlt x0 b3x /\ Rlt c3 y0 /\ Rlt y0 d3)
                       q
                       Hq). }
        apply Hqcoords.
        let xq. assume Hqcoords2.
        apply Hqcoords2.
        let yq. assume Hqineq.
        claim Hqtup : q = (xq,yq).
        { claim H1 : (((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x) /\ Rlt c3 yq).
          { exact (andEL (((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x) /\ Rlt c3 yq)
                        (Rlt yq d3)
                        Hqineq). }
          claim H2 : ((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x).
          { exact (andEL ((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x)
                        (Rlt c3 yq)
                        H1). }
          claim H3 : (q = (xq,yq) /\ Rlt a3 xq).
          { exact (andEL (q = (xq,yq) /\ Rlt a3 xq)
                        (Rlt xq b3x)
                        H2). }
          exact (andEL (q = (xq,yq)) (Rlt a3 xq) H3). }
        claim Ha3xq : Rlt a3 xq.
        { claim H1 : (((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x) /\ Rlt c3 yq).
          { exact (andEL (((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x) /\ Rlt c3 yq)
                        (Rlt yq d3)
                        Hqineq). }
          claim H2 : ((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x).
          { exact (andEL ((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x)
                        (Rlt c3 yq)
                        H1). }
          claim H3 : (q = (xq,yq) /\ Rlt a3 xq).
          { exact (andEL (q = (xq,yq) /\ Rlt a3 xq)
                        (Rlt xq b3x)
                        H2). }
          exact (andER (q = (xq,yq)) (Rlt a3 xq) H3). }
        claim Hxqb3 : Rlt xq b3x.
        { claim H1 : (((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x) /\ Rlt c3 yq).
          { exact (andEL (((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x) /\ Rlt c3 yq)
                        (Rlt yq d3)
                        Hqineq). }
          claim H2 : ((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x).
          { exact (andEL ((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x)
                        (Rlt c3 yq)
                        H1). }
          exact (andER (q = (xq,yq) /\ Rlt a3 xq) (Rlt xq b3x) H2). }
        claim Hc3yq : Rlt c3 yq.
        { claim H1 : (((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x) /\ Rlt c3 yq).
          { exact (andEL (((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x) /\ Rlt c3 yq)
                        (Rlt yq d3)
                        Hqineq). }
          exact (andER ((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x) (Rlt c3 yq) H1). }
        claim Hyqd3 : Rlt yq d3.
        { exact (andER (((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x) /\ Rlt c3 yq) (Rlt yq d3) Hqineq). }

        (** Derive inequalities needed for membership in b1 and b2 **)
        claim Haxq : Rlt a1 xq /\ Rlt a2 xq.
        { claim HxqR : xq :e R.
          { exact (RltE_right a3 xq Ha3xq). }
          claim Ha1S : SNo a1.
          { exact (real_SNo a1 Ha1R). }
          claim Ha2S : SNo a2.
          { exact (real_SNo a2 Ha2R). }
          claim Ha3xq_if : Rlt (if a1 < a2 then a2 else a1) xq.
          { rewrite <- Ha3def. exact Ha3xq. }
          apply (SNoLt_trichotomy_or_impred a1 a2 Ha1S Ha2S (Rlt a1 xq /\ Rlt a2 xq)).
          - assume Ha1lt : a1 < a2.
            claim Ha1a2 : Rlt a1 a2.
            { exact (RltI a1 a2 Ha1R Ha2R Ha1lt). }
            claim Ha2xq : Rlt a2 xq.
            { rewrite <- (If_i_1 (a1 < a2) a2 a1 Ha1lt). exact Ha3xq_if. }
            claim Ha1xq : Rlt a1 xq.
            { exact (Rlt_tra a1 a2 xq Ha1a2 Ha2xq). }
            apply andI.
            - exact Ha1xq.
            - exact Ha2xq.
          - assume Haeq : a1 = a2.
            claim Hnlt : ~(a1 < a2).
            { assume Hlt.
              claim Hlt' : a1 < a1.
              { rewrite Haeq at 2. exact Hlt. }
              exact ((SNoLt_irref a1) Hlt'). }
            claim Ha1xq : Rlt a1 xq.
            { rewrite <- (If_i_0 (a1 < a2) a2 a1 Hnlt). exact Ha3xq_if. }
            claim Ha2xq : Rlt a2 xq.
            { rewrite <- Haeq. exact Ha1xq. }
            apply andI.
            - exact Ha1xq.
            - exact Ha2xq.
          - assume Ha2lt : a2 < a1.
            claim Hnlt : ~(a1 < a2).
            { assume Hlt.
              claim Ha2S' : SNo a2.
              { exact Ha2S. }
              claim Ha1S' : SNo a1.
              { exact Ha1S. }
              claim Ha2lt2 : a2 < a2.
              { exact (SNoLt_tra a2 a1 a2 Ha2S' Ha1S' Ha2S' Ha2lt Hlt). }
              exact ((SNoLt_irref a2) Ha2lt2). }
            claim Ha2a1 : Rlt a2 a1.
            { exact (RltI a2 a1 Ha2R Ha1R Ha2lt). }
            claim Ha1xq : Rlt a1 xq.
            { rewrite <- (If_i_0 (a1 < a2) a2 a1 Hnlt). exact Ha3xq_if. }
            claim Ha2xq : Rlt a2 xq.
            { exact (Rlt_tra a2 a1 xq Ha2a1 Ha1xq). }
            apply andI.
            - exact Ha1xq.
            - exact Ha2xq. }

        claim Hxbq : Rlt xq b1x /\ Rlt xq b2x.
        { claim HxqR : xq :e R.
          { exact (RltE_left xq b3x Hxqb3). }
          claim Hb1S : SNo b1x.
          { exact (real_SNo b1x Hb1xR). }
          claim Hb2S : SNo b2x.
          { exact (real_SNo b2x Hb2xR). }
          claim HxqS : SNo xq.
          { exact (real_SNo xq HxqR). }
          claim Hxqb3_if : Rlt xq (if b1x < b2x then b1x else b2x).
          { rewrite <- Hb3def. exact Hxqb3. }
          apply (SNoLt_trichotomy_or_impred b1x b2x Hb1S Hb2S (Rlt xq b1x /\ Rlt xq b2x)).
          - assume Hb1lt : b1x < b2x.
            claim Hb1b2 : Rlt b1x b2x.
            { exact (RltI b1x b2x Hb1xR Hb2xR Hb1lt). }
            claim Hxqb1 : Rlt xq b1x.
            { rewrite <- (If_i_1 (b1x < b2x) b1x b2x Hb1lt). exact Hxqb3_if. }
            claim Hxqb2 : Rlt xq b2x.
            { exact (Rlt_tra xq b1x b2x Hxqb1 Hb1b2). }
            apply andI.
            - exact Hxqb1.
            - exact Hxqb2.
          - assume Hbeq : b1x = b2x.
            claim Hnlt : ~(b1x < b2x).
            { assume Hlt.
              claim Hlt' : b1x < b1x.
              { rewrite Hbeq at 2. exact Hlt. }
              exact ((SNoLt_irref b1x) Hlt'). }
            claim Hxqb2 : Rlt xq b2x.
            { rewrite <- (If_i_0 (b1x < b2x) b1x b2x Hnlt). exact Hxqb3_if. }
            claim Hxqb1 : Rlt xq b1x.
            { rewrite Hbeq. exact Hxqb2. }
            apply andI.
            - exact Hxqb1.
            - exact Hxqb2.
          - assume Hb2lt : b2x < b1x.
            claim Hnlt : ~(b1x < b2x).
            { assume Hlt.
              claim Hb2lt2 : b2x < b2x.
              { exact (SNoLt_tra b2x b1x b2x Hb2S Hb1S Hb2S Hb2lt Hlt). }
              exact ((SNoLt_irref b2x) Hb2lt2). }
            claim Hb2b1 : Rlt b2x b1x.
            { exact (RltI b2x b1x Hb2xR Hb1xR Hb2lt). }
            claim Hxqb2 : Rlt xq b2x.
            { rewrite <- (If_i_0 (b1x < b2x) b1x b2x Hnlt). exact Hxqb3_if. }
            claim Hxqb1 : Rlt xq b1x.
            { exact (Rlt_tra xq b2x b1x Hxqb2 Hb2b1). }
            apply andI.
            - exact Hxqb1.
            - exact Hxqb2. }

        claim Hcyq : Rlt c1 yq /\ Rlt c2 yq.
        { claim HyqR : yq :e R.
          { exact (RltE_right c3 yq Hc3yq). }
          claim Hc1S : SNo c1.
          { exact (real_SNo c1 Hc1R). }
          claim Hc2S : SNo c2.
          { exact (real_SNo c2 Hc2R). }
          claim Hc3yq_if : Rlt (if c1 < c2 then c2 else c1) yq.
          { rewrite <- Hc3def. exact Hc3yq. }
          apply (SNoLt_trichotomy_or_impred c1 c2 Hc1S Hc2S (Rlt c1 yq /\ Rlt c2 yq)).
          - assume Hc1lt : c1 < c2.
            claim Hc1c2 : Rlt c1 c2.
            { exact (RltI c1 c2 Hc1R Hc2R Hc1lt). }
            claim Hc2yq : Rlt c2 yq.
            { rewrite <- (If_i_1 (c1 < c2) c2 c1 Hc1lt). exact Hc3yq_if. }
            claim Hc1yq : Rlt c1 yq.
            { exact (Rlt_tra c1 c2 yq Hc1c2 Hc2yq). }
            apply andI.
            - exact Hc1yq.
            - exact Hc2yq.
          - assume Hceq : c1 = c2.
            claim Hnlt : ~(c1 < c2).
            { assume Hlt.
              claim Hlt' : c1 < c1.
              { rewrite Hceq at 2. exact Hlt. }
              exact ((SNoLt_irref c1) Hlt'). }
            claim Hc1yq : Rlt c1 yq.
            { rewrite <- (If_i_0 (c1 < c2) c2 c1 Hnlt). exact Hc3yq_if. }
            claim Hc2yq : Rlt c2 yq.
            { rewrite <- Hceq. exact Hc1yq. }
            apply andI.
            - exact Hc1yq.
            - exact Hc2yq.
          - assume Hc2lt : c2 < c1.
            claim Hnlt : ~(c1 < c2).
            { assume Hlt.
              claim Hc2lt2 : c2 < c2.
              { exact (SNoLt_tra c2 c1 c2 Hc2S Hc1S Hc2S Hc2lt Hlt). }
              exact ((SNoLt_irref c2) Hc2lt2). }
            claim Hc2c1 : Rlt c2 c1.
            { exact (RltI c2 c1 Hc2R Hc1R Hc2lt). }
            claim Hc1yq : Rlt c1 yq.
            { rewrite <- (If_i_0 (c1 < c2) c2 c1 Hnlt). exact Hc3yq_if. }
            claim Hc2yq : Rlt c2 yq.
            { exact (Rlt_tra c2 c1 yq Hc2c1 Hc1yq). }
            apply andI.
            - exact Hc1yq.
            - exact Hc2yq. }

        claim Hydq : Rlt yq d1 /\ Rlt yq d2.
        { claim HyqR : yq :e R.
          { exact (RltE_left yq d3 Hyqd3). }
          claim Hd1S : SNo d1.
          { exact (real_SNo d1 Hd1R). }
          claim Hd2S : SNo d2.
          { exact (real_SNo d2 Hd2R). }
          claim HyqS : SNo yq.
          { exact (real_SNo yq HyqR). }
          claim Hyqd3_if : Rlt yq (if d1 < d2 then d1 else d2).
          { rewrite <- Hd3def. exact Hyqd3. }
          apply (SNoLt_trichotomy_or_impred d1 d2 Hd1S Hd2S (Rlt yq d1 /\ Rlt yq d2)).
          - assume Hd1lt : d1 < d2.
            claim Hd1d2 : Rlt d1 d2.
            { exact (RltI d1 d2 Hd1R Hd2R Hd1lt). }
            claim Hyqd1 : Rlt yq d1.
            { rewrite <- (If_i_1 (d1 < d2) d1 d2 Hd1lt). exact Hyqd3_if. }
            claim Hyqd2 : Rlt yq d2.
            { exact (Rlt_tra yq d1 d2 Hyqd1 Hd1d2). }
            apply andI.
            - exact Hyqd1.
            - exact Hyqd2.
          - assume Hdeq : d1 = d2.
            claim Hnlt : ~(d1 < d2).
            { assume Hlt.
              claim Hlt' : d1 < d1.
              { rewrite Hdeq at 2. exact Hlt. }
              exact ((SNoLt_irref d1) Hlt'). }
            claim Hyqd2 : Rlt yq d2.
            { rewrite <- (If_i_0 (d1 < d2) d1 d2 Hnlt). exact Hyqd3_if. }
            claim Hyqd1 : Rlt yq d1.
            { rewrite Hdeq. exact Hyqd2. }
            apply andI.
            - exact Hyqd1.
            - exact Hyqd2.
          - assume Hd2lt : d2 < d1.
            claim Hnlt : ~(d1 < d2).
            { assume Hlt.
              claim Hd2lt2 : d2 < d2.
              { exact (SNoLt_tra d2 d1 d2 Hd2S Hd1S Hd2S Hd2lt Hlt). }
              exact ((SNoLt_irref d2) Hd2lt2). }
            claim Hd2d1 : Rlt d2 d1.
            { exact (RltI d2 d1 Hd2R Hd1R Hd2lt). }
            claim Hyqd2 : Rlt yq d2.
            { rewrite <- (If_i_0 (d1 < d2) d1 d2 Hnlt). exact Hyqd3_if. }
            claim Hyqd1 : Rlt yq d1.
            { exact (Rlt_tra yq d2 d1 Hyqd2 Hd2d1). }
            apply andI.
            - exact Hyqd1.
            - exact Hyqd2. }

        (** Build membership in b1 and b2 using Hb1eq and Hb2eq **)
        claim Ha1xq : Rlt a1 xq.
        { exact (andEL (Rlt a1 xq) (Rlt a2 xq) Haxq). }
        claim Ha2xq : Rlt a2 xq.
        { exact (andER (Rlt a1 xq) (Rlt a2 xq) Haxq). }
        claim Hxqb1 : Rlt xq b1x.
        { exact (andEL (Rlt xq b1x) (Rlt xq b2x) Hxbq). }
        claim Hxqb2 : Rlt xq b2x.
        { exact (andER (Rlt xq b1x) (Rlt xq b2x) Hxbq). }
        claim Hc1yq : Rlt c1 yq.
        { exact (andEL (Rlt c1 yq) (Rlt c2 yq) Hcyq). }
        claim Hc2yq : Rlt c2 yq.
        { exact (andER (Rlt c1 yq) (Rlt c2 yq) Hcyq). }
        claim Hyqd1 : Rlt yq d1.
        { exact (andEL (Rlt yq d1) (Rlt yq d2) Hydq). }
        claim Hyqd2 : Rlt yq d2.
        { exact (andER (Rlt yq d1) (Rlt yq d2) Hydq). }

        claim Hpred1 :
          exists x0:set, exists y0:set,
            q = (x0,y0) /\ Rlt a1 x0 /\ Rlt x0 b1x /\ Rlt c1 y0 /\ Rlt y0 d1.
        { witness xq. witness yq.
          claim H1 : q = (xq,yq) /\ Rlt a1 xq.
          { exact (andI (q = (xq,yq)) (Rlt a1 xq) Hqtup Ha1xq). }
          claim H12 : (q = (xq,yq) /\ Rlt a1 xq) /\ Rlt xq b1x.
          { exact (andI (q = (xq,yq) /\ Rlt a1 xq) (Rlt xq b1x) H1 Hxqb1). }
          claim H123 : ((q = (xq,yq) /\ Rlt a1 xq) /\ Rlt xq b1x) /\ Rlt c1 yq.
          { exact (andI ((q = (xq,yq) /\ Rlt a1 xq) /\ Rlt xq b1x) (Rlt c1 yq) H12 Hc1yq). }
          exact (andI (((q = (xq,yq) /\ Rlt a1 xq) /\ Rlt xq b1x) /\ Rlt c1 yq) (Rlt yq d1) H123 Hyqd1). }
        claim Hpred2 :
          exists x0:set, exists y0:set,
            q = (x0,y0) /\ Rlt a2 x0 /\ Rlt x0 b2x /\ Rlt c2 y0 /\ Rlt y0 d2.
        { witness xq. witness yq.
          claim H1 : q = (xq,yq) /\ Rlt a2 xq.
          { exact (andI (q = (xq,yq)) (Rlt a2 xq) Hqtup Ha2xq). }
          claim H12 : (q = (xq,yq) /\ Rlt a2 xq) /\ Rlt xq b2x.
          { exact (andI (q = (xq,yq) /\ Rlt a2 xq) (Rlt xq b2x) H1 Hxqb2). }
          claim H123 : ((q = (xq,yq) /\ Rlt a2 xq) /\ Rlt xq b2x) /\ Rlt c2 yq.
          { exact (andI ((q = (xq,yq) /\ Rlt a2 xq) /\ Rlt xq b2x) (Rlt c2 yq) H12 Hc2yq). }
          exact (andI (((q = (xq,yq) /\ Rlt a2 xq) /\ Rlt xq b2x) /\ Rlt c2 yq) (Rlt yq d2) H123 Hyqd2). }

        claim Hqb1 : q :e b1.
        { rewrite Hb1eq.
          exact (SepI EuclidPlane
                      (fun q0 : set =>
                        exists x0:set, exists y0:set,
                          q0 = (x0,y0) /\ Rlt a1 x0 /\ Rlt x0 b1x /\ Rlt c1 y0 /\ Rlt y0 d1)
                      q
                      HqEuclid
                      Hpred1). }
        claim Hqb2 : q :e b2.
        { rewrite Hb2eq.
          exact (SepI EuclidPlane
                      (fun q0 : set =>
                        exists x0:set, exists y0:set,
                          q0 = (x0,y0) /\ Rlt a2 x0 /\ Rlt x0 b2x /\ Rlt c2 y0 /\ Rlt y0 d2)
                      q
                      HqEuclid
                      Hpred2). }
        exact (binintersectI b1 b2 q Hqb1 Hqb2).
Qed.

(** from 13 Example 4: circular and rectangular bases generate the same topology **)
(** LATEX VERSION: The topology generated by circular regions equals the topology generated by rectangular regions in R^2. **)
(** LATEX VERSION: This is shown by local refinement in both directions: each circular neighborhood contains a rectangular one, and each rectangular neighborhood contains a circular one. **)

(** from 13 Example 4: rectangular neighborhoods inside circular neighborhoods **)
(** LATEX VERSION: For any point x in a circular region, there is an open rectangle containing x and contained in that circular region. **)
Theorem rectangular_refines_circular_plane :
  forall b :e circular_regions, forall x:set,
    x :e b -> exists r :e rectangular_regions, x :e r /\ r c= b.
let b. assume Hb.
let x. assume Hxb.
prove exists r :e rectangular_regions, x :e r /\ r c= b.
(** Unpack b as a circular region around some center c with radius r0 **)
claim Hbprop :
  exists c:set, exists r0:set,
    c :e EuclidPlane /\ Rlt 0 r0 /\
    b = {p :e EuclidPlane|Rlt (distance_R2 p c) r0}.
{ exact (SepE2 (Power EuclidPlane)
               (fun U0 : set => exists c:set, exists r:set,
                 c :e EuclidPlane /\ Rlt 0 r /\
                 U0 = {p :e EuclidPlane|Rlt (distance_R2 p c) r})
               b
               Hb). }
apply Hbprop.
let c. assume Hbprop2.
apply Hbprop2.
let r0. assume Hbcore.
claim Hcr0 : c :e EuclidPlane /\ Rlt 0 r0.
{ exact (andEL (c :e EuclidPlane /\ Rlt 0 r0)
              (b = {p :e EuclidPlane|Rlt (distance_R2 p c) r0})
              Hbcore). }
claim Hc : c :e EuclidPlane.
{ exact (andEL (c :e EuclidPlane) (Rlt 0 r0) Hcr0). }
claim Hr0 : Rlt 0 r0.
{ exact (andER (c :e EuclidPlane) (Rlt 0 r0) Hcr0). }
claim HbEq : b = {p :e EuclidPlane|Rlt (distance_R2 p c) r0}.
{ exact (andER (c :e EuclidPlane /\ Rlt 0 r0)
              (b = {p :e EuclidPlane|Rlt (distance_R2 p c) r0})
              Hbcore). }
claim Hxb' : x :e {p :e EuclidPlane|Rlt (distance_R2 p c) r0}.
{ rewrite <- HbEq. exact Hxb. }
claim HxE : x :e EuclidPlane.
{ exact (SepE1 EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 c) r0) x Hxb'). }
claim Hxball : Rlt (distance_R2 x c) r0.
{ exact (SepE2 EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 c) r0) x Hxb'). }

(** Core refinement: build a rectangle around x inside the ball around c **)
apply (rectangle_inside_ball x c r0 HxE Hc Hr0 Hxball).
let r. assume Hrpair.
witness r.
claim Hr : r :e rectangular_regions.
{ exact (andEL (r :e rectangular_regions) (x :e r /\ r c= {p :e EuclidPlane|Rlt (distance_R2 p c) r0}) Hrpair). }
claim Hrprop : x :e r /\ r c= {p :e EuclidPlane|Rlt (distance_R2 p c) r0}.
{ exact (andER (r :e rectangular_regions) (x :e r /\ r c= {p :e EuclidPlane|Rlt (distance_R2 p c) r0}) Hrpair). }
claim Hxr : x :e r.
{ exact (andEL (x :e r) (r c= {p :e EuclidPlane|Rlt (distance_R2 p c) r0}) Hrprop). }
claim Hrsub : r c= {p :e EuclidPlane|Rlt (distance_R2 p c) r0}.
{ exact (andER (x :e r) (r c= {p :e EuclidPlane|Rlt (distance_R2 p c) r0}) Hrprop). }
claim Hrsubb : r c= b.
{ rewrite HbEq. exact Hrsub. }
apply andI.
- exact Hr.
- apply andI.
  + exact Hxr.
  + exact Hrsubb.
Qed.

(** from 13 Example 4: circular neighborhoods inside rectangular neighborhoods **)
(** LATEX VERSION: For any point x in an open rectangle, there is a circular region containing x and contained in that rectangle. **)
Theorem circular_refines_rectangular_plane :
  forall b :e rectangular_regions, forall x:set,
    x :e b -> exists u :e circular_regions, x :e u /\ u c= b.
let b. assume Hb.
let x. assume Hxb.
prove exists u :e circular_regions, x :e u /\ u c= b.
(** Unpack b as a rectangle with endpoints a,b0,c,d0 **)
claim Hbprop :
  exists a:set, exists b0:set, exists c:set, exists d0:set,
    a :e R /\ b0 :e R /\ c :e R /\ d0 :e R /\ Rlt a b0 /\ Rlt c d0 /\
      b = {p :e EuclidPlane|
             exists x0:set, exists y0:set,
               p = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b0 /\ Rlt c y0 /\ Rlt y0 d0}.
{ exact (SepE2 (Power EuclidPlane)
               (fun U0 : set =>
                 exists a b c d:set, a :e R /\ b :e R /\ c :e R /\ d :e R /\ Rlt a b /\ Rlt c d /\
                   U0 = {p1 :e EuclidPlane|
                          exists x0:set, exists y0:set,
                            p1 = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b /\ Rlt c y0 /\ Rlt y0 d})
               b
               Hb). }
apply Hbprop.
let a. assume Hbprop2.
apply Hbprop2.
let b0. assume Hbprop3.
apply Hbprop3.
let c. assume Hbprop4.
apply Hbprop4.
let d0. assume Hbcore.
claim HbEq :
  b = {p :e EuclidPlane|
         exists x0:set, exists y0:set,
           p = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b0 /\ Rlt c y0 /\ Rlt y0 d0}.
{ exact (andER (a :e R /\ b0 :e R /\ c :e R /\ d0 :e R /\ Rlt a b0 /\ Rlt c d0)
              (b = {p :e EuclidPlane|
                     exists x0:set, exists y0:set,
                       p = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b0 /\ Rlt c y0 /\ Rlt y0 d0})
              Hbcore). }
claim Hxb' : x :e {p :e EuclidPlane|
                    exists x0:set, exists y0:set,
                      p = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b0 /\ Rlt c y0 /\ Rlt y0 d0}.
{ rewrite <- HbEq. exact Hxb. }
claim HxE : x :e EuclidPlane.
{ exact (SepE1 EuclidPlane
             (fun p1 : set =>
               exists x0:set, exists y0:set,
                 p1 = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b0 /\ Rlt c y0 /\ Rlt y0 d0)
             x
             Hxb'). }

(** Core refinement: build a small circular region around x contained in the rectangle **)
apply (ball_inside_rectangle b x Hb HxE Hxb).
let r3. assume Hrad2.
claim Hr3 : Rlt 0 r3.
{ exact (andEL (Rlt 0 r3)
              (forall p:set, p :e EuclidPlane -> Rlt (distance_R2 p x) r3 -> p :e b)
              Hrad2). }
claim HradP : forall p:set, p :e EuclidPlane -> Rlt (distance_R2 p x) r3 -> p :e b.
{ exact (andER (Rlt 0 r3)
              (forall p:set, p :e EuclidPlane -> Rlt (distance_R2 p x) r3 -> p :e b)
              Hrad2). }
set u := {p :e EuclidPlane|Rlt (distance_R2 p x) r3}.
witness u.
apply andI.
- prove u :e circular_regions.
  claim HuDef : u = {p :e EuclidPlane|Rlt (distance_R2 p x) r3}.
  { reflexivity. }
  rewrite HuDef.
  exact (circular_regionI x r3 HxE Hr3).
- apply andI.
  + prove x :e u.
    claim HxBall : Rlt (distance_R2 x x) r3.
    { rewrite (distance_R2_refl_0 x HxE).
      exact Hr3. }
    exact (SepI EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 x) r3) x HxE HxBall).
  + prove u c= b.
    let p. assume Hp : p :e u.
    claim HpE : p :e EuclidPlane.
    { exact (SepE1 EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 x) r3) p Hp). }
    claim HpBall : Rlt (distance_R2 p x) r3.
    { exact (SepE2 EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 x) r3) p Hp). }
    exact (HradP p HpE HpBall).
Qed.

Theorem circular_rectangular_same_topology_plane :
  generated_topology EuclidPlane circular_regions = generated_topology EuclidPlane rectangular_regions.
prove generated_topology EuclidPlane circular_regions = generated_topology EuclidPlane rectangular_regions.
apply set_ext.
- (** inclusion: generated_topology EuclidPlane circular_regions c= generated_topology EuclidPlane rectangular_regions **)
  let U. assume HU : U :e generated_topology EuclidPlane circular_regions.
  prove U :e generated_topology EuclidPlane rectangular_regions.
  claim HUPow : U :e Power EuclidPlane.
  { exact (SepE1 (Power EuclidPlane)
                 (fun U0 : set =>
                   forall x0 :e U0, exists b :e circular_regions, x0 :e b /\ b c= U0)
                 U
                 HU). }
  claim HUprop : forall x0 :e U, exists b :e circular_regions, x0 :e b /\ b c= U.
  { exact (SepE2 (Power EuclidPlane)
                 (fun U0 : set =>
                   forall x0 :e U0, exists b :e circular_regions, x0 :e b /\ b c= U0)
                 U
                 HU). }
  claim HUsub : U c= EuclidPlane.
  { exact (PowerE EuclidPlane U HUPow). }
  claim HUrect : forall x0 :e U, exists r :e rectangular_regions, x0 :e r /\ r c= U.
  { let x0. assume Hx0U.
    claim Hexb : exists b :e circular_regions, x0 :e b /\ b c= U.
    { exact (HUprop x0 Hx0U). }
    apply Hexb.
    let b. assume Hbpair.
    claim Hb : b :e circular_regions.
    { exact (andEL (b :e circular_regions) (x0 :e b /\ b c= U) Hbpair). }
    claim Hbprop : x0 :e b /\ b c= U.
    { exact (andER (b :e circular_regions) (x0 :e b /\ b c= U) Hbpair). }
    claim Hx0b : x0 :e b.
    { exact (andEL (x0 :e b) (b c= U) Hbprop). }
    claim HbsubU : b c= U.
    { exact (andER (x0 :e b) (b c= U) Hbprop). }
    claim Hexr : exists r :e rectangular_regions, x0 :e r /\ r c= b.
    { exact (rectangular_refines_circular_plane b Hb x0 Hx0b). }
    apply Hexr.
    let r. assume Hrpair.
    claim Hr : r :e rectangular_regions.
    { exact (andEL (r :e rectangular_regions) (x0 :e r /\ r c= b) Hrpair). }
    claim Hrprop : x0 :e r /\ r c= b.
    { exact (andER (r :e rectangular_regions) (x0 :e r /\ r c= b) Hrpair). }
    claim Hx0r : x0 :e r.
    { exact (andEL (x0 :e r) (r c= b) Hrprop). }
    claim Hrsubb : r c= b.
    { exact (andER (x0 :e r) (r c= b) Hrprop). }
    claim HrsubU : r c= U.
    { exact (Subq_tra r b U Hrsubb HbsubU). }
    witness r.
    apply andI.
    - exact Hr.
    - apply andI.
      + exact Hx0r.
      + exact HrsubU. }
  exact (SepI (Power EuclidPlane)
              (fun U0 : set =>
                forall x0 :e U0, exists r :e rectangular_regions, x0 :e r /\ r c= U0)
              U
              HUPow
              HUrect).
- (** inclusion: generated_topology EuclidPlane rectangular_regions c= generated_topology EuclidPlane circular_regions **)
  let U. assume HU : U :e generated_topology EuclidPlane rectangular_regions.
  prove U :e generated_topology EuclidPlane circular_regions.
  claim HUPow : U :e Power EuclidPlane.
  { exact (SepE1 (Power EuclidPlane)
                 (fun U0 : set =>
                   forall x0 :e U0, exists b :e rectangular_regions, x0 :e b /\ b c= U0)
                 U
                 HU). }
  claim HUprop : forall x0 :e U, exists b :e rectangular_regions, x0 :e b /\ b c= U.
  { exact (SepE2 (Power EuclidPlane)
                 (fun U0 : set =>
                   forall x0 :e U0, exists b :e rectangular_regions, x0 :e b /\ b c= U0)
                 U
                 HU). }
  claim HUcirc : forall x0 :e U, exists u :e circular_regions, x0 :e u /\ u c= U.
  { let x0. assume Hx0U.
    claim Hexb : exists b :e rectangular_regions, x0 :e b /\ b c= U.
    { exact (HUprop x0 Hx0U). }
    apply Hexb.
    let b. assume Hbpair.
    claim Hb : b :e rectangular_regions.
    { exact (andEL (b :e rectangular_regions) (x0 :e b /\ b c= U) Hbpair). }
    claim Hbprop : x0 :e b /\ b c= U.
    { exact (andER (b :e rectangular_regions) (x0 :e b /\ b c= U) Hbpair). }
    claim Hx0b : x0 :e b.
    { exact (andEL (x0 :e b) (b c= U) Hbprop). }
    claim HbsubU : b c= U.
    { exact (andER (x0 :e b) (b c= U) Hbprop). }
    claim Hexu : exists u :e circular_regions, x0 :e u /\ u c= b.
    { exact (circular_refines_rectangular_plane b Hb x0 Hx0b). }
    apply Hexu.
    let u. assume Hupair.
    claim Hu : u :e circular_regions.
    { exact (andEL (u :e circular_regions) (x0 :e u /\ u c= b) Hupair). }
    claim Huprop : x0 :e u /\ u c= b.
    { exact (andER (u :e circular_regions) (x0 :e u /\ u c= b) Hupair). }
    claim Hx0u : x0 :e u.
    { exact (andEL (x0 :e u) (u c= b) Huprop). }
    claim Husubb : u c= b.
    { exact (andER (x0 :e u) (u c= b) Huprop). }
    claim HusubU : u c= U.
    { exact (Subq_tra u b U Husubb HbsubU). }
    witness u.
    apply andI.
    - exact Hu.
    - apply andI.
      + exact Hx0u.
      + exact HusubU. }
  exact (SepI (Power EuclidPlane)
              (fun U0 : set =>
                forall x0 :e U0, exists b :e circular_regions, x0 :e b /\ b c= U0)
              U
              HUPow
              HUcirc).
Qed.

(** from 13: refinement of basis yields finer topology **) 
(** LATEX VERSION: If B refines every open set of the topology generated by B, then T(B) is finer than T(B). **)
Theorem lemma_finer_if_basis_refines : forall X B B':set,
  basis_on X B -> basis_refines X B' (generated_topology X B) ->
  finer_than (generated_topology X B') (generated_topology X B).
let X B B'. assume HBasis Href.
claim Hprop : forall U :e generated_topology X B, forall x :e U, exists b' :e B', x :e b' /\ b' c= U.
{ exact (andER (topology_on X (generated_topology X B))
               (forall U :e generated_topology X B, forall x :e U, exists b' :e B', x :e b' /\ b' c= U)
               Href). }
prove generated_topology X B c= generated_topology X B'.
  let U. assume HU.
  claim HUsubX : U c= X.
  { exact (PowerE X U (SepE1 (Power X)
                             (fun U0 : set => forall x0 :e U0, exists b0 :e B, x0 :e b0 /\ b0 c= U0)
                             U HU)). }
  claim HUprop : forall x :e U, exists b' :e B', x :e b' /\ b' c= U.
  { exact (Hprop U HU). }
  exact (SepI (Power X)
              (fun U0 : set => forall x0 :e U0, exists b0 :e B', x0 :e b0 /\ b0 c= U0)
              U
              (PowerI X U HUsubX)
              HUprop).
Qed.

(** from 13 Definition: subbasis and its generated topology **) 
(** LATEX VERSION: A subbasis S for a topology on X is a collection of subsets of X whose union equals X. **)
(** SUSPICIOUS DEFINITION: The condition is `Union S = X`; in later uses it is easy to accidentally only show `Union S c= X`, which is weaker. **)
Definition subbasis_on : set -> set -> prop := fun X S =>
  S c= Power X /\ Union S = X.

(** from 13: finite intersections of subbasis elements **)
(** LATEX VERSION: intersection_of_family collects common points of all sets in a family; finite_subcollections picks finite families; finite_intersections_of X S takes intersections of finite subfamilies of S. **)
(** FIXED: Now takes ambient set X as first parameter. Empty family correctly gives X; nonempty Fam gives the usual intersection inside X. **)
(** SUSPICIOUS DEFINITION: `intersection_of_family X Fam` does not require `Fam c= Power X`; it relies on the ambient restriction `x :e X` to force the intersection to lie in X. **)
Definition intersection_of_family : set -> set -> set :=
  fun X Fam => {x :e X|forall U:set, U :e Fam -> x :e U}.

(** helper: intersection of a family stays in the ambient union **) 
(** LATEX VERSION: Placeholder lemma: each member of an intersection lies in the union of the family (to be proved properly). **)
Definition finite_subcollections : set -> set :=
  fun S => {F :e Power S|finite F}.

(** FIXED: Now takes X to pass to intersection_of_family. **)
Definition finite_intersections_of : set -> set -> set := fun X S =>
  {intersection_of_family X F|F :e finite_subcollections S}.

(** from 13: basis obtained from a subbasis by finite intersections **)
(** LATEX VERSION: basis_of_subbasis X S is the set of nonempty finite intersections of elements of S. **)
(** FIXED: Now properly uses X parameter. Empty intersection gives X; the filter keeps only nonempty intersections. **)
(** SUSPICIOUS DEFINITION: `basis_of_subbasis` removes `Empty`; this matches the usual convention but means `X` appears only via the empty intersection and only when `X <> Empty`. **)
Definition basis_of_subbasis : set -> set -> set := fun X S =>
  {b :e finite_intersections_of X S | b <> Empty}.

(** Helper: Finite intersection of a family is in the basis_of_subbasis **)
Theorem finite_intersection_in_basis : forall X S F:set,
  F :e finite_subcollections S ->
  intersection_of_family X F <> Empty ->
  intersection_of_family X F :e basis_of_subbasis X S.
let X S F. assume HF Hnon.
prove intersection_of_family X F :e basis_of_subbasis X S.
(** basis_of_subbasis X S = {b :e finite_intersections_of X S | b <> Empty} **)
exact (SepI (finite_intersections_of X S) (fun b:set => b <> Empty) (intersection_of_family X F)
            (ReplI (finite_subcollections S) (fun F0 : set => intersection_of_family X F0) F HF)
            Hnon).
 
Qed.

(** Helper: empty family intersection equals X **)
Theorem intersection_of_family_empty_eq : forall X:set,
  intersection_of_family X Empty = X.
let X.
apply set_ext.
- let x. assume Hx: x :e intersection_of_family X Empty.
  prove x :e X.
  exact (SepE1 X (fun x0 : set => forall U:set, U :e Empty -> x0 :e U) x Hx).
- let x. assume HxX: x :e X.
  prove x :e intersection_of_family X Empty.
  exact (SepI X (fun x0 : set => forall U:set, U :e Empty -> x0 :e U) x
              HxX
              (fun U HU => EmptyE U HU (x :e U))).
Qed.

(** Helper: singleton family intersection equals the set when it is a subset of X **)
Theorem intersection_of_family_singleton_eq : forall X s:set,
  s c= X ->
  intersection_of_family X {s} = s.
let X s. assume HsSubX.
apply set_ext.
- let x. assume Hx: x :e intersection_of_family X {s}.
  prove x :e s.
  claim Hall: forall U:set, U :e {s} -> x :e U.
  { exact (SepE2 X (fun x0 : set => forall U:set, U :e {s} -> x0 :e U) x Hx). }
  exact (Hall s (SingI s)).
- let x. assume Hx: x :e s.
  prove x :e intersection_of_family X {s}.
  claim HxX: x :e X.
  { exact (HsSubX x Hx). }
  claim Hprop: forall U:set, U :e {s} -> x :e U.
  { let U. assume HU: U :e {s}.
    prove x :e U.
    claim HUeq: U = s.
    { exact (SingE s U HU). }
    rewrite HUeq.
    exact Hx.
  }
  exact (SepI X (fun x0 : set => forall U:set, U :e {s} -> x0 :e U) x HxX Hprop).
Qed.

(** Helper: Elements of subbasis are in the generated basis **)
Theorem subbasis_elem_in_basis : forall X S s:set,
  subbasis_on X S ->
  s :e S ->
  s <> Empty ->
  s :e basis_of_subbasis X S.
let X S s. assume HSsub HsS HsNonempty.
prove s :e basis_of_subbasis X S.
claim HS: S c= Power X.
{ exact (andEL (S c= Power X) (Union S = X) HSsub). }
claim HsPow: s :e Power X.
{ exact (HS s HsS). }
claim HsSubX: s c= X.
{ exact (PowerE X s HsPow). }
set F := {s}.
claim HFPower: F :e Power S.
{ apply PowerI S F.
  let t. assume Ht: t :e F.
  prove t :e S.
  claim HtEq: t = s.
  { exact (SingE s t Ht). }
  rewrite HtEq.
  exact HsS.
}
claim HFinF: finite F.
{ exact (Sing_finite s). }
claim HFsubcol: F :e finite_subcollections S.
{ exact (SepI (Power S) (fun F0 : set => finite F0) F HFPower HFinF). }
claim HinterEq: intersection_of_family X F = s.
{ exact (intersection_of_family_singleton_eq X s HsSubX). }
claim HinterNonempty: intersection_of_family X F <> Empty.
{ rewrite HinterEq. exact HsNonempty. }
claim HinterInBasis: intersection_of_family X F :e basis_of_subbasis X S.
{ exact (finite_intersection_in_basis X S F HFsubcol HinterNonempty). }
rewrite <- HinterEq at 1.
exact HinterInBasis.
Qed.

(** Helper: X itself (empty intersection) is in the basis when nonempty **)
Theorem X_in_basis_of_subbasis : forall X S:set,
  X <> Empty ->
  X :e basis_of_subbasis X S.
let X S. assume HXnonempty.
prove X :e basis_of_subbasis X S.
set F := Empty.
claim HFPower: F :e Power S.
{ exact (Empty_In_Power S). }
claim HFinF: finite F.
{ exact finite_Empty. }
claim HFsubcol: F :e finite_subcollections S.
{ exact (SepI (Power S) (fun F0 : set => finite F0) F HFPower HFinF). }
claim HinterEq: intersection_of_family X F = X.
{ exact (intersection_of_family_empty_eq X). }
claim HinterNonempty: intersection_of_family X F <> Empty.
{ rewrite HinterEq. exact HXnonempty. }
claim HinterInBasis: intersection_of_family X F :e basis_of_subbasis X S.
{ exact (finite_intersection_in_basis X S F HFsubcol HinterNonempty). }
rewrite <- HinterEq at 1.
exact HinterInBasis.
Qed.

(** Helper: Finite intersection of topology elements is in the topology **)
Theorem intersection_of_family_adjoin : forall X F U:set,
  intersection_of_family X (F :\/: {U}) = (intersection_of_family X F) :/\: U.
let X F U.
apply set_ext.
- let x. assume Hx: x :e intersection_of_family X (F :\/: {U}).
  prove x :e (intersection_of_family X F) :/\: U.
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0 : set => forall T:set, T :e (F :\/: {U}) -> x0 :e T) x Hx). }
  claim Hall: forall T:set, T :e (F :\/: {U}) -> x :e T.
  { exact (SepE2 X (fun x0 : set => forall T:set, T :e (F :\/: {U}) -> x0 :e T) x Hx). }
  claim HxInF: x :e intersection_of_family X F.
  { exact (SepI X (fun x0 : set => forall T:set, T :e F -> x0 :e T) x
                HxX
                (fun T HT => Hall T (binunionI1 F {U} T HT))). }
  claim HxU: x :e U.
  { exact (Hall U (binunionI2 F {U} U (SingI U))). }
  exact (binintersectI (intersection_of_family X F) U x HxInF HxU).
- let x. assume Hx: x :e (intersection_of_family X F) :/\: U.
  prove x :e intersection_of_family X (F :\/: {U}).
  claim HxInF: x :e intersection_of_family X F.
  { exact (binintersectE1 (intersection_of_family X F) U x Hx). }
  claim HxU: x :e U.
  { exact (binintersectE2 (intersection_of_family X F) U x Hx). }
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0 : set => forall T:set, T :e F -> x0 :e T) x HxInF). }
  claim HallF: forall T:set, T :e F -> x :e T.
  { exact (SepE2 X (fun x0 : set => forall T:set, T :e F -> x0 :e T) x HxInF). }
  claim Hall: forall T:set, T :e (F :\/: {U}) -> x :e T.
  { let T. assume HT.
    prove x :e T.
    apply (binunionE' F {U} T (x :e T)).
    - assume HTF: T :e F.
      exact (HallF T HTF).
    - assume HTU: T :e {U}.
      claim HUeq: T = U.
      { exact (SingE U T HTU). }
      rewrite HUeq.
      exact HxU.
    - exact HT.
  }
  exact (SepI X (fun x0 : set => forall T:set, T :e (F :\/: {U}) -> x0 :e T) x
              HxX
              Hall).
Qed.

Theorem finite_intersection_in_topology : forall X T F:set,
  topology_on X T ->
  F :e Power T ->
  finite F ->
  intersection_of_family X F :e T.
let X T F.
assume HTtop: topology_on X T.
assume HFpow: F :e Power T.
assume HFin: finite F.
prove intersection_of_family X F :e T.
(** Use finite induction on F with property: if F c= T then intersection is open **)
claim HpEmpty: Empty :e Power T -> intersection_of_family X Empty :e T.
{ assume HpowEmpty.
  rewrite (intersection_of_family_empty_eq X).
  exact (topology_has_X X T HTtop).
}
claim HpStep: forall F0 y:set,
  finite F0 ->
  y /:e F0 ->
  (F0 :e Power T -> intersection_of_family X F0 :e T) ->
  ((F0 :\/: {y}) :e Power T -> intersection_of_family X (F0 :\/: {y}) :e T).
{ let F0 y.
  assume HFin0 HyNotin IH.
  assume HpowUnion: (F0 :\/: {y}) :e Power T.
  claim HsubUnion: F0 :\/: {y} c= T.
  { exact (PowerE T (F0 :\/: {y}) HpowUnion). }
  claim HsubF0: F0 c= T.
  { let U. assume HU: U :e F0.
    exact (HsubUnion U (binunionI1 F0 {y} U HU)). }
  claim HF0pow: F0 :e Power T.
  { exact (PowerI T F0 HsubF0). }
  claim HinterF0: intersection_of_family X F0 :e T.
  { exact (IH HF0pow). }
  claim HyT: y :e T.
  { exact (HsubUnion y (binunionI2 F0 {y} y (SingI y))). }
  rewrite (intersection_of_family_adjoin X F0 y).
  exact (topology_binintersect_closed X T (intersection_of_family X F0) y HTtop HinterF0 HyT).
}
claim Hall: forall F0:set, finite F0 -> (F0 :e Power T -> intersection_of_family X F0 :e T).
{ exact (finite_ind (fun F0:set => F0 :e Power T -> intersection_of_family X F0 :e T) HpEmpty HpStep). }
claim Hspec: F :e Power T -> intersection_of_family X F :e T.
{ exact (Hall F HFin). }
exact (Hspec HFpow).
Qed.

(** from 13: topology generated by a subbasis **) 
(** LATEX VERSION: generated_topology_from_subbasis X S is the topology generated by the basis arising from S. **)
Definition generated_topology_from_subbasis : set -> set -> set :=
  fun X S => generated_topology X (basis_of_subbasis X S).

(** from 13: finite intersections of a subbasis form a basis **) 
(** LATEX VERSION: The set of nonempty finite intersections of subbasis elements forms a basis. **)
Theorem finite_intersections_basis_of_subbasis : forall X S:set,
  subbasis_on X S -> basis_on X (basis_of_subbasis X S).
let X S.
assume HS.
prove basis_on X (basis_of_subbasis X S).
(** basis_on X B requires: B c= Power X, covering, and intersection property **)
prove basis_of_subbasis X S c= Power X
  /\ (forall x :e X, exists b :e basis_of_subbasis X S, x :e b)
  /\ (forall b1 :e basis_of_subbasis X S, forall b2 :e basis_of_subbasis X S, forall x:set,
        x :e b1 -> x :e b2 -> exists b3 :e basis_of_subbasis X S, x :e b3 /\ b3 c= b1 :/\: b2).
apply andI.
- (** Build left-associative conjunction **)
  apply andI.
  + (** Axiom 1: basis_of_subbasis X S c= Power X **)
    let b. assume Hb: b :e basis_of_subbasis X S.
    prove b :e Power X.
    (** b is a nonempty finite intersection of subbasis elements **)
    (** basis_of_subbasis X S = {b :e finite_intersections_of X S | b <> Empty} **)
    claim Hb_in_finite: b :e finite_intersections_of X S.
    { exact (SepE1 (finite_intersections_of X S) (fun b0 => b0 <> Empty) b Hb). }
    (** finite_intersections_of X S = {intersection_of_family F | F :e finite_subcollections S} **)
    (** So b = intersection_of_family F for some finite F c= S **)
    claim Hex: exists F :e finite_subcollections S, b = intersection_of_family X F.
    { exact (ReplE (finite_subcollections S) (fun F => intersection_of_family X F) b Hb_in_finite). }
    apply Hex.
    let F. assume HF_and_eq. apply HF_and_eq.
    assume HF: F :e finite_subcollections S.
    assume Hbeq: b = intersection_of_family X F.
    prove b :e Power X.
    apply PowerI.
    (** Need to show b c= X **)
    let x. assume Hx: x :e b.
    prove x :e X.
    (** With new definition: intersection_of_family X F = {x :e X | forall U :e F, x :e U}. So x :e intersection_of_family X F directly gives x :e X. **)
    claim Hx_intersect: x :e intersection_of_family X F.
    { rewrite <- Hbeq. exact Hx. }
    exact (SepE1 X (fun x0 => forall U:set, U :e F -> x0 :e U) x Hx_intersect).
  + (** Axiom 2: covering property - forall x :e X, exists b :e basis_of_subbasis X S, x :e b **)
    let x. assume Hx: x :e X.
    prove exists b :e basis_of_subbasis X S, x :e b.
    (** Use Union S = X from subbasis_on: pick s :e S with x :e s, then s is a nonempty finite intersection **)
    claim HSsub: S c= Power X.
    { exact (andEL (S c= Power X) (Union S = X) HS). }
    claim HUnionS: Union S = X.
    { exact (andER (S c= Power X) (Union S = X) HS). }
    claim HxUnionS: x :e Union S.
    { rewrite HUnionS. exact Hx. }
    apply (UnionE_impred S x HxUnionS).
    let s. assume Hxs: x :e s. assume HsS: s :e S.
    claim HsNe: s <> Empty.
    { assume Hseq: s = Empty.
      claim HxEmpty: x :e Empty.
      { rewrite <- Hseq. exact Hxs. }
      exact (EmptyE x HxEmpty).
    }
    claim HsInBasis: s :e basis_of_subbasis X S.
    { exact (subbasis_elem_in_basis X S s HS HsS HsNe). }
    witness s.
    apply andI.
    * exact HsInBasis.
    * exact Hxs.
- (** Axiom 3: intersection property **)
  let b1. assume Hb1: b1 :e basis_of_subbasis X S.
  let b2. assume Hb2: b2 :e basis_of_subbasis X S.
  let x. assume Hxb1: x :e b1. assume Hxb2: x :e b2.
  prove exists b3 :e basis_of_subbasis X S, x :e b3 /\ b3 c= b1 :/\: b2.
  (** b1 and b2 are finite intersections; their intersection is also a finite intersection **)
  (** Take b3 = b1 :/\: b2 if nonempty **)
  set b3 := b1 :/\: b2.
  claim Hxb3: x :e b3.
  { apply binintersectI. exact Hxb1. exact Hxb2. }
  claim Hb3_ne: b3 <> Empty.
  { assume Hempty: b3 = Empty.
    claim Hx_in_empty: x :e Empty.
    { rewrite <- Hempty. exact Hxb3. }
    exact (EmptyE x Hx_in_empty).
  }
  (** Need to show b3 :e basis_of_subbasis X S **)
  (** b3 = b1 :/\: b2 where b1, b2 are finite intersections **)
  witness b3.
  apply andI.
  + (** b3 :e basis_of_subbasis X S **)
    prove b3 :e basis_of_subbasis X S.
    (** Extract that b1, b2 are finite intersections **)
    claim Hb1_finite: b1 :e finite_intersections_of X S.
    { exact (SepE1 (finite_intersections_of X S) (fun b0 => b0 <> Empty) b1 Hb1). }
    claim Hb2_finite: b2 :e finite_intersections_of X S.
    { exact (SepE1 (finite_intersections_of X S) (fun b0 => b0 <> Empty) b2 Hb2). }
    (** Get witnesses F1, F2 **)
    claim Hex1: exists F1 :e finite_subcollections S, b1 = intersection_of_family X F1.
    { exact (ReplE (finite_subcollections S) (fun F => intersection_of_family X F) b1 Hb1_finite). }
    apply Hex1.
    let F1. assume HF1_and_eq1. apply HF1_and_eq1.
    assume HF1: F1 :e finite_subcollections S.
    assume Hb1eq: b1 = intersection_of_family X F1.
    claim Hex2: exists F2 :e finite_subcollections S, b2 = intersection_of_family X F2.
    { exact (ReplE (finite_subcollections S) (fun F => intersection_of_family X F) b2 Hb2_finite). }
    apply Hex2.
    let F2. assume HF2_and_eq2. apply HF2_and_eq2.
    assume HF2: F2 :e finite_subcollections S.
    assume Hb2eq: b2 = intersection_of_family X F2.
    (** With new definition: intersection_of_family X Empty = X. So F1 and F2 may be empty without causing ill-defined intersections. **)
    (** Now b3 = b1 :/\: b2 = intersection_of_family X (F1 :\/: F2) **)
    set F12 := F1 :\/: F2.
    (** Show F12 :e finite_subcollections S **)
    claim HF12_finite: F12 :e finite_subcollections S.
    { prove F12 :e {F :e Power S | finite F}.
      claim HF12_sub: F12 c= S.
      { claim HF1_sub: F1 c= S.
        { claim HF1_power: F1 :e Power S.
          { exact (SepE1 (Power S) (fun F0 => finite F0) F1 HF1). }
          exact (PowerE S F1 HF1_power).
        }
        claim HF2_sub: F2 c= S.
        { claim HF2_power: F2 :e Power S.
          { exact (SepE1 (Power S) (fun F0 => finite F0) F2 HF2). }
          exact (PowerE S F2 HF2_power).
        }
        exact (binunion_Subq_min F1 F2 S HF1_sub HF2_sub).
      }
      claim HF12_power: F12 :e Power S.
      { apply PowerI. exact HF12_sub. }
      claim HF12_is_finite: finite F12.
      { claim HF1_is_finite: finite F1.
        { exact (SepE2 (Power S) (fun F0 => finite F0) F1 HF1). }
        claim HF2_is_finite: finite F2.
        { exact (SepE2 (Power S) (fun F0 => finite F0) F2 HF2). }
        exact (binunion_finite F1 HF1_is_finite F2 HF2_is_finite).
      }
      exact (SepI (Power S) (fun F => finite F) F12 HF12_power HF12_is_finite).
    }
    (** Show b3 = intersection_of_family F12 **)
    claim Hb3_eq: b3 = intersection_of_family X F12.
    { (** b3 = b1 :/\: b2 = (intersection_of_family F1) :/\: (intersection_of_family F2)                        = intersection_of_family (F1 :\/: F2) = intersection_of_family F12 **)
      apply set_ext.
      - (** b3 c= intersection_of_family F12 **)
        let z. assume Hz: z :e b3.
        prove z :e intersection_of_family X F12.
        claim Hzb1: z :e b1.
        { exact (binintersectE1 b1 b2 z Hz). }
        claim Hzb2: z :e b2.
        { exact (binintersectE2 b1 b2 z Hz). }
        (** z :e intersection_of_family F1 **)
        claim Hz_intersect1: z :e intersection_of_family X F1.
        { rewrite <- Hb1eq. exact Hzb1. }
        (** z :e intersection_of_family F2 **)
        claim Hz_intersect2: z :e intersection_of_family X F2.
        { rewrite <- Hb2eq. exact Hzb2. }
        (** Show z :e intersection_of_family X F12 **)
        prove z :e intersection_of_family X F12.
        (** New definition: intersection_of_family X F = {x :e X | forall U :e F, x :e U} **)
        claim Hz_in_X: z :e X.
        { exact (SepE1 X (fun x => forall U:set, U :e F1 -> x :e U) z Hz_intersect1). }
        claim Hz_all1: forall U:set, U :e F1 -> z :e U.
        { exact (SepE2 X (fun x => forall U:set, U :e F1 -> x :e U) z Hz_intersect1). }
        claim Hz_all2: forall U:set, U :e F2 -> z :e U.
        { exact (SepE2 X (fun x => forall U:set, U :e F2 -> x :e U) z Hz_intersect2). }
        claim Hz_all12: forall U:set, U :e F12 -> z :e U.
        { let U. assume HU: U :e F12.
          prove z :e U.
          apply (binunionE F1 F2 U HU).
          - assume HUF1: U :e F1. exact (Hz_all1 U HUF1).
          - assume HUF2: U :e F2. exact (Hz_all2 U HUF2).
        }
        exact (SepI X (fun x => forall U:set, U :e F12 -> x :e U) z Hz_in_X Hz_all12).
      - (** intersection_of_family X F12 c= b3 **)
        let z. assume Hz: z :e intersection_of_family X F12.
        prove z :e b3.
        (** New definition gives us z :e X and forall U :e F12, z :e U **)
        claim Hz_in_X: z :e X.
        { exact (SepE1 X (fun x => forall U:set, U :e F12 -> x :e U) z Hz). }
        claim Hz_all12: forall U:set, U :e F12 -> z :e U.
        { exact (SepE2 X (fun x => forall U:set, U :e F12 -> x :e U) z Hz). }
        claim Hz_all1: forall U:set, U :e F1 -> z :e U.
        { let U. assume HU: U :e F1.
          prove z :e U.
          exact (Hz_all12 U (binunionI1 F1 F2 U HU)).
        }
        claim Hz_all2: forall U:set, U :e F2 -> z :e U.
        { let U. assume HU: U :e F2.
          prove z :e U.
          exact (Hz_all12 U (binunionI2 F1 F2 U HU)).
        }
        (** Use Hz_all1 and Hz_all2 to show z :e b1 and z :e b2 **)
        (** New definition: intersection_of_family X F = {x :e X | forall U :e F, x :e U} **)
        claim Hz_intersect1: z :e intersection_of_family X F1.
        { exact (SepI X (fun x => forall U:set, U :e F1 -> x :e U) z Hz_in_X Hz_all1). }
        claim Hz_intersect2: z :e intersection_of_family X F2.
        { exact (SepI X (fun x => forall U:set, U :e F2 -> x :e U) z Hz_in_X Hz_all2). }
        claim Hzb1: z :e b1.
        { rewrite Hb1eq. exact Hz_intersect1. }
        claim Hzb2: z :e b2.
        { rewrite Hb2eq. exact Hz_intersect2. }
        exact (binintersectI b1 b2 z Hzb1 Hzb2).
    }
    (** Now show b3 :e basis_of_subbasis X S using finite_intersection_in_basis **)
    claim H_intersect_ne: intersection_of_family X F12 <> Empty.
    { assume Hempty_intersect: intersection_of_family X F12 = Empty.
      claim Hb3_empty: b3 = Empty.
      { rewrite Hb3_eq. exact Hempty_intersect. }
      exact (Hb3_ne Hb3_empty).
    }
    claim H_intersect_in_basis: intersection_of_family X F12 :e basis_of_subbasis X S.
    { exact (finite_intersection_in_basis X S F12 HF12_finite H_intersect_ne). }
    claim Hb3_in_basis: b3 :e basis_of_subbasis X S.
    { rewrite Hb3_eq. exact H_intersect_in_basis. }
    exact Hb3_in_basis.
  + (** x :e b3 /\ b3 c= b1 :/\: b2 **)
    apply andI.
    * exact Hxb3.
    * exact (Subq_ref (b1 :/\: b2)).
Qed.

(** from 13: topology generated by a subbasis is a topology **) 
(** LATEX VERSION: The topology generated from a subbasis S on X satisfies the topology axioms. **)
Theorem topology_from_subbasis_is_topology : forall X S:set,
  subbasis_on X S -> topology_on X (generated_topology_from_subbasis X S).
let X S.
assume HS.
prove topology_on X (generated_topology_from_subbasis X S).
(** Strategy: Show basis_of_subbasis X S is a basis, then apply lemma_topology_from_basis **)
claim HBasis: basis_on X (basis_of_subbasis X S).
{ exact (finite_intersections_basis_of_subbasis X S HS). }
claim HTopo: topology_on X (generated_topology X (basis_of_subbasis X S)).
{ exact (lemma_topology_from_basis X (basis_of_subbasis X S) HBasis). }
(** generated_topology_from_subbasis X S = generated_topology X (basis_of_subbasis X S) by definition **)
exact HTopo.
Qed.

(** from 13: generated topology from subbasis is minimal among topologies containing S **) 
(** LATEX VERSION: Among all topologies containing a subbasis S, the generated one is the smallest/finer-than criterion. **)
Theorem topology_generated_by_basis_is_minimal : forall X S T:set,
  subbasis_on X S -> topology_on X T -> S c= T ->
  finer_than T (generated_topology_from_subbasis X S).
let X S T.
assume HS HT HST.
prove finer_than T (generated_topology_from_subbasis X S).
(** finer_than T (generated_topology_from_subbasis X S) = generated_topology_from_subbasis X S c= T **)
prove generated_topology_from_subbasis X S c= T.
(** generated_topology_from_subbasis X S = generated_topology X (basis_of_subbasis X S) **)
prove generated_topology X (basis_of_subbasis X S) c= T.
(** Strategy: show every basis element is in T, then every generated open set is in T **)
let U. assume HU: U :e generated_topology X (basis_of_subbasis X S).
prove U :e T.
(** U :e generated_topology X B means U c= X and forall x :e U, exists b :e B with x :e b, b c= U **)
claim HU_def: U c= X /\ (forall x :e U, exists b :e basis_of_subbasis X S, x :e b /\ b c= U).
{ (** generated_topology X B = {U :e Power X | forall x :e U, exists b :e B, x :e b /\ b c= U} **)
  claim HU_power: U :e Power X.
  { exact (SepE1 (Power X) (fun U0 => forall x :e U0, exists b :e basis_of_subbasis X S, x :e b /\ b c= U0) U HU). }
  claim HUsub_X: U c= X.
  { exact (PowerE X U HU_power). }
  claim HU_local: forall x :e U, exists b :e basis_of_subbasis X S, x :e b /\ b c= U.
  { exact (SepE2 (Power X) (fun U0 => forall x :e U0, exists b :e basis_of_subbasis X S, x :e b /\ b c= U0) U HU). }
  exact (andI (U c= X) (forall x :e U, exists b :e basis_of_subbasis X S, x :e b /\ b c= U) HUsub_X HU_local).
}
claim HUsub: U c= X.
{ exact (andEL (U c= X) (forall x :e U, exists b :e basis_of_subbasis X S, x :e b /\ b c= U) HU_def). }
claim HUlocal: forall x :e U, exists b :e basis_of_subbasis X S, x :e b /\ b c= U.
{ exact (andER (U c= X) (forall x :e U, exists b :e basis_of_subbasis X S, x :e b /\ b c= U) HU_def). }
(** Show: every basis element is in T **)
claim Hbasis_in_T: forall b :e basis_of_subbasis X S, b :e T.
{ let b. assume Hb: b :e basis_of_subbasis X S.
  prove b :e T.
  (** b is either X itself or a nonempty finite intersection of elements from S **)
  (** Case 1: if b = X, then X :e T since T is a topology **)
  (** Case 2: if b is a finite intersection of S elements, use that T is closed under finite intersections **)
  apply (xm (b = X)).
  - assume Hb_eq_X: b = X.
    (** X :e T since T is a topology on X **)
    claim HX_in_T: X :e T.
    { (** Extract from topology_on X T **)
      claim H1: ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T).
      { exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) (forall U :e T, forall V :e T, U :/\: V :e T) HT). }
      claim H2: (T c= Power X /\ Empty :e T) /\ X :e T.
      { exact (andEL ((T c= Power X /\ Empty :e T) /\ X :e T) (forall UFam :e Power T, Union UFam :e T) H1). }
      exact (andER (T c= Power X /\ Empty :e T) (X :e T) H2).
    }
    claim Hb_in_T_case1: b :e T.
    { rewrite Hb_eq_X. exact HX_in_T. }
    exact Hb_in_T_case1.
  - assume Hb_ne_X: b <> X.
    (** b is a nonempty finite intersection of S elements **)
    (** b :e basis_of_subbasis X S = {b :e finite_intersections_of X S | b <> Empty} **)
    claim Hb_finite_inter: b :e finite_intersections_of X S.
    { exact (SepE1 (finite_intersections_of X S) (fun b0 => b0 <> Empty) b Hb). }
    (** finite_intersections_of X S = {intersection_of_family F | F :e finite_subcollections S} **)
    claim Hex_F: exists F :e finite_subcollections S, b = intersection_of_family X F.
    { exact (ReplE (finite_subcollections S) (fun F => intersection_of_family X F) b Hb_finite_inter). }
    apply Hex_F.
    let F. assume HF_and_eq. apply HF_and_eq.
    assume HF: F :e finite_subcollections S.
    assume Hb_eq: b = intersection_of_family X F.
    (** F is a finite subcollection of S, so F c= S and finite F **)
    claim HF_sub_S: F c= S.
    { claim HF_power: F :e Power S.
      { exact (SepE1 (Power S) (fun F0 => finite F0) F HF). }
      exact (PowerE S F HF_power).
    }
    claim HF_finite: finite F.
    { exact (SepE2 (Power S) (fun F0 => finite F0) F HF). }
    (** Now b = intersection_of_family F where each element of F is in S, hence in T **)
    (** All elements of F are in T since F c= S c= T **)
    claim HF_sub_T: F c= T.
    { let s. assume Hs: s :e F.
      claim Hs_in_S: s :e S.
      { exact (HF_sub_S s Hs). }
      exact (HST s Hs_in_S).
    }
    claim HF_in_PowerT: F :e Power T.
    { apply PowerI. exact HF_sub_T. }
    (** Apply finite_intersection_in_topology **)
    claim Hb_inter_in_T: intersection_of_family X F :e T.
    { exact (finite_intersection_in_topology X T F HT HF_in_PowerT HF_finite). }
    claim Hb_in_T_case2: b :e T.
    { rewrite Hb_eq. exact Hb_inter_in_T. }
    exact Hb_in_T_case2.
}
(** Now show U is union of basis elements, hence in T **)
(** Strategy: U = Union {b :e basis_of_subbasis X S | b c= U}, and this is a union of T elements **)
set Fam := {b :e basis_of_subbasis X S | b c= U}.
claim HU_eq_union: U = Union Fam.
{ apply set_ext.
  - (** U c= Union Fam **)
    let x. assume Hx: x :e U.
    (** By HUlocal, exists b :e basis_of_subbasis X S with x :e b /\ b c= U **)
    claim Hex_b: exists b :e basis_of_subbasis X S, x :e b /\ b c= U.
    { exact (HUlocal x Hx). }
    apply Hex_b.
    let b. assume Hb_and_props. apply Hb_and_props.
    assume Hb_basis: b :e basis_of_subbasis X S.
    assume Hxb_and_sub. apply Hxb_and_sub.
    assume Hxb: x :e b.
    assume Hb_sub_U: b c= U.
    claim Hb_in_Fam: b :e Fam.
    { exact (SepI (basis_of_subbasis X S) (fun b0 => b0 c= U) b Hb_basis Hb_sub_U). }
    exact (UnionI Fam x b Hxb Hb_in_Fam).
  - (** Union Fam c= U **)
    let x. assume Hx: x :e Union Fam.
    apply UnionE_impred Fam x Hx.
    let b. assume Hxb: x :e b. assume Hb_Fam: b :e Fam.
    claim Hb_sub_U: b c= U.
    { exact (SepE2 (basis_of_subbasis X S) (fun b0 => b0 c= U) b Hb_Fam). }
    exact (Hb_sub_U x Hxb).
}
(** Now show U :e T using that U = Union Fam and Fam c= T **)
claim HFam_sub_T: Fam c= T.
{ let b. assume Hb: b :e Fam.
  claim Hb_basis: b :e basis_of_subbasis X S.
  { exact (SepE1 (basis_of_subbasis X S) (fun b0 => b0 c= U) b Hb). }
  exact (Hbasis_in_T b Hb_basis).
}
claim HFam_in_PowerT: Fam :e Power T.
{ apply PowerI. exact HFam_sub_T. }
(** T is closed under unions, so Union Fam :e T **)
claim HUnion_Fam_in_T: Union Fam :e T.
{ (** Extract union closure from topology_on X T **)
  claim H1: ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T).
  { exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) (forall U :e T, forall V :e T, U :/\: V :e T) HT). }
  claim H_union_closure: forall UFam :e Power T, Union UFam :e T.
  { exact (andER (((T c= Power X /\ Empty :e T) /\ X :e T)) (forall UFam :e Power T, Union UFam :e T) H1). }
  exact (H_union_closure Fam HFam_in_PowerT).
}
claim HU_in_T: U :e T.
{ rewrite HU_eq_union. exact HUnion_Fam_in_T. }
exact HU_in_T.
Qed.

(** from 13 Exercise 1: local openness implies set is open **)
(** LATEX VERSION: Exercise 1: If every xA lies in some open UA, then A is open. **)
Theorem ex13_1_local_open_subset : forall X T A:set,
  topology_on X T ->
  (forall x :e A, exists U :e T, x :e U /\ U c= A) ->
  open_in X T A.
let X T A.
assume HT Hlocal.
prove open_in X T A.
(** Strategy: show A = Union of family of open sets, then A is open **)
set Fam : set := {U :e T | U c= A}.
claim HFam_sub : Fam c= T.
{ let U. assume HU. exact (SepE1 T (fun U0 => U0 c= A) U HU). }
claim HUnion_eq : Union Fam = A.
{ apply set_ext.
  - (** Union Fam c= A **)
    let x. assume Hx.
    apply UnionE_impred Fam x Hx.
    let U. assume HxU HUFam.
    claim HUsub : U c= A.
    { exact (SepE2 T (fun U0 => U0 c= A) U HUFam). }
    exact (HUsub x HxU).
  - (** A c= Union Fam **)
    let x. assume HxA.
    claim Hex : exists U :e T, x :e U /\ U c= A.
    { exact (Hlocal x HxA). }
    apply Hex.
    let U. assume HU.
    claim HUT : U :e T.
    { exact (andEL (U :e T) (x :e U /\ U c= A) HU). }
    claim Hrest : x :e U /\ U c= A.
    { exact (andER (U :e T) (x :e U /\ U c= A) HU). }
    claim HxU : x :e U.
    { exact (andEL (x :e U) (U c= A) Hrest). }
    claim HUsub : U c= A.
    { exact (andER (x :e U) (U c= A) Hrest). }
    claim HUFam : U :e Fam.
    { exact (SepI T (fun U0 => U0 c= A) U HUT HUsub). }
    exact (UnionI Fam x U HxU HUFam).
}
claim HUnionT : Union Fam :e T.
{ exact (topology_union_closed X T Fam HT HFam_sub). }
claim HAT : A :e T.
{ rewrite <- HUnion_eq. exact HUnionT. }
prove topology_on X T /\ A :e T.
apply andI.
- exact HT.
- exact HAT.
Qed.

(** from 13 Exercise 2: comparison of nine topologies on {a,b,c} **) 
(** LATEX VERSION: Exercise 2 constructs nine topologies on {a,b,c} and compares which are topologies and their fineness relations. **)
Definition a_elt : set := Empty.
Definition b_elt : set := {Empty}.
Definition c_elt : set := {{Empty}}.
(** FIXED: Use binunion to create proper 3-element set {a,b,c}; old UPair a_elt (UPair b_elt c_elt) gave {a,{b,c}}, new UPair a_elt b_elt :\/: {c_elt} gives {a,b,c}. **)
Definition abc_set : set := UPair a_elt b_elt :\/: {c_elt}.

Definition top_abc_1 : set := UPair Empty abc_set.
Definition top_abc_2 : set := Power abc_set.
(** FIXED: Nested `UPair` does not create a 3- or 4-element family; use unions with singletons. **)
Definition top_abc_3 : set := UPair Empty {a_elt} :\/: {abc_set}.
Definition top_abc_4 : set := UPair Empty {b_elt} :\/: {abc_set}.
Definition top_abc_5 : set := UPair Empty {c_elt} :\/: {abc_set}.
Definition top_abc_6 : set := UPair Empty (UPair a_elt b_elt) :\/: {abc_set}.
Definition top_abc_7 : set := UPair Empty (UPair a_elt c_elt) :\/: {abc_set}.
Definition top_abc_8 : set := UPair Empty (UPair b_elt c_elt) :\/: {abc_set}.
Definition top_abc_9 : set := (UPair Empty {a_elt} :\/: {UPair a_elt b_elt}) :\/: {abc_set}.

(** Helper: topology of the form {Empty, A, X} **)
Theorem topology_three_sets : forall X A:set,
  A c= X ->
  topology_on X (UPair Empty A :\/: {X}).
let X A. assume HA.
set T := UPair Empty A :\/: {X}.
claim HTPow: T c= Power X.
{ let U. assume HU: U :e T.
  prove U :e Power X.
  apply (binunionE' (UPair Empty A) {X} U (U :e Power X)).
  - assume HU0: U :e UPair Empty A.
    apply (UPairE U Empty A HU0).
    + assume HUeq: U = Empty. rewrite HUeq. exact (Empty_In_Power X).
    + assume HUeq: U = A. rewrite HUeq. exact (PowerI X A HA).
  - assume HU0: U :e {X}.
    claim HUeq: U = X.
    { exact (SingE X U HU0). }
    rewrite HUeq.
    exact (Self_In_Power X).
  - exact HU.
}
claim HEmptyIn: Empty :e T.
{ exact (binunionI1 (UPair Empty A) {X} Empty (UPairI1 Empty A)). }
claim HXIn: X :e T.
{ exact (binunionI2 (UPair Empty A) {X} X (SingI X)). }
prove topology_on X T.
prove (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T))
  /\ (forall U :e T, forall V :e T, U :/\: V :e T).
apply andI.
- apply andI.
  + apply andI.
    * apply andI.
      - exact HTPow.
      - exact HEmptyIn.
    * exact HXIn.
  + let UFam. assume HUFam: UFam :e Power T.
    prove Union UFam :e T.
    claim HUFsub: UFam c= T.
    { exact (PowerE T UFam HUFam). }
    apply (xm (X :e UFam)).
    * assume HXUF: X :e UFam.
      claim HUnionSub: Union UFam c= X.
      { claim HUFpowX: UFam c= Power X.
        { let U. assume HU: U :e UFam.
          exact (HTPow U (HUFsub U HU)).
        }
        exact (Union_Power X UFam HUFpowX).
      }
      claim HUnionEq: Union UFam = X.
      { apply set_ext.
        - exact HUnionSub.
        - let x. assume HxX: x :e X.
          exact (UnionI UFam x X HxX HXUF).
      }
      rewrite HUnionEq.
      exact HXIn.
    * assume HXnot: X /:e UFam.
      apply (xm (A :e UFam)).
	      - assume HAUF: A :e UFam.
         claim HUnionSub: Union UFam c= A.
         { let x. assume Hx: x :e Union UFam.
           prove x :e A.
           apply UnionE_impred UFam x Hx.
           let U. assume HxU: x :e U. assume HUUF: U :e UFam.
           claim HUinT: U :e T.
           { exact (HUFsub U HUUF). }
           apply (binunionE' (UPair Empty A) {X} U (x :e A)).
           - assume HU0: U :e UPair Empty A.
	             apply (UPairE U Empty A HU0).
	             + assume HUeq: U = Empty.
	               claim HxEmpty: x :e Empty.
	               { rewrite <- HUeq. exact HxU. }
	               exact (EmptyE x HxEmpty (x :e A)).
	             + assume HUeq: U = A.
	               rewrite <- HUeq.
	               exact HxU.
           - assume HU0: U :e {X}.
	             claim HUeq: U = X.
	             { exact (SingE X U HU0). }
	             apply FalseE.
	             claim HXUF2: X :e UFam.
	             { rewrite <- HUeq. exact HUUF. }
	             exact (HXnot HXUF2).
           - exact HUinT.
         }
         claim HUnionEq: Union UFam = A.
         { apply set_ext.
           - exact HUnionSub.
           - let x. assume HxA: x :e A.
             exact (UnionI UFam x A HxA HAUF).
         }
         rewrite HUnionEq.
         exact (binunionI1 (UPair Empty A) {X} A (UPairI2 Empty A)).
	      - assume HAnot: A /:e UFam.
         claim HUnionEq: Union UFam = Empty.
         { apply set_ext.
           - let x. assume Hx: x :e Union UFam.
             prove x :e Empty.
             apply UnionE_impred UFam x Hx.
             let U. assume HxU: x :e U. assume HUUF: U :e UFam.
             claim HUinT: U :e T.
             { exact (HUFsub U HUUF). }
             apply (binunionE' (UPair Empty A) {X} U (x :e Empty)).
             + assume HU0: U :e UPair Empty A.
	               apply (UPairE U Empty A HU0).
	               * assume HUeq: U = Empty.
	                 rewrite <- HUeq.
	                 exact HxU.
	               * assume HUeq: U = A.
	                 apply FalseE.
	                 claim HAUF2: A :e UFam.
	                 { rewrite <- HUeq. exact HUUF. }
	                 exact (HAnot HAUF2).
             + assume HU0: U :e {X}.
	               claim HUeq: U = X.
	               { exact (SingE X U HU0). }
	               apply FalseE.
	               claim HXUF2: X :e UFam.
	               { rewrite <- HUeq. exact HUUF. }
	               exact (HXnot HXUF2).
             + exact HUinT.
           - let x. assume Hx: x :e Empty.
             exact (EmptyE x Hx (x :e Union UFam)).
         }
         rewrite HUnionEq.
         exact HEmptyIn.
- let U. assume HU: U :e T.
  let V. assume HV: V :e T.
  prove U :/\: V :e T.
  apply (binunionE' (UPair Empty A) {X} U (U :/\: V :e T)).
  - assume HU0: U :e UPair Empty A.
    apply (UPairE U Empty A HU0).
    + assume HUeq: U = Empty.
      rewrite HUeq.
      claim HcapEq: Empty :/\: V = Empty.
      { apply set_ext.
        - let x. assume Hx: x :e Empty :/\: V.
          exact (binintersectE1 Empty V x Hx).
        - let x. assume Hx: x :e Empty.
          exact (binintersectI Empty V x Hx (EmptyE x Hx (x :e V))).
      }
      rewrite HcapEq.
      exact HEmptyIn.
    + assume HUeq: U = A.
      rewrite HUeq.
      apply (binunionE' (UPair Empty A) {X} V (A :/\: V :e T)).
      * assume HV0: V :e UPair Empty A.
        apply (UPairE V Empty A HV0).
        - assume HVeq: V = Empty.
           rewrite HVeq.
           claim HcapEq: A :/\: Empty = Empty.
           { rewrite (binintersect_com A Empty). exact (binintersect_Subq_eq_1 Empty A (Subq_Empty A)). }
           rewrite HcapEq.
           exact HEmptyIn.
        - assume HVeq: V = A.
           rewrite HVeq.
           claim HcapEq: A :/\: A = A.
           { exact (binintersect_Subq_eq_1 A A (Subq_ref A)). }
           rewrite HcapEq.
           exact (binunionI1 (UPair Empty A) {X} A (UPairI2 Empty A)).
      * assume HV0: V :e {X}.
        claim HVeq: V = X.
        { exact (SingE X V HV0). }
        rewrite HVeq.
        claim HcapEq: A :/\: X = A.
        { exact (binintersect_Subq_eq_1 A X HA). }
        rewrite HcapEq.
        exact (binunionI1 (UPair Empty A) {X} A (UPairI2 Empty A)).
      * exact HV.
  - assume HU0: U :e {X}.
    claim HUeq: U = X.
    { exact (SingE X U HU0). }
    rewrite HUeq.
    claim HVpow: V :e Power X.
    { exact (HTPow V HV). }
    claim HVsub: V c= X.
    { exact (PowerE X V HVpow). }
    claim HcapEq: X :/\: V = V.
    { rewrite (binintersect_com X V). exact (binintersect_Subq_eq_1 V X HVsub). }
    rewrite HcapEq.
    exact HV.
  - exact HU.
Qed.

(** Helper: topology of the form {Empty, A, B, X} with A c= B c= X **)
Theorem topology_chain_four_sets : forall X A B:set,
  A c= B ->
  B c= X ->
  topology_on X ((UPair Empty A :\/: {B}) :\/: {X}).
let X A B. assume HAB HBX.
set T0 := UPair Empty A :\/: {B}.
set T := T0 :\/: {X}.
claim HA_X: A c= X.
{ exact (Subq_tra A B X HAB HBX). }
claim HTPow: T c= Power X.
{ let U. assume HU: U :e T.
  prove U :e Power X.
  apply (binunionE' T0 {X} U (U :e Power X)).
  - assume HU0: U :e T0.
    apply (binunionE' (UPair Empty A) {B} U (U :e Power X)).
    + assume HU1: U :e UPair Empty A.
      apply (UPairE U Empty A HU1).
      * assume HUeq: U = Empty. rewrite HUeq. exact (Empty_In_Power X).
      * assume HUeq: U = A. rewrite HUeq. exact (PowerI X A HA_X).
    + assume HU1: U :e {B}.
      claim HUeq: U = B.
      { exact (SingE B U HU1). }
      rewrite HUeq.
      exact (PowerI X B HBX).
    + exact HU0.
  - assume HU0: U :e {X}.
    claim HUeq: U = X.
    { exact (SingE X U HU0). }
    rewrite HUeq.
    exact (Self_In_Power X).
  - exact HU.
}
claim HEmptyIn: Empty :e T.
{ exact (binunionI1 T0 {X} Empty (binunionI1 (UPair Empty A) {B} Empty (UPairI1 Empty A))). }
claim HXIn: X :e T.
{ exact (binunionI2 T0 {X} X (SingI X)). }
prove topology_on X T.
prove (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T))
  /\ (forall U :e T, forall V :e T, U :/\: V :e T).
apply andI.
- apply andI.
  + apply andI.
    * apply andI.
      - exact HTPow.
      - exact HEmptyIn.
    * exact HXIn.
  + let UFam. assume HUFam: UFam :e Power T.
    prove Union UFam :e T.
    claim HUFsub: UFam c= T.
    { exact (PowerE T UFam HUFam). }
    apply (xm (X :e UFam)).
    * assume HXUF: X :e UFam.
      claim HUnionSub: Union UFam c= X.
      { claim HUFpowX: UFam c= Power X.
        { let U. assume HU: U :e UFam.
          exact (HTPow U (HUFsub U HU)).
        }
        exact (Union_Power X UFam HUFpowX).
      }
      claim HUnionEq: Union UFam = X.
      { apply set_ext.
        - exact HUnionSub.
        - let x. assume HxX: x :e X.
          exact (UnionI UFam x X HxX HXUF).
      }
      rewrite HUnionEq.
      exact HXIn.
    * assume HXnot: X /:e UFam.
      apply (xm (B :e UFam)).
      - assume HBUF: B :e UFam.
         claim HUnionSub: Union UFam c= B.
         { let x. assume Hx: x :e Union UFam.
           prove x :e B.
           apply UnionE_impred UFam x Hx.
           let U. assume HxU: x :e U. assume HUUF: U :e UFam.
           claim HUinT: U :e T.
           { exact (HUFsub U HUUF). }
           apply (binunionE' T0 {X} U (x :e B)).
           - assume HU0: U :e T0.
             apply (binunionE' (UPair Empty A) {B} U (x :e B)).
             + assume HU1: U :e UPair Empty A.
	               apply (UPairE U Empty A HU1).
	               * assume HUeq: U = Empty.
		                 claim HxEmpty: x :e Empty.
		                 { rewrite <- HUeq. exact HxU. }
		                 exact (EmptyE x HxEmpty (x :e B)).
	               * assume HUeq: U = A.
	                 claim HxA: x :e A.
	                 { rewrite <- HUeq. exact HxU. }
	                 exact (HAB x HxA).
             + assume HU1: U :e {B}.
	               claim HUeq: U = B.
	               { exact (SingE B U HU1). }
	               rewrite <- HUeq.
	               exact HxU.
             + exact HU0.
           - assume HU0: U :e {X}.
	             claim HUeq: U = X.
	             { exact (SingE X U HU0). }
	             apply FalseE.
	             claim HXUF2: X :e UFam.
	             { rewrite <- HUeq. exact HUUF. }
	             exact (HXnot HXUF2).
           - exact HUinT.
         }
         claim HUnionEq: Union UFam = B.
         { apply set_ext.
           - exact HUnionSub.
           - let x. assume HxB: x :e B.
             exact (UnionI UFam x B HxB HBUF).
         }
         rewrite HUnionEq.
         exact (binunionI1 T0 {X} B (binunionI2 (UPair Empty A) {B} B (SingI B))).
      - assume HBnot: B /:e UFam.
         apply (xm (A :e UFam)).
         - assume HAUF: A :e UFam.
             claim HUnionSub: Union UFam c= A.
             { let x. assume Hx: x :e Union UFam.
               prove x :e A.
               apply UnionE_impred UFam x Hx.
               let U. assume HxU: x :e U. assume HUUF: U :e UFam.
               claim HUinT: U :e T.
               { exact (HUFsub U HUUF). }
               apply (binunionE' T0 {X} U (x :e A)).
               * assume HU0: U :e T0.
                 apply (binunionE' (UPair Empty A) {B} U (x :e A)).
                 + assume HU1: U :e UPair Empty A.
	                   apply (UPairE U Empty A HU1).
	                   - assume HUeq: U = Empty.
	                      claim HxEmpty: x :e Empty.
	                      { rewrite <- HUeq. exact HxU. }
	                      exact (EmptyE x HxEmpty (x :e A)).
	                   - assume HUeq: U = A.
	                      rewrite <- HUeq.
	                      exact HxU.
                 + assume HU1: U :e {B}.
	                   claim HUeq: U = B.
	                   { exact (SingE B U HU1). }
	                   apply FalseE.
	                   claim HBUF2: B :e UFam.
	                   { rewrite <- HUeq. exact HUUF. }
	                   exact (HBnot HBUF2).
                 + exact HU0.
               * assume HU0: U :e {X}.
	                 claim HUeq: U = X.
	                 { exact (SingE X U HU0). }
	                 apply FalseE.
	                 claim HXUF2: X :e UFam.
	                 { rewrite <- HUeq. exact HUUF. }
	                 exact (HXnot HXUF2).
               * exact HUinT.
             }
             claim HUnionEq: Union UFam = A.
             { apply set_ext.
               - exact HUnionSub.
               - let x. assume HxA: x :e A.
                 exact (UnionI UFam x A HxA HAUF).
             }
             rewrite HUnionEq.
             exact (binunionI1 T0 {X} A (binunionI1 (UPair Empty A) {B} A (UPairI2 Empty A))).
         - assume HAnot: A /:e UFam.
             claim HUnionEq: Union UFam = Empty.
             { apply set_ext.
               - let x. assume Hx: x :e Union UFam.
                 prove x :e Empty.
                 apply UnionE_impred UFam x Hx.
                 let U. assume HxU: x :e U. assume HUUF: U :e UFam.
                 claim HUinT: U :e T.
                 { exact (HUFsub U HUUF). }
                 apply (binunionE' T0 {X} U (x :e Empty)).
                 + assume HU0: U :e T0.
                   apply (binunionE' (UPair Empty A) {B} U (x :e Empty)).
                   * assume HU1: U :e UPair Empty A.
	                     apply (UPairE U Empty A HU1).
	                     - assume HUeq: U = Empty.
	                        rewrite <- HUeq.
	                        exact HxU.
	                     - assume HUeq: U = A.
	                        apply FalseE.
	                        claim HAUF2: A :e UFam.
	                        { rewrite <- HUeq. exact HUUF. }
	                        exact (HAnot HAUF2).
                   * assume HU1: U :e {B}.
	                     claim HUeq: U = B.
	                     { exact (SingE B U HU1). }
	                     apply FalseE.
	                     claim HBUF2: B :e UFam.
	                     { rewrite <- HUeq. exact HUUF. }
	                     exact (HBnot HBUF2).
                   * exact HU0.
                 + assume HU0: U :e {X}.
	                   claim HUeq: U = X.
	                   { exact (SingE X U HU0). }
	                   apply FalseE.
	                   claim HXUF2: X :e UFam.
	                   { rewrite <- HUeq. exact HUUF. }
	                   exact (HXnot HXUF2).
                 + exact HUinT.
               - let x. assume Hx: x :e Empty.
                 exact (EmptyE x Hx (x :e Union UFam)).
             }
             rewrite HUnionEq.
             exact HEmptyIn.
- let U. assume HU: U :e T.
  let V. assume HV: V :e T.
  prove U :/\: V :e T.
  apply (binunionE' T0 {X} U (U :/\: V :e T)).
  - assume HU0: U :e T0.
    apply (binunionE' (UPair Empty A) {B} U (U :/\: V :e T)).
    + assume HU1: U :e UPair Empty A.
      apply (UPairE U Empty A HU1).
      * assume HUeq: U = Empty.
        rewrite HUeq.
        claim HcapEq: Empty :/\: V = Empty.
        { apply set_ext.
          - let x. assume Hx: x :e Empty :/\: V.
            exact (binintersectE1 Empty V x Hx).
          - let x. assume Hx: x :e Empty.
            exact (binintersectI Empty V x Hx (EmptyE x Hx (x :e V))).
        }
        rewrite HcapEq.
        exact HEmptyIn.
      * assume HUeq: U = A.
        rewrite HUeq.
        apply (binunionE' T0 {X} V (A :/\: V :e T)).
        - assume HV0: V :e T0.
           apply (binunionE' (UPair Empty A) {B} V (A :/\: V :e T)).
           - assume HV1: V :e UPair Empty A.
               apply (UPairE V Empty A HV1).
               * assume HVeq: V = Empty.
                 rewrite HVeq.
                 claim HcapEq: A :/\: Empty = Empty.
                 { rewrite (binintersect_com A Empty). exact (binintersect_Subq_eq_1 Empty A (Subq_Empty A)). }
                 rewrite HcapEq.
                 exact HEmptyIn.
               * assume HVeq: V = A.
                 rewrite HVeq.
                 claim HcapEq: A :/\: A = A.
                 { exact (binintersect_Subq_eq_1 A A (Subq_ref A)). }
                 rewrite HcapEq.
                 exact (binunionI1 T0 {X} A (binunionI1 (UPair Empty A) {B} A (UPairI2 Empty A))).
           - assume HV1: V :e {B}.
               claim HVeq: V = B.
               { exact (SingE B V HV1). }
               rewrite HVeq.
               claim HcapEq: A :/\: B = A.
               { exact (binintersect_Subq_eq_1 A B HAB). }
               rewrite HcapEq.
               exact (binunionI1 T0 {X} A (binunionI1 (UPair Empty A) {B} A (UPairI2 Empty A))).
           - exact HV0.
        - assume HV0: V :e {X}.
           claim HVeq: V = X.
           { exact (SingE X V HV0). }
           rewrite HVeq.
           claim HcapEq: A :/\: X = A.
           { exact (binintersect_Subq_eq_1 A X HA_X). }
           rewrite HcapEq.
           exact (binunionI1 T0 {X} A (binunionI1 (UPair Empty A) {B} A (UPairI2 Empty A))).
        - exact HV.
    + assume HU1: U :e {B}.
      claim HUeq: U = B.
      { exact (SingE B U HU1). }
      rewrite HUeq.
      apply (binunionE' T0 {X} V (B :/\: V :e T)).
      * assume HV0: V :e T0.
        apply (binunionE' (UPair Empty A) {B} V (B :/\: V :e T)).
        - assume HV1: V :e UPair Empty A.
           apply (UPairE V Empty A HV1).
           - assume HVeq: V = Empty.
               rewrite HVeq.
               claim HcapEq: B :/\: Empty = Empty.
               { rewrite (binintersect_com B Empty). exact (binintersect_Subq_eq_1 Empty B (Subq_Empty B)). }
               rewrite HcapEq.
               exact HEmptyIn.
           - assume HVeq: V = A.
               rewrite HVeq.
               claim HcapEq: B :/\: A = A.
               { rewrite (binintersect_com B A). exact (binintersect_Subq_eq_1 A B HAB). }
               rewrite HcapEq.
               exact (binunionI1 T0 {X} A (binunionI1 (UPair Empty A) {B} A (UPairI2 Empty A))).
        - assume HV1: V :e {B}.
           claim HVeq: V = B.
           { exact (SingE B V HV1). }
           rewrite HVeq.
           claim HcapEq: B :/\: B = B.
           { exact (binintersect_Subq_eq_1 B B (Subq_ref B)). }
           rewrite HcapEq.
           exact (binunionI1 T0 {X} B (binunionI2 (UPair Empty A) {B} B (SingI B))).
        - exact HV0.
      * assume HV0: V :e {X}.
        claim HVeq: V = X.
        { exact (SingE X V HV0). }
        rewrite HVeq.
        claim HcapEq: B :/\: X = B.
        { exact (binintersect_Subq_eq_1 B X HBX). }
        rewrite HcapEq.
        exact (binunionI1 T0 {X} B (binunionI2 (UPair Empty A) {B} B (SingI B))).
      * exact HV.
    + exact HU0.
  - assume HU0: U :e {X}.
    claim HUeq: U = X.
    { exact (SingE X U HU0). }
    rewrite HUeq.
    claim HVpow: V :e Power X.
    { exact (HTPow V HV). }
    claim HVsub: V c= X.
    { exact (PowerE X V HVpow). }
    claim HcapEq: X :/\: V = V.
    { rewrite (binintersect_com X V). exact (binintersect_Subq_eq_1 V X HVsub). }
    rewrite HcapEq.
    exact HV.
  - exact HU.
Qed.

Theorem ex13_2_compare_nine_topologies :
  topology_on abc_set top_abc_1 /\ topology_on abc_set top_abc_2 /\
  topology_on abc_set top_abc_3 /\ topology_on abc_set top_abc_4 /\
  topology_on abc_set top_abc_5 /\ topology_on abc_set top_abc_6 /\
  topology_on abc_set top_abc_7 /\ topology_on abc_set top_abc_8 /\
  topology_on abc_set top_abc_9 /\
  exists finer_pairs:set,
    finer_pairs =
      {p :e Power (Power (Power abc_set))|
         exists T1 T2:set, p = setprod T1 T2 /\
           (T1 = top_abc_1 \/ T1 = top_abc_2 \/ T1 = top_abc_3 \/
            T1 = top_abc_4 \/ T1 = top_abc_5 \/ T1 = top_abc_6 \/
            T1 = top_abc_7 \/ T1 = top_abc_8 \/ T1 = top_abc_9) /\
           (T2 = top_abc_1 \/ T2 = top_abc_2 \/ T2 = top_abc_3 \/
            T2 = top_abc_4 \/ T2 = top_abc_5 \/ T2 = top_abc_6 \/
           T2 = top_abc_7 \/ T2 = top_abc_8 \/ T2 = top_abc_9) /\
           T1 c= T2}.
prove topology_on abc_set top_abc_1 /\ topology_on abc_set top_abc_2 /\
  topology_on abc_set top_abc_3 /\ topology_on abc_set top_abc_4 /\
  topology_on abc_set top_abc_5 /\ topology_on abc_set top_abc_6 /\
  topology_on abc_set top_abc_7 /\ topology_on abc_set top_abc_8 /\
  topology_on abc_set top_abc_9 /\
  exists finer_pairs:set,
    finer_pairs =
      {p :e Power (Power (Power abc_set))|
         exists T1 T2:set, p = setprod T1 T2 /\
           (T1 = top_abc_1 \/ T1 = top_abc_2 \/ T1 = top_abc_3 \/
            T1 = top_abc_4 \/ T1 = top_abc_5 \/ T1 = top_abc_6 \/
            T1 = top_abc_7 \/ T1 = top_abc_8 \/ T1 = top_abc_9) /\
           (T2 = top_abc_1 \/ T2 = top_abc_2 \/ T2 = top_abc_3 \/
            T2 = top_abc_4 \/ T2 = top_abc_5 \/ T2 = top_abc_6 \/
           T2 = top_abc_7 \/ T2 = top_abc_8 \/ T2 = top_abc_9) /\
           T1 c= T2}.
apply andI.
- (** nine topology axioms **)
  apply andI.
  - apply andI.
    - apply andI.
      - apply andI.
        - apply andI.
          - apply andI.
            - apply andI.
	              - apply andI.
	                - (** topology_on abc_set top_abc_1 **)
	                  claim Ht1: top_abc_1 = indiscrete_topology abc_set.
	                  { reflexivity. }
	                  rewrite Ht1.
	                  exact (indiscrete_topology_on abc_set).
	                - (** topology_on abc_set top_abc_2 **)
                  claim Ht2: top_abc_2 = discrete_topology abc_set.
                  { reflexivity. }
                  rewrite Ht2.
                  exact (discrete_topology_on abc_set).
              - (** topology_on abc_set top_abc_3 **)
                claim HA: {a_elt} c= abc_set.
                { let x. assume Hx: x :e {a_elt}.
                  prove x :e abc_set.
                  claim Hxeq: x = a_elt.
                  { exact (SingE a_elt x Hx). }
                  rewrite Hxeq.
                  exact (binunionI1 (UPair a_elt b_elt) {c_elt} a_elt (UPairI1 a_elt b_elt)).
                }
                exact (topology_three_sets abc_set {a_elt} HA).
            - (** topology_on abc_set top_abc_4 **)
              claim HB: {b_elt} c= abc_set.
              { let x. assume Hx: x :e {b_elt}.
                prove x :e abc_set.
                claim Hxeq: x = b_elt.
                { exact (SingE b_elt x Hx). }
                rewrite Hxeq.
                exact (binunionI1 (UPair a_elt b_elt) {c_elt} b_elt (UPairI2 a_elt b_elt)).
              }
              exact (topology_three_sets abc_set {b_elt} HB).
          - (** topology_on abc_set top_abc_5 **)
            claim HC: {c_elt} c= abc_set.
            { let x. assume Hx: x :e {c_elt}.
              prove x :e abc_set.
              claim Hxeq: x = c_elt.
              { exact (SingE c_elt x Hx). }
              rewrite Hxeq.
              exact (binunionI2 (UPair a_elt b_elt) {c_elt} c_elt (SingI c_elt)).
            }
            exact (topology_three_sets abc_set {c_elt} HC).
        - (** topology_on abc_set top_abc_6 **)
          claim HAB: (UPair a_elt b_elt) c= abc_set.
          { let x. assume Hx: x :e UPair a_elt b_elt.
            prove x :e abc_set.
            apply (UPairE x a_elt b_elt Hx).
            - assume Hxeq: x = a_elt.
              rewrite Hxeq.
              exact (binunionI1 (UPair a_elt b_elt) {c_elt} a_elt (UPairI1 a_elt b_elt)).
            - assume Hxeq: x = b_elt.
              rewrite Hxeq.
              exact (binunionI1 (UPair a_elt b_elt) {c_elt} b_elt (UPairI2 a_elt b_elt)).
          }
          exact (topology_three_sets abc_set (UPair a_elt b_elt) HAB).
      - (** topology_on abc_set top_abc_7 **)
        claim HAC: (UPair a_elt c_elt) c= abc_set.
        { let x. assume Hx: x :e UPair a_elt c_elt.
          prove x :e abc_set.
          apply (UPairE x a_elt c_elt Hx).
          - assume Hxeq: x = a_elt.
            rewrite Hxeq.
            exact (binunionI1 (UPair a_elt b_elt) {c_elt} a_elt (UPairI1 a_elt b_elt)).
          - assume Hxeq: x = c_elt.
            rewrite Hxeq.
            exact (binunionI2 (UPair a_elt b_elt) {c_elt} c_elt (SingI c_elt)).
        }
        exact (topology_three_sets abc_set (UPair a_elt c_elt) HAC).
    - (** topology_on abc_set top_abc_8 **)
      claim HBC: (UPair b_elt c_elt) c= abc_set.
      { let x. assume Hx: x :e UPair b_elt c_elt.
        prove x :e abc_set.
        apply (UPairE x b_elt c_elt Hx).
        - assume Hxeq: x = b_elt.
          rewrite Hxeq.
          exact (binunionI1 (UPair a_elt b_elt) {c_elt} b_elt (UPairI2 a_elt b_elt)).
        - assume Hxeq: x = c_elt.
          rewrite Hxeq.
          exact (binunionI2 (UPair a_elt b_elt) {c_elt} c_elt (SingI c_elt)).
      }
      exact (topology_three_sets abc_set (UPair b_elt c_elt) HBC).
  - (** topology_on abc_set top_abc_9 **)
    claim HAinAB: {a_elt} c= UPair a_elt b_elt.
    { let x. assume Hx: x :e {a_elt}.
      prove x :e UPair a_elt b_elt.
      claim Hxeq: x = a_elt.
      { exact (SingE a_elt x Hx). }
      rewrite Hxeq.
      exact (UPairI1 a_elt b_elt).
    }
    claim HABsubX: UPair a_elt b_elt c= abc_set.
    { let x. assume Hx: x :e UPair a_elt b_elt.
      prove x :e abc_set.
      exact (binunionI1 (UPair a_elt b_elt) {c_elt} x Hx).
    }
    exact (topology_chain_four_sets abc_set {a_elt} (UPair a_elt b_elt) HAinAB HABsubX).
- (** finer_pairs set of refinement pairs **)
  witness
    {p :e Power (Power (Power abc_set))|
       exists T1 T2:set, p = setprod T1 T2 /\
         (T1 = top_abc_1 \/ T1 = top_abc_2 \/ T1 = top_abc_3 \/
          T1 = top_abc_4 \/ T1 = top_abc_5 \/ T1 = top_abc_6 \/
          T1 = top_abc_7 \/ T1 = top_abc_8 \/ T1 = top_abc_9) /\
         (T2 = top_abc_1 \/ T2 = top_abc_2 \/ T2 = top_abc_3 \/
          T2 = top_abc_4 \/ T2 = top_abc_5 \/ T2 = top_abc_6 \/
          T2 = top_abc_7 \/ T2 = top_abc_8 \/ T2 = top_abc_9) /\
         T1 c= T2}.
  reflexivity.
Qed.

(** from 13 Exercise 2: some basic fineness relations between the nine examples **)
(** LATEX VERSION: Exercise 2 asks to compare the nine topologies by inclusion (finer/coarser). **)
Theorem top_abc_3_finer_than_top_abc_1 : finer_than top_abc_3 top_abc_1.
let U. assume HU: U :e top_abc_1.
prove U :e top_abc_3.
apply (UPairE U Empty abc_set HU).
- assume HUeq: U = Empty.
  rewrite HUeq.
  exact (binunionI1 (UPair Empty {a_elt}) {abc_set} Empty (UPairI1 Empty {a_elt})).
- assume HUeq: U = abc_set.
  rewrite HUeq.
  exact (binunionI2 (UPair Empty {a_elt}) {abc_set} abc_set (SingI abc_set)).
Qed.

Theorem top_abc_2_finer_than_top_abc_3 : finer_than top_abc_2 top_abc_3.
let U. assume HU: U :e top_abc_3.
prove U :e top_abc_2.
(** top_abc_2 = Power abc_set; show U c= abc_set **)
claim Ht2: top_abc_2 = Power abc_set.
{ reflexivity. }
rewrite Ht2.
apply PowerI.
let x. assume Hx: x :e U.
prove x :e abc_set.
apply (binunionE' (UPair Empty {a_elt}) {abc_set} U (x :e abc_set)).
- assume HU0: U :e UPair Empty {a_elt}.
  apply (UPairE U Empty {a_elt} HU0).
  + assume HUeq: U = Empty.
    claim HxEmpty: x :e Empty.
    { rewrite <- HUeq. exact Hx. }
    exact (EmptyE x HxEmpty (x :e abc_set)).
  + assume HUeq: U = {a_elt}.
    claim HxSing: x :e {a_elt}.
    { rewrite <- HUeq. exact Hx. }
    claim Hxeq: x = a_elt.
    { exact (SingE a_elt x HxSing). }
    rewrite Hxeq.
    exact (binunionI1 (UPair a_elt b_elt) {c_elt} a_elt (UPairI1 a_elt b_elt)).
- assume HU0: U :e {abc_set}.
  claim HUeq: U = abc_set.
  { exact (SingE abc_set U HU0). }
  rewrite <- HUeq.
  exact Hx.
- exact HU.
Qed.

Theorem top_abc_9_finer_than_top_abc_3 : finer_than top_abc_9 top_abc_3.
let U. assume HU: U :e top_abc_3.
prove U :e top_abc_9.
apply (binunionE' (UPair Empty {a_elt}) {abc_set} U (U :e top_abc_9)).
- assume HU0: U :e UPair Empty {a_elt}.
  exact (binunionI1 (UPair Empty {a_elt} :\/: {UPair a_elt b_elt}) {abc_set} U
          (binunionI1 (UPair Empty {a_elt}) {UPair a_elt b_elt} U HU0)).
- assume HU0: U :e {abc_set}.
  claim HUeq: U = abc_set.
  { exact (SingE abc_set U HU0). }
  rewrite HUeq.
  exact (binunionI2 (UPair Empty {a_elt} :\/: {UPair a_elt b_elt}) {abc_set} abc_set (SingI abc_set)).
- exact HU.
Qed.

Theorem top_abc_9_finer_than_top_abc_6 : finer_than top_abc_9 top_abc_6.
let U. assume HU: U :e top_abc_6.
prove U :e top_abc_9.
apply (binunionE' (UPair Empty (UPair a_elt b_elt)) {abc_set} U (U :e top_abc_9)).
- assume HU0: U :e UPair Empty (UPair a_elt b_elt).
  apply (UPairE U Empty (UPair a_elt b_elt) HU0).
  + assume HUeq: U = Empty.
    rewrite HUeq.
    exact (binunionI1 (UPair Empty {a_elt} :\/: {UPair a_elt b_elt}) {abc_set} Empty
            (binunionI1 (UPair Empty {a_elt}) {UPair a_elt b_elt} Empty (UPairI1 Empty {a_elt}))).
  + assume HUeq: U = UPair a_elt b_elt.
    rewrite HUeq.
    exact (binunionI1 (UPair Empty {a_elt} :\/: {UPair a_elt b_elt}) {abc_set} (UPair a_elt b_elt)
            (binunionI2 (UPair Empty {a_elt}) {UPair a_elt b_elt} (UPair a_elt b_elt) (SingI (UPair a_elt b_elt)))).
- assume HU0: U :e {abc_set}.
  claim HUeq: U = abc_set.
  { exact (SingE abc_set U HU0). }
  rewrite HUeq.
  exact (binunionI2 (UPair Empty {a_elt} :\/: {UPair a_elt b_elt}) {abc_set} abc_set (SingI abc_set)).
- exact HU.
Qed.

(** helper for 13 exercises: intersection of a family of topologies (placeholder) **)
(** LATEX VERSION: Intersection_Fam X Fam denotes the intersection (common opens) of all topologies in Fam. **)
(** FIXED: `Intersection_Fam X Fam` is the collection of common open sets, as subsets of the given ambient set `X`; for `Fam = Empty`, `Intersection_Fam X Fam = Power X`. **)
Definition Intersection_Fam : set -> set -> set :=
  fun X Fam => {U :e Power X|forall T:set, T :e Fam -> U :e T}.

(** helper: empty family gives discrete topology **)
Theorem Intersection_Fam_empty_eq : forall X Fam:set,
  ~(exists T:set, T :e Fam) ->
  Intersection_Fam X Fam = Power X.
let X Fam.
assume HFamEmpty: ~(exists T:set, T :e Fam).
apply set_ext.
- let U. assume HU: U :e Intersection_Fam X Fam.
  exact (SepE1 (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) U HU).
- let U. assume HU: U :e Power X.
  claim HAllT: forall T:set, T :e Fam -> U :e T.
  { let T. assume HT: T :e Fam.
    apply FalseE.
    apply HFamEmpty.
    witness T. exact HT.
  }
  exact (SepI (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) U HU HAllT).
Qed.

(** helper: intersection of a family stays within X (updated for new signature) **)
Theorem intersection_of_family_sub_X : forall X Fam:set,
  intersection_of_family X Fam c= X.
let X Fam.
let x. assume Hx.
exact (SepE1 X (fun x0 => forall U:set, U :e Fam -> x0 :e U) x Hx).
Qed.

(** helper: empty set is in intersection family when all members contain Empty **)
Theorem intersection_of_family_empty : forall Fam:set,
  (forall T:set, T :e Fam -> Empty :e T) ->
  forall X:set, Empty :e Intersection_Fam X Fam.
let Fam.
assume HFamEmpty: forall T:set, T :e Fam -> Empty :e T.
let X.
prove Empty :e Intersection_Fam X Fam.
(** Intersection_Fam X Fam = {U :e Power X | forall T :e Fam, U :e T} **)
claim HEmptyPower: Empty :e Power X.
{ apply PowerI. apply Subq_Empty. }
exact (SepI (Power X) (fun U => forall T:set, T :e Fam -> U :e T) Empty HEmptyPower HFamEmpty).
Qed.

(** from 12 Exercises Item 3: countable complement topology and Tinfty **) 
(** LATEX VERSION: Show that the collection Tc from Example 4 of 12 is a topology on X. Is the collection Tinfty = {U | X-U is infinite or empty or all of X} a topology on X. **)
Definition infinite_complement_family : set -> set :=
  fun X => {U :e Power X | infinite (X :\: U) \/ U = Empty \/ U = X}.

(** LATEX VERSION: Exercise 3: The countable-complement topology Tc on X is a topology. **)
Theorem ex13_3a_Tc_topology : forall X:set, topology_on X (countable_complement_topology X).
let X.
exact (countable_complement_topology_on X).
Qed.

(** helper: nonempty open sets in T_c have countable complement (placeholder) **) 
Theorem ex13_3a_countable_complement_open : forall X:set, forall U :e countable_complement_topology X,
  U <> Empty -> countable (X :\: U).
let X U.
assume HU: U :e countable_complement_topology X.
assume Hnemp: U <> Empty.
prove countable (X :\: U).
(** By definition, U  countable_complement_topology X means countable(X\\U)  U = Empty; since U  Empty, we get countable(X\\U). **)
claim Hprop: countable (X :\: U) \/ U = Empty.
{ exact (SepE2 (Power X) (fun V:set => countable (X :\: V) \/ V = Empty) U HU). }
claim Hcount_branch: countable (X :\: U) -> countable (X :\: U).
{ assume Hcount. exact Hcount. }
claim Hempty_branch: U = Empty -> countable (X :\: U).
{ assume HUeq.
  apply FalseE.
  exact (Hnemp HUeq). }
exact (Hprop (countable (X :\: U)) Hcount_branch Hempty_branch).
Qed.

(** helper: unions of Tc open families remain Tc-open (placeholder) **) 
Theorem ex13_3a_union_helper : forall X:set, forall UFam :e Power (countable_complement_topology X),
  Union UFam :e countable_complement_topology X.
let X UFam.
assume HUFam: UFam :e Power (countable_complement_topology X).
prove Union UFam :e countable_complement_topology X.
(** This follows from countable_complement_topology_on plus the union axiom of topology_on **)
claim Htop : topology_on X (countable_complement_topology X).
{ exact (countable_complement_topology_on X). }
exact (topology_union_axiom X (countable_complement_topology X) Htop UFam HUFam).
Qed.

(** helper: removing a finite subset from an infinite set leaves an infinite set **)
(** LATEX VERSION: If X is infinite and F is finite, then X\\F is infinite. **)
Theorem infinite_setminus_finite : forall X F:set,
  infinite X -> finite F -> infinite (X :\: F).
let X F.
assume HinfX: infinite X.
assume HfinF: finite F.
prove infinite (X :\: F).
assume HfinXF: finite (X :\: F).
claim HfinU: finite ((X :\: F) :\/: F).
{ exact (binunion_finite (X :\: F) HfinXF F HfinF). }
claim HXsubU: X c= (X :\: F) :\/: F.
{ let x. assume HxX: x :e X.
  apply (xm (x :e F)).
  - assume HxF: x :e F.
    exact (binunionI2 (X :\: F) F x HxF).
  - assume HxnotF: ~(x :e F).
    claim HxXF: x :e X :\: F.
    { exact (setminusI X F x HxX HxnotF). }
    exact (binunionI1 (X :\: F) F x HxXF).
}
claim HfinX: finite X.
{ exact (Subq_finite ((X :\: F) :\/: F) HfinU X HXsubU). }
exact (HinfX HfinX).
Qed.

Theorem ex13_3b_witness_sets : forall X:set,
  infinite X ->
  exists U V:set,
    U :e infinite_complement_family X /\ V :e infinite_complement_family X /\
    ~(Union (UPair U V) :e infinite_complement_family X).
let X.
assume HinfX: infinite X.
prove exists U V:set,
  U :e infinite_complement_family X /\ V :e infinite_complement_family X /\
  ~(Union (UPair U V) :e infinite_complement_family X).
(** SUSPICIOUS DEFINITION: This needs a set-theoretic construction on an arbitrary infinite set X producing U,V with infinite complements but with (X\\(UV)) finite nonempty; this is nontrivial in this development, so the witness construction is currently admitted. **)
admit.
Qed.

(** LATEX VERSION: Exercise 3: For infinite X, Tinfty is not a topology (union-closure fails). **)
Theorem ex13_3b_Tinfty_not_topology : forall X:set,
  infinite X ->
  ~topology_on X (infinite_complement_family X).
let X.
assume HinfX: infinite X.
assume Htop: topology_on X (infinite_complement_family X).
prove False.
(** Extract union-closure axiom from topology_on **)
claim H1:
  ((infinite_complement_family X c= Power X /\ Empty :e infinite_complement_family X) /\ X :e infinite_complement_family X) /\
  (forall UFam :e Power (infinite_complement_family X), Union UFam :e infinite_complement_family X).
{ exact (andEL (((infinite_complement_family X c= Power X /\ Empty :e infinite_complement_family X) /\ X :e infinite_complement_family X) /\
               (forall UFam :e Power (infinite_complement_family X), Union UFam :e infinite_complement_family X))
              (forall U :e infinite_complement_family X,
                 forall V :e infinite_complement_family X,
                   U :/\: V :e infinite_complement_family X)
              Htop). }
claim HUnionClosure: forall UFam :e Power (infinite_complement_family X),
  Union UFam :e infinite_complement_family X.
{ exact (andER ((infinite_complement_family X c= Power X /\ Empty :e infinite_complement_family X) /\ X :e infinite_complement_family X)
              (forall UFam :e Power (infinite_complement_family X), Union UFam :e infinite_complement_family X)
              H1). }
(** Use the (admitted) witness sets showing union failure **)
apply (ex13_3b_witness_sets X HinfX).
let U.
assume HexV.
apply HexV.
let V.
assume HUV.
claim Hcore: U :e infinite_complement_family X /\ V :e infinite_complement_family X.
{ exact (andEL (U :e infinite_complement_family X /\ V :e infinite_complement_family X)
              (~(Union (UPair U V) :e infinite_complement_family X))
              HUV). }
claim Hnot: ~(Union (UPair U V) :e infinite_complement_family X).
{ exact (andER (U :e infinite_complement_family X /\ V :e infinite_complement_family X)
              (~(Union (UPair U V) :e infinite_complement_family X))
              HUV). }
claim HU: U :e infinite_complement_family X.
{ exact (andEL (U :e infinite_complement_family X) (V :e infinite_complement_family X) Hcore). }
claim HV: V :e infinite_complement_family X.
{ exact (andER (U :e infinite_complement_family X) (V :e infinite_complement_family X) Hcore). }
claim HUVsub: UPair U V c= infinite_complement_family X.
{ let W. assume HW: W :e UPair U V.
  apply (UPairE W U V HW (W :e infinite_complement_family X)).
  - assume HWU: W = U. rewrite HWU. exact HU.
  - assume HWV: W = V. rewrite HWV. exact HV.
}
claim HUVinPower: UPair U V :e Power (infinite_complement_family X).
{ apply PowerI. exact HUVsub. }
claim HUnionIn: Union (UPair U V) :e infinite_complement_family X.
{ exact (HUnionClosure (UPair U V) HUVinPower). }
exact (Hnot HUnionIn).
Qed.

(** helper: structured witness outline for Tinfty failure, for infinite ambient sets **) 
Theorem ex13_3b_witness_outline : forall X:set,
  infinite X -> exists U V:set, U :e infinite_complement_family X /\ V :e infinite_complement_family X.
let X.
assume HinfX: infinite X.
prove exists U V:set, U :e infinite_complement_family X /\ V :e infinite_complement_family X.
witness Empty.
witness X.
apply andI.
- (** Empty is in the family by the defining disjunction **)
  prove Empty :e infinite_complement_family X.
  claim Hdisj : infinite (X :\: Empty) \/ Empty = Empty \/ Empty = X.
  { apply orIL.
    apply orIR.
    reflexivity. }
  exact (SepI (Power X)
              (fun U0 : set => infinite (X :\: U0) \/ U0 = Empty \/ U0 = X)
              Empty
              (Empty_In_Power X)
              Hdisj).
- (** X is in the family by the defining disjunction **)
  prove X :e infinite_complement_family X.
  claim Hdisj : infinite (X :\: X) \/ X = Empty \/ X = X.
  { apply orIR.
    reflexivity. }
  exact (SepI (Power X)
              (fun U0 : set => infinite (X :\: U0) \/ U0 = Empty \/ U0 = X)
              X
              (Self_In_Power X)
              Hdisj).
Qed.

(** from 13 Exercise 4(a): intersection of topologies **)
(** LATEX VERSION: Exercise 4(a): The intersection of a nonempty family of topologies on X is a topology. **)
Theorem ex13_4a_intersection_topology : forall X Fam:set,
  (exists T:set, T :e Fam) ->
  (forall T :e Fam, topology_on X T) ->
  topology_on X (Intersection_Fam X Fam).
let X Fam.
assume HFamNonempty: exists T:set, T :e Fam.
assume HfamTop: forall T :e Fam, topology_on X T.
prove topology_on X (Intersection_Fam X Fam).
prove Intersection_Fam X Fam c= Power X
  /\ Empty :e Intersection_Fam X Fam
  /\ X :e Intersection_Fam X Fam
  /\ (forall UFam :e Power (Intersection_Fam X Fam), Union UFam :e Intersection_Fam X Fam)
  /\ (forall U :e Intersection_Fam X Fam, forall V :e Intersection_Fam X Fam, U :/\: V :e Intersection_Fam X Fam).
apply andI.
- (** Left part: subset, empty, X, union **)
  apply andI.
  + (** Left part: subset, empty, X **)
    apply andI.
    * (** Left part: subset and empty **)
      apply andI.
      { (** Axiom 1: Intersection_Fam X Fam c= Power X **)
        let U. assume HU: U :e Intersection_Fam X Fam.
        prove U :e Power X.
        exact (SepE1 (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) U HU).
      }
      { (** Axiom 2: Empty :e Intersection_Fam X Fam **)
        prove Empty :e Intersection_Fam X Fam.
        claim HEmptyPower: Empty :e Power X.
        { exact (Empty_In_Power X). }
        claim HEmptyAllT: forall T:set, T :e Fam -> Empty :e T.
        { let T. assume HT: T :e Fam.
          exact (topology_has_empty X T (HfamTop T HT)).
        }
        exact (SepI (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) Empty HEmptyPower HEmptyAllT).
      }
    * (** Axiom 3: X :e Intersection_Fam X Fam **)
      prove X :e Intersection_Fam X Fam.
      claim HXPower: X :e Power X.
      { exact (Self_In_Power X). }
      claim HXAllT: forall T:set, T :e Fam -> X :e T.
      { let T. assume HT: T :e Fam.
        exact (topology_has_X X T (HfamTop T HT)).
      }
      exact (SepI (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) X HXPower HXAllT).
  + (** Axiom 4: unions preserved **)
    let UFam. assume HUFamPow: UFam :e Power (Intersection_Fam X Fam).
    prove Union UFam :e Intersection_Fam X Fam.
    claim HUFamSubInter: UFam c= Intersection_Fam X Fam.
    { exact (PowerE (Intersection_Fam X Fam) UFam HUFamPow). }
    claim HUFamSubPowX: UFam c= Power X.
    { let U. assume HUinUFam: U :e UFam.
      claim HUinInter: U :e Intersection_Fam X Fam.
      { exact (HUFamSubInter U HUinUFam). }
      exact (SepE1 (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) U HUinInter).
    }
    claim HUnionPower: Union UFam :e Power X.
    { apply PowerI.
      exact (Union_Power X UFam HUFamSubPowX).
    }
    claim HUnionAllT: forall T:set, T :e Fam -> Union UFam :e T.
    { let T. assume HT: T :e Fam.
      claim HTtop: topology_on X T.
      { exact (HfamTop T HT). }
      claim HUFamSubT: UFam c= T.
      { let U. assume HUinUFam: U :e UFam.
        claim HUinInter: U :e Intersection_Fam X Fam.
        { exact (HUFamSubInter U HUinUFam). }
        claim HUinAllT: forall T0:set, T0 :e Fam -> U :e T0.
        { exact (SepE2 (Power X) (fun U0 => forall T0:set, T0 :e Fam -> U0 :e T0) U HUinInter). }
        exact (HUinAllT T HT).
      }
      claim HUFamPowT: UFam :e Power T.
      { apply PowerI. exact HUFamSubT. }
      exact (topology_union_axiom X T HTtop UFam HUFamPowT).
    }
    exact (SepI (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) (Union UFam) HUnionPower HUnionAllT).
- (** Axiom 5: binary intersections preserved **)
  let U. assume HU: U :e Intersection_Fam X Fam.
  let V. assume HV: V :e Intersection_Fam X Fam.
  prove U :/\: V :e Intersection_Fam X Fam.
  claim HUinPower: U :e Power X.
  { exact (SepE1 (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) U HU). }
  claim HVinPower: V :e Power X.
  { exact (SepE1 (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) V HV). }
  claim HUVPower: U :/\: V :e Power X.
  { exact (binintersect_Power X U V HUinPower HVinPower). }
  claim HUVinAllT: forall T:set, T :e Fam -> U :/\: V :e T.
  { let T. assume HT: T :e Fam.
    claim HTtop: topology_on X T.
    { exact (HfamTop T HT). }
    claim HUT: U :e T.
    { exact ((SepE2 (Power X) (fun U0 => forall T0:set, T0 :e Fam -> U0 :e T0) U HU) T HT). }
    claim HVT: V :e T.
    { exact ((SepE2 (Power X) (fun U0 => forall T0:set, T0 :e Fam -> U0 :e T0) V HV) T HT). }
    exact (topology_binintersect_axiom X T HTtop U HUT V HVT).
  }
  exact (SepI (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) (U :/\: V) HUVPower HUVinAllT).
Qed.

(** from 13 Exercise 4(b): smallest/largest topology containing a family **) 
(** LATEX VERSION: Exercise 4(b): There exist smallest and largest topologies containing a given family of topologies on X. **)
Theorem ex13_4b_smallest_largest : forall X Fam:set,
  (forall T :e Fam, topology_on X T) ->
  exists Tmin, topology_on X Tmin /\ (forall T :e Fam, T c= Tmin) /\
    (forall T', topology_on X T' /\ (forall T :e Fam, T c= T') -> Tmin c= T') /\
  exists Tmax, topology_on X Tmax /\ (forall T :e Fam, Tmax c= T) /\
    (forall T', topology_on X T' /\ (forall T :e Fam, T' c= T) -> T' c= Tmax).
let X Fam.
assume HfamTop: forall T :e Fam, topology_on X T.
prove exists Tmin, topology_on X Tmin /\ (forall T :e Fam, T c= Tmin) /\ (forall T', topology_on X T' /\ (forall T :e Fam, T c= T') -> Tmin c= T') /\ exists Tmax, topology_on X Tmax /\ (forall T :e Fam, Tmax c= T) /\ (forall T', topology_on X T' /\ (forall T :e Fam, T' c= T) -> T' c= Tmax).
		(** Strategy: Tmax = Intersection_Fam X Fam (by ex13_4a_intersection_topology); Tmin = generated_topology_from_subbasis X (Union Fam :\/: {X}) (adding X so the subbasis union equals X even if Fam is empty). **)
set Tmax := Intersection_Fam X Fam.
set Tmin := generated_topology_from_subbasis X (Union Fam :\/: {X}).
(** First prove Tmax properties **)
claim HTmax_topology: topology_on X Tmax.
{ apply (xm (exists T:set, T :e Fam)).
  - assume HFamNonempty: exists T:set, T :e Fam.
    exact (ex13_4a_intersection_topology X Fam HFamNonempty HfamTop).
  - assume HFamEmpty: ~(exists T:set, T :e Fam).
    (** If `Fam` is empty then `Intersection_Fam X Fam = Power X`, i.e. the discrete topology. **)
    rewrite (Intersection_Fam_empty_eq X Fam HFamEmpty).
    exact (discrete_topology_on X).
}
claim HTmax_subset_all: forall T :e Fam, Tmax c= T.
{ let T. assume HT: T :e Fam.
  (** Tmax = Intersection_Fam X Fam = {U :e Power X | forall T :e Fam, U :e T} **)
  (** So every U in Tmax is in every T in Fam, hence Tmax c= T **)
  let U. assume HU: U :e Tmax.
  claim HUinT: U :e T.
  { claim HUinAllT: forall T0:set, T0 :e Fam -> U :e T0.
    { exact (SepE2 (Power X) (fun U0 => forall T0:set, T0 :e Fam -> U0 :e T0) U HU). }
    exact (HUinAllT T HT).
  }
  exact HUinT.
}
claim HTmax_maximal: forall T', topology_on X T' /\ (forall T :e Fam, T' c= T) -> T' c= Tmax.
{ let T'. assume HT'_cond.
  claim HT'_top: topology_on X T'.
  { exact (andEL (topology_on X T') (forall T :e Fam, T' c= T) HT'_cond). }
  claim HT'_sub_all: forall T :e Fam, T' c= T.
  { exact (andER (topology_on X T') (forall T :e Fam, T' c= T) HT'_cond). }
  (** Need to show T' c= Tmax, i.e., every U in T' is in Tmax **)
  (** U :e Tmax iff U :e Power X and forall T :e Fam, U :e T **)
  let U. assume HU: U :e T'.
  (** Show U :e Tmax = Intersection_Fam X Fam **)
  claim HUinPower: U :e Power X.
  { claim HT'_sub_PowerX: T' c= Power X.
    { claim H1: ((T' c= Power X /\ Empty :e T') /\ X :e T') /\ (forall UFam :e Power T', Union UFam :e T').
      { exact (andEL (((T' c= Power X /\ Empty :e T') /\ X :e T') /\ (forall UFam :e Power T', Union UFam :e T')) (forall U0 :e T', forall V :e T', U0 :/\: V :e T') HT'_top). }
      claim H2: (T' c= Power X /\ Empty :e T') /\ X :e T'.
      { exact (andEL ((T' c= Power X /\ Empty :e T') /\ X :e T') (forall UFam :e Power T', Union UFam :e T') H1). }
      claim H3: T' c= Power X /\ Empty :e T'.
      { exact (andEL (T' c= Power X /\ Empty :e T') (X :e T') H2). }
      exact (andEL (T' c= Power X) (Empty :e T') H3).
    }
    exact (HT'_sub_PowerX U HU).
  }
  claim HUinAllT: forall T :e Fam, U :e T.
  { let T. assume HT: T :e Fam.
    claim HT'subT: T' c= T.
    { exact (HT'_sub_all T HT). }
    exact (HT'subT U HU).
  }
  exact (SepI (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) U HUinPower HUinAllT).
}
(** Now prove Tmin properties **)
(** First show Union Fam is a subbasis **)
claim HUnionFam_subbasis: subbasis_on X (Union Fam :\/: {X}).
{ (** subbasis_on X S := (S c= Power X) /\ Union S = X **)
  prove (Union Fam :\/: {X}) c= Power X /\ Union (Union Fam :\/: {X}) = X.
  apply andI.
  - (** Union Fam :\/: {X} c= Power X **)
    let U. assume HU: U :e Union Fam :\/: {X}.
    prove U :e Power X.
    apply (binunionE' (Union Fam) {X} U (U :e Power X)).
    + assume HUinUnion: U :e Union Fam.
      apply UnionE_impred Fam U HUinUnion.
      let T. assume HUT: U :e T. assume HT: T :e Fam.
      claim HTtop: topology_on X T.
      { exact (HfamTop T HT). }
      claim H1: ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T).
      { exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) (forall U0 :e T, forall V :e T, U0 :/\: V :e T) HTtop). }
      claim H2: (T c= Power X /\ Empty :e T) /\ X :e T.
      { exact (andEL ((T c= Power X /\ Empty :e T) /\ X :e T) (forall UFam :e Power T, Union UFam :e T) H1). }
      claim H3: T c= Power X /\ Empty :e T.
      { exact (andEL (T c= Power X /\ Empty :e T) (X :e T) H2). }
      claim HTsub: T c= Power X.
      { exact (andEL (T c= Power X) (Empty :e T) H3). }
      exact (HTsub U HUT).
    + assume HUinSing: U :e {X}.
      claim HUeq: U = X.
      { exact (SingE X U HUinSing). }
      rewrite HUeq.
      exact (PowerI X X (Subq_ref X)).
    + exact HU.
  - (** Union (Union Fam :\/: {X}) = X **)
    apply set_ext.
    + (** Union (Union Fam :\/: {X}) c= X **)
      let x. assume Hx: x :e Union (Union Fam :\/: {X}).
      prove x :e X.
      apply UnionE_impred (Union Fam :\/: {X}) x Hx.
      let U. assume HxU: x :e U. assume HU: U :e Union Fam :\/: {X}.
      apply (binunionE' (Union Fam) {X} U (x :e X)).
      - assume HUinUnion: U :e Union Fam.
        apply UnionE_impred Fam U HUinUnion.
        let T. assume HUT: U :e T. assume HT: T :e Fam.
        claim HTtop: topology_on X T.
        { exact (HfamTop T HT). }
        claim HUsubX: U c= X.
        { exact (topology_elem_subset X T U HTtop HUT). }
        exact (HUsubX x HxU).
      - assume HUinSing: U :e {X}.
        claim HUeq: U = X.
        { exact (SingE X U HUinSing). }
        rewrite <- HUeq.
        exact HxU.
      - exact HU.
    + (** X c= Union (Union Fam :\/: {X}) **)
      let x. assume HxX: x :e X.
      prove x :e Union (Union Fam :\/: {X}).
      claim HX_in_subbasis: X :e Union Fam :\/: {X}.
      { exact (binunionI2 (Union Fam) {X} X (SingI X)). }
      exact (UnionI (Union Fam :\/: {X}) x X HxX HX_in_subbasis).
}
claim HTmin_topology: topology_on X Tmin.
{ exact (topology_from_subbasis_is_topology X (Union Fam :\/: {X}) HUnionFam_subbasis). }
claim HTmin_contains_all: forall T :e Fam, T c= Tmin.
{ let T. assume HT: T :e Fam.
  (** Need to show every open set in T is in Tmin = generated_topology_from_subbasis X (Union Fam) **)
  let U. assume HU: U :e T.
  (** Show U :e generated_topology_from_subbasis X (Union Fam :\/: {X}) **)
  (** = generated_topology X (basis_of_subbasis X (Union Fam :\/: {X})) **)
  (** = {V :e Power X | forall x :e V, exists b :e basis_of_subbasis X (Union Fam :\/: {X}), x :e b /\ b c= V} **)
  (** Since U :e T and T :e Fam, we have U :e Union Fam and hence U :e Union Fam :\/: {X} **)
  claim HUinUnionFam: U :e Union Fam.
  { exact (UnionI Fam U T HU HT). }
  (** U is in the subbasis, so by subbasis_elem_in_basis, it's in the basis **)
  apply (xm (U = Empty)).
  - assume HUempty: U = Empty.
    (** Empty is in every topology **)
    claim HEmptyinTmin: Empty :e Tmin.
    { claim H1: ((Tmin c= Power X /\ Empty :e Tmin) /\ X :e Tmin) /\ (forall UFam :e Power Tmin, Union UFam :e Tmin).
      { exact (andEL (((Tmin c= Power X /\ Empty :e Tmin) /\ X :e Tmin) /\ (forall UFam :e Power Tmin, Union UFam :e Tmin)) (forall U0 :e Tmin, forall V :e Tmin, U0 :/\: V :e Tmin) HTmin_topology). }
      claim H2: (Tmin c= Power X /\ Empty :e Tmin) /\ X :e Tmin.
      { exact (andEL ((Tmin c= Power X /\ Empty :e Tmin) /\ X :e Tmin) (forall UFam :e Power Tmin, Union UFam :e Tmin) H1). }
      claim H3: Tmin c= Power X /\ Empty :e Tmin.
      { exact (andEL (Tmin c= Power X /\ Empty :e Tmin) (X :e Tmin) H2). }
      exact (andER (Tmin c= Power X) (Empty :e Tmin) H3).
    }
    rewrite HUempty.
    exact HEmptyinTmin.
  - assume HUnonempty: U <> Empty.
    claim HUinSubbasis: U :e Union Fam :\/: {X}.
    { exact (binunionI1 (Union Fam) {X} U HUinUnionFam). }
    claim HUinBasis: U :e basis_of_subbasis X (Union Fam :\/: {X}).
    { exact (subbasis_elem_in_basis X (Union Fam :\/: {X}) U HUnionFam_subbasis HUinSubbasis HUnonempty). }
    (** Now use basis_in_generated **)
    claim HBasis: basis_on X (basis_of_subbasis X (Union Fam :\/: {X})).
    { exact (finite_intersections_basis_of_subbasis X (Union Fam :\/: {X}) HUnionFam_subbasis). }
    exact (basis_in_generated X (basis_of_subbasis X (Union Fam :\/: {X})) U HBasis HUinBasis).
}
claim HTmin_minimal: forall T', topology_on X T' /\ (forall T :e Fam, T c= T') -> Tmin c= T'.
{ let T'. assume HT'_cond.
  claim HT'_top: topology_on X T'.
  { exact (andEL (topology_on X T') (forall T :e Fam, T c= T') HT'_cond). }
  claim HT'_contains_all: forall T :e Fam, T c= T'.
  { exact (andER (topology_on X T') (forall T :e Fam, T c= T') HT'_cond). }
  (** Show Union Fam :\/: {X} c= T' **)
  claim HSubbasis_sub_T': Union Fam :\/: {X} c= T'.
  { let U. assume HU: U :e Union Fam :\/: {X}.
    apply (binunionE' (Union Fam) {X} U (U :e T')).
    - assume HUinUnion: U :e Union Fam.
      apply UnionE_impred Fam U HUinUnion.
      let T. assume HUT: U :e T. assume HT: T :e Fam.
      claim HTsubT': T c= T'.
      { exact (HT'_contains_all T HT). }
      exact (HTsubT' U HUT).
    - assume HUinSing: U :e {X}.
      claim HUeq: U = X.
      { exact (SingE X U HUinSing). }
      rewrite HUeq.
      exact (topology_has_X X T' HT'_top).
    - exact HU.
  }
  (** Apply topology_generated_by_basis_is_minimal **)
  exact (topology_generated_by_basis_is_minimal X (Union Fam :\/: {X}) T' HUnionFam_subbasis HT'_top HSubbasis_sub_T').
}
(** Combine all parts with existential introductions **)
witness Tmin.
apply andI.
- apply andI.
  + (** topology_on X Tmin /\ (forall T :e Fam, T c= Tmin) **)
    apply andI.
    * exact HTmin_topology.
    * exact HTmin_contains_all.
  + exact HTmin_minimal.
- (** exists Tmax... **)
  witness Tmax.
  apply andI.
  + (** topology_on X Tmax /\ (forall T :e Fam, Tmax c= T) **)
    apply andI.
    * exact HTmax_topology.
    * exact HTmax_subset_all.
  + exact HTmax_maximal.
Qed.

(** from 13 Exercise 4(c): specific smallest/largest topology on {a,b,c} **) 
(** LATEX VERSION: Exercise 4(c): Determine the smallest and largest topologies on {a,b,c} containing given families (continuation of Exercise 4). **)
Theorem ex13_4c_specific_topologies :
  exists Tsmall Tall:set, topology_on abc_set Tsmall /\ topology_on abc_set Tall.
prove exists Tsmall Tall:set, topology_on abc_set Tsmall /\ topology_on abc_set Tall.
witness (indiscrete_topology abc_set).
witness (discrete_topology abc_set).
apply andI.
- exact (indiscrete_topology_on abc_set).
- exact (discrete_topology_on abc_set).
Qed.

(** from 13 Exercise 5: topology generated by a basis is intersection of topologies containing it **) 
(** LATEX VERSION: Exercise 5: The topology generated by a basis A equals the intersection of all topologies on X containing A. **)
Theorem ex13_5_basis_intersection : forall X A:set,
  basis_on X A ->
  generated_topology X A =
    Intersection_Fam X {T :e Power (Power X)|topology_on X T /\ A c= T}.
let X A.
assume HA: basis_on X A.
prove generated_topology X A = Intersection_Fam X {T :e Power (Power X)|topology_on X T /\ A c= T}.
set Fam := {T :e Power (Power X)|topology_on X T /\ A c= T}.
apply set_ext.
- (** generated_topology X A c= Intersection_Fam X Fam **)
  let U. assume HU: U :e generated_topology X A.
  (** Show U :e Intersection_Fam X Fam, i.e., U :e every T in Fam **)
  claim HUinPower: U :e Power X.
  { claim HUsub: U c= X.
    { exact (generated_topology_subset X A U HU). }
    exact (PowerI X U HUsub).
  }
  claim HUinAllT: forall T :e Fam, U :e T.
  { let T. assume HT: T :e Fam.
    (** Extract topology_on X T and A c= T from HT **)
    claim HTinPowerPower: T :e Power (Power X).
    { exact (SepE1 (Power (Power X)) (fun T0 => topology_on X T0 /\ A c= T0) T HT). }
    claim HTcond: topology_on X T /\ A c= T.
    { exact (SepE2 (Power (Power X)) (fun T0 => topology_on X T0 /\ A c= T0) T HT). }
    claim HTtop: topology_on X T.
    { exact (andEL (topology_on X T) (A c= T) HTcond). }
    claim HAinT: A c= T.
    { exact (andER (topology_on X T) (A c= T) HTcond). }
    (** Apply generated_topology_finer: if T contains all basis elements, generated_topology X A c= T **)
    claim HGenSubT: generated_topology X A c= T.
    { claim HAllAinT: forall a :e A, a :e T.
      { let a. assume Ha: a :e A.
        exact (HAinT a Ha).
      }
      exact (generated_topology_finer X A T HA HTtop HAllAinT).
    }
    exact (HGenSubT U HU).
  }
  exact (SepI (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) U HUinPower HUinAllT).
- (** Intersection_Fam X Fam c= generated_topology X A **)
  let U. assume HU: U :e Intersection_Fam X Fam.
  (** U is in every topology containing A, in particular in generated_topology X A **)
  claim HGenTop: topology_on X (generated_topology X A).
  { exact (lemma_topology_from_basis X A HA). }
  claim HAinGen: A c= generated_topology X A.
  { let a. assume Ha: a :e A.
    exact (basis_in_generated X A a HA Ha).
  }
  claim HGenInFam: generated_topology X A :e Fam.
  { (** Need to show generated_topology X A :e Power (Power X) and satisfies the condition **)
    claim HGenInPowerPower: generated_topology X A :e Power (Power X).
    { apply PowerI.
      let V. assume HV: V :e generated_topology X A.
      claim HVsub: V c= X.
      { exact (generated_topology_subset X A V HV). }
      exact (PowerI X V HVsub).
    }
    exact (SepI (Power (Power X)) (fun T => topology_on X T /\ A c= T) (generated_topology X A) HGenInPowerPower (andI (topology_on X (generated_topology X A)) (A c= generated_topology X A) HGenTop HAinGen)).
  }
  (** Now U :e Intersection_Fam X Fam means U :e every T in Fam **)
  claim HUinAllT: forall T :e Fam, U :e T.
  { exact (SepE2 (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) U HU). }
  exact (HUinAllT (generated_topology X A) HGenInFam).
Qed.

(** from 13 Exercise 6: incomparability of two real line topologies **)
(** LATEX VERSION: Exercise 6: Compare the standard, lower limit, and K-topologies on ; standard vs lower-limit and standard vs K are incomparable. **)
(** FIXED: Now uses proper rational definition (same as Q); rational = {x :e real | exists m :e int, exists n :e omega\\{0}, x = m/n} from line 6202. **)
(** NOTE: `rational_numbers` is an alias of `Q`. **)
Definition rational_numbers : set := Q.

(** from 13: rationals are reals **)
(** LATEX VERSION: Q is a subset of R. **)
Theorem rational_numbers_Subq_R : rational_numbers c= R.
exact (Subq_rational_real).
Qed.

(** from 13: elements of Q are in R **)
(** LATEX VERSION: If q is rational then q is real. **)
Theorem rational_numbers_in_R : forall q :e rational_numbers, q :e R.
let q. assume Hq.
exact (rational_numbers_Subq_R q Hq).
Qed.

Definition open_interval : set -> set -> set := fun a b => {x :e R|Rlt a x /\ Rlt x b}.
(** SUSPICIOUS DEFINITION: The endpoints `a,b` are not required to be in `R` explicitly; membership uses `Rlt` so ill-typed endpoints make the interval behave like `Empty`. **)
(** from 13 Exercise 6: lower limit basis element **)
(** LATEX VERSION: Lower limit topology uses half open intervals [a,b). **)
Definition halfopen_interval_left : set -> set -> set := fun a b => {x :e R|~(Rlt x a) /\ Rlt x b}.

(** from 13 Exercise 7: upper limit basis element **)
(** LATEX VERSION: Upper limit topology uses half open intervals (a,b]. **)
Definition halfopen_interval_right : set -> set -> set := fun a b => {x :e R|Rlt a x /\ ~(Rlt b x)}.
(** SUSPICIOUS DEFINITION: These half-open intervals use `~(Rlt x a)` and `~(Rlt b x)` as non-strict bounds; later proofs rely on the linearity of `<` on `R` to relate this to equality. **)

(** from 13 Exercise 7: upper limit interval is a subset of R **)
(** LATEX VERSION: (a,b] is a subset of R. **)
Theorem halfopen_interval_right_Subq_R : forall a b:set, halfopen_interval_right a b c= R.
let a b.
let x. assume Hx.
exact (SepE1 R (fun x0 : set => Rlt a x0 /\ ~(Rlt b x0)) x Hx).
Qed.

(** from 13 Exercise 7: right endpoint belongs to (a,b] when a<b **)
(** LATEX VERSION: If a<b then b is in (a,b]. **)
Theorem halfopen_interval_right_rightmem : forall a b:set, Rlt a b -> b :e halfopen_interval_right a b.
let a b. assume Hab.
claim HbR : b :e R.
{ exact (RltE_right a b Hab). }
claim Hprop : Rlt a b /\ ~(Rlt b b).
{ apply andI.
  - exact Hab.
  - exact (not_Rlt_refl b HbR). }
exact (SepI R (fun x0 : set => Rlt a x0 /\ ~(Rlt b x0)) b HbR Hprop).
Qed.

(** from 13 Exercise 6: open interval is a subset of  **)
(** LATEX VERSION: (a,b) is a subset of . **)
Theorem open_interval_Subq_R : forall a b:set, open_interval a b c= R.
let a b.
let x. assume Hx.
exact (SepE1 R (fun x0 : set => Rlt a x0 /\ Rlt x0 b) x Hx).
Qed.

(** from 13: every real lies in some standard open interval **)
(** LATEX VERSION: For any x in R, x is contained in (x-1,x+1). **)
Theorem real_in_open_interval_minus1_plus1 : forall x:set,
  x :e R ->
  x :e open_interval (add_SNo x (minus_SNo 1)) (add_SNo x 1).
let x. assume HxR.
set a0 := add_SNo x (minus_SNo 1).
set b0 := add_SNo x 1.
claim Hm1R : minus_SNo 1 :e R.
{ exact (real_minus_SNo 1 real_1). }
claim Ha0R : a0 :e R.
{ exact (real_add_SNo x HxR (minus_SNo 1) Hm1R). }
claim Hb0R : b0 :e R.
{ exact (real_add_SNo x HxR 1 real_1). }
claim HxS : SNo x.
{ exact (real_SNo x HxR). }
claim Hm1S : SNo (minus_SNo 1).
{ exact (real_SNo (minus_SNo 1) Hm1R). }
claim H1S : SNo 1.
{ exact (real_SNo 1 real_1). }
claim Ha0ltx : a0 < x.
{ claim Hlt : a0 < add_SNo x 0.
  { exact (add_SNo_Lt2 x (minus_SNo 1) 0 HxS Hm1S SNo_0 minus_1_lt_0). }
  rewrite <- (add_SNo_0R x HxS) at 2.
  exact Hlt. }
claim Hxltb0 : x < b0.
{ claim Hlt : add_SNo x 0 < b0.
  { exact (add_SNo_Lt2 x 0 1 HxS SNo_0 H1S SNoLt_0_1). }
  rewrite <- (add_SNo_0R x HxS) at 1.
  exact Hlt. }
claim Ha0x : Rlt a0 x.
{ exact (RltI a0 x Ha0R HxR Ha0ltx). }
claim Hxb0 : Rlt x b0.
{ exact (RltI x b0 HxR Hb0R Hxltb0). }
claim Hconj : Rlt a0 x /\ Rlt x b0.
{ apply andI.
  - exact Ha0x.
  - exact Hxb0. }
exact (SepI R (fun x0 : set => Rlt a0 x0 /\ Rlt x0 b0) x HxR Hconj).
Qed.

(** from 13 Exercise 6: half open interval is a subset of  **)
(** LATEX VERSION: [a,b) is a subset of . **)
Theorem halfopen_interval_left_Subq_R : forall a b:set, halfopen_interval_left a b c= R.
let a b.
let x. assume Hx.
exact (SepE1 R (fun x0 : set => ~(Rlt x0 a) /\ Rlt x0 b) x Hx).
Qed.

(** from 13 Exercise 6: left endpoint belongs to [a,b) when a<b **)
(** LATEX VERSION: If a<b then a[a,b). **)
Theorem halfopen_interval_left_leftmem : forall a b:set, Rlt a b -> a :e halfopen_interval_left a b.
let a b. assume Hab.
claim HaR : a :e R.
{ exact (RltE_left a b Hab). }
claim Hb : ~(Rlt a a) /\ Rlt a b.
{ apply andI.
  - exact (not_Rlt_refl a HaR).
  - exact Hab. }
exact (SepI R (fun x0 : set => ~(Rlt x0 a) /\ Rlt x0 b) a HaR Hb).
Qed.

Definition R_standard_basis : set :=
  \/_ a :e R, {open_interval a b|b :e R}.

Definition R_standard_topology : set :=
  generated_topology R R_standard_basis.
(** SUSPICIOUS DEFINITION: This basis includes all `open_interval a b` with `a,b :e R` without requiring `Rlt a b`; empty intervals are allowed as basis elements, which is harmless but can complicate refinement arguments. **)

(** from 13: standard open intervals form a basis on R **)
(** LATEX VERSION: The collection of open intervals (a,b) is a basis for the standard topology on R. **)
Theorem R_standard_basis_is_basis_local : basis_on R R_standard_basis.
prove basis_on R R_standard_basis.
prove R_standard_basis c= Power R
  /\ (forall x :e R, exists b :e R_standard_basis, x :e b)
  /\ (forall b1 :e R_standard_basis, forall b2 :e R_standard_basis, forall x:set,
        x :e b1 -> x :e b2 ->
        exists b3 :e R_standard_basis, x :e b3 /\ b3 c= b1 :/\: b2).
apply andI.
- apply andI.
  + (** basis elements are subsets of R **)
    let U. assume HU : U :e R_standard_basis.
    prove U :e Power R.
    (** destruct U  _{aR} {open_interval a b | bR} **)
    claim Hexa : exists a :e R, U :e {open_interval a b|b :e R}.
    { exact (famunionE R (fun a0 : set => {open_interval a0 b|b :e R}) U HU). }
    apply Hexa.
    let a. assume Hapair.
    claim HaR : a :e R.
    { exact (andEL (a :e R) (U :e {open_interval a b|b :e R}) Hapair). }
    claim HUfam : U :e {open_interval a b|b :e R}.
    { exact (andER (a :e R) (U :e {open_interval a b|b :e R}) Hapair). }
    claim Hexb : exists b :e R, U = open_interval a b.
    { exact (ReplE R (fun b0 : set => open_interval a b0) U HUfam). }
    apply Hexb.
    let b. assume Hbpair.
    claim HbR : b :e R.
    { exact (andEL (b :e R) (U = open_interval a b) Hbpair). }
    claim HUeq : U = open_interval a b.
    { exact (andER (b :e R) (U = open_interval a b) Hbpair). }
    rewrite HUeq.
    exact (PowerI R (open_interval a b) (open_interval_Subq_R a b)).
  + (** coverage: every x has a basis neighborhood **)
    let x. assume HxR.
    (** choose (x-1, x+1) **)
    claim Hm1R : minus_SNo 1 :e R.
    { exact (real_minus_SNo 1 real_1). }
    set a0 := add_SNo x (minus_SNo 1).
    set b0 := add_SNo x 1.
    claim Ha0R : a0 :e R.
    { exact (real_add_SNo x HxR (minus_SNo 1) Hm1R). }
    claim Hb0R : b0 :e R.
    { exact (real_add_SNo x HxR 1 real_1). }
    set I := open_interval a0 b0.
    witness I.
    apply andI.
    * (** I is in the standard basis **)
      claim HIa : I :e {open_interval a0 bb|bb :e R}.
      { exact (ReplI R (fun bb : set => open_interval a0 bb) b0 Hb0R). }
      exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a0 I Ha0R HIa).
    * (** x is in I **)
      claim HxS : SNo x.
      { exact (real_SNo x HxR). }
      claim Hm1S : SNo (minus_SNo 1).
      { exact (SNo_minus_SNo 1 SNo_1). }
      claim Hxltb0 : x < b0.
      { claim Hx0lt : 0 < 1.
        { exact SNoLt_0_1. }
	      claim Hx0eq : add_SNo x 0 = x.
	      { exact (add_SNo_0R x HxS). }
	      claim Hlt : add_SNo x 0 < add_SNo x 1.
	      { exact (add_SNo_Lt2 x 0 1 HxS SNo_0 SNo_1 Hx0lt). }
	      rewrite <- Hx0eq at 1.
	      exact Hlt. }
      claim Ha0ltx : a0 < x.
      { claim Hlt : add_SNo x (minus_SNo 1) < add_SNo x 0.
        { exact (add_SNo_Lt2 x (minus_SNo 1) 0 HxS Hm1S SNo_0 minus_1_lt_0). }
        rewrite <- (add_SNo_0R x HxS) at 2.
        exact Hlt. }
      claim Ha0x : Rlt a0 x.
      { exact (RltI a0 x Ha0R HxR Ha0ltx). }
      claim Hxb0 : Rlt x b0.
      { exact (RltI x b0 HxR Hb0R Hxltb0). }
      claim Hconj : Rlt a0 x /\ Rlt x b0.
      { apply andI.
        - exact Ha0x.
        - exact Hxb0. }
      exact (SepI R (fun x0 : set => Rlt a0 x0 /\ Rlt x0 b0) x HxR Hconj).
- (** intersection refinement **)
  let b1. assume Hb1.
  let b2. assume Hb2.
  let x. assume Hx1 Hx2.
  (** destruct b1 = (a1,b1') and b2 = (a2,b2') with endpoints in R **)
  claim Hexa1 : exists a1 :e R, b1 :e {open_interval a1 b|b :e R}.
  { exact (famunionE R (fun a0 : set => {open_interval a0 b|b :e R}) b1 Hb1). }
  claim Hexa2 : exists a2 :e R, b2 :e {open_interval a2 b|b :e R}.
  { exact (famunionE R (fun a0 : set => {open_interval a0 b|b :e R}) b2 Hb2). }
  apply Hexa1.
  let a1. assume Ha1pair.
  claim Ha1R : a1 :e R.
  { exact (andEL (a1 :e R) (b1 :e {open_interval a1 b|b :e R}) Ha1pair). }
  claim Hb1fam : b1 :e {open_interval a1 b|b :e R}.
  { exact (andER (a1 :e R) (b1 :e {open_interval a1 b|b :e R}) Ha1pair). }
  claim Hexb1 : exists bb1 :e R, b1 = open_interval a1 bb1.
  { exact (ReplE R (fun bb : set => open_interval a1 bb) b1 Hb1fam). }
  apply Hexb1.
  let bb1. assume Hbb1pair.
  claim Hbb1R : bb1 :e R.
  { exact (andEL (bb1 :e R) (b1 = open_interval a1 bb1) Hbb1pair). }
  claim Hb1eq : b1 = open_interval a1 bb1.
  { exact (andER (bb1 :e R) (b1 = open_interval a1 bb1) Hbb1pair). }
  apply Hexa2.
  let a2. assume Ha2pair.
  claim Ha2R : a2 :e R.
  { exact (andEL (a2 :e R) (b2 :e {open_interval a2 b|b :e R}) Ha2pair). }
  claim Hb2fam : b2 :e {open_interval a2 b|b :e R}.
  { exact (andER (a2 :e R) (b2 :e {open_interval a2 b|b :e R}) Ha2pair). }
  claim Hexb2 : exists bb2 :e R, b2 = open_interval a2 bb2.
  { exact (ReplE R (fun bb : set => open_interval a2 bb) b2 Hb2fam). }
  apply Hexb2.
  let bb2. assume Hbb2pair.
  claim Hbb2R : bb2 :e R.
  { exact (andEL (bb2 :e R) (b2 = open_interval a2 bb2) Hbb2pair). }
  claim Hb2eq : b2 = open_interval a2 bb2.
  { exact (andER (bb2 :e R) (b2 = open_interval a2 bb2) Hbb2pair). }
  (** extract inequalities from x  intervals **)
  claim HxIn1 : x :e open_interval a1 bb1.
  { rewrite <- Hb1eq. exact Hx1. }
  claim HxIn2 : x :e open_interval a2 bb2.
  { rewrite <- Hb2eq. exact Hx2. }
  claim HxR : x :e R.
  { exact (SepE1 R (fun x0 : set => Rlt a1 x0 /\ Rlt x0 bb1) x HxIn1). }
  claim HxProp1 : Rlt a1 x /\ Rlt x bb1.
  { exact (SepE2 R (fun x0 : set => Rlt a1 x0 /\ Rlt x0 bb1) x HxIn1). }
  claim HxProp2 : Rlt a2 x /\ Rlt x bb2.
  { exact (SepE2 R (fun x0 : set => Rlt a2 x0 /\ Rlt x0 bb2) x HxIn2). }
  claim Ha1x : Rlt a1 x.
  { exact (andEL (Rlt a1 x) (Rlt x bb1) HxProp1). }
  claim Hxbb1 : Rlt x bb1.
  { exact (andER (Rlt a1 x) (Rlt x bb1) HxProp1). }
  claim Ha2x : Rlt a2 x.
  { exact (andEL (Rlt a2 x) (Rlt x bb2) HxProp2). }
  claim Hxbb2 : Rlt x bb2.
  { exact (andER (Rlt a2 x) (Rlt x bb2) HxProp2). }
  (** choose endpoints a3 = max(a1,a2) and b3 = min(bb1,bb2) by trichotomy **)
  claim Ha1S : SNo a1.
  { exact (real_SNo a1 Ha1R). }
  claim Ha2S : SNo a2.
  { exact (real_SNo a2 Ha2R). }
  claim Hb1S : SNo bb1.
  { exact (real_SNo bb1 Hbb1R). }
  claim Hb2S : SNo bb2.
  { exact (real_SNo bb2 Hbb2R). }
  claim HxS : SNo x.
  { exact (real_SNo x HxR). }
  (** a3 and b3 are selected by case splits; proof is classical but long **)
  claim Ha1xlt : a1 < x.
  { exact (RltE_lt a1 x Ha1x). }
  claim Ha2xlt : a2 < x.
  { exact (RltE_lt a2 x Ha2x). }
  claim Hxltbb1 : x < bb1.
  { exact (RltE_lt x bb1 Hxbb1). }
  claim Hxltbb2 : x < bb2.
  { exact (RltE_lt x bb2 Hxbb2). }
  (** Decide which left endpoint is larger **)
  apply (SNoLt_trichotomy_or_impred a1 a2 Ha1S Ha2S
           (exists b3 :e R_standard_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
  - assume Ha1lt : a1 < a2.
    (** left endpoint a2 **)
    apply (SNoLt_trichotomy_or_impred bb1 bb2 Hb1S Hb2S
             (exists b3 :e R_standard_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
    + assume Hb1lt : bb1 < bb2.
      (** right endpoint bb1 **)
      set I3 := open_interval a2 bb1.
      witness I3.
      apply andI.
      * (** I3 in basis **)
        claim HI3fam : I3 :e {open_interval a2 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => open_interval a2 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a2 I3 Ha2R HI3fam).
      * apply andI.
        { (** x in I3 **)
          claim Hax : Rlt a2 x.
          { exact Ha2x. }
          claim Hxb : Rlt x bb1.
          { exact Hxbb1. }
          claim Hconj : Rlt a2 x /\ Rlt x bb1.
          { apply andI.
            - exact Hax.
            - exact Hxb. }
          exact (SepI R (fun z : set => Rlt a2 z /\ Rlt z bb1) x HxR Hconj). }
        { (** I3 subset b1  b2 **)
          let y. assume HyI3 : y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => Rlt a2 z /\ Rlt z bb1) y HyI3). }
          claim HyProp : Rlt a2 y /\ Rlt y bb1.
          { exact (SepE2 R (fun z : set => Rlt a2 z /\ Rlt z bb1) y HyI3). }
          claim Ha2y : Rlt a2 y.
          { exact (andEL (Rlt a2 y) (Rlt y bb1) HyProp). }
          claim Hybb1 : Rlt y bb1.
          { exact (andER (Rlt a2 y) (Rlt y bb1) HyProp). }
          claim HyS : SNo y.
          { exact (real_SNo y HyR). }
          claim Ha1S' : SNo a1.
          { exact Ha1S. }
          claim Ha2S' : SNo a2.
          { exact Ha2S. }
          claim Hbb1S' : SNo bb1.
          { exact Hb1S. }
          claim Hbb2S' : SNo bb2.
          { exact Hb2S. }
          claim Ha2ylt : a2 < y.
          { exact (RltE_lt a2 y Ha2y). }
          claim Hybb1lt : y < bb1.
          { exact (RltE_lt y bb1 Hybb1). }
          (** y in b2 = (a2,bb2) **)
          claim Hybb2lt : y < bb2.
          { exact (SNoLt_tra y bb1 bb2 HyS Hbb1S' Hbb2S' Hybb1lt Hb1lt). }
          claim Hybb2 : Rlt y bb2.
          { exact (RltI y bb2 HyR Hbb2R Hybb2lt). }
          claim HyIn2 : y :e open_interval a2 bb2.
          { exact (SepI R (fun z : set => Rlt a2 z /\ Rlt z bb2) y HyR (andI (Rlt a2 y) (Rlt y bb2) Ha2y Hybb2)). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq. exact HyIn2. }
          (** y in b1 = (a1,bb1) **)
          claim Ha1ylt : a1 < y.
          { exact (SNoLt_tra a1 a2 y Ha1S' Ha2S' HyS Ha1lt Ha2ylt). }
          claim Ha1y : Rlt a1 y.
          { exact (RltI a1 y Ha1R HyR Ha1ylt). }
          claim HyIn1 : y :e open_interval a1 bb1.
          { exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyR (andI (Rlt a1 y) (Rlt y bb1) Ha1y Hybb1)). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq. exact HyIn1. }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hbeq : bb1 = bb2.
      set I3 := open_interval a2 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {open_interval a2 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => open_interval a2 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a2 I3 Ha2R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a2 x /\ Rlt x bb1.
          { apply andI.
            - exact Ha2x.
            - exact Hxbb1. }
          exact (SepI R (fun z : set => Rlt a2 z /\ Rlt z bb1) x HxR Hconj). }
        { let y. assume HyI3 : y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => Rlt a2 z /\ Rlt z bb1) y HyI3). }
          claim HyProp : Rlt a2 y /\ Rlt y bb1.
          { exact (SepE2 R (fun z : set => Rlt a2 z /\ Rlt z bb1) y HyI3). }
          claim Ha2y : Rlt a2 y.
          { exact (andEL (Rlt a2 y) (Rlt y bb1) HyProp). }
          claim Hybb1 : Rlt y bb1.
          { exact (andER (Rlt a2 y) (Rlt y bb1) HyProp). }
          claim HyS : SNo y.
          { exact (real_SNo y HyR). }
          claim Ha2ylt : a2 < y.
          { exact (RltE_lt a2 y Ha2y). }
          claim Hybb1lt : y < bb1.
          { exact (RltE_lt y bb1 Hybb1). }
          (** y in b2 using bb2=bb1 **)
          claim Hybb2 : Rlt y bb2.
          { rewrite <- Hbeq. exact Hybb1. }
          claim HyIn2 : y :e open_interval a2 bb2.
          { exact (SepI R (fun z : set => Rlt a2 z /\ Rlt z bb2) y HyR (andI (Rlt a2 y) (Rlt y bb2) Ha2y Hybb2)). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq. exact HyIn2. }
          (** y in b1 using a1<a2 **)
          claim Ha1ylt : a1 < y.
          { exact (SNoLt_tra a1 a2 y Ha1S Ha2S HyS Ha1lt Ha2ylt). }
          claim Ha1y : Rlt a1 y.
          { exact (RltI a1 y Ha1R HyR Ha1ylt). }
          claim HyIn1 : y :e open_interval a1 bb1.
          { exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyR (andI (Rlt a1 y) (Rlt y bb1) Ha1y Hybb1)). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq. exact HyIn1. }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hb2lt : bb2 < bb1.
      (** right endpoint bb2 **)
      set I3 := open_interval a2 bb2.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {open_interval a2 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => open_interval a2 bb) bb2 Hbb2R). }
        exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a2 I3 Ha2R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a2 x /\ Rlt x bb2.
          { apply andI.
            - exact Ha2x.
            - exact Hxbb2. }
          exact (SepI R (fun z : set => Rlt a2 z /\ Rlt z bb2) x HxR Hconj). }
        { let y. assume HyI3 : y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => Rlt a2 z /\ Rlt z bb2) y HyI3). }
          claim HyProp : Rlt a2 y /\ Rlt y bb2.
          { exact (SepE2 R (fun z : set => Rlt a2 z /\ Rlt z bb2) y HyI3). }
          claim Ha2y : Rlt a2 y.
          { exact (andEL (Rlt a2 y) (Rlt y bb2) HyProp). }
          claim Hybb2 : Rlt y bb2.
          { exact (andER (Rlt a2 y) (Rlt y bb2) HyProp). }
          claim HyS : SNo y.
          { exact (real_SNo y HyR). }
          claim Ha2ylt : a2 < y.
          { exact (RltE_lt a2 y Ha2y). }
          claim Hybb2lt : y < bb2.
          { exact (RltE_lt y bb2 Hybb2). }
          (** y in b1 uses bb2<bb1 **)
          claim Hybb1lt : y < bb1.
          { exact (SNoLt_tra y bb2 bb1 HyS Hb2S Hb1S Hybb2lt Hb2lt). }
          claim Hybb1 : Rlt y bb1.
          { exact (RltI y bb1 HyR Hbb1R Hybb1lt). }
          claim Ha1ylt : a1 < y.
          { exact (SNoLt_tra a1 a2 y Ha1S Ha2S HyS Ha1lt Ha2ylt). }
          claim Ha1y : Rlt a1 y.
          { exact (RltI a1 y Ha1R HyR Ha1ylt). }
          claim HyIn1 : y :e open_interval a1 bb1.
          { exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyR (andI (Rlt a1 y) (Rlt y bb1) Ha1y Hybb1)). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq. exact HyIn1. }
          claim HyIn2 : y :e open_interval a2 bb2.
          { exact (SepI R (fun z : set => Rlt a2 z /\ Rlt z bb2) y HyR (andI (Rlt a2 y) (Rlt y bb2) Ha2y Hybb2)). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq. exact HyIn2. }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
  - assume Haeq : a1 = a2.
    (** left endpoint a1 **)
    apply (SNoLt_trichotomy_or_impred bb1 bb2 Hb1S Hb2S
             (exists b3 :e R_standard_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
    + assume Hb1lt : bb1 < bb2.
      set I3 := open_interval a1 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {open_interval a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => open_interval a1 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hax : Rlt a1 x.
          { exact Ha1x. }
          claim Hconj : Rlt a1 x /\ Rlt x bb1.
          { apply andI.
            - exact Hax.
            - exact Hxbb1. }
          exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) x HxR Hconj). }
        { let y. assume HyI3 : y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyI3). }
          claim HyProp : Rlt a1 y /\ Rlt y bb1.
          { exact (SepE2 R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyI3). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (Rlt y bb1) HyProp). }
          claim Hybb1 : Rlt y bb1.
          { exact (andER (Rlt a1 y) (Rlt y bb1) HyProp). }
          claim HyS : SNo y.
          { exact (real_SNo y HyR). }
          claim Hybb1lt : y < bb1.
          { exact (RltE_lt y bb1 Hybb1). }
          claim Hybb2lt : y < bb2.
          { exact (SNoLt_tra y bb1 bb2 HyS Hb1S Hb2S Hybb1lt Hb1lt). }
	          claim Hybb2 : Rlt y bb2.
	          { exact (RltI y bb2 HyR Hbb2R Hybb2lt). }
	          claim HyIn1 : y :e open_interval a1 bb1.
	          { exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyR (andI (Rlt a1 y) (Rlt y bb1) Ha1y Hybb1)). }
	          claim HyIn2 : y :e open_interval a2 bb2.
	          { rewrite <- Haeq.
	            exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb2) y HyR (andI (Rlt a1 y) (Rlt y bb2) Ha1y Hybb2)). }
	          claim Hyb1 : y :e b1.
	          { rewrite Hb1eq. exact HyIn1. }
	          claim Hyb2 : y :e b2.
	          { rewrite Hb2eq. exact HyIn2. }
	          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hbeq : bb1 = bb2.
      set I3 := open_interval a1 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {open_interval a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => open_interval a1 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ Rlt x bb1.
          { apply andI.
            - exact Ha1x.
            - exact Hxbb1. }
          exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) x HxR Hconj). }
        { let y. assume HyI3 : y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyI3). }
          claim HyProp : Rlt a1 y /\ Rlt y bb1.
          { exact (SepE2 R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyI3). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (Rlt y bb1) HyProp). }
          claim Hybb1 : Rlt y bb1.
          { exact (andER (Rlt a1 y) (Rlt y bb1) HyProp). }
          claim Hybb2 : Rlt y bb2.
          { rewrite <- Hbeq. exact Hybb1. }
	          claim HyIn1 : y :e open_interval a1 bb1.
	          { exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyR (andI (Rlt a1 y) (Rlt y bb1) Ha1y Hybb1)). }
	          claim HyIn2 : y :e open_interval a2 bb2.
	          { rewrite <- Haeq.
	            exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb2) y HyR (andI (Rlt a1 y) (Rlt y bb2) Ha1y Hybb2)). }
	          claim Hyb1 : y :e b1.
	          { rewrite Hb1eq. exact HyIn1. }
	          claim Hyb2 : y :e b2.
	          { rewrite Hb2eq. exact HyIn2. }
	          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hb2lt : bb2 < bb1.
      set I3 := open_interval a1 bb2.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {open_interval a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => open_interval a1 bb) bb2 Hbb2R). }
        exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ Rlt x bb2.
          { apply andI.
            - exact Ha1x.
            - exact Hxbb2. }
          exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb2) x HxR Hconj). }
        { let y. assume HyI3 : y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => Rlt a1 z /\ Rlt z bb2) y HyI3). }
          claim HyProp : Rlt a1 y /\ Rlt y bb2.
          { exact (SepE2 R (fun z : set => Rlt a1 z /\ Rlt z bb2) y HyI3). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (Rlt y bb2) HyProp). }
          claim Hybb2 : Rlt y bb2.
          { exact (andER (Rlt a1 y) (Rlt y bb2) HyProp). }
          claim HyS : SNo y.
          { exact (real_SNo y HyR). }
          claim Hybb2lt : y < bb2.
          { exact (RltE_lt y bb2 Hybb2). }
          claim Hybb1lt : y < bb1.
          { exact (SNoLt_tra y bb2 bb1 HyS Hb2S Hb1S Hybb2lt Hb2lt). }
          claim Hybb1 : Rlt y bb1.
          { exact (RltI y bb1 HyR Hbb1R Hybb1lt). }
	          claim HyIn1 : y :e open_interval a1 bb1.
	          { exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyR (andI (Rlt a1 y) (Rlt y bb1) Ha1y Hybb1)). }
	          claim HyIn2 : y :e open_interval a2 bb2.
	          { rewrite <- Haeq.
	            exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb2) y HyR (andI (Rlt a1 y) (Rlt y bb2) Ha1y Hybb2)). }
	          claim Hyb1 : y :e b1.
	          { rewrite Hb1eq. exact HyIn1. }
	          claim Hyb2 : y :e b2.
	          { rewrite Hb2eq. exact HyIn2. }
	          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
  - assume Ha2lt : a2 < a1.
    (** symmetric to first main case; use left endpoint a1 **)
    apply (SNoLt_trichotomy_or_impred bb1 bb2 Hb1S Hb2S
             (exists b3 :e R_standard_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
    + assume Hb1lt : bb1 < bb2.
      set I3 := open_interval a1 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {open_interval a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => open_interval a1 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ Rlt x bb1.
          { apply andI.
            - exact Ha1x.
            - exact Hxbb1. }
          exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) x HxR Hconj). }
        { let y. assume HyI3 : y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyI3). }
          claim HyProp : Rlt a1 y /\ Rlt y bb1.
          { exact (SepE2 R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyI3). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (Rlt y bb1) HyProp). }
          claim Hybb1 : Rlt y bb1.
          { exact (andER (Rlt a1 y) (Rlt y bb1) HyProp). }
          claim HyS : SNo y.
          { exact (real_SNo y HyR). }
          claim Ha1ylt : a1 < y.
          { exact (RltE_lt a1 y Ha1y). }
          claim Hybb1lt : y < bb1.
          { exact (RltE_lt y bb1 Hybb1). }
          (** y in b2: need a2<y and y<bb2 **)
          claim Ha2ylt : a2 < y.
          { exact (SNoLt_tra a2 a1 y Ha2S Ha1S HyS Ha2lt Ha1ylt). }
          claim Ha2y : Rlt a2 y.
          { exact (RltI a2 y Ha2R HyR Ha2ylt). }
          claim Hybb2lt : y < bb2.
          { exact (SNoLt_tra y bb1 bb2 HyS Hb1S Hb2S Hybb1lt Hb1lt). }
          claim Hybb2 : Rlt y bb2.
          { exact (RltI y bb2 HyR Hbb2R Hybb2lt). }
	          claim HyIn1 : y :e open_interval a1 bb1.
	          { exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyR (andI (Rlt a1 y) (Rlt y bb1) Ha1y Hybb1)). }
	          claim HyIn2 : y :e open_interval a2 bb2.
	          { exact (SepI R (fun z : set => Rlt a2 z /\ Rlt z bb2) y HyR (andI (Rlt a2 y) (Rlt y bb2) Ha2y Hybb2)). }
	          claim Hyb1 : y :e b1.
	          { rewrite Hb1eq. exact HyIn1. }
	          claim Hyb2 : y :e b2.
	          { rewrite Hb2eq. exact HyIn2. }
	          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hbeq : bb1 = bb2.
      set I3 := open_interval a1 bb2.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {open_interval a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => open_interval a1 bb) bb2 Hbb2R). }
        exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ Rlt x bb2.
          { apply andI.
            - exact Ha1x.
            - rewrite <- Hbeq.
              exact Hxbb1. }
          exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb2) x HxR Hconj). }
        { let y. assume HyI3 : y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => Rlt a1 z /\ Rlt z bb2) y HyI3). }
          claim HyProp : Rlt a1 y /\ Rlt y bb2.
          { exact (SepE2 R (fun z : set => Rlt a1 z /\ Rlt z bb2) y HyI3). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (Rlt y bb2) HyProp). }
	          claim Hybb2 : Rlt y bb2.
	          { exact (andER (Rlt a1 y) (Rlt y bb2) HyProp). }
	          claim Hybb1 : Rlt y bb1.
	          { rewrite Hbeq. exact Hybb2. }
          claim HyS : SNo y.
          { exact (real_SNo y HyR). }
          claim Ha1ylt : a1 < y.
          { exact (RltE_lt a1 y Ha1y). }
          claim Ha2ylt : a2 < y.
          { exact (SNoLt_tra a2 a1 y Ha2S Ha1S HyS Ha2lt Ha1ylt). }
          claim Ha2y : Rlt a2 y.
          { exact (RltI a2 y Ha2R HyR Ha2ylt). }
	          claim HyIn1 : y :e open_interval a1 bb1.
	          { exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyR (andI (Rlt a1 y) (Rlt y bb1) Ha1y Hybb1)). }
	          claim HyIn2 : y :e open_interval a2 bb2.
	          { exact (SepI R (fun z : set => Rlt a2 z /\ Rlt z bb2) y HyR (andI (Rlt a2 y) (Rlt y bb2) Ha2y Hybb2)). }
	          claim Hyb1 : y :e b1.
	          { rewrite Hb1eq. exact HyIn1. }
	          claim Hyb2 : y :e b2.
	          { rewrite Hb2eq. exact HyIn2. }
	          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hb2lt : bb2 < bb1.
      set I3 := open_interval a1 bb2.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {open_interval a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => open_interval a1 bb) bb2 Hbb2R). }
        exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ Rlt x bb2.
          { apply andI.
            - exact Ha1x.
            - exact Hxbb2. }
          exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb2) x HxR Hconj). }
        { let y. assume HyI3 : y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => Rlt a1 z /\ Rlt z bb2) y HyI3). }
          claim HyProp : Rlt a1 y /\ Rlt y bb2.
          { exact (SepE2 R (fun z : set => Rlt a1 z /\ Rlt z bb2) y HyI3). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (Rlt y bb2) HyProp). }
          claim Hybb2 : Rlt y bb2.
          { exact (andER (Rlt a1 y) (Rlt y bb2) HyProp). }
          claim HyS : SNo y.
          { exact (real_SNo y HyR). }
          claim Ha1ylt : a1 < y.
          { exact (RltE_lt a1 y Ha1y). }
          claim Ha2ylt : a2 < y.
          { exact (SNoLt_tra a2 a1 y Ha2S Ha1S HyS Ha2lt Ha1ylt). }
          claim Ha2y : Rlt a2 y.
          { exact (RltI a2 y Ha2R HyR Ha2ylt). }
          claim Hybb2lt : y < bb2.
          { exact (RltE_lt y bb2 Hybb2). }
          claim Hybb1lt : y < bb1.
          { exact (SNoLt_tra y bb2 bb1 HyS Hb2S Hb1S Hybb2lt Hb2lt). }
          claim Hybb1 : Rlt y bb1.
          { exact (RltI y bb1 HyR Hbb1R Hybb1lt). }
	          claim HyIn1 : y :e open_interval a1 bb1.
	          { exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyR (andI (Rlt a1 y) (Rlt y bb1) Ha1y Hybb1)). }
	          claim HyIn2 : y :e open_interval a2 bb2.
	          { exact (SepI R (fun z : set => Rlt a2 z /\ Rlt z bb2) y HyR (andI (Rlt a2 y) (Rlt y bb2) Ha2y Hybb2)). }
	          claim Hyb1 : y :e b1.
	          { rewrite Hb1eq. exact HyIn1. }
	          claim Hyb2 : y :e b2.
	          { rewrite Hb2eq. exact HyIn2. }
	          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
Qed.

(** helper: any open interval is open in the standard topology **)
(** LATEX VERSION: Every interval (a,b) is open in the standard topology on . **)
Theorem open_interval_in_R_standard_topology : forall a b:set,
  Rlt a b -> open_interval a b :e R_standard_topology.
let a b. assume Hab.
claim HaR: a :e R.
{ exact (RltE_left a b Hab). }
claim HbR: b :e R.
{ exact (RltE_right a b Hab). }
claim HbFam : open_interval a b :e {open_interval a b0|b0 :e R}.
{ exact (ReplI R (fun b0:set => open_interval a b0) b HbR). }
claim HbStd : open_interval a b :e R_standard_basis.
{ exact (famunionI R (fun a0:set => {open_interval a0 b0|b0 :e R}) a (open_interval a b) HaR HbFam). }
exact (generated_topology_contains_basis R R_standard_basis R_standard_basis_is_basis_local (open_interval a b) HbStd).
Qed.

(** from 13: the standard topology on R is a topology **)
(** LATEX VERSION: The topology generated by the standard basis satisfies the topology axioms. **)
Theorem R_standard_topology_is_topology_local : topology_on R R_standard_topology.
exact (lemma_topology_from_basis R R_standard_basis R_standard_basis_is_basis_local).
Qed.

Definition R_lower_limit_basis : set :=
  \/_ a :e R, {halfopen_interval_left a b|b :e R}.

Definition R_lower_limit_topology : set :=
  generated_topology R R_lower_limit_basis.

(** helper: the lower limit basis is a basis on R **)
Theorem R_lower_limit_basis_is_basis_local : basis_on R R_lower_limit_basis.
prove basis_on R R_lower_limit_basis.
prove R_lower_limit_basis c= Power R
  /\ (forall x :e R, exists b :e R_lower_limit_basis, x :e b)
  /\ (forall b1 :e R_lower_limit_basis, forall b2 :e R_lower_limit_basis, forall x:set,
        x :e b1 -> x :e b2 ->
        exists b3 :e R_lower_limit_basis, x :e b3 /\ b3 c= b1 :/\: b2).
apply andI.
- apply andI.
  + (** basis elements are subsets of R **)
    let U. assume HU : U :e R_lower_limit_basis.
    prove U :e Power R.
    claim Hexa : exists a :e R, U :e {halfopen_interval_left a b|b :e R}.
    { exact (famunionE R (fun a0:set => {halfopen_interval_left a0 b|b :e R}) U HU). }
    apply Hexa.
    let a. assume Hapair.
    claim HaR : a :e R.
    { exact (andEL (a :e R) (U :e {halfopen_interval_left a b|b :e R}) Hapair). }
    claim HUfam : U :e {halfopen_interval_left a b|b :e R}.
    { exact (andER (a :e R) (U :e {halfopen_interval_left a b|b :e R}) Hapair). }
    claim Hexb : exists b :e R, U = halfopen_interval_left a b.
    { exact (ReplE R (fun b0 : set => halfopen_interval_left a b0) U HUfam). }
    apply Hexb.
    let b. assume Hbpair.
    claim HUeq : U = halfopen_interval_left a b.
    { exact (andER (b :e R) (U = halfopen_interval_left a b) Hbpair). }
    rewrite HUeq.
    exact (PowerI R (halfopen_interval_left a b) (halfopen_interval_left_Subq_R a b)).
  + (** coverage: every x has a basis neighborhood [x,x+1) **)
    let x. assume HxR.
    claim HxS : SNo x.
    { exact (real_SNo x HxR). }
    set b0 := add_SNo x 1.
    claim Hb0R : b0 :e R.
    { exact (real_add_SNo x HxR 1 real_1). }
    claim Hb0S : SNo b0.
    { exact (real_SNo b0 Hb0R). }
    claim Hxltb0 : x < b0.
    { claim Hx0lt : add_SNo x 0 < add_SNo x 1.
      { exact (add_SNo_Lt2 x 0 1 HxS SNo_0 SNo_1 SNoLt_0_1). }
      rewrite <- (add_SNo_0R x HxS) at 1.
      exact Hx0lt. }
    claim Hxb0 : Rlt x b0.
    { exact (RltI x b0 HxR Hb0R Hxltb0). }
    set I := halfopen_interval_left x b0.
    witness I.
    apply andI.
    * (** I is in the lower limit basis **)
      claim HIa : I :e {halfopen_interval_left x bb|bb :e R}.
      { exact (ReplI R (fun bb : set => halfopen_interval_left x bb) b0 Hb0R). }
      exact (famunionI R (fun aa : set => {halfopen_interval_left aa bb|bb :e R}) x I HxR HIa).
    * (** x is in I **)
      exact (halfopen_interval_left_leftmem x b0 Hxb0).
- (** intersection refinement **)
  let b1. assume Hb1.
  let b2. assume Hb2.
  let x. assume Hx1 Hx2.
  prove exists b3 :e R_lower_limit_basis, x :e b3 /\ b3 c= b1 :/\: b2.
  (** destruct b1 = halfopen_interval_left a1 bb1 with a1,bb1 in R **)
  claim Hexa1 : exists a1 :e R, b1 :e {halfopen_interval_left a1 b|b :e R}.
  { exact (famunionE R (fun a0:set => {halfopen_interval_left a0 b|b :e R}) b1 Hb1). }
  apply Hexa1.
  let a1. assume Ha1pair. apply Ha1pair.
  assume Ha1R : a1 :e R.
  assume Hb1fam : b1 :e {halfopen_interval_left a1 b|b :e R}.
  claim Hexb1 : exists bb1 :e R, b1 = halfopen_interval_left a1 bb1.
  { exact (ReplE R (fun bb : set => halfopen_interval_left a1 bb) b1 Hb1fam). }
  apply Hexb1.
  let bb1. assume Hbb1pair. apply Hbb1pair.
  assume Hbb1R : bb1 :e R.
  assume Hb1eq : b1 = halfopen_interval_left a1 bb1.

  (** destruct b2 = halfopen_interval_left a2 bb2 with a2,bb2 in R **)
  claim Hexa2 : exists a2 :e R, b2 :e {halfopen_interval_left a2 b|b :e R}.
  { exact (famunionE R (fun a0:set => {halfopen_interval_left a0 b|b :e R}) b2 Hb2). }
  apply Hexa2.
  let a2. assume Ha2pair. apply Ha2pair.
  assume Ha2R : a2 :e R.
  assume Hb2fam : b2 :e {halfopen_interval_left a2 b|b :e R}.
  claim Hexb2 : exists bb2 :e R, b2 = halfopen_interval_left a2 bb2.
  { exact (ReplE R (fun bb : set => halfopen_interval_left a2 bb) b2 Hb2fam). }
  apply Hexb2.
  let bb2. assume Hbb2pair. apply Hbb2pair.
  assume Hbb2R : bb2 :e R.
  assume Hb2eq : b2 = halfopen_interval_left a2 bb2.

  (** extract constraints from x membership **)
  claim HxIn1 : x :e halfopen_interval_left a1 bb1.
  { rewrite <- Hb1eq. exact Hx1. }
  claim HxIn2 : x :e halfopen_interval_left a2 bb2.
  { rewrite <- Hb2eq. exact Hx2. }
  claim HxR : x :e R.
  { exact (SepE1 R (fun x0 : set => ~(Rlt x0 a1) /\ Rlt x0 bb1) x HxIn1). }
  claim HxProp1 : ~(Rlt x a1) /\ Rlt x bb1.
  { exact (SepE2 R (fun x0 : set => ~(Rlt x0 a1) /\ Rlt x0 bb1) x HxIn1). }
  claim HxProp2 : ~(Rlt x a2) /\ Rlt x bb2.
  { exact (SepE2 R (fun x0 : set => ~(Rlt x0 a2) /\ Rlt x0 bb2) x HxIn2). }
  claim Hnxa1 : ~(Rlt x a1).
  { exact (andEL (~(Rlt x a1)) (Rlt x bb1) HxProp1). }
  claim Hxbb1 : Rlt x bb1.
  { exact (andER (~(Rlt x a1)) (Rlt x bb1) HxProp1). }
  claim Hnxa2 : ~(Rlt x a2).
  { exact (andEL (~(Rlt x a2)) (Rlt x bb2) HxProp2). }
  claim Hxbb2 : Rlt x bb2.
  { exact (andER (~(Rlt x a2)) (Rlt x bb2) HxProp2). }

  claim Ha1S : SNo a1.
  { exact (real_SNo a1 Ha1R). }
  claim Ha2S : SNo a2.
  { exact (real_SNo a2 Ha2R). }
  claim Hb1S : SNo bb1.
  { exact (real_SNo bb1 Hbb1R). }
  claim Hb2S : SNo bb2.
  { exact (real_SNo bb2 Hbb2R). }

  (** choose max left endpoint and min right endpoint by trichotomy **)
  apply (SNoLt_trichotomy_or_impred a1 a2 Ha1S Ha2S
           (exists b3 :e R_lower_limit_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
  - assume Ha1lt : a1 < a2.
    claim Ha1a2 : Rlt a1 a2.
    { exact (RltI a1 a2 Ha1R Ha2R Ha1lt). }
    apply (SNoLt_trichotomy_or_impred bb1 bb2 Hb1S Hb2S
             (exists b3 :e R_lower_limit_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
    + assume Hb1lt : bb1 < bb2.
      claim Hbb1bb2 : Rlt bb1 bb2.
      { exact (RltI bb1 bb2 Hbb1R Hbb2R Hb1lt). }
      set I3 := halfopen_interval_left a2 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_left a2 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_left a2 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_left aa bb|bb :e R}) a2 I3 Ha2R HI3fam).
      * apply andI.
        { (** x in I3 **)
          claim Hconj : ~(Rlt x a2) /\ Rlt x bb1.
          { apply andI.
            - exact Hnxa2.
            - exact Hxbb1. }
          exact (SepI R (fun z : set => ~(Rlt z a2) /\ Rlt z bb1) x HxR Hconj). }
        { (** I3 subset b1  b2 **)
          let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => ~(Rlt z a2) /\ Rlt z bb1) y Hy). }
          claim HyProp : ~(Rlt y a2) /\ Rlt y bb1.
          { exact (SepE2 R (fun z : set => ~(Rlt z a2) /\ Rlt z bb1) y Hy). }
          claim Hnya2 : ~(Rlt y a2).
          { exact (andEL (~(Rlt y a2)) (Rlt y bb1) HyProp). }
          claim Hybb1 : Rlt y bb1.
          { exact (andER (~(Rlt y a2)) (Rlt y bb1) HyProp). }
          claim Hnya1 : ~(Rlt y a1).
          { assume Hya1 : Rlt y a1.
            claim Hya2 : Rlt y a2.
            { exact (Rlt_tra y a1 a2 Hya1 Ha1a2). }
            exact (Hnya2 Hya2). }
          claim Hybb2 : Rlt y bb2.
          { exact (Rlt_tra y bb1 bb2 Hybb1 Hbb1bb2). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq at 1.
            exact (SepI R (fun z : set => ~(Rlt z a1) /\ Rlt z bb1) y HyR (andI (~(Rlt y a1)) (Rlt y bb1) Hnya1 Hybb1)). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            exact (SepI R (fun z : set => ~(Rlt z a2) /\ Rlt z bb2) y HyR (andI (~(Rlt y a2)) (Rlt y bb2) Hnya2 Hybb2)). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume HbbEq : bb1 = bb2.
      set I3 := halfopen_interval_left a2 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_left a2 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_left a2 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_left aa bb|bb :e R}) a2 I3 Ha2R HI3fam).
      * apply andI.
        { claim Hconj : ~(Rlt x a2) /\ Rlt x bb1.
          { apply andI.
            - exact Hnxa2.
            - exact Hxbb1. }
          exact (SepI R (fun z : set => ~(Rlt z a2) /\ Rlt z bb1) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => ~(Rlt z a2) /\ Rlt z bb1) y Hy). }
          claim HyProp : ~(Rlt y a2) /\ Rlt y bb1.
          { exact (SepE2 R (fun z : set => ~(Rlt z a2) /\ Rlt z bb1) y Hy). }
          claim Hnya2 : ~(Rlt y a2).
          { exact (andEL (~(Rlt y a2)) (Rlt y bb1) HyProp). }
          claim Hybb1 : Rlt y bb1.
          { exact (andER (~(Rlt y a2)) (Rlt y bb1) HyProp). }
          claim Hnya1 : ~(Rlt y a1).
          { assume Hya1 : Rlt y a1.
            claim Hya2 : Rlt y a2.
            { exact (Rlt_tra y a1 a2 Hya1 Ha1a2). }
            exact (Hnya2 Hya2). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            exact (SepI R (fun z : set => ~(Rlt z a1) /\ Rlt z bb1) y HyR (andI (~(Rlt y a1)) (Rlt y bb1) Hnya1 Hybb1)). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            claim Hybb2 : Rlt y bb2.
            { rewrite <- HbbEq.
              exact Hybb1. }
            exact (SepI R (fun z : set => ~(Rlt z a2) /\ Rlt z bb2) y HyR (andI (~(Rlt y a2)) (Rlt y bb2) Hnya2 Hybb2)). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hb2lt : bb2 < bb1.
      claim Hbb2bb1 : Rlt bb2 bb1.
      { exact (RltI bb2 bb1 Hbb2R Hbb1R Hb2lt). }
      set I3 := halfopen_interval_left a2 bb2.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_left a2 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_left a2 bb) bb2 Hbb2R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_left aa bb|bb :e R}) a2 I3 Ha2R HI3fam).
      * apply andI.
        { claim Hconj : ~(Rlt x a2) /\ Rlt x bb2.
          { apply andI.
            - exact Hnxa2.
            - exact Hxbb2. }
          exact (SepI R (fun z : set => ~(Rlt z a2) /\ Rlt z bb2) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => ~(Rlt z a2) /\ Rlt z bb2) y Hy). }
          claim HyProp : ~(Rlt y a2) /\ Rlt y bb2.
          { exact (SepE2 R (fun z : set => ~(Rlt z a2) /\ Rlt z bb2) y Hy). }
          claim Hnya2 : ~(Rlt y a2).
          { exact (andEL (~(Rlt y a2)) (Rlt y bb2) HyProp). }
          claim Hybb2 : Rlt y bb2.
          { exact (andER (~(Rlt y a2)) (Rlt y bb2) HyProp). }
          claim Hnya1 : ~(Rlt y a1).
          { assume Hya1 : Rlt y a1.
            claim Hya2 : Rlt y a2.
            { exact (Rlt_tra y a1 a2 Hya1 Ha1a2). }
            exact (Hnya2 Hya2). }
          claim Hybb1 : Rlt y bb1.
          { exact (Rlt_tra y bb2 bb1 Hybb2 Hbb2bb1). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            exact (SepI R (fun z : set => ~(Rlt z a1) /\ Rlt z bb1) y HyR (andI (~(Rlt y a1)) (Rlt y bb1) Hnya1 Hybb1)). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            exact (SepI R (fun z : set => ~(Rlt z a2) /\ Rlt z bb2) y HyR (andI (~(Rlt y a2)) (Rlt y bb2) Hnya2 Hybb2)). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
  - assume HaEq : a1 = a2.
    apply (SNoLt_trichotomy_or_impred bb1 bb2 Hb1S Hb2S
             (exists b3 :e R_lower_limit_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
    + assume Hb1lt : bb1 < bb2.
      claim Hbb1bb2 : Rlt bb1 bb2.
      { exact (RltI bb1 bb2 Hbb1R Hbb2R Hb1lt). }
      set I3 := halfopen_interval_left a1 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_left a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_left a1 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_left aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { exact HxIn1. }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => ~(Rlt z a1) /\ Rlt z bb1) y Hy). }
          claim HyProp : ~(Rlt y a1) /\ Rlt y bb1.
          { exact (SepE2 R (fun z : set => ~(Rlt z a1) /\ Rlt z bb1) y Hy). }
          claim Hnya1 : ~(Rlt y a1).
          { exact (andEL (~(Rlt y a1)) (Rlt y bb1) HyProp). }
          claim Hybb1 : Rlt y bb1.
          { exact (andER (~(Rlt y a1)) (Rlt y bb1) HyProp). }
          claim Hybb2 : Rlt y bb2.
          { exact (Rlt_tra y bb1 bb2 Hybb1 Hbb1bb2). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            exact (SepI R (fun z : set => ~(Rlt z a1) /\ Rlt z bb1) y HyR (andI (~(Rlt y a1)) (Rlt y bb1) Hnya1 Hybb1)). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            claim Hnya2 : ~(Rlt y a2).
            { rewrite <- HaEq.
              exact Hnya1. }
            exact (SepI R (fun z : set => ~(Rlt z a2) /\ Rlt z bb2) y HyR (andI (~(Rlt y a2)) (Rlt y bb2) Hnya2 Hybb2)). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume HbEq : bb1 = bb2.
      witness b1.
      apply andI.
      * exact Hb1.
      * apply andI.
        { exact Hx1. }
        { let y. assume Hy: y :e b1.
          prove y :e b1 :/\: b2.
          claim Hyb2: y :e b2.
          { claim Hb1b2 : b1 = b2.
            { rewrite Hb1eq.
              rewrite Hb2eq.
              rewrite HaEq.
              rewrite HbEq.
              reflexivity. }
            rewrite <- Hb1b2.
            exact Hy. }
          exact (binintersectI b1 b2 y Hy Hyb2). }
    + assume Hb2lt : bb2 < bb1.
      claim Hbb2bb1 : Rlt bb2 bb1.
      { exact (RltI bb2 bb1 Hbb2R Hbb1R Hb2lt). }
      set I3 := halfopen_interval_left a1 bb2.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_left a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_left a1 bb) bb2 Hbb2R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_left aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : ~(Rlt x a1) /\ Rlt x bb2.
          { apply andI.
            - exact Hnxa1.
            - exact Hxbb2. }
          exact (SepI R (fun z : set => ~(Rlt z a1) /\ Rlt z bb2) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => ~(Rlt z a1) /\ Rlt z bb2) y Hy). }
          claim HyProp : ~(Rlt y a1) /\ Rlt y bb2.
          { exact (SepE2 R (fun z : set => ~(Rlt z a1) /\ Rlt z bb2) y Hy). }
          claim Hnya1 : ~(Rlt y a1).
          { exact (andEL (~(Rlt y a1)) (Rlt y bb2) HyProp). }
          claim Hybb2 : Rlt y bb2.
          { exact (andER (~(Rlt y a1)) (Rlt y bb2) HyProp). }
          claim Hybb1 : Rlt y bb1.
          { exact (Rlt_tra y bb2 bb1 Hybb2 Hbb2bb1). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            exact (SepI R (fun z : set => ~(Rlt z a1) /\ Rlt z bb1) y HyR (andI (~(Rlt y a1)) (Rlt y bb1) Hnya1 Hybb1)). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            claim Hnya2 : ~(Rlt y a2).
            { rewrite <- HaEq.
              exact Hnya1. }
            exact (SepI R (fun z : set => ~(Rlt z a2) /\ Rlt z bb2) y HyR (andI (~(Rlt y a2)) (Rlt y bb2) Hnya2 Hybb2)). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
  - assume Ha2lt : a2 < a1.
    claim Ha2a1 : Rlt a2 a1.
    { exact (RltI a2 a1 Ha2R Ha1R Ha2lt). }
    apply (SNoLt_trichotomy_or_impred bb1 bb2 Hb1S Hb2S
             (exists b3 :e R_lower_limit_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
    + assume Hb1lt : bb1 < bb2.
      claim Hbb1bb2 : Rlt bb1 bb2.
      { exact (RltI bb1 bb2 Hbb1R Hbb2R Hb1lt). }
      set I3 := halfopen_interval_left a1 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_left a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_left a1 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_left aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : ~(Rlt x a1) /\ Rlt x bb1.
          { apply andI.
            - exact Hnxa1.
            - exact Hxbb1. }
          exact (SepI R (fun z : set => ~(Rlt z a1) /\ Rlt z bb1) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => ~(Rlt z a1) /\ Rlt z bb1) y Hy). }
          claim HyProp : ~(Rlt y a1) /\ Rlt y bb1.
          { exact (SepE2 R (fun z : set => ~(Rlt z a1) /\ Rlt z bb1) y Hy). }
          claim Hnya1 : ~(Rlt y a1).
          { exact (andEL (~(Rlt y a1)) (Rlt y bb1) HyProp). }
          claim Hybb1 : Rlt y bb1.
          { exact (andER (~(Rlt y a1)) (Rlt y bb1) HyProp). }
          claim Hnya2 : ~(Rlt y a2).
          { assume Hya2 : Rlt y a2.
            claim Hya1 : Rlt y a1.
            { exact (Rlt_tra y a2 a1 Hya2 Ha2a1). }
            exact (Hnya1 Hya1). }
          claim Hybb2 : Rlt y bb2.
          { exact (Rlt_tra y bb1 bb2 Hybb1 Hbb1bb2). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            exact (SepI R (fun z : set => ~(Rlt z a1) /\ Rlt z bb1) y HyR (andI (~(Rlt y a1)) (Rlt y bb1) Hnya1 Hybb1)). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            exact (SepI R (fun z : set => ~(Rlt z a2) /\ Rlt z bb2) y HyR (andI (~(Rlt y a2)) (Rlt y bb2) Hnya2 Hybb2)). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume HbEq : bb1 = bb2.
      set I3 := halfopen_interval_left a1 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_left a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_left a1 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_left aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { exact HxIn1. }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => ~(Rlt z a1) /\ Rlt z bb1) y Hy). }
          claim HyProp : ~(Rlt y a1) /\ Rlt y bb1.
          { exact (SepE2 R (fun z : set => ~(Rlt z a1) /\ Rlt z bb1) y Hy). }
          claim Hnya1 : ~(Rlt y a1).
          { exact (andEL (~(Rlt y a1)) (Rlt y bb1) HyProp). }
          claim Hybb1 : Rlt y bb1.
          { exact (andER (~(Rlt y a1)) (Rlt y bb1) HyProp). }
          claim Hnya2 : ~(Rlt y a2).
          { assume Hya2 : Rlt y a2.
            claim Hya1 : Rlt y a1.
            { exact (Rlt_tra y a2 a1 Hya2 Ha2a1). }
            exact (Hnya1 Hya1). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            exact (SepI R (fun z : set => ~(Rlt z a1) /\ Rlt z bb1) y HyR (andI (~(Rlt y a1)) (Rlt y bb1) Hnya1 Hybb1)). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            claim Hybb2 : Rlt y bb2.
            { rewrite <- HbEq.
              exact Hybb1. }
            exact (SepI R (fun z : set => ~(Rlt z a2) /\ Rlt z bb2) y HyR (andI (~(Rlt y a2)) (Rlt y bb2) Hnya2 Hybb2)). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hb2lt : bb2 < bb1.
      claim Hbb2bb1 : Rlt bb2 bb1.
      { exact (RltI bb2 bb1 Hbb2R Hbb1R Hb2lt). }
      set I3 := halfopen_interval_left a1 bb2.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_left a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_left a1 bb) bb2 Hbb2R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_left aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : ~(Rlt x a1) /\ Rlt x bb2.
          { apply andI.
            - exact Hnxa1.
            - exact Hxbb2. }
          exact (SepI R (fun z : set => ~(Rlt z a1) /\ Rlt z bb2) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => ~(Rlt z a1) /\ Rlt z bb2) y Hy). }
          claim HyProp : ~(Rlt y a1) /\ Rlt y bb2.
          { exact (SepE2 R (fun z : set => ~(Rlt z a1) /\ Rlt z bb2) y Hy). }
          claim Hnya1 : ~(Rlt y a1).
          { exact (andEL (~(Rlt y a1)) (Rlt y bb2) HyProp). }
          claim Hybb2 : Rlt y bb2.
          { exact (andER (~(Rlt y a1)) (Rlt y bb2) HyProp). }
          claim Hnya2 : ~(Rlt y a2).
          { assume Hya2 : Rlt y a2.
            claim Hya1 : Rlt y a1.
            { exact (Rlt_tra y a2 a1 Hya2 Ha2a1). }
            exact (Hnya1 Hya1). }
          claim Hybb1 : Rlt y bb1.
          { exact (Rlt_tra y bb2 bb1 Hybb2 Hbb2bb1). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            exact (SepI R (fun z : set => ~(Rlt z a1) /\ Rlt z bb1) y HyR (andI (~(Rlt y a1)) (Rlt y bb1) Hnya1 Hybb1)). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            exact (SepI R (fun z : set => ~(Rlt z a2) /\ Rlt z bb2) y HyR (andI (~(Rlt y a2)) (Rlt y bb2) Hnya2 Hybb2)). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
Qed.

(** from 13: the lower limit topology on R is a topology **)
(** LATEX VERSION: The topology generated by the lower limit basis satisfies the topology axioms. **)
Theorem R_lower_limit_topology_is_topology : topology_on R R_lower_limit_topology.
exact (lemma_topology_from_basis R R_lower_limit_basis R_lower_limit_basis_is_basis_local).
Qed.

(** from 13 Exercise 7: basis for the upper limit topology on R **)
(** LATEX VERSION: The upper limit topology on R is generated by half open intervals (a,b]. **)
Definition R_upper_limit_basis : set :=
  \/_ a :e R, {halfopen_interval_right a b|b :e R}.

(** helper: the upper limit basis is a basis on R **)
Theorem R_upper_limit_basis_is_basis_local : basis_on R R_upper_limit_basis.
prove basis_on R R_upper_limit_basis.
prove R_upper_limit_basis c= Power R
  /\ (forall x :e R, exists b :e R_upper_limit_basis, x :e b)
  /\ (forall b1 :e R_upper_limit_basis, forall b2 :e R_upper_limit_basis, forall x:set,
        x :e b1 -> x :e b2 ->
        exists b3 :e R_upper_limit_basis, x :e b3 /\ b3 c= b1 :/\: b2).
apply andI.
- apply andI.
  + (** basis elements are subsets of R **)
    let U. assume HU : U :e R_upper_limit_basis.
    prove U :e Power R.
    claim Hexa : exists a :e R, U :e {halfopen_interval_right a b|b :e R}.
    { exact (famunionE R (fun a0 : set => {halfopen_interval_right a0 b|b :e R}) U HU). }
    apply Hexa.
    let a. assume Hapair.
    claim HaR : a :e R.
    { exact (andEL (a :e R) (U :e {halfopen_interval_right a b|b :e R}) Hapair). }
    claim HUfam : U :e {halfopen_interval_right a b|b :e R}.
    { exact (andER (a :e R) (U :e {halfopen_interval_right a b|b :e R}) Hapair). }
    claim Hexb : exists b :e R, U = halfopen_interval_right a b.
    { exact (ReplE R (fun b0 : set => halfopen_interval_right a b0) U HUfam). }
    apply Hexb.
    let b. assume Hbpair.
    claim HbR : b :e R.
    { exact (andEL (b :e R) (U = halfopen_interval_right a b) Hbpair). }
    claim HUeq : U = halfopen_interval_right a b.
    { exact (andER (b :e R) (U = halfopen_interval_right a b) Hbpair). }
    rewrite HUeq.
    exact (PowerI R (halfopen_interval_right a b) (halfopen_interval_right_Subq_R a b)).
  + (** coverage: every x has a basis neighborhood (x-1,x] **)
    let x. assume HxR.
    claim Hm1R : minus_SNo 1 :e R.
    { exact (real_minus_SNo 1 real_1). }
    set a0 := add_SNo x (minus_SNo 1).
    claim Ha0R : a0 :e R.
    { exact (real_add_SNo x HxR (minus_SNo 1) Hm1R). }
    set I := halfopen_interval_right a0 x.
    witness I.
    apply andI.
    * (** I is in the upper limit basis **)
      claim HIa : I :e {halfopen_interval_right a0 bb|bb :e R}.
      { exact (ReplI R (fun bb : set => halfopen_interval_right a0 bb) x HxR). }
      exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R}) a0 I Ha0R HIa).
    * (** x is in I **)
      claim HxS : SNo x.
      { exact (real_SNo x HxR). }
      claim Hm1S : SNo (minus_SNo 1).
      { exact (SNo_minus_SNo 1 SNo_1). }
      claim Ha0ltx : a0 < x.
      { claim Hlt : add_SNo x (minus_SNo 1) < add_SNo x 0.
        { exact (add_SNo_Lt2 x (minus_SNo 1) 0 HxS Hm1S SNo_0 minus_1_lt_0). }
        rewrite <- (add_SNo_0R x HxS) at 2.
        exact Hlt. }
      claim Ha0x : Rlt a0 x.
      { exact (RltI a0 x Ha0R HxR Ha0ltx). }
      claim Hnx : ~(Rlt x x).
      { exact (not_Rlt_refl x HxR). }
      claim Hconj : Rlt a0 x /\ ~(Rlt x x).
      { apply andI.
        - exact Ha0x.
        - exact Hnx. }
      exact (SepI R (fun x0 : set => Rlt a0 x0 /\ ~(Rlt x x0)) x HxR Hconj).
- (** intersection refinement **)
  let b1. assume Hb1.
  let b2. assume Hb2.
  let x. assume Hx1 Hx2.
  (** destruct b1 and b2 as halfopen intervals (a,bb] **)
  claim Hexa1 : exists a1 :e R, b1 :e {halfopen_interval_right a1 b|b :e R}.
  { exact (famunionE R (fun a0 : set => {halfopen_interval_right a0 b|b :e R}) b1 Hb1). }
  claim Hexa2 : exists a2 :e R, b2 :e {halfopen_interval_right a2 b|b :e R}.
  { exact (famunionE R (fun a0 : set => {halfopen_interval_right a0 b|b :e R}) b2 Hb2). }
  apply Hexa1.
  let a1. assume Ha1pair.
  claim Ha1R : a1 :e R.
  { exact (andEL (a1 :e R) (b1 :e {halfopen_interval_right a1 b|b :e R}) Ha1pair). }
  claim Hb1fam : b1 :e {halfopen_interval_right a1 b|b :e R}.
  { exact (andER (a1 :e R) (b1 :e {halfopen_interval_right a1 b|b :e R}) Ha1pair). }
  claim Hexb1 : exists bb1 :e R, b1 = halfopen_interval_right a1 bb1.
  { exact (ReplE R (fun bb : set => halfopen_interval_right a1 bb) b1 Hb1fam). }
  apply Hexb1.
  let bb1. assume Hbb1pair.
  claim Hbb1R : bb1 :e R.
  { exact (andEL (bb1 :e R) (b1 = halfopen_interval_right a1 bb1) Hbb1pair). }
  claim Hb1eq : b1 = halfopen_interval_right a1 bb1.
  { exact (andER (bb1 :e R) (b1 = halfopen_interval_right a1 bb1) Hbb1pair). }
  apply Hexa2.
  let a2. assume Ha2pair.
  claim Ha2R : a2 :e R.
  { exact (andEL (a2 :e R) (b2 :e {halfopen_interval_right a2 b|b :e R}) Ha2pair). }
  claim Hb2fam : b2 :e {halfopen_interval_right a2 b|b :e R}.
  { exact (andER (a2 :e R) (b2 :e {halfopen_interval_right a2 b|b :e R}) Ha2pair). }
  claim Hexb2 : exists bb2 :e R, b2 = halfopen_interval_right a2 bb2.
  { exact (ReplE R (fun bb : set => halfopen_interval_right a2 bb) b2 Hb2fam). }
  apply Hexb2.
  let bb2. assume Hbb2pair.
  claim Hbb2R : bb2 :e R.
  { exact (andEL (bb2 :e R) (b2 = halfopen_interval_right a2 bb2) Hbb2pair). }
  claim Hb2eq : b2 = halfopen_interval_right a2 bb2.
  { exact (andER (bb2 :e R) (b2 = halfopen_interval_right a2 bb2) Hbb2pair). }
  (** extract constraints from x membership **)
  claim HxIn1 : x :e halfopen_interval_right a1 bb1.
  { rewrite <- Hb1eq. exact Hx1. }
  claim HxIn2 : x :e halfopen_interval_right a2 bb2.
  { rewrite <- Hb2eq. exact Hx2. }
  claim HxR : x :e R.
  { exact (SepE1 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) x HxIn1). }
  claim HxProp1 : Rlt a1 x /\ ~(Rlt bb1 x).
  { exact (SepE2 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) x HxIn1). }
  claim HxProp2 : Rlt a2 x /\ ~(Rlt bb2 x).
  { exact (SepE2 R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb2 x0)) x HxIn2). }
  claim Ha1x : Rlt a1 x.
  { exact (andEL (Rlt a1 x) (~(Rlt bb1 x)) HxProp1). }
  claim Hnbb1x : ~(Rlt bb1 x).
  { exact (andER (Rlt a1 x) (~(Rlt bb1 x)) HxProp1). }
  claim Ha2x : Rlt a2 x.
  { exact (andEL (Rlt a2 x) (~(Rlt bb2 x)) HxProp2). }
  claim Hnbb2x : ~(Rlt bb2 x).
  { exact (andER (Rlt a2 x) (~(Rlt bb2 x)) HxProp2). }
  claim Ha1S : SNo a1.
  { exact (real_SNo a1 Ha1R). }
  claim Ha2S : SNo a2.
  { exact (real_SNo a2 Ha2R). }
  claim Hb1S : SNo bb1.
  { exact (real_SNo bb1 Hbb1R). }
  claim Hb2S : SNo bb2.
  { exact (real_SNo bb2 Hbb2R). }
  (** choose max left endpoint and min right endpoint by trichotomy **)
  apply (SNoLt_trichotomy_or_impred a1 a2 Ha1S Ha2S
           (exists b3 :e R_upper_limit_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
  - assume Ha1lt : a1 < a2.
    claim Ha1a2 : Rlt a1 a2.
    { exact (RltI a1 a2 Ha1R Ha2R Ha1lt). }
    apply (SNoLt_trichotomy_or_impred bb1 bb2 Hb1S Hb2S
             (exists b3 :e R_upper_limit_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
    + assume Hb1lt : bb1 < bb2.
      claim Hbb1bb2 : Rlt bb1 bb2.
      { exact (RltI bb1 bb2 Hbb1R Hbb2R Hb1lt). }
      set I3 := halfopen_interval_right a2 bb1.
      witness I3.
      apply andI.
      * (** I3 is in the basis **)
        claim HI3fam : I3 :e {halfopen_interval_right a2 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_right a2 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R}) a2 I3 Ha2R HI3fam).
      * apply andI.
        { (** x in I3 **)
          claim Hconj : Rlt a2 x /\ ~(Rlt bb1 x).
          { apply andI.
            - exact Ha2x.
            - exact Hnbb1x. }
          exact (SepI R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb1 x0)) x HxR Hconj). }
        { (** I3 subset b1  b2 **)
          let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb1 x0)) y Hy). }
          claim HyProp : Rlt a2 y /\ ~(Rlt bb1 y).
          { exact (SepE2 R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb1 x0)) y Hy). }
          claim Ha2y : Rlt a2 y.
          { exact (andEL (Rlt a2 y) (~(Rlt bb1 y)) HyProp). }
          claim Hnbb1y : ~(Rlt bb1 y).
          { exact (andER (Rlt a2 y) (~(Rlt bb1 y)) HyProp). }
          claim Ha1y : Rlt a1 y.
          { exact (Rlt_tra a1 a2 y Ha1a2 Ha2y). }
          claim Hnbb2y : ~(Rlt bb2 y).
          { assume Hbb2y : Rlt bb2 y.
            claim Hbb1y : Rlt bb1 y.
            { exact (Rlt_tra bb1 bb2 y Hbb1bb2 Hbb2y). }
            exact (Hnbb1y Hbb1y). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            claim Hc1 : Rlt a1 y /\ ~(Rlt bb1 y).
            { apply andI.
              - exact Ha1y.
              - exact Hnbb1y. }
            exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y HyR Hc1). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            claim Hc2 : Rlt a2 y /\ ~(Rlt bb2 y).
            { apply andI.
              - exact Ha2y.
              - exact Hnbb2y. }
            exact (SepI R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb2 x0)) y HyR Hc2). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hbeq : bb1 = bb2.
      set I3 := halfopen_interval_right a2 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_right a2 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_right a2 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R}) a2 I3 Ha2R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a2 x /\ ~(Rlt bb1 x).
          { apply andI.
            - exact Ha2x.
            - exact Hnbb1x. }
          exact (SepI R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb1 x0)) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb1 x0)) y Hy). }
          claim HyProp : Rlt a2 y /\ ~(Rlt bb1 y).
          { exact (SepE2 R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb1 x0)) y Hy). }
          claim Ha2y : Rlt a2 y.
          { exact (andEL (Rlt a2 y) (~(Rlt bb1 y)) HyProp). }
          claim Hnbb1y : ~(Rlt bb1 y).
          { exact (andER (Rlt a2 y) (~(Rlt bb1 y)) HyProp). }
          claim Ha1y : Rlt a1 y.
          { exact (Rlt_tra a1 a2 y Ha1a2 Ha2y). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            claim Hc1 : Rlt a1 y /\ ~(Rlt bb1 y).
            { apply andI.
              - exact Ha1y.
              - exact Hnbb1y. }
            exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y HyR Hc1). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            rewrite <- Hbeq.
            claim Hc2 : Rlt a2 y /\ ~(Rlt bb1 y).
            { apply andI.
              - exact Ha2y.
              - exact Hnbb1y. }
            exact (SepI R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb1 x0)) y HyR Hc2). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hb2lt : bb2 < bb1.
      claim Hbb2bb1 : Rlt bb2 bb1.
      { exact (RltI bb2 bb1 Hbb2R Hbb1R Hb2lt). }
      set I3 := halfopen_interval_right a2 bb2.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_right a2 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_right a2 bb) bb2 Hbb2R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R}) a2 I3 Ha2R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a2 x /\ ~(Rlt bb2 x).
          { apply andI.
            - exact Ha2x.
            - exact Hnbb2x. }
          exact (SepI R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb2 x0)) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb2 x0)) y Hy). }
          claim HyProp : Rlt a2 y /\ ~(Rlt bb2 y).
          { exact (SepE2 R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb2 x0)) y Hy). }
          claim Ha2y : Rlt a2 y.
          { exact (andEL (Rlt a2 y) (~(Rlt bb2 y)) HyProp). }
          claim Hnbb2y : ~(Rlt bb2 y).
          { exact (andER (Rlt a2 y) (~(Rlt bb2 y)) HyProp). }
          claim Ha1y : Rlt a1 y.
          { exact (Rlt_tra a1 a2 y Ha1a2 Ha2y). }
          claim Hnbb1y : ~(Rlt bb1 y).
          { assume Hbb1y : Rlt bb1 y.
            claim Hbb2y : Rlt bb2 y.
            { exact (Rlt_tra bb2 bb1 y Hbb2bb1 Hbb1y). }
            exact (Hnbb2y Hbb2y). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            claim Hc1 : Rlt a1 y /\ ~(Rlt bb1 y).
            { apply andI.
              - exact Ha1y.
              - exact Hnbb1y. }
            exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y HyR Hc1). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            claim Hc2 : Rlt a2 y /\ ~(Rlt bb2 y).
            { apply andI.
              - exact Ha2y.
              - exact Hnbb2y. }
            exact (SepI R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb2 x0)) y HyR Hc2). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
  - assume Haeq : a1 = a2.
    apply (SNoLt_trichotomy_or_impred bb1 bb2 Hb1S Hb2S
             (exists b3 :e R_upper_limit_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
    + assume Hb1lt : bb1 < bb2.
      claim Hbb1bb2 : Rlt bb1 bb2.
      { exact (RltI bb1 bb2 Hbb1R Hbb2R Hb1lt). }
      set I3 := halfopen_interval_right a1 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_right a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_right a1 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ ~(Rlt bb1 x).
          { apply andI.
            - exact Ha1x.
            - exact Hnbb1x. }
          exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y Hy). }
          claim HyProp : Rlt a1 y /\ ~(Rlt bb1 y).
          { exact (SepE2 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y Hy). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (~(Rlt bb1 y)) HyProp). }
          claim Hnbb1y : ~(Rlt bb1 y).
          { exact (andER (Rlt a1 y) (~(Rlt bb1 y)) HyProp). }
          claim Hnbb2y : ~(Rlt bb2 y).
          { assume Hbb2y : Rlt bb2 y.
            claim Hbb1y : Rlt bb1 y.
            { exact (Rlt_tra bb1 bb2 y Hbb1bb2 Hbb2y). }
            exact (Hnbb1y Hbb1y). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            claim Hc1 : Rlt a1 y /\ ~(Rlt bb1 y).
            { apply andI.
              - exact Ha1y.
              - exact Hnbb1y. }
            exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y HyR Hc1). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            rewrite <- Haeq.
            claim Hc2 : Rlt a1 y /\ ~(Rlt bb2 y).
            { apply andI.
              - exact Ha1y.
              - exact Hnbb2y. }
            exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb2 x0)) y HyR Hc2). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hbeq : bb1 = bb2.
      set I3 := halfopen_interval_right a1 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_right a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_right a1 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ ~(Rlt bb1 x).
          { apply andI.
            - exact Ha1x.
            - exact Hnbb1x. }
          exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq. exact Hy. }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            rewrite <- Haeq.
            rewrite <- Hbeq.
            exact Hy. }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hb2lt : bb2 < bb1.
      claim Hbb2bb1 : Rlt bb2 bb1.
      { exact (RltI bb2 bb1 Hbb2R Hbb1R Hb2lt). }
      set I3 := halfopen_interval_right a1 bb2.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_right a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_right a1 bb) bb2 Hbb2R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ ~(Rlt bb2 x).
          { apply andI.
            - exact Ha1x.
            - exact Hnbb2x. }
          exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb2 x0)) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb2 x0)) y Hy). }
          claim HyProp : Rlt a1 y /\ ~(Rlt bb2 y).
          { exact (SepE2 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb2 x0)) y Hy). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (~(Rlt bb2 y)) HyProp). }
          claim Hnbb2y : ~(Rlt bb2 y).
          { exact (andER (Rlt a1 y) (~(Rlt bb2 y)) HyProp). }
          claim Hnbb1y : ~(Rlt bb1 y).
          { assume Hbb1y : Rlt bb1 y.
            claim Hbb2y : Rlt bb2 y.
            { exact (Rlt_tra bb2 bb1 y Hbb2bb1 Hbb1y). }
            exact (Hnbb2y Hbb2y). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            claim Hc1 : Rlt a1 y /\ ~(Rlt bb1 y).
            { apply andI.
              - exact Ha1y.
              - exact Hnbb1y. }
            exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y HyR Hc1). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            rewrite <- Haeq.
            claim Hc2 : Rlt a1 y /\ ~(Rlt bb2 y).
            { apply andI.
              - exact Ha1y.
              - exact Hnbb2y. }
            exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb2 x0)) y HyR Hc2). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
  - assume Ha2lt : a2 < a1.
    claim Ha2a1 : Rlt a2 a1.
    { exact (RltI a2 a1 Ha2R Ha1R Ha2lt). }
    apply (SNoLt_trichotomy_or_impred bb1 bb2 Hb1S Hb2S
             (exists b3 :e R_upper_limit_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
    + assume Hb1lt : bb1 < bb2.
      claim Hbb1bb2 : Rlt bb1 bb2.
      { exact (RltI bb1 bb2 Hbb1R Hbb2R Hb1lt). }
      set I3 := halfopen_interval_right a1 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_right a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_right a1 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ ~(Rlt bb1 x).
          { apply andI.
            - exact Ha1x.
            - exact Hnbb1x. }
          exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y Hy). }
          claim HyProp : Rlt a1 y /\ ~(Rlt bb1 y).
          { exact (SepE2 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y Hy). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (~(Rlt bb1 y)) HyProp). }
          claim Hnbb1y : ~(Rlt bb1 y).
          { exact (andER (Rlt a1 y) (~(Rlt bb1 y)) HyProp). }
          claim Ha2y : Rlt a2 y.
          { exact (Rlt_tra a2 a1 y Ha2a1 Ha1y). }
          claim Hnbb2y : ~(Rlt bb2 y).
          { assume Hbb2y : Rlt bb2 y.
            claim Hbb1y : Rlt bb1 y.
            { exact (Rlt_tra bb1 bb2 y Hbb1bb2 Hbb2y). }
            exact (Hnbb1y Hbb1y). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            claim Hc1 : Rlt a1 y /\ ~(Rlt bb1 y).
            { apply andI.
              - exact Ha1y.
              - exact Hnbb1y. }
            exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y HyR Hc1). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            claim Hc2 : Rlt a2 y /\ ~(Rlt bb2 y).
            { apply andI.
              - exact Ha2y.
              - exact Hnbb2y. }
            exact (SepI R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb2 x0)) y HyR Hc2). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hbeq : bb1 = bb2.
      set I3 := halfopen_interval_right a1 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_right a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_right a1 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ ~(Rlt bb1 x).
          { apply andI.
            - exact Ha1x.
            - exact Hnbb1x. }
          exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y Hy). }
          claim HyProp : Rlt a1 y /\ ~(Rlt bb1 y).
          { exact (SepE2 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y Hy). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (~(Rlt bb1 y)) HyProp). }
          claim Hnbb1y : ~(Rlt bb1 y).
          { exact (andER (Rlt a1 y) (~(Rlt bb1 y)) HyProp). }
          claim Ha2y : Rlt a2 y.
          { exact (Rlt_tra a2 a1 y Ha2a1 Ha1y). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq. exact Hy. }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            claim Hnbb2y : ~(Rlt bb2 y).
              { assume Hbb2y : Rlt bb2 y.
                claim Hbb1y : Rlt bb1 y.
              { rewrite Hbeq at 1.
                exact Hbb2y. }
                exact (Hnbb1y Hbb1y). }
            claim Hc2 : Rlt a2 y /\ ~(Rlt bb2 y).
            { apply andI.
              - exact Ha2y.
              - exact Hnbb2y. }
            exact (SepI R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb2 x0)) y HyR Hc2). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hb2lt : bb2 < bb1.
      claim Hbb2bb1 : Rlt bb2 bb1.
      { exact (RltI bb2 bb1 Hbb2R Hbb1R Hb2lt). }
      set I3 := halfopen_interval_right a1 bb2.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_right a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_right a1 bb) bb2 Hbb2R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ ~(Rlt bb2 x).
          { apply andI.
            - exact Ha1x.
            - exact Hnbb2x. }
          exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb2 x0)) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb2 x0)) y Hy). }
          claim HyProp : Rlt a1 y /\ ~(Rlt bb2 y).
          { exact (SepE2 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb2 x0)) y Hy). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (~(Rlt bb2 y)) HyProp). }
          claim Hnbb2y : ~(Rlt bb2 y).
          { exact (andER (Rlt a1 y) (~(Rlt bb2 y)) HyProp). }
          claim Ha2y : Rlt a2 y.
          { exact (Rlt_tra a2 a1 y Ha2a1 Ha1y). }
          claim Hnbb1y : ~(Rlt bb1 y).
          { assume Hbb1y : Rlt bb1 y.
            claim Hbb2y : Rlt bb2 y.
            { exact (Rlt_tra bb2 bb1 y Hbb2bb1 Hbb1y). }
            exact (Hnbb2y Hbb2y). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            claim Hc1 : Rlt a1 y /\ ~(Rlt bb1 y).
            { apply andI.
              - exact Ha1y.
              - exact Hnbb1y. }
            exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y HyR Hc1). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            claim Hc2 : Rlt a2 y /\ ~(Rlt bb2 y).
            { apply andI.
              - exact Ha2y.
              - exact Hnbb2y. }
            exact (SepI R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb2 x0)) y HyR Hc2). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
Qed.

(** from 13 Exercise 7: upper limit topology on R **)
(** LATEX VERSION: The upper limit topology is the topology generated by that basis. **)
Definition R_upper_limit_topology : set :=
  generated_topology R R_upper_limit_basis.

(** helper: the upper limit topology on R is a topology **)
Theorem R_upper_limit_topology_is_topology_local : topology_on R R_upper_limit_topology.
exact (lemma_topology_from_basis R R_upper_limit_basis R_upper_limit_basis_is_basis_local).
Qed.

(** FIXED: Now uses proper reciprocal from line 5762; recip_SNo computes 1/x for surreal numbers (including naturals), so for n, recip_SNo n computes 1/n. **)
Definition inv_nat : set -> set := recip_SNo.

(** helper: 1/n is real for n in omega **)
Theorem inv_nat_real : forall n:set, n :e omega -> inv_nat n :e R.
let n. assume Hn: n :e omega.
prove inv_nat n :e R.
(** omega is included in SNoS_ omega, and SNoS_ omega is included in real **)
claim HnSNoS: n :e SNoS_ omega.
{ exact (omega_SNoS_omega n Hn). }
claim HnR: n :e real.
{ exact (SNoS_omega_real n HnSNoS). }
exact (real_recip_SNo n HnR).
Qed.

(** from 13 Exercise 6: the set K={1/n | n in omega and n not 0} used in the K-topology **)
(** LATEX VERSION: Let K={1/n : n in N} as a subset of R (excluding n=0). **)
Definition K_set : set := {inv_nat n|n :e omega :\: {0}}.

(** helper: 0 is not in K_set **)
Theorem zero_not_in_K_set : 0 /:e K_set.
assume H0K: 0 :e K_set.
apply (ReplE (omega :\: {0}) (fun n:set => inv_nat n) 0 H0K).
let n. assume Hnconj.
claim HnIn: n :e omega :\: {0}.
{ exact (andEL (n :e omega :\: {0}) (0 = inv_nat n) Hnconj). }
claim H0eq: 0 = inv_nat n.
{ exact (andER (n :e omega :\: {0}) (0 = inv_nat n) Hnconj). }
claim HnO: n :e omega.
{ exact (setminusE1 omega {0} n HnIn). }
claim Hnnot0: n /:e {0}.
{ exact (setminusE2 omega {0} n HnIn). }
claim HnNat: nat_p n.
{ exact (omega_nat_p n HnO). }
claim HnCase: n = 0 \/ exists k:set, nat_p k /\ n = ordsucc k.
{ exact (nat_inv n HnNat). }
claim Hexk: exists k:set, nat_p k /\ n = ordsucc k.
{ apply (HnCase (exists k:set, nat_p k /\ n = ordsucc k)).
  - assume Hn0: n = 0.
    apply FalseE.
    claim Hnin0: n :e {0}.
    { rewrite Hn0. exact (SingI 0). }
    exact (Hnnot0 Hnin0).
  - assume H. exact H. }
apply Hexk.
let k. assume Hkconj.
claim Hkeq: n = ordsucc k.
{ exact (andER (nat_p k) (n = ordsucc k) Hkconj). }
claim HkNat: nat_p k.
{ exact (andEL (nat_p k) (n = ordsucc k) Hkconj). }
claim HkOrd: ordinal k.
{ exact (nat_p_ordinal k HkNat). }
claim Hpos: 0 < n.
{ rewrite Hkeq.
  exact (ordinal_ordsucc_pos k HkOrd). }
claim HSn: SNo n.
{ exact (omega_SNo n HnO). }
claim Hposcase: inv_nat n = recip_SNo_pos n.
{ exact (recip_SNo_poscase n Hpos). }
claim HrecipPos: 0 < recip_SNo_pos n.
{ exact (recip_SNo_pos_is_pos n HSn Hpos). }
claim HinvPos: 0 < inv_nat n.
{ rewrite Hposcase.
  exact HrecipPos. }
claim H0lt0: 0 < 0.
{ rewrite H0eq at 2.
  exact HinvPos. }
exact ((SNoLt_irref 0) H0lt0).
Qed.

(** helper: K_set is a subset of R **)
Theorem K_set_Subq_R : K_set c= R.
let x. assume Hx: x :e K_set.
apply (ReplE_impred (omega :\: {0}) (fun n:set => inv_nat n) x Hx (x :e R)).
let n. assume HnIn: n :e omega :\: {0}. assume Heq: x = inv_nat n.
claim HnO: n :e omega.
{ exact (setminusE1 omega {0} n HnIn). }
rewrite Heq.
exact (inv_nat_real n HnO).
Qed.

(** helper: elements of K_set are positive reals **)
Theorem inv_nat_pos : forall n:set, n :e omega :\: {0} -> Rlt 0 (inv_nat n).
let n. assume HnIn: n :e omega :\: {0}.
claim HnO: n :e omega.
{ exact (setminusE1 omega {0} n HnIn). }
claim Hnnot0: n /:e {0}.
{ exact (setminusE2 omega {0} n HnIn). }
claim HnNat: nat_p n.
{ exact (omega_nat_p n HnO). }
claim HnCase: n = 0 \/ exists k:set, nat_p k /\ n = ordsucc k.
{ exact (nat_inv n HnNat). }
claim Hexk: exists k:set, nat_p k /\ n = ordsucc k.
{ apply (HnCase (exists k:set, nat_p k /\ n = ordsucc k)).
  - assume Hn0: n = 0.
    apply FalseE.
    claim Hnin0: n :e {0}.
    { rewrite Hn0. exact (SingI 0). }
    exact (Hnnot0 Hnin0).
  - assume H. exact H. }
apply Hexk.
let k. assume Hkconj.
claim Hkeq: n = ordsucc k.
{ exact (andER (nat_p k) (n = ordsucc k) Hkconj). }
claim HkNat: nat_p k.
{ exact (andEL (nat_p k) (n = ordsucc k) Hkconj). }
claim HkOrd: ordinal k.
{ exact (nat_p_ordinal k HkNat). }
claim Hpos: 0 < n.
{ rewrite Hkeq.
  exact (ordinal_ordsucc_pos k HkOrd). }
claim HSn: SNo n.
{ exact (omega_SNo n HnO). }
claim Hposcase: inv_nat n = recip_SNo_pos n.
{ exact (recip_SNo_poscase n Hpos). }
claim HrecipPos: 0 < recip_SNo_pos n.
{ exact (recip_SNo_pos_is_pos n HSn Hpos). }
claim HinvPos: 0 < inv_nat n.
{ rewrite Hposcase.
  exact HrecipPos. }
claim HinvR: inv_nat n :e R.
{ exact (inv_nat_real n HnO). }
exact (RltI 0 (inv_nat n) real_0 HinvR HinvPos).
Qed.

Definition R_K_basis : set :=
  \/_ a :e R, {open_interval a b :\: K_set|b :e R}.

Definition R_K_topology : set :=
  generated_topology R (R_standard_basis :\/: R_K_basis).

(** helper: the K topology basis is a basis on R **)
Theorem R_standard_plus_K_basis_is_basis_local : basis_on R (R_standard_basis :\/: R_K_basis).
prove basis_on R (R_standard_basis :\/: R_K_basis).
prove (R_standard_basis :\/: R_K_basis) c= Power R
  /\ (forall x :e R, exists b :e (R_standard_basis :\/: R_K_basis), x :e b)
  /\ (forall b1 :e (R_standard_basis :\/: R_K_basis), forall b2 :e (R_standard_basis :\/: R_K_basis), forall x:set,
        x :e b1 -> x :e b2 ->
        exists b3 :e (R_standard_basis :\/: R_K_basis), x :e b3 /\ b3 c= b1 :/\: b2).
apply andI.
- apply andI.
  + (** basis elements are subsets of R **)
    let U. assume HU: U :e (R_standard_basis :\/: R_K_basis).
    apply (binunionE' R_standard_basis R_K_basis U (U :e Power R)).
    - (** U from standard basis **)
      assume HUstd: U :e R_standard_basis.
      claim HUsubR: U c= R.
      { exact (basis_elem_subset R R_standard_basis U R_standard_basis_is_basis_local HUstd). }
      exact (PowerI R U HUsubR).
    - (** U from K basis **)
      assume HUk: U :e R_K_basis.
      claim Hexa : exists a :e R, U :e {open_interval a b :\: K_set|b :e R}.
      { exact (famunionE R (fun a0 : set => {open_interval a0 b :\: K_set|b :e R}) U HUk). }
      apply Hexa.
      let a. assume Hapair.
      claim HaR: a :e R.
      { exact (andEL (a :e R) (U :e {open_interval a b :\: K_set|b :e R}) Hapair). }
      claim HUfam: U :e {open_interval a b :\: K_set|b :e R}.
      { exact (andER (a :e R) (U :e {open_interval a b :\: K_set|b :e R}) Hapair). }
      claim Hexb: exists b :e R, U = open_interval a b :\: K_set.
      { exact (ReplE R (fun b0 : set => open_interval a b0 :\: K_set) U HUfam). }
      apply Hexb.
      let b. assume Hbpair.
      claim HbR: b :e R.
      { exact (andEL (b :e R) (U = open_interval a b :\: K_set) Hbpair). }
      claim HUeq: U = open_interval a b :\: K_set.
      { exact (andER (b :e R) (U = open_interval a b :\: K_set) Hbpair). }
      rewrite HUeq.
      claim Hsub1: (open_interval a b :\: K_set) c= open_interval a b.
      { exact (setminus_Subq (open_interval a b) K_set). }
      claim Hsub2: open_interval a b c= R.
      { exact (open_interval_Subq_R a b). }
      exact (PowerI R (open_interval a b :\: K_set) (Subq_tra (open_interval a b :\: K_set) (open_interval a b) R Hsub1 Hsub2)).
    - exact HU.
  + (** coverage: inherit from standard basis **)
    let x. assume HxR: x :e R.
    claim Hcov: forall x0 :e R, exists b :e R_standard_basis, x0 :e b.
    { exact (andER (R_standard_basis c= Power R)
                   (forall x0 :e R, exists b :e R_standard_basis, x0 :e b)
                   (andEL (R_standard_basis c= Power R /\
                           (forall x0 :e R, exists b :e R_standard_basis, x0 :e b))
                          (forall b1 :e R_standard_basis, forall b2 :e R_standard_basis, forall x0:set,
                            x0 :e b1 -> x0 :e b2 ->
                            exists b3 :e R_standard_basis, x0 :e b3 /\ b3 c= b1 :/\: b2)
                          R_standard_basis_is_basis_local)). }
    claim Hex: exists b :e R_standard_basis, x :e b.
    { exact (Hcov x HxR). }
    apply Hex.
    let b. assume Hbpair.
    witness b.
    apply andI.
    * exact (binunionI1 R_standard_basis R_K_basis b (andEL (b :e R_standard_basis) (x :e b) Hbpair)).
    * exact (andER (b :e R_standard_basis) (x :e b) Hbpair).
- (** intersection refinement **)
  let b1. assume Hb1.
  let b2. assume Hb2.
  let x. assume Hx1 Hx2.
  prove exists b3 :e (R_standard_basis :\/: R_K_basis), x :e b3 /\ b3 c= b1 :/\: b2.
  claim HstdInt:
    forall u1 :e R_standard_basis, forall u2 :e R_standard_basis, forall x0:set,
      x0 :e u1 -> x0 :e u2 ->
      exists u3 :e R_standard_basis, x0 :e u3 /\ u3 c= u1 :/\: u2.
  { exact (andER (R_standard_basis c= Power R /\ (forall x0 :e R, exists b :e R_standard_basis, x0 :e b))
                 (forall u1 :e R_standard_basis, forall u2 :e R_standard_basis, forall x0:set,
                   x0 :e u1 -> x0 :e u2 ->
                   exists u3 :e R_standard_basis, x0 :e u3 /\ u3 c= u1 :/\: u2)
                 R_standard_basis_is_basis_local). }
  apply (binunionE' R_standard_basis R_K_basis b1 (exists b3 :e (R_standard_basis :\/: R_K_basis), x :e b3 /\ b3 c= b1 :/\: b2)).
  - assume Hb1Std: b1 :e R_standard_basis.
    apply (binunionE' R_standard_basis R_K_basis b2 (exists b3 :e (R_standard_basis :\/: R_K_basis), x :e b3 /\ b3 c= b1 :/\: b2)).
    + assume Hb2Std: b2 :e R_standard_basis.
      apply (HstdInt b1 Hb1Std b2 Hb2Std x Hx1 Hx2).
      let b3std. assume Hb3pair.
      witness b3std.
      apply andI.
      * exact (binunionI1 R_standard_basis R_K_basis b3std (andEL (b3std :e R_standard_basis) (x :e b3std /\ b3std c= b1 :/\: b2) Hb3pair)).
      * exact (andER (b3std :e R_standard_basis) (x :e b3std /\ b3std c= b1 :/\: b2) Hb3pair).
    + assume Hb2K: b2 :e R_K_basis.
      (** destruct b2 = open_interval a2 bb2 \\ K_set **)
      claim Hexa2 : exists a2 :e R, b2 :e {open_interval a2 b :\: K_set|b :e R}.
      { exact (famunionE R (fun a0 : set => {open_interval a0 b :\: K_set|b :e R}) b2 Hb2K). }
      apply Hexa2.
      let a2. assume Ha2pair.
      claim Ha2R : a2 :e R.
      { exact (andEL (a2 :e R) (b2 :e {open_interval a2 b :\: K_set|b :e R}) Ha2pair). }
      claim Hb2fam : b2 :e {open_interval a2 b :\: K_set|b :e R}.
      { exact (andER (a2 :e R) (b2 :e {open_interval a2 b :\: K_set|b :e R}) Ha2pair). }
      claim Hexb2 : exists bb2 :e R, b2 = open_interval a2 bb2 :\: K_set.
      { exact (ReplE R (fun bb : set => open_interval a2 bb :\: K_set) b2 Hb2fam). }
      apply Hexb2.
      let bb2. assume Hbb2pair.
      claim Hbb2R : bb2 :e R.
      { exact (andEL (bb2 :e R) (b2 = open_interval a2 bb2 :\: K_set) Hbb2pair). }
      claim Hb2eq : b2 = open_interval a2 bb2 :\: K_set.
      { exact (andER (bb2 :e R) (b2 = open_interval a2 bb2 :\: K_set) Hbb2pair). }
      set I2 := open_interval a2 bb2.
      claim HI2Std: I2 :e R_standard_basis.
      { claim HI2fam : I2 :e {open_interval a2 b|b :e R}.
        { exact (ReplI R (fun b0 : set => open_interval a2 b0) bb2 Hbb2R). }
        exact (famunionI R (fun a0 : set => {open_interval a0 b|b :e R}) a2 I2 Ha2R HI2fam). }
      claim HxInB2: x :e I2 :\: K_set.
      { rewrite <- Hb2eq.
        exact Hx2. }
      claim HxInI2: x :e I2.
      { exact (setminusE1 I2 K_set x HxInB2). }
      claim HxNotK: x /:e K_set.
      { exact (setminusE2 I2 K_set x HxInB2). }
      apply (HstdInt b1 Hb1Std I2 HI2Std x Hx1 HxInI2).
      let I0. assume HI0pair.
      claim HI0Std: I0 :e R_standard_basis.
      { exact (andEL (I0 :e R_standard_basis) (x :e I0 /\ I0 c= b1 :/\: I2) HI0pair). }
      claim HI0rest: x :e I0 /\ I0 c= b1 :/\: I2.
      { exact (andER (I0 :e R_standard_basis) (x :e I0 /\ I0 c= b1 :/\: I2) HI0pair). }
      claim HxI0: x :e I0.
      { exact (andEL (x :e I0) (I0 c= b1 :/\: I2) HI0rest). }
      claim HI0sub: I0 c= b1 :/\: I2.
      { exact (andER (x :e I0) (I0 c= b1 :/\: I2) HI0rest). }
      (** destruct I0 = open_interval c d **)
      claim Hexc : exists c :e R, I0 :e {open_interval c b|b :e R}.
      { exact (famunionE R (fun c0 : set => {open_interval c0 b|b :e R}) I0 HI0Std). }
      apply Hexc.
      let c. assume Hcpair.
      claim HcR: c :e R.
      { exact (andEL (c :e R) (I0 :e {open_interval c b|b :e R}) Hcpair). }
      claim HI0fam: I0 :e {open_interval c b|b :e R}.
      { exact (andER (c :e R) (I0 :e {open_interval c b|b :e R}) Hcpair). }
      claim Hexd : exists d :e R, I0 = open_interval c d.
      { exact (ReplE R (fun d0 : set => open_interval c d0) I0 HI0fam). }
      apply Hexd.
      let d. assume Hdpair.
      claim HdR: d :e R.
      { exact (andEL (d :e R) (I0 = open_interval c d) Hdpair). }
      claim HI0eq: I0 = open_interval c d.
      { exact (andER (d :e R) (I0 = open_interval c d) Hdpair). }
      set Kint := open_interval c d :\: K_set.
      witness Kint.
      apply andI.
      * (** Kint is in the union basis via the K basis **)
        claim HKfam : Kint :e {open_interval c b :\: K_set|b :e R}.
        { exact (ReplI R (fun b0 : set => open_interval c b0 :\: K_set) d HdR). }
        claim HKinK : Kint :e R_K_basis.
        { exact (famunionI R (fun a0 : set => {open_interval a0 b :\: K_set|b :e R}) c Kint HcR HKfam). }
        exact (binunionI2 R_standard_basis R_K_basis Kint HKinK).
      * apply andI.
        { (** x in Kint **)
          prove x :e open_interval c d :\: K_set.
          apply setminusI.
          - prove x :e open_interval c d.
            rewrite <- HI0eq.
            exact HxI0.
          - exact HxNotK. }
        { (** subset property **)
          let y. assume Hy: y :e Kint.
          prove y :e b1 :/\: b2.
          claim HyOpen: y :e open_interval c d.
          { exact (setminusE1 (open_interval c d) K_set y Hy). }
          claim HyI0: y :e I0.
          { rewrite HI0eq.
            exact HyOpen. }
          claim HyNotK: y /:e K_set.
          { exact (setminusE2 (open_interval c d) K_set y Hy). }
          claim Hyb1I2: y :e b1 :/\: I2.
          { exact (HI0sub y HyI0). }
          claim Hyb1: y :e b1.
          { exact (binintersectE1 b1 I2 y Hyb1I2). }
          claim HyI2: y :e I2.
          { exact (binintersectE2 b1 I2 y Hyb1I2). }
          claim Hyb2: y :e b2.
          { rewrite Hb2eq.
            exact (setminusI I2 K_set y HyI2 HyNotK). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + exact Hb2.
  - assume Hb1K: b1 :e R_K_basis.
    apply (binunionE' R_standard_basis R_K_basis b2 (exists b3 :e (R_standard_basis :\/: R_K_basis), x :e b3 /\ b3 c= b1 :/\: b2)).
    + assume Hb2Std: b2 :e R_standard_basis.
      (** symmetric to the previous mixed case **)
      claim Hexa1 : exists a1 :e R, b1 :e {open_interval a1 b :\: K_set|b :e R}.
      { exact (famunionE R (fun a0 : set => {open_interval a0 b :\: K_set|b :e R}) b1 Hb1K). }
      apply Hexa1.
      let a1. assume Ha1pair.
      claim Ha1R : a1 :e R.
      { exact (andEL (a1 :e R) (b1 :e {open_interval a1 b :\: K_set|b :e R}) Ha1pair). }
      claim Hb1fam : b1 :e {open_interval a1 b :\: K_set|b :e R}.
      { exact (andER (a1 :e R) (b1 :e {open_interval a1 b :\: K_set|b :e R}) Ha1pair). }
      claim Hexb1 : exists bb1 :e R, b1 = open_interval a1 bb1 :\: K_set.
      { exact (ReplE R (fun bb : set => open_interval a1 bb :\: K_set) b1 Hb1fam). }
      apply Hexb1.
      let bb1. assume Hbb1pair.
      claim Hbb1R : bb1 :e R.
      { exact (andEL (bb1 :e R) (b1 = open_interval a1 bb1 :\: K_set) Hbb1pair). }
      claim Hb1eq : b1 = open_interval a1 bb1 :\: K_set.
      { exact (andER (bb1 :e R) (b1 = open_interval a1 bb1 :\: K_set) Hbb1pair). }
      set I1 := open_interval a1 bb1.
      claim HI1Std: I1 :e R_standard_basis.
      { claim HI1fam : I1 :e {open_interval a1 b|b :e R}.
        { exact (ReplI R (fun b0 : set => open_interval a1 b0) bb1 Hbb1R). }
        exact (famunionI R (fun a0 : set => {open_interval a0 b|b :e R}) a1 I1 Ha1R HI1fam). }
      claim HxInB1: x :e I1 :\: K_set.
      { rewrite <- Hb1eq.
        exact Hx1. }
      claim HxInI1: x :e I1.
      { exact (setminusE1 I1 K_set x HxInB1). }
      claim HxNotK: x /:e K_set.
      { exact (setminusE2 I1 K_set x HxInB1). }
      apply (HstdInt I1 HI1Std b2 Hb2Std x HxInI1 Hx2).
      let I0. assume HI0pair.
      claim HI0Std: I0 :e R_standard_basis.
      { exact (andEL (I0 :e R_standard_basis) (x :e I0 /\ I0 c= I1 :/\: b2) HI0pair). }
      claim HI0rest: x :e I0 /\ I0 c= I1 :/\: b2.
      { exact (andER (I0 :e R_standard_basis) (x :e I0 /\ I0 c= I1 :/\: b2) HI0pair). }
      claim HxI0: x :e I0.
      { exact (andEL (x :e I0) (I0 c= I1 :/\: b2) HI0rest). }
      claim HI0sub: I0 c= I1 :/\: b2.
      { exact (andER (x :e I0) (I0 c= I1 :/\: b2) HI0rest). }
      claim Hexc : exists c :e R, I0 :e {open_interval c b|b :e R}.
      { exact (famunionE R (fun c0 : set => {open_interval c0 b|b :e R}) I0 HI0Std). }
      apply Hexc.
      let c. assume Hcpair.
      claim HcR: c :e R.
      { exact (andEL (c :e R) (I0 :e {open_interval c b|b :e R}) Hcpair). }
      claim HI0fam: I0 :e {open_interval c b|b :e R}.
      { exact (andER (c :e R) (I0 :e {open_interval c b|b :e R}) Hcpair). }
      claim Hexd : exists d :e R, I0 = open_interval c d.
      { exact (ReplE R (fun d0 : set => open_interval c d0) I0 HI0fam). }
      apply Hexd.
      let d. assume Hdpair.
      claim HdR: d :e R.
      { exact (andEL (d :e R) (I0 = open_interval c d) Hdpair). }
      claim HI0eq: I0 = open_interval c d.
      { exact (andER (d :e R) (I0 = open_interval c d) Hdpair). }
      set Kint := open_interval c d :\: K_set.
      witness Kint.
      apply andI.
      * claim HKfam : Kint :e {open_interval c b :\: K_set|b :e R}.
        { exact (ReplI R (fun b0 : set => open_interval c b0 :\: K_set) d HdR). }
        claim HKinK : Kint :e R_K_basis.
        { exact (famunionI R (fun a0 : set => {open_interval a0 b :\: K_set|b :e R}) c Kint HcR HKfam). }
        exact (binunionI2 R_standard_basis R_K_basis Kint HKinK).
      * apply andI.
        { prove x :e open_interval c d :\: K_set.
          apply setminusI.
          - prove x :e open_interval c d.
            rewrite <- HI0eq.
            exact HxI0.
          - exact HxNotK. }
        { let y. assume Hy: y :e Kint.
          prove y :e b1 :/\: b2.
          claim HyOpen: y :e open_interval c d.
          { exact (setminusE1 (open_interval c d) K_set y Hy). }
          claim HyI0: y :e I0.
          { rewrite HI0eq.
            exact HyOpen. }
          claim HyNotK: y /:e K_set.
          { exact (setminusE2 (open_interval c d) K_set y Hy). }
          claim HyI1b2: y :e I1 :/\: b2.
          { exact (HI0sub y HyI0). }
          claim HyI1: y :e I1.
          { exact (binintersectE1 I1 b2 y HyI1b2). }
          claim Hyb2: y :e b2.
          { exact (binintersectE2 I1 b2 y HyI1b2). }
          claim Hyb1: y :e b1.
          { rewrite Hb1eq.
            exact (setminusI I1 K_set y HyI1 HyNotK). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hb2K: b2 :e R_K_basis.
      (** both K basis elements; refine using their open-interval parts **)
      claim Hexa1 : exists a1 :e R, b1 :e {open_interval a1 b :\: K_set|b :e R}.
      { exact (famunionE R (fun a0 : set => {open_interval a0 b :\: K_set|b :e R}) b1 Hb1K). }
      claim Hexa2 : exists a2 :e R, b2 :e {open_interval a2 b :\: K_set|b :e R}.
      { exact (famunionE R (fun a0 : set => {open_interval a0 b :\: K_set|b :e R}) b2 Hb2K). }
      apply Hexa1.
      let a1. assume Ha1pair.
      claim Ha1R : a1 :e R.
      { exact (andEL (a1 :e R) (b1 :e {open_interval a1 b :\: K_set|b :e R}) Ha1pair). }
      claim Hb1fam : b1 :e {open_interval a1 b :\: K_set|b :e R}.
      { exact (andER (a1 :e R) (b1 :e {open_interval a1 b :\: K_set|b :e R}) Ha1pair). }
      claim Hexb1 : exists bb1 :e R, b1 = open_interval a1 bb1 :\: K_set.
      { exact (ReplE R (fun bb : set => open_interval a1 bb :\: K_set) b1 Hb1fam). }
      apply Hexb1.
      let bb1. assume Hbb1pair.
      claim Hbb1R : bb1 :e R.
      { exact (andEL (bb1 :e R) (b1 = open_interval a1 bb1 :\: K_set) Hbb1pair). }
      claim Hb1eq : b1 = open_interval a1 bb1 :\: K_set.
      { exact (andER (bb1 :e R) (b1 = open_interval a1 bb1 :\: K_set) Hbb1pair). }
      apply Hexa2.
      let a2. assume Ha2pair.
      claim Ha2R : a2 :e R.
      { exact (andEL (a2 :e R) (b2 :e {open_interval a2 b :\: K_set|b :e R}) Ha2pair). }
      claim Hb2fam : b2 :e {open_interval a2 b :\: K_set|b :e R}.
      { exact (andER (a2 :e R) (b2 :e {open_interval a2 b :\: K_set|b :e R}) Ha2pair). }
      claim Hexb2 : exists bb2 :e R, b2 = open_interval a2 bb2 :\: K_set.
      { exact (ReplE R (fun bb : set => open_interval a2 bb :\: K_set) b2 Hb2fam). }
      apply Hexb2.
      let bb2. assume Hbb2pair.
      claim Hbb2R : bb2 :e R.
      { exact (andEL (bb2 :e R) (b2 = open_interval a2 bb2 :\: K_set) Hbb2pair). }
      claim Hb2eq : b2 = open_interval a2 bb2 :\: K_set.
      { exact (andER (bb2 :e R) (b2 = open_interval a2 bb2 :\: K_set) Hbb2pair). }
      set I1 := open_interval a1 bb1.
      set I2 := open_interval a2 bb2.
      claim HI1Std: I1 :e R_standard_basis.
      { claim HI1fam : I1 :e {open_interval a1 b|b :e R}.
        { exact (ReplI R (fun b0 : set => open_interval a1 b0) bb1 Hbb1R). }
        exact (famunionI R (fun a0 : set => {open_interval a0 b|b :e R}) a1 I1 Ha1R HI1fam). }
      claim HI2Std: I2 :e R_standard_basis.
      { claim HI2fam : I2 :e {open_interval a2 b|b :e R}.
        { exact (ReplI R (fun b0 : set => open_interval a2 b0) bb2 Hbb2R). }
        exact (famunionI R (fun a0 : set => {open_interval a0 b|b :e R}) a2 I2 Ha2R HI2fam). }
      claim HxInB1: x :e I1 :\: K_set.
      { rewrite <- Hb1eq.
        exact Hx1. }
      claim HxInB2: x :e I2 :\: K_set.
      { rewrite <- Hb2eq.
        exact Hx2. }
      claim HxInI1: x :e I1.
      { exact (setminusE1 I1 K_set x HxInB1). }
      claim HxInI2: x :e I2.
      { exact (setminusE1 I2 K_set x HxInB2). }
      claim HxNotK: x /:e K_set.
      { exact (setminusE2 I1 K_set x HxInB1). }
      apply (HstdInt I1 HI1Std I2 HI2Std x HxInI1 HxInI2).
      let I0. assume HI0pair.
      claim HI0Std: I0 :e R_standard_basis.
      { exact (andEL (I0 :e R_standard_basis) (x :e I0 /\ I0 c= I1 :/\: I2) HI0pair). }
      claim HI0rest: x :e I0 /\ I0 c= I1 :/\: I2.
      { exact (andER (I0 :e R_standard_basis) (x :e I0 /\ I0 c= I1 :/\: I2) HI0pair). }
      claim HxI0: x :e I0.
      { exact (andEL (x :e I0) (I0 c= I1 :/\: I2) HI0rest). }
      claim HI0sub: I0 c= I1 :/\: I2.
      { exact (andER (x :e I0) (I0 c= I1 :/\: I2) HI0rest). }
      claim Hexc : exists c :e R, I0 :e {open_interval c b|b :e R}.
      { exact (famunionE R (fun c0 : set => {open_interval c0 b|b :e R}) I0 HI0Std). }
      apply Hexc.
      let c. assume Hcpair.
      claim HcR: c :e R.
      { exact (andEL (c :e R) (I0 :e {open_interval c b|b :e R}) Hcpair). }
      claim HI0fam: I0 :e {open_interval c b|b :e R}.
      { exact (andER (c :e R) (I0 :e {open_interval c b|b :e R}) Hcpair). }
      claim Hexd : exists d :e R, I0 = open_interval c d.
      { exact (ReplE R (fun d0 : set => open_interval c d0) I0 HI0fam). }
      apply Hexd.
      let d. assume Hdpair.
      claim HdR: d :e R.
      { exact (andEL (d :e R) (I0 = open_interval c d) Hdpair). }
      claim HI0eq: I0 = open_interval c d.
      { exact (andER (d :e R) (I0 = open_interval c d) Hdpair). }
      set Kint := open_interval c d :\: K_set.
      witness Kint.
      apply andI.
      * claim HKfam : Kint :e {open_interval c b :\: K_set|b :e R}.
        { exact (ReplI R (fun b0 : set => open_interval c b0 :\: K_set) d HdR). }
        claim HKinK : Kint :e R_K_basis.
        { exact (famunionI R (fun a0 : set => {open_interval a0 b :\: K_set|b :e R}) c Kint HcR HKfam). }
        exact (binunionI2 R_standard_basis R_K_basis Kint HKinK).
      * apply andI.
        { prove x :e open_interval c d :\: K_set.
          apply setminusI.
          - prove x :e open_interval c d.
            rewrite <- HI0eq.
            exact HxI0.
          - exact HxNotK. }
        { let y. assume Hy: y :e Kint.
          prove y :e b1 :/\: b2.
          claim HyOpen: y :e open_interval c d.
          { exact (setminusE1 (open_interval c d) K_set y Hy). }
          claim HyI0: y :e I0.
          { rewrite HI0eq.
            exact HyOpen. }
          claim HyNotK: y /:e K_set.
          { exact (setminusE2 (open_interval c d) K_set y Hy). }
          claim HyI1I2: y :e I1 :/\: I2.
          { exact (HI0sub y HyI0). }
          claim HyI1: y :e I1.
          { exact (binintersectE1 I1 I2 y HyI1I2). }
          claim HyI2: y :e I2.
          { exact (binintersectE2 I1 I2 y HyI1I2). }
          claim Hyb1: y :e b1.
          { rewrite Hb1eq.
            exact (setminusI I1 K_set y HyI1 HyNotK). }
          claim Hyb2: y :e b2.
          { rewrite Hb2eq.
            exact (setminusI I2 K_set y HyI2 HyNotK). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + exact Hb2.
  - exact Hb1.
Qed.

(** helper: the K topology on R is a topology **)
Theorem R_K_topology_is_topology_local : topology_on R R_K_topology.
exact (lemma_topology_from_basis R (R_standard_basis :\/: R_K_basis) R_standard_plus_K_basis_is_basis_local).
Qed.

(** helper: K_set meets any lower limit neighborhood of 0 **)
(** LATEX VERSION: In the lower limit topology, every basic neighborhood [a,b) of 0 contains some element of K={1/n}. **)
Theorem K_set_meets_lower_limit_neighborhood_0 :
  forall a b:set,
    a :e R -> b :e R ->
    ~(Rlt 0 a) ->
    Rlt 0 b ->
    exists y:set, y :e halfopen_interval_left a b /\ y :e K_set.
let a b.
assume HaR: a :e R.
assume HbR: b :e R.
assume Hnot0a: ~(Rlt 0 a).
assume H0b: Rlt 0 b.
set r := recip_SNo b.
claim HbS: SNo b.
{ exact (real_SNo b HbR). }
claim H0ltb: 0 < b.
{ exact (RltE_lt 0 b H0b). }
claim Hbne0: b <> 0.
{ assume Hb0: b = 0.
  claim H00: 0 < 0.
  { rewrite <- Hb0 at 2.
    exact H0ltb. }
  exact ((SNoLt_irref 0) H00). }
claim HrS: SNo r.
{ exact (SNo_recip_SNo b HbS). }
claim HrR: r :e R.
{ exact (real_recip_SNo b HbR). }
claim Hrpos: 0 < r.
{ exact (recip_SNo_of_pos_is_pos b HbS H0ltb). }
claim Hrnonneg: 0 <= r.
{ exact (SNoLtLe 0 r Hrpos). }
claim Hexn: exists n :e omega, n <= r /\ r < ordsucc n.
{ exact (nonneg_real_nat_interval r HrR Hrnonneg). }
apply Hexn.
let n.
assume Hnpair: n :e omega /\ (n <= r /\ r < ordsucc n).
claim HnOmega: n :e omega.
{ exact (andEL (n :e omega) (n <= r /\ r < ordsucc n) Hnpair). }
claim Hnrest: n <= r /\ r < ordsucc n.
{ exact (andER (n :e omega) (n <= r /\ r < ordsucc n) Hnpair). }
claim HrltN: r < ordsucc n.
{ exact (andER (n <= r) (r < ordsucc n) Hnrest). }
set N := ordsucc n.
claim HNOmega: N :e omega.
{ exact (omega_ordsucc n HnOmega). }
claim HnNat: nat_p n.
{ exact (omega_nat_p n HnOmega). }
claim HnOrd: ordinal n.
{ exact (nat_p_ordinal n HnNat). }
claim H0ltN: 0 < N.
{ exact (ordinal_ordsucc_pos n HnOrd). }
claim HNS: SNo N.
{ exact (omega_SNo N HNOmega). }
claim Hineq: mul_SNo b r < mul_SNo b N.
{ exact (pos_mul_SNo_Lt b r N HbS H0ltb HrS HNS HrltN). }
claim Hbr1: mul_SNo b r = 1.
{ exact (recip_SNo_invR b HbS Hbne0). }
claim H1ltbN: 1 < mul_SNo b N.
{ rewrite <- Hbr1.
  exact Hineq. }
claim HinvLt: div_SNo 1 N < b.
{ exact (div_SNo_pos_LtL 1 N b SNo_1 HNS (real_SNo b HbR) H0ltN H1ltbN). }
claim HinvEq: div_SNo 1 N = inv_nat N.
{ prove div_SNo 1 N = inv_nat N.
  claim Hdivdef: div_SNo 1 N = mul_SNo 1 (recip_SNo N).
  { reflexivity. }
  claim Hinvdef: inv_nat N = recip_SNo N.
  { reflexivity. }
  rewrite Hdivdef.
  rewrite Hinvdef at 2.
  rewrite (mul_SNo_oneL (recip_SNo N) (SNo_recip_SNo N HNS)).
  reflexivity. }
claim Hyltb: inv_nat N < b.
{ rewrite <- HinvEq.
  exact HinvLt. }
claim HyR: inv_nat N :e R.
{ exact (inv_nat_real N HNOmega). }
claim HyRltb: Rlt (inv_nat N) b.
{ exact (RltI (inv_nat N) b HyR HbR Hyltb). }
claim HNnot0: N /:e {0}.
{ assume HNin: N :e {0}.
  claim HNeq0: N = 0.
  { exact (SingE 0 N HNin). }
  claim H00: 0 < 0.
  { rewrite <- HNeq0 at 2.
    exact H0ltN. }
  exact ((SNoLt_irref 0) H00). }
claim HNinSetminus: N :e omega :\: {0}.
{ apply setminusI.
  - exact HNOmega.
  - exact HNnot0. }
claim HyK: inv_nat N :e K_set.
{ exact (ReplI (omega :\: {0}) (fun m:set => inv_nat m) N HNinSetminus). }
claim Hypos: Rlt 0 (inv_nat N).
{ exact (inv_nat_pos N HNinSetminus). }
claim HnotHyLta: ~(Rlt (inv_nat N) a).
{ assume Hylta: Rlt (inv_nat N) a.
  claim H0lta: Rlt 0 a.
  { exact (Rlt_tra 0 (inv_nat N) a Hypos Hylta). }
  exact (Hnot0a H0lta). }
witness (inv_nat N).
apply andI.
- prove inv_nat N :e halfopen_interval_left a b.
  exact (SepI R (fun x0:set => ~(Rlt x0 a) /\ Rlt x0 b) (inv_nat N) HyR
          (andI (~(Rlt (inv_nat N) a)) (Rlt (inv_nat N) b) HnotHyLta HyRltb)).
- exact HyK.
Qed.

(** LATEX VERSION: Exercise 6: The lower-limit topology and the K-topology on  are incomparable. **)
Theorem ex13_6_Rl_RK_not_comparable :
  ~finer_than R_lower_limit_topology R_K_topology /\
  ~finer_than R_K_topology R_lower_limit_topology.
prove ~finer_than R_lower_limit_topology R_K_topology /\ ~finer_than R_K_topology R_lower_limit_topology.
apply andI.
- (** not finer_than R_lower_limit_topology R_K_topology **)
  assume Hf: finer_than R_lower_limit_topology R_K_topology.
  prove False.
  set U := open_interval (minus_SNo 1) 1 :\: K_set.
  claim HUm1R: minus_SNo 1 :e R.
  { exact (real_minus_SNo 1 real_1). }
  claim HU1R: 1 :e R.
  { exact real_1. }
  claim HUinKbasis: U :e R_K_basis.
  { prove U :e R_K_basis.
    apply (famunionI R (fun a0:set => {open_interval a0 b :\: K_set|b :e R})
             (minus_SNo 1) U HUm1R).
    claim HUfam: U :e {open_interval (minus_SNo 1) b :\: K_set|b :e R}.
    { exact (ReplI R (fun b0:set => open_interval (minus_SNo 1) b0 :\: K_set) 1 HU1R). }
    exact HUfam. }
  claim HUinB: U :e (R_standard_basis :\/: R_K_basis).
  { exact (binunionI2 R_standard_basis R_K_basis U HUinKbasis). }
  claim HUinKtop: U :e R_K_topology.
  { exact (basis_in_generated R (R_standard_basis :\/: R_K_basis) U
            R_standard_plus_K_basis_is_basis_local HUinB). }
  claim HUinLower: U :e R_lower_limit_topology.
  { exact (Hf U HUinKtop). }
  claim H0inU: 0 :e U.
  { prove 0 :e U.
    apply setminusI.
    - prove 0 :e open_interval (minus_SNo 1) 1.
      claim Hm10: Rlt (minus_SNo 1) 0.
      { apply RltI.
        - exact HUm1R.
        - exact real_0.
        - exact minus_1_lt_0. }
      claim H01: Rlt 0 1.
      { exact Rlt_0_1. }
      claim H0prop: Rlt (minus_SNo 1) 0 /\ Rlt 0 1.
      { exact (andI (Rlt (minus_SNo 1) 0) (Rlt 0 1) Hm10 H01). }
      exact (SepI R (fun x0:set => Rlt (minus_SNo 1) x0 /\ Rlt x0 1) 0 real_0 H0prop).
    - exact zero_not_in_K_set. }
  claim HUcond: forall x :e U, exists b :e R_lower_limit_basis, x :e b /\ b c= U.
  { exact (SepE2 (Power R)
            (fun U0:set => forall x0 :e U0, exists b0 :e R_lower_limit_basis, x0 :e b0 /\ b0 c= U0)
            U HUinLower). }
  claim Hexb0: exists b0 :e R_lower_limit_basis, 0 :e b0 /\ b0 c= U.
  { exact (HUcond 0 H0inU). }
  apply Hexb0.
  let b0. assume Hb0pair: b0 :e R_lower_limit_basis /\ (0 :e b0 /\ b0 c= U).
  claim Hb0inB: b0 :e R_lower_limit_basis.
  { exact (andEL (b0 :e R_lower_limit_basis) (0 :e b0 /\ b0 c= U) Hb0pair). }
  claim Hb0rest: 0 :e b0 /\ b0 c= U.
  { exact (andER (b0 :e R_lower_limit_basis) (0 :e b0 /\ b0 c= U) Hb0pair). }
  claim H0inb0: 0 :e b0.
  { exact (andEL (0 :e b0) (b0 c= U) Hb0rest). }
  claim Hb0subU: b0 c= U.
  { exact (andER (0 :e b0) (b0 c= U) Hb0rest). }
  claim Hexa0: exists a0 :e R, b0 :e {halfopen_interval_left a0 b|b :e R}.
  { exact (famunionE R (fun a0:set => {halfopen_interval_left a0 b|b :e R}) b0 Hb0inB). }
  apply Hexa0.
  let a0. assume Ha0pair: a0 :e R /\ b0 :e {halfopen_interval_left a0 b|b :e R}.
  claim Ha0R: a0 :e R.
  { exact (andEL (a0 :e R) (b0 :e {halfopen_interval_left a0 b|b :e R}) Ha0pair). }
  claim Hb0fam: b0 :e {halfopen_interval_left a0 b|b :e R}.
  { exact (andER (a0 :e R) (b0 :e {halfopen_interval_left a0 b|b :e R}) Ha0pair). }
  claim Hexb1: exists b1 :e R, b0 = halfopen_interval_left a0 b1.
  { exact (ReplE R (fun b1:set => halfopen_interval_left a0 b1) b0 Hb0fam). }
  apply Hexb1.
  let b1. assume Hb1pair: b1 :e R /\ b0 = halfopen_interval_left a0 b1.
  claim Hb1R: b1 :e R.
  { exact (andEL (b1 :e R) (b0 = halfopen_interval_left a0 b1) Hb1pair). }
  claim Hb0eq: b0 = halfopen_interval_left a0 b1.
  { exact (andER (b1 :e R) (b0 = halfopen_interval_left a0 b1) Hb1pair). }
  claim H0inHalf: 0 :e halfopen_interval_left a0 b1.
  { rewrite <- Hb0eq. exact H0inb0. }
  claim H0prop: ~(Rlt 0 a0) /\ Rlt 0 b1.
  { exact (SepE2 R (fun x0:set => ~(Rlt x0 a0) /\ Rlt x0 b1) 0 H0inHalf). }
  claim Hnot0lta0: ~(Rlt 0 a0).
  { exact (andEL (~(Rlt 0 a0)) (Rlt 0 b1) H0prop). }
  claim H0ltb1: Rlt 0 b1.
  { exact (andER (~(Rlt 0 a0)) (Rlt 0 b1) H0prop). }
  claim Hexy: exists y:set, y :e b0 /\ y :e K_set.
  { claim Hexy2: exists y:set, y :e halfopen_interval_left a0 b1 /\ y :e K_set.
    { exact (K_set_meets_lower_limit_neighborhood_0 a0 b1 Ha0R Hb1R Hnot0lta0 H0ltb1). }
    apply Hexy2.
    let y. assume Hyconj2: y :e halfopen_interval_left a0 b1 /\ y :e K_set.
    witness y.
    apply andI.
    - prove y :e b0.
      rewrite Hb0eq.
      exact (andEL (y :e halfopen_interval_left a0 b1) (y :e K_set) Hyconj2).
    - exact (andER (y :e halfopen_interval_left a0 b1) (y :e K_set) Hyconj2). }
  apply Hexy.
  let y. assume Hyconj: y :e b0 /\ y :e K_set.
  claim Hyb0: y :e b0.
  { exact (andEL (y :e b0) (y :e K_set) Hyconj). }
  claim HyK: y :e K_set.
  { exact (andER (y :e b0) (y :e K_set) Hyconj). }
  claim HyinU: y :e U.
  { exact (Hb0subU y Hyb0). }
  claim HynotK: y /:e K_set.
  { exact (setminusE2 (open_interval (minus_SNo 1) 1) K_set y HyinU). }
  exact (HynotK HyK).
- (** not finer_than R_K_topology R_lower_limit_topology **)
  assume Hf: finer_than R_K_topology R_lower_limit_topology.
  prove False.
  set U0 := halfopen_interval_left 0 1.
  claim HU0Lower: U0 :e R_lower_limit_topology.
  { prove U0 :e R_lower_limit_topology.
    (** R_lower_limit_topology = generated_topology R R_lower_limit_basis **)
    prove U0 :e generated_topology R R_lower_limit_basis.
    claim HU0Pow: U0 :e Power R.
    { exact (PowerI R U0 (halfopen_interval_left_Subq_R 0 1)). }
    claim HU0Prop: forall x :e U0, exists b0 :e R_lower_limit_basis, x :e b0 /\ b0 c= U0.
    { let x. assume HxU0: x :e U0.
      claim HxR: x :e R.
      { exact (SepE1 R (fun x0:set => ~(Rlt x0 0) /\ Rlt x0 1) x HxU0). }
      claim HxProp: ~(Rlt x 0) /\ Rlt x 1.
      { exact (SepE2 R (fun x0:set => ~(Rlt x0 0) /\ Rlt x0 1) x HxU0). }
      claim Hxlt1: Rlt x 1.
      { exact (andER (~(Rlt x 0)) (Rlt x 1) HxProp). }
      set bx := halfopen_interval_left x 1.
      witness bx.
      apply andI.
      - (** bx in the lower limit basis **)
        prove bx :e R_lower_limit_basis.
        apply (famunionI R (fun a0:set => {halfopen_interval_left a0 b|b :e R}) x bx HxR).
        exact (ReplI R (fun b0:set => halfopen_interval_left x b0) 1 real_1).
      - apply andI.
        + (** x in bx **)
          prove x :e bx.
          claim Hnotxx: ~(Rlt x x).
          { exact (not_Rlt_refl x HxR). }
          claim Hxpropbx: ~(Rlt x x) /\ Rlt x 1.
          { exact (andI (~(Rlt x x)) (Rlt x 1) Hnotxx Hxlt1). }
          exact (SepI R (fun t:set => ~(Rlt t x) /\ Rlt t 1) x HxR Hxpropbx).
        + (** bx subset U0 **)
          prove bx c= U0.
          let y. assume Hybx: y :e bx.
          claim HyR: y :e R.
          { exact (SepE1 R (fun t:set => ~(Rlt t x) /\ Rlt t 1) y Hybx). }
          claim HyProp: ~(Rlt y x) /\ Rlt y 1.
          { exact (SepE2 R (fun t:set => ~(Rlt t x) /\ Rlt t 1) y Hybx). }
          claim Hylt1: Rlt y 1.
          { exact (andER (~(Rlt y x)) (Rlt y 1) HyProp). }
          claim Hnotyltx: ~(Rlt y x).
          { exact (andEL (~(Rlt y x)) (Rlt y 1) HyProp). }
          claim Hnotxlt0: ~(x < 0).
          { assume Hxlt0: x < 0.
            claim HxRlt0: Rlt x 0.
            { exact (RltI x 0 HxR real_0 Hxlt0). }
            exact ((andEL (~(Rlt x 0)) (Rlt x 1) HxProp) HxRlt0). }
          claim HxS: SNo x.
          { exact (real_SNo x HxR). }
          claim H0S: SNo 0.
          { exact SNo_0. }
          claim HxLe0or: x < 0 \/ 0 <= x.
          { exact (SNoLtLe_or x 0 HxS H0S). }
          claim H0Lex: 0 <= x.
          { apply (HxLe0or (0 <= x)).
            - assume Hxlt0: x < 0.
              apply FalseE.
              exact (Hnotxlt0 Hxlt0).
            - assume H. exact H. }
          claim Hnotylt0: ~(Rlt y 0).
          { assume Hylt0: Rlt y 0.
            claim Hylt0lt: y < 0.
            { exact (RltE_lt y 0 Hylt0). }
            claim HyS: SNo y.
            { exact (real_SNo y HyR). }
            claim Hyltx: y < x.
            { exact (SNoLtLe_tra y 0 x HyS H0S HxS Hylt0lt H0Lex). }
            claim HyRltx: Rlt y x.
            { exact (RltI y x HyR HxR Hyltx). }
            exact (Hnotyltx HyRltx). }
          claim HyPropU0: ~(Rlt y 0) /\ Rlt y 1.
          { exact (andI (~(Rlt y 0)) (Rlt y 1) Hnotylt0 Hylt1). }
          exact (SepI R (fun z:set => ~(Rlt z 0) /\ Rlt z 1) y HyR HyPropU0). }
    exact (SepI (Power R)
                (fun U:set => forall x :e U, exists b0 :e R_lower_limit_basis, x :e b0 /\ b0 c= U)
                U0
                HU0Pow
                HU0Prop). }
  claim HU0K: U0 :e R_K_topology.
  { exact (Hf U0 HU0Lower). }
  claim H0inU0: 0 :e U0.
  { prove 0 :e U0.
    claim Hnot00: ~(Rlt 0 0).
    { exact (not_Rlt_refl 0 real_0). }
    claim H0prop: ~(Rlt 0 0) /\ Rlt 0 1.
    { exact (andI (~(Rlt 0 0)) (Rlt 0 1) Hnot00 Rlt_0_1). }
    exact (SepI R (fun z:set => ~(Rlt z 0) /\ Rlt z 1) 0 real_0 H0prop). }
  claim HU0cond: forall x :e U0, exists b1 :e (R_standard_basis :\/: R_K_basis), x :e b1 /\ b1 c= U0.
  { exact (SepE2 (Power R)
            (fun U:set => forall x0 :e U, exists b1 :e (R_standard_basis :\/: R_K_basis), x0 :e b1 /\ b1 c= U)
            U0 HU0K). }
  claim Hexb1: exists b1 :e (R_standard_basis :\/: R_K_basis), 0 :e b1 /\ b1 c= U0.
  { exact (HU0cond 0 H0inU0). }
  apply Hexb1.
  let b1. assume Hb1pair.
  claim Hb1B: b1 :e (R_standard_basis :\/: R_K_basis).
  { exact (andEL (b1 :e (R_standard_basis :\/: R_K_basis)) (0 :e b1 /\ b1 c= U0) Hb1pair). }
  claim Hb1rest: 0 :e b1 /\ b1 c= U0.
  { exact (andER (b1 :e (R_standard_basis :\/: R_K_basis)) (0 :e b1 /\ b1 c= U0) Hb1pair). }
  claim H0inb1: 0 :e b1.
  { exact (andEL (0 :e b1) (b1 c= U0) Hb1rest). }
  claim Hb1subU0: b1 c= U0.
  { exact (andER (0 :e b1) (b1 c= U0) Hb1rest). }
	  apply (binunionE R_standard_basis R_K_basis b1 Hb1B).
	  - (** b1 from standard basis **)
	    assume Hb1Std: b1 :e R_standard_basis.
    (** destruct b1 = open_interval a c **)
    claim Hexa: exists a :e R, b1 :e {open_interval a b|b :e R}.
    { exact (famunionE R (fun a0:set => {open_interval a0 b|b :e R}) b1 Hb1Std). }
    apply Hexa.
    let a0. assume Ha0pair.
    claim Ha0R: a0 :e R.
    { exact (andEL (a0 :e R) (b1 :e {open_interval a0 b|b :e R}) Ha0pair). }
    claim Hb1Fam: b1 :e {open_interval a0 b|b :e R}.
    { exact (andER (a0 :e R) (b1 :e {open_interval a0 b|b :e R}) Ha0pair). }
    claim Hexc: exists c0 :e R, b1 = open_interval a0 c0.
    { exact (ReplE R (fun c:set => open_interval a0 c) b1 Hb1Fam). }
    apply Hexc.
    let c0. assume Hc0pair.
    claim Hc0R: c0 :e R.
    { exact (andEL (c0 :e R) (b1 = open_interval a0 c0) Hc0pair). }
    claim Hb1eq: b1 = open_interval a0 c0.
    { exact (andER (c0 :e R) (b1 = open_interval a0 c0) Hc0pair). }
    claim H0inInt: 0 :e open_interval a0 c0.
    { rewrite <- Hb1eq. exact H0inb1. }
    claim H0IntProp: Rlt a0 0 /\ Rlt 0 c0.
    { exact (SepE2 R (fun t:set => Rlt a0 t /\ Rlt t c0) 0 H0inInt). }
    claim Ha0lt0: Rlt a0 0.
    { exact (andEL (Rlt a0 0) (Rlt 0 c0) H0IntProp). }
    claim H0ltc0: Rlt 0 c0.
    { exact (andER (Rlt a0 0) (Rlt 0 c0) H0IntProp). }
    set e1 := eps_ 1.
    claim H1omega: 1 :e omega.
    { exact (nat_p_omega 1 nat_1). }
    claim He1SNoS: e1 :e SNoS_ omega.
    { exact (SNo_eps_SNoS_omega 1 H1omega). }
    claim He1R: e1 :e R.
    { exact (SNoS_omega_real e1 He1SNoS). }
    claim He1S: SNo e1.
    { exact (real_SNo e1 He1R). }
    claim He1pos: 0 < e1.
    { exact (SNo_eps_pos 1 H1omega). }
    claim H0Ord: ordinal 0.
    { exact (nat_p_ordinal 0 nat_0). }
    claim H0in1: 0 :e 1.
    { exact (ordinal_0_In_ordsucc 0 H0Ord). }
    claim He1lt1: e1 < 1.
    { claim He1ltE0: eps_ 1 < eps_ 0.
      { exact (SNo_eps_decr 1 H1omega 0 H0in1). }
      rewrite <- (eps_0_1) at 2.
      exact He1ltE0. }
	    set y := mul_SNo a0 e1.
	    claim HyR: y :e R.
	    { exact (real_mul_SNo a0 Ha0R e1 He1R). }
	    claim Ha0S: SNo a0.
	    { exact (real_SNo a0 Ha0R). }
    claim HyNeg: y < 0.
    { exact (mul_SNo_neg_pos a0 e1 Ha0S He1S (RltE_lt a0 0 Ha0lt0) He1pos). }
    claim Hyltc0: y < c0.
    { claim H0ltc0lt: 0 < c0.
      { exact (RltE_lt 0 c0 H0ltc0). }
      claim Hc0S: SNo c0.
      { exact (real_SNo c0 Hc0R). }
      claim HyS: SNo y.
      { exact (real_SNo y HyR). }
      exact (SNoLt_tra y 0 c0 HyS SNo_0 Hc0S HyNeg H0ltc0lt). }
	    claim Ha0lty: a0 < y.
	    { claim Ha0lt: a0 < 0.
	      { exact (RltE_lt a0 0 Ha0lt0). }
	      claim Ha0mul: mul_SNo a0 1 < mul_SNo a0 e1.
	      { exact (neg_mul_SNo_Lt a0 1 e1 Ha0S Ha0lt SNo_1 He1S He1lt1). }
	      prove a0 < y.
	      rewrite <- (mul_SNo_oneR a0 Ha0S) at 1.
	      exact Ha0mul. }
	    claim HyInt: y :e open_interval a0 c0.
	    { prove y :e open_interval a0 c0.
	      claim Harlt: Rlt a0 y.
	      { exact (RltI a0 y Ha0R HyR Ha0lty). }
	      claim Hyrc0: Rlt y c0.
	      { exact (RltI y c0 HyR Hc0R Hyltc0). }
	      claim Hconj: Rlt a0 y /\ Rlt y c0.
	      { exact (andI (Rlt a0 y) (Rlt y c0) Harlt Hyrc0). }
	      exact (SepI R (fun t:set => Rlt a0 t /\ Rlt t c0) y HyR Hconj). }
    claim Hyinb1: y :e b1.
    { rewrite Hb1eq. exact HyInt. }
    claim HyinU0: y :e U0.
    { exact (Hb1subU0 y Hyinb1). }
    claim HyU0prop: ~(Rlt y 0) /\ Rlt y 1.
    { exact (SepE2 R (fun z:set => ~(Rlt z 0) /\ Rlt z 1) y HyinU0). }
    claim Hnotylt0: ~(Rlt y 0).
    { exact (andEL (~(Rlt y 0)) (Rlt y 1) HyU0prop). }
    claim HyRlt0: Rlt y 0.
    { exact (RltI y 0 HyR real_0 HyNeg). }
    exact (Hnotylt0 HyRlt0).
	  - (** b1 from K basis **)
	    assume Hb1K: b1 :e R_K_basis.
    (** destruct b1 = open_interval a c \\ K_set **)
    claim Hexa: exists a :e R, b1 :e {open_interval a b :\: K_set|b :e R}.
    { exact (famunionE R (fun a0:set => {open_interval a0 b :\: K_set|b :e R}) b1 Hb1K). }
    apply Hexa.
    let a0. assume Ha0pair.
    claim Ha0R: a0 :e R.
    { exact (andEL (a0 :e R) (b1 :e {open_interval a0 b :\: K_set|b :e R}) Ha0pair). }
    claim Hb1Fam: b1 :e {open_interval a0 b :\: K_set|b :e R}.
    { exact (andER (a0 :e R) (b1 :e {open_interval a0 b :\: K_set|b :e R}) Ha0pair). }
    claim Hexc: exists c0 :e R, b1 = open_interval a0 c0 :\: K_set.
    { exact (ReplE R (fun c:set => open_interval a0 c :\: K_set) b1 Hb1Fam). }
    apply Hexc.
    let c0. assume Hc0pair.
    claim Hc0R: c0 :e R.
    { exact (andEL (c0 :e R) (b1 = open_interval a0 c0 :\: K_set) Hc0pair). }
    claim Hb1eq: b1 = open_interval a0 c0 :\: K_set.
    { exact (andER (c0 :e R) (b1 = open_interval a0 c0 :\: K_set) Hc0pair). }
    claim H0inSetminus: 0 :e open_interval a0 c0 :\: K_set.
    { rewrite <- Hb1eq. exact H0inb1. }
    claim H0inInt: 0 :e open_interval a0 c0.
    { exact (setminusE1 (open_interval a0 c0) K_set 0 H0inSetminus). }
    claim H0IntProp: Rlt a0 0 /\ Rlt 0 c0.
    { exact (SepE2 R (fun t:set => Rlt a0 t /\ Rlt t c0) 0 H0inInt). }
    claim Ha0lt0: Rlt a0 0.
    { exact (andEL (Rlt a0 0) (Rlt 0 c0) H0IntProp). }
    claim H0ltc0: Rlt 0 c0.
    { exact (andER (Rlt a0 0) (Rlt 0 c0) H0IntProp). }
    set e1 := eps_ 1.
    claim H1omega: 1 :e omega.
    { exact (nat_p_omega 1 nat_1). }
    claim He1SNoS: e1 :e SNoS_ omega.
    { exact (SNo_eps_SNoS_omega 1 H1omega). }
    claim He1R: e1 :e R.
    { exact (SNoS_omega_real e1 He1SNoS). }
    claim He1S: SNo e1.
    { exact (real_SNo e1 He1R). }
    claim He1pos: 0 < e1.
    { exact (SNo_eps_pos 1 H1omega). }
    claim H0Ord: ordinal 0.
    { exact (nat_p_ordinal 0 nat_0). }
    claim H0in1: 0 :e 1.
    { exact (ordinal_0_In_ordsucc 0 H0Ord). }
    claim He1lt1: e1 < 1.
    { claim He1ltE0: eps_ 1 < eps_ 0.
      { exact (SNo_eps_decr 1 H1omega 0 H0in1). }
      rewrite <- (eps_0_1) at 2.
      exact He1ltE0. }
	    set y := mul_SNo a0 e1.
	    claim Ha0S: SNo a0.
	    { exact (real_SNo a0 Ha0R). }
	    claim HyR: y :e R.
	    { exact (real_mul_SNo a0 Ha0R e1 He1R). }
	    claim HyNeg: y < 0.
    { exact (mul_SNo_neg_pos a0 e1 Ha0S He1S (RltE_lt a0 0 Ha0lt0) He1pos). }
    claim Hyltc0: y < c0.
    { claim H0ltc0lt: 0 < c0.
      { exact (RltE_lt 0 c0 H0ltc0). }
      claim Hc0S: SNo c0.
      { exact (real_SNo c0 Hc0R). }
      claim HyS: SNo y.
      { exact (real_SNo y HyR). }
      exact (SNoLt_tra y 0 c0 HyS SNo_0 Hc0S HyNeg H0ltc0lt). }
	    claim Ha0lty: a0 < y.
	    { claim Ha0lt: a0 < 0.
	      { exact (RltE_lt a0 0 Ha0lt0). }
	      claim Ha0mul: mul_SNo a0 1 < mul_SNo a0 e1.
	      { exact (neg_mul_SNo_Lt a0 1 e1 Ha0S Ha0lt SNo_1 He1S He1lt1). }
	      prove a0 < y.
	      rewrite <- (mul_SNo_oneR a0 Ha0S) at 1.
	      exact Ha0mul. }
	    claim HyInt: y :e open_interval a0 c0.
	    { prove y :e open_interval a0 c0.
	      claim Harlt: Rlt a0 y.
	      { exact (RltI a0 y Ha0R HyR Ha0lty). }
	      claim Hyrc0: Rlt y c0.
	      { exact (RltI y c0 HyR Hc0R Hyltc0). }
	      claim Hconj: Rlt a0 y /\ Rlt y c0.
	      { exact (andI (Rlt a0 y) (Rlt y c0) Harlt Hyrc0). }
	      exact (SepI R (fun t:set => Rlt a0 t /\ Rlt t c0) y HyR Hconj). }
    claim HynotK: y /:e K_set.
    { assume HyK: y :e K_set.
      apply (ReplE_impred (omega :\: {0}) (fun m:set => inv_nat m) y HyK False).
      let m. assume HmIn: m :e omega :\: {0}. assume Hyeq: y = inv_nat m.
      claim Hypos: Rlt 0 y.
      { rewrite Hyeq.
        exact (inv_nat_pos m HmIn). }
      claim Hyposlt: 0 < y.
      { exact (RltE_lt 0 y Hypos). }
      claim HyS: SNo y.
      { exact (real_SNo y HyR). }
      claim H0lt0: 0 < 0.
      { exact (SNoLt_tra 0 y 0 SNo_0 HyS SNo_0 Hyposlt HyNeg). }
      exact ((SNoLt_irref 0) H0lt0). }
    claim HyinSetminus: y :e open_interval a0 c0 :\: K_set.
    { exact (setminusI (open_interval a0 c0) K_set y HyInt HynotK). }
    claim Hyinb1: y :e b1.
    { rewrite Hb1eq. exact HyinSetminus. }
    claim HyinU0: y :e U0.
    { exact (Hb1subU0 y Hyinb1). }
    claim HyU0prop: ~(Rlt y 0) /\ Rlt y 1.
    { exact (SepE2 R (fun z:set => ~(Rlt z 0) /\ Rlt z 1) y HyinU0). }
    claim Hnotylt0: ~(Rlt y 0).
    { exact (andEL (~(Rlt y 0)) (Rlt y 1) HyU0prop). }
    claim HyRlt0: Rlt y 0.
    { exact (RltI y 0 HyR real_0 HyNeg). }
    exact (Hnotylt0 HyRlt0).
Qed.

(** from 13 Exercise 7: containment relations among five  topologies **) 
(** LATEX VERSION: Exercise 7 lists several standard  topologies and records which contain which (upper limit finer than standard, etc.). **)
Definition R_finite_complement_topology : set := finite_complement_topology R.
Definition R_ray_topology : set :=
  {U :e Power R|U = Empty \/ U = R \/ (exists a :e R, U = {x :e R|Rlt x a})}.

(** from 13 Exercise 7: open rays are open in the standard topology **)
(** LATEX VERSION: The ray (a,) is open in the standard topology on . **)
Theorem open_ray_in_R_standard_topology : forall a:set, a :e R -> {x :e R|Rlt a x} :e R_standard_topology.
let a. assume HaR.
set U := {x :e R|Rlt a x}.
prove U :e R_standard_topology.
claim HUinPow : U :e Power R.
{ apply PowerI.
  let x. assume Hx.
  exact (SepE1 R (fun x0 : set => Rlt a x0) x Hx). }
claim HUprop : forall x :e U, exists b :e R_standard_basis, x :e b /\ b c= U.
{ let x. assume HxU.
  claim HxR : x :e R.
  { exact (SepE1 R (fun x0 : set => Rlt a x0) x HxU). }
  claim Hax : Rlt a x.
  { exact (SepE2 R (fun x0 : set => Rlt a x0) x HxU). }
  claim H0omega : 0 :e omega.
  { exact (nat_p_omega 0 nat_0). }
  set e0 := eps_ 0.
  claim He0SNoS : e0 :e SNoS_ omega.
  { exact (SNo_eps_SNoS_omega 0 H0omega). }
  claim He0R : e0 :e R.
  { exact (SNoS_omega_real e0 He0SNoS). }
  claim HbR : add_SNo x e0 :e R.
  { exact (real_add_SNo x HxR e0 He0R). }
  set b := open_interval a (add_SNo x e0).
  claim HbStd : b :e R_standard_basis.
  { claim HbFam : b :e {open_interval a b0|b0 :e R}.
    { exact (ReplI R (fun b0 : set => open_interval a b0) (add_SNo x e0) HbR). }
    exact (famunionI R
                      (fun a0 : set => {open_interval a0 b0|b0 :e R})
                      a
                      b
                      HaR
                      HbFam). }
  claim Hxinb : x :e b.
  { claim Hxlt : x < add_SNo x e0.
    { exact (add_SNo_eps_Lt x (real_SNo x HxR) 0 H0omega). }
    claim Hxxe0 : Rlt x (add_SNo x e0).
    { exact (RltI x (add_SNo x e0) HxR HbR Hxlt). }
    claim Hpropb : Rlt a x /\ Rlt x (add_SNo x e0).
    { apply andI.
      - exact Hax.
      - exact Hxxe0. }
    exact (SepI R (fun x0 : set => Rlt a x0 /\ Rlt x0 (add_SNo x e0)) x HxR Hpropb). }
  claim HbSubU : b c= U.
  { let y. assume Hyb.
    claim HyR : y :e R.
    { exact (SepE1 R (fun x0 : set => Rlt a x0 /\ Rlt x0 (add_SNo x e0)) y Hyb). }
    claim Hyprop : Rlt a y /\ Rlt y (add_SNo x e0).
    { exact (SepE2 R (fun x0 : set => Rlt a x0 /\ Rlt x0 (add_SNo x e0)) y Hyb). }
    claim Hay : Rlt a y.
    { exact (andEL (Rlt a y) (Rlt y (add_SNo x e0)) Hyprop). }
    exact (SepI R (fun x0 : set => Rlt a x0) y HyR Hay). }
  witness b.
  apply andI.
  - exact HbStd.
  - apply andI.
    + exact Hxinb.
    + exact HbSubU. }
exact (SepI (Power R)
            (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
            U
            HUinPow
            HUprop).
Qed.

(** from 13: left open ray is open in the standard topology on R **)
(** LATEX VERSION: The ray (-infty,b) is open in the standard topology on R. **)
Theorem open_left_ray_in_R_standard_topology : forall b:set, b :e R -> {x :e R|Rlt x b} :e R_standard_topology.
let b. assume HbR.
set U := {x :e R|Rlt x b}.
prove U :e R_standard_topology.
claim HUinPow : U :e Power R.
{ apply PowerI.
  let x. assume Hx.
  exact (SepE1 R (fun x0 : set => Rlt x0 b) x Hx). }
claim HUprop : forall x :e U, exists bb :e R_standard_basis, x :e bb /\ bb c= U.
{ let x. assume HxU.
  claim HxR : x :e R.
  { exact (SepE1 R (fun x0 : set => Rlt x0 b) x HxU). }
  claim Hxb : Rlt x b.
  { exact (SepE2 R (fun x0 : set => Rlt x0 b) x HxU). }
  claim H0omega : 0 :e omega.
  { exact (nat_p_omega 0 nat_0). }
  set e0 := eps_ 0.
  claim He0SNoS : e0 :e SNoS_ omega.
  { exact (SNo_eps_SNoS_omega 0 H0omega). }
  claim He0R : e0 :e R.
  { exact (SNoS_omega_real e0 He0SNoS). }
  claim He0S : SNo e0.
  { exact (real_SNo e0 He0R). }
  claim HxS : SNo x.
  { exact (real_SNo x HxR). }
  claim HmE0R : minus_SNo e0 :e R.
  { exact (real_minus_SNo e0 He0R). }
  claim HmE0S : SNo (minus_SNo e0).
  { exact (real_SNo (minus_SNo e0) HmE0R). }
  claim HaR : add_SNo x (minus_SNo e0) :e R.
  { exact (real_add_SNo x HxR (minus_SNo e0) HmE0R). }
  set a0 := add_SNo x (minus_SNo e0).
  set I := open_interval a0 b.
  claim HIStd : I :e R_standard_basis.
  { claim HIa : I :e {open_interval a0 bb|bb :e R}.
    { exact (ReplI R (fun bb : set => open_interval a0 bb) b HbR). }
    exact (famunionI R
                     (fun aa : set => {open_interval aa bb|bb :e R})
                     a0
                     I
                     HaR
                     HIa). }
  claim HxInI : x :e I.
  { claim Hxlt : x < add_SNo x e0.
    { exact (add_SNo_eps_Lt x HxS 0 H0omega). }
    claim Hxme0ltx : a0 < x.
    { exact (add_SNo_minus_Lt1b x e0 x HxS He0S HxS Hxlt). }
    claim Hax : Rlt a0 x.
    { exact (RltI a0 x HaR HxR Hxme0ltx). }
    claim HpropI : Rlt a0 x /\ Rlt x b.
    { apply andI.
      - exact Hax.
      - exact Hxb. }
    exact (SepI R (fun x0 : set => Rlt a0 x0 /\ Rlt x0 b) x HxR HpropI). }
  claim HISubU : I c= U.
  { let y. assume HyI.
    claim HyR : y :e R.
    { exact (SepE1 R (fun y0 : set => Rlt a0 y0 /\ Rlt y0 b) y HyI). }
    claim HyProp : Rlt a0 y /\ Rlt y b.
    { exact (SepE2 R (fun y0 : set => Rlt a0 y0 /\ Rlt y0 b) y HyI). }
    claim Hyb : Rlt y b.
    { exact (andER (Rlt a0 y) (Rlt y b) HyProp). }
    exact (SepI R (fun y0 : set => Rlt y0 b) y HyR Hyb). }
  witness I.
  apply andI.
  - exact HIStd.
  - apply andI.
    + exact HxInI.
    + exact HISubU. }
exact (SepI (Power R)
            (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
            U
            HUinPow
            HUprop).
Qed.

(** from 13: unions of standard open sets are standard open **)
(** LATEX VERSION: Arbitrary unions of open sets are open; in particular, unions of two open sets are open. **)
Theorem binunion_in_R_standard_topology : forall U V:set,
  U :e R_standard_topology ->
  V :e R_standard_topology ->
  U :\/: V :e R_standard_topology.
let U V. assume HU HV.
prove U :\/: V :e R_standard_topology.
claim HUpow : U :e Power R.
{ exact (SepE1 (Power R)
               (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
               U
               HU). }
claim HVpow : V :e Power R.
{ exact (SepE1 (Power R)
               (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
               V
               HV). }
claim HUprop : forall x :e U, exists b0 :e R_standard_basis, x :e b0 /\ b0 c= U.
{ exact (SepE2 (Power R)
               (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
               U
               HU). }
claim HVprop : forall x :e V, exists b0 :e R_standard_basis, x :e b0 /\ b0 c= V.
{ exact (SepE2 (Power R)
               (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
               V
               HV). }
claim HUVpow : U :\/: V :e Power R.
{ apply PowerI.
  let x. assume HxUV : x :e U :\/: V.
  apply (binunionE U V x HxUV).
  - assume HxU : x :e U.
    exact (PowerE R U HUpow x HxU).
  - assume HxV : x :e V.
    exact (PowerE R V HVpow x HxV). }
claim HUVprop : forall x :e U :\/: V, exists b0 :e R_standard_basis, x :e b0 /\ b0 c= U :\/: V.
{ let x. assume HxUV : x :e U :\/: V.
  apply (binunionE U V x HxUV).
  - assume HxU : x :e U.
    claim Hexb : exists b0 :e R_standard_basis, x :e b0 /\ b0 c= U.
    { exact (HUprop x HxU). }
    apply Hexb.
    let b0. assume Hb0pair.
    witness b0.
    apply andI.
    + exact (andEL (b0 :e R_standard_basis) (x :e b0 /\ b0 c= U) Hb0pair).
    + claim Hb0prop : x :e b0 /\ b0 c= U.
      { exact (andER (b0 :e R_standard_basis) (x :e b0 /\ b0 c= U) Hb0pair). }
      apply andI.
      - exact (andEL (x :e b0) (b0 c= U) Hb0prop).
      - claim Hb0subU : b0 c= U.
        { exact (andER (x :e b0) (b0 c= U) Hb0prop). }
        let y. assume Hyb0.
        claim HyU : y :e U.
        { exact (Hb0subU y Hyb0). }
        exact (binunionI1 U V y HyU).
  - assume HxV : x :e V.
    claim Hexb : exists b0 :e R_standard_basis, x :e b0 /\ b0 c= V.
    { exact (HVprop x HxV). }
    apply Hexb.
    let b0. assume Hb0pair.
    witness b0.
    apply andI.
    + exact (andEL (b0 :e R_standard_basis) (x :e b0 /\ b0 c= V) Hb0pair).
    + claim Hb0prop : x :e b0 /\ b0 c= V.
      { exact (andER (b0 :e R_standard_basis) (x :e b0 /\ b0 c= V) Hb0pair). }
      apply andI.
      - exact (andEL (x :e b0) (b0 c= V) Hb0prop).
      - claim Hb0subV : b0 c= V.
        { exact (andER (x :e b0) (b0 c= V) Hb0prop). }
        let y. assume Hyb0.
        claim HyV : y :e V.
        { exact (Hb0subV y Hyb0). }
        exact (binunionI2 U V y HyV). }
exact (SepI (Power R)
            (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
            (U :\/: V)
            HUVpow
            HUVprop).
Qed.

(** from 13: complement of a point in R equals union of two open rays **)
(** LATEX VERSION: R minus {a} is (-infty,a) union (a,infty). **)
Theorem R_minus_singleton_eq_rays_union : forall a:set, a :e R ->
  R :\: {a,a} = {x :e R|Rlt x a} :\/: {x :e R|Rlt a x}.
let a. assume HaR.
apply set_ext.
- let x. assume Hx : x :e R :\: {a,a}.
  prove x :e {x0 :e R|Rlt x0 a} :\/: {x0 :e R|Rlt a x0}.
  claim Hxpair : x :e R /\ x /:e {a,a}.
  { exact (setminusE R {a,a} x Hx). }
  claim HxR : x :e R.
  { exact (andEL (x :e R) (x /:e {a,a}) Hxpair). }
  claim HxNot : x /:e {a,a}.
  { exact (andER (x :e R) (x /:e {a,a}) Hxpair). }
  claim HxS : SNo x.
  { exact (real_SNo x HxR). }
  claim HaS : SNo a.
  { exact (real_SNo a HaR). }
  apply (SNoLt_trichotomy_or_impred x a HxS HaS (x :e {x0 :e R|Rlt x0 a} :\/: {x0 :e R|Rlt a x0})).
  - assume Hxlt : x < a.
    claim HxRlt : Rlt x a.
    { exact (RltI x a HxR HaR Hxlt). }
    claim HxLeft : x :e {x0 :e R|Rlt x0 a}.
    { exact (SepI R (fun x0 : set => Rlt x0 a) x HxR HxRlt). }
    exact (binunionI1 {x0 :e R|Rlt x0 a} {x0 :e R|Rlt a x0} x HxLeft).
  - assume Hxeq : x = a.
    claim Hxinpair : x :e {a,a}.
    { rewrite Hxeq.
      exact (UPairI1 a a). }
    claim Hfalse : False.
    { exact (HxNot Hxinpair). }
    exact (FalseE Hfalse (x :e {x0 :e R|Rlt x0 a} :\/: {x0 :e R|Rlt a x0})).
  - assume Halt : a < x.
    claim HxRlt : Rlt a x.
    { exact (RltI a x HaR HxR Halt). }
    claim HxRight : x :e {x0 :e R|Rlt a x0}.
    { exact (SepI R (fun x0 : set => Rlt a x0) x HxR HxRlt). }
    exact (binunionI2 {x0 :e R|Rlt x0 a} {x0 :e R|Rlt a x0} x HxRight).
- let x. assume Hx : x :e {x0 :e R|Rlt x0 a} :\/: {x0 :e R|Rlt a x0}.
  prove x :e R :\: {a,a}.
  apply (binunionE {x0 :e R|Rlt x0 a} {x0 :e R|Rlt a x0} x Hx).
  - assume HxLeft : x :e {x0 :e R|Rlt x0 a}.
    claim HxR : x :e R.
    { exact (SepE1 R (fun x0 : set => Rlt x0 a) x HxLeft). }
    claim HxRlt : Rlt x a.
    { exact (SepE2 R (fun x0 : set => Rlt x0 a) x HxLeft). }
    claim HxNot : x /:e {a,a}.
    { assume Hxin : x :e {a,a}.
      claim Hxeq : x = a.
      { apply (UPairE x a a Hxin (x = a)).
        - assume H1. exact H1.
        - assume H1. exact H1. }
      claim Haa : Rlt a a.
      { rewrite <- Hxeq at 1.
        exact HxRlt. }
      exact ((not_Rlt_refl a HaR) Haa). }
    exact (setminusI R {a,a} x HxR HxNot).
  - assume HxRight : x :e {x0 :e R|Rlt a x0}.
    claim HxR : x :e R.
    { exact (SepE1 R (fun x0 : set => Rlt a x0) x HxRight). }
    claim HxRlt : Rlt a x.
    { exact (SepE2 R (fun x0 : set => Rlt a x0) x HxRight). }
    claim HxNot : x /:e {a,a}.
    { assume Hxin : x :e {a,a}.
      claim Hxeq : x = a.
      { apply (UPairE x a a Hxin (x = a)).
        - assume H1. exact H1.
        - assume H1. exact H1. }
      claim Haa : Rlt a a.
      { rewrite <- Hxeq at 2.
        exact HxRlt. }
      exact ((not_Rlt_refl a HaR) Haa). }
    exact (setminusI R {a,a} x HxR HxNot).
Qed.

(** from 13: complement of a point is open in the standard topology on R **)
(** LATEX VERSION: Since (-infty,a) and (a,infty) are open, their union R minus {a} is open. **)
Theorem R_minus_singleton_in_R_standard_topology : forall a:set, a :e R -> R :\: {a,a} :e R_standard_topology.
let a. assume HaR.
rewrite (R_minus_singleton_eq_rays_union a HaR).
apply (binunion_in_R_standard_topology {x :e R|Rlt x a} {x :e R|Rlt a x}).
- exact (open_left_ray_in_R_standard_topology a HaR).
- exact (open_ray_in_R_standard_topology a HaR).
Qed.

(** from 13: complement of a union is intersection of complements **)
(** LATEX VERSION: X minus (A union B) equals (X minus A) intersect (X minus B). **)
Theorem setminus_binunion_eq_binintersect : forall X A B:set,
  X :\: (A :\/: B) = (X :\: A) :/\: (X :\: B).
let X A B.
apply set_ext.
- let x. assume Hx : x :e X :\: (A :\/: B).
  prove x :e (X :\: A) :/\: (X :\: B).
  claim Hxpair : x :e X /\ x /:e (A :\/: B).
  { exact (setminusE X (A :\/: B) x Hx). }
  claim HxX : x :e X.
  { exact (andEL (x :e X) (x /:e (A :\/: B)) Hxpair). }
  claim HxNot : x /:e (A :\/: B).
  { exact (andER (x :e X) (x /:e (A :\/: B)) Hxpair). }
  claim HxNotA : x /:e A.
  { assume HxA : x :e A.
    claim HxAB : x :e A :\/: B.
    { exact (binunionI1 A B x HxA). }
    exact (HxNot HxAB). }
  claim HxNotB : x /:e B.
  { assume HxB : x :e B.
    claim HxAB : x :e A :\/: B.
    { exact (binunionI2 A B x HxB). }
    exact (HxNot HxAB). }
  exact (binintersectI (X :\: A) (X :\: B) x (setminusI X A x HxX HxNotA) (setminusI X B x HxX HxNotB)).
- let x. assume Hx : x :e (X :\: A) :/\: (X :\: B).
  prove x :e X :\: (A :\/: B).
  claim HxXA : x :e X :\: A.
  { exact (binintersectE1 (X :\: A) (X :\: B) x Hx). }
  claim HxXB : x :e X :\: B.
  { exact (binintersectE2 (X :\: A) (X :\: B) x Hx). }
  claim HxX : x :e X.
  { exact (setminusE1 X A x HxXA). }
  claim HxNotA : x /:e A.
  { exact (setminusE2 X A x HxXA). }
  claim HxNotB : x /:e B.
  { exact (setminusE2 X B x HxXB). }
  claim HxNotAB : x /:e (A :\/: B).
  { assume HxAB : x :e A :\/: B.
    apply (binunionE A B x HxAB).
    - assume HxA. exact (HxNotA HxA).
    - assume HxB. exact (HxNotB HxB). }
  exact (setminusI X (A :\/: B) x HxX HxNotAB).
Qed.

(** from 13: complement of an intersection is union of complements **)
(** LATEX VERSION: X minus (A intersect B) equals (X minus A) union (X minus B). **)
Theorem setminus_binintersect_eq_binunion : forall X A B:set,
  X :\: (A :/\: B) = (X :\: A) :\/: (X :\: B).
let X A B.
apply set_ext.
- let x. assume Hx : x :e X :\: (A :/\: B).
  prove x :e (X :\: A) :\/: (X :\: B).
  claim Hxpair : x :e X /\ x /:e (A :/\: B).
  { exact (setminusE X (A :/\: B) x Hx). }
  claim HxX : x :e X.
  { exact (andEL (x :e X) (x /:e (A :/\: B)) Hxpair). }
  claim HxNotAB : x /:e (A :/\: B).
  { exact (andER (x :e X) (x /:e (A :/\: B)) Hxpair). }
  apply (xm (x :e A)).
  + assume HxA : x :e A.
    claim HxNotB : x /:e B.
    { assume HxB : x :e B.
      claim HxAB : x :e A :/\: B.
      { exact (binintersectI A B x HxA HxB). }
      exact (HxNotAB HxAB). }
    exact (binunionI2 (X :\: A) (X :\: B) x (setminusI X B x HxX HxNotB)).
  + assume HxNotA : ~(x :e A).
    exact (binunionI1 (X :\: A) (X :\: B) x (setminusI X A x HxX HxNotA)).
- let x. assume Hx : x :e (X :\: A) :\/: (X :\: B).
  prove x :e X :\: (A :/\: B).
  apply (binunionE (X :\: A) (X :\: B) x Hx).
  + assume HxXA : x :e X :\: A.
    claim HxX : x :e X.
    { exact (setminusE1 X A x HxXA). }
    claim HxNotAB : x /:e A :/\: B.
    { assume HxAB : x :e A :/\: B.
      claim HxA : x :e A.
      { exact (binintersectE1 A B x HxAB). }
      exact ((setminusE2 X A x HxXA) HxA). }
    exact (setminusI X (A :/\: B) x HxX HxNotAB).
  + assume HxXB : x :e X :\: B.
    claim HxX : x :e X.
    { exact (setminusE1 X B x HxXB). }
    claim HxNotAB : x /:e A :/\: B.
    { assume HxAB : x :e A :/\: B.
      claim HxB : x :e B.
      { exact (binintersectE2 A B x HxAB). }
      exact ((setminusE2 X B x HxXB) HxB). }
    exact (setminusI X (A :/\: B) x HxX HxNotAB).
Qed.

(** from 13: double complement inside X **)
(** LATEX VERSION: If U is a subset of X then X minus (X minus U) equals U. **)
Theorem setminus_setminus_eq : forall X U:set,
  U c= X ->
  X :\: (X :\: U) = U.
let X U. assume HUsub.
apply set_ext.
- let x. assume Hx : x :e X :\: (X :\: U).
  prove x :e U.
  claim Hxpair : x :e X /\ x /:e (X :\: U).
  { exact (setminusE X (X :\: U) x Hx). }
  claim HxX : x :e X.
  { exact (andEL (x :e X) (x /:e (X :\: U)) Hxpair). }
  claim HxNot : x /:e (X :\: U).
  { exact (andER (x :e X) (x /:e (X :\: U)) Hxpair). }
  apply (xm (x :e U)).
  - assume HxU. exact HxU.
  - assume HxNotU : ~(x :e U).
    claim HxXU : x :e X :\: U.
    { exact (setminusI X U x HxX HxNotU). }
    exact (FalseE (HxNot HxXU) (x :e U)).
- let x. assume HxU : x :e U.
  prove x :e X :\: (X :\: U).
  claim HxX : x :e X.
  { exact (HUsub x HxU). }
  claim HxNot : x /:e (X :\: U).
  { assume HxXU : x :e X :\: U.
    exact ((setminusE2 X U x HxXU) HxU). }
  exact (setminusI X (X :\: U) x HxX HxNot).
Qed.

(** from 12: finite intersections of closed sets are closed **)
(** LATEX VERSION: Finite intersections of closed sets are closed because their complements are finite unions of open sets. **)
Theorem binintersect_closed : forall X T C D:set,
  closed_in X T C ->
  closed_in X T D ->
  closed_in X T (C :/\: D).
let X T C D.
assume HC: closed_in X T C.
assume HD: closed_in X T D.
prove closed_in X T (C :/\: D).
claim HTx: topology_on X T.
{ exact (andEL (topology_on X T) (C c= X /\ exists U :e T, C = X :\: U) HC). }
claim HCsubX: C c= X.
{ exact (andEL (C c= X) (exists U :e T, C = X :\: U)
        (andER (topology_on X T) (C c= X /\ exists U :e T, C = X :\: U) HC)). }
claim HDsubX: D c= X.
{ exact (andEL (D c= X) (exists U :e T, D = X :\: U)
        (andER (topology_on X T) (D c= X /\ exists U :e T, D = X :\: U) HD)). }
claim HopenC: open_in X T (X :\: C).
{ exact (open_of_closed_complement X T C HC). }
claim HopenD: open_in X T (X :\: D).
{ exact (open_of_closed_complement X T D HD). }
claim HXCdT: X :\: C :e T.
{ exact (andER (topology_on X T) (X :\: C :e T) HopenC). }
claim HXDdT: X :\: D :e T.
{ exact (andER (topology_on X T) (X :\: D :e T) HopenD). }
claim Hunion_compl_in_T: (X :\: C) :\/: (X :\: D) :e T.
{ claim Hpairsub: {X :\: C, X :\: D} c= T.
  { let U. assume HU: U :e {X :\: C, X :\: D}.
    claim Hor: U = X :\: C \/ U = X :\: D.
    { exact (UPairE U (X :\: C) (X :\: D) HU). }
    apply Hor.
    - assume HUeq: U = X :\: C.
      rewrite HUeq. exact HXCdT.
    - assume HUeq: U = X :\: D.
      rewrite HUeq. exact HXDdT.
  }
  claim HUnionPair: Union {X :\: C, X :\: D} :e T.
  { exact (topology_union_closed X T {X :\: C, X :\: D} HTx Hpairsub). }
  rewrite (binunion_eq_Union_pair (X :\: C) (X :\: D)).
  exact HUnionPair.
}
prove topology_on X T /\ (C :/\: D c= X /\ exists U :e T, C :/\: D = X :\: U).
apply andI.
- exact HTx.
- apply andI.
  + exact (Subq_tra (C :/\: D) C X (binintersect_Subq_1 C D) HCsubX).
  + witness ((X :\: C) :\/: (X :\: D)).
    apply andI.
    * exact Hunion_compl_in_T.
    * prove C :/\: D = X :\: ((X :\: C) :\/: (X :\: D)).
      rewrite (setminus_binunion_eq_binintersect X (X :\: C) (X :\: D)).
      rewrite (setminus_setminus_eq X C HCsubX).
      rewrite (setminus_setminus_eq X D HDsubX).
      reflexivity.
Qed.

(** from 12: finite unions of closed sets are closed **)
(** LATEX VERSION: Finite unions of closed sets are closed because their complements are finite intersections of open sets. **)
Theorem binunion_closed : forall X T C D:set,
  closed_in X T C ->
  closed_in X T D ->
  closed_in X T (C :\/: D).
let X T C D.
assume HC: closed_in X T C.
assume HD: closed_in X T D.
prove closed_in X T (C :\/: D).
claim HTx: topology_on X T.
{ exact (andEL (topology_on X T) (C c= X /\ exists U :e T, C = X :\: U) HC). }
claim HCsubX: C c= X.
{ exact (andEL (C c= X) (exists U :e T, C = X :\: U)
        (andER (topology_on X T) (C c= X /\ exists U :e T, C = X :\: U) HC)). }
claim HDsubX: D c= X.
{ exact (andEL (D c= X) (exists U :e T, D = X :\: U)
        (andER (topology_on X T) (D c= X /\ exists U :e T, D = X :\: U) HD)). }
claim HopenC: open_in X T (X :\: C).
{ exact (open_of_closed_complement X T C HC). }
claim HopenD: open_in X T (X :\: D).
{ exact (open_of_closed_complement X T D HD). }
claim Hinter_compl_in_T: (X :\: C) :/\: (X :\: D) :e T.
{ claim HXCdT: X :\: C :e T.
  { exact (andER (topology_on X T) (X :\: C :e T) HopenC). }
  claim HXDdT: X :\: D :e T.
  { exact (andER (topology_on X T) (X :\: D :e T) HopenD). }
  exact (topology_binintersect_closed X T (X :\: C) (X :\: D) HTx HXCdT HXDdT).
}
prove topology_on X T /\ (C :\/: D c= X /\ exists U :e T, C :\/: D = X :\: U).
apply andI.
- exact HTx.
- apply andI.
  + exact (binunion_Subq_min C D X HCsubX HDsubX).
  + witness ((X :\: C) :/\: (X :\: D)).
    apply andI.
    * exact Hinter_compl_in_T.
    * prove C :\/: D = X :\: ((X :\: C) :/\: (X :\: D)).
      rewrite (setminus_binintersect_eq_binunion X (X :\: C) (X :\: D)).
      rewrite (setminus_setminus_eq X C HCsubX).
      rewrite (setminus_setminus_eq X D HDsubX).
      reflexivity.
Qed.

(** from 13: complements of finite sets are open in the standard topology on R **)
(** LATEX VERSION: In the standard topology, the complement of a finite set is open. **)
Theorem Sing_eq_UPair : forall x:set, {x} = {x,x}.
let x.
apply set_ext.
- let y. assume Hy : y :e {x}.
  claim Hyeq : y = x.
  { exact (SingE x y Hy). }
  rewrite Hyeq.
  exact (UPairI1 x x).
- let y. assume Hy : y :e {x,x}.
  claim Hyeq : y = x.
  { apply (UPairE y x x Hy (y = x)).
    - assume H1. exact H1.
    - assume H1. exact H1. }
  rewrite Hyeq.
  exact (SingI x).
Qed.

Theorem finite_complement_open_in_R_standard_topology : forall F:set,
  finite F ->
  F c= R ->
  R :\: F :e R_standard_topology.
let F. assume HFin.
assume HFsubR.
set p := fun F0:set => F0 c= R -> R :\: F0 :e R_standard_topology.
claim HpEmpty : p Empty.
{ assume Hsub : Empty c= R.
  claim Hreq : R :\: Empty = R.
  { apply set_ext.
    - let x. assume Hx : x :e R :\: Empty.
      exact (setminusE1 R Empty x Hx).
    - let x. assume HxR : x :e R.
      exact (setminusI R Empty x HxR (EmptyE x)). }
  rewrite Hreq.
  exact (topology_has_X R R_standard_topology (R_standard_topology_is_topology_local)).
}
claim HpStep : forall X y:set,
  finite X ->
  y /:e X ->
  p X ->
  p (X :\/: {y}).
{ let X y. assume HFinX HyNot HXind.
  assume HsubXY : (X :\/: {y}) c= R.
  claim HsubX : X c= R.
  { let z. assume HzX : z :e X.
    exact (HsubXY z (binunionI1 X {y} z HzX)). }
  claim HyR : y :e R.
  { exact (HsubXY y (binunionI2 X {y} y (SingI y))). }
  claim HXopen : R :\: X :e R_standard_topology.
  { exact (HXind HsubX). }
  claim Hyopen : R :\: {y} :e R_standard_topology.
  { rewrite (Sing_eq_UPair y).
    exact (R_minus_singleton_in_R_standard_topology y HyR). }
  claim Hdecomp : R :\: (X :\/: {y}) = (R :\: X) :/\: (R :\: {y}).
  { exact (setminus_binunion_eq_binintersect R X {y}). }
  rewrite Hdecomp.
  exact (topology_binintersect_closed R R_standard_topology (R :\: X) (R :\: {y})
         (R_standard_topology_is_topology_local)
         HXopen
         Hyopen).
}
claim Hall : forall F0:set, finite F0 -> p F0.
{ exact (finite_ind p HpEmpty HpStep). }
exact (Hall F HFin HFsubR).
Qed.

(** LATEX VERSION: Containment statements among the five  topologies in Exercise 7. **)
Theorem ex13_7_R_topology_containments :
  finer_than R_upper_limit_topology R_standard_topology /\
  finer_than R_K_topology R_standard_topology /\
  finer_than R_standard_topology R_finite_complement_topology /\
  finer_than R_standard_topology R_ray_topology.
prove finer_than R_upper_limit_topology R_standard_topology /\ finer_than R_K_topology R_standard_topology /\ finer_than R_standard_topology R_finite_complement_topology /\ finer_than R_standard_topology R_ray_topology.
apply andI.
- apply andI.
  + apply andI.
    * prove finer_than R_upper_limit_topology R_standard_topology.
      (** finer_than T' T means T c= T' **)
      prove R_standard_topology c= R_upper_limit_topology.
      let U. assume HU: U :e R_standard_topology.
      (** Expand generated_topology membership for the standard topology **)
      claim HUinPow : U :e Power R.
      { exact (SepE1 (Power R)
                     (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
                     U
                     HU). }
      claim HUprop : forall x :e U, exists b0 :e R_standard_basis, x :e b0 /\ b0 c= U.
      { exact (SepE2 (Power R)
                     (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
                     U
                     HU). }
      (** Refine a standard basis neighborhood (a,b) to an upper-limit neighborhood (a,x] around x **)
      claim HUpropUpper : forall x :e U, exists b0 :e R_upper_limit_basis, x :e b0 /\ b0 c= U.
      { let x. assume HxU.
        claim HexStd : exists bStd :e R_standard_basis, x :e bStd /\ bStd c= U.
        { exact (HUprop x HxU). }
        apply HexStd.
        let bStd. assume HbStdPair.
        claim HbStdIn : bStd :e R_standard_basis.
        { exact (andEL (bStd :e R_standard_basis) (x :e bStd /\ bStd c= U) HbStdPair). }
        claim HbStdProp : x :e bStd /\ bStd c= U.
        { exact (andER (bStd :e R_standard_basis) (x :e bStd /\ bStd c= U) HbStdPair). }
        claim HxInbStd : x :e bStd.
        { exact (andEL (x :e bStd) (bStd c= U) HbStdProp). }
        claim HbStdSubU : bStd c= U.
        { exact (andER (x :e bStd) (bStd c= U) HbStdProp). }
        (** Unpack bStd as an open interval open_interval a0 b0 **)
        claim Hexa0 : exists a0 :e R, bStd :e {open_interval a0 b0|b0 :e R}.
        { exact (famunionE R (fun a0 : set => {open_interval a0 b0|b0 :e R}) bStd HbStdIn). }
        apply Hexa0.
        let a0. assume Ha0Pair.
        claim Ha0R : a0 :e R.
        { exact (andEL (a0 :e R) (bStd :e {open_interval a0 b0|b0 :e R}) Ha0Pair). }
        claim HbStdFam : bStd :e {open_interval a0 b0|b0 :e R}.
        { exact (andER (a0 :e R) (bStd :e {open_interval a0 b0|b0 :e R}) Ha0Pair). }
        claim Hexb0 : exists b0 :e R, bStd = open_interval a0 b0.
        { exact (ReplE R (fun b0 : set => open_interval a0 b0) bStd HbStdFam). }
        apply Hexb0.
        let b0. assume Hb0Pair.
        claim Hb0R : b0 :e R.
        { exact (andEL (b0 :e R) (bStd = open_interval a0 b0) Hb0Pair). }
        claim HbStdEq : bStd = open_interval a0 b0.
        { exact (andER (b0 :e R) (bStd = open_interval a0 b0) Hb0Pair). }
        (** From x in bStd, extract x in open_interval a0 b0 **)
        claim HxInI : x :e open_interval a0 b0.
        { rewrite <- HbStdEq.
          exact HxInbStd. }
        claim HxR : x :e R.
        { exact (SepE1 R (fun x0 : set => Rlt a0 x0 /\ Rlt x0 b0) x HxInI). }
        claim HxIProp : Rlt a0 x /\ Rlt x b0.
        { exact (SepE2 R (fun x0 : set => Rlt a0 x0 /\ Rlt x0 b0) x HxInI). }
        claim Ha0x : Rlt a0 x.
        { exact (andEL (Rlt a0 x) (Rlt x b0) HxIProp). }
        claim Hxb0 : Rlt x b0.
        { exact (andER (Rlt a0 x) (Rlt x b0) HxIProp). }
        (** Define the upper-limit neighborhood (a0,x] **)
        set bUpper := halfopen_interval_right a0 x.
        witness bUpper.
        apply andI.
        - (** bUpper is in the upper-limit basis **)
          claim HbFamUpper : bUpper :e {halfopen_interval_right a0 bb|bb :e R}.
          { exact (ReplI R (fun bb : set => halfopen_interval_right a0 bb) x HxR). }
          exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R})
                           a0
                           bUpper
                           Ha0R
                           HbFamUpper).
        - apply andI.
          + (** x is in (a0,x] **)
            exact (halfopen_interval_right_rightmem a0 x Ha0x).
          + (** (a0,x] is contained in U **)
            let y. assume HyUpper : y :e bUpper.
            prove y :e U.
            claim HyR : y :e R.
            { exact (SepE1 R (fun y0 : set => Rlt a0 y0 /\ ~(Rlt x y0)) y HyUpper). }
            claim HyProp : Rlt a0 y /\ ~(Rlt x y).
            { exact (SepE2 R (fun y0 : set => Rlt a0 y0 /\ ~(Rlt x y0)) y HyUpper). }
            claim Ha0y : Rlt a0 y.
            { exact (andEL (Rlt a0 y) (~(Rlt x y)) HyProp). }
            claim HnotRltxy : ~(Rlt x y).
            { exact (andER (Rlt a0 y) (~(Rlt x y)) HyProp). }
            (** Convert ~(Rlt x y) into ~(x<y) using known realness of x and y **)
            claim Hnot_xlt_y : ~(x < y).
            { assume Hxy : x < y.
              claim HxyRlt : Rlt x y.
              { exact (RltI x y HxR HyR Hxy). }
              exact (HnotRltxy HxyRlt). }
            (** Show y < b0 using trichotomy between y and x, since x < b0 **)
            claim HyS : SNo y.
            { exact (real_SNo y HyR). }
            claim HxS : SNo x.
            { exact (real_SNo x HxR). }
            claim Hb0S : SNo b0.
            { exact (real_SNo b0 Hb0R). }
            claim Hxltb0 : x < b0.
            { exact (RltE_lt x b0 Hxb0). }
            claim Hyltb0 : y < b0.
            { apply (SNoLt_trichotomy_or_impred y x HyS HxS (y < b0)).
              - assume Hyltx : y < x.
                exact (SNoLt_tra y x b0 HyS HxS Hb0S Hyltx Hxltb0).
              - assume Heyx : y = x.
                rewrite Heyx.
                exact Hxltb0.
              - assume HxltY : x < y.
                claim HxyFalse : False.
                { exact (Hnot_xlt_y HxltY). }
                exact (FalseE HxyFalse (y < b0)). }
            claim HyRltb0 : Rlt y b0.
            { exact (RltI y b0 HyR Hb0R Hyltb0). }
            (** y is in the standard open interval (a0,b0) = bStd **)
            claim HyConj : Rlt a0 y /\ Rlt y b0.
            { apply andI.
              - exact Ha0y.
              - exact HyRltb0. }
            claim HyInI : y :e open_interval a0 b0.
            { exact (SepI R (fun y0 : set => Rlt a0 y0 /\ Rlt y0 b0) y HyR HyConj). }
            claim HyInbStd : y :e bStd.
            { rewrite HbStdEq at 1.
              exact HyInI. }
            exact (HbStdSubU y HyInbStd).
      }
      (** Conclude: U is open in R_upper_limit_topology by definition **)
      exact (SepI (Power R)
                  (fun U0 : set => forall x0 :e U0, exists b0 :e R_upper_limit_basis, x0 :e b0 /\ b0 c= U0)
                  U
                  HUinPow
                  HUpropUpper).
    * prove finer_than R_K_topology R_standard_topology.
      (** finer_than T' T means T c= T' **)
      prove R_standard_topology c= R_K_topology.
      let U. assume HU: U :e R_standard_topology.
      (** Expand generated_topology membership for the standard topology **)
      claim HUinPow : U :e Power R.
      { exact (SepE1 (Power R)
                     (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
                     U
                     HU). }
      claim HUprop : forall x :e U, exists b0 :e R_standard_basis, x :e b0 /\ b0 c= U.
      { exact (SepE2 (Power R)
                     (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
                     U
                     HU). }
      (** Show U satisfies the defining property for generated_topology R (R_standard_basis :\/: R_K_basis) **)
      claim HUpropK : forall x :e U, exists b0 :e (R_standard_basis :\/: R_K_basis), x :e b0 /\ b0 c= U.
      { let x. assume HxU.
        claim Hexb : exists b0 :e R_standard_basis, x :e b0 /\ b0 c= U.
        { exact (HUprop x HxU). }
        apply Hexb.
        let b0. assume Hb0pair.
        claim Hb0Std : b0 :e R_standard_basis.
        { exact (andEL (b0 :e R_standard_basis) (x :e b0 /\ b0 c= U) Hb0pair). }
        claim Hb0prop : x :e b0 /\ b0 c= U.
        { exact (andER (b0 :e R_standard_basis) (x :e b0 /\ b0 c= U) Hb0pair). }
        claim Hxb0 : x :e b0.
        { exact (andEL (x :e b0) (b0 c= U) Hb0prop). }
        claim Hb0subU : b0 c= U.
        { exact (andER (x :e b0) (b0 c= U) Hb0prop). }
        witness b0.
        apply andI.
        - exact (binunionI1 R_standard_basis R_K_basis b0 Hb0Std).
        - apply andI.
          + exact Hxb0.
          + exact Hb0subU. }
      exact (SepI (Power R)
                  (fun U0 : set => forall x0 :e U0, exists b0 :e (R_standard_basis :\/: R_K_basis), x0 :e b0 /\ b0 c= U0)
                  U
                  HUinPow
                  HUpropK).
  + prove finer_than R_standard_topology R_finite_complement_topology.
    (** finer_than T' T means T c= T' **)
    prove R_finite_complement_topology c= R_standard_topology.
    let U. assume HU : U :e R_finite_complement_topology.
    (** Unpack membership in finite_complement_topology R **)
    claim HUpow : U :e Power R.
    { exact (SepE1 (Power R)
                   (fun U0 : set => finite (R :\: U0) \/ U0 = Empty)
                   U
                   HU). }
    claim HUsub : U c= R.
    { exact (PowerE R U HUpow). }
    claim HUcases : finite (R :\: U) \/ U = Empty.
    { exact (SepE2 (Power R)
                   (fun U0 : set => finite (R :\: U0) \/ U0 = Empty)
                   U
                   HU). }
    apply (HUcases (U :e R_standard_topology)).
    - assume HFin : finite (R :\: U).
      prove U :e R_standard_topology.
      claim HFsubR : (R :\: U) c= R.
      { exact (setminus_Subq R U). }
      claim Hopen : R :\: (R :\: U) :e R_standard_topology.
      { exact (finite_complement_open_in_R_standard_topology (R :\: U) HFin HFsubR). }
      rewrite <- (setminus_setminus_eq R U HUsub).
      exact Hopen.
    - assume HUe : U = Empty.
      rewrite HUe.
      exact (topology_has_empty R R_standard_topology (R_standard_topology_is_topology_local)).
- prove finer_than R_standard_topology R_ray_topology.
  let U. assume HU: U :e R_ray_topology.
  claim HUcases : U = Empty \/ U = R \/ exists a :e R, U = {x :e R|Rlt x a}.
  { exact (SepE2 (Power R) (fun U0 : set => U0 = Empty \/ U0 = R \/ exists a0 :e R, U0 = {x :e R|Rlt x a0}) U HU). }
  claim Hempty : Empty :e R_standard_topology.
  { exact (SepI (Power R)
                (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
                Empty
                (Empty_In_Power R)
                (fun x0 Hx0 => EmptyE x0 Hx0 (exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= Empty))). }
  claim Hall : R :e R_standard_topology.
  { claim HRpow : R :e Power R.
    { apply PowerI.
      exact (Subq_ref R). }
    claim HRprop : forall x :e R, exists b0 :e R_standard_basis, x :e b0 /\ b0 c= R.
    { let x. assume HxR.
      set a0 := add_SNo x (minus_SNo 1).
      set b0 := add_SNo x 1.
      set I := open_interval a0 b0.
      claim Hm1R : minus_SNo 1 :e R.
      { exact (real_minus_SNo 1 real_1). }
      claim Ha0R : a0 :e R.
      { exact (real_add_SNo x HxR (minus_SNo 1) Hm1R). }
      claim Hb0R : b0 :e R.
      { exact (real_add_SNo x HxR 1 real_1). }
      claim HxS : SNo x.
      { exact (real_SNo x HxR). }
      claim Hm1S : SNo (minus_SNo 1).
      { exact (real_SNo (minus_SNo 1) Hm1R). }
      claim Ha0lt : a0 < x.
      { claim Hlt : a0 < add_SNo x 0.
        { exact (add_SNo_Lt2 x (minus_SNo 1) 0 HxS Hm1S SNo_0 minus_1_lt_0). }
        rewrite <- (add_SNo_0R x HxS) at 2.
        exact Hlt. }
      claim Hxb0 : x < b0.
      { claim Hlt : add_SNo x 0 < b0.
        { exact (add_SNo_Lt2 x 0 1 HxS SNo_0 (real_SNo 1 real_1) SNoLt_0_1). }
        rewrite <- (add_SNo_0R x HxS) at 1.
        exact Hlt. }
      claim HxInI : x :e I.
      { claim Hax : Rlt a0 x.
        { exact (RltI a0 x Ha0R HxR Ha0lt). }
        claim Hxb : Rlt x b0.
        { exact (RltI x b0 HxR Hb0R Hxb0). }
        claim Hconj : Rlt a0 x /\ Rlt x b0.
        { apply andI.
          - exact Hax.
          - exact Hxb. }
        exact (SepI R (fun x0 : set => Rlt a0 x0 /\ Rlt x0 b0) x HxR Hconj). }
      claim HIStd : I :e R_standard_basis.
      { claim HIa : I :e {open_interval a0 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => open_interval a0 bb) b0 Hb0R). }
        exact (famunionI R
                         (fun aa : set => {open_interval aa bb|bb :e R})
                         a0
                         I
                         Ha0R
                         HIa). }
      witness I.
      apply andI.
      - exact HIStd.
      - apply andI.
        + exact HxInI.
        + exact (open_interval_Subq_R a0 b0). }
    exact (SepI (Power R)
                (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
                R
                HRpow
                HRprop). }
  claim Hcase1 : U = Empty -> U :e R_standard_topology.
  { assume Heq. rewrite Heq. exact Hempty. }
  claim Hcase2 : U = R -> U :e R_standard_topology.
  { assume Heq. rewrite Heq. exact Hall. }
  claim Hcase3 : (exists a0 :e R, U = {x :e R|Rlt x a0}) -> U :e R_standard_topology.
  { assume Hex.
    apply Hex.
    let a0.
    assume Ha0pair : a0 :e R /\ U = {x :e R|Rlt x a0}.
    claim Ha0R : a0 :e R.
    { exact (andEL (a0 :e R) (U = {x :e R|Rlt x a0}) Ha0pair). }
    claim Heq : U = {x :e R|Rlt x a0}.
    { exact (andER (a0 :e R) (U = {x :e R|Rlt x a0}) Ha0pair). }
    rewrite Heq.
    exact (open_left_ray_in_R_standard_topology a0 Ha0R). }
  prove U :e R_standard_topology.
  apply (HUcases (U :e R_standard_topology)).
  - assume HUR : U = Empty \/ U = R.
    apply (HUR (U :e R_standard_topology)).
    + exact Hcase1.
    + exact Hcase2.
  - exact Hcase3.
Qed.

(** from 13 Exercise 8(a): rational open intervals generate standard topology on  **) 
(** LATEX VERSION: Exercise 8(a): Basis of rational open intervals generates the standard topology on . **)
Definition rational_open_intervals_basis : set :=
  \/_ q1 :e rational_numbers, {open_interval q1 q2|q2 :e rational_numbers}.

(** from 13 Exercise 8(a): rational open intervals are standard open intervals **)
(** LATEX VERSION: Any rational open interval (q1,q2) is a standard basis element since q1,q2 are real. **)
Theorem rational_open_intervals_basis_Subq_R_standard_basis :
  rational_open_intervals_basis c= R_standard_basis.
prove rational_open_intervals_basis c= R_standard_basis.
let I. assume HI: I :e rational_open_intervals_basis.
apply (famunionE_impred rational_numbers
         (fun q1 : set => {open_interval q1 q2|q2 :e rational_numbers})
         I
         HI
         (I :e R_standard_basis)).
let q1. assume Hq1Q HIq1.
apply (ReplE_impred rational_numbers
         (fun q2 : set => open_interval q1 q2)
         I
         HIq1
         (I :e R_standard_basis)).
let q2. assume Hq2Q Heq.
rewrite Heq.
claim Hq1R : q1 :e R.
{ exact (rational_numbers_in_R q1 Hq1Q). }
claim Hq2R : q2 :e R.
{ exact (rational_numbers_in_R q2 Hq2Q). }
claim HIq2 : open_interval q1 q2 :e {open_interval q1 b|b :e R}.
{ exact (ReplI R (fun b : set => open_interval q1 b) q2 Hq2R). }
exact (famunionI R (fun a : set => {open_interval a b|b :e R}) q1 (open_interval q1 q2) Hq1R HIq2).
Qed.

(** from 13 Exercise 8(a): density of rationals in reals (in order sense) **)
(** LATEX VERSION: Between any two real numbers a<b there exists a rational q with a<q<b. **)
Theorem rational_dense_between_reals : forall a b:set,
  a :e R -> b :e R -> Rlt a b ->
  exists q :e rational_numbers, Rlt a q /\ Rlt q b.
let a b.
assume HaR HbR Hab.
prove exists q :e rational_numbers, Rlt a q /\ Rlt q b.
claim HaS: SNo a.
{ exact (real_SNo a HaR). }
claim HbS: SNo b.
{ exact (real_SNo b HbR). }
claim Hablt: a < b.
{ exact (RltE_lt a b Hab). }
claim HmaR: minus_SNo a :e R.
{ exact (real_minus_SNo a HaR). }
claim HmaS: SNo (minus_SNo a).
{ exact (real_SNo (minus_SNo a) HmaR). }
set d := add_SNo b (minus_SNo a).
claim HdDef: d = add_SNo b (minus_SNo a).
{ reflexivity. }
claim HdR: d :e R.
{ rewrite HdDef.
  exact (real_add_SNo b HbR (minus_SNo a) HmaR). }
claim HdS: SNo d.
{ exact (real_SNo d HdR). }
claim H0ltd: 0 < d.
{ rewrite HdDef.
  claim Hlt: add_SNo a (minus_SNo a) < add_SNo b (minus_SNo a).
  { exact (add_SNo_Lt1 a (minus_SNo a) b HaS HmaS HbS Hablt). }
  claim H0eq: add_SNo a (minus_SNo a) = 0.
  { exact (add_SNo_minus_SNo_rinv a HaS). }
  rewrite <- H0eq.
  exact Hlt. }
(** choose N with eps_N < d using invd = 1/d and a bounded eps product **)
set invd := recip_SNo_pos d.
claim HinvdDef: invd = recip_SNo_pos d.
{ reflexivity. }
claim HinvdR: invd :e R.
{ rewrite HinvdDef.
  exact (real_recip_SNo_pos d HdR H0ltd). }
claim HinvdS: SNo invd.
{ exact (real_SNo invd HinvdR). }
claim Hinvdpos: 0 < invd.
{ exact (recip_SNo_pos_is_pos d HdS H0ltd). }
claim HexN: exists N :e omega, eps_ N < d.
{ apply (real_E invd HinvdR (exists N :e omega, eps_ N < d)).
  assume HinvS: SNo invd.
  assume Hlev.
  assume HinS.
  assume Hlow.
  assume Hup.
  assume Huniq.
  assume Happrox.
  claim HexNlt: exists N :e omega, mul_SNo (eps_ N) invd < 1.
  { exact (SNoS_ordsucc_omega_bdd_eps_pos invd HinS Hinvdpos Hup). }
  apply HexNlt.
  let N. assume HNpair.
  claim HNomega: N :e omega.
  { exact (andEL (N :e omega) (mul_SNo (eps_ N) invd < 1) HNpair). }
  claim HmulLt: mul_SNo (eps_ N) invd < 1.
  { exact (andER (N :e omega) (mul_SNo (eps_ N) invd < 1) HNpair). }
  witness N.
  apply andI.
  - exact HNomega.
  - claim HepsS: SNo (eps_ N).
    { exact (SNo_eps_ N HNomega). }
    (** eps_N < 1/:/invd, then 1/:/invd = d **)
    claim HepsLtDiv: eps_ N < div_SNo 1 invd.
    { exact (div_SNo_pos_LtR 1 invd (eps_ N) SNo_1 HinvS HepsS Hinvdpos HmulLt). }
    claim HdivEq: div_SNo 1 invd = d.
    { claim Hposcase: recip_SNo invd = recip_SNo_pos invd.
      { exact (recip_SNo_poscase invd Hinvdpos). }
      claim HrecipInv: recip_SNo_pos invd = d.
      { rewrite HinvdDef.
        exact (recip_SNo_pos_invol d HdS H0ltd). }
      claim HdivDef: div_SNo 1 invd = mul_SNo 1 (recip_SNo invd).
      { reflexivity. }
      rewrite HdivDef.
      rewrite Hposcase.
      rewrite HrecipInv.
      exact (mul_SNo_oneL d HdS). }
    rewrite <- HdivEq.
    exact HepsLtDiv.
}
apply HexN.
let N. assume HNpair.
claim HNomega: N :e omega.
{ exact (andEL (N :e omega) (eps_ N < d) HNpair). }
claim HepsNlt: eps_ N < d.
{ exact (andER (N :e omega) (eps_ N < d) HNpair). }
(** approximate b from below within eps_N using real_E, then show the approximant lies above a **)
claim Hexq: exists q :e SNoS_ omega, q < b /\ b < add_SNo q (eps_ N).
{ apply (real_E b HbR (exists q :e SNoS_ omega, q < b /\ b < add_SNo q (eps_ N))).
  assume HbS': SNo b.
  assume Hlev.
  assume HbInS.
  assume Hlow.
  assume Hup.
  assume Huniq.
  assume Happrox.
  exact (Happrox N HNomega). }
apply Hexq.
let q. assume Hqpair. apply Hqpair.
assume HqInS: q :e SNoS_ omega.
assume Hqprop: q < b /\ b < add_SNo q (eps_ N).
claim Hqltb: q < b.
{ exact (andEL (q < b) (b < add_SNo q (eps_ N)) Hqprop). }
claim Hbltqeps: b < add_SNo q (eps_ N).
{ exact (andER (q < b) (b < add_SNo q (eps_ N)) Hqprop). }
claim HqRat: q :e rational_numbers.
{ exact (Subq_SNoS_omega_rational q HqInS). }
claim HqR: q :e R.
{ exact (rational_numbers_in_R q HqRat). }
claim HqS: SNo q.
{ exact (real_SNo q HqR). }
claim HepsR: eps_ N :e R.
{ exact (rational_numbers_in_R (eps_ N) (Subq_SNoS_omega_rational (eps_ N) (SNo_eps_SNoS_omega N HNomega))). }
claim HepsS: SNo (eps_ N).
{ exact (real_SNo (eps_ N) HepsR). }
claim Hbmepsltq: add_SNo b (minus_SNo (eps_ N)) < q.
{ exact (add_SNo_minus_Lt1b b (eps_ N) q HbS HepsS HqS Hbltqeps). }
claim Haepsltb: add_SNo a (eps_ N) < b.
{ prove add_SNo a (eps_ N) < b.
  claim Hlt1: add_SNo (eps_ N) a < add_SNo d a.
  { exact (add_SNo_Lt1 (eps_ N) a d HepsS HaS HdS HepsNlt). }
  claim Hdplus: add_SNo d a = b.
  { rewrite HdDef.
    exact (add_SNo_minus_R2' b a HbS HaS). }
  claim Hcom: add_SNo (eps_ N) a = add_SNo a (eps_ N).
  { exact (add_SNo_com (eps_ N) a HepsS HaS). }
  rewrite <- Hcom.
  rewrite <- Hdplus.
  exact Hlt1. }
claim Haltbmeps: a < add_SNo b (minus_SNo (eps_ N)).
{ exact (add_SNo_minus_Lt2b b (eps_ N) a HbS HepsS HaS Haepsltb). }
claim HbmepsS: SNo (add_SNo b (minus_SNo (eps_ N))).
{ exact (SNo_add_SNo b (minus_SNo (eps_ N)) HbS (SNo_minus_SNo (eps_ N) HepsS)). }
claim Hqlt: a < q.
{ exact (SNoLt_tra a (add_SNo b (minus_SNo (eps_ N))) q HaS HbmepsS HqS Haltbmeps Hbmepsltq). }
claim Haq: Rlt a q.
{ exact (RltI a q HaR HqR Hqlt). }
claim Hqb: Rlt q b.
{ exact (RltI q b HqR HbR Hqltb). }
witness q.
apply andI.
- exact HqRat.
- apply andI.
  - exact Haq.
  - exact Hqb.
Qed.

(** from 13 Exercise 8(a): rational endpoints around a point in a real open interval **)
(** LATEX VERSION: If x is in (a,b) then there are rationals q1,q2 with q1<x<q2 and (q1,q2) contained in (a,b). **)
Theorem rational_interval_refines_real_interval : forall a b x:set,
  a :e R -> b :e R -> x :e R ->
  x :e open_interval a b ->
  exists q1 :e rational_numbers, exists q2 :e rational_numbers,
    x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a b.
let a b x.
assume HaR HbR HxR HxInab.
claim HxabProp: Rlt a x /\ Rlt x b.
{ exact (SepE2 R (fun z : set => Rlt a z /\ Rlt z b) x HxInab). }
claim Hax: Rlt a x.
{ exact (andEL (Rlt a x) (Rlt x b) HxabProp). }
claim Hxb: Rlt x b.
{ exact (andER (Rlt a x) (Rlt x b) HxabProp). }
(** choose q1 rational with a<q1<x **)
apply (rational_dense_between_reals a x HaR HxR Hax).
let q1. assume Hq1pair. apply Hq1pair.
assume Hq1Q: q1 :e rational_numbers.
assume Hq1Prop: Rlt a q1 /\ Rlt q1 x.
claim Hq1R: q1 :e R.
{ exact (rational_numbers_in_R q1 Hq1Q). }
claim Haq1: Rlt a q1.
{ exact (andEL (Rlt a q1) (Rlt q1 x) Hq1Prop). }
claim Hq1x: Rlt q1 x.
{ exact (andER (Rlt a q1) (Rlt q1 x) Hq1Prop). }
(** choose q2 rational with x<q2<b **)
apply (rational_dense_between_reals x b HxR HbR Hxb).
let q2. assume Hq2pair. apply Hq2pair.
assume Hq2Q: q2 :e rational_numbers.
assume Hq2Prop: Rlt x q2 /\ Rlt q2 b.
claim Hq2R: q2 :e R.
{ exact (rational_numbers_in_R q2 Hq2Q). }
claim Hxq2: Rlt x q2.
{ exact (andEL (Rlt x q2) (Rlt q2 b) Hq2Prop). }
claim Hq2b: Rlt q2 b.
{ exact (andER (Rlt x q2) (Rlt q2 b) Hq2Prop). }
(** witness the rational interval (q1,q2) around x **)
witness q1.
apply andI.
- exact Hq1Q.
- witness q2.
  apply andI.
  * exact Hq2Q.
  * apply andI.
    { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z q2) x HxR
                   (andI (Rlt q1 x) (Rlt x q2) Hq1x Hxq2)). }
    { let y. assume Hy: y :e open_interval q1 q2.
      prove y :e open_interval a b.
      claim HyR: y :e R.
      { exact (SepE1 R (fun z : set => Rlt q1 z /\ Rlt z q2) y Hy). }
      claim HyProp: Rlt q1 y /\ Rlt y q2.
      { exact (SepE2 R (fun z : set => Rlt q1 z /\ Rlt z q2) y Hy). }
      claim Hq1y: Rlt q1 y.
      { exact (andEL (Rlt q1 y) (Rlt y q2) HyProp). }
      claim Hyq2: Rlt y q2.
      { exact (andER (Rlt q1 y) (Rlt y q2) HyProp). }
      claim HaS: SNo a.
      { exact (real_SNo a HaR). }
      claim Hq1S: SNo q1.
      { exact (real_SNo q1 Hq1R). }
      claim HyS: SNo y.
      { exact (real_SNo y HyR). }
      claim HbS: SNo b.
      { exact (real_SNo b HbR). }
      claim Hq2S: SNo q2.
      { exact (real_SNo q2 Hq2R). }
      claim Haq1lt: a < q1.
      { exact (RltE_lt a q1 Haq1). }
      claim Hq1ylt: q1 < y.
      { exact (RltE_lt q1 y Hq1y). }
      claim Hyq2lt: y < q2.
      { exact (RltE_lt y q2 Hyq2). }
      claim Hq2blt: q2 < b.
      { exact (RltE_lt q2 b Hq2b). }
      claim Haylt: a < y.
      { exact (SNoLt_tra a q1 y HaS Hq1S HyS Haq1lt Hq1ylt). }
      claim Hyblt: y < b.
      { exact (SNoLt_tra y q2 b HyS Hq2S HbS Hyq2lt Hq2blt). }
      claim Hay: Rlt a y.
      { exact (RltI a y HaR HyR Haylt). }
      claim Hyb: Rlt y b.
      { exact (RltI y b HyR HbR Hyblt). }
      claim Hconj: Rlt a y /\ Rlt y b.
      { apply andI.
        - exact Hay.
        - exact Hyb. }
      exact (SepI R (fun z : set => Rlt a z /\ Rlt z b) y HyR Hconj). }
Qed.

Theorem ex13_8a_rational_intervals_basis_standard :
  basis_on R rational_open_intervals_basis /\
  generated_topology R rational_open_intervals_basis = R_standard_topology.
prove basis_on R rational_open_intervals_basis /\ generated_topology R rational_open_intervals_basis = R_standard_topology.
(** NOTE: This needs a density lemma for `rational_numbers` in `R`; a route is to use `real_E` to approximate reals by elements of `SNoS_ omega` and then `Subq_SNoS_omega_rational`, plus an inequality bridge using `eps_ k`. **)
apply andI.
- (** rational open intervals satisfy basis_on R (partial: subset property) **)
  prove rational_open_intervals_basis c= Power R
    /\ (forall x :e R, exists b :e rational_open_intervals_basis, x :e b)
    /\ (forall b1 :e rational_open_intervals_basis, forall b2 :e rational_open_intervals_basis, forall x:set,
          x :e b1 -> x :e b2 ->
          exists b3 :e rational_open_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2).
  apply andI.
  - prove rational_open_intervals_basis c= Power R /\ (forall x :e R, exists b :e rational_open_intervals_basis, x :e b).
    apply andI.
    + (** every rational open interval is a subset of R **)
      prove rational_open_intervals_basis c= Power R.
      let b. assume Hb: b :e rational_open_intervals_basis.
      prove b :e Power R.
      apply (famunionE_impred rational_numbers
               (fun q1 : set => {open_interval q1 q2|q2 :e rational_numbers})
               b
               Hb
               (b :e Power R)).
      let q1. assume Hq1 Hbq1.
      apply (ReplE_impred rational_numbers
               (fun q2 : set => open_interval q1 q2)
               b
               Hbq1
               (b :e Power R)).
	      let q2. assume Hq2 Heq.
	      rewrite Heq.
	      exact (PowerI R (open_interval q1 q2) (open_interval_Subq_R q1 q2)).
	    + (** coverage of R by rational open intervals **)
	      let x. assume HxR.
	      set a0 := add_SNo x (minus_SNo 1).
	      set b0 := add_SNo x 1.
	      claim Hm1R : minus_SNo 1 :e R.
	      { exact (real_minus_SNo 1 real_1). }
	      claim Ha0R : a0 :e R.
	      { exact (real_add_SNo x HxR (minus_SNo 1) Hm1R). }
	      claim Hb0R : b0 :e R.
	      { exact (real_add_SNo x HxR 1 real_1). }
	      claim HxInI : x :e open_interval a0 b0.
	      { exact (real_in_open_interval_minus1_plus1 x HxR). }
	      claim HexRat : exists q1 :e rational_numbers, exists q2 :e rational_numbers,
	        x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a0 b0.
	      { exact (rational_interval_refines_real_interval a0 b0 x Ha0R Hb0R HxR HxInI). }
	      apply HexRat.
	      let q1. assume Hq1pair. apply Hq1pair.
	      assume Hq1: q1 :e rational_numbers.
	      assume Hexq2: exists q2 :e rational_numbers,
	        x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a0 b0.
	      apply Hexq2.
	      let q2. assume Hq2pair. apply Hq2pair.
	      assume Hq2: q2 :e rational_numbers.
	      assume HxInQ : x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a0 b0.
	      claim HxInQint : x :e open_interval q1 q2.
	      { exact (andEL (x :e open_interval q1 q2) (open_interval q1 q2 c= open_interval a0 b0) HxInQ). }
	      witness (open_interval q1 q2).
	      apply andI.
	      * (** open_interval q1 q2 is in the rational-open-interval basis **)
	        claim Hq2fam : open_interval q1 q2 :e {open_interval q1 q2'|q2' :e rational_numbers}.
	        { exact (ReplI rational_numbers (fun q2' : set => open_interval q1 q2') q2 Hq2). }
	        exact (famunionI rational_numbers
	                 (fun q1' : set => {open_interval q1' q2'|q2' :e rational_numbers})
	                 q1
	                 (open_interval q1 q2)
	                 Hq1
	                 Hq2fam).
	      * exact HxInQint.
	  - (** intersection refinement using rational endpoints **)
	    let b1. assume Hb1.
	    let b2. assume Hb2.
	    let x. assume Hx1 Hx2.
	    prove exists b3 :e rational_open_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2.
	    (** destruct b1 = open_interval q1 q2 with q1,q2 rationals **)
	    claim Hexq1 : exists q1 :e rational_numbers, b1 :e {open_interval q1 q2|q2 :e rational_numbers}.
	    { exact (famunionE rational_numbers (fun q1 : set => {open_interval q1 q2|q2 :e rational_numbers}) b1 Hb1). }
	    apply Hexq1.
	    let q1. assume Hq1pair. apply Hq1pair.
	    assume Hq1Q : q1 :e rational_numbers.
	    assume Hb1fam : b1 :e {open_interval q1 q2|q2 :e rational_numbers}.
	    claim Hexq2 : exists q2 :e rational_numbers, b1 = open_interval q1 q2.
	    { exact (ReplE rational_numbers (fun q2 : set => open_interval q1 q2) b1 Hb1fam). }
	    apply Hexq2.
	    let q2. assume Hq2pair. apply Hq2pair.
	    assume Hq2Q : q2 :e rational_numbers.
	    assume Hb1eq : b1 = open_interval q1 q2.
	    (** destruct b2 = open_interval r1 r2 with r1,r2 rationals **)
	    claim Hexr1 : exists r1 :e rational_numbers, b2 :e {open_interval r1 r2|r2 :e rational_numbers}.
	    { exact (famunionE rational_numbers (fun r1 : set => {open_interval r1 r2|r2 :e rational_numbers}) b2 Hb2). }
	    apply Hexr1.
	    let r1. assume Hr1pair. apply Hr1pair.
	    assume Hr1Q : r1 :e rational_numbers.
	    assume Hb2fam : b2 :e {open_interval r1 r2|r2 :e rational_numbers}.
	    claim Hexr2 : exists r2 :e rational_numbers, b2 = open_interval r1 r2.
	    { exact (ReplE rational_numbers (fun r2 : set => open_interval r1 r2) b2 Hb2fam). }
	    apply Hexr2.
	    let r2. assume Hr2pair. apply Hr2pair.
	    assume Hr2Q : r2 :e rational_numbers.
	    assume Hb2eq : b2 = open_interval r1 r2.
	    (** x in the two intervals **)
	    claim HxIn1 : x :e open_interval q1 q2.
	    { rewrite <- Hb1eq. exact Hx1. }
	    claim HxIn2 : x :e open_interval r1 r2.
	    { rewrite <- Hb2eq. exact Hx2. }
	    claim HxR : x :e R.
	    { exact (SepE1 R (fun z : set => Rlt q1 z /\ Rlt z q2) x HxIn1). }
	    claim HxProp1 : Rlt q1 x /\ Rlt x q2.
	    { exact (SepE2 R (fun z : set => Rlt q1 z /\ Rlt z q2) x HxIn1). }
	    claim HxProp2 : Rlt r1 x /\ Rlt x r2.
	    { exact (SepE2 R (fun z : set => Rlt r1 z /\ Rlt z r2) x HxIn2). }
	    claim Hq1x : Rlt q1 x.
	    { exact (andEL (Rlt q1 x) (Rlt x q2) HxProp1). }
	    claim Hxq2 : Rlt x q2.
	    { exact (andER (Rlt q1 x) (Rlt x q2) HxProp1). }
	    claim Hr1x : Rlt r1 x.
	    { exact (andEL (Rlt r1 x) (Rlt x r2) HxProp2). }
	    claim Hxr2 : Rlt x r2.
	    { exact (andER (Rlt r1 x) (Rlt x r2) HxProp2). }
	    (** endpoint types **)
	    claim Hq1R : q1 :e R.
	    { exact (rational_numbers_in_R q1 Hq1Q). }
	    claim Hq2R : q2 :e R.
	    { exact (rational_numbers_in_R q2 Hq2Q). }
	    claim Hr1R : r1 :e R.
	    { exact (rational_numbers_in_R r1 Hr1Q). }
	    claim Hr2R : r2 :e R.
	    { exact (rational_numbers_in_R r2 Hr2Q). }
	    claim Hq1S : SNo q1.
	    { exact (real_SNo q1 Hq1R). }
	    claim Hq2S : SNo q2.
	    { exact (real_SNo q2 Hq2R). }
	    claim Hr1S : SNo r1.
	    { exact (real_SNo r1 Hr1R). }
	    claim Hr2S : SNo r2.
	    { exact (real_SNo r2 Hr2R). }
	    claim HxS : SNo x.
	    { exact (real_SNo x HxR). }
	    claim Hq1xlt : q1 < x.
	    { exact (RltE_lt q1 x Hq1x). }
	    claim Hr1xlt : r1 < x.
	    { exact (RltE_lt r1 x Hr1x). }
	    claim Hxq2lt : x < q2.
	    { exact (RltE_lt x q2 Hxq2). }
	    claim Hxr2lt : x < r2.
	    { exact (RltE_lt x r2 Hxr2). }
	    (** choose max left endpoint and min right endpoint by trichotomy **)
	    apply (SNoLt_trichotomy_or_impred q1 r1 Hq1S Hr1S
	             (exists b3 :e rational_open_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
	    - assume Hq1lt : q1 < r1.
	      (** left endpoint r1 **)
	      apply (SNoLt_trichotomy_or_impred q2 r2 Hq2S Hr2S
	               (exists b3 :e rational_open_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
	      + assume Hq2lt : q2 < r2.
	        (** right endpoint q2 **)
	        set I3 := open_interval r1 q2.
	        witness I3.
	        apply andI.
	        * (** I3 in basis **)
	          claim HI3fam : I3 :e {open_interval r1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => open_interval r1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {open_interval aa bb|bb :e rational_numbers})
	                   r1
	                   I3
	                   Hr1Q
	                   HI3fam).
	        * apply andI.
	          { (** x in I3 **)
	            claim Hr1xRlt : Rlt r1 x.
	            { exact Hr1x. }
	            claim Hxq2Rlt : Rlt x q2.
	            { exact Hxq2. }
	            exact (SepI R (fun z : set => Rlt r1 z /\ Rlt z q2) x HxR
	                         (andI (Rlt r1 x) (Rlt x q2) Hr1xRlt Hxq2Rlt)). }
	          { (** I3 subset b1  b2 **)
	            let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => Rlt r1 z /\ Rlt z q2) y HyI3). }
	            claim HyProp : Rlt r1 y /\ Rlt y q2.
	            { exact (SepE2 R (fun z : set => Rlt r1 z /\ Rlt z q2) y HyI3). }
	            claim Hr1y : Rlt r1 y.
	            { exact (andEL (Rlt r1 y) (Rlt y q2) HyProp). }
	            claim Hyq2 : Rlt y q2.
	            { exact (andER (Rlt r1 y) (Rlt y q2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hr1ylt : r1 < y.
	            { exact (RltE_lt r1 y Hr1y). }
	            claim Hyq2lt : y < q2.
	            { exact (RltE_lt y q2 Hyq2). }
	            (** y in b2 = (r1,r2) since q2<r2 **)
	            claim Hyr2lt : y < r2.
	            { exact (SNoLt_tra y q2 r2 HyS Hq2S Hr2S Hyq2lt Hq2lt). }
	            claim Hyr2 : Rlt y r2.
	            { exact (RltI y r2 HyR Hr2R Hyr2lt). }
	            claim HyIn2 : y :e open_interval r1 r2.
	            { exact (SepI R (fun z : set => Rlt r1 z /\ Rlt z r2) y HyR
	                         (andI (Rlt r1 y) (Rlt y r2) Hr1y Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            (** y in b1 = (q1,q2) since q1<r1 **)
	            claim Hq1ylt : q1 < y.
	            { exact (SNoLt_tra q1 r1 y Hq1S Hr1S HyS Hq1lt Hr1ylt). }
	            claim Hq1y : Rlt q1 y.
	            { exact (RltI q1 y Hq1R HyR Hq1ylt). }
	            claim HyIn1 : y :e open_interval q1 q2.
	            { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyR
	                         (andI (Rlt q1 y) (Rlt y q2) Hq1y Hyq2)). }
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyIn1. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hq2eq : q2 = r2.
	        set I3 := open_interval r1 q2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {open_interval r1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => open_interval r1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {open_interval aa bb|bb :e rational_numbers})
	                   r1
	                   I3
	                   Hr1Q
	                   HI3fam).
	        * apply andI.
	          { exact (SepI R (fun z : set => Rlt r1 z /\ Rlt z q2) x HxR
	                         (andI (Rlt r1 x) (Rlt x q2) Hr1x Hxq2)). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => Rlt r1 z /\ Rlt z q2) y HyI3). }
	            claim HyProp : Rlt r1 y /\ Rlt y q2.
	            { exact (SepE2 R (fun z : set => Rlt r1 z /\ Rlt z q2) y HyI3). }
	            claim Hr1y : Rlt r1 y.
	            { exact (andEL (Rlt r1 y) (Rlt y q2) HyProp). }
	            claim Hyq2 : Rlt y q2.
	            { exact (andER (Rlt r1 y) (Rlt y q2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hr1ylt : r1 < y.
	            { exact (RltE_lt r1 y Hr1y). }
	            claim Hyq2lt : y < q2.
	            { exact (RltE_lt y q2 Hyq2). }
	            (** y in b2 using r2=q2 **)
	            claim Hyr2 : Rlt y r2.
	            { rewrite <- Hq2eq. exact Hyq2. }
	            claim HyIn2 : y :e open_interval r1 r2.
	            { exact (SepI R (fun z : set => Rlt r1 z /\ Rlt z r2) y HyR
	                         (andI (Rlt r1 y) (Rlt y r2) Hr1y Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            (** y in b1 since q1<r1 **)
	            claim Hq1ylt : q1 < y.
	            { exact (SNoLt_tra q1 r1 y Hq1S Hr1S HyS Hq1lt Hr1ylt). }
	            claim Hq1y : Rlt q1 y.
	            { exact (RltI q1 y Hq1R HyR Hq1ylt). }
	            claim HyIn1 : y :e open_interval q1 q2.
	            { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyR
	                         (andI (Rlt q1 y) (Rlt y q2) Hq1y Hyq2)). }
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyIn1. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hr2lt : r2 < q2.
	        (** right endpoint r2 **)
	        set I3 := open_interval r1 r2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {open_interval r1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => open_interval r1 qq) r2 Hr2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {open_interval aa bb|bb :e rational_numbers})
	                   r1
	                   I3
	                   Hr1Q
	                   HI3fam).
	        * apply andI.
	          { exact (SepI R (fun z : set => Rlt r1 z /\ Rlt z r2) x HxR
	                         (andI (Rlt r1 x) (Rlt x r2) Hr1x Hxr2)). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => Rlt r1 z /\ Rlt z r2) y HyI3). }
	            claim HyProp : Rlt r1 y /\ Rlt y r2.
	            { exact (SepE2 R (fun z : set => Rlt r1 z /\ Rlt z r2) y HyI3). }
	            claim Hr1y : Rlt r1 y.
	            { exact (andEL (Rlt r1 y) (Rlt y r2) HyProp). }
	            claim Hyr2 : Rlt y r2.
	            { exact (andER (Rlt r1 y) (Rlt y r2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hr1ylt : r1 < y.
	            { exact (RltE_lt r1 y Hr1y). }
	            claim Hyr2lt : y < r2.
	            { exact (RltE_lt y r2 Hyr2). }
	            (** y in b1: need y<q2 since r2<q2 **)
	            claim Hyq2lt : y < q2.
	            { exact (SNoLt_tra y r2 q2 HyS Hr2S Hq2S Hyr2lt Hr2lt). }
	            claim Hyq2 : Rlt y q2.
	            { exact (RltI y q2 HyR Hq2R Hyq2lt). }
	            claim Hq1ylt : q1 < y.
	            { exact (SNoLt_tra q1 r1 y Hq1S Hr1S HyS Hq1lt Hr1ylt). }
	            claim Hq1y : Rlt q1 y.
	            { exact (RltI q1 y Hq1R HyR Hq1ylt). }
	            claim HyIn1 : y :e open_interval q1 q2.
	            { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyR
	                         (andI (Rlt q1 y) (Rlt y q2) Hq1y Hyq2)). }
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyIn1. }
	            (** y in b2 = (r1,r2) **)
	            claim HyIn2 : y :e open_interval r1 r2.
	            { exact (SepI R (fun z : set => Rlt r1 z /\ Rlt z r2) y HyR
	                         (andI (Rlt r1 y) (Rlt y r2) Hr1y Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	    - assume Hq1eq : q1 = r1.
	      (** left endpoint q1 **)
	      apply (SNoLt_trichotomy_or_impred q2 r2 Hq2S Hr2S
	               (exists b3 :e rational_open_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
	      + assume Hq2lt : q2 < r2.
	        set I3 := open_interval q1 q2.
	        witness I3.
	        apply andI.
	        * (** I3 in basis **)
	          claim HI3fam : I3 :e {open_interval q1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => open_interval q1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {open_interval aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
	        * apply andI.
	          { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z q2) x HxR HxProp1). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            (** y in b1 directly **)
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyI3. }
	            (** y in b2 since r1=q1 and q2<r2 **)
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyI3). }
	            claim HyProp : Rlt q1 y /\ Rlt y q2.
	            { exact (SepE2 R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyI3). }
	            claim Hqy : Rlt q1 y.
	            { exact (andEL (Rlt q1 y) (Rlt y q2) HyProp). }
	            claim Hyq2 : Rlt y q2.
	            { exact (andER (Rlt q1 y) (Rlt y q2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hyq2lt : y < q2.
	            { exact (RltE_lt y q2 Hyq2). }
	            claim Hyr2lt : y < r2.
	            { exact (SNoLt_tra y q2 r2 HyS Hq2S Hr2S Hyq2lt Hq2lt). }
	            claim Hyr2 : Rlt y r2.
	            { exact (RltI y r2 HyR Hr2R Hyr2lt). }
	            claim HyIn2 : y :e open_interval r1 r2.
	            { rewrite <- Hq1eq.
	              exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z r2) y HyR
	                           (andI (Rlt q1 y) (Rlt y r2) Hqy Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hq2eq : q2 = r2.
	        set I3 := open_interval q1 q2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {open_interval q1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => open_interval q1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {open_interval aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
	        * apply andI.
	          { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z q2) x HxR HxProp1). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyI3. }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. rewrite <- Hq1eq. rewrite <- Hq2eq. exact HyI3. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hr2lt : r2 < q2.
	        set I3 := open_interval q1 r2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {open_interval q1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => open_interval q1 qq) r2 Hr2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {open_interval aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
	        * apply andI.
	          { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z r2) x HxR
	                         (andI (Rlt q1 x) (Rlt x r2) Hq1x Hxr2)). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => Rlt q1 z /\ Rlt z r2) y HyI3). }
	            claim HyProp : Rlt q1 y /\ Rlt y r2.
	            { exact (SepE2 R (fun z : set => Rlt q1 z /\ Rlt z r2) y HyI3). }
	            claim Hq1y : Rlt q1 y.
	            { exact (andEL (Rlt q1 y) (Rlt y r2) HyProp). }
	            claim Hyr2 : Rlt y r2.
	            { exact (andER (Rlt q1 y) (Rlt y r2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hyr2lt : y < r2.
	            { exact (RltE_lt y r2 Hyr2). }
	            claim Hyq2lt : y < q2.
	            { exact (SNoLt_tra y r2 q2 HyS Hr2S Hq2S Hyr2lt Hr2lt). }
	            claim Hyq2 : Rlt y q2.
	            { exact (RltI y q2 HyR Hq2R Hyq2lt). }
	            claim HyIn1 : y :e open_interval q1 q2.
	            { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyR
	                         (andI (Rlt q1 y) (Rlt y q2) Hq1y Hyq2)). }
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyIn1. }
	            claim HyIn2 : y :e open_interval r1 r2.
	            { rewrite <- Hq1eq.
	              exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z r2) y HyR
	                           (andI (Rlt q1 y) (Rlt y r2) Hq1y Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	    - assume Hr1lt : r1 < q1.
	      (** left endpoint q1 **)
	      apply (SNoLt_trichotomy_or_impred q2 r2 Hq2S Hr2S
	               (exists b3 :e rational_open_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
	      + assume Hq2lt : q2 < r2.
	        set I3 := open_interval q1 q2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {open_interval q1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => open_interval q1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {open_interval aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
	        * apply andI.
	          { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z q2) x HxR HxProp1). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            (** y in b1 directly **)
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyI3. }
	            (** y in b2 since r1<q1 and q2<r2 **)
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyI3). }
	            claim HyProp : Rlt q1 y /\ Rlt y q2.
	            { exact (SepE2 R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyI3). }
	            claim Hq1y : Rlt q1 y.
	            { exact (andEL (Rlt q1 y) (Rlt y q2) HyProp). }
	            claim Hyq2 : Rlt y q2.
	            { exact (andER (Rlt q1 y) (Rlt y q2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hq1ylt : q1 < y.
	            { exact (RltE_lt q1 y Hq1y). }
	            claim Hyq2lt : y < q2.
	            { exact (RltE_lt y q2 Hyq2). }
	            claim Hr1ylt : r1 < y.
	            { exact (SNoLt_tra r1 q1 y Hr1S Hq1S HyS Hr1lt Hq1ylt). }
	            claim Hr1y : Rlt r1 y.
	            { exact (RltI r1 y Hr1R HyR Hr1ylt). }
	            claim Hyr2lt : y < r2.
	            { exact (SNoLt_tra y q2 r2 HyS Hq2S Hr2S Hyq2lt Hq2lt). }
	            claim Hyr2 : Rlt y r2.
	            { exact (RltI y r2 HyR Hr2R Hyr2lt). }
	            claim HyIn2 : y :e open_interval r1 r2.
	            { exact (SepI R (fun z : set => Rlt r1 z /\ Rlt z r2) y HyR
	                         (andI (Rlt r1 y) (Rlt y r2) Hr1y Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hq2eq : q2 = r2.
	        set I3 := open_interval q1 q2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {open_interval q1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => open_interval q1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {open_interval aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
	        * apply andI.
	          { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z q2) x HxR HxProp1). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyI3. }
	            (** y in b2 using r2=q2 and r1<q1 **)
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyI3). }
	            claim HyProp : Rlt q1 y /\ Rlt y q2.
	            { exact (SepE2 R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyI3). }
	            claim Hq1y : Rlt q1 y.
	            { exact (andEL (Rlt q1 y) (Rlt y q2) HyProp). }
	            claim Hyq2 : Rlt y q2.
	            { exact (andER (Rlt q1 y) (Rlt y q2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hq1ylt : q1 < y.
	            { exact (RltE_lt q1 y Hq1y). }
	            claim Hr1ylt : r1 < y.
	            { exact (SNoLt_tra r1 q1 y Hr1S Hq1S HyS Hr1lt Hq1ylt). }
	            claim Hr1y : Rlt r1 y.
	            { exact (RltI r1 y Hr1R HyR Hr1ylt). }
	            claim Hyr2 : Rlt y r2.
	            { rewrite <- Hq2eq. exact Hyq2. }
	            claim HyIn2 : y :e open_interval r1 r2.
	            { exact (SepI R (fun z : set => Rlt r1 z /\ Rlt z r2) y HyR
	                         (andI (Rlt r1 y) (Rlt y r2) Hr1y Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hr2lt : r2 < q2.
	        set I3 := open_interval q1 r2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {open_interval q1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => open_interval q1 qq) r2 Hr2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {open_interval aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
	        * apply andI.
	          { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z r2) x HxR
	                         (andI (Rlt q1 x) (Rlt x r2) Hq1x Hxr2)). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => Rlt q1 z /\ Rlt z r2) y HyI3). }
	            claim HyProp : Rlt q1 y /\ Rlt y r2.
	            { exact (SepE2 R (fun z : set => Rlt q1 z /\ Rlt z r2) y HyI3). }
	            claim Hq1y : Rlt q1 y.
	            { exact (andEL (Rlt q1 y) (Rlt y r2) HyProp). }
	            claim Hyr2 : Rlt y r2.
	            { exact (andER (Rlt q1 y) (Rlt y r2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hq1ylt : q1 < y.
	            { exact (RltE_lt q1 y Hq1y). }
	            claim Hyr2lt : y < r2.
	            { exact (RltE_lt y r2 Hyr2). }
	            claim Hyq2lt : y < q2.
	            { exact (SNoLt_tra y r2 q2 HyS Hr2S Hq2S Hyr2lt Hr2lt). }
	            claim Hyq2 : Rlt y q2.
	            { exact (RltI y q2 HyR Hq2R Hyq2lt). }
	            claim HyIn1 : y :e open_interval q1 q2.
	            { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyR
	                         (andI (Rlt q1 y) (Rlt y q2) Hq1y Hyq2)). }
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyIn1. }
	            (** y in b2 since r1<q1 and y<r2 **)
	            claim Hr1ylt : r1 < y.
	            { exact (SNoLt_tra r1 q1 y Hr1S Hq1S HyS Hr1lt Hq1ylt). }
		    claim Hr1y : Rlt r1 y.
		    { exact (RltI r1 y Hr1R HyR Hr1ylt). }
		    claim HyIn2 : y :e open_interval r1 r2.
		    { exact (SepI R (fun z : set => Rlt r1 z /\ Rlt z r2) y HyR
		                         (andI (Rlt r1 y) (Rlt y r2) Hr1y Hyr2)). }
		    claim Hyb2 : y :e b2.
		    { rewrite Hb2eq. exact HyIn2. }
		    exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	- (** generated_topology R rational_open_intervals_basis equals R_standard_topology **)
	  prove generated_topology R rational_open_intervals_basis = R_standard_topology.
	  (** R_standard_topology = generated_topology R R_standard_basis **)
	  apply set_ext.
	  + let U. assume HU: U :e generated_topology R rational_open_intervals_basis.
	    prove U :e R_standard_topology.
	    (** Unpack U membership in generated_topology R rational_open_intervals_basis **)
	    claim HUpow: U :e Power R.
	    { exact (SepE1 (Power R)
	             (fun U0 : set => forall x0 :e U0, exists b :e rational_open_intervals_basis, x0 :e b /\ b c= U0)
	             U
	             HU). }
	    claim HUprop: forall x0 :e U, exists b :e rational_open_intervals_basis, x0 :e b /\ b c= U.
	    { exact (SepE2 (Power R)
	             (fun U0 : set => forall x0 :e U0, exists b :e rational_open_intervals_basis, x0 :e b /\ b c= U0)
	             U
	             HU). }
	    (** Show U satisfies the standard-basis neighborhood property **)
	    prove U :e generated_topology R R_standard_basis.
	    prove U :e {U0 :e Power R | forall x0 :e U0, exists b :e R_standard_basis, x0 :e b /\ b c= U0}.
	    claim HUstdprop: forall x0 :e U, exists b :e R_standard_basis, x0 :e b /\ b c= U.
	    { let x. assume HxU: x :e U.
	      apply (HUprop x HxU).
	      let b. assume Hbpair.
	      claim HbB: b :e rational_open_intervals_basis.
	      { exact (andEL (b :e rational_open_intervals_basis) (x :e b /\ b c= U) Hbpair). }
	      claim Hbprop: x :e b /\ b c= U.
	      { exact (andER (b :e rational_open_intervals_basis) (x :e b /\ b c= U) Hbpair). }
	      claim Hxb: x :e b.
	      { exact (andEL (x :e b) (b c= U) Hbprop). }
	      claim HbsubU: b c= U.
	      { exact (andER (x :e b) (b c= U) Hbprop). }
	      claim HbStd: b :e R_standard_basis.
	      { exact (rational_open_intervals_basis_Subq_R_standard_basis b HbB). }
	      witness b.
	      apply andI.
	      - exact HbStd.
	      - apply andI.
	        + exact Hxb.
	        + exact HbsubU.
	    }
	    exact (SepI (Power R)
	            (fun U0 : set => forall x0 :e U0, exists b :e R_standard_basis, x0 :e b /\ b c= U0)
	            U
	            HUpow
	            HUstdprop).
	  + let U. assume HU: U :e R_standard_topology.
	    prove U :e generated_topology R rational_open_intervals_basis.
	    (** Unpack U membership in R_standard_topology = generated_topology R R_standard_basis **)
	    claim HUpow: U :e Power R.
	    { exact (SepE1 (Power R)
	             (fun U0 : set => forall x0 :e U0, exists b :e R_standard_basis, x0 :e b /\ b c= U0)
	             U
	             HU). }
	    claim HUprop: forall x0 :e U, exists b :e R_standard_basis, x0 :e b /\ b c= U.
	    { exact (SepE2 (Power R)
	             (fun U0 : set => forall x0 :e U0, exists b :e R_standard_basis, x0 :e b /\ b c= U0)
	             U
	             HU). }
	    claim HUsubR: U c= R.
	    { exact (PowerE R U HUpow). }
	    prove U :e {U0 :e Power R | forall x0 :e U0, exists b :e rational_open_intervals_basis, x0 :e b /\ b c= U0}.
	    apply SepI.
	    - exact HUpow.
	    - let x. assume HxU: x :e U.
	      claim HxR: x :e R.
	      { exact (HUsubR x HxU). }
	      apply (HUprop x HxU).
	      let I. assume HIpair.
	      claim HIStd: I :e R_standard_basis.
	      { exact (andEL (I :e R_standard_basis) (x :e I /\ I c= U) HIpair). }
	      claim HIprop: x :e I /\ I c= U.
	      { exact (andER (I :e R_standard_basis) (x :e I /\ I c= U) HIpair). }
	      claim HxI: x :e I.
	      { exact (andEL (x :e I) (I c= U) HIprop). }
	      claim HIsubU: I c= U.
	      { exact (andER (x :e I) (I c= U) HIprop). }
	      (** Destruct I as an open_interval a b with a,b in R **)
	      claim Hexa: exists a :e R, I :e {open_interval a b|b :e R}.
	      { exact (famunionE R (fun a0 : set => {open_interval a0 b|b :e R}) I HIStd). }
	      apply Hexa.
	      let a. assume Hapair. apply Hapair.
	      assume HaR: a :e R.
	      assume HIfam: I :e {open_interval a b|b :e R}.
	      claim Hexb: exists b :e R, I = open_interval a b.
	      { exact (ReplE R (fun b0 : set => open_interval a b0) I HIfam). }
	      apply Hexb.
	      let b. assume Hbpair. apply Hbpair.
	      assume HbR: b :e R.
	      assume HIeq: I = open_interval a b.
	      claim HxInab: x :e open_interval a b.
	      { rewrite <- HIeq. exact HxI. }
	      (** refine the real interval (a,b) to a rational interval around x **)
	      claim HexRat: exists q1 :e rational_numbers, exists q2 :e rational_numbers,
	        x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a b.
	      { exact (rational_interval_refines_real_interval a b x HaR HbR HxR HxInab). }
	      apply HexRat.
	      let q1. assume Hq1pair. apply Hq1pair.
	      assume Hq1Q: q1 :e rational_numbers.
	      assume Hexq2: exists q2 :e rational_numbers,
	        x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a b.
	      apply Hexq2.
	      let q2. assume Hq2pair. apply Hq2pair.
	      assume Hq2Q: q2 :e rational_numbers.
	      assume HxInQ: x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a b.
	      claim HxInQint: x :e open_interval q1 q2.
	      { exact (andEL (x :e open_interval q1 q2) (open_interval q1 q2 c= open_interval a b) HxInQ). }
	      claim HQsub: open_interval q1 q2 c= open_interval a b.
	      { exact (andER (x :e open_interval q1 q2) (open_interval q1 q2 c= open_interval a b) HxInQ). }
	      claim HabsubU: open_interval a b c= U.
	      { rewrite <- HIeq.
	        exact HIsubU. }
	      claim HQsubU: open_interval q1 q2 c= U.
	      { exact (Subq_tra (open_interval q1 q2) (open_interval a b) U HQsub HabsubU). }
	      (** show open_interval q1 q2 is in rational_open_intervals_basis **)
	      claim Hq2fam : open_interval q1 q2 :e {open_interval q1 q2'|q2' :e rational_numbers}.
	      { exact (ReplI rational_numbers (fun q2' : set => open_interval q1 q2') q2 Hq2Q). }
	      claim HbInB: open_interval q1 q2 :e rational_open_intervals_basis.
	      { exact (famunionI rational_numbers
	               (fun q1' : set => {open_interval q1' q2'|q2' :e rational_numbers})
	               q1
	               (open_interval q1 q2)
	               Hq1Q
	               Hq2fam). }
	      witness (open_interval q1 q2).
	      apply andI.
	      * exact HbInB.
	      * apply andI.
	        { exact HxInQint. }
	        { exact HQsubU. }
Qed.

(** from 13 Exercise 8(b): half-open rational intervals generate a different topology **) 
(** LATEX VERSION: Exercise 8(b): Half-open rational intervals form a basis whose generated topology differs from the lower limit topology. **)
Definition rational_halfopen_intervals_basis : set :=
  \/_ q1 :e rational_numbers, {halfopen_interval_left q1 q2|q2 :e rational_numbers}.

(** LATEX VERSION: The half-open rational basis generates a topology distinct from the lower limit topology. **)
Theorem ex13_8b_halfopen_rational_basis_topology :
  basis_on R rational_halfopen_intervals_basis /\
  generated_topology R rational_halfopen_intervals_basis <> R_lower_limit_topology.
prove basis_on R rational_halfopen_intervals_basis /\ generated_topology R rational_halfopen_intervals_basis <> R_lower_limit_topology.
(** NOTE: This needs density of rationals plus a separation argument showing the generated topology from halfopen rational intervals differs from the lower limit topology; as in (a), use `real_E` and `Subq_SNoS_omega_rational` once order and epsilon inequalities are available. **)
apply andI.
- (** rational half-open intervals satisfy basis_on R (partial: subset property) **)
  prove rational_halfopen_intervals_basis c= Power R
    /\ (forall x :e R, exists b :e rational_halfopen_intervals_basis, x :e b)
    /\ (forall b1 :e rational_halfopen_intervals_basis, forall b2 :e rational_halfopen_intervals_basis, forall x:set,
          x :e b1 -> x :e b2 ->
          exists b3 :e rational_halfopen_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2).
  apply andI.
  - prove rational_halfopen_intervals_basis c= Power R /\ (forall x :e R, exists b :e rational_halfopen_intervals_basis, x :e b).
    apply andI.
	    + (** every rational half-open interval is a subset of R **)
	      prove rational_halfopen_intervals_basis c= Power R.
      let b. assume Hb: b :e rational_halfopen_intervals_basis.
      prove b :e Power R.
      apply (famunionE_impred rational_numbers
               (fun q1 : set => {halfopen_interval_left q1 q2|q2 :e rational_numbers})
               b
               Hb
               (b :e Power R)).
      let q1. assume Hq1 Hbq1.
      apply (ReplE_impred rational_numbers
               (fun q2 : set => halfopen_interval_left q1 q2)
               b
               Hbq1
               (b :e Power R)).
      let q2. assume Hq2 Heq.
	      rewrite Heq.
	      exact (PowerI R (halfopen_interval_left q1 q2) (halfopen_interval_left_Subq_R q1 q2)).
	    + (** coverage of R by rational half-open intervals **)
	      prove forall x :e R, exists b :e rational_halfopen_intervals_basis, x :e b.
	      let x. assume HxR.
	      set a0 := add_SNo x (minus_SNo 1).
	      set b0 := add_SNo x 1.
	      claim Hm1R : minus_SNo 1 :e R.
	      { exact (real_minus_SNo 1 real_1). }
	      claim Ha0R : a0 :e R.
	      { exact (real_add_SNo x HxR (minus_SNo 1) Hm1R). }
	      claim Hb0R : b0 :e R.
	      { exact (real_add_SNo x HxR 1 real_1). }
	      claim HxInab : x :e open_interval a0 b0.
	      { exact (real_in_open_interval_minus1_plus1 x HxR). }
	      claim HexRat: exists q1 :e rational_numbers, exists q2 :e rational_numbers,
	        x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a0 b0.
	      { exact (rational_interval_refines_real_interval a0 b0 x Ha0R Hb0R HxR HxInab). }
	      apply HexRat.
	      let q1. assume Hq1pair. apply Hq1pair.
	      assume Hq1Q: q1 :e rational_numbers.
	      assume Hexq2: exists q2 :e rational_numbers,
	        x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a0 b0.
	      apply Hexq2.
	      let q2. assume Hq2pair. apply Hq2pair.
	      assume Hq2Q: q2 :e rational_numbers.
	      assume Hxpair: x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a0 b0.
	      claim HxInQ : x :e open_interval q1 q2.
	      { exact (andEL (x :e open_interval q1 q2) (open_interval q1 q2 c= open_interval a0 b0) Hxpair). }
	      claim HxInQprop : Rlt q1 x /\ Rlt x q2.
	      { exact (SepE2 R (fun z : set => Rlt q1 z /\ Rlt z q2) x HxInQ). }
	      claim Hq1x : Rlt q1 x.
	      { exact (andEL (Rlt q1 x) (Rlt x q2) HxInQprop). }
	      claim Hxq2 : Rlt x q2.
	      { exact (andER (Rlt q1 x) (Rlt x q2) HxInQprop). }
	      set I := halfopen_interval_left q1 q2.
	      claim HIinFam : I :e {halfopen_interval_left q1 qq|qq :e rational_numbers}.
	      { exact (ReplI rational_numbers (fun qq : set => halfopen_interval_left q1 qq) q2 Hq2Q). }
	      claim HIinB : I :e rational_halfopen_intervals_basis.
	      { exact (famunionI rational_numbers
	               (fun aa : set => {halfopen_interval_left aa bb|bb :e rational_numbers})
	               q1
	               I
	               Hq1Q
	               HIinFam). }
	      claim Hnxq1 : ~(Rlt x q1).
	      { assume Hxq1 : Rlt x q1.
	        claim HxS : SNo x.
	        { exact (real_SNo x HxR). }
	        claim Hq1R : q1 :e R.
	        { exact (rational_numbers_in_R q1 Hq1Q). }
	        claim Hq1S : SNo q1.
	        { exact (real_SNo q1 Hq1R). }
	        claim Hxq1lt : x < q1.
	        { exact (RltE_lt x q1 Hxq1). }
	        claim Hq1xlt : q1 < x.
	        { exact (RltE_lt q1 x Hq1x). }
	        claim Hxxlt : x < x.
	        { exact (SNoLt_tra x q1 x HxS Hq1S HxS Hxq1lt Hq1xlt). }
	        exact ((SNoLt_irref x) Hxxlt). }
	      claim HxInI : x :e I.
	      { claim Hconj : ~(Rlt x q1) /\ Rlt x q2.
	        { apply andI.
	          - exact Hnxq1.
	          - exact Hxq2. }
	        exact (SepI R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) x HxR Hconj). }
	      witness I.
	      apply andI.
	      * exact HIinB.
	      * exact HxInI.
		  - (** intersection refinement using rational endpoints **)
		    let b1. assume Hb1.
		    let b2. assume Hb2.
		    let x. assume Hx1 Hx2.
	    prove exists b3 :e rational_halfopen_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2.
	    (** destruct b1 = halfopen_interval_left q1 q2 with q1,q2 rationals **)
	    claim Hexq1 : exists q1 :e rational_numbers, b1 :e {halfopen_interval_left q1 q2|q2 :e rational_numbers}.
	    { exact (famunionE rational_numbers (fun q1 : set => {halfopen_interval_left q1 q2|q2 :e rational_numbers}) b1 Hb1). }
	    apply Hexq1.
	    let q1. assume Hq1pair. apply Hq1pair.
	    assume Hq1Q : q1 :e rational_numbers.
	    assume Hb1fam : b1 :e {halfopen_interval_left q1 q2|q2 :e rational_numbers}.
	    claim Hexq2 : exists q2 :e rational_numbers, b1 = halfopen_interval_left q1 q2.
	    { exact (ReplE rational_numbers (fun q2 : set => halfopen_interval_left q1 q2) b1 Hb1fam). }
	    apply Hexq2.
	    let q2. assume Hq2pair. apply Hq2pair.
	    assume Hq2Q : q2 :e rational_numbers.
	    assume Hb1eq : b1 = halfopen_interval_left q1 q2.
	    (** destruct b2 = halfopen_interval_left r1 r2 with r1,r2 rationals **)
	    claim Hexr1 : exists r1 :e rational_numbers, b2 :e {halfopen_interval_left r1 r2|r2 :e rational_numbers}.
	    { exact (famunionE rational_numbers (fun r1 : set => {halfopen_interval_left r1 r2|r2 :e rational_numbers}) b2 Hb2). }
	    apply Hexr1.
	    let r1. assume Hr1pair. apply Hr1pair.
	    assume Hr1Q : r1 :e rational_numbers.
	    assume Hb2fam : b2 :e {halfopen_interval_left r1 r2|r2 :e rational_numbers}.
	    claim Hexr2 : exists r2 :e rational_numbers, b2 = halfopen_interval_left r1 r2.
	    { exact (ReplE rational_numbers (fun r2 : set => halfopen_interval_left r1 r2) b2 Hb2fam). }
	    apply Hexr2.
	    let r2. assume Hr2pair. apply Hr2pair.
	    assume Hr2Q : r2 :e rational_numbers.
	    assume Hb2eq : b2 = halfopen_interval_left r1 r2.
	    (** x in the two half-open intervals **)
	    claim HxIn1 : x :e halfopen_interval_left q1 q2.
	    { rewrite <- Hb1eq. exact Hx1. }
	    claim HxIn2 : x :e halfopen_interval_left r1 r2.
	    { rewrite <- Hb2eq. exact Hx2. }
	    claim HxR : x :e R.
	    { exact (SepE1 R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) x HxIn1). }
	    claim HxProp1 : ~(Rlt x q1) /\ Rlt x q2.
	    { exact (SepE2 R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) x HxIn1). }
	    claim HxProp2 : ~(Rlt x r1) /\ Rlt x r2.
	    { exact (SepE2 R (fun z : set => ~(Rlt z r1) /\ Rlt z r2) x HxIn2). }
	    claim Hnxq1 : ~(Rlt x q1).
	    { exact (andEL (~(Rlt x q1)) (Rlt x q2) HxProp1). }
	    claim Hxq2 : Rlt x q2.
	    { exact (andER (~(Rlt x q1)) (Rlt x q2) HxProp1). }
	    claim Hnxr1 : ~(Rlt x r1).
	    { exact (andEL (~(Rlt x r1)) (Rlt x r2) HxProp2). }
	    claim Hxr2 : Rlt x r2.
	    { exact (andER (~(Rlt x r1)) (Rlt x r2) HxProp2). }
	    (** endpoint types **)
	    claim Hq1R : q1 :e R.
	    { exact (rational_numbers_in_R q1 Hq1Q). }
	    claim Hq2R : q2 :e R.
	    { exact (rational_numbers_in_R q2 Hq2Q). }
	    claim Hr1R : r1 :e R.
	    { exact (rational_numbers_in_R r1 Hr1Q). }
	    claim Hr2R : r2 :e R.
	    { exact (rational_numbers_in_R r2 Hr2Q). }
	    claim Hq1S : SNo q1.
	    { exact (real_SNo q1 Hq1R). }
	    claim Hq2S : SNo q2.
	    { exact (real_SNo q2 Hq2R). }
	    claim Hr1S : SNo r1.
	    { exact (real_SNo r1 Hr1R). }
	    claim Hr2S : SNo r2.
	    { exact (real_SNo r2 Hr2R). }
	    claim HxS : SNo x.
	    { exact (real_SNo x HxR). }
	    claim Hxq2lt : x < q2.
	    { exact (RltE_lt x q2 Hxq2). }
	    claim Hxr2lt : x < r2.
	    { exact (RltE_lt x r2 Hxr2). }
	    (** choose max left endpoint and min right endpoint by trichotomy **)
	    apply (SNoLt_trichotomy_or_impred q1 r1 Hq1S Hr1S
	             (exists b3 :e rational_halfopen_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
	    - assume Hq1lt : q1 < r1.
	      (** left endpoint r1 **)
	      apply (SNoLt_trichotomy_or_impred q2 r2 Hq2S Hr2S
	               (exists b3 :e rational_halfopen_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
	      + assume Hq2lt : q2 < r2.
	        (** right endpoint q2 **)
	        set I3 := halfopen_interval_left r1 q2.
	        witness I3.
	        apply andI.
	        * (** I3 in basis **)
	          claim HI3fam : I3 :e {halfopen_interval_left r1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => halfopen_interval_left r1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {halfopen_interval_left aa bb|bb :e rational_numbers})
	                   r1
	                   I3
	                   Hr1Q
	                   HI3fam).
	        * apply andI.
	          { (** x in I3 **)
	            claim Hconj : ~(Rlt x r1) /\ Rlt x q2.
	            { apply andI.
	              - exact Hnxr1.
	              - exact Hxq2. }
	            exact (SepI R (fun z : set => ~(Rlt z r1) /\ Rlt z q2) x HxR Hconj). }
	          { (** I3 subset b1  b2 **)
	            let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => ~(Rlt z r1) /\ Rlt z q2) y HyI3). }
	            claim HyProp : ~(Rlt y r1) /\ Rlt y q2.
	            { exact (SepE2 R (fun z : set => ~(Rlt z r1) /\ Rlt z q2) y HyI3). }
	            claim Hnyr1 : ~(Rlt y r1).
	            { exact (andEL (~(Rlt y r1)) (Rlt y q2) HyProp). }
	            claim Hyq2 : Rlt y q2.
	            { exact (andER (~(Rlt y r1)) (Rlt y q2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hyq2lt : y < q2.
	            { exact (RltE_lt y q2 Hyq2). }
	            (** y in b2: y < r2 since y<q2 and q2<r2 **)
	            claim Hyr2lt : y < r2.
	            { exact (SNoLt_tra y q2 r2 HyS Hq2S Hr2S Hyq2lt Hq2lt). }
	            claim Hyr2 : Rlt y r2.
	            { exact (RltI y r2 HyR Hr2R Hyr2lt). }
	            claim HyIn2 : y :e halfopen_interval_left r1 r2.
	            { exact (SepI R (fun z : set => ~(Rlt z r1) /\ Rlt z r2) y HyR
	                         (andI (~(Rlt y r1)) (Rlt y r2) Hnyr1 Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            (** y in b1: need ~(Rlt y q1) and Rlt y q2 (already) **)
	            claim Hnyq1 : ~(Rlt y q1).
	            { assume Hyq1 : Rlt y q1.
	              claim Hyq1lt : y < q1.
	              { exact (RltE_lt y q1 Hyq1). }
	              claim Hyr1lt : y < r1.
	              { exact (SNoLt_tra y q1 r1 HyS Hq1S Hr1S Hyq1lt Hq1lt). }
	              claim Hyr1 : Rlt y r1.
	              { exact (RltI y r1 HyR Hr1R Hyr1lt). }
	              exact (Hnyr1 Hyr1). }
	            claim HyIn1 : y :e halfopen_interval_left q1 q2.
	            { exact (SepI R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyR
	                         (andI (~(Rlt y q1)) (Rlt y q2) Hnyq1 Hyq2)). }
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyIn1. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hq2eq : q2 = r2.
	        set I3 := halfopen_interval_left r1 q2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {halfopen_interval_left r1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => halfopen_interval_left r1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {halfopen_interval_left aa bb|bb :e rational_numbers})
	                   r1
	                   I3
	                   Hr1Q
	                   HI3fam).
	        * apply andI.
	          { exact (SepI R (fun z : set => ~(Rlt z r1) /\ Rlt z q2) x HxR
	                         (andI (~(Rlt x r1)) (Rlt x q2) Hnxr1 Hxq2)). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => ~(Rlt z r1) /\ Rlt z q2) y HyI3). }
	            claim HyProp : ~(Rlt y r1) /\ Rlt y q2.
	            { exact (SepE2 R (fun z : set => ~(Rlt z r1) /\ Rlt z q2) y HyI3). }
	            claim Hnyr1 : ~(Rlt y r1).
	            { exact (andEL (~(Rlt y r1)) (Rlt y q2) HyProp). }
	            claim Hyq2 : Rlt y q2.
	            { exact (andER (~(Rlt y r1)) (Rlt y q2) HyProp). }
	            claim Hyr2 : Rlt y r2.
	            { rewrite <- Hq2eq. exact Hyq2. }
	            claim HyIn2 : y :e halfopen_interval_left r1 r2.
	            { exact (SepI R (fun z : set => ~(Rlt z r1) /\ Rlt z r2) y HyR
	                         (andI (~(Rlt y r1)) (Rlt y r2) Hnyr1 Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            claim Hnyq1 : ~(Rlt y q1).
	            { assume Hyq1 : Rlt y q1.
	              claim HyS : SNo y.
	              { exact (real_SNo y HyR). }
	              claim Hyq1lt : y < q1.
	              { exact (RltE_lt y q1 Hyq1). }
	              claim Hyr1lt : y < r1.
	              { exact (SNoLt_tra y q1 r1 HyS Hq1S Hr1S Hyq1lt Hq1lt). }
	              claim Hyr1 : Rlt y r1.
	              { exact (RltI y r1 HyR Hr1R Hyr1lt). }
	              exact (Hnyr1 Hyr1). }
	            claim HyIn1 : y :e halfopen_interval_left q1 q2.
	            { exact (SepI R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyR
	                         (andI (~(Rlt y q1)) (Rlt y q2) Hnyq1 Hyq2)). }
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyIn1. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hr2lt : r2 < q2.
	        (** right endpoint r2 **)
	        set I3 := halfopen_interval_left r1 r2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {halfopen_interval_left r1 rr|rr :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun rr : set => halfopen_interval_left r1 rr) r2 Hr2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {halfopen_interval_left aa bb|bb :e rational_numbers})
	                   r1
	                   I3
	                   Hr1Q
	                   HI3fam).
	        * apply andI.
	          { (** x in I3 **)
	            claim Hconj : ~(Rlt x r1) /\ Rlt x r2.
	            { apply andI.
	              - exact Hnxr1.
	              - exact Hxr2. }
	            exact (SepI R (fun z : set => ~(Rlt z r1) /\ Rlt z r2) x HxR Hconj). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => ~(Rlt z r1) /\ Rlt z r2) y HyI3). }
	            claim HyProp : ~(Rlt y r1) /\ Rlt y r2.
	            { exact (SepE2 R (fun z : set => ~(Rlt z r1) /\ Rlt z r2) y HyI3). }
	            claim Hnyr1 : ~(Rlt y r1).
	            { exact (andEL (~(Rlt y r1)) (Rlt y r2) HyProp). }
	            claim Hyr2 : Rlt y r2.
	            { exact (andER (~(Rlt y r1)) (Rlt y r2) HyProp). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyI3. }
	            (** y in b1: need Rlt y q2 since r2<q2 **)
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hyr2lt : y < r2.
	            { exact (RltE_lt y r2 Hyr2). }
	            claim Hyq2lt : y < q2.
	            { exact (SNoLt_tra y r2 q2 HyS Hr2S Hq2S Hyr2lt Hr2lt). }
	            claim Hyq2 : Rlt y q2.
	            { exact (RltI y q2 HyR Hq2R Hyq2lt). }
	            claim Hnyq1 : ~(Rlt y q1).
	            { assume Hyq1 : Rlt y q1.
	              claim Hyq1lt : y < q1.
	              { exact (RltE_lt y q1 Hyq1). }
	              claim Hyr1lt : y < r1.
	              { exact (SNoLt_tra y q1 r1 HyS Hq1S Hr1S Hyq1lt Hq1lt). }
	              claim Hyr1 : Rlt y r1.
	              { exact (RltI y r1 HyR Hr1R Hyr1lt). }
	              exact (Hnyr1 Hyr1). }
	            claim HyIn1 : y :e halfopen_interval_left q1 q2.
	            { exact (SepI R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyR
	                         (andI (~(Rlt y q1)) (Rlt y q2) Hnyq1 Hyq2)). }
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyIn1. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	    - assume Hq1eq : q1 = r1.
	      (** left endpoint q1 **)
	      apply (SNoLt_trichotomy_or_impred q2 r2 Hq2S Hr2S
	               (exists b3 :e rational_halfopen_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
	      + assume Hq2lt : q2 < r2.
	        set I3 := halfopen_interval_left q1 q2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {halfopen_interval_left q1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => halfopen_interval_left q1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {halfopen_interval_left aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
		        * apply andI.
		          { exact HxIn1. }
		          { let y. assume HyI3 : y :e I3.
		            prove y :e b1 :/\: b2.
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyI3. }
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyI3). }
	            claim HyProp : ~(Rlt y q1) /\ Rlt y q2.
	            { exact (SepE2 R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyI3). }
	            claim Hnyq1 : ~(Rlt y q1).
	            { exact (andEL (~(Rlt y q1)) (Rlt y q2) HyProp). }
	            claim Hyq2 : Rlt y q2.
	            { exact (andER (~(Rlt y q1)) (Rlt y q2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hyq2lt : y < q2.
	            { exact (RltE_lt y q2 Hyq2). }
	            claim Hyr2lt : y < r2.
	            { exact (SNoLt_tra y q2 r2 HyS Hq2S Hr2S Hyq2lt Hq2lt). }
	            claim Hyr2 : Rlt y r2.
	            { exact (RltI y r2 HyR Hr2R Hyr2lt). }
	            claim HyIn2 : y :e halfopen_interval_left r1 r2.
	            { rewrite <- Hq1eq at 1.
	              exact (SepI R (fun z : set => ~(Rlt z q1) /\ Rlt z r2) y HyR
	                           (andI (~(Rlt y q1)) (Rlt y r2) Hnyq1 Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hq2eq : q2 = r2.
	        set I3 := halfopen_interval_left q1 q2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {halfopen_interval_left q1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => halfopen_interval_left q1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {halfopen_interval_left aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
		        * apply andI.
		          { exact HxIn1. }
		          { let y. assume HyI3 : y :e I3.
		            prove y :e b1 :/\: b2.
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyI3. }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. rewrite <- Hq1eq. rewrite <- Hq2eq. exact HyI3. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hr2lt : r2 < q2.
	        set I3 := halfopen_interval_left q1 r2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {halfopen_interval_left q1 rr|rr :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun rr : set => halfopen_interval_left q1 rr) r2 Hr2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {halfopen_interval_left aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
		        * apply andI.
		          { claim Hconj : ~(Rlt x q1) /\ Rlt x r2.
		            { apply andI.
		              - exact Hnxq1.
		              - exact Hxr2. }
		            exact (SepI R (fun z : set => ~(Rlt z q1) /\ Rlt z r2) x HxR Hconj). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => ~(Rlt z q1) /\ Rlt z r2) y HyI3). }
	            claim HyProp : ~(Rlt y q1) /\ Rlt y r2.
	            { exact (SepE2 R (fun z : set => ~(Rlt z q1) /\ Rlt z r2) y HyI3). }
	            claim Hnyq1 : ~(Rlt y q1).
	            { exact (andEL (~(Rlt y q1)) (Rlt y r2) HyProp). }
	            claim Hyr2 : Rlt y r2.
	            { exact (andER (~(Rlt y q1)) (Rlt y r2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hyr2lt : y < r2.
	            { exact (RltE_lt y r2 Hyr2). }
	            claim Hyq2lt : y < q2.
	            { exact (SNoLt_tra y r2 q2 HyS Hr2S Hq2S Hyr2lt Hr2lt). }
	            claim Hyq2 : Rlt y q2.
	            { exact (RltI y q2 HyR Hq2R Hyq2lt). }
	            claim HyIn1 : y :e halfopen_interval_left q1 q2.
	            { exact (SepI R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyR
	                         (andI (~(Rlt y q1)) (Rlt y q2) Hnyq1 Hyq2)). }
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyIn1. }
	            claim HyIn2 : y :e halfopen_interval_left r1 r2.
	            { rewrite <- Hq1eq at 1.
	              exact (SepI R (fun z : set => ~(Rlt z q1) /\ Rlt z r2) y HyR
	                           (andI (~(Rlt y q1)) (Rlt y r2) Hnyq1 Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	    - assume Hr1lt : r1 < q1.
	      (** left endpoint q1 **)
	      apply (SNoLt_trichotomy_or_impred q2 r2 Hq2S Hr2S
	               (exists b3 :e rational_halfopen_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
	      + assume Hq2lt : q2 < r2.
	        set I3 := halfopen_interval_left q1 q2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {halfopen_interval_left q1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => halfopen_interval_left q1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {halfopen_interval_left aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
	        * apply andI.
	          { exact HxIn1. }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyI3. }
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyI3). }
	            claim HyProp : ~(Rlt y q1) /\ Rlt y q2.
	            { exact (SepE2 R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyI3). }
	            claim Hnyq1 : ~(Rlt y q1).
	            { exact (andEL (~(Rlt y q1)) (Rlt y q2) HyProp). }
	            claim Hyq2 : Rlt y q2.
	            { exact (andER (~(Rlt y q1)) (Rlt y q2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hyq2lt : y < q2.
	            { exact (RltE_lt y q2 Hyq2). }
	            claim Hyr2lt : y < r2.
	            { exact (SNoLt_tra y q2 r2 HyS Hq2S Hr2S Hyq2lt Hq2lt). }
	            claim Hyr2 : Rlt y r2.
	            { exact (RltI y r2 HyR Hr2R Hyr2lt). }
	            claim Hnyr1 : ~(Rlt y r1).
	            { assume Hyr1 : Rlt y r1.
	              claim Hyr1lt : y < r1.
	              { exact (RltE_lt y r1 Hyr1). }
	              claim Hyq1lt : y < q1.
	              { exact (SNoLt_tra y r1 q1 HyS Hr1S Hq1S Hyr1lt Hr1lt). }
	              claim Hyq1 : Rlt y q1.
	              { exact (RltI y q1 HyR Hq1R Hyq1lt). }
	              exact (Hnyq1 Hyq1). }
	            claim HyIn2 : y :e halfopen_interval_left r1 r2.
	            { exact (SepI R (fun z : set => ~(Rlt z r1) /\ Rlt z r2) y HyR
	                         (andI (~(Rlt y r1)) (Rlt y r2) Hnyr1 Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hq2eq : q2 = r2.
	        set I3 := halfopen_interval_left q1 q2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {halfopen_interval_left q1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => halfopen_interval_left q1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {halfopen_interval_left aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
	        * apply andI.
	          { exact HxIn1. }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyI3. }
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyI3). }
	            claim HyProp : ~(Rlt y q1) /\ Rlt y q2.
	            { exact (SepE2 R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyI3). }
	            claim Hnyq1 : ~(Rlt y q1).
	            { exact (andEL (~(Rlt y q1)) (Rlt y q2) HyProp). }
	            claim Hyq2 : Rlt y q2.
	            { exact (andER (~(Rlt y q1)) (Rlt y q2) HyProp). }
	            claim Hyr2 : Rlt y r2.
	            { rewrite <- Hq2eq. exact Hyq2. }
	            claim Hnyr1 : ~(Rlt y r1).
	            { assume Hyr1 : Rlt y r1.
	              claim HyS : SNo y.
	              { exact (real_SNo y HyR). }
	              claim Hyr1lt : y < r1.
	              { exact (RltE_lt y r1 Hyr1). }
	              claim Hyq1lt : y < q1.
	              { exact (SNoLt_tra y r1 q1 HyS Hr1S Hq1S Hyr1lt Hr1lt). }
	              claim Hyq1 : Rlt y q1.
	              { exact (RltI y q1 HyR Hq1R Hyq1lt). }
	              exact (Hnyq1 Hyq1). }
	            claim HyIn2 : y :e halfopen_interval_left r1 r2.
	            { exact (SepI R (fun z : set => ~(Rlt z r1) /\ Rlt z r2) y HyR
	                         (andI (~(Rlt y r1)) (Rlt y r2) Hnyr1 Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hr2lt : r2 < q2.
	        set I3 := halfopen_interval_left q1 r2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {halfopen_interval_left q1 rr|rr :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun rr : set => halfopen_interval_left q1 rr) r2 Hr2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {halfopen_interval_left aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
	        * apply andI.
	          { claim Hconj : ~(Rlt x q1) /\ Rlt x r2.
	            { apply andI.
	              - exact Hnxq1.
	              - exact Hxr2. }
	            exact (SepI R (fun z : set => ~(Rlt z q1) /\ Rlt z r2) x HxR Hconj). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => ~(Rlt z q1) /\ Rlt z r2) y HyI3). }
	            claim HyProp : ~(Rlt y q1) /\ Rlt y r2.
	            { exact (SepE2 R (fun z : set => ~(Rlt z q1) /\ Rlt z r2) y HyI3). }
	            claim Hnyq1 : ~(Rlt y q1).
	            { exact (andEL (~(Rlt y q1)) (Rlt y r2) HyProp). }
	            claim Hyr2 : Rlt y r2.
	            { exact (andER (~(Rlt y q1)) (Rlt y r2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hyr2lt : y < r2.
	            { exact (RltE_lt y r2 Hyr2). }
	            claim Hyq2lt : y < q2.
	            { exact (SNoLt_tra y r2 q2 HyS Hr2S Hq2S Hyr2lt Hr2lt). }
	            claim Hyq2 : Rlt y q2.
	            { exact (RltI y q2 HyR Hq2R Hyq2lt). }
	            claim HyIn1 : y :e halfopen_interval_left q1 q2.
	            { exact (SepI R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyR
	                         (andI (~(Rlt y q1)) (Rlt y q2) Hnyq1 Hyq2)). }
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyIn1. }
	            claim Hnyr1 : ~(Rlt y r1).
	            { assume Hyr1 : Rlt y r1.
	              claim Hyr1lt : y < r1.
	              { exact (RltE_lt y r1 Hyr1). }
	              claim Hyq1lt : y < q1.
	              { exact (SNoLt_tra y r1 q1 HyS Hr1S Hq1S Hyr1lt Hr1lt). }
	              claim Hyq1 : Rlt y q1.
	              { exact (RltI y q1 HyR Hq1R Hyq1lt). }
	              exact (Hnyq1 Hyq1). }
	            claim HyIn2 : y :e halfopen_interval_left r1 r2.
	            { exact (SepI R (fun z : set => ~(Rlt z r1) /\ Rlt z r2) y HyR
	                         (andI (~(Rlt y r1)) (Rlt y r2) Hnyr1 Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	- (** generated topology differs from R_lower_limit_topology **)
	  assume Heq: generated_topology R rational_halfopen_intervals_basis = R_lower_limit_topology.
	  set a := sqrt_SNo_nonneg 2.
	  set U := {x :e R | ~(Rlt x a)}.
	  claim HaDiff: a :e R :\: rational_numbers.
	  { exact sqrt_2_irrational. }
	  claim HaR: a :e R.
	  { exact (setminusE1 R rational_numbers a HaDiff). }
	  claim HaNotQ: a /:e rational_numbers.
	  { exact (setminusE2 R rational_numbers a HaDiff). }
	  (** U is open in the lower limit topology **)
	  claim HUinLower: U :e R_lower_limit_topology.
	  { prove U :e R_lower_limit_topology.
	    prove U :e generated_topology R R_lower_limit_basis.
	    prove U :e {U0 :e Power R | forall x0 :e U0, exists b0 :e R_lower_limit_basis, x0 :e b0 /\ b0 c= U0}.
	    claim HUsub: U c= R.
	    { let y. assume HyU.
	      exact (SepE1 R (fun z : set => ~(Rlt z a)) y HyU). }
	    claim HUpow: U :e Power R.
	    { exact (PowerI R U HUsub). }
	    claim HUprop: forall x0 :e U, exists b0 :e R_lower_limit_basis, x0 :e b0 /\ b0 c= U.
	    { let x0. assume Hx0U.
	      claim Hx0R: x0 :e R.
	      { exact (SepE1 R (fun z : set => ~(Rlt z a)) x0 Hx0U). }
	      claim Hnx0a: ~(Rlt x0 a).
	      { exact (SepE2 R (fun z : set => ~(Rlt z a)) x0 Hx0U). }
	      set b0 := add_SNo x0 1.
	      claim Hb0R: b0 :e R.
	      { exact (real_add_SNo x0 Hx0R 1 real_1). }
	      set I0 := halfopen_interval_left a b0.
	      claim HI0fam: I0 :e {halfopen_interval_left a bb|bb :e R}.
	      { exact (ReplI R (fun bb : set => halfopen_interval_left a bb) b0 Hb0R). }
	      claim HI0inB: I0 :e R_lower_limit_basis.
	      { exact (famunionI R (fun aa : set => {halfopen_interval_left aa bb|bb :e R}) a I0 HaR HI0fam). }
	      claim Hx0InStd: x0 :e open_interval (add_SNo x0 (minus_SNo 1)) b0.
	      { exact (real_in_open_interval_minus1_plus1 x0 Hx0R). }
	      claim Hx0StdProp: Rlt (add_SNo x0 (minus_SNo 1)) x0 /\ Rlt x0 b0.
	      { exact (SepE2 R (fun z : set => Rlt (add_SNo x0 (minus_SNo 1)) z /\ Rlt z b0) x0 Hx0InStd). }
	      claim Hx0b0: Rlt x0 b0.
	      { exact (andER (Rlt (add_SNo x0 (minus_SNo 1)) x0) (Rlt x0 b0) Hx0StdProp). }
	      claim Hx0InI0: x0 :e I0.
	      { claim Hconj: ~(Rlt x0 a) /\ Rlt x0 b0.
	        { apply andI.
	          - exact Hnx0a.
	          - exact Hx0b0. }
	        exact (SepI R (fun z : set => ~(Rlt z a) /\ Rlt z b0) x0 Hx0R Hconj). }
	      claim HI0subU: I0 c= U.
	      { let y. assume HyI0.
	        claim HyR: y :e R.
	        { exact (SepE1 R (fun z : set => ~(Rlt z a) /\ Rlt z b0) y HyI0). }
	        claim HyProp: ~(Rlt y a) /\ Rlt y b0.
	        { exact (SepE2 R (fun z : set => ~(Rlt z a) /\ Rlt z b0) y HyI0). }
	        claim Hnya: ~(Rlt y a).
	        { exact (andEL (~(Rlt y a)) (Rlt y b0) HyProp). }
	        exact (SepI R (fun z : set => ~(Rlt z a)) y HyR Hnya). }
	      witness I0.
	      apply andI.
	      - exact HI0inB.
	      - apply andI.
	        { exact Hx0InI0. }
	        { exact HI0subU. } }
	    exact (SepI (Power R)
	              (fun U0 : set => forall x0 :e U0, exists b0 :e R_lower_limit_basis, x0 :e b0 /\ b0 c= U0)
	              U
	              HUpow
	              HUprop). }
	  (** Using the assumed equality, U would be open in the rational half-open topology **)
	  claim HUinRat: U :e generated_topology R rational_halfopen_intervals_basis.
	  { rewrite Heq. exact HUinLower. }
	  claim HUpropRat: forall x0 :e U, exists b0 :e rational_halfopen_intervals_basis, x0 :e b0 /\ b0 c= U.
	  { exact (SepE2 (Power R)
	            (fun U0 : set => forall x0 :e U0, exists b0 :e rational_halfopen_intervals_basis, x0 :e b0 /\ b0 c= U0)
	            U
	            HUinRat). }
	  (** But a has no neighborhood inside U using rational left endpoints **)
	  claim HaU: a :e U.
	  { exact (SepI R (fun z : set => ~(Rlt z a)) a HaR (not_Rlt_refl a HaR)). }
	  apply (HUpropRat a HaU).
	  let b. assume Hbpair. apply Hbpair.
	  assume HbInB: b :e rational_halfopen_intervals_basis.
	  assume Hbrest: a :e b /\ b c= U.
	  claim Hab: a :e b.
	  { exact (andEL (a :e b) (b c= U) Hbrest). }
	  claim HbsubU: b c= U.
	  { exact (andER (a :e b) (b c= U) Hbrest). }
	  (** destruct b as [q1,q2) with rationals q1,q2 **)
	  claim Hexq1: exists q1 :e rational_numbers, b :e {halfopen_interval_left q1 q2|q2 :e rational_numbers}.
	  { exact (famunionE rational_numbers (fun q1 : set => {halfopen_interval_left q1 q2|q2 :e rational_numbers}) b HbInB). }
	  apply Hexq1.
	  let q1. assume Hq1pair. apply Hq1pair.
	  assume Hq1Q: q1 :e rational_numbers.
	  assume HbFam: b :e {halfopen_interval_left q1 q2|q2 :e rational_numbers}.
	  claim Hexq2: exists q2 :e rational_numbers, b = halfopen_interval_left q1 q2.
	  { exact (ReplE rational_numbers (fun q2 : set => halfopen_interval_left q1 q2) b HbFam). }
	  apply Hexq2.
	  let q2. assume Hq2pair. apply Hq2pair.
	  assume Hq2Q: q2 :e rational_numbers.
	  assume HbEq: b = halfopen_interval_left q1 q2.
	  claim Hq1R: q1 :e R.
	  { exact (rational_numbers_in_R q1 Hq1Q). }
	  claim Hq2R: q2 :e R.
	  { exact (rational_numbers_in_R q2 Hq2Q). }
	  claim Hq1S: SNo q1.
	  { exact (real_SNo q1 Hq1R). }
	  claim Hq2S: SNo q2.
	  { exact (real_SNo q2 Hq2R). }
	  claim HaS: SNo a.
	  { exact (real_SNo a HaR). }
		  claim HaInInt: a :e halfopen_interval_left q1 q2.
		  { rewrite <- HbEq. exact Hab. }
	  claim HaIntProp: ~(Rlt a q1) /\ Rlt a q2.
	  { exact (SepE2 R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) a HaInInt). }
	  claim HnaRq1: ~(Rlt a q1).
	  { exact (andEL (~(Rlt a q1)) (Rlt a q2) HaIntProp). }
	  claim Haq2: Rlt a q2.
	  { exact (andER (~(Rlt a q1)) (Rlt a q2) HaIntProp). }
	  claim HnaLt: ~(a < q1).
	  { assume Haq1lt: a < q1.
	    claim Haq1: Rlt a q1.
	    { exact (RltI a q1 HaR Hq1R Haq1lt). }
	    exact (HnaRq1 Haq1). }
	  claim Hq1lta: q1 < a.
	  { apply (SNoLt_trichotomy_or_impred a q1 HaS Hq1S (q1 < a)).
	    - assume Haq1lt: a < q1.
	      apply FalseE.
	      exact (HnaLt Haq1lt).
		    - assume Haq1eq: a = q1.
		      claim HaQ: a :e rational_numbers.
		      { rewrite Haq1eq. exact Hq1Q. }
		      apply FalseE.
		      exact (HaNotQ HaQ).
	    - assume Hq1alt: q1 < a.
	      exact Hq1alt. }
	  claim Hq1a: Rlt q1 a.
	  { exact (RltI q1 a Hq1R HaR Hq1lta). }
	  claim Haq2lt: a < q2.
	  { exact (RltE_lt a q2 Haq2). }
	  claim Hq1q2lt: q1 < q2.
	  { exact (SNoLt_tra q1 a q2 Hq1S HaS Hq2S Hq1lta Haq2lt). }
	  claim Hq1q2: Rlt q1 q2.
	  { exact (RltI q1 q2 Hq1R Hq2R Hq1q2lt). }
	  claim Hq1Inb: q1 :e b.
	  { rewrite HbEq.
	    exact (halfopen_interval_left_leftmem q1 q2 Hq1q2). }
	  claim Hq1U: q1 :e U.
	  { exact (HbsubU q1 Hq1Inb). }
	  claim Hnq1a: ~(Rlt q1 a).
	  { exact (SepE2 R (fun z : set => ~(Rlt z a)) q1 Hq1U). }
	  exact (Hnq1a Hq1a).
	Qed.

(** from 14 Definition: basis for the order topology **) 
(** LATEX VERSION: For a simply ordered set X, the order-topology basis consists of all open intervals/rays; here represented abstractly. **)
(** FIXED: For dictionary order on R, a and b are ordered pairs (a1,a2) and (b1,b2), not cartesian products setprod a1 a2 and setprod b1 b2. **)
(** SUSPICIOUS DEFINITION: `order_rel` is implemented as a case split over a small list of carrier sets used later; this is not a general interface for simply ordered sets and may force later axioms. **)
Definition order_rel : set -> set -> set -> prop := fun X a b =>
  (X = R /\ Rlt a b)
  \/
  (X = rational_numbers /\ Rlt a b)
  \/
  (X = omega /\ a :e b)
  \/
  (X = omega :\: {0} /\ a :e b)
  \/
  (X = setprod 2 omega /\
   exists i m j n:set,
     (i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
      a = (i, m) /\ b = (j, n) /\ (i :e j \/ (i = j /\ m :e n))))
  \/
  (X = setprod R R /\
   exists a1 a2 b1 b2:set,
     a = (a1, a2) /\ b = (b1, b2) /\
     (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))).

(** helper: in the dictionary order on {0,1} we have (0,0) < (1,0) **)
Theorem order_rel_setprod_2_omega_00_10 :
  order_rel (setprod 2 omega) (0,0) (1,0).
prove order_rel (setprod 2 omega) (0,0) (1,0).
(** Unfold `order_rel` at X = setprod 2 omega and select the 5th disjunct. **)
prove (setprod 2 omega = R /\ Rlt (0,0) (1,0))
  \/
  (setprod 2 omega = rational_numbers /\ Rlt (0,0) (1,0))
  \/
  (setprod 2 omega = omega /\ (0,0) :e (1,0))
  \/
  (setprod 2 omega = omega :\: {0} /\ (0,0) :e (1,0))
  \/
  (setprod 2 omega = setprod 2 omega /\
   exists i m j n:set,
     i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
     (0,0) = (i, m) /\ (1,0) = (j, n) /\
     (i :e j \/ (i = j /\ m :e n)))
  \/
  (setprod 2 omega = setprod R R /\
   exists a1 a2 b1 b2:set,
     (0,0) = (a1, a2) /\ (1,0) = (b1, b2) /\
     (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))).
apply orIL.
apply orIR.
prove setprod 2 omega = setprod 2 omega /\
   exists i m j n:set,
     i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
     (0,0) = (i, m) /\ (1,0) = (j, n) /\
     (i :e j \/ (i = j /\ m :e n)).
apply andI.
- reflexivity.
- witness 0.
  witness 0.
  witness 1.
  witness 0.
  claim Hm0: 0 :e omega.
  { exact (nat_p_omega 0 nat_0). }
  claim Heq00: (0,0) = (0,0).
  { reflexivity. }
  claim Heq10: (1,0) = (1,0).
  { reflexivity. }
  claim H12: 0 :e 2 /\ 0 :e omega.
  { exact (andI (0 :e 2) (0 :e omega) In_0_2 Hm0). }
  claim H123: (0 :e 2 /\ 0 :e omega) /\ 1 :e 2.
  { exact (andI (0 :e 2 /\ 0 :e omega) (1 :e 2) H12 In_1_2). }
  claim H1234: ((0 :e 2 /\ 0 :e omega) /\ 1 :e 2) /\ 0 :e omega.
  { exact (andI ((0 :e 2 /\ 0 :e omega) /\ 1 :e 2) (0 :e omega) H123 Hm0). }
  claim H12345: (((0 :e 2 /\ 0 :e omega) /\ 1 :e 2) /\ 0 :e omega) /\ (0,0) = (0,0).
  { exact (andI (((0 :e 2 /\ 0 :e omega) /\ 1 :e 2) /\ 0 :e omega) ((0,0) = (0,0)) H1234 Heq00). }
  claim H123456: ((((0 :e 2 /\ 0 :e omega) /\ 1 :e 2) /\ 0 :e omega) /\ (0,0) = (0,0)) /\ (1,0) = (1,0).
  { exact (andI ((((0 :e 2 /\ 0 :e omega) /\ 1 :e 2) /\ 0 :e omega) /\ (0,0) = (0,0)) ((1,0) = (1,0)) H12345 Heq10). }
  claim Hlex: 0 :e 1 \/ (0 = 1 /\ 0 :e 0).
  { exact (orIL (0 :e 1) (0 = 1 /\ 0 :e 0) In_0_1). }
  apply andI.
  - exact H123456.
  - exact Hlex.
Qed.

(** helper: in the dictionary order on {0,1} we have (0,0) < (1,n) for any n **)
Theorem order_rel_setprod_2_omega_00_1n : forall n:set,
  n :e omega -> order_rel (setprod 2 omega) (0,0) (1,n).
let n. assume HnOmega.
prove order_rel (setprod 2 omega) (0,0) (1,n).
(** Unfold `order_rel` at X = setprod 2 omega and select the 5th disjunct. **)
prove (setprod 2 omega = R /\ Rlt (0,0) (1,n))
  \/
  (setprod 2 omega = rational_numbers /\ Rlt (0,0) (1,n))
  \/
  (setprod 2 omega = omega /\ (0,0) :e (1,n))
  \/
  (setprod 2 omega = omega :\: {0} /\ (0,0) :e (1,n))
  \/
  (setprod 2 omega = setprod 2 omega /\
   exists i m j n0:set,
     i :e 2 /\ m :e omega /\ j :e 2 /\ n0 :e omega /\
     (0,0) = (i, m) /\ (1,n) = (j, n0) /\
     (i :e j \/ (i = j /\ m :e n0)))
  \/
  (setprod 2 omega = setprod R R /\
   exists a1 a2 b1 b2:set,
     (0,0) = (a1, a2) /\ (1,n) = (b1, b2) /\
     (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))).
apply orIL.
apply orIR.
prove setprod 2 omega = setprod 2 omega /\
   exists i m j n0:set,
     i :e 2 /\ m :e omega /\ j :e 2 /\ n0 :e omega /\
     (0,0) = (i, m) /\ (1,n) = (j, n0) /\
     (i :e j \/ (i = j /\ m :e n0)).
apply andI.
- reflexivity.
- witness 0.
  witness 0.
  witness 1.
  witness n.
  claim Hm0: 0 :e omega.
  { exact (nat_p_omega 0 nat_0). }
  claim Heq00: (0,0) = (0,0).
  { reflexivity. }
  claim Heq1n: (1,n) = (1,n).
  { reflexivity. }
  claim H12: 0 :e 2 /\ 0 :e omega.
  { exact (andI (0 :e 2) (0 :e omega) In_0_2 Hm0). }
  claim H123: (0 :e 2 /\ 0 :e omega) /\ 1 :e 2.
  { exact (andI (0 :e 2 /\ 0 :e omega) (1 :e 2) H12 In_1_2). }
  claim H1234: ((0 :e 2 /\ 0 :e omega) /\ 1 :e 2) /\ n :e omega.
  { exact (andI ((0 :e 2 /\ 0 :e omega) /\ 1 :e 2) (n :e omega) H123 HnOmega). }
  claim H12345: (((0 :e 2 /\ 0 :e omega) /\ 1 :e 2) /\ n :e omega) /\ (0,0) = (0,0).
  { exact (andI (((0 :e 2 /\ 0 :e omega) /\ 1 :e 2) /\ n :e omega) ((0,0) = (0,0)) H1234 Heq00). }
  claim H123456: ((((0 :e 2 /\ 0 :e omega) /\ 1 :e 2) /\ n :e omega) /\ (0,0) = (0,0)) /\ (1,n) = (1,n).
  { exact (andI ((((0 :e 2 /\ 0 :e omega) /\ 1 :e 2) /\ n :e omega) /\ (0,0) = (0,0)) ((1,n) = (1,n)) H12345 Heq1n). }
  claim Hlex: 0 :e 1 \/ (0 = 1 /\ 0 :e n).
  { exact (orIL (0 :e 1) (0 = 1 /\ 0 :e n) In_0_1). }
  apply andI.
  - exact H123456.
  - exact Hlex.
Qed.

(** helper: in the dictionary order on {0,1} we have (0,k) < (1,n) for any k,n **)
Theorem order_rel_setprod_2_omega_0k_1n : forall k n:set,
  k :e omega -> n :e omega -> order_rel (setprod 2 omega) (0,k) (1,n).
let k n. assume HkOmega. assume HnOmega.
prove order_rel (setprod 2 omega) (0,k) (1,n).
(** Unfold `order_rel` at X = setprod 2 omega and select the 5th disjunct. **)
prove (setprod 2 omega = R /\ Rlt (0,k) (1,n))
  \/
  (setprod 2 omega = rational_numbers /\ Rlt (0,k) (1,n))
  \/
  (setprod 2 omega = omega /\ (0,k) :e (1,n))
  \/
  (setprod 2 omega = omega :\: {0} /\ (0,k) :e (1,n))
  \/
  (setprod 2 omega = setprod 2 omega /\
   exists i m j n0:set,
     i :e 2 /\ m :e omega /\ j :e 2 /\ n0 :e omega /\
     (0,k) = (i, m) /\ (1,n) = (j, n0) /\
     (i :e j \/ (i = j /\ m :e n0)))
  \/
  (setprod 2 omega = setprod R R /\
   exists a1 a2 b1 b2:set,
     (0,k) = (a1, a2) /\ (1,n) = (b1, b2) /\
     (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))).
apply orIL.
apply orIR.
prove setprod 2 omega = setprod 2 omega /\
   exists i m j n0:set,
     i :e 2 /\ m :e omega /\ j :e 2 /\ n0 :e omega /\
     (0,k) = (i, m) /\ (1,n) = (j, n0) /\
     (i :e j \/ (i = j /\ m :e n0)).
apply andI.
- reflexivity.
- witness 0.
  witness k.
  witness 1.
  witness n.
  claim Heq0k: (0,k) = (0,k).
  { reflexivity. }
  claim Heq1n: (1,n) = (1,n).
  { reflexivity. }
  claim H12: 0 :e 2 /\ k :e omega.
  { exact (andI (0 :e 2) (k :e omega) In_0_2 HkOmega). }
  claim H123: (0 :e 2 /\ k :e omega) /\ 1 :e 2.
  { exact (andI (0 :e 2 /\ k :e omega) (1 :e 2) H12 In_1_2). }
  claim H1234: ((0 :e 2 /\ k :e omega) /\ 1 :e 2) /\ n :e omega.
  { exact (andI ((0 :e 2 /\ k :e omega) /\ 1 :e 2) (n :e omega) H123 HnOmega). }
  claim H12345: (((0 :e 2 /\ k :e omega) /\ 1 :e 2) /\ n :e omega) /\ (0,k) = (0,k).
  { exact (andI (((0 :e 2 /\ k :e omega) /\ 1 :e 2) /\ n :e omega) ((0,k) = (0,k)) H1234 Heq0k). }
  claim H123456: ((((0 :e 2 /\ k :e omega) /\ 1 :e 2) /\ n :e omega) /\ (0,k) = (0,k)) /\ (1,n) = (1,n).
  { exact (andI ((((0 :e 2 /\ k :e omega) /\ 1 :e 2) /\ n :e omega) /\ (0,k) = (0,k)) ((1,n) = (1,n)) H12345 Heq1n). }
  claim Hlex: 0 :e 1 \/ (0 = 1 /\ k :e n).
  { exact (orIL (0 :e 1) (0 = 1 /\ k :e n) In_0_1). }
  apply andI.
  - exact H123456.
  - exact Hlex.
Qed.

(** helper: in the dictionary order on {0,1} we have (0,k) < (0,ordsucc k) for any k **)
Theorem order_rel_setprod_2_omega_0k_0succk : forall k:set,
  k :e omega -> order_rel (setprod 2 omega) (0,k) (0, ordsucc k).
let k. assume HkOmega.
claim HsuccOmega: ordsucc k :e omega.
{ exact (omega_ordsucc k HkOmega). }
prove order_rel (setprod 2 omega) (0,k) (0, ordsucc k).
(** Unfold `order_rel` at X = setprod 2 omega and select the 5th disjunct. **)
prove (setprod 2 omega = R /\ Rlt (0,k) (0, ordsucc k))
  \/
  (setprod 2 omega = rational_numbers /\ Rlt (0,k) (0, ordsucc k))
  \/
  (setprod 2 omega = omega /\ (0,k) :e (0, ordsucc k))
  \/
  (setprod 2 omega = omega :\: {0} /\ (0,k) :e (0, ordsucc k))
  \/
  (setprod 2 omega = setprod 2 omega /\
   exists i m j n0:set,
     i :e 2 /\ m :e omega /\ j :e 2 /\ n0 :e omega /\
     (0,k) = (i, m) /\ (0, ordsucc k) = (j, n0) /\
     (i :e j \/ (i = j /\ m :e n0)))
  \/
  (setprod 2 omega = setprod R R /\
   exists a1 a2 b1 b2:set,
     (0,k) = (a1, a2) /\ (0, ordsucc k) = (b1, b2) /\
     (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))).
apply orIL.
apply orIR.
prove setprod 2 omega = setprod 2 omega /\
   exists i m j n0:set,
     i :e 2 /\ m :e omega /\ j :e 2 /\ n0 :e omega /\
     (0,k) = (i, m) /\ (0, ordsucc k) = (j, n0) /\
     (i :e j \/ (i = j /\ m :e n0)).
apply andI.
- reflexivity.
- witness 0.
  witness k.
  witness 0.
  witness (ordsucc k).
  claim Heq0k: (0,k) = (0,k).
  { reflexivity. }
  claim Heq0sk: (0, ordsucc k) = (0, ordsucc k).
  { reflexivity. }
  claim H12: 0 :e 2 /\ k :e omega.
  { exact (andI (0 :e 2) (k :e omega) In_0_2 HkOmega). }
  claim H123: (0 :e 2 /\ k :e omega) /\ 0 :e 2.
  { exact (andI (0 :e 2 /\ k :e omega) (0 :e 2) H12 In_0_2). }
  claim H1234: ((0 :e 2 /\ k :e omega) /\ 0 :e 2) /\ ordsucc k :e omega.
  { exact (andI ((0 :e 2 /\ k :e omega) /\ 0 :e 2) (ordsucc k :e omega) H123 HsuccOmega). }
  claim H12345: (((0 :e 2 /\ k :e omega) /\ 0 :e 2) /\ ordsucc k :e omega) /\ (0,k) = (0,k).
  { exact (andI (((0 :e 2 /\ k :e omega) /\ 0 :e 2) /\ ordsucc k :e omega) ((0,k) = (0,k)) H1234 Heq0k). }
  claim H123456: ((((0 :e 2 /\ k :e omega) /\ 0 :e 2) /\ ordsucc k :e omega) /\ (0,k) = (0,k)) /\ (0, ordsucc k) = (0, ordsucc k).
  { exact (andI ((((0 :e 2 /\ k :e omega) /\ 0 :e 2) /\ ordsucc k :e omega) /\ (0,k) = (0,k)) ((0, ordsucc k) = (0, ordsucc k)) H12345 Heq0sk). }
  claim H00: 0 = 0.
  { reflexivity. }
  claim HkInSucc: k :e ordsucc k.
  { exact (ordsuccI2 k). }
  claim Hlex: 0 :e 0 \/ (0 = 0 /\ k :e ordsucc k).
  { exact (orIR (0 :e 0) (0 = 0 /\ k :e ordsucc k) (andI (0 = 0) (k :e ordsucc k) H00 HkInSucc)). }
  apply andI.
  - exact H123456.
  - exact Hlex.
Qed.

(** helper: eps_ 1 is not an element of the ordinal 2 **)
(** LATEX VERSION: 1/2 is neither 0 nor 1. **)
Theorem eps_1_not_in_2 : eps_ 1 /:e 2.
assume Heps2: eps_ 1 :e 2.
prove False.
claim Hsub: 2 c= {0,1}.
{ exact Subq_2_UPair01. }
claim Heps01: eps_ 1 :e {0,1}.
{ exact (Hsub (eps_ 1) Heps2). }
apply (UPairE (eps_ 1) 0 1 Heps01 False).
- assume Heq0: eps_ 1 = 0.
  claim H1omega: 1 :e omega.
  { exact (nat_p_omega 1 nat_1). }
  claim Heps1SNoS: eps_ 1 :e SNoS_ omega.
  { exact (SNo_eps_SNoS_omega 1 H1omega). }
  claim HepsR: eps_ 1 :e R.
  { exact (SNoS_omega_real (eps_ 1) Heps1SNoS). }
  claim H0ltEps: Rlt 0 (eps_ 1).
  { exact (RltI 0 (eps_ 1) real_0 HepsR (SNo_eps_pos 1 H1omega)). }
  claim Hbad: Rlt 0 0.
  { rewrite <- Heq0 at 2. exact H0ltEps. }
  exact ((not_Rlt_refl 0 real_0) Hbad).
- assume Heq1: eps_ 1 = 1.
  claim H1omega: 1 :e omega.
  { exact (nat_p_omega 1 nat_1). }
  claim Heps1SNoS: eps_ 1 :e SNoS_ omega.
  { exact (SNo_eps_SNoS_omega 1 H1omega). }
  claim HepsR: eps_ 1 :e R.
  { exact (SNoS_omega_real (eps_ 1) Heps1SNoS). }
  claim H0Ord: ordinal 0.
  { exact (nat_p_ordinal 0 nat_0). }
  claim H0in1: 0 :e 1.
  { exact (ordinal_0_In_ordsucc 0 H0Ord). }
  claim HepsLt1S: (eps_ 1) < 1.
  { claim HepsLtE0: eps_ 1 < eps_ 0.
    { exact (SNo_eps_decr 1 H1omega 0 H0in1). }
    rewrite <- (eps_0_1) at 2.
    exact HepsLtE0. }
  claim HepsLt1: Rlt (eps_ 1) 1.
  { exact (RltI (eps_ 1) 1 HepsR real_1 HepsLt1S). }
  claim Hbad: Rlt 1 1.
  { rewrite <- Heq1 at 1. exact HepsLt1. }
  exact ((not_Rlt_refl 1 real_1) Hbad).
Qed.

(** helper: setprod R R is not setprod 2 omega **)
Theorem setprod_R_R_neq_setprod_2_omega : setprod R R <> setprod 2 omega.
assume Heq: setprod R R = setprod 2 omega.
prove False.
claim H1omega: 1 :e omega.
{ exact (nat_p_omega 1 nat_1). }
claim Heps1SNoS: eps_ 1 :e SNoS_ omega.
{ exact (SNo_eps_SNoS_omega 1 H1omega). }
claim HepsR: eps_ 1 :e R.
{ exact (SNoS_omega_real (eps_ 1) Heps1SNoS). }
claim HpRR: (eps_ 1, 0) :e setprod R R.
{ exact (tuple_2_setprod_by_pair_Sigma R R (eps_ 1) 0 HepsR real_0). }
claim Hp2o: (eps_ 1, 0) :e setprod 2 omega.
{ rewrite <- Heq. exact HpRR. }
claim Heps2: ((eps_ 1, 0) 0) :e 2.
{ exact (ap0_Sigma 2 (fun _ : set => omega) (eps_ 1, 0) Hp2o). }
claim Heps2': eps_ 1 :e 2.
{ rewrite <- (tuple_2_0_eq (eps_ 1) 0).
  exact Heps2. }
exact (eps_1_not_in_2 Heps2').
Qed.

(** helper: reintroduce tagging notation y' as SetAdjoin y {1} in the topology section **)
Definition tag_topology : set -> set := fun y => SetAdjoin y {1}.
Postfix ' 100 := tag_topology.

(** helper: singleton {1} is not a surreal number **)
Theorem Sing1_not_SNo : ~SNo {1}.
assume HSNo: SNo {1}.
prove False.
set alpha := SNoLev {1}.
claim Hlev: ordinal alpha /\ SNo_ alpha {1}.
{ exact (SNoLev_prop {1} HSNo). }
claim Hord: ordinal alpha.
{ exact (andEL (ordinal alpha) (SNo_ alpha {1}) Hlev). }
claim HSNoa: SNo_ alpha {1}.
{ exact (andER (ordinal alpha) (SNo_ alpha {1}) Hlev). }

claim Hsub: {1} c= SNoElts_ alpha.
{ exact (andEL ({1} c= SNoElts_ alpha)
               (forall beta :e alpha, exactly1of2 (beta ' :e {1}) (beta :e {1}))
               HSNoa). }
claim Hprop: forall beta :e alpha, exactly1of2 (beta ' :e {1}) (beta :e {1}).
{ exact (andER ({1} c= SNoElts_ alpha)
               (forall beta :e alpha, exactly1of2 (beta ' :e {1}) (beta :e {1}))
               HSNoa). }

claim H1inElts: 1 :e SNoElts_ alpha.
{ exact (Hsub 1 (SingI 1)). }

claim H1inalpha: 1 :e alpha.
{ apply (binunionE' alpha {beta '|beta :e alpha} 1 (1 :e alpha)).
  - assume H1a: 1 :e alpha.
    exact H1a.
	  - assume H1tag: 1 :e {beta '|beta :e alpha}.
	    apply (ReplE alpha (fun beta : set => beta ') 1 H1tag).
	    let beta. assume Hbp.
	    apply Hbp.
	    assume Hbetaalpha: beta :e alpha.
	    assume HtagEq: 1 = beta '.
	    prove 1 :e alpha.
	    apply FalseE.
	    claim Hord1: ordinal 1.
	    { exact (nat_p_ordinal 1 nat_1). }
	    claim HnotOrdTag: ~ordinal (beta ').
	    { exact (tagged_not_ordinal beta). }
	    claim HnotOrd1: ~ordinal 1.
	    { rewrite HtagEq at 1.
	      exact HnotOrdTag. }
	    exact (HnotOrd1 Hord1).
	  - exact H1inElts. }

claim Htr: TransSet alpha.
{ exact (ordinal_TransSet alpha Hord). }
claim H1sub: 1 c= alpha.
{ exact (Htr 1 H1inalpha). }
claim H0inalpha: 0 :e alpha.
{ exact (H1sub 0 In_0_1). }

claim Hex01: exactly1of2 (0 ' :e {1}) (0 :e {1}).
{ exact (Hprop 0 H0inalpha). }

apply (exactly1of2_E (0 ' :e {1}) (0 :e {1}) Hex01 False).
- assume Htag: 0 ' :e {1}.
  assume _: ~(0 :e {1}).
  prove False.
  claim HtagEq: 0 ' = 1.
  { exact (SingE 1 (0 ') Htag). }
	  claim Hord1: ordinal 1.
	  { exact (nat_p_ordinal 1 nat_1). }
	  claim HnotOrdTag: ~ordinal (0 ').
	  { exact (tagged_not_ordinal 0). }
	  claim HnotOrd1: ~ordinal 1.
	  { rewrite <- HtagEq at 1.
	    exact HnotOrdTag. }
	  exact (HnotOrd1 Hord1).
- assume _: ~(0 ' :e {1}).
  assume H0: 0 :e {1}.
  prove False.
  claim H0eq: 0 = 1.
  { exact (SingE 1 0 H0). }
  exact (neq_0_1 H0eq).
Qed.

(** Helper: Inj1 0 equals 1 **)
Theorem Inj1_0_eq_1 : Inj1 0 = 1.
apply set_ext.
- let y. assume Hy: y :e Inj1 0.
  prove y :e 1.
  claim Hcase: y = 0 \/ exists x :e 0, y = Inj1 x.
  { exact (Inj1E 0 y Hy). }
  apply (Hcase (y :e 1)).
  - assume Hy0: y = 0.
    rewrite Hy0.
    exact In_0_1.
  - assume Hex: exists x :e 0, y = Inj1 x.
    apply Hex.
    let x. assume Hxp.
    apply Hxp.
    assume Hx0 HyEq.
    apply FalseE.
    exact (EmptyE x Hx0).
- let y. assume Hy: y :e 1.
  prove y :e Inj1 0.
  claim HySing: y :e {0}.
  { prove y :e {0}.
    rewrite <- eq_1_Sing0.
    exact Hy. }
  claim Hy0: y = 0.
  { exact (SingE 0 y HySing). }
  rewrite Hy0.
  exact (Inj1I1 0).
Qed.

(** Helper: tuple (0,1) equals {1} **)
Theorem tuple_0_1_eq_Sing1 : (0,1) = {1}.
prove (0,1) = {1}.
apply set_ext.
- let z. assume Hz: z :e (0,1).
  prove z :e {1}.
  claim Hzsum: z :e 0 :+: 1.
  { prove z :e 0 :+: 1.
    rewrite (tuple_pair 0 1).
    exact Hz. }
  claim Hcases: (exists x :e 0, z = Inj0 x) \/ (exists y :e 1, z = Inj1 y).
  { exact (setsum_Inj_inv 0 1 z Hzsum). }
  apply (Hcases (z :e {1})).
  - assume Hex: exists x :e 0, z = Inj0 x.
    apply Hex.
    let x. assume Hxp.
    apply Hxp.
    assume Hx0 HzEq.
    apply FalseE.
    exact (EmptyE x Hx0).
  - assume Hex: exists y :e 1, z = Inj1 y.
    apply Hex.
    let y. assume Hyp.
    apply Hyp.
    assume Hy1 HzEq.
    claim HySing: y :e {0}.
    { prove y :e {0}.
      rewrite <- eq_1_Sing0.
      exact Hy1. }
    claim Hy0: y = 0.
    { exact (SingE 0 y HySing). }
    claim HzInj10: z = Inj1 0.
    { prove z = Inj1 0.
      rewrite <- Hy0.
      exact HzEq. }
    claim Hz1: z = 1.
    { rewrite HzInj10.
      rewrite Inj1_0_eq_1.
      reflexivity. }
    rewrite Hz1.
    exact (SingI 1).
- let z. assume Hz: z :e {1}.
  prove z :e (0,1).
  rewrite <- (tuple_pair 0 1).
  claim Hz1: z = 1.
  { exact (SingE 1 z Hz). }
  rewrite Hz1.
  rewrite <- Inj1_0_eq_1 at 1.
  exact (Inj1_setsum 0 1 0 In_0_1).
Qed.

(** helper: setprod R R is not R **)
Theorem setprod_R_R_neq_R : setprod R R <> R.
assume Heq: setprod R R = R.
prove False.

claim HpRR: (0,1) :e setprod R R.
{ exact (tuple_2_setprod_by_pair_Sigma R R 0 1 real_0 real_1). }
claim HpR: (0,1) :e R.
{ rewrite <- Heq. exact HpRR. }
claim HSing1R: {1} :e R.
{ rewrite <- tuple_0_1_eq_Sing1 at 1.
  exact HpR. }
claim HdefR: R = real.
{ reflexivity. }
claim HSing1real: {1} :e real.
{ rewrite <- HdefR at 1.
  exact HSing1R. }
claim HSNo: SNo {1}.
{ exact (real_SNo {1} HSing1real). }
exact (Sing1_not_SNo HSNo).
Qed.

(** helper: setprod R R is not rational_numbers **)
Theorem setprod_R_R_neq_rational_numbers : setprod R R <> rational_numbers.
assume Heq: setprod R R = rational_numbers.
prove False.

(** rationals are countable: equip omega rational_numbers gives atleastp rational_numbers omega **)
claim Hequip: equip omega rational_numbers.
{ claim HdefQ: rational_numbers = rational.
  { reflexivity. }
  rewrite HdefQ.
  exact form100_3. }
claim Hequip_sym: equip rational_numbers omega.
{ exact (equip_sym omega rational_numbers Hequip). }
claim Hcount_Q: atleastp rational_numbers omega.
{ exact (equip_atleastp rational_numbers omega Hequip_sym). }
claim Hcount_prod: atleastp (setprod R R) omega.
{ rewrite Heq.
  exact Hcount_Q. }

(** inject R into RR via x  (x,0) **)
claim Hinj_R_prod: atleastp R (setprod R R).
{ prove exists f : set -> set, inj R (setprod R R) f.
  witness (fun x:set => (x,0)).
  apply (injI R (setprod R R) (fun x:set => (x,0))).
  - let x. assume Hx: x :e R.
    prove (x,0) :e setprod R R.
    exact (tuple_2_setprod_by_pair_Sigma R R x 0 Hx real_0).
  - let x.
    assume Hx: x :e R.
    let z.
    assume Hz: z :e R.
    assume Hxz: (x,0) = (z,0).
    prove x = z.
    claim Hcoords: x = z /\ 0 = 0.
    { exact (tuple_eq_coords x 0 z 0 Hxz). }
    exact (andEL (x = z) (0 = 0) Hcoords). }

(** compose injections to get R countable, contradict real uncountability **)
claim Hcount_R: atleastp R omega.
{ exact (atleastp_tra R (setprod R R) omega Hinj_R_prod Hcount_prod). }
claim HdefR: R = real.
{ reflexivity. }
claim Hcount_real: atleastp real omega.
{ rewrite <- HdefR.
  exact Hcount_R. }
exact (form100_22_real_uncountable_atleastp Hcount_real).
Qed.

(** helper: R is not countable, hence R is not omega, omega\\{0}, or Q **)
(** LATEX VERSION: Uses uncountability of reals to separate R from  and . **)
Theorem R_neq_omega : R <> omega.
assume Heq: R = omega.
prove False.
claim HdefR: R = real.
{ reflexivity. }
claim Heq': real = omega.
{ rewrite <- HdefR. exact Heq. }
claim Homega_countable: atleastp omega omega.
{ exact (Subq_atleastp omega omega (Subq_ref omega)). }
claim Hreal_countable: atleastp real omega.
{ rewrite Heq' at 1.
  exact Homega_countable. }
exact (form100_22_real_uncountable_atleastp Hreal_countable).
Qed.

Theorem R_neq_omega_nonzero : R <> (omega :\: {0}).
assume Heq: R = omega :\: {0}.
prove False.
claim HdefR: R = real.
{ reflexivity. }
claim Heq': real = omega :\: {0}.
{ rewrite <- HdefR. exact Heq. }
claim Hsub: (omega :\: {0}) c= omega.
{ exact (setminus_Subq omega {0}). }
claim Hcount_nonzero: atleastp (omega :\: {0}) omega.
{ exact (Subq_atleastp (omega :\: {0}) omega Hsub). }
claim Hreal_countable: atleastp real omega.
{ rewrite Heq' at 1.
  exact Hcount_nonzero. }
exact (form100_22_real_uncountable_atleastp Hreal_countable).
Qed.

Theorem R_neq_rational_numbers : R <> rational_numbers.
assume Heq: R = rational_numbers.
prove False.
claim HdefR: R = real.
{ reflexivity. }
claim Heq': real = rational_numbers.
{ rewrite <- HdefR. exact Heq. }
(** rationals are countable by form100_3 and rational_numbers = rational **)
claim Hequip: equip omega rational_numbers.
{ claim HdefQ: rational_numbers = rational.
  { reflexivity. }
  rewrite HdefQ.
  exact form100_3. }
claim Hequip_sym: equip rational_numbers omega.
{ exact (equip_sym omega rational_numbers Hequip). }
claim Hcount_Q: atleastp rational_numbers omega.
{ exact (equip_atleastp rational_numbers omega Hequip_sym). }
claim Hreal_countable: atleastp real omega.
{ rewrite Heq' at 1.
  exact Hcount_Q. }
exact (form100_22_real_uncountable_atleastp Hreal_countable).
Qed.

(** helper: R is not setprod 2 omega **)
(** LATEX VERSION:  is uncountable, but 2 is countable. **)
Theorem R_neq_setprod_2_omega : R <> setprod 2 omega.
assume Heq: R = setprod 2 omega.
prove False.

(** Countability of omega by the identity injection. **)
claim Homega_countable: countable omega.
{ exact (Subq_atleastp omega omega (Subq_ref omega)). }

(** Countability of 2 via 2 c= {0,1} c= omega. **)
claim H01subomega: {0,1} c= omega.
{ let x. assume Hx: x :e {0,1}.
  prove x :e omega.
  apply (UPairE x 0 1 Hx (x :e omega)).
  - assume Hx0: x = 0.
    rewrite Hx0.
    exact (nat_p_omega 0 nat_0).
  - assume Hx1: x = 1.
    rewrite Hx1.
    exact (nat_p_omega 1 nat_1). }
claim H2subomega: 2 c= omega.
{ exact (Subq_tra 2 {0,1} omega Subq_2_UPair01 H01subomega). }
claim H2countable: countable 2.
{ exact (Subq_atleastp 2 omega H2subomega). }

(** Therefore setprod 2 omega is countable. **)
claim Hprod_countable: countable (setprod 2 omega).
{ exact (setprod_countable 2 omega H2countable Homega_countable). }

(** Transfer countability to R by rewriting, contradicting real uncountability. **)
claim HRcountable: countable R.
{ rewrite Heq. exact Hprod_countable. }
claim HdefR: R = real.
{ reflexivity. }
claim Hreal_countable: atleastp real omega.
{ rewrite <- HdefR at 1.
  exact HRcountable. }
exact (form100_22_real_uncountable_atleastp Hreal_countable).
Qed.

(** Helper: strict order on  implies order_rel on  **)
(** LATEX VERSION: If a<b in  then order_rel(,a,b) holds (first disjunct in the definition). **)
Theorem Rlt_implies_order_rel_R : forall a b:set, Rlt a b -> order_rel R a b.
let a b. assume Hab.
prove order_rel R a b.
(** Unfold `order_rel` at X = R. **)
prove (R = R /\ Rlt a b)
  \/
  (R = rational_numbers /\ Rlt a b)
  \/
  (R = omega /\ a :e b)
  \/
  (R = omega :\: {0} /\ a :e b)
  \/
  (R = setprod 2 omega /\
   exists i m j n:set,
     i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
     a = (i, m) /\ b = (j, n) /\
     (i :e j \/ (i = j /\ m :e n)))
  \/
  (R = setprod R R /\
   exists a1 a2 b1 b2:set,
     a = (a1, a2) /\ b = (b1, b2) /\
     (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))).
(** `\/` is left-associative; inject into the leftmost disjunct repeatedly. **)
apply orIL.
apply orIL.
apply orIL.
apply orIL.
apply orIL.
prove R = R /\ Rlt a b.
apply andI.
- reflexivity.
- exact Hab.
Qed.

(** Helper: order_rel on  implies strict order on  **)
(** LATEX VERSION: If order_rel(,a,b) then a<b in  (all other disjuncts contradict known inequalities of carrier sets). **)
Theorem order_rel_R_implies_Rlt : forall a b:set, order_rel R a b -> Rlt a b.
let a b. assume Hrel: order_rel R a b.
prove Rlt a b.
apply (Hrel (Rlt a b)).
- assume Hleft.
  apply (Hleft (Rlt a b)).
  - assume Hleft2.
    apply (Hleft2 (Rlt a b)).
    + assume Hleft3.
      apply (Hleft3 (Rlt a b)).
      * assume Hleft4.
        apply (Hleft4 (Rlt a b)).
        - assume HA: R = R /\ Rlt a b.
           exact (andER (R = R) (Rlt a b) HA).
        - assume HB: R = rational_numbers /\ Rlt a b.
           apply FalseE.
           claim Heq: R = rational_numbers.
           { exact (andEL (R = rational_numbers) (Rlt a b) HB). }
           exact (R_neq_rational_numbers Heq).
      * assume HC: R = omega /\ a :e b.
        apply FalseE.
        claim Heq: R = omega.
        { exact (andEL (R = omega) (a :e b) HC). }
        exact (R_neq_omega Heq).
    + assume HD: R = omega :\: {0} /\ a :e b.
      apply FalseE.
      claim Heq: R = omega :\: {0}.
      { exact (andEL (R = omega :\: {0}) (a :e b) HD). }
      exact (R_neq_omega_nonzero Heq).
  - assume HE: R = setprod 2 omega /\
      exists i m j n:set,
        i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
        a = (i, m) /\ b = (j, n) /\ (i :e j \/ (i = j /\ m :e n)).
    apply FalseE.
    claim Heq: R = setprod 2 omega.
    { exact (andEL (R = setprod 2 omega)
                  (exists i m j n:set,
                    i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
                    a = (i, m) /\ b = (j, n) /\ (i :e j \/ (i = j /\ m :e n)))
                  HE). }
    exact (R_neq_setprod_2_omega Heq).
- assume HF: R = setprod R R /\
    exists a1 a2 b1 b2:set,
      a = (a1, a2) /\ b = (b1, b2) /\
      (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)).
  apply FalseE.
  claim Heq: R = setprod R R.
  { exact (andEL (R = setprod R R)
                 (exists a1 a2 b1 b2:set,
                   a = (a1, a2) /\ b = (b1, b2) /\
                   (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)))
                 HF). }
  apply setprod_R_R_neq_R.
  rewrite <- Heq.
  reflexivity.
Qed.

(** Helper: strict order on  implies order_rel on  **)
(** LATEX VERSION: If a<b in  then order_rel(,a,b) holds (second disjunct in the definition). **)
Theorem Rlt_implies_order_rel_Q : forall a b:set, Rlt a b -> order_rel rational_numbers a b.
let a b. assume Hab.
prove order_rel rational_numbers a b.
(** Unfold `order_rel` at X = rational_numbers. **)
prove (rational_numbers = R /\ Rlt a b)
  \/
  (rational_numbers = rational_numbers /\ Rlt a b)
  \/
  (rational_numbers = omega /\ a :e b)
  \/
  (rational_numbers = omega :\: {0} /\ a :e b)
  \/
  (rational_numbers = setprod 2 omega /\
   exists i m j n:set,
     i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
     a = (i, m) /\ b = (j, n) /\
     (i :e j \/ (i = j /\ m :e n)))
  \/
  (rational_numbers = setprod R R /\
   exists a1 a2 b1 b2:set,
     a = (a1, a2) /\ b = (b1, b2) /\
     (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))).
(** Reach the inner disjunction (A \/ B), then choose B. **)
apply orIL.
apply orIL.
apply orIL.
apply orIL.
apply orIR.
prove rational_numbers = rational_numbers /\ Rlt a b.
apply andI.
- reflexivity.
- exact Hab.
Qed.

(** Helper: membership order on  implies order_rel on  **)
(** LATEX VERSION: For , the strict order is membership: if ab then order_rel(,a,b). **)
Theorem mem_implies_order_rel_omega : forall a b:set, a :e b -> order_rel omega a b.
let a b. assume Hab.
prove order_rel omega a b.
(** Unfold `order_rel` at X = omega and inject into the 3rd disjunct. **)
prove (omega = R /\ Rlt a b)
  \/
  (omega = rational_numbers /\ Rlt a b)
  \/
  (omega = omega /\ a :e b)
  \/
  (omega = omega :\: {0} /\ a :e b)
  \/
  (omega = setprod 2 omega /\
   exists i m j n:set,
     i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
     a = (i, m) /\ b = (j, n) /\
     (i :e j \/ (i = j /\ m :e n)))
  \/
  (omega = setprod R R /\
   exists a1 a2 b1 b2:set,
     a = (a1, a2) /\ b = (b1, b2) /\
     (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))).
apply orIL.
apply orIL.
apply orIL.
apply orIR.
prove omega = omega /\ a :e b.
apply andI.
- reflexivity.
- exact Hab.
Qed.

(** Helper: membership order on \\{0} implies order_rel on \\{0} **)
(** LATEX VERSION: For \\{0}, we still use membership as the strict order. **)
Theorem mem_implies_order_rel_omega_nonzero : forall a b:set, a :e b -> order_rel (omega :\: {0}) a b.
let a b. assume Hab.
prove order_rel (omega :\: {0}) a b.
(** Unfold and inject into the 4th disjunct. **)
prove (omega :\: {0} = R /\ Rlt a b)
  \/
  (omega :\: {0} = rational_numbers /\ Rlt a b)
  \/
  (omega :\: {0} = omega /\ a :e b)
  \/
  (omega :\: {0} = omega :\: {0} /\ a :e b)
  \/
  (omega :\: {0} = setprod 2 omega /\
   exists i m j n:set,
     i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
     a = (i, m) /\ b = (j, n) /\
     (i :e j \/ (i = j /\ m :e n)))
  \/
  (omega :\: {0} = setprod R R /\
   exists a1 a2 b1 b2:set,
     a = (a1, a2) /\ b = (b1, b2) /\
     (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))).
apply orIL.
apply orIL.
apply orIR.
prove omega :\: {0} = omega :\: {0} /\ a :e b.
apply andI.
- reflexivity.
- exact Hab.
Qed.

Definition order_topology_basis : set -> set := fun X =>
  ({I :e Power X | exists a :e X, exists b :e X,
        I = {x :e X | order_rel X a x /\ order_rel X x b}}
   :\/:
   {I :e Power X | exists b :e X, I = {x :e X | order_rel X x b}}
   :\/:
   {I :e Power X | exists a :e X, I = {x :e X | order_rel X a x}}).

(** from 14 Definition: order topology on a simply ordered set **)
(** LATEX VERSION: The order topology on X is the topology generated by the order-topology basis on X. **)
Definition order_topology : set -> set := fun X => generated_topology X (order_topology_basis X).

(** Helper: order topology basis satisfies basis axioms **)
(** SUSPICIOUS DEFINITION: This lemma is stated for arbitrary X, but order_rel is only implemented for a small list of carrier sets; for other X the basis cover axiom may fail. This is a modeling gap, so the proof is currently admitted. **)
Theorem order_topology_basis_is_basis : forall X:set,
  basis_on X (order_topology_basis X).
admit.
Qed.

(** from 14: order topology is a topology **) 
(** LATEX VERSION: The order topology satisfies the topology axioms. **)
Theorem order_topology_is_topology : forall X:set,
  topology_on X (order_topology X).
let X.
prove topology_on X (order_topology X).
(** order_topology X = generated_topology X (order_topology_basis X) **)
(** Apply axiom that order_topology_basis X is a basis, then use lemma_topology_from_basis **)
exact (lemma_topology_from_basis X (order_topology_basis X) (order_topology_basis_is_basis X)).
Qed.

(** from 14: open rays form a subbasis for the order topology **) 
(** LATEX VERSION: The upper and lower open rays form a subbasis generating the order topology. **)
Definition open_ray_upper : set -> set -> set := fun X a => {x :e X | order_rel X a x}.
Definition open_ray_lower : set -> set -> set := fun X a => {x :e X | order_rel X x a}.

Definition open_rays_subbasis : set -> set := fun X =>
  (({I :e Power X | exists a :e X, I = open_ray_upper X a}
    :\/:
    {I :e Power X | exists b :e X, I = open_ray_lower X b})
   :\/:
   {X}).

(** Helper: open rays subbasis is a subset of Power X **)
Theorem open_rays_subbasis_sub_Power : forall X:set,
  open_rays_subbasis X c= Power X.
let X.
prove open_rays_subbasis X c= Power X.
let I. assume HI: I :e open_rays_subbasis X.
prove I :e Power X.
apply (binunionE' ({I0 :e Power X | exists a :e X, I0 = open_ray_upper X a}
                   :\/:
                   {I0 :e Power X | exists b :e X, I0 = open_ray_lower X b})
                  {X}
                  I
                  (I :e Power X)).
- assume HI0: I :e ({I0 :e Power X | exists a :e X, I0 = open_ray_upper X a}
                    :\/:
                    {I0 :e Power X | exists b :e X, I0 = open_ray_lower X b}).
  apply (binunionE' {I0 :e Power X | exists a :e X, I0 = open_ray_upper X a}
                    {I0 :e Power X | exists b :e X, I0 = open_ray_lower X b}
                    I
                    (I :e Power X)).
  + assume HI1: I :e {I0 :e Power X | exists a :e X, I0 = open_ray_upper X a}.
    exact (SepE1 (Power X) (fun I0 : set => exists a :e X, I0 = open_ray_upper X a) I HI1).
  + assume HI2: I :e {I0 :e Power X | exists b :e X, I0 = open_ray_lower X b}.
    exact (SepE1 (Power X) (fun I0 : set => exists b :e X, I0 = open_ray_lower X b) I HI2).
  + exact HI0.
- assume HIX: I :e {X}.
  claim HIEq: I = X.
  { exact (SingE X I HIX). }
  rewrite HIEq.
  exact (Self_In_Power X).
- exact HI.
Qed.

(** Helper: open rays subbasis covers X and lies in Power X **)
Theorem open_rays_subbasis_is_subbasis : forall X:set,
  subbasis_on X (open_rays_subbasis X).
let X.
prove subbasis_on X (open_rays_subbasis X).
prove (open_rays_subbasis X c= Power X) /\ Union (open_rays_subbasis X) = X.
apply andI.
- exact (open_rays_subbasis_sub_Power X).
- apply set_ext.
  + let x. assume HxU: x :e Union (open_rays_subbasis X).
    prove x :e X.
    apply (UnionE_impred (open_rays_subbasis X) x HxU).
    let U.
    assume HxUin: x :e U.
    assume HU: U :e open_rays_subbasis X.
    claim HUpow: U :e Power X.
    { exact (open_rays_subbasis_sub_Power X U HU). }
    claim HUsub: U c= X.
    { exact (PowerE X U HUpow). }
    exact (HUsub x HxUin).
  + let x. assume HxX: x :e X.
    prove x :e Union (open_rays_subbasis X).
    claim HXInS: X :e open_rays_subbasis X.
    { exact (binunionI2 ({I0 :e Power X | exists a :e X, I0 = open_ray_upper X a}
                         :\/:
                         {I0 :e Power X | exists b :e X, I0 = open_ray_lower X b})
                        {X}
                        X
                        (SingI X)). }
    exact (UnionI (open_rays_subbasis X) x X HxX HXInS).
Qed.

(** Helper: an upper ray is a basis element for the order topology **)
Theorem open_ray_upper_in_order_topology_basis : forall X a:set,
  a :e X -> open_ray_upper X a :e order_topology_basis X.
let X a. assume HaX.
prove open_ray_upper X a :e order_topology_basis X.
set U := open_ray_upper X a.
claim HUpow: U :e Power X.
{ apply PowerI.
  let x. assume HxU: x :e U.
  exact (SepE1 X (fun x0 : set => order_rel X a x0) x HxU). }
claim HUex: exists a0 :e X, U = {x :e X | order_rel X a0 x}.
{ witness a.
  prove a :e X /\ U = {x :e X | order_rel X a x}.
  apply andI.
  - exact HaX.
  - reflexivity.
}
claim HUfam: U :e {I :e Power X | exists a0 :e X, I = {x :e X | order_rel X a0 x}}.
{ exact (SepI (Power X)
              (fun I0 : set => exists a0 :e X, I0 = {x :e X | order_rel X a0 x})
              U
              HUpow
              HUex). }
exact (binunionI2 ({I :e Power X | exists a0 :e X, exists b0 :e X,
                      I = {x :e X | order_rel X a0 x /\ order_rel X x b0}}
                   :\/:
                   {I :e Power X | exists b0 :e X, I = {x :e X | order_rel X x b0}})
                  {I :e Power X | exists a0 :e X, I = {x :e X | order_rel X a0 x}}
                  U
                  HUfam).
Qed.

(** Helper: a lower ray is a basis element for the order topology **)
Theorem open_ray_lower_in_order_topology_basis : forall X b:set,
  b :e X -> open_ray_lower X b :e order_topology_basis X.
let X b. assume HbX.
prove open_ray_lower X b :e order_topology_basis X.
set U := open_ray_lower X b.
claim HUpow: U :e Power X.
{ apply PowerI.
  let x. assume HxU: x :e U.
  exact (SepE1 X (fun x0 : set => order_rel X x0 b) x HxU). }
claim HUex: exists b0 :e X, U = {x :e X | order_rel X x b0}.
{ witness b.
  prove b :e X /\ U = {x :e X | order_rel X x b}.
  apply andI.
  - exact HbX.
  - reflexivity.
}
claim HUfam: U :e {I :e Power X | exists b0 :e X, I = {x :e X | order_rel X x b0}}.
{ exact (SepI (Power X)
              (fun I0 : set => exists b0 :e X, I0 = {x :e X | order_rel X x b0})
              U
              HUpow
              HUex). }
exact (binunionI1 ({I :e Power X | exists a0 :e X, exists b0 :e X,
                      I = {x :e X | order_rel X a0 x /\ order_rel X x b0}}
                   :\/:
                   {I :e Power X | exists b0 :e X, I = {x :e X | order_rel X x b0}})
                  {I :e Power X | exists a0 :e X, I = {x :e X | order_rel X a0 x}}
                  U
                  (binunionI2 {I :e Power X | exists a0 :e X, exists b0 :e X,
                                I = {x :e X | order_rel X a0 x /\ order_rel X x b0}}
                              {I :e Power X | exists b0 :e X, I = {x :e X | order_rel X x b0}}
                              U
                              HUfam)).
Qed.

(** Helper: open rays subbasis elements are open in the order topology **)
Theorem open_rays_subbasis_sub_order_topology : forall X:set,
  open_rays_subbasis X c= order_topology X.
let X.
prove open_rays_subbasis X c= order_topology X.
let U. assume HU: U :e open_rays_subbasis X.
prove U :e order_topology X.
apply (binunionE' ({I0 :e Power X | exists a :e X, I0 = open_ray_upper X a}
                   :\/:
                   {I0 :e Power X | exists b :e X, I0 = open_ray_lower X b})
                  {X}
                  U
                  (U :e order_topology X)).
- assume HU0: U :e ({I0 :e Power X | exists a :e X, I0 = open_ray_upper X a}
                    :\/:
                    {I0 :e Power X | exists b :e X, I0 = open_ray_lower X b}).
  apply (binunionE' {I0 :e Power X | exists a :e X, I0 = open_ray_upper X a}
                    {I0 :e Power X | exists b :e X, I0 = open_ray_lower X b}
                    U
                    (U :e order_topology X)).
  + assume HU1: U :e {I0 :e Power X | exists a :e X, I0 = open_ray_upper X a}.
    claim Hex: exists a :e X, U = open_ray_upper X a.
    { exact (SepE2 (Power X) (fun I0 : set => exists a :e X, I0 = open_ray_upper X a) U HU1). }
    apply Hex.
    let a.
    assume Hcore: a :e X /\ U = open_ray_upper X a.
    apply Hcore.
    assume HaX: a :e X.
    assume HUeq: U = open_ray_upper X a.
    rewrite HUeq.
    claim HUinB: open_ray_upper X a :e order_topology_basis X.
    { exact (open_ray_upper_in_order_topology_basis X a HaX). }
    exact (generated_topology_contains_basis X (order_topology_basis X) (order_topology_basis_is_basis X)
            (open_ray_upper X a) HUinB).
  + assume HU2: U :e {I0 :e Power X | exists b :e X, I0 = open_ray_lower X b}.
    claim Hex: exists b :e X, U = open_ray_lower X b.
    { exact (SepE2 (Power X) (fun I0 : set => exists b :e X, I0 = open_ray_lower X b) U HU2). }
    apply Hex.
    let b.
    assume Hcore: b :e X /\ U = open_ray_lower X b.
    apply Hcore.
    assume HbX: b :e X.
    assume HUeq: U = open_ray_lower X b.
    rewrite HUeq.
    claim HUinB: open_ray_lower X b :e order_topology_basis X.
    { exact (open_ray_lower_in_order_topology_basis X b HbX). }
    exact (generated_topology_contains_basis X (order_topology_basis X) (order_topology_basis_is_basis X)
            (open_ray_lower X b) HUinB).
  + exact HU0.
- assume HUX: U :e {X}.
  claim HUeq: U = X.
  { exact (SingE X U HUX). }
  rewrite HUeq.
  exact (topology_has_X X (order_topology X) (order_topology_is_topology X)).
- exact HU.
Qed.

(** Helper: any subbasis element is open in the generated topology from the subbasis **)
Theorem subbasis_elem_open_in_generated_from_subbasis : forall X S s:set,
  subbasis_on X S ->
  s :e S ->
  s :e generated_topology_from_subbasis X S.
let X S s.
assume HS HsS.
apply (xm (s = Empty)).
- assume HsEmpty.
  rewrite HsEmpty.
  claim HT: topology_on X (generated_topology_from_subbasis X S).
  { exact (topology_from_subbasis_is_topology X S HS). }
  exact (topology_has_empty X (generated_topology_from_subbasis X S) HT).
- assume HsNe.
  claim HBasis: basis_on X (basis_of_subbasis X S).
  { exact (finite_intersections_basis_of_subbasis X S HS). }
  claim HsBasis: s :e basis_of_subbasis X S.
  { exact (subbasis_elem_in_basis X S s HS HsS HsNe). }
  exact (generated_topology_contains_basis X (basis_of_subbasis X S) HBasis s HsBasis).
Qed.

(** Helper: upper ray belongs to open_rays_subbasis **)
Theorem open_ray_upper_in_open_rays_subbasis : forall X a:set,
  a :e X ->
  open_ray_upper X a :e open_rays_subbasis X.
let X a. assume HaX.
set U := open_ray_upper X a.
claim HUpow: U :e Power X.
{ apply PowerI.
  let x. assume HxU: x :e U.
  exact (SepE1 X (fun x0 : set => order_rel X a x0) x HxU). }
claim HUex: exists a0 :e X, U = open_ray_upper X a0.
{ witness a.
  prove a :e X /\ U = open_ray_upper X a.
  apply andI.
  - exact HaX.
  - reflexivity.
}
claim HUfam: U :e {I0 :e Power X | exists a0 :e X, I0 = open_ray_upper X a0}.
{ exact (SepI (Power X)
              (fun I0 : set => exists a0 :e X, I0 = open_ray_upper X a0)
              U
              HUpow
              HUex). }
exact (binunionI1 ({I0 :e Power X | exists a0 :e X, I0 = open_ray_upper X a0}
                   :\/:
                   {I0 :e Power X | exists b0 :e X, I0 = open_ray_lower X b0})
                  {X}
                  U
                  (binunionI1 {I0 :e Power X | exists a0 :e X, I0 = open_ray_upper X a0}
                              {I0 :e Power X | exists b0 :e X, I0 = open_ray_lower X b0}
                              U
                              HUfam)).
Qed.

(** Helper: lower ray belongs to open_rays_subbasis **)
Theorem open_ray_lower_in_open_rays_subbasis : forall X b:set,
  b :e X ->
  open_ray_lower X b :e open_rays_subbasis X.
let X b. assume HbX.
set U := open_ray_lower X b.
claim HUpow: U :e Power X.
{ apply PowerI.
  let x. assume HxU: x :e U.
  exact (SepE1 X (fun x0 : set => order_rel X x0 b) x HxU). }
claim HUex: exists b0 :e X, U = open_ray_lower X b0.
{ witness b.
  prove b :e X /\ U = open_ray_lower X b.
  apply andI.
  - exact HbX.
  - reflexivity.
}
claim HUfam: U :e {I0 :e Power X | exists b0 :e X, I0 = open_ray_lower X b0}.
{ exact (SepI (Power X)
              (fun I0 : set => exists b0 :e X, I0 = open_ray_lower X b0)
              U
              HUpow
              HUex). }
exact (binunionI1 ({I0 :e Power X | exists a0 :e X, I0 = open_ray_upper X a0}
                   :\/:
                   {I0 :e Power X | exists b0 :e X, I0 = open_ray_lower X b0})
                  {X}
                  U
                  (binunionI2 {I0 :e Power X | exists a0 :e X, I0 = open_ray_upper X a0}
                              {I0 :e Power X | exists b0 :e X, I0 = open_ray_lower X b0}
                              U
                              HUfam)).
Qed.

(** Helper: open interval equals intersection of open rays **)
Theorem open_interval_eq_rays_intersection : forall X a b:set,
  {x :e X | order_rel X a x /\ order_rel X x b}
  =
  (open_ray_upper X a) :/\: (open_ray_lower X b).
let X a b.
apply set_ext.
- let x. assume Hx: x :e {x0 :e X | order_rel X a x0 /\ order_rel X x0 b}.
  prove x :e (open_ray_upper X a) :/\: (open_ray_lower X b).
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0 : set => order_rel X a x0 /\ order_rel X x0 b) x Hx). }
  claim HxRel: order_rel X a x /\ order_rel X x b.
  { exact (SepE2 X (fun x0 : set => order_rel X a x0 /\ order_rel X x0 b) x Hx). }
  claim HxUp: x :e open_ray_upper X a.
  { exact (SepI X (fun x0 : set => order_rel X a x0) x HxX
                 (andEL (order_rel X a x) (order_rel X x b) HxRel)). }
  claim HxLo: x :e open_ray_lower X b.
  { exact (SepI X (fun x0 : set => order_rel X x0 b) x HxX
                 (andER (order_rel X a x) (order_rel X x b) HxRel)). }
  exact (binintersectI (open_ray_upper X a) (open_ray_lower X b) x HxUp HxLo).
- let x. assume Hx: x :e (open_ray_upper X a) :/\: (open_ray_lower X b).
  prove x :e {x0 :e X | order_rel X a x0 /\ order_rel X x0 b}.
  claim HxUp: x :e open_ray_upper X a.
  { exact (binintersectE1 (open_ray_upper X a) (open_ray_lower X b) x Hx). }
  claim HxLo: x :e open_ray_lower X b.
  { exact (binintersectE2 (open_ray_upper X a) (open_ray_lower X b) x Hx). }
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0 : set => order_rel X a x0) x HxUp). }
  claim HxRelUp: order_rel X a x.
  { exact (SepE2 X (fun x0 : set => order_rel X a x0) x HxUp). }
  claim HxRelLo: order_rel X x b.
  { exact (SepE2 X (fun x0 : set => order_rel X x0 b) x HxLo). }
  exact (SepI X (fun x0 : set => order_rel X a x0 /\ order_rel X x0 b) x HxX
              (andI (order_rel X a x) (order_rel X x b) HxRelUp HxRelLo)).
Qed.

(** Helper: order topology basis elements are open in the topology generated by open rays **)
Theorem order_topology_basis_sub_generated_from_open_rays : forall X:set,
  order_topology_basis X c= generated_topology_from_subbasis X (open_rays_subbasis X).
let X.
set Tsub := generated_topology_from_subbasis X (open_rays_subbasis X).
claim HSsub: subbasis_on X (open_rays_subbasis X).
{ exact (open_rays_subbasis_is_subbasis X). }
claim HTsub: topology_on X Tsub.
{ exact (topology_from_subbasis_is_topology X (open_rays_subbasis X) HSsub). }
prove order_topology_basis X c= Tsub.
let I. assume HI: I :e order_topology_basis X.
prove I :e Tsub.
apply (binunionE' ({I0 :e Power X | exists a0 :e X, exists b0 :e X,
                      I0 = {x :e X | order_rel X a0 x /\ order_rel X x b0}}
                   :\/:
                   {I0 :e Power X | exists b0 :e X, I0 = {x :e X | order_rel X x b0}})
                  {I0 :e Power X | exists a0 :e X, I0 = {x :e X | order_rel X a0 x}}
                  I
                  (I :e Tsub)).
- assume HI0: I :e ({I0 :e Power X | exists a0 :e X, exists b0 :e X,
                      I0 = {x :e X | order_rel X a0 x /\ order_rel X x b0}}
                     :\/:
                     {I0 :e Power X | exists b0 :e X, I0 = {x :e X | order_rel X x b0}}).
  apply (binunionE' {I0 :e Power X | exists a0 :e X, exists b0 :e X,
                       I0 = {x :e X | order_rel X a0 x /\ order_rel X x b0}}
                    {I0 :e Power X | exists b0 :e X, I0 = {x :e X | order_rel X x b0}}
                    I
                    (I :e Tsub)).
  + assume HIint: I :e {I0 :e Power X | exists a0 :e X, exists b0 :e X,
                          I0 = {x :e X | order_rel X a0 x /\ order_rel X x b0}}.
    claim Hex: exists a0 :e X, exists b0 :e X, I = {x :e X | order_rel X a0 x /\ order_rel X x b0}.
    { exact (SepE2 (Power X)
                   (fun I0 : set => exists a0 :e X, exists b0 :e X, I0 = {x :e X | order_rel X a0 x /\ order_rel X x b0})
                   I
                   HIint). }
    apply Hex.
    let a0.
    assume Hcore: a0 :e X /\ exists b0 :e X, I = {x :e X | order_rel X a0 x /\ order_rel X x b0}.
    apply Hcore.
    assume HaX: a0 :e X.
    assume Hexb: exists b0 :e X, I = {x :e X | order_rel X a0 x /\ order_rel X x b0}.
    apply Hexb.
    let b0.
    assume Hcore2: b0 :e X /\ I = {x :e X | order_rel X a0 x /\ order_rel X x b0}.
    apply Hcore2.
    assume HbX: b0 :e X.
    assume HIeq: I = {x :e X | order_rel X a0 x /\ order_rel X x b0}.
    rewrite HIeq.
    set U1 := open_ray_upper X a0.
    set U2 := open_ray_lower X b0.
    claim HU1S: U1 :e open_rays_subbasis X.
    { exact (open_ray_upper_in_open_rays_subbasis X a0 HaX). }
    claim HU2S: U2 :e open_rays_subbasis X.
    { exact (open_ray_lower_in_open_rays_subbasis X b0 HbX). }
    claim HU1open: U1 :e Tsub.
    { exact (subbasis_elem_open_in_generated_from_subbasis X (open_rays_subbasis X) U1 HSsub HU1S). }
    claim HU2open: U2 :e Tsub.
    { exact (subbasis_elem_open_in_generated_from_subbasis X (open_rays_subbasis X) U2 HSsub HU2S). }
    claim Heq: {x :e X | order_rel X a0 x /\ order_rel X x b0} = U1 :/\: U2.
    { exact (open_interval_eq_rays_intersection X a0 b0). }
    rewrite Heq.
    exact (topology_binintersect_closed X Tsub U1 U2 HTsub HU1open HU2open).
  + assume HIlow: I :e {I0 :e Power X | exists b0 :e X, I0 = {x :e X | order_rel X x b0}}.
    claim Hex: exists b0 :e X, I = {x :e X | order_rel X x b0}.
    { exact (SepE2 (Power X)
                   (fun I0 : set => exists b0 :e X, I0 = {x :e X | order_rel X x b0})
                   I
                   HIlow). }
    apply Hex.
    let b0.
    assume Hcore: b0 :e X /\ I = {x :e X | order_rel X x b0}.
    apply Hcore.
    assume HbX: b0 :e X.
    assume HIeq: I = {x :e X | order_rel X x b0}.
    rewrite HIeq.
    claim Hdef: open_ray_lower X b0 = {x :e X | order_rel X x b0}.
    { reflexivity. }
    rewrite <- Hdef.
    set U := open_ray_lower X b0.
    claim HUS: U :e open_rays_subbasis X.
    { exact (open_ray_lower_in_open_rays_subbasis X b0 HbX). }
    exact (subbasis_elem_open_in_generated_from_subbasis X (open_rays_subbasis X) U HSsub HUS).
  + exact HI0.
- assume HIup: I :e {I0 :e Power X | exists a0 :e X, I0 = {x :e X | order_rel X a0 x}}.
  claim Hex: exists a0 :e X, I = {x :e X | order_rel X a0 x}.
  { exact (SepE2 (Power X)
                 (fun I0 : set => exists a0 :e X, I0 = {x :e X | order_rel X a0 x})
                 I
                 HIup). }
  apply Hex.
  let a0.
  assume Hcore: a0 :e X /\ I = {x :e X | order_rel X a0 x}.
  apply Hcore.
  assume HaX: a0 :e X.
  assume HIeq: I = {x :e X | order_rel X a0 x}.
  rewrite HIeq.
  claim Hdef: open_ray_upper X a0 = {x :e X | order_rel X a0 x}.
  { reflexivity. }
  rewrite <- Hdef.
  set U := open_ray_upper X a0.
  claim HUS: U :e open_rays_subbasis X.
  { exact (open_ray_upper_in_open_rays_subbasis X a0 HaX). }
  exact (subbasis_elem_open_in_generated_from_subbasis X (open_rays_subbasis X) U HSsub HUS).
- exact HI.
Qed.

Theorem open_rays_subbasis_for_order_topology : forall X:set,
  generated_topology_from_subbasis X (open_rays_subbasis X) = order_topology X.
let X.
prove generated_topology_from_subbasis X (open_rays_subbasis X) = order_topology X.
apply set_ext.
- let U. assume HU : U :e generated_topology_from_subbasis X (open_rays_subbasis X).
  prove U :e order_topology X.
  claim HS: subbasis_on X (open_rays_subbasis X).
  { exact (open_rays_subbasis_is_subbasis X). }
  claim HT: topology_on X (order_topology X).
  { exact (order_topology_is_topology X). }
  claim HSsub: open_rays_subbasis X c= order_topology X.
  { exact (open_rays_subbasis_sub_order_topology X). }
  claim Hmin: finer_than (order_topology X) (generated_topology_from_subbasis X (open_rays_subbasis X)).
  { exact (topology_generated_by_basis_is_minimal X (open_rays_subbasis X) (order_topology X) HS HT HSsub). }
  exact (Hmin U HU).
- let U. assume HU : U :e order_topology X.
  prove U :e generated_topology_from_subbasis X (open_rays_subbasis X).
  set Tsub := generated_topology_from_subbasis X (open_rays_subbasis X).
  claim HS: subbasis_on X (open_rays_subbasis X).
  { exact (open_rays_subbasis_is_subbasis X). }
  claim HTsub: topology_on X Tsub.
  { exact (topology_from_subbasis_is_topology X (open_rays_subbasis X) HS). }
  claim HBsub: forall b :e order_topology_basis X, b :e Tsub.
  { let b. assume Hb.
    exact (order_topology_basis_sub_generated_from_open_rays X b Hb). }
  claim Hfiner: finer_than Tsub (generated_topology X (order_topology_basis X)).
  { exact (generated_topology_finer X (order_topology_basis X) Tsub (order_topology_basis_is_basis X) HTsub HBsub). }
  exact (Hfiner U HU).
Qed.

(** from 14 Example 1: standard basis is a basis on  **)
(** LATEX VERSION: The standard open-interval basis on  satisfies the basis axioms. **)
Theorem R_standard_basis_is_basis : basis_on R R_standard_basis.
prove basis_on R R_standard_basis.
(** Reuse the earlier proof to avoid duplicate work. **)
exact R_standard_basis_is_basis_local.
Qed.

(** from 14 Example 1: standard topology is a topology **)
(** LATEX VERSION: The standard topology on  satisfies the topology axioms. **)
Theorem R_standard_topology_is_topology : topology_on R R_standard_topology.
prove topology_on R R_standard_topology.
exact (lemma_topology_from_basis R R_standard_basis (R_standard_basis_is_basis)).
Qed.

(** from 14 Example 1: standard topology on  is the order topology **)
(** LATEX VERSION: Example 1: The standard topology on  equals its order topology. **)
(** NOTE: The earlier axiom equating bases was too strong; we only need equality of the generated topologies. **)
Theorem standard_topology_is_order_topology : order_topology R = R_standard_topology.
prove order_topology R = R_standard_topology.
apply set_ext.
- let U. assume HU: U :e order_topology R.
  prove U :e R_standard_topology.
  claim HBasis: basis_on R (order_topology_basis R).
  { exact (order_topology_basis_is_basis R). }
  claim HTstd: topology_on R R_standard_topology.
  { exact R_standard_topology_is_topology. }
  claim HBsub: forall b :e order_topology_basis R, b :e R_standard_topology.
  { let b. assume Hb: b :e order_topology_basis R.
    prove b :e R_standard_topology.

    set A := {I :e Power R | exists a :e R, exists b0 :e R,
                I = {x :e R | order_rel R a x /\ order_rel R x b0}}.
    set B := {I :e Power R | exists b0 :e R, I = {x :e R | order_rel R x b0}}.
    set C := {I :e Power R | exists a :e R, I = {x :e R | order_rel R a x}}.

    claim HbU: b :e (A :\/: B :\/: C).
    { exact Hb. }

    apply (binunionE' (A :\/: B) C b (b :e R_standard_topology)).
    - assume HbAB: b :e (A :\/: B).
      apply (binunionE' A B b (b :e R_standard_topology)).
      + assume HbA: b :e A.
        claim Hex: exists a :e R, exists b0 :e R, b = {x :e R | order_rel R a x /\ order_rel R x b0}.
        { exact (SepE2 (Power R)
                      (fun I0 : set => exists a :e R, exists b0 :e R,
                         I0 = {x :e R | order_rel R a x /\ order_rel R x b0})
                      b HbA). }
        apply Hex.
        let a. assume Hap.
        apply Hap.
        assume HaR: a :e R.
        assume Hexb: exists b0 :e R, b = {x :e R | order_rel R a x /\ order_rel R x b0}.
        apply Hexb.
        let b0. assume Hbp.
        apply Hbp.
        assume Hb0R: b0 :e R.
        assume Hbeq: b = {x :e R | order_rel R a x /\ order_rel R x b0}.

        claim HintEq: {x :e R | order_rel R a x /\ order_rel R x b0} = open_interval a b0.
        { apply set_ext.
          - let x. assume HxI: x :e {x0 :e R | order_rel R a x0 /\ order_rel R x0 b0}.
            prove x :e open_interval a b0.
            claim HxR: x :e R.
            { exact (SepE1 R (fun x0 : set => order_rel R a x0 /\ order_rel R x0 b0) x HxI). }
            claim Hconj: order_rel R a x /\ order_rel R x b0.
            { exact (SepE2 R (fun x0 : set => order_rel R a x0 /\ order_rel R x0 b0) x HxI). }
            claim Hax: order_rel R a x.
            { exact (andEL (order_rel R a x) (order_rel R x b0) Hconj). }
            claim Hxb: order_rel R x b0.
            { exact (andER (order_rel R a x) (order_rel R x b0) Hconj). }
            claim Haxlt: Rlt a x.
            { exact (order_rel_R_implies_Rlt a x Hax). }
            claim Hxblt: Rlt x b0.
            { exact (order_rel_R_implies_Rlt x b0 Hxb). }
            claim Hconj': Rlt a x /\ Rlt x b0.
            { exact (andI (Rlt a x) (Rlt x b0) Haxlt Hxblt). }
            exact (SepI R (fun x0 : set => Rlt a x0 /\ Rlt x0 b0) x HxR Hconj').
          - let x. assume HxI: x :e open_interval a b0.
            prove x :e {x0 :e R | order_rel R a x0 /\ order_rel R x0 b0}.
            claim HxR: x :e R.
            { exact (SepE1 R (fun x0 : set => Rlt a x0 /\ Rlt x0 b0) x HxI). }
            claim Hconj: Rlt a x /\ Rlt x b0.
            { exact (SepE2 R (fun x0 : set => Rlt a x0 /\ Rlt x0 b0) x HxI). }
            claim Hax: Rlt a x.
            { exact (andEL (Rlt a x) (Rlt x b0) Hconj). }
            claim Hxb: Rlt x b0.
            { exact (andER (Rlt a x) (Rlt x b0) Hconj). }
            claim Haxrel: order_rel R a x.
            { exact (Rlt_implies_order_rel_R a x Hax). }
            claim Hxbrel: order_rel R x b0.
            { exact (Rlt_implies_order_rel_R x b0 Hxb). }
            claim Hconj': order_rel R a x /\ order_rel R x b0.
            { exact (andI (order_rel R a x) (order_rel R x b0) Haxrel Hxbrel). }
            exact (SepI R (fun x0 : set => order_rel R a x0 /\ order_rel R x0 b0) x HxR Hconj'). }

        rewrite Hbeq.
        rewrite HintEq.
        claim HIinBasis: open_interval a b0 :e R_standard_basis.
        { claim HIa: open_interval a b0 :e {open_interval a bb|bb :e R}.
          { exact (ReplI R (fun bb : set => open_interval a bb) b0 Hb0R). }
          exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a (open_interval a b0) HaR HIa). }
        exact (generated_topology_contains_basis R R_standard_basis (R_standard_basis_is_basis) (open_interval a b0) HIinBasis).
      + assume HbB: b :e B.
        claim Hex: exists b0 :e R, b = {x :e R | order_rel R x b0}.
        { exact (SepE2 (Power R)
                      (fun I0 : set => exists b0 :e R, I0 = {x :e R | order_rel R x b0})
                      b HbB). }
        apply Hex.
        let b0. assume Hbp.
        apply Hbp.
        assume Hb0R: b0 :e R.
        assume Hbeq: b = {x :e R | order_rel R x b0}.
        claim HrayEq: {x :e R | order_rel R x b0} = {x :e R | Rlt x b0}.
        { apply set_ext.
          - let x. assume HxU: x :e {x0 :e R | order_rel R x0 b0}.
            prove x :e {x0 :e R | Rlt x0 b0}.
            claim HxR: x :e R.
            { exact (SepE1 R (fun x0 : set => order_rel R x0 b0) x HxU). }
            claim Hrel: order_rel R x b0.
            { exact (SepE2 R (fun x0 : set => order_rel R x0 b0) x HxU). }
            claim Hlt: Rlt x b0.
            { exact (order_rel_R_implies_Rlt x b0 Hrel). }
            exact (SepI R (fun x0 : set => Rlt x0 b0) x HxR Hlt).
          - let x. assume HxU: x :e {x0 :e R | Rlt x0 b0}.
            prove x :e {x0 :e R | order_rel R x0 b0}.
            claim HxR: x :e R.
            { exact (SepE1 R (fun x0 : set => Rlt x0 b0) x HxU). }
            claim Hlt: Rlt x b0.
            { exact (SepE2 R (fun x0 : set => Rlt x0 b0) x HxU). }
            claim Hrel: order_rel R x b0.
            { exact (Rlt_implies_order_rel_R x b0 Hlt). }
            exact (SepI R (fun x0 : set => order_rel R x0 b0) x HxR Hrel). }
        rewrite Hbeq.
        rewrite HrayEq.
        exact (open_left_ray_in_R_standard_topology b0 Hb0R).
      + exact HbAB.
    - assume HbC: b :e C.
      claim Hex: exists a :e R, b = {x :e R | order_rel R a x}.
      { exact (SepE2 (Power R)
                    (fun I0 : set => exists a0 :e R, I0 = {x :e R | order_rel R a0 x})
                    b HbC). }
      apply Hex.
      let a. assume Hap.
      apply Hap.
      assume HaR: a :e R.
      assume Hbeq: b = {x :e R | order_rel R a x}.
      claim HrayEq: {x :e R | order_rel R a x} = {x :e R | Rlt a x}.
      { apply set_ext.
        - let x. assume HxU: x :e {x0 :e R | order_rel R a x0}.
          prove x :e {x0 :e R | Rlt a x0}.
          claim HxR: x :e R.
          { exact (SepE1 R (fun x0 : set => order_rel R a x0) x HxU). }
          claim Hrel: order_rel R a x.
          { exact (SepE2 R (fun x0 : set => order_rel R a x0) x HxU). }
          claim Hlt: Rlt a x.
          { exact (order_rel_R_implies_Rlt a x Hrel). }
          exact (SepI R (fun x0 : set => Rlt a x0) x HxR Hlt).
        - let x. assume HxU: x :e {x0 :e R | Rlt a x0}.
          prove x :e {x0 :e R | order_rel R a x0}.
          claim HxR: x :e R.
          { exact (SepE1 R (fun x0 : set => Rlt a x0) x HxU). }
          claim Hlt: Rlt a x.
          { exact (SepE2 R (fun x0 : set => Rlt a x0) x HxU). }
          claim Hrel: order_rel R a x.
          { exact (Rlt_implies_order_rel_R a x Hlt). }
          exact (SepI R (fun x0 : set => order_rel R a x0) x HxR Hrel). }
      rewrite Hbeq.
      rewrite HrayEq.
      exact (open_ray_in_R_standard_topology a HaR).
    - exact HbU.
  }
  claim Hfiner: finer_than R_standard_topology (generated_topology R (order_topology_basis R)).
  { exact (generated_topology_finer R (order_topology_basis R) R_standard_topology HBasis HTstd HBsub). }
  exact (Hfiner U HU).
- let U. assume HU: U :e R_standard_topology.
  prove U :e order_topology R.
  claim HBasisStd: basis_on R R_standard_basis.
  { exact (R_standard_basis_is_basis). }
  claim HTord: topology_on R (order_topology R).
  { exact (order_topology_is_topology R). }
  claim HBsubStd: forall b :e R_standard_basis, b :e order_topology R.
  { let b. assume Hb: b :e R_standard_basis.
    prove b :e order_topology R.
    claim Hexa : exists a :e R, b :e {open_interval a bb|bb :e R}.
    { exact (famunionE R (fun a0 : set => {open_interval a0 bb|bb :e R}) b Hb). }
    apply Hexa.
    let a. assume Hap.
    apply Hap.
    assume HaR: a :e R.
    assume HbFam: b :e {open_interval a bb|bb :e R}.
    claim Hexb : exists b0 :e R, b = open_interval a b0.
    { exact (ReplE R (fun bb0 : set => open_interval a bb0) b HbFam). }
    apply Hexb.
    let b0. assume Hbp.
    apply Hbp.
    assume Hb0R: b0 :e R.
    assume Hbeq: b = open_interval a b0.
    rewrite Hbeq.

    set A := {I :e Power R | exists a1 :e R, exists b1 :e R,
                I = {x :e R | order_rel R a1 x /\ order_rel R x b1}}.
    set B := {I :e Power R | exists b1 :e R, I = {x :e R | order_rel R x b1}}.
    set C := {I :e Power R | exists a1 :e R, I = {x :e R | order_rel R a1 x}}.

    claim HPow: open_interval a b0 :e Power R.
    { exact (PowerI R (open_interval a b0) (open_interval_Subq_R a b0)). }

    claim HintEq: open_interval a b0 = {x :e R | order_rel R a x /\ order_rel R x b0}.
    { apply set_ext.
      - let x. assume HxI: x :e open_interval a b0.
        prove x :e {x0 :e R | order_rel R a x0 /\ order_rel R x0 b0}.
        claim HxR: x :e R.
        { exact (SepE1 R (fun x0 : set => Rlt a x0 /\ Rlt x0 b0) x HxI). }
        claim Hconj: Rlt a x /\ Rlt x b0.
        { exact (SepE2 R (fun x0 : set => Rlt a x0 /\ Rlt x0 b0) x HxI). }
        claim Hax: Rlt a x.
        { exact (andEL (Rlt a x) (Rlt x b0) Hconj). }
        claim Hxb: Rlt x b0.
        { exact (andER (Rlt a x) (Rlt x b0) Hconj). }
        claim Haxrel: order_rel R a x.
        { exact (Rlt_implies_order_rel_R a x Hax). }
        claim Hxbrel: order_rel R x b0.
        { exact (Rlt_implies_order_rel_R x b0 Hxb). }
        claim Hconj': order_rel R a x /\ order_rel R x b0.
        { exact (andI (order_rel R a x) (order_rel R x b0) Haxrel Hxbrel). }
        exact (SepI R (fun x0 : set => order_rel R a x0 /\ order_rel R x0 b0) x HxR Hconj').
      - let x. assume HxI: x :e {x0 :e R | order_rel R a x0 /\ order_rel R x0 b0}.
        prove x :e open_interval a b0.
        claim HxR: x :e R.
        { exact (SepE1 R (fun x0 : set => order_rel R a x0 /\ order_rel R x0 b0) x HxI). }
        claim Hconj: order_rel R a x /\ order_rel R x b0.
        { exact (SepE2 R (fun x0 : set => order_rel R a x0 /\ order_rel R x0 b0) x HxI). }
        claim Hax: order_rel R a x.
        { exact (andEL (order_rel R a x) (order_rel R x b0) Hconj). }
        claim Hxb: order_rel R x b0.
        { exact (andER (order_rel R a x) (order_rel R x b0) Hconj). }
        claim Haxlt: Rlt a x.
        { exact (order_rel_R_implies_Rlt a x Hax). }
        claim Hxblt: Rlt x b0.
        { exact (order_rel_R_implies_Rlt x b0 Hxb). }
        claim Hconj': Rlt a x /\ Rlt x b0.
        { exact (andI (Rlt a x) (Rlt x b0) Haxlt Hxblt). }
        exact (SepI R (fun x0 : set => Rlt a x0 /\ Rlt x0 b0) x HxR Hconj'). }

    claim Hpred: exists a1 :e R, exists b1 :e R,
        open_interval a b0 = {x :e R | order_rel R a1 x /\ order_rel R x b1}.
    { witness a.
      apply andI.
      - exact HaR.
      - witness b0.
        apply andI.
        + exact Hb0R.
        + exact HintEq. }

    claim HInA: open_interval a b0 :e A.
    { exact (SepI (Power R)
                 (fun I0 : set => exists a1 :e R, exists b1 :e R,
                    I0 = {x :e R | order_rel R a1 x /\ order_rel R x b1})
                 (open_interval a b0)
                 HPow
                 Hpred). }

    claim HInAB: open_interval a b0 :e (A :\/: B).
    { exact (binunionI1 A B (open_interval a b0) HInA). }
    claim HInABC: open_interval a b0 :e (A :\/: B :\/: C).
    { exact (binunionI1 (A :\/: B) C (open_interval a b0) HInAB). }
    claim HbBasis: open_interval a b0 :e order_topology_basis R.
    { exact HInABC. }
    exact (generated_topology_contains_basis R (order_topology_basis R) (order_topology_basis_is_basis R)
            (open_interval a b0) HbBasis).
  }
  claim Hfiner: finer_than (order_topology R) (generated_topology R R_standard_basis).
  { exact (generated_topology_finer R R_standard_basis (order_topology R) HBasisStd HTord HBsubStd). }
  exact (Hfiner U HU).
Qed.

(** from 14 Example 2: dictionary order topology on  **) 
(** LATEX VERSION: Example 2 defines the dictionary order topology on  via the order topology construction. **)
Definition R2_dictionary_order_topology : set := order_topology (setprod R R).

Theorem dictionary_order_topology_is_topology :
  topology_on (setprod R R) R2_dictionary_order_topology.
prove topology_on (setprod R R) R2_dictionary_order_topology.
(** R2_dictionary_order_topology = order_topology (setprod R R) by definition **)
exact (order_topology_is_topology (setprod R R)).
Qed.

(** from 14 Example 2: rectangle subbasis yields product-style topology **) 
(** LATEX VERSION: Rectangle-type sets give a basis generating the dictionary order topology on . **)
(** NOTE: Current witness uses `order_topology_basis`; rectangle characterization is not yet formalized. **)
Theorem rectangles_basis_for_R2 :
  exists B:set, basis_on (setprod R R) B /\ generated_topology (setprod R R) B = R2_dictionary_order_topology.
prove exists B:set, basis_on (setprod R R) B /\ generated_topology (setprod R R) B = R2_dictionary_order_topology.
witness (order_topology_basis (setprod R R)).
apply andI.
- exact (order_topology_basis_is_basis (setprod R R)).
- reflexivity.
Qed.

(** from 14 Example 3: order topology on  is discrete **)
(** LATEX VERSION: Example 3: The order topology on the positive integers is the discrete topology. **)
Definition Zplus : set := omega :\: {0}.

(** Helper: 0 is not in Zplus **)
(** Uses the definition Zplus = omega :\: {0}. **)
Theorem zero_not_in_Zplus : 0 /:e Zplus.
prove ~(0 :e Zplus).
assume H0: 0 :e Zplus.
prove False.
claim H0m: 0 :e omega :\: {0}.
{ exact H0. }
claim Hcore: 0 :e omega /\ 0 /:e {0}.
{ exact (setminusE omega {0} 0 H0m). }
claim H0not: 0 /:e {0}.
{ exact (andER (0 :e omega) (0 /:e {0}) Hcore). }
exact (H0not (SingI 0)).
Qed.

(** Helper: 1 is in Zplus **)
(** Uses the definition Zplus = omega :\: {0}. **)
Theorem one_in_Zplus : 1 :e Zplus.
prove 1 :e omega :\: {0}.
claim H1omega: 1 :e omega.
{ exact (nat_p_omega 1 nat_1). }
claim H1not0: 1 /:e {0}.
{ assume H1: 1 :e {0}.
  prove False.
  claim Heq: 1 = 0.
  { exact (SingE 0 1 H1). }
  exact (neq_1_0 Heq). }
exact (setminusI omega {0} 1 H1omega H1not0).
Qed.

(** Helper: 2 is in Zplus **)
(** Uses the definition Zplus = omega :\: {0}. **)
Theorem two_in_Zplus : 2 :e Zplus.
prove 2 :e omega :\: {0}.
claim H2omega: 2 :e omega.
{ exact (nat_p_omega 2 nat_2). }
claim H2not0: 2 /:e {0}.
{ assume H2: 2 :e {0}.
  prove False.
  claim Heq: 2 = 0.
  { exact (SingE 0 2 H2). }
  exact (neq_2_0 Heq). }
exact (setminusI omega {0} 2 H2omega H2not0).
Qed.

(** Helper: 0 is in rational_numbers **)
(** Uses the definition rational = {x :e real | exists m :e int, exists n :e omega :\: {0}, x = m :/: n}. **)
Theorem zero_in_rational_numbers : 0 :e rational_numbers.
prove 0 :e rational.
claim H0real: 0 :e real.
{ exact real_0. }
claim H0omega: 0 :e omega.
{ exact (nat_p_omega 0 nat_0). }
claim H0int: 0 :e int.
{ exact (Subq_omega_int 0 H0omega). }
claim H1omega: 1 :e omega.
{ exact (nat_p_omega 1 nat_1). }
claim H1not0: 1 /:e {0}.
{ assume H1: 1 :e {0}.
  prove False.
  claim Heq: 1 = 0.
  { exact (SingE 0 1 H1). }
  exact (neq_1_0 Heq). }
claim H1nonzero: 1 :e omega :\: {0}.
{ exact (setminusI omega {0} 1 H1omega H1not0). }
claim Heq0: 0 = div_SNo 0 1.
{ claim Hdiv: div_SNo 0 1 = 0.
  { exact (div_SNo_0_num 1 SNo_1). }
  rewrite <- Hdiv at 1.
  reflexivity. }
claim Hex: exists m :e int, exists n :e omega :\: {0}, 0 = div_SNo m n.
{ witness 0.
  apply andI.
  - exact H0int.
  - witness 1.
    apply andI.
    + exact H1nonzero.
    + exact Heq0. }
exact (SepI real
            (fun x:set => exists m :e int, exists n :e omega :\: {0}, x = div_SNo m n)
            0
            H0real
            Hex).
Qed.

(** Helper: 1 is in rational_numbers **)
(** Uses the definition rational = {x :e real | exists m :e int, exists n :e omega :\: {0}, x = m :/: n}. **)
Theorem one_in_rational_numbers : 1 :e rational_numbers.
prove 1 :e rational.
claim H1real: 1 :e real.
{ exact real_1. }
claim H1omega: 1 :e omega.
{ exact (nat_p_omega 1 nat_1). }
claim H1int: 1 :e int.
{ exact (Subq_omega_int 1 H1omega). }
claim H1not0: 1 /:e {0}.
{ assume H1: 1 :e {0}.
  prove False.
  claim Heq: 1 = 0.
  { exact (SingE 0 1 H1). }
  exact (neq_1_0 Heq). }
claim H1nonzero: 1 :e omega :\: {0}.
{ exact (setminusI omega {0} 1 H1omega H1not0). }
claim Hrecip1: recip_SNo 1 = 1.
{ claim H1neq0: 1 <> 0.
  { exact neq_1_0. }
  claim Hinv: mul_SNo 1 (recip_SNo 1) = 1.
  { exact (recip_SNo_invR 1 SNo_1 H1neq0). }
  rewrite <- (mul_SNo_oneL (recip_SNo 1) (SNo_recip_SNo 1 SNo_1)) at 1.
  exact Hinv. }
claim Heq1: 1 = div_SNo 1 1.
{ claim Hdivdef: div_SNo 1 1 = mul_SNo 1 (recip_SNo 1).
  { reflexivity. }
  rewrite Hdivdef.
  rewrite Hrecip1.
  rewrite (mul_SNo_oneR 1 SNo_1).
  reflexivity. }
claim Hex: exists m :e int, exists n :e omega :\: {0}, 1 = div_SNo m n.
{ witness 1.
  apply andI.
  - exact H1int.
  - witness 1.
    apply andI.
    + exact H1nonzero.
    + exact Heq1. }
exact (SepI real
            (fun x:set => exists m :e int, exists n :e omega :\: {0}, x = div_SNo m n)
            1
            H1real
            Hex).
Qed.

(** Helper: minus one is in rational_numbers **)
Theorem minus_one_in_rational_numbers : minus_SNo 1 :e rational_numbers.
prove minus_SNo 1 :e rational.
claim HdefQ: rational_numbers = rational.
{ reflexivity. }
claim H1rat: 1 :e rational.
{ rewrite <- HdefQ at 1.
  exact one_in_rational_numbers. }
claim Hm1rat: minus_SNo 1 :e rational.
{ exact (rational_minus_SNo 1 H1rat). }
rewrite <- HdefQ at 1.
exact Hm1rat.
Qed.

(** Helper: minus one is not in omega **)
Theorem minus_one_not_in_omega : minus_SNo 1 /:e omega.
assume Hm1: minus_SNo 1 :e omega.
prove False.
claim Hle0: 0 <= minus_SNo 1.
{ exact (omega_nonneg (minus_SNo 1) Hm1). }
claim Hm1S: SNo (minus_SNo 1).
{ exact (SNo_minus_SNo 1 SNo_1). }
apply (SNoLeE 0 (minus_SNo 1) SNo_0 Hm1S Hle0 False).
- assume H0ltm1: 0 < minus_SNo 1.
  claim Hm1lt0: minus_SNo 1 < 0.
  { exact minus_1_lt_0. }
  claim H00: 0 < 0.
  { exact (SNoLt_tra 0 (minus_SNo 1) 0 SNo_0 Hm1S SNo_0 H0ltm1 Hm1lt0). }
  exact ((SNoLt_irref 0) H00).
- assume H0eqm1: 0 = minus_SNo 1.
  claim Hm1lt0: minus_SNo 1 < 0.
  { exact minus_1_lt_0. }
  claim H00: 0 < 0.
  { rewrite H0eqm1 at 1.
    exact Hm1lt0. }
  exact ((SNoLt_irref 0) H00).
Qed.

(** Helper: rational_numbers is not omega **)
Theorem rational_numbers_neq_omega : rational_numbers <> omega.
assume Heq: rational_numbers = omega.
prove False.
claim Hm1Q: minus_SNo 1 :e rational_numbers.
{ exact minus_one_in_rational_numbers. }
claim Hm1omega: minus_SNo 1 :e omega.
{ rewrite <- Heq.
  exact Hm1Q. }
exact (minus_one_not_in_omega Hm1omega).
Qed.

(** Helper: rational_numbers is not omega minus {0} **)
Theorem rational_numbers_neq_omega_nonzero : rational_numbers <> (omega :\: {0}).
assume Heq: rational_numbers = omega :\: {0}.
prove False.
claim Hm1Q: minus_SNo 1 :e rational_numbers.
{ exact minus_one_in_rational_numbers. }
claim Hm1NZ: minus_SNo 1 :e omega :\: {0}.
{ rewrite <- Heq.
  exact Hm1Q. }
claim Hm1omega: minus_SNo 1 :e omega.
{ exact (setminusE1 omega {0} (minus_SNo 1) Hm1NZ). }
exact (minus_one_not_in_omega Hm1omega).
Qed.

(** Helper: Zplus is not omega **)
Theorem Zplus_neq_omega : Zplus <> omega.
assume Heq: Zplus = omega.
prove False.
claim H0omega: 0 :e omega.
{ exact (nat_p_omega 0 nat_0). }
claim H0Z: 0 :e Zplus.
{ rewrite Heq. exact H0omega. }
exact (zero_not_in_Zplus H0Z).
Qed.

(** Helper: Zplus is not R **)
Theorem Zplus_neq_R : Zplus <> R.
assume Heq: Zplus = R.
prove False.
claim H0R: 0 :e R.
{ exact real_0. }
claim H0Z: 0 :e Zplus.
{ rewrite Heq. exact H0R. }
  exact (zero_not_in_Zplus H0Z).
Qed.

(** Helper: Zplus is not rational_numbers **)
Theorem Zplus_neq_rational_numbers : Zplus <> rational_numbers.
assume Heq: Zplus = rational_numbers.
prove False.
claim H0Q: 0 :e rational_numbers.
{ exact zero_in_rational_numbers. }
	claim H0Z: 0 :e Zplus.
	{ rewrite Heq. exact H0Q. }
	exact (zero_not_in_Zplus H0Z).
Qed.

(** Helper: {1} is not transitive **)
Theorem not_TransSet_singleton_1 : ~ TransSet {1}.
assume H: TransSet {1}.
prove False.
claim H1in: 1 :e {1}.
{ exact (SingI 1). }
claim Hsub: 1 c= {1}.
{ exact (H 1 H1in). }
claim H0in1: 0 :e 1.
{ exact In_0_1. }
claim H0inSing1: 0 :e {1}.
{ exact (Hsub 0 H0in1). }
claim Heq: 0 = 1.
{ exact (SingE 1 0 H0inSing1). }
exact (neq_0_1 Heq).
Qed.

(** Helper: {1} is not in omega **)
Theorem Sing1_not_in_omega : {1} /:e omega.
assume H: {1} :e omega.
prove False.
claim Hnat: nat_p {1}.
{ exact (omega_nat_p {1} H). }
claim Hord: ordinal {1}.
{ exact (nat_p_ordinal {1} Hnat). }
claim Htr: TransSet {1}.
{ exact (ordinal_TransSet {1} Hord). }
exact (not_TransSet_singleton_1 Htr).
Qed.

(** helper: setprod R R is not omega **)
Theorem setprod_R_R_neq_omega : setprod R R <> omega.
assume Heq: setprod R R = omega.
prove False.
claim HpRR: (0,1) :e setprod R R.
{ exact (tuple_2_setprod_by_pair_Sigma R R 0 1 real_0 real_1). }
claim HpOmega: (0,1) :e omega.
{ rewrite <- Heq. exact HpRR. }
claim HSingOmega: {1} :e omega.
{ rewrite <- tuple_0_1_eq_Sing1.
  exact HpOmega. }
exact (Sing1_not_in_omega HSingOmega).
Qed.

(** helper: setprod R R is not omega nonzero **)
Theorem setprod_R_R_neq_omega_nonzero : setprod R R <> (omega :\: {0}).
assume Heq: setprod R R = (omega :\: {0}).
prove False.
claim HpRR: (0,1) :e setprod R R.
{ exact (tuple_2_setprod_by_pair_Sigma R R 0 1 real_0 real_1). }
claim HpNZ: (0,1) :e (omega :\: {0}).
{ rewrite <- Heq. exact HpRR. }
claim Hcore: (0,1) :e omega /\ (0,1) /:e {0}.
{ exact (setminusE omega {0} (0,1) HpNZ). }
claim HpOmega: (0,1) :e omega.
{ exact (andEL ((0,1) :e omega) ((0,1) /:e {0}) Hcore). }
claim HSingOmega: {1} :e omega.
{ rewrite <- tuple_0_1_eq_Sing1.
  exact HpOmega. }
exact (Sing1_not_in_omega HSingOmega).
Qed.

(** helper: setprod 2 omega is not omega **)
Theorem setprod_2_omega_neq_omega : setprod 2 omega <> omega.
assume Heq: setprod 2 omega = omega.
prove False.
claim H1omega: 1 :e omega.
{ exact (nat_p_omega 1 nat_1). }
claim Hp: (0,1) :e setprod 2 omega.
{ exact (tuple_2_setprod_by_pair_Sigma 2 omega 0 1 In_0_2 H1omega). }
claim HpOmega: (0,1) :e omega.
{ rewrite <- Heq. exact Hp. }
claim HSingOmega: {1} :e omega.
{ rewrite <- tuple_0_1_eq_Sing1.
  exact HpOmega. }
exact (Sing1_not_in_omega HSingOmega).
Qed.

(** helper: setprod 2 omega is not omega nonzero **)
Theorem setprod_2_omega_neq_omega_nonzero : setprod 2 omega <> (omega :\: {0}).
assume Heq: setprod 2 omega = (omega :\: {0}).
prove False.
claim H1omega: 1 :e omega.
{ exact (nat_p_omega 1 nat_1). }
claim Hp: (0,1) :e setprod 2 omega.
{ exact (tuple_2_setprod_by_pair_Sigma 2 omega 0 1 In_0_2 H1omega). }
claim HpNZ: (0,1) :e (omega :\: {0}).
{ rewrite <- Heq. exact Hp. }
claim Hcore: (0,1) :e omega /\ (0,1) /:e {0}.
{ exact (setminusE omega {0} (0,1) HpNZ). }
claim HpOmega: (0,1) :e omega.
{ exact (andEL ((0,1) :e omega) ((0,1) /:e {0}) Hcore). }
claim HSingOmega: {1} :e omega.
{ rewrite <- tuple_0_1_eq_Sing1.
  exact HpOmega. }
exact (Sing1_not_in_omega HSingOmega).
Qed.

(** helper: setprod 2 omega is not setprod R R **)
Theorem setprod_2_omega_neq_setprod_R_R : setprod 2 omega <> setprod R R.
assume Heq: setprod 2 omega = setprod R R.
prove False.
apply setprod_R_R_neq_setprod_2_omega.
rewrite <- Heq.
reflexivity.
Qed.

(** helper: setprod 2 omega is not R **)
Theorem setprod_2_omega_neq_R : setprod 2 omega <> R.
assume Heq: setprod 2 omega = R.
prove False.

(** Countability of omega by the identity injection. **)
claim Homega_countable: countable omega.
{ prove atleastp omega omega.
  claim Homega_sub: omega c= omega.
  { let x. assume Hx: x :e omega.
    exact Hx. }
  exact (Subq_atleastp omega omega Homega_sub). }

(** Countability of 2 via 2 c= {0,1} c= omega. **)
claim H01subomega: {0,1} c= omega.
{ let x. assume Hx: x :e {0,1}.
  prove x :e omega.
  apply (UPairE x 0 1 Hx (x :e omega)).
  - assume Hx0: x = 0.
    rewrite Hx0.
    exact (nat_p_omega 0 nat_0).
  - assume Hx1: x = 1.
    rewrite Hx1.
    exact (nat_p_omega 1 nat_1). }
claim H2subomega: 2 c= omega.
{ exact (Subq_tra 2 {0,1} omega Subq_2_UPair01 H01subomega). }
claim H2countable: countable 2.
{ exact (Subq_atleastp 2 omega H2subomega). }

(** Therefore setprod 2 omega is countable. **)
claim Hprod_countable: countable (setprod 2 omega).
{ exact (setprod_countable 2 omega H2countable Homega_countable). }

(** Transfer countability to R by rewriting, contradicting real uncountability. **)
claim HRcountable: countable R.
{ rewrite <- Heq. exact Hprod_countable. }
claim HdefR: R = real.
{ reflexivity. }
claim Hreal_countable: atleastp real omega.
{ rewrite <- HdefR at 1.
  exact HRcountable. }
exact (form100_22_real_uncountable_atleastp Hreal_countable).
Qed.

(** helper: setprod 2 omega is not rational_numbers **)
Theorem setprod_2_omega_neq_rational_numbers : setprod 2 omega <> rational_numbers.
assume Heq: setprod 2 omega = rational_numbers.
prove False.
claim H1omega: 1 :e omega.
{ exact (nat_p_omega 1 nat_1). }
claim Hp: (0,1) :e setprod 2 omega.
{ exact (tuple_2_setprod_by_pair_Sigma 2 omega 0 1 In_0_2 H1omega). }
claim HpQ: (0,1) :e rational_numbers.
{ rewrite <- Heq.
  exact Hp. }
claim HSingQ: {1} :e rational_numbers.
{ rewrite <- tuple_0_1_eq_Sing1.
  exact HpQ. }
claim HSingR: {1} :e R.
{ exact (rational_numbers_in_R {1} HSingQ). }
claim HSingS: SNo {1}.
{ exact (real_SNo {1} HSingR). }
exact (Sing1_not_SNo HSingS).
Qed.

(** helper: rational_numbers is not setprod 2 omega **)
Theorem rational_numbers_neq_setprod_2_omega : rational_numbers <> setprod 2 omega.
assume Heq: rational_numbers = setprod 2 omega.
prove False.
apply setprod_2_omega_neq_rational_numbers.
rewrite <- Heq.
reflexivity.
Qed.

(** helper: rational_numbers is not setprod R R **)
Theorem rational_numbers_neq_setprod_R_R : rational_numbers <> setprod R R.
assume Heq: rational_numbers = setprod R R.
prove False.
apply setprod_R_R_neq_rational_numbers.
rewrite <- Heq.
reflexivity.
Qed.

(** helper: rational_numbers is not R **)
Theorem rational_numbers_neq_R : rational_numbers <> R.
assume Heq: rational_numbers = R.
prove False.
apply R_neq_rational_numbers.
rewrite <- Heq.
reflexivity.
Qed.

(** Helper: order_rel on rational_numbers implies strict order in R **)
(** LATEX VERSION: If order_rel(,a,b) then a<b in  (all other disjuncts contradict known inequalities of carrier sets). **)
Theorem order_rel_Q_implies_Rlt : forall a b:set, order_rel rational_numbers a b -> Rlt a b.
let a b. assume Hrel: order_rel rational_numbers a b.
prove Rlt a b.
apply (Hrel (Rlt a b)).
- assume Hleft.
  apply (Hleft (Rlt a b)).
  - assume Hleft2.
    apply (Hleft2 (Rlt a b)).
    + assume Hleft3.
      apply (Hleft3 (Rlt a b)).
      * assume Hleft4.
        apply (Hleft4 (Rlt a b)).
        - assume HA: rational_numbers = R /\ Rlt a b.
          apply FalseE.
          claim Heq: rational_numbers = R.
          { exact (andEL (rational_numbers = R) (Rlt a b) HA). }
          exact (rational_numbers_neq_R Heq).
        - assume HB: rational_numbers = rational_numbers /\ Rlt a b.
          exact (andER (rational_numbers = rational_numbers) (Rlt a b) HB).
      * assume HC: rational_numbers = omega /\ a :e b.
        apply FalseE.
        claim Heq: rational_numbers = omega.
        { exact (andEL (rational_numbers = omega) (a :e b) HC). }
        exact (rational_numbers_neq_omega Heq).
    + assume HD: rational_numbers = omega :\: {0} /\ a :e b.
      apply FalseE.
      claim Heq: rational_numbers = omega :\: {0}.
      { exact (andEL (rational_numbers = omega :\: {0}) (a :e b) HD). }
      exact (rational_numbers_neq_omega_nonzero Heq).
  - assume HE: rational_numbers = setprod 2 omega /\
      exists i m j n:set,
        i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
        a = (i, m) /\ b = (j, n) /\ (i :e j \/ (i = j /\ m :e n)).
    apply FalseE.
    claim Heq: rational_numbers = setprod 2 omega.
    { exact (andEL (rational_numbers = setprod 2 omega)
                  (exists i m j n:set,
                    i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
                    a = (i, m) /\ b = (j, n) /\ (i :e j \/ (i = j /\ m :e n)))
                  HE). }
    exact (rational_numbers_neq_setprod_2_omega Heq).
- assume HF: rational_numbers = setprod R R /\
    exists a1 a2 b1 b2:set,
      a = (a1, a2) /\ b = (b1, b2) /\
      (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)).
  apply FalseE.
  claim Heq: rational_numbers = setprod R R.
  { exact (andEL (rational_numbers = setprod R R)
                 (exists a1 a2 b1 b2:set,
                   a = (a1, a2) /\ b = (b1, b2) /\
                   (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)))
                 HF). }
  exact (rational_numbers_neq_setprod_R_R Heq).
Qed.

(** helper: unfold order_rel on setprod 2 omega to the dictionary-order case **)
Theorem order_rel_setprod_2_omega_unfold : forall a b:set,
  order_rel (setprod 2 omega) a b ->
  exists i m j n:set,
    (i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
     a = (i, m) /\ b = (j, n) /\ (i :e j \/ (i = j /\ m :e n))).
let a b. assume Hrel: order_rel (setprod 2 omega) a b.
apply (Hrel (exists i m j n:set,
               (i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
                a = (i, m) /\ b = (j, n) /\ (i :e j \/ (i = j /\ m :e n))))).
- assume Hleft.
  apply (Hleft (exists i m j n:set,
                 (i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
                  a = (i, m) /\ b = (j, n) /\ (i :e j \/ (i = j /\ m :e n))))).
  - assume Hmid.
    apply (Hmid (exists i m j n:set,
                   (i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
                    a = (i, m) /\ b = (j, n) /\ (i :e j \/ (i = j /\ m :e n))))).
    + assume Hm2.
      apply (Hm2 (exists i m j n:set,
                    (i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
                     a = (i, m) /\ b = (j, n) /\ (i :e j \/ (i = j /\ m :e n))))).
      - assume Hm3.
        apply (Hm3 (exists i m j n:set,
                      (i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
                       a = (i, m) /\ b = (j, n) /\ (i :e j \/ (i = j /\ m :e n))))).
        - assume Hc1.
          apply FalseE.
          claim Heq: setprod 2 omega = R.
          { exact (andEL (setprod 2 omega = R) (Rlt a b) Hc1). }
          exact (setprod_2_omega_neq_R Heq).
        - assume Hc2.
          apply FalseE.
          claim Heq: setprod 2 omega = rational_numbers.
          { exact (andEL (setprod 2 omega = rational_numbers) (Rlt a b) Hc2). }
          exact (setprod_2_omega_neq_rational_numbers Heq).
      - assume Hc3.
        apply FalseE.
        claim Heq: setprod 2 omega = omega.
        { exact (andEL (setprod 2 omega = omega) (a :e b) Hc3). }
        exact (setprod_2_omega_neq_omega Heq).
    + assume Hc4.
      apply FalseE.
      claim Heq: setprod 2 omega = omega :\: {0}.
      { exact (andEL (setprod 2 omega = omega :\: {0}) (a :e b) Hc4). }
      exact (setprod_2_omega_neq_omega_nonzero Heq).
  - assume Hc5.
    exact (andER (setprod 2 omega = setprod 2 omega)
                 (exists i m j n:set,
                   i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
                   a = (i, m) /\ b = (j, n) /\
                   (i :e j \/ (i = j /\ m :e n)))
                 Hc5).
- assume Hc6.
  apply FalseE.
  claim Heq: setprod 2 omega = setprod R R.
  { exact (andEL (setprod 2 omega = setprod R R)
                (exists a1 a2 b1 b2:set,
                  a = (a1, a2) /\ b = (b1, b2) /\ (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)))
                Hc6). }
  exact (setprod_2_omega_neq_setprod_R_R Heq).
Qed.

(** helper: unfold order_rel on setprod R R to the dictionary-order case **)
Theorem order_rel_setprod_R_R_unfold : forall a b:set,
  order_rel (setprod R R) a b ->
  exists a1 a2 b1 b2:set,
    a = (a1, a2) /\ b = (b1, b2) /\ (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)).
let a b. assume Hrel: order_rel (setprod R R) a b.
apply (Hrel (exists a1 a2 b1 b2:set,
               a = (a1, a2) /\ b = (b1, b2) /\ (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)))).
- assume Hleft.
  apply (Hleft (exists a1 a2 b1 b2:set,
                 a = (a1, a2) /\ b = (b1, b2) /\ (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)))).
  - assume Hmid.
    apply (Hmid (exists a1 a2 b1 b2:set,
                   a = (a1, a2) /\ b = (b1, b2) /\ (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)))).
    + assume Hm2.
      apply (Hm2 (exists a1 a2 b1 b2:set,
                    a = (a1, a2) /\ b = (b1, b2) /\ (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)))).
      - assume Hm3.
        apply (Hm3 (exists a1 a2 b1 b2:set,
                      a = (a1, a2) /\ b = (b1, b2) /\ (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)))).
        - assume Hc1.
          apply FalseE.
          claim Heq: setprod R R = R.
          { exact (andEL (setprod R R = R) (Rlt a b) Hc1). }
          exact (setprod_R_R_neq_R Heq).
        - assume Hc2.
          apply FalseE.
          claim Heq: setprod R R = rational_numbers.
          { exact (andEL (setprod R R = rational_numbers) (Rlt a b) Hc2). }
          exact (setprod_R_R_neq_rational_numbers Heq).
      - assume Hc3.
        apply FalseE.
        claim Heq: setprod R R = omega.
        { exact (andEL (setprod R R = omega) (a :e b) Hc3). }
        exact (setprod_R_R_neq_omega Heq).
    + assume Hc4.
      apply FalseE.
      claim Heq: setprod R R = omega :\: {0}.
      { exact (andEL (setprod R R = omega :\: {0}) (a :e b) Hc4). }
      exact (setprod_R_R_neq_omega_nonzero Heq).
  - assume Hc5.
    apply FalseE.
    claim Heq: setprod R R = setprod 2 omega.
    { exact (andEL (setprod R R = setprod 2 omega)
                  (exists i m j n:set,
                    i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
                    a = (i, m) /\ b = (j, n) /\
                    (i :e j \/ (i = j /\ m :e n)))
                  Hc5). }
    exact (setprod_R_R_neq_setprod_2_omega Heq).
- assume Hc6.
  exact (andER (setprod R R = setprod R R)
               (exists a1 a2 b1 b2:set,
                 a = (a1, a2) /\ b = (b1, b2) /\ (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)))
               Hc6).
Qed.

(** helper: introduce order_rel on RR from the dictionary comparison disjunction **)
Theorem order_rel_setprod_R_R_intro : forall a1 a2 b1 b2:set,
  (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)) ->
  order_rel (setprod R R) (a1, a2) (b1, b2).
let a1 a2 b1 b2.
assume Hdisj.
prove order_rel (setprod R R) (a1, a2) (b1, b2).
prove (setprod R R = R /\ Rlt (a1, a2) (b1, b2))
  \/
  (setprod R R = rational_numbers /\ Rlt (a1, a2) (b1, b2))
  \/
  (setprod R R = omega /\ (a1, a2) :e (b1, b2))
  \/
  (setprod R R = omega :\: {0} /\ (a1, a2) :e (b1, b2))
  \/
  (setprod R R = setprod 2 omega /\
   exists i m j n:set,
     i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
     (a1, a2) = (i, m) /\ (b1, b2) = (j, n) /\
     (i :e j \/ (i = j /\ m :e n)))
  \/
  (setprod R R = setprod R R /\
   exists c1 c2 d1 d2:set,
     (a1, a2) = (c1, c2) /\ (b1, b2) = (d1, d2) /\
     (Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2))).
apply orIR.
prove setprod R R = setprod R R /\
   exists c1 c2 d1 d2:set,
     (a1, a2) = (c1, c2) /\ (b1, b2) = (d1, d2) /\
     (Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2)).
apply andI.
- reflexivity.
- witness a1.
  witness a2.
  witness b1.
  witness b2.
  prove (a1, a2) = (a1, a2) /\ (b1, b2) = (b1, b2) /\
        (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)).
  apply andI.
  + apply andI.
    - reflexivity.
    - reflexivity.
  + exact Hdisj.
Qed.

(** Helper: Zplus is not setprod 2 omega **)
Theorem Zplus_neq_setprod_2_omega : Zplus <> setprod 2 omega.
assume Heq: Zplus = setprod 2 omega.
prove False.
claim H1omega: 1 :e omega.
{ exact (nat_p_omega 1 nat_1). }
claim Hp: (0,1) :e setprod 2 omega.
{ exact (tuple_2_setprod_by_pair_Sigma 2 omega 0 1 In_0_2 H1omega). }
claim HpZ: (0,1) :e Zplus.
{ rewrite Heq. exact Hp. }
claim Hcore: (0,1) :e omega /\ (0,1) /:e {0}.
{ exact (setminusE omega {0} (0,1) HpZ). }
claim HpOmega: (0,1) :e omega.
{ exact (andEL ((0,1) :e omega) ((0,1) /:e {0}) Hcore). }
claim HSingOmega: {1} :e omega.
{ prove {1} :e omega.
  rewrite <- tuple_0_1_eq_Sing1.
  exact HpOmega. }
exact (Sing1_not_in_omega HSingOmega).
Qed.

(** Helper: Zplus is not setprod R R **)
Theorem Zplus_neq_setprod_R_R : Zplus <> setprod R R.
assume Heq: Zplus = setprod R R.
prove False.
claim Hp: (0,1) :e setprod R R.
{ exact (tuple_2_setprod_by_pair_Sigma R R 0 1 real_0 real_1). }
claim HpZ: (0,1) :e Zplus.
{ rewrite Heq. exact Hp. }
claim Hcore: (0,1) :e omega /\ (0,1) /:e {0}.
{ exact (setminusE omega {0} (0,1) HpZ). }
claim HpOmega: (0,1) :e omega.
{ exact (andEL ((0,1) :e omega) ((0,1) /:e {0}) Hcore). }
claim HSingOmega: {1} :e omega.
{ prove {1} :e omega.
  rewrite <- tuple_0_1_eq_Sing1.
  exact HpOmega. }
exact (Sing1_not_in_omega HSingOmega).
Qed.

(** Helper: on Zplus, order_rel is membership order **)
Theorem order_rel_Zplus_iff_mem : forall a b:set,
  a :e Zplus -> b :e Zplus -> (order_rel Zplus a b <-> a :e b).
let a b. assume HaZ HbZ.
apply iffI.
- assume Hrel: order_rel Zplus a b.
  prove a :e b.
  (** eliminate disjunctions in order_rel using Zplus inequalities **)
  apply (Hrel (a :e b)).
  - assume Hleft.
    apply (Hleft (a :e b)).
    - assume Hmid.
      apply (Hmid (a :e b)).
      + assume Hm2.
        apply (Hm2 (a :e b)).
        - assume Hm3.
          apply (Hm3 (a :e b)).
          - assume Hc1.
             apply FalseE.
             claim Heq: Zplus = R.
             { exact (andEL (Zplus = R) (Rlt a b) Hc1). }
             exact (Zplus_neq_R Heq).
          - assume Hc2.
             apply FalseE.
             claim Heq: Zplus = rational_numbers.
             { exact (andEL (Zplus = rational_numbers) (Rlt a b) Hc2). }
             exact (Zplus_neq_rational_numbers Heq).
        - assume Hc3.
          apply FalseE.
          claim Heq: Zplus = omega.
          { exact (andEL (Zplus = omega) (a :e b) Hc3). }
          exact (Zplus_neq_omega Heq).
      + assume Hc4.
        exact (andER (Zplus = omega :\: {0}) (a :e b) Hc4).
    - assume Hc5.
      apply FalseE.
      claim Heq: Zplus = setprod 2 omega.
      { exact (andEL (Zplus = setprod 2 omega)
                    (exists i m j n:set,
                      i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
                      a = (i, m) /\ b = (j, n) /\
                      (i :e j \/ (i = j /\ m :e n)))
                    Hc5). }
      exact (Zplus_neq_setprod_2_omega Heq).
  - assume Hc6.
    apply FalseE.
    claim Heq: Zplus = setprod R R.
    { exact (andEL (Zplus = setprod R R)
                  (exists a1 a2 b1 b2:set,
                    a = (a1, a2) /\ b = (b1, b2) /\
                    (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)))
                  Hc6). }
    exact (Zplus_neq_setprod_R_R Heq).
- assume Hab: a :e b.
  prove order_rel Zplus a b.
  claim Heq: Zplus = omega :\: {0}.
  { reflexivity. }
  rewrite Heq.
  exact (mem_implies_order_rel_omega_nonzero a b Hab).
Qed.

(** Helper: membership in Zplus implies membership in omega **)
Theorem Zplus_mem_omega : forall n:set, n :e Zplus -> n :e omega.
let n. assume Hn: n :e Zplus.
claim Hcore: n :e omega /\ n /:e {0}.
{ exact (setminusE omega {0} n Hn). }
exact (andEL (n :e omega) (n /:e {0}) Hcore).
Qed.

(** Helper: membership in Zplus implies n<>0 **)
Theorem Zplus_mem_nonzero : forall n:set, n :e Zplus -> n <> 0.
let n. assume Hn: n :e Zplus.
assume Heq: n = 0.
prove False.
claim Hcore: n :e omega /\ n /:e {0}.
{ exact (setminusE omega {0} n Hn). }
claim Hnnot0: n /:e {0}.
{ exact (andER (n :e omega) (n /:e {0}) Hcore). }
claim HnIn: n :e {0}.
{ rewrite Heq.
  exact (SingI 0). }
exact (Hnnot0 HnIn).
Qed.

(** Helper: Zplus is a subset of omega **)
Theorem Zplus_Subq_omega : Zplus c= omega.
let n. assume Hn: n :e Zplus.
exact (Zplus_mem_omega n Hn).
Qed.

(** Helper: successor of a Zplus element is again in Zplus **)
Theorem Zplus_ordsucc_closed : forall n:set, n :e Zplus -> ordsucc n :e Zplus.
let n. assume Hn: n :e Zplus.
claim HnOmega: n :e omega.
{ exact (Zplus_mem_omega n Hn). }
claim HsuccOmega: ordsucc n :e omega.
{ exact (omega_ordsucc n HnOmega). }
claim HsuccNot0: ordsucc n /:e {0}.
{ assume H0: ordsucc n :e {0}.
  prove False.
  claim Heq0: ordsucc n = 0.
  { exact (SingE 0 (ordsucc n) H0). }
  exact (neq_ordsucc_0 n Heq0). }
exact (setminusI omega {0} (ordsucc n) HsuccOmega HsuccNot0).
Qed.

(** Helper: singleton sets are basic opens in the order topology basis on Zplus **)
Theorem nat_nonzero_in_Zplus : forall n:set, nat_p n -> n <> 0 -> n :e Zplus.
let n. assume HnNat HnNeq.
prove n :e omega :\: {0}.
claim HnOmega: n :e omega.
{ exact (nat_p_omega n HnNat). }
claim Hnnot0: n /:e {0}.
{ assume Hn0: n :e {0}.
  prove False.
  claim Heq: n = 0.
  { exact (SingE 0 n Hn0). }
  exact (HnNeq Heq). }
exact (setminusI omega {0} n HnOmega Hnnot0).
Qed.

(** Helper: singleton {1} is in the order topology basis on Zplus **)
Theorem singleton_ordsucc0_in_order_topology_basis_Zplus :
  {ordsucc 0} :e order_topology_basis Zplus.
prove {ordsucc 0} :e order_topology_basis Zplus.
(** expand order_topology_basis **)
claim Hdef: order_topology_basis Zplus =
  ({I :e Power Zplus | exists a :e Zplus, exists b :e Zplus,
        I = {x :e Zplus | order_rel Zplus a x /\ order_rel Zplus x b}}
   :\/:
   {I :e Power Zplus | exists b :e Zplus, I = {x :e Zplus | order_rel Zplus x b}}
   :\/:
   {I :e Power Zplus | exists a :e Zplus, I = {x :e Zplus | order_rel Zplus a x}}).
{ reflexivity. }
rewrite Hdef.
(** order_topology_basis Zplus is a union of three families; use lower ray family **)
apply binunionI1.
apply binunionI2.
apply (SepI (Power Zplus)
            (fun I : set => exists b0 :e Zplus, I = {x :e Zplus | order_rel Zplus x b0})
            {ordsucc 0}).
- apply PowerI.
  let x. assume Hx: x :e {ordsucc 0}.
  prove x :e Zplus.
  claim HxEq: x = ordsucc 0.
  { exact (SingE (ordsucc 0) x Hx). }
  rewrite HxEq.
  exact one_in_Zplus.
- witness (ordsucc (ordsucc 0)).
  apply andI.
  - exact two_in_Zplus.
  - prove {ordsucc 0} = {x :e Zplus | order_rel Zplus x (ordsucc (ordsucc 0))}.
    apply set_ext.
    - let x. assume Hx: x :e {ordsucc 0}.
       prove x :e {x :e Zplus | order_rel Zplus x (ordsucc (ordsucc 0))}.
       claim HxEq: x = ordsucc 0.
       { exact (SingE (ordsucc 0) x Hx). }
       apply (SepI Zplus
                   (fun t : set => order_rel Zplus t (ordsucc (ordsucc 0)))
                   x).
       - rewrite HxEq.
         exact one_in_Zplus.
       - rewrite HxEq.
         claim Hmem: ordsucc 0 :e ordsucc (ordsucc 0).
         { exact (ordsuccI2 (ordsucc 0)). }
         exact (iffER (order_rel Zplus (ordsucc 0) (ordsucc (ordsucc 0)))
                      (ordsucc 0 :e ordsucc (ordsucc 0))
                      (order_rel_Zplus_iff_mem (ordsucc 0) (ordsucc (ordsucc 0)) one_in_Zplus two_in_Zplus)
                      Hmem).
    - let x. assume Hx: x :e {x :e Zplus | order_rel Zplus x (ordsucc (ordsucc 0))}.
       prove x :e {ordsucc 0}.
       claim HxZ: x :e Zplus.
       { exact (SepE1 Zplus (fun t : set => order_rel Zplus t (ordsucc (ordsucc 0))) x Hx). }
       claim Hrel: order_rel Zplus x (ordsucc (ordsucc 0)).
       { exact (SepE2 Zplus (fun t : set => order_rel Zplus t (ordsucc (ordsucc 0))) x Hx). }
       claim Hmem: x :e ordsucc (ordsucc 0).
       { exact (iffEL (order_rel Zplus x (ordsucc (ordsucc 0)))
                      (x :e ordsucc (ordsucc 0))
                      (order_rel_Zplus_iff_mem x (ordsucc (ordsucc 0)) HxZ two_in_Zplus)
                      Hrel). }
       claim HxNe0: x <> 0.
       { exact (Zplus_mem_nonzero x HxZ). }
       claim Hcase: x :e ordsucc 0 \/ x = ordsucc 0.
       { exact (ordsuccE (ordsucc 0) x Hmem). }
       claim HxEq1: x = ordsucc 0.
       { apply (Hcase (x = ordsucc 0)).
         - assume HxIn1: x :e ordsucc 0.
           apply FalseE.
           claim Hcase0: x :e 0 \/ x = 0.
           { exact (ordsuccE 0 x HxIn1). }
           claim Hx0: x = 0.
           { apply (Hcase0 (x = 0)).
             + assume HxIn0: x :e 0.
               apply FalseE.
               exact (EmptyE x HxIn0).
             + assume Hx0. exact Hx0. }
           exact (HxNe0 Hx0).
         - assume HxEq. exact HxEq. }
       rewrite HxEq1.
       exact (SingI (ordsucc 0)).
Qed.

(** Helper: singleton of a successor is in the order topology basis on Zplus **)
Theorem singleton_ordsucc_in_order_topology_basis_Zplus : forall m:set,
  m :e Zplus -> {ordsucc m} :e order_topology_basis Zplus.
let m. assume Hm.
prove {ordsucc m} :e order_topology_basis Zplus.
(** expand order_topology_basis **)
claim Hdef: order_topology_basis Zplus =
  ({I :e Power Zplus | exists a :e Zplus, exists b :e Zplus,
        I = {x :e Zplus | order_rel Zplus a x /\ order_rel Zplus x b}}
   :\/:
   {I :e Power Zplus | exists b :e Zplus, I = {x :e Zplus | order_rel Zplus x b}}
   :\/:
   {I :e Power Zplus | exists a :e Zplus, I = {x :e Zplus | order_rel Zplus a x}}).
{ reflexivity. }
rewrite Hdef.
(** use open interval (m, ordsucc (ordsucc m)) in the interval family **)
apply binunionI1.
apply binunionI1.
apply (SepI (Power Zplus)
            (fun I : set =>
               exists a :e Zplus, exists b :e Zplus,
                 I = {x :e Zplus | order_rel Zplus a x /\ order_rel Zplus x b})
            {ordsucc m}).
- apply PowerI.
  let x. assume Hx: x :e {ordsucc m}.
  prove x :e Zplus.
  claim HxEq: x = ordsucc m.
  { exact (SingE (ordsucc m) x Hx). }
  rewrite HxEq.
  exact (Zplus_ordsucc_closed m Hm).
- witness m.
  apply andI.
  - exact Hm.
  - witness (ordsucc (ordsucc m)).
    apply andI.
    - exact (Zplus_ordsucc_closed (ordsucc m) (Zplus_ordsucc_closed m Hm)).
    - prove {ordsucc m} =
        {x :e Zplus | order_rel Zplus m x /\ order_rel Zplus x (ordsucc (ordsucc m))}.
       apply set_ext.
       - let x. assume Hx: x :e {ordsucc m}.
          prove x :e {x :e Zplus | order_rel Zplus m x /\ order_rel Zplus x (ordsucc (ordsucc m))}.
          claim HxEq: x = ordsucc m.
          { exact (SingE (ordsucc m) x Hx). }
          apply (SepI Zplus
                      (fun t : set => order_rel Zplus m t /\ order_rel Zplus t (ordsucc (ordsucc m)))
                      x).
          - rewrite HxEq.
            exact (Zplus_ordsucc_closed m Hm).
          - rewrite HxEq.
            apply andI.
            * claim Hmem1: m :e ordsucc m.
              { exact (ordsuccI2 m). }
              exact (iffER (order_rel Zplus m (ordsucc m))
                           (m :e ordsucc m)
                           (order_rel_Zplus_iff_mem m (ordsucc m) Hm (Zplus_ordsucc_closed m Hm))
                           Hmem1).
            * claim Hmem2: ordsucc m :e ordsucc (ordsucc m).
              { exact (ordsuccI2 (ordsucc m)). }
              exact (iffER (order_rel Zplus (ordsucc m) (ordsucc (ordsucc m)))
                           (ordsucc m :e ordsucc (ordsucc m))
                           (order_rel_Zplus_iff_mem (ordsucc m) (ordsucc (ordsucc m))
                                                    (Zplus_ordsucc_closed m Hm)
                                                    (Zplus_ordsucc_closed (ordsucc m) (Zplus_ordsucc_closed m Hm)))
                           Hmem2).
       - let x. assume Hx: x :e {x :e Zplus | order_rel Zplus m x /\ order_rel Zplus x (ordsucc (ordsucc m))}.
          prove x :e {ordsucc m}.
          claim HxZ: x :e Zplus.
          { exact (SepE1 Zplus
                        (fun t : set => order_rel Zplus m t /\ order_rel Zplus t (ordsucc (ordsucc m)))
                        x
                        Hx). }
          claim Hconj: order_rel Zplus m x /\ order_rel Zplus x (ordsucc (ordsucc m)).
          { exact (SepE2 Zplus
                        (fun t : set => order_rel Zplus m t /\ order_rel Zplus t (ordsucc (ordsucc m)))
                        x
                        Hx). }
          claim Hrel1: order_rel Zplus m x.
          { exact (andEL (order_rel Zplus m x)
                         (order_rel Zplus x (ordsucc (ordsucc m)))
                         Hconj). }
          claim Hrel2: order_rel Zplus x (ordsucc (ordsucc m)).
          { exact (andER (order_rel Zplus m x)
                         (order_rel Zplus x (ordsucc (ordsucc m)))
                         Hconj). }
          claim Hmemb: m :e x.
          { exact (iffEL (order_rel Zplus m x)
                         (m :e x)
                         (order_rel_Zplus_iff_mem m x Hm HxZ)
                         Hrel1). }
          claim HbZ: ordsucc (ordsucc m) :e Zplus.
          { exact (Zplus_ordsucc_closed (ordsucc m) (Zplus_ordsucc_closed m Hm)). }
          claim HxInb: x :e ordsucc (ordsucc m).
          { exact (iffEL (order_rel Zplus x (ordsucc (ordsucc m)))
                         (x :e ordsucc (ordsucc m))
                         (order_rel_Zplus_iff_mem x (ordsucc (ordsucc m)) HxZ HbZ)
                         Hrel2). }
          claim Hcase: x :e ordsucc m \/ x = ordsucc m.
          { exact (ordsuccE (ordsucc m) x HxInb). }
          claim HxEq: x = ordsucc m.
          { apply (Hcase (x = ordsucc m)).
            - assume HxIn1: x :e ordsucc m.
              apply FalseE.
              claim Hcase2: x :e m \/ x = m.
              { exact (ordsuccE m x HxIn1). }
              claim HxInm: x :e m.
              { apply (Hcase2 (x :e m)).
                + assume Hxm. exact Hxm.
                + assume Hxeq.
                  apply FalseE.
                  claim Hmm: m :e m.
                  { prove m :e m.
                    rewrite <- Hxeq at 2.
                    exact Hmemb. }
                  exact (In_irref m Hmm). }
              exact (In_no2cycle m x Hmemb HxInm).
            - assume Hxeq. exact Hxeq. }
          rewrite HxEq.
          exact (SingI (ordsucc m)).
Qed.

Theorem singleton_in_order_topology_basis_Zplus : forall n:set,
  n :e Zplus -> {n} :e order_topology_basis Zplus.
let n. assume HnZ.
claim HnOmega: n :e omega.
{ exact (Zplus_mem_omega n HnZ). }
claim HnNat: nat_p n.
{ exact (omega_nat_p n HnOmega). }
claim HnNeq0: n <> 0.
{ exact (Zplus_mem_nonzero n HnZ). }
claim Hcase: n = 0 \/ exists m:set, nat_p m /\ n = ordsucc m.
{ exact (nat_inv n HnNat). }
apply (Hcase ({n} :e order_topology_basis Zplus)).
- assume Hn0: n = 0.
  prove {n} :e order_topology_basis Zplus.
  apply FalseE.
  exact (HnNeq0 Hn0).
- assume Hex: exists m:set, nat_p m /\ n = ordsucc m.
  apply Hex.
  let m. assume Hmpair.
  apply Hmpair.
  assume HmNat HnEq.
  apply (xm (m = 0)).
  + assume Hm0: m = 0.
    prove {n} :e order_topology_basis Zplus.
    rewrite HnEq.
    rewrite Hm0.
    exact singleton_ordsucc0_in_order_topology_basis_Zplus.
  + assume HmNe0: m <> 0.
    prove {n} :e order_topology_basis Zplus.
    claim HmZ: m :e Zplus.
    { exact (nat_nonzero_in_Zplus m HmNat HmNe0). }
    rewrite HnEq.
    exact (singleton_ordsucc_in_order_topology_basis_Zplus m HmZ).
Qed.

(** Helper: order topology on Zplus is discrete **)
Theorem Zplus_order_topology_is_discrete :
  generated_topology Zplus (order_topology_basis Zplus) = Power Zplus.
prove generated_topology Zplus (order_topology_basis Zplus) = Power Zplus.
apply set_ext.
- let U. assume HU: U :e generated_topology Zplus (order_topology_basis Zplus).
  prove U :e Power Zplus.
  exact (SepE1 (Power Zplus)
               (fun U0 : set => forall x :e U0, exists b :e order_topology_basis Zplus, x :e b /\ b c= U0)
               U HU).
- let U. assume HU: U :e Power Zplus.
  prove U :e generated_topology Zplus (order_topology_basis Zplus).
  prove U :e {U0 :e Power Zplus | forall x :e U0, exists b :e order_topology_basis Zplus, x :e b /\ b c= U0}.
  apply (SepI (Power Zplus)
              (fun U0 : set => forall x :e U0, exists b :e order_topology_basis Zplus, x :e b /\ b c= U0)
              U
              HU).
  claim HUsub: U c= Zplus.
  { exact (PowerE Zplus U HU). }
  let x. assume Hx: x :e U.
  witness {x}.
  apply andI.
  + exact (singleton_in_order_topology_basis_Zplus x (HUsub x Hx)).
  + apply andI.
    * exact (SingI x).
    * let y. assume Hy: y :e {x}.
      prove y :e U.
      claim HyEq: y = x.
      { exact (SingE x y Hy). }
      rewrite HyEq.
      exact Hx.
Qed.

Theorem order_topology_on_Zplus_discrete :
  order_topology Zplus = discrete_topology Zplus.
prove order_topology Zplus = discrete_topology Zplus.
(** Zplus = omega :\: {0} by definition **)
(** order_topology Zplus = generated_topology Zplus (order_topology_basis Zplus) **)
(** discrete_topology Zplus = Power Zplus **)
exact Zplus_order_topology_is_discrete.
Qed.

(** Helper: conjunction reassociation (/\ is left-associative) **)
Theorem and_assoc : forall A B C:prop, (A /\ B) /\ C -> A /\ (B /\ C).
let A B C.
assume H.
apply (H (A /\ (B /\ C))).
assume Hab Hc.
apply (Hab (A /\ (B /\ C))).
assume Ha Hb.
apply andI.
- exact Ha.
- apply andI.
  * exact Hb.
  * exact Hc.
Qed.

Theorem and_assoc_rev : forall A B C:prop, A /\ (B /\ C) -> (A /\ B) /\ C.
let A B C.
assume H.
apply (H ((A /\ B) /\ C)).
assume Ha Hbc.
apply (Hbc ((A /\ B) /\ C)).
assume Hb Hc.
apply andI.
- apply andI.
  * exact Ha.
  * exact Hb.
- exact Hc.
Qed.

(** Helper: eliminate a 7-way conjunction A /\ B /\ C /\ D /\ E /\ F /\ G **)
Theorem and7E : forall A B C D E F G:prop,
  A /\ B /\ C /\ D /\ E /\ F /\ G ->
  forall p:prop, (A -> B -> C -> D -> E -> F -> G -> p) -> p.
let A B C D E F G.
assume H.
let p. assume Hp.
apply (H p).
assume H1 Hg.
apply (H1 p).
assume H2 Hf.
apply (H2 p).
assume H3 He.
apply (H3 p).
assume H4 Hd.
apply (H4 p).
assume H5 Hc.
apply (H5 p).
assume Ha Hb.
exact (Hp Ha Hb Hc Hd He Hf Hg).
Qed.

(** Helper: if a 7-way conjunction ends with a specific disjunctive clause, extract it by one split **)
Theorem conj7_last_disjE : forall i m j n a b:set,
  i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
  a = (i, m) /\ b = (j, n) /\
  (i :e j \/ (i = j /\ m :e n)) ->
  (i :e j \/ (i = j /\ m :e n)).
let i m j n a b.
assume Hcore.
apply Hcore.
assume Hcoords Hlex.
exact Hlex.
Qed.

(** from 14 Example 4: two-row dictionary order space is not discrete **) 
(** LATEX VERSION: Example 4: The dictionary order topology on {1,2} is not discrete. **)
Definition two_by_nat : set := setprod 2 omega.
Definition two_by_nat_order_topology : set := order_topology two_by_nat.

(** helper: singleton {(1,0)} is not a basis element in the order topology basis on two_by_nat **)
Theorem two_by_nat_singleton_not_in_basis :
  {(1,0)} /:e order_topology_basis two_by_nat.
set X := two_by_nat.
set U := {(1,0)}.
assume HU: U :e order_topology_basis X.
prove False.

apply (binunionE' ({I :e Power X | exists a :e X, exists b :e X,
                      I = {x :e X | order_rel X a x /\ order_rel X x b}}
                   :\/:
                   {I :e Power X | exists b :e X,
                      I = {x :e X | order_rel X x b}})
                  {I :e Power X | exists a :e X,
                      I = {x :e X | order_rel X a x}}
                  U
                  False).
- assume HU12: U :e ({I :e Power X | exists a :e X, exists b :e X,
                        I = {x :e X | order_rel X a x /\ order_rel X x b}}
                     :\/:
                     {I :e Power X | exists b :e X,
                        I = {x :e X | order_rel X x b}}).
  apply (binunionE' {I :e Power X | exists a :e X, exists b :e X,
                       I = {x :e X | order_rel X a x /\ order_rel X x b}}
                    {I :e Power X | exists b :e X,
                       I = {x :e X | order_rel X x b}}
                    U
                    False).
		  + assume HU1: U :e {I :e Power X | exists a :e X, exists b :e X,
		                        I = {x :e X | order_rel X a x /\ order_rel X x b}}.
		    claim Hexab: exists a :e X, exists b :e X,
		      U = {x :e X | order_rel X a x /\ order_rel X x b}.
		    { exact (SepE2 (Power X)
		                   (fun I0 : set => exists a :e X, exists b :e X,
		                     I0 = {x :e X | order_rel X a x /\ order_rel X x b})
		                   U
		                   HU1). }
		    apply Hexab.
		    let a. assume HaPair. apply HaPair.
		    assume HaX: a :e X.
		    assume Hexb.
		    apply Hexb.
		    let b. assume HbPair. apply HbPair.
		    assume HbX: b :e X.
		    assume HUeq: U = {x :e X | order_rel X a x /\ order_rel X x b}.

		    claim H10inU: (1,0) :e U.
		    { exact (SingI (1,0)). }
		    claim H10inDef: (1,0) :e {x :e X | order_rel X a x /\ order_rel X x b}.
		    { rewrite <- HUeq.
		      exact H10inU. }
		    claim Hrelconj: order_rel X a (1,0) /\ order_rel X (1,0) b.
		    { exact (SepE2 X (fun x0 : set => order_rel X a x0 /\ order_rel X x0 b) (1,0) H10inDef). }
		    claim HrelL: order_rel X a (1,0).
		    { exact (andEL (order_rel X a (1,0)) (order_rel X (1,0) b) Hrelconj). }
		    claim HrelR: order_rel X (1,0) b.
		    { exact (andER (order_rel X a (1,0)) (order_rel X (1,0) b) Hrelconj). }

		    claim HXeq: X = setprod 2 omega.
		    { reflexivity. }
		    claim HrelL2: order_rel (setprod 2 omega) a (1,0).
		    { prove order_rel (setprod 2 omega) a (1,0).
		      rewrite <- HXeq at 1.
		      exact HrelL. }
		    claim HrelR2: order_rel (setprod 2 omega) (1,0) b.
		    { prove order_rel (setprod 2 omega) (1,0) b.
		      rewrite <- HXeq at 1.
		      exact HrelR. }

		    (** Analyze `a < (1,0)` to get `a = (0,m)` for some m. **)
		    claim HexL: exists i m j n0:set,
		      i :e 2 /\ m :e omega /\ j :e 2 /\ n0 :e omega /\
		      a = (i, m) /\ (1,0) = (j, n0) /\ (i :e j \/ (i = j /\ m :e n0)).
		    { exact (order_rel_setprod_2_omega_unfold a (1,0) HrelL2). }
		    apply HexL.
		    let i. assume HiPair. apply HiPair.
		    let m. assume HmPair. apply HmPair.
		    let j. assume HjPair. apply HjPair.
		    let n0. assume Hcore.

		    claim Hcoords: i :e 2 /\ m :e omega /\ j :e 2 /\ n0 :e omega /\ a = (i, m) /\ (1,0) = (j, n0).
		    { apply Hcore.
		      assume Hcoords0 Hlex0.
		      exact Hcoords0. }
		    claim Hlex: i :e j \/ (i = j /\ m :e n0).
		    { apply Hcore.
		      assume Hcoords0 Hlex0.
		      exact Hlex0. }

		    claim HjnEq: (1,0) = (j, n0).
		    { exact (andER (i :e 2 /\ m :e omega /\ j :e 2 /\ n0 :e omega /\ a = (i, m))
		                   ((1,0) = (j, n0))
		                   Hcoords). }
		    claim Hcoords5: i :e 2 /\ m :e omega /\ j :e 2 /\ n0 :e omega /\ a = (i, m).
		    { exact (andEL (i :e 2 /\ m :e omega /\ j :e 2 /\ n0 :e omega /\ a = (i, m))
		                   ((1,0) = (j, n0))
		                   Hcoords). }

		    claim HaEq2: a = (i, m).
		    { exact (andER (i :e 2 /\ m :e omega /\ j :e 2 /\ n0 :e omega)
		                   (a = (i, m))
		                   Hcoords5). }
		    claim Hcoords4: i :e 2 /\ m :e omega /\ j :e 2 /\ n0 :e omega.
		    { exact (andEL (i :e 2 /\ m :e omega /\ j :e 2 /\ n0 :e omega)
		                   (a = (i, m))
		                   Hcoords5). }

		    claim Hn0Omega: n0 :e omega.
		    { exact (andER (i :e 2 /\ m :e omega /\ j :e 2)
		                   (n0 :e omega)
		                   Hcoords4). }
		    claim Hcoords3: i :e 2 /\ m :e omega /\ j :e 2.
		    { exact (andEL (i :e 2 /\ m :e omega /\ j :e 2)
		                   (n0 :e omega)
		                   Hcoords4). }

		    claim Hj2: j :e 2.
		    { exact (andER (i :e 2 /\ m :e omega)
		                   (j :e 2)
		                   Hcoords3). }
		    claim Hcoords2: i :e 2 /\ m :e omega.
		    { exact (andEL (i :e 2 /\ m :e omega)
		                   (j :e 2)
		                   Hcoords3). }

		    claim Hi2: i :e 2.
		    { exact (andEL (i :e 2) (m :e omega) Hcoords2). }
		    claim HmOmega: m :e omega.
		    { exact (andER (i :e 2) (m :e omega) Hcoords2). }

		    claim HjEq1: j = 1.
		    { prove j = 1.
		      rewrite <- (tuple_2_0_eq j n0) at 1.
		      rewrite <- (tuple_2_0_eq 1 0) at 2.
		      claim Hproj0: (j,n0) 0 = (1,0) 0.
		      { rewrite <- HjnEq. reflexivity. }
		      exact Hproj0. }

		    claim Hn0Eq0: n0 = 0.
		    { prove n0 = 0.
		      rewrite <- (tuple_2_1_eq j n0) at 1.
		      rewrite <- HjnEq at 1.
		      exact (tuple_2_1_eq 1 0). }

		    claim HiEq0: i = 0.
		    { apply (Hlex (i = 0)).
		      - assume Hilj: i :e j.
		        prove i = 0.
		        claim HiIn1: i :e 1.
		        { rewrite <- HjEq1.
		          exact Hilj. }
		        claim HiInSing0: i :e {0}.
		        { rewrite <- eq_1_Sing0.
		          exact HiIn1. }
		        exact (SingE 0 i HiInSing0).
		      - assume Hind: i = j /\ m :e n0.
		        apply FalseE.
		        claim Hmn: m :e n0.
		        { exact (andER (i = j) (m :e n0) Hind). }
		        claim HmIn0: m :e 0.
		        { rewrite <- Hn0Eq0.
		          exact Hmn. }
		        exact (EmptyE m HmIn0). }

		    claim HaEq: a = (0, m).
		    { prove a = (0, m).
		      rewrite HaEq2.
		      rewrite HiEq0.
		      reflexivity. }

		    (** Analyze `(1,0) < b` to get `b = (1,n)` for some n. **)
		    claim HexR: exists i2 m2 j2 n:set,
		      i2 :e 2 /\ m2 :e omega /\ j2 :e 2 /\ n :e omega /\
		      (1,0) = (i2, m2) /\ b = (j2, n) /\ (i2 :e j2 \/ (i2 = j2 /\ m2 :e n)).
		    { exact (order_rel_setprod_2_omega_unfold (1,0) b HrelR2). }
		    apply HexR.
		    let i2. assume Hi2Pair. apply Hi2Pair.
		    let m2. assume Hm2Pair. apply Hm2Pair.
		    let j2. assume Hj2Pair. apply Hj2Pair.
		    let n. assume Hcore2.

		    claim HcoordsR: i2 :e 2 /\ m2 :e omega /\ j2 :e 2 /\ n :e omega /\ (1,0) = (i2, m2) /\ b = (j2, n).
		    { apply Hcore2.
		      assume Hcoords0 Hlex0.
		      exact Hcoords0. }
		    claim HlexR: i2 :e j2 \/ (i2 = j2 /\ m2 :e n).
		    { apply Hcore2.
		      assume Hcoords0 Hlex0.
		      exact Hlex0. }

		    claim HbEq2: b = (j2, n).
		    { exact (andER (i2 :e 2 /\ m2 :e omega /\ j2 :e 2 /\ n :e omega /\ (1,0) = (i2, m2))
		                   (b = (j2, n))
		                   HcoordsR). }
		    claim HcoordsR5: i2 :e 2 /\ m2 :e omega /\ j2 :e 2 /\ n :e omega /\ (1,0) = (i2, m2).
		    { exact (andEL (i2 :e 2 /\ m2 :e omega /\ j2 :e 2 /\ n :e omega /\ (1,0) = (i2, m2))
		                   (b = (j2, n))
		                   HcoordsR). }

		    claim H10EqR: (1,0) = (i2, m2).
		    { exact (andER (i2 :e 2 /\ m2 :e omega /\ j2 :e 2 /\ n :e omega)
		                   ((1,0) = (i2, m2))
		                   HcoordsR5). }
		    claim HcoordsR4: i2 :e 2 /\ m2 :e omega /\ j2 :e 2 /\ n :e omega.
		    { exact (andEL (i2 :e 2 /\ m2 :e omega /\ j2 :e 2 /\ n :e omega)
		                   ((1,0) = (i2, m2))
		                   HcoordsR5). }

		    claim HnOmega: n :e omega.
		    { exact (andER (i2 :e 2 /\ m2 :e omega /\ j2 :e 2)
		                   (n :e omega)
		                   HcoordsR4). }
		    claim HcoordsR3: i2 :e 2 /\ m2 :e omega /\ j2 :e 2.
		    { exact (andEL (i2 :e 2 /\ m2 :e omega /\ j2 :e 2)
		                   (n :e omega)
		                   HcoordsR4). }

		    claim Hj2_2: j2 :e 2.
		    { exact (andER (i2 :e 2 /\ m2 :e omega)
		                   (j2 :e 2)
		                   HcoordsR3). }
		    claim HcoordsR2: i2 :e 2 /\ m2 :e omega.
		    { exact (andEL (i2 :e 2 /\ m2 :e omega)
		                   (j2 :e 2)
		                   HcoordsR3). }

		    claim Hi2Eq1: i2 = 1.
		    { prove i2 = 1.
		      rewrite <- (tuple_2_0_eq i2 m2) at 1.
		      rewrite <- (tuple_2_0_eq 1 0) at 2.
		      claim Hproj0: (i2,m2) 0 = (1,0) 0.
		      { rewrite <- H10EqR. reflexivity. }
		      exact Hproj0. }

		    claim Hj2Eq1: j2 = 1.
		    { apply (HlexR (j2 = 1)).
		      - assume Hilj: i2 :e j2.
		        apply FalseE.
		        claim H1j: 1 :e j2.
		        { rewrite <- Hi2Eq1.
		          exact Hilj. }
		        claim Hsub2: 2 c= {0,1}.
		        { exact Subq_2_UPair01. }
		        claim Hj01: j2 :e {0,1}.
		        { exact (Hsub2 j2 Hj2_2). }
		        apply (UPairE j2 0 1 Hj01 False).
			        + assume Hj0: j2 = 0.
			          claim H1in0: 1 :e 0.
			          { rewrite <- Hj0 at 2.
			            exact H1j. }
			          exact (EmptyE 1 H1in0).
			        + assume Hj1: j2 = 1.
			          claim H1in1: 1 :e 1.
			          { rewrite <- Hj1 at 2.
			            exact H1j. }
			          exact (In_irref 1 H1in1).
		      - assume Hind: i2 = j2 /\ m2 :e n.
		        prove j2 = 1.
		        claim Hij: i2 = j2.
		        { exact (andEL (i2 = j2) (m2 :e n) Hind). }
		        rewrite <- Hij.
		        exact Hi2Eq1. }

			    claim HbEq: b = (1, n).
			    { prove b = (1, n).
			      rewrite HbEq2.
			      rewrite Hj2Eq1.
			      reflexivity. }

		    (** Define a second point in the interval and derive contradiction. **)
		    claim HsuccOmega: ordsucc m :e omega.
		    { exact (omega_ordsucc m HmOmega). }
			    claim H0sX: (0, ordsucc m) :e X.
			    { rewrite HXeq.
			      exact (tuple_2_setprod_by_pair_Sigma 2 omega 0 (ordsucc m) In_0_2 HsuccOmega). }

		    claim H0sL: order_rel X a (0, ordsucc m).
		    { prove order_rel X a (0, ordsucc m).
		      rewrite HXeq at 1.
		      rewrite HaEq.
		      exact (order_rel_setprod_2_omega_0k_0succk m HmOmega). }
		    claim H0sR: order_rel X (0, ordsucc m) b.
		    { prove order_rel X (0, ordsucc m) b.
		      rewrite HXeq at 1.
		      rewrite HbEq.
		      exact (order_rel_setprod_2_omega_0k_1n (ordsucc m) n HsuccOmega HnOmega). }

		    claim H0score: order_rel X a (0, ordsucc m) /\ order_rel X (0, ordsucc m) b.
		    { apply andI.
		      - exact H0sL.
		      - exact H0sR. }
		    claim H0sinDef: (0, ordsucc m) :e {x :e X | order_rel X a x /\ order_rel X x b}.
		    { exact (SepI X (fun x0 : set => order_rel X a x0 /\ order_rel X x0 b) (0, ordsucc m) H0sX H0score). }
		    claim H0sinU: (0, ordsucc m) :e U.
		    { rewrite HUeq.
		      exact H0sinDef. }

		    claim H0sEq10: (0, ordsucc m) = (1,0).
		    { exact (SingE (1,0) (0, ordsucc m) H0sinU). }
		    claim H0Eq1: 0 = 1.
		    { prove 0 = 1.
		      rewrite <- (tuple_2_0_eq 0 (ordsucc m)) at 1.
		      rewrite <- (tuple_2_0_eq 1 0) at 2.
		      claim Hproj0: (0, ordsucc m) 0 = (1,0) 0.
		      { rewrite H0sEq10. reflexivity. }
		      exact Hproj0. }
		    exact (neq_0_1 H0Eq1).
		  + assume HU2: U :e {I :e Power X | exists b :e X,
		                        I = {x :e X | order_rel X x b}}.
		    claim Hexb: exists b :e X, U = {x :e X | order_rel X x b}.
		    { exact (SepE2 (Power X)
		                   (fun I0 : set => exists b :e X, I0 = {x :e X | order_rel X x b})
		                   U
		                   HU2). }
		    apply Hexb.
		    let b. assume HbPair. apply HbPair.
		    assume HbX: b :e X.
		    assume HUeq: U = {x :e X | order_rel X x b}.

		    claim H10inU: (1,0) :e U.
		    { exact (SingI (1,0)). }
		    claim H10inDef: (1,0) :e {x :e X | order_rel X x b}.
		    { rewrite <- HUeq.
		      exact H10inU. }
		    claim Hrel: order_rel X (1,0) b.
		    { exact (SepE2 X (fun x0 : set => order_rel X x0 b) (1,0) H10inDef). }

		    claim HXeq: X = setprod 2 omega.
		    { reflexivity. }
		    claim Hrel2: order_rel (setprod 2 omega) (1,0) b.
		    { prove order_rel (setprod 2 omega) (1,0) b.
		      rewrite <- HXeq at 1.
		      exact Hrel. }

		    claim Hex: exists i m j n:set,
		      i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
		      (1,0) = (i, m) /\ b = (j, n) /\ (i :e j \/ (i = j /\ m :e n)).
		    { exact (order_rel_setprod_2_omega_unfold (1,0) b Hrel2). }
		    apply Hex.
		    let i. assume HiPair. apply HiPair.
		    let m. assume HmPair. apply HmPair.
		    let j. assume HjPair. apply HjPair.
		    let n. assume Hcore.

			    claim Hcoords: i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\ (1,0) = (i, m) /\ b = (j, n).
			    { apply Hcore.
			      assume Hcoords0 Hlex0.
			      exact Hcoords0. }
			    claim Hlex: i :e j \/ (i = j /\ m :e n).
			    { apply Hcore.
			      assume Hcoords0 Hlex0.
			      exact Hlex0. }
			
			    claim HbEq2: b = (j, n).
			    { exact (andER (i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\ (1,0) = (i, m))
			                   (b = (j, n))
			                   Hcoords). }
			    claim Hcoords5: i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\ (1,0) = (i, m).
			    { exact (andEL (i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\ (1,0) = (i, m))
			                   (b = (j, n))
			                   Hcoords). }
			
			    claim H10Eq2: (1,0) = (i, m).
			    { exact (andER (i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega)
			                   ((1,0) = (i, m))
			                   Hcoords5). }
			    claim Hcoords4: i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega.
			    { exact (andEL (i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega)
			                   ((1,0) = (i, m))
			                   Hcoords5). }

		    claim HnOmega: n :e omega.
		    { exact (andER (i :e 2 /\ m :e omega /\ j :e 2)
		                   (n :e omega)
		                   Hcoords4). }
		    claim Hcoords3: i :e 2 /\ m :e omega /\ j :e 2.
		    { exact (andEL (i :e 2 /\ m :e omega /\ j :e 2)
		                   (n :e omega)
		                   Hcoords4). }

		    claim Hj2: j :e 2.
		    { exact (andER (i :e 2 /\ m :e omega)
		                   (j :e 2)
		                   Hcoords3). }
		    claim Hcoords2: i :e 2 /\ m :e omega.
		    { exact (andEL (i :e 2 /\ m :e omega)
		                   (j :e 2)
		                   Hcoords3). }

		    claim Hi2: i :e 2.
		    { exact (andEL (i :e 2) (m :e omega) Hcoords2). }
		    claim HmOmega: m :e omega.
		    { exact (andER (i :e 2) (m :e omega) Hcoords2). }

			    claim HiEq: i = 1.
			    { prove i = 1.
			      rewrite <- (tuple_2_0_eq i m) at 1.
			      rewrite <- (tuple_2_0_eq 1 0) at 2.
			      claim Hproj0: (i,m) 0 = (1,0) 0.
			      { rewrite <- H10Eq2. reflexivity. }
			      exact Hproj0. }
	
			    claim Hj1: j = 1.
			    { apply (Hlex (j = 1)).
		      - assume Hilj: i :e j.
		        apply FalseE.
		        claim H1j: 1 :e j.
		        { rewrite <- HiEq at 1.
		          exact Hilj. }
		        claim Hsub2: 2 c= {0,1}.
		        { exact Subq_2_UPair01. }
		        claim Hj01: j :e {0,1}.
		        { exact (Hsub2 j Hj2). }
		        apply (UPairE j 0 1 Hj01 False).
		        + assume Hj0: j = 0.
		          claim H1in0: 1 :e 0.
		          { rewrite <- Hj0 at 2.
		            exact H1j. }
		          exact (EmptyE 1 H1in0).
		        + assume Hj1': j = 1.
		          claim H1in1: 1 :e 1.
		          { rewrite <- Hj1' at 2.
		            exact H1j. }
		          exact (In_irref 1 H1in1).
		      - assume Hind: i = j /\ m :e n.
		        prove j = 1.
		        claim Hij: i = j.
		        { exact (andEL (i = j) (m :e n) Hind). }
	        rewrite <- Hij at 1.
	        exact HiEq. }

		    claim HbEq: b = (1, n).
		    { prove b = (1, n).
		      rewrite <- Hj1 at 2.
		      exact HbEq2. }

		    claim H0omega: 0 :e omega.
		    { exact (nat_p_omega 0 nat_0). }
    claim H00X: (0,0) :e X.
    { rewrite HXeq.
      exact (tuple_2_setprod_by_pair_Sigma 2 omega 0 0 In_0_2 H0omega). }
		    claim H00rel: order_rel X (0,0) b.
		    { prove order_rel X (0,0) b.
		      rewrite HXeq at 1.
		      rewrite HbEq.
		      exact (order_rel_setprod_2_omega_00_1n n HnOmega). }

		    claim H00inDef: (0,0) :e {x :e X | order_rel X x b}.
		    { exact (SepI X (fun x0 : set => order_rel X x0 b) (0,0) H00X H00rel). }
		    claim H00inU: (0,0) :e U.
		    { rewrite HUeq.
		      exact H00inDef. }

		    claim H00Eq10: (0,0) = (1,0).
		    { exact (SingE (1,0) (0,0) H00inU). }
		    claim H0Eq1: 0 = 1.
		    { prove 0 = 1.
		      rewrite <- (tuple_2_0_eq 0 0) at 1.
		      rewrite <- (tuple_2_0_eq 1 0) at 2.
		      claim Hproj0: (0,0) 0 = (1,0) 0.
		      { rewrite H00Eq10. reflexivity. }
		      exact Hproj0. }
		    exact (neq_0_1 H0Eq1).
	  + exact HU12.
	- assume HU3: U :e {I :e Power X | exists a :e X,
	                      I = {x :e X | order_rel X a x}}.
	  claim Hexa: exists a :e X, U = {x :e X | order_rel X a x}.
	  { exact (SepE2 (Power X)
	                 (fun I0 : set => exists a :e X, I0 = {x :e X | order_rel X a x})
	                 U
	                 HU3). }
	  apply Hexa.
	  let a. assume HaPair. apply HaPair.
	  assume HaX: a :e X.
	  assume HUeq: U = {x :e X | order_rel X a x}.

	  claim H10inU: (1,0) :e U.
	  { exact (SingI (1,0)). }
	  claim H10inDef: (1,0) :e {x :e X | order_rel X a x}.
	  { rewrite <- HUeq.
	    exact H10inU. }
	  claim Hrel: order_rel X a (1,0).
	  { exact (SepE2 X (fun x0 : set => order_rel X a x0) (1,0) H10inDef). }

	  claim HXeq: X = setprod 2 omega.
	  { reflexivity. }
	  claim Hrel2: order_rel (setprod 2 omega) a (1,0).
	  { prove order_rel (setprod 2 omega) a (1,0).
	    rewrite <- HXeq at 1.
	    exact Hrel. }

	  claim Hex: exists i m j n:set,
	    i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
	    a = (i, m) /\ (1,0) = (j, n) /\ (i :e j \/ (i = j /\ m :e n)).
	  { exact (order_rel_setprod_2_omega_unfold a (1,0) Hrel2). }
	  apply Hex.
	  let i. assume HiPair. apply HiPair.
	  let m. assume HmPair. apply HmPair.
	  let j. assume HjPair. apply HjPair.
	  let n. assume Hcore.

	  claim Hcoords: i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\ a = (i, m) /\ (1,0) = (j, n).
	  { apply Hcore.
	    assume Hcoords0 Hlex0.
	    exact Hcoords0. }
	  claim Hlex: i :e j \/ (i = j /\ m :e n).
	  { apply Hcore.
	    assume Hcoords0 Hlex0.
	    exact Hlex0. }

	  claim HjnEq: (1,0) = (j, n).
	  { exact (andER (i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\ a = (i, m))
	                 ((1,0) = (j, n))
	                 Hcoords). }
	  claim Hcoords5: i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\ a = (i, m).
	  { exact (andEL (i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\ a = (i, m))
	                 ((1,0) = (j, n))
	                 Hcoords). }

	  claim HaEq2: a = (i, m).
	  { exact (andER (i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega)
	                 (a = (i, m))
	                 Hcoords5). }
	  claim Hcoords4: i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega.
	  { exact (andEL (i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega)
	                 (a = (i, m))
	                 Hcoords5). }

	  claim HnOmega: n :e omega.
	  { exact (andER (i :e 2 /\ m :e omega /\ j :e 2)
	                 (n :e omega)
	                 Hcoords4). }
	  claim Hcoords3: i :e 2 /\ m :e omega /\ j :e 2.
	  { exact (andEL (i :e 2 /\ m :e omega /\ j :e 2)
	                 (n :e omega)
	                 Hcoords4). }

	  claim Hj2: j :e 2.
	  { exact (andER (i :e 2 /\ m :e omega)
	                 (j :e 2)
	                 Hcoords3). }
	  claim Hcoords2: i :e 2 /\ m :e omega.
	  { exact (andEL (i :e 2 /\ m :e omega)
	                 (j :e 2)
	                 Hcoords3). }

	  claim Hi2: i :e 2.
	  { exact (andEL (i :e 2) (m :e omega) Hcoords2). }
	  claim HmOmega: m :e omega.
	  { exact (andER (i :e 2) (m :e omega) Hcoords2). }

	  claim HjEq1: j = 1.
	  { prove j = 1.
	    rewrite <- (tuple_2_0_eq j n) at 1.
	    rewrite <- (tuple_2_0_eq 1 0) at 2.
	    claim Hproj0: (j,n) 0 = (1,0) 0.
	    { rewrite <- HjnEq. reflexivity. }
	    exact Hproj0. }

		  claim HnEq0: n = 0.
		  { prove n = 0.
		    rewrite <- (tuple_2_1_eq j n) at 1.
		    rewrite <- HjnEq at 1.
		    exact (tuple_2_1_eq 1 0). }

	  claim HiEq0: i = 0.
	  { apply (Hlex (i = 0)).
	    - assume Hilj: i :e j.
		      prove i = 0.
		      claim HiIn1: i :e 1.
		      { rewrite <- HjEq1.
		        exact Hilj. }
		      claim HiInSing0: i :e {0}.
		      { rewrite <- eq_1_Sing0.
		        exact HiIn1. }
		      exact (SingE 0 i HiInSing0).
	    - assume Hind: i = j /\ m :e n.
	      apply FalseE.
	      claim Hmn: m :e n.
	      { exact (andER (i = j) (m :e n) Hind). }
		      claim HmIn0: m :e 0.
		      { rewrite <- HnEq0.
		        exact Hmn. }
	      exact (EmptyE m HmIn0). }

		  claim HaEq: a = (0, m).
		  { prove a = (0, m).
		    rewrite HaEq2.
		    rewrite HiEq0.
		    reflexivity. }

		  claim HsuccOmega: ordsucc m :e omega.
		  { exact (omega_ordsucc m HmOmega). }
			  claim H0sX: (0, ordsucc m) :e X.
			  { rewrite HXeq.
			    exact (tuple_2_setprod_by_pair_Sigma 2 omega 0 (ordsucc m) In_0_2 HsuccOmega). }

		  claim H0srel: order_rel X a (0, ordsucc m).
		  { prove order_rel X a (0, ordsucc m).
		    rewrite HXeq at 1.
		    rewrite HaEq.
		    exact (order_rel_setprod_2_omega_0k_0succk m HmOmega). }

		  claim H0sinDef: (0, ordsucc m) :e {x :e X | order_rel X a x}.
		  { exact (SepI X (fun x0 : set => order_rel X a x0) (0, ordsucc m) H0sX H0srel). }
		  claim H0sinU: (0, ordsucc m) :e U.
		  { rewrite HUeq.
		    exact H0sinDef. }

		  claim H0sEq10: (0, ordsucc m) = (1,0).
		  { exact (SingE (1,0) (0, ordsucc m) H0sinU). }

		  claim H0Eq1: 0 = 1.
		  { prove 0 = 1.
		    rewrite <- (tuple_2_0_eq 0 (ordsucc m)) at 1.
		    rewrite <- (tuple_2_0_eq 1 0) at 2.
		    claim Hproj0: (0, ordsucc m) 0 = (1,0) 0.
		    { rewrite H0sEq10. reflexivity. }
		    exact Hproj0. }
		  exact (neq_0_1 H0Eq1).
	- exact HU.
Qed.

(** Helper: singleton {(1,0)} is not open in two_by_nat order topology **)
Theorem two_by_nat_singleton_not_open :
  ~ ({(1,0)} :e two_by_nat_order_topology).
assume Hopen: {(1,0)} :e two_by_nat_order_topology.
prove False.
set X := two_by_nat.
set B := order_topology_basis X.
set U := {(1,0)}.

(** Unpack generated_topology membership: x in U implies existence of basis neighborhood inside U **)
claim Hneigh: forall x :e U, exists b :e B, x :e b /\ b c= U.
{ exact (SepE2 (Power X)
               (fun U0 : set => forall x :e U0, exists b :e B, x :e b /\ b c= U0)
               U
               Hopen). }

claim HxU: (1,0) :e U.
{ exact (SingI (1,0)). }

claim Hexb: exists b :e B, (1,0) :e b /\ b c= U.
{ exact (Hneigh (1,0) HxU). }
apply Hexb.
let b. assume Hbpair. apply Hbpair.
assume HbB: b :e B.
assume Hbcore: (1,0) :e b /\ b c= U.
claim HbcU: b c= U.
{ exact (andER ((1,0) :e b) (b c= U) Hbcore). }
claim HUcb: U c= b.
{ let y. assume Hy: y :e U.
  prove y :e b.
  claim HyEq: y = (1,0).
  { exact (SingE (1,0) y Hy). }
  rewrite HyEq.
  exact (andEL ((1,0) :e b) (b c= U) Hbcore). }
claim HbeqU: b = U.
{ apply set_ext.
  - let y. assume Hy: y :e b.
    exact (HbcU y Hy).
  - let y. assume Hy: y :e U.
    exact (HUcb y Hy). }

claim HUnotB: U /:e B.
{ exact two_by_nat_singleton_not_in_basis. }

claim HUinB: U :e B.
{ rewrite <- HbeqU. exact HbB. }
exact (HUnotB HUinB).
Qed.

(** LATEX VERSION: The two-by- dictionary order space fails to be discrete. **)
Theorem two_by_nat_not_discrete :
  ~ (two_by_nat_order_topology = discrete_topology two_by_nat).
prove ~ (two_by_nat_order_topology = discrete_topology two_by_nat).
(** Proof by contradiction: assume they're equal **)
assume Heq: two_by_nat_order_topology = discrete_topology two_by_nat.
(** In discrete topology, all singletons are open **)
set singleton_1_0 := {(1,0)}.
claim Hsingleton_in_discrete: singleton_1_0 :e discrete_topology two_by_nat.
{ (** discrete_topology two_by_nat = Power two_by_nat, so any subset is open **)
  (** Need to show singleton_1_0 :e Power two_by_nat **)
  (** This requires singleton_1_0 c= two_by_nat **)
  claim H0omega: 0 :e omega.
  { exact (nat_p_omega 0 nat_0). }
  claim Helem: (1,0) :e two_by_nat.
  { exact (tuple_2_setprod_by_pair_Sigma 2 omega 1 0 In_1_2 H0omega). }
  claim Hsub: singleton_1_0 c= two_by_nat.
  { let y. assume Hy: y :e singleton_1_0.
    prove y :e two_by_nat.
    claim HyEq: y = (1,0).
    { exact (SingE (1,0) y Hy). }
    rewrite HyEq.
    exact Helem. }

  exact (PowerI two_by_nat singleton_1_0 Hsub).
}
claim Hsingleton_in_order: singleton_1_0 :e two_by_nat_order_topology.
{ rewrite Heq. exact Hsingleton_in_discrete. }
(** But this contradicts the axiom **)
exact (two_by_nat_singleton_not_open Hsingleton_in_order).
Qed.

(** from 15 Definition: product topology on XY **) 
(** LATEX VERSION: The product topology on XY is generated by the basis of rectangles UV with U open in X and V open in Y. **)
Definition rectangle_set : set -> set -> set := fun U V => setprod U V.

(** Helper: definitional expansion for rectangle_set **)
Theorem rectangle_set_def : forall U V:set, rectangle_set U V = setprod U V.
let U V.
reflexivity.
Qed.

(** Helper: pairing belongs to rectangle_set **)
Theorem tuple_2_rectangle_set : forall U V:set, forall x y:set,
  x :e U -> y :e V -> (x,y) :e rectangle_set U V.
let U V x y.
assume Hx: x :e U.
assume Hy: y :e V.
prove (x,y) :e rectangle_set U V.
rewrite rectangle_set_def.
rewrite <- (tuple_pair x y) at 1.
exact (pair_Sigma U (fun _ : set => V) x Hx y Hy).
Qed.

(** Helper: surjective pairing for setprod **)
Theorem setprod_eta : forall X Y p:set,
  p :e setprod X Y -> p = (p 0, p 1).
let X Y p.
assume Hp: p :e setprod X Y.
prove p = (p 0, p 1).
apply (Sigma_E X (fun _ : set => Y) p Hp).
let x.
assume Hx_pair.
apply Hx_pair.
assume HxX Hexy.
apply Hexy.
let y.
assume Hy_pair.
apply Hy_pair.
assume HyY Hpeq.
claim HeqT: p = (x,y).
{ prove p = (x,y).
  rewrite <- (tuple_pair x y).
  exact Hpeq. }
claim Hp0: p 0 = x.
{ rewrite HeqT. exact (tuple_2_0_eq x y). }
claim Hp1: p 1 = y.
{ rewrite HeqT. exact (tuple_2_1_eq x y). }
rewrite Hp0.
rewrite Hp1.
exact HeqT.
Qed.

(** Helper: cartesian products preserve subset relation **)
Theorem setprod_Subq : forall U V X Y:set,
  U c= X -> V c= Y -> setprod U V c= setprod X Y.
let U V X Y.
assume HU: U c= X.
assume HV: V c= Y.
prove setprod U V c= setprod X Y.
let p.
assume Hp: p :e setprod U V.
prove p :e setprod X Y.
claim Hp0: p 0 :e U.
{ exact (ap0_Sigma U (fun u => V) p Hp). }
claim Hp1: p 1 :e V.
{ exact (ap1_Sigma U (fun u => V) p Hp). }
claim Hp0X: p 0 :e X.
{ exact (HU (p 0) Hp0). }
claim Hp1Y: p 1 :e Y.
{ exact (HV (p 1) Hp1). }
claim Heta: p = (p 0, p 1).
{ exact (setprod_eta U V p Hp). }
rewrite Heta.
prove (p 0, p 1) :e setprod X Y.
exact (tuple_2_setprod_by_pair_Sigma X Y (p 0) (p 1) Hp0X Hp1Y).
Qed.

(** Helper: elements of cartesian products have coordinates **)
Theorem setprod_elem_decompose : forall X Y p:set,
  p :e setprod X Y ->
  exists x :e X, exists y :e Y, p :e setprod {x} {y}.
let X Y p.
assume Hp: p :e setprod X Y.
claim Hp0X: p 0 :e X.
{ exact (ap0_Sigma X (fun _ : set => Y) p Hp). }
claim Hp1Y: p 1 :e Y.
{ exact (ap1_Sigma X (fun _ : set => Y) p Hp). }
witness (p 0).
apply andI.
- exact Hp0X.
- witness (p 1).
  apply andI.
  * exact Hp1Y.
  * claim Heta: p = (p 0, p 1).
    { exact (setprod_eta X Y p Hp). }
    rewrite Heta at 1.
    exact (tuple_2_setprod_by_pair_Sigma {p 0} {p 1} (p 0) (p 1) (SingI (p 0)) (SingI (p 1))).
Qed.

(** Helper: singleton subset property **)
Theorem singleton_subset : forall x U:set, x :e U -> {x} c= U.
let x U. assume HxU.
prove {x} c= U.
let y. assume Hy: y :e {x}.
prove y :e U.
claim HyEq: y = x.
{ exact (SingE x y Hy). }
rewrite HyEq.
exact HxU.
Qed.

(** Helper: singleton element equality **)
Theorem singleton_elem : forall x y:set, x :e {y} -> x = y.
let x y. assume H.
exact (SingE y x H).
Qed.

(** Helper: coordinates of product elements **)
Theorem setprod_coords_in : forall x y U V p:set,
  p :e setprod {x} {y} -> p :e setprod U V -> x :e U /\ y :e V.
let x y U V p.
assume Hpxy: p :e setprod {x} {y}.
assume HpUV: p :e setprod U V.
prove x :e U /\ y :e V.
claim Hp0x: p 0 :e {x}.
{ exact (ap0_Sigma {x} (fun u => {y}) p Hpxy). }
claim Hp1y: p 1 :e {y}.
{ exact (ap1_Sigma {x} (fun u => {y}) p Hpxy). }
claim Hp0_eq_x: p 0 = x.
{ exact (singleton_elem (p 0) x Hp0x). }
claim Hp1_eq_y: p 1 = y.
{ exact (singleton_elem (p 1) y Hp1y). }
claim Hp0U: p 0 :e U.
{ exact (ap0_Sigma U (fun u => V) p HpUV). }
claim Hp1V: p 1 :e V.
{ exact (ap1_Sigma U (fun u => V) p HpUV). }
apply andI.
- prove x :e U.
  rewrite <- Hp0_eq_x.
  exact Hp0U.
- prove y :e V.
  rewrite <- Hp1_eq_y.
  exact Hp1V.
Qed.

(** Helper: intersection of cartesian products **)
Theorem setprod_intersection : forall U1 V1 U2 V2:set,
  setprod U1 V1 :/\: setprod U2 V2 = setprod (U1 :/\: U2) (V1 :/\: V2).
let U1 V1 U2 V2.
prove setprod U1 V1 :/\: setprod U2 V2 = setprod (U1 :/\: U2) (V1 :/\: V2).
apply set_ext.
- let p. assume Hp: p :e setprod U1 V1 :/\: setprod U2 V2.
  prove p :e setprod (U1 :/\: U2) (V1 :/\: V2).
  claim HpU1V1: p :e setprod U1 V1.
  { exact (binintersectE1 (setprod U1 V1) (setprod U2 V2) p Hp). }
  claim HpU2V2: p :e setprod U2 V2.
  { exact (binintersectE2 (setprod U1 V1) (setprod U2 V2) p Hp). }
  claim Hp0U1: p 0 :e U1.
  { exact (ap0_Sigma U1 (fun u => V1) p HpU1V1). }
  claim Hp1V1: p 1 :e V1.
  { exact (ap1_Sigma U1 (fun u => V1) p HpU1V1). }
  claim Hp0U2: p 0 :e U2.
  { exact (ap0_Sigma U2 (fun u => V2) p HpU2V2). }
  claim Hp1V2: p 1 :e V2.
  { exact (ap1_Sigma U2 (fun u => V2) p HpU2V2). }
  claim Hp0: p 0 :e U1 :/\: U2.
  { exact (binintersectI U1 U2 (p 0) Hp0U1 Hp0U2). }
  claim Hp1: p 1 :e V1 :/\: V2.
  { exact (binintersectI V1 V2 (p 1) Hp1V1 Hp1V2). }
  claim Heta: p = (p 0, p 1).
  { exact (setprod_eta U1 V1 p HpU1V1). }
  rewrite Heta.
  exact (tuple_2_setprod_by_pair_Sigma (U1 :/\: U2) (V1 :/\: V2) (p 0) (p 1) Hp0 Hp1).
- let p. assume Hp: p :e setprod (U1 :/\: U2) (V1 :/\: V2).
  prove p :e setprod U1 V1 :/\: setprod U2 V2.
  claim Hp0: p 0 :e U1 :/\: U2.
  { exact (ap0_Sigma (U1 :/\: U2) (fun u => V1 :/\: V2) p Hp). }
  claim Hp1: p 1 :e V1 :/\: V2.
  { exact (ap1_Sigma (U1 :/\: U2) (fun u => V1 :/\: V2) p Hp). }
  claim Hp0U1: p 0 :e U1.
  { exact (binintersectE1 U1 U2 (p 0) Hp0). }
  claim Hp0U2: p 0 :e U2.
  { exact (binintersectE2 U1 U2 (p 0) Hp0). }
  claim Hp1V1: p 1 :e V1.
  { exact (binintersectE1 V1 V2 (p 1) Hp1). }
  claim Hp1V2: p 1 :e V2.
  { exact (binintersectE2 V1 V2 (p 1) Hp1). }
  claim Heta: p = (p 0, p 1).
  { exact (setprod_eta (U1 :/\: U2) (V1 :/\: V2) p Hp). }
  rewrite Heta.
  apply binintersectI.
  + exact (tuple_2_setprod_by_pair_Sigma U1 V1 (p 0) (p 1) Hp0U1 Hp1V1).
  + exact (tuple_2_setprod_by_pair_Sigma U2 V2 (p 0) (p 1) Hp0U2 Hp1V2).
Qed.

Definition product_subbasis : set -> set -> set -> set -> set :=
  fun X Tx Y Ty =>
    \/_ U :e Tx, {rectangle_set U V|V :e Ty}.

Definition product_topology : set -> set -> set -> set -> set :=
  fun X Tx Y Ty => generated_topology (setprod X Y) (product_subbasis X Tx Y Ty).

(** Helper: product subbasis satisfies basis axioms **)
Theorem product_subbasis_is_basis : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
let X Tx Y Ty.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
prove product_subbasis X Tx Y Ty c= Power (setprod X Y)
  /\ (forall p :e setprod X Y, exists b :e product_subbasis X Tx Y Ty, p :e b)
  /\ (forall b1 :e product_subbasis X Tx Y Ty,
        forall b2 :e product_subbasis X Tx Y Ty,
          forall p:set, p :e b1 -> p :e b2 ->
            exists b3 :e product_subbasis X Tx Y Ty, p :e b3 /\ b3 c= b1 :/\: b2).
apply andI.
- apply andI.
  + (** subset axiom: every rectangle is a subset of XY **)
    let b. assume Hb: b :e product_subbasis X Tx Y Ty.
    prove b :e Power (setprod X Y).
    claim HTxSub: Tx c= Power X.
    { exact (topology_subset_axiom X Tx HTx). }
    claim HTySub: Ty c= Power Y.
    { exact (topology_subset_axiom Y Ty HTy). }
    claim HexU: exists U :e Tx, b :e {rectangle_set U V|V :e Ty}.
    { exact (famunionE Tx (fun U0:set => {rectangle_set U0 V|V :e Ty}) b Hb). }
    apply HexU.
    let U. assume HUconj: U :e Tx /\ b :e {rectangle_set U V|V :e Ty}.
    claim HU: U :e Tx.
    { exact (andEL (U :e Tx) (b :e {rectangle_set U V|V :e Ty}) HUconj). }
    claim HbRepl: b :e {rectangle_set U V|V :e Ty}.
    { exact (andER (U :e Tx) (b :e {rectangle_set U V|V :e Ty}) HUconj). }
    claim HexV: exists V :e Ty, b = rectangle_set U V.
    { exact (ReplE Ty (fun V0:set => rectangle_set U V0) b HbRepl). }
    apply HexV.
    let V. assume HVconj: V :e Ty /\ b = rectangle_set U V.
    claim HV: V :e Ty.
    { exact (andEL (V :e Ty) (b = rectangle_set U V) HVconj). }
    claim Hbeq: b = rectangle_set U V.
    { exact (andER (V :e Ty) (b = rectangle_set U V) HVconj). }
    claim HUpow: U :e Power X.
    { exact (HTxSub U HU). }
    claim HVpow: V :e Power Y.
    { exact (HTySub V HV). }
    claim HUsubX: U c= X.
    { exact (PowerE X U HUpow). }
    claim HVsubY: V c= Y.
    { exact (PowerE Y V HVpow). }
    claim HrectSub: rectangle_set U V c= setprod X Y.
    { exact (setprod_Subq U V X Y HUsubX HVsubY). }
    rewrite Hbeq.
    exact (PowerI (setprod X Y) (rectangle_set U V) HrectSub).
  + (** cover axiom: every p in XY lies in some rectangle in the subbasis **)
    let p. assume Hp: p :e setprod X Y.
    witness (rectangle_set X Y).
    apply andI.
    * prove rectangle_set X Y :e product_subbasis X Tx Y Ty.
      claim HXTx: X :e Tx.
      { exact (topology_has_X X Tx HTx). }
      claim HYTy: Y :e Ty.
      { exact (topology_has_X Y Ty HTy). }
      claim HRfam: rectangle_set X Y :e {rectangle_set X V|V :e Ty}.
      { exact (ReplI Ty (fun V0:set => rectangle_set X V0) Y HYTy). }
      exact (famunionI Tx (fun U0:set => {rectangle_set U0 V|V :e Ty}) X (rectangle_set X Y) HXTx HRfam).
    * (** p is in XY **)
      exact Hp.
- (** refinement axiom: intersection of two rectangles refines to a rectangle **)
  let b1. assume Hb1: b1 :e product_subbasis X Tx Y Ty.
  let b2. assume Hb2: b2 :e product_subbasis X Tx Y Ty.
  let p. assume Hp1: p :e b1.
  assume Hp2: p :e b2.
  claim HexU1: exists U1 :e Tx, b1 :e {rectangle_set U1 V|V :e Ty}.
  { exact (famunionE Tx (fun U0:set => {rectangle_set U0 V|V :e Ty}) b1 Hb1). }
  apply HexU1.
  let U1. assume HU1conj: U1 :e Tx /\ b1 :e {rectangle_set U1 V|V :e Ty}.
  claim HU1: U1 :e Tx.
  { exact (andEL (U1 :e Tx) (b1 :e {rectangle_set U1 V|V :e Ty}) HU1conj). }
  claim Hb1Repl: b1 :e {rectangle_set U1 V|V :e Ty}.
  { exact (andER (U1 :e Tx) (b1 :e {rectangle_set U1 V|V :e Ty}) HU1conj). }
  claim HexV1: exists V1 :e Ty, b1 = rectangle_set U1 V1.
  { exact (ReplE Ty (fun V0:set => rectangle_set U1 V0) b1 Hb1Repl). }
  apply HexV1.
  let V1. assume HV1conj: V1 :e Ty /\ b1 = rectangle_set U1 V1.
  claim HV1: V1 :e Ty.
  { exact (andEL (V1 :e Ty) (b1 = rectangle_set U1 V1) HV1conj). }
  claim Hb1eq: b1 = rectangle_set U1 V1.
  { exact (andER (V1 :e Ty) (b1 = rectangle_set U1 V1) HV1conj). }

  claim HexU2: exists U2 :e Tx, b2 :e {rectangle_set U2 V|V :e Ty}.
  { exact (famunionE Tx (fun U0:set => {rectangle_set U0 V|V :e Ty}) b2 Hb2). }
  apply HexU2.
  let U2. assume HU2conj: U2 :e Tx /\ b2 :e {rectangle_set U2 V|V :e Ty}.
  claim HU2: U2 :e Tx.
  { exact (andEL (U2 :e Tx) (b2 :e {rectangle_set U2 V|V :e Ty}) HU2conj). }
  claim Hb2Repl: b2 :e {rectangle_set U2 V|V :e Ty}.
  { exact (andER (U2 :e Tx) (b2 :e {rectangle_set U2 V|V :e Ty}) HU2conj). }
  claim HexV2: exists V2 :e Ty, b2 = rectangle_set U2 V2.
  { exact (ReplE Ty (fun V0:set => rectangle_set U2 V0) b2 Hb2Repl). }
  apply HexV2.
  let V2. assume HV2conj: V2 :e Ty /\ b2 = rectangle_set U2 V2.
  claim HV2: V2 :e Ty.
  { exact (andEL (V2 :e Ty) (b2 = rectangle_set U2 V2) HV2conj). }
  claim Hb2eq: b2 = rectangle_set U2 V2.
  { exact (andER (V2 :e Ty) (b2 = rectangle_set U2 V2) HV2conj). }

  set b3 := rectangle_set (U1 :/\: U2) (V1 :/\: V2).
  witness b3.
  apply andI.
  + (** b3 in the product subbasis **)
    claim HU12: (U1 :/\: U2) :e Tx.
    { exact (topology_binintersect_closed X Tx U1 U2 HTx HU1 HU2). }
    claim HV12: (V1 :/\: V2) :e Ty.
    { exact (topology_binintersect_closed Y Ty V1 V2 HTy HV1 HV2). }
    claim Hb3fam: rectangle_set (U1 :/\: U2) (V1 :/\: V2) :e {rectangle_set (U1 :/\: U2) V|V :e Ty}.
    { exact (ReplI Ty (fun V0:set => rectangle_set (U1 :/\: U2) V0) (V1 :/\: V2) HV12). }
    exact (famunionI Tx (fun U0:set => {rectangle_set U0 V|V :e Ty}) (U1 :/\: U2) b3 HU12 Hb3fam).
  + (** p in b3 and b3 subset of b1b2 **)
    apply andI.
    * (** membership **)
      claim HpU1V1: p :e rectangle_set U1 V1.
      { rewrite <- Hb1eq.
        exact Hp1. }
      claim HpU2V2: p :e rectangle_set U2 V2.
      { rewrite <- Hb2eq.
        exact Hp2. }
      claim HpInt: p :e (rectangle_set U1 V1) :/\: (rectangle_set U2 V2).
      { exact (binintersectI (rectangle_set U1 V1) (rectangle_set U2 V2) p HpU1V1 HpU2V2). }
      rewrite <- (setprod_intersection U1 V1 U2 V2).
      exact HpInt.
    * (** subset **)
      claim HintEq: b1 :/\: b2 = b3.
      { prove b1 :/\: b2 = b3.
        rewrite Hb1eq.
        rewrite Hb2eq.
        exact (setprod_intersection U1 V1 U2 V2). }
      rewrite HintEq.
      exact (Subq_ref b3).
Qed.

(** from 15: product topology is a topology **)
(** LATEX VERSION: The product topology determined by Tx and Ty satisfies the topology axioms on XY. **)
Theorem product_topology_is_topology : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  topology_on (setprod X Y) (product_topology X Tx Y Ty).
let X Tx Y Ty.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove topology_on (setprod X Y) (product_topology X Tx Y Ty).
(** product_topology X Tx Y Ty = generated_topology (setprod X Y) (product_subbasis X Tx Y Ty) **)
(** Use axiom that product_subbasis forms a basis, then apply lemma_topology_from_basis **)
exact (lemma_topology_from_basis (setprod X Y) (product_subbasis X Tx Y Ty)
         (product_subbasis_is_basis X Tx Y Ty HTx HTy)).
Qed.

(** Definition: product basis from two bases **)
Definition product_basis_from : set -> set -> set :=
  fun Bx By => \/_ U :e Bx, {setprod U V | V :e By}.

(** Helper: product basis generates product topology **)
Theorem product_basis_generates_product_topology : forall X Y Bx By Tx Ty:set,
  basis_on X Bx -> generated_topology X Bx = Tx ->
  basis_on Y By -> generated_topology Y By = Ty ->
  generated_topology (setprod X Y) (product_basis_from Bx By) = product_topology X Tx Y Ty.
let X Y Bx By Tx Ty.
assume HBx_basis: basis_on X Bx.
assume HTx_eq: generated_topology X Bx = Tx.
assume HBy_basis: basis_on Y By.
assume HTy_eq: generated_topology Y By = Ty.
claim HTx: topology_on X Tx.
{ rewrite <- HTx_eq.
  exact (lemma_topology_from_basis X Bx HBx_basis). }
claim HTy: topology_on Y Ty.
{ rewrite <- HTy_eq.
  exact (lemma_topology_from_basis Y By HBy_basis). }
claim HTprod: topology_on (setprod X Y) (product_topology X Tx Y Ty).
{ exact (product_topology_is_topology X Tx Y Ty HTx HTy). }
claim HCsub: forall c :e product_basis_from Bx By, c :e product_topology X Tx Y Ty.
{ let c. assume HcC.
  claim HBprod: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
  { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
  claim HexU: exists U :e Bx, c :e {setprod U V | V :e By}.
  { exact (famunionE Bx (fun U0:set => {setprod U0 V0 | V0 :e By}) c HcC). }
  apply HexU.
  let U. assume HUconj: U :e Bx /\ c :e {setprod U V | V :e By}.
  claim HU: U :e Bx.
  { exact (andEL (U :e Bx) (c :e {setprod U V | V :e By}) HUconj). }
  claim HcRepl: c :e {setprod U V | V :e By}.
  { exact (andER (U :e Bx) (c :e {setprod U V | V :e By}) HUconj). }
  claim HexV: exists V :e By, c = setprod U V.
  { exact (ReplE By (fun V0:set => setprod U V0) c HcRepl). }
  apply HexV.
  let V. assume HVconj: V :e By /\ c = setprod U V.
  claim HV: V :e By.
  { exact (andEL (V :e By) (c = setprod U V) HVconj). }
  claim Hceq: c = setprod U V.
  { exact (andER (V :e By) (c = setprod U V) HVconj). }
  claim HUTx: U :e Tx.
  { rewrite <- HTx_eq.
    exact (generated_topology_contains_basis X Bx HBx_basis U HU). }
  claim HVTy: V :e Ty.
  { rewrite <- HTy_eq.
    exact (generated_topology_contains_basis Y By HBy_basis V HV). }
  claim HcSub: c :e product_subbasis X Tx Y Ty.
  { rewrite Hceq.
    claim Hrepl: rectangle_set U V :e {rectangle_set U W | W :e Ty}.
    { exact (ReplI Ty (fun W:set => rectangle_set U W) V HVTy). }
    exact (famunionI Tx (fun U0:set => {rectangle_set U0 W | W :e Ty}) U (rectangle_set U V) HUTx Hrepl). }
  exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBprod c HcSub). }
claim Href: forall U :e product_topology X Tx Y Ty, forall p :e U,
  exists Cx :e product_basis_from Bx By, p :e Cx /\ Cx c= U.
{ let U. assume HU: U :e product_topology X Tx Y Ty.
  let p. assume Hp: p :e U.
  claim HUprop: forall q :e U, exists b :e product_subbasis X Tx Y Ty, q :e b /\ b c= U.
  { exact (SepE2 (Power (setprod X Y))
                 (fun U0:set => forall q0 :e U0, exists b0 :e product_subbasis X Tx Y Ty, q0 :e b0 /\ b0 c= U0)
                 U HU). }
  claim Hexb: exists b :e product_subbasis X Tx Y Ty, p :e b /\ b c= U.
  { exact (HUprop p Hp). }
  apply Hexb.
  let b. assume Hbpair.
  claim HbSub: b :e product_subbasis X Tx Y Ty.
  { exact (andEL (b :e product_subbasis X Tx Y Ty) (p :e b /\ b c= U) Hbpair). }
  claim Hbprop: p :e b /\ b c= U.
  { exact (andER (b :e product_subbasis X Tx Y Ty) (p :e b /\ b c= U) Hbpair). }
  claim Hpb: p :e b.
  { exact (andEL (p :e b) (b c= U) Hbprop). }
  claim HbsubU: b c= U.
  { exact (andER (p :e b) (b c= U) Hbprop). }
  claim HexU0: exists U0 :e Tx, b :e {rectangle_set U0 V0 | V0 :e Ty}.
  { exact (famunionE Tx (fun U1:set => {rectangle_set U1 V1 | V1 :e Ty}) b HbSub). }
  apply HexU0.
  let U0. assume HU0conj: U0 :e Tx /\ b :e {rectangle_set U0 V0 | V0 :e Ty}.
  claim HU0: U0 :e Tx.
  { exact (andEL (U0 :e Tx) (b :e {rectangle_set U0 V0 | V0 :e Ty}) HU0conj). }
  claim HbRepl: b :e {rectangle_set U0 V0 | V0 :e Ty}.
  { exact (andER (U0 :e Tx) (b :e {rectangle_set U0 V0 | V0 :e Ty}) HU0conj). }
  claim HexV0: exists V0 :e Ty, b = rectangle_set U0 V0.
  { exact (ReplE Ty (fun V1:set => rectangle_set U0 V1) b HbRepl). }
  apply HexV0.
  let V0. assume HV0conj: V0 :e Ty /\ b = rectangle_set U0 V0.
  claim HV0: V0 :e Ty.
  { exact (andEL (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }
  claim Hbeq: b = rectangle_set U0 V0.
  { exact (andER (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }
  claim Hpb0: p :e rectangle_set U0 V0.
  { prove p :e rectangle_set U0 V0.
    rewrite <- Hbeq.
    exact Hpb. }
  claim Hp0U0: p 0 :e U0.
  { exact (ap0_Sigma U0 (fun _ : set => V0) p Hpb0). }
  claim Hp1V0: p 1 :e V0.
  { exact (ap1_Sigma U0 (fun _ : set => V0) p Hpb0). }
  claim HU0gen: U0 :e generated_topology X Bx.
  { rewrite HTx_eq. exact HU0. }
  claim HV0gen: V0 :e generated_topology Y By.
  { rewrite HTy_eq. exact HV0. }
  claim HU0loc: forall x :e U0, exists bx :e Bx, x :e bx /\ bx c= U0.
  { exact (SepE2 (Power X)
                 (fun U1:set => forall x1 :e U1, exists b1 :e Bx, x1 :e b1 /\ b1 c= U1)
                 U0 HU0gen). }
  claim HV0loc: forall y :e V0, exists by :e By, y :e by /\ by c= V0.
  { exact (SepE2 (Power Y)
                 (fun V1:set => forall y1 :e V1, exists b1 :e By, y1 :e b1 /\ b1 c= V1)
                 V0 HV0gen). }
  claim Hexbx: exists bx :e Bx, p 0 :e bx /\ bx c= U0.
  { exact (HU0loc (p 0) Hp0U0). }
  apply Hexbx.
  let bx. assume Hbxpair.
  claim Hbx: bx :e Bx.
  { exact (andEL (bx :e Bx) (p 0 :e bx /\ bx c= U0) Hbxpair). }
  claim Hbxprop: p 0 :e bx /\ bx c= U0.
  { exact (andER (bx :e Bx) (p 0 :e bx /\ bx c= U0) Hbxpair). }
  claim Hp0bx: p 0 :e bx.
  { exact (andEL (p 0 :e bx) (bx c= U0) Hbxprop). }
  claim Hbxsub: bx c= U0.
  { exact (andER (p 0 :e bx) (bx c= U0) Hbxprop). }
  claim Hexby: exists by :e By, p 1 :e by /\ by c= V0.
  { exact (HV0loc (p 1) Hp1V0). }
  apply Hexby.
  let by. assume Hbypair.
  claim Hby: by :e By.
  { exact (andEL (by :e By) (p 1 :e by /\ by c= V0) Hbypair). }
  claim Hbyprop: p 1 :e by /\ by c= V0.
  { exact (andER (by :e By) (p 1 :e by /\ by c= V0) Hbypair). }
  claim Hp1by: p 1 :e by.
  { exact (andEL (p 1 :e by) (by c= V0) Hbyprop). }
  claim Hbysub: by c= V0.
  { exact (andER (p 1 :e by) (by c= V0) Hbyprop). }
  witness (setprod bx by).
  apply andI.
  - (** membership in product_basis_from **)
    claim Hrepl: setprod bx by :e {setprod bx w | w :e By}.
    { exact (ReplI By (fun w:set => setprod bx w) by Hby). }
    exact (famunionI Bx (fun u:set => {setprod u w | w :e By}) bx (setprod bx by) Hbx Hrepl).
  - apply andI.
    + (** p in setprod bx by **)
      claim Heta: p = (p 0, p 1).
      { exact (setprod_eta U0 V0 p Hpb0). }
      rewrite Heta.
      exact (tuple_2_setprod_by_pair_Sigma bx by (p 0) (p 1) Hp0bx Hp1by).
    + (** subset **)
      claim Hsubbb: setprod bx by c= setprod U0 V0.
      { exact (setprod_Subq bx by U0 V0 Hbxsub Hbysub). }
      claim HsubbU: setprod U0 V0 c= U.
      { rewrite <- Hbeq. exact HbsubU. }
      exact (Subq_tra (setprod bx by) (setprod U0 V0) U Hsubbb HsubbU). }
apply (andER (basis_on (setprod X Y) (product_basis_from Bx By))
             (generated_topology (setprod X Y) (product_basis_from Bx By) = product_topology X Tx Y Ty)
             (basis_refines_topology (setprod X Y) (product_topology X Tx Y Ty) (product_basis_from Bx By) HTprod HCsub Href)).
Qed.

(** Helper: product_basis_from is a basis on the product **)
Theorem product_basis_from_is_basis_on : forall X Y Bx By Tx Ty:set,
  basis_on X Bx -> generated_topology X Bx = Tx ->
  basis_on Y By -> generated_topology Y By = Ty ->
  basis_on (setprod X Y) (product_basis_from Bx By).
let X Y Bx By Tx Ty.
assume HBx_basis: basis_on X Bx.
assume HTx_eq: generated_topology X Bx = Tx.
assume HBy_basis: basis_on Y By.
assume HTy_eq: generated_topology Y By = Ty.
claim HTx: topology_on X Tx.
{ rewrite <- HTx_eq.
  exact (lemma_topology_from_basis X Bx HBx_basis). }
claim HTy: topology_on Y Ty.
{ rewrite <- HTy_eq.
  exact (lemma_topology_from_basis Y By HBy_basis). }
claim HTprod: topology_on (setprod X Y) (product_topology X Tx Y Ty).
{ exact (product_topology_is_topology X Tx Y Ty HTx HTy). }
claim HCsub: forall c :e product_basis_from Bx By, c :e product_topology X Tx Y Ty.
{ let c. assume HcC.
  claim HBprod: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
  { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
  claim HexU: exists U :e Bx, c :e {setprod U V | V :e By}.
  { exact (famunionE Bx (fun U0:set => {setprod U0 V0 | V0 :e By}) c HcC). }
  apply HexU.
  let U. assume HUconj: U :e Bx /\ c :e {setprod U V | V :e By}.
  claim HU: U :e Bx.
  { exact (andEL (U :e Bx) (c :e {setprod U V | V :e By}) HUconj). }
  claim HcRepl: c :e {setprod U V | V :e By}.
  { exact (andER (U :e Bx) (c :e {setprod U V | V :e By}) HUconj). }
  claim HexV: exists V :e By, c = setprod U V.
  { exact (ReplE By (fun V0:set => setprod U V0) c HcRepl). }
  apply HexV.
  let V. assume HVconj: V :e By /\ c = setprod U V.
  claim HV: V :e By.
  { exact (andEL (V :e By) (c = setprod U V) HVconj). }
  claim Hceq: c = setprod U V.
  { exact (andER (V :e By) (c = setprod U V) HVconj). }
  claim HUTx: U :e Tx.
  { rewrite <- HTx_eq.
    exact (generated_topology_contains_basis X Bx HBx_basis U HU). }
  claim HVTy: V :e Ty.
  { rewrite <- HTy_eq.
    exact (generated_topology_contains_basis Y By HBy_basis V HV). }
  claim HcSub: c :e product_subbasis X Tx Y Ty.
  { rewrite Hceq.
    claim Hrepl: rectangle_set U V :e {rectangle_set U W | W :e Ty}.
    { exact (ReplI Ty (fun W:set => rectangle_set U W) V HVTy). }
    exact (famunionI Tx (fun U0:set => {rectangle_set U0 W | W :e Ty}) U (rectangle_set U V) HUTx Hrepl). }
  exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBprod c HcSub). }
claim Href: forall U :e product_topology X Tx Y Ty, forall p :e U,
  exists Cx :e product_basis_from Bx By, p :e Cx /\ Cx c= U.
{ let U. assume HU: U :e product_topology X Tx Y Ty.
  let p. assume Hp: p :e U.
  claim HUprop: forall q :e U, exists b :e product_subbasis X Tx Y Ty, q :e b /\ b c= U.
  { exact (SepE2 (Power (setprod X Y))
                 (fun U0:set => forall q0 :e U0, exists b0 :e product_subbasis X Tx Y Ty, q0 :e b0 /\ b0 c= U0)
                 U HU). }
  claim Hexb: exists b :e product_subbasis X Tx Y Ty, p :e b /\ b c= U.
  { exact (HUprop p Hp). }
  apply Hexb.
  let b. assume Hbpair.
  claim HbSub: b :e product_subbasis X Tx Y Ty.
  { exact (andEL (b :e product_subbasis X Tx Y Ty) (p :e b /\ b c= U) Hbpair). }
  claim Hbprop: p :e b /\ b c= U.
  { exact (andER (b :e product_subbasis X Tx Y Ty) (p :e b /\ b c= U) Hbpair). }
  claim Hpb: p :e b.
  { exact (andEL (p :e b) (b c= U) Hbprop). }
  claim HbsubU: b c= U.
  { exact (andER (p :e b) (b c= U) Hbprop). }
  claim HexU0: exists U0 :e Tx, b :e {rectangle_set U0 V0 | V0 :e Ty}.
  { exact (famunionE Tx (fun U1:set => {rectangle_set U1 V1 | V1 :e Ty}) b HbSub). }
  apply HexU0.
  let U0. assume HU0conj: U0 :e Tx /\ b :e {rectangle_set U0 V0 | V0 :e Ty}.
  claim HU0: U0 :e Tx.
  { exact (andEL (U0 :e Tx) (b :e {rectangle_set U0 V0 | V0 :e Ty}) HU0conj). }
  claim HbRepl: b :e {rectangle_set U0 V0 | V0 :e Ty}.
  { exact (andER (U0 :e Tx) (b :e {rectangle_set U0 V0 | V0 :e Ty}) HU0conj). }
  claim HexV0: exists V0 :e Ty, b = rectangle_set U0 V0.
  { exact (ReplE Ty (fun V1:set => rectangle_set U0 V1) b HbRepl). }
  apply HexV0.
  let V0. assume HV0conj: V0 :e Ty /\ b = rectangle_set U0 V0.
  claim HV0: V0 :e Ty.
  { exact (andEL (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }
  claim Hbeq: b = rectangle_set U0 V0.
  { exact (andER (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }
  claim Hpb0: p :e rectangle_set U0 V0.
  { prove p :e rectangle_set U0 V0.
    rewrite <- Hbeq.
    exact Hpb. }
  claim Hp0U0: p 0 :e U0.
  { exact (ap0_Sigma U0 (fun _ : set => V0) p Hpb0). }
  claim Hp1V0: p 1 :e V0.
  { exact (ap1_Sigma U0 (fun _ : set => V0) p Hpb0). }
  claim HU0gen: U0 :e generated_topology X Bx.
  { rewrite HTx_eq. exact HU0. }
  claim HV0gen: V0 :e generated_topology Y By.
  { rewrite HTy_eq. exact HV0. }
  claim HU0loc: forall x :e U0, exists bx :e Bx, x :e bx /\ bx c= U0.
  { exact (SepE2 (Power X)
                 (fun U1:set => forall x1 :e U1, exists b1 :e Bx, x1 :e b1 /\ b1 c= U1)
                 U0 HU0gen). }
  claim HV0loc: forall y :e V0, exists by :e By, y :e by /\ by c= V0.
  { exact (SepE2 (Power Y)
                 (fun V1:set => forall y1 :e V1, exists b1 :e By, y1 :e b1 /\ b1 c= V1)
                 V0 HV0gen). }
  claim Hexbx: exists bx :e Bx, p 0 :e bx /\ bx c= U0.
  { exact (HU0loc (p 0) Hp0U0). }
  apply Hexbx.
  let bx. assume Hbxpair.
  claim Hbx: bx :e Bx.
  { exact (andEL (bx :e Bx) (p 0 :e bx /\ bx c= U0) Hbxpair). }
  claim Hbxprop: p 0 :e bx /\ bx c= U0.
  { exact (andER (bx :e Bx) (p 0 :e bx /\ bx c= U0) Hbxpair). }
  claim Hp0bx: p 0 :e bx.
  { exact (andEL (p 0 :e bx) (bx c= U0) Hbxprop). }
  claim Hbxsub: bx c= U0.
  { exact (andER (p 0 :e bx) (bx c= U0) Hbxprop). }
  claim Hexby: exists by :e By, p 1 :e by /\ by c= V0.
  { exact (HV0loc (p 1) Hp1V0). }
  apply Hexby.
  let by. assume Hbypair.
  claim Hby: by :e By.
  { exact (andEL (by :e By) (p 1 :e by /\ by c= V0) Hbypair). }
  claim Hbyprop: p 1 :e by /\ by c= V0.
  { exact (andER (by :e By) (p 1 :e by /\ by c= V0) Hbypair). }
  claim Hp1by: p 1 :e by.
  { exact (andEL (p 1 :e by) (by c= V0) Hbyprop). }
  claim Hbysub: by c= V0.
  { exact (andER (p 1 :e by) (by c= V0) Hbyprop). }
  witness (setprod bx by).
  apply andI.
  - claim Hrepl: setprod bx by :e {setprod bx w | w :e By}.
    { exact (ReplI By (fun w:set => setprod bx w) by Hby). }
    exact (famunionI Bx (fun u:set => {setprod u w | w :e By}) bx (setprod bx by) Hbx Hrepl).
  - apply andI.
    + claim Heta: p = (p 0, p 1).
      { exact (setprod_eta U0 V0 p Hpb0). }
      rewrite Heta.
      exact (tuple_2_setprod_by_pair_Sigma bx by (p 0) (p 1) Hp0bx Hp1by).
    + claim Hsubbb: setprod bx by c= setprod U0 V0.
      { exact (setprod_Subq bx by U0 V0 Hbxsub Hbysub). }
      claim HsubbU: setprod U0 V0 c= U.
      { rewrite <- Hbeq. exact HbsubU. }
      exact (Subq_tra (setprod bx by) (setprod U0 V0) U Hsubbb HsubbU). }
exact (andEL (basis_on (setprod X Y) (product_basis_from Bx By))
             (generated_topology (setprod X Y) (product_basis_from Bx By) = product_topology X Tx Y Ty)
             (basis_refines_topology (setprod X Y) (product_topology X Tx Y Ty) (product_basis_from Bx By) HTprod HCsub Href)).
Qed.

(** from 15 Theorem: basis of products of basis elements **)
(** LATEX VERSION: If Bx, By are bases for Tx, Ty, then the collection {UV|UBx, VBy} is a basis generating the product topology. **)
Theorem product_basis_generates :
  forall X Tx Y Ty Bx By:set,
    basis_on X Bx /\ generated_topology X Bx = Tx ->
    basis_on Y By /\ generated_topology Y By = Ty ->
    exists B:set,
      basis_on (setprod X Y) B /\
      (forall U :e Bx, forall V :e By, setprod U V :e B) /\
  generated_topology (setprod X Y) B = product_topology X Tx Y Ty.
let X Tx Y Ty Bx By.
assume HBx: basis_on X Bx /\ generated_topology X Bx = Tx.
assume HBy: basis_on Y By /\ generated_topology Y By = Ty.
prove exists B:set,
      basis_on (setprod X Y) B /\
      (forall U :e Bx, forall V :e By, setprod U V :e B) /\
  generated_topology (setprod X Y) B = product_topology X Tx Y Ty.
(** Witness B = product_basis_from Bx By = {UV | UBx, VBy} **)
witness (product_basis_from Bx By).
prove basis_on (setprod X Y) (product_basis_from Bx By) /\
      (forall U :e Bx, forall V :e By, setprod U V :e product_basis_from Bx By) /\
  generated_topology (setprod X Y) (product_basis_from Bx By) = product_topology X Tx Y Ty.
apply andI.
- (** Part 1 & 2: product_basis_from Bx By is a basis and contains all UV **)
  apply andI.
  + (** Prove basis_on (setprod X Y) (product_basis_from Bx By) **)
    (** Extract properties from assumptions **)
    claim HBx_basis: basis_on X Bx.
    { exact (andEL (basis_on X Bx) (generated_topology X Bx = Tx) HBx). }
    claim HBy_basis: basis_on Y By.
    { exact (andEL (basis_on Y By) (generated_topology Y By = Ty) HBy). }
    (** Verify three basis axioms for product_basis_from Bx By **)
    prove product_basis_from Bx By c= Power (setprod X Y)
      /\ (forall p :e setprod X Y, exists b :e product_basis_from Bx By, p :e b)
      /\ (forall b1 :e product_basis_from Bx By, forall b2 :e product_basis_from Bx By, forall p:set,
            p :e b1 -> p :e b2 -> exists b3 :e product_basis_from Bx By, p :e b3 /\ b3 c= b1 :/\: b2).
    (** Left-associative structure: (Axiom1 /\ Axiom2) /\ Axiom3 **)
    apply andI.
    * (** Prove Axiom1 /\ Axiom2 **)
      apply andI.
      - (** Axiom 1: product_basis_from Bx By c= Power (setprod X Y) **)
        let b. assume Hb: b :e product_basis_from Bx By.
        prove b :e Power (setprod X Y).
        (** b is in the family union, so b = setprod U V for some U :e Bx, V :e By **)
        claim Hexists: exists U :e Bx, b :e {setprod U V' | V' :e By}.
        { exact (famunionE Bx (fun U' => {setprod U' V' | V' :e By}) b Hb). }
        apply Hexists.
        let U. assume HU_conj: U :e Bx /\ b :e {setprod U V' | V' :e By}.
        claim HU: U :e Bx.
        { exact (andEL (U :e Bx) (b :e {setprod U V' | V' :e By}) HU_conj). }
        claim HbRepl: b :e {setprod U V' | V' :e By}.
        { exact (andER (U :e Bx) (b :e {setprod U V' | V' :e By}) HU_conj). }
        (** b :e {setprod U V' | V' :e By}, so b = setprod U V for some V :e By **)
        claim Hexists2: exists V :e By, b = setprod U V.
        { exact (ReplE By (fun V' => setprod U V') b HbRepl). }
        apply Hexists2.
        let V. assume HV_conj: V :e By /\ b = setprod U V.
        claim HV: V :e By.
        { exact (andEL (V :e By) (b = setprod U V) HV_conj). }
        claim Hbeq: b = setprod U V.
        { exact (andER (V :e By) (b = setprod U V) HV_conj). }
        (** Now show setprod U V :e Power (setprod X Y) **)
        (** Need U c= X and V c= Y **)
        claim HBx_sub: Bx c= Power X.
        { exact (andEL (Bx c= Power X) (forall x :e X, exists b :e Bx, x :e b) (andEL (Bx c= Power X /\ (forall x :e X, exists b :e Bx, x :e b)) (forall b1 :e Bx, forall b2 :e Bx, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e Bx, x :e b3 /\ b3 c= b1 :/\: b2) HBx_basis)). }
        claim HBy_sub: By c= Power Y.
        { exact (andEL (By c= Power Y) (forall y :e Y, exists b :e By, y :e b) (andEL (By c= Power Y /\ (forall y :e Y, exists b :e By, y :e b)) (forall b1 :e By, forall b2 :e By, forall y:set, y :e b1 -> y :e b2 -> exists b3 :e By, y :e b3 /\ b3 c= b1 :/\: b2) HBy_basis)). }
        claim HUsubX: U c= X.
        { exact (PowerE X U (HBx_sub U HU)). }
        claim HVsubY: V c= Y.
        { exact (PowerE Y V (HBy_sub V HV)). }
        claim HUVsub: setprod U V c= setprod X Y.
        { exact (setprod_Subq U V X Y HUsubX HVsubY). }
        (** Since b = setprod U V, we have b c= setprod X Y **)
        claim Hbsub: b c= setprod X Y.
        { rewrite Hbeq. exact HUVsub. }
        exact (PowerI (setprod X Y) b Hbsub).
      - (** Axiom 2: covering - every (x,y) is in some UV **)
        let p. assume Hp: p :e setprod X Y.
        prove exists b :e product_basis_from Bx By, p :e b.
        (** Use setprod_elem_decompose to extract coordinates **)
        claim Hcoords: exists x :e X, exists y :e Y, p :e setprod {x} {y}.
        { exact (setprod_elem_decompose X Y p Hp). }
        apply Hcoords.
        let x. assume Hx_conj: x :e X /\ exists y :e Y, p :e setprod {x} {y}.
        claim Hx: x :e X.
        { exact (andEL (x :e X) (exists y :e Y, p :e setprod {x} {y}) Hx_conj). }
        claim Hy_exists: exists y :e Y, p :e setprod {x} {y}.
        { exact (andER (x :e X) (exists y :e Y, p :e setprod {x} {y}) Hx_conj). }
        apply Hy_exists.
        let y. assume Hy_conj: y :e Y /\ p :e setprod {x} {y}.
        claim Hy: y :e Y.
        { exact (andEL (y :e Y) (p :e setprod {x} {y}) Hy_conj). }
        claim Hp_sing: p :e setprod {x} {y}.
        { exact (andER (y :e Y) (p :e setprod {x} {y}) Hy_conj). }
        (** Use covering property of Bx to find U containing x **)
        claim HBx_cover: forall x' :e X, exists U :e Bx, x' :e U.
        { exact (andER (Bx c= Power X) (forall x' :e X, exists U :e Bx, x' :e U)
                       (andEL (Bx c= Power X /\ (forall x' :e X, exists U :e Bx, x' :e U))
                              (forall b1 :e Bx, forall b2 :e Bx, forall x':set, x' :e b1 -> x' :e b2 -> exists b3 :e Bx, x' :e b3 /\ b3 c= b1 :/\: b2)
                              HBx_basis)). }
        claim HU_exists: exists U :e Bx, x :e U.
        { exact (HBx_cover x Hx). }
        apply HU_exists.
        let U. assume HU_conj: U :e Bx /\ x :e U.
        claim HU: U :e Bx.
        { exact (andEL (U :e Bx) (x :e U) HU_conj). }
        claim Hx_in_U: x :e U.
        { exact (andER (U :e Bx) (x :e U) HU_conj). }
        (** Use covering property of By to find V containing y **)
        claim HBy_cover: forall y' :e Y, exists V :e By, y' :e V.
        { exact (andER (By c= Power Y) (forall y' :e Y, exists V :e By, y' :e V)
                       (andEL (By c= Power Y /\ (forall y' :e Y, exists V :e By, y' :e V))
                              (forall b1 :e By, forall b2 :e By, forall y':set, y' :e b1 -> y' :e b2 -> exists b3 :e By, y' :e b3 /\ b3 c= b1 :/\: b2)
                              HBy_basis)). }
        claim HV_exists: exists V :e By, y :e V.
        { exact (HBy_cover y Hy). }
        apply HV_exists.
        let V. assume HV_conj: V :e By /\ y :e V.
        claim HV: V :e By.
        { exact (andEL (V :e By) (y :e V) HV_conj). }
        claim Hy_in_V: y :e V.
        { exact (andER (V :e By) (y :e V) HV_conj). }
        (** Now show p :e setprod U V using singleton subsets **)
        claim Hx_sing_sub: {x} c= U.
        { exact (singleton_subset x U Hx_in_U). }
        claim Hy_sing_sub: {y} c= V.
        { exact (singleton_subset y V Hy_in_V). }
        claim HUV_sub: setprod {x} {y} c= setprod U V.
        { exact (setprod_Subq {x} {y} U V Hx_sing_sub Hy_sing_sub). }
        claim Hp_in_UV: p :e setprod U V.
        { exact (HUV_sub p Hp_sing). }
        (** Finally, witness setprod U V :e product_basis_from Bx By **)
        witness (setprod U V).
        prove setprod U V :e product_basis_from Bx By /\ p :e setprod U V.
        apply andI.
        + (** Show setprod U V :e product_basis_from Bx By **)
          claim HUVinRepl: setprod U V :e {setprod U V' | V' :e By}.
          { exact (ReplI By (fun V' => setprod U V') V HV). }
          exact (famunionI Bx (fun U' => {setprod U' V' | V' :e By}) U (setprod U V) HU HUVinRepl).
        + exact Hp_in_UV.

    * (** Axiom 3: intersection property **)
      let b1. assume Hb1: b1 :e product_basis_from Bx By.
      let b2. assume Hb2: b2 :e product_basis_from Bx By.
      let p. assume Hpb1: p :e b1. assume Hpb2: p :e b2.
      prove exists b3 :e product_basis_from Bx By, p :e b3 /\ b3 c= b1 :/\: b2.
      (** Extract U1, V1 from b1 **)
      claim Hexists1: exists U1 :e Bx, b1 :e {setprod U1 V' | V' :e By}.
      { exact (famunionE Bx (fun U' => {setprod U' V' | V' :e By}) b1 Hb1). }
      apply Hexists1.
      let U1. assume HU1_conj: U1 :e Bx /\ b1 :e {setprod U1 V' | V' :e By}.
      claim HU1: U1 :e Bx.
      { exact (andEL (U1 :e Bx) (b1 :e {setprod U1 V' | V' :e By}) HU1_conj). }
      claim Hb1Repl: b1 :e {setprod U1 V' | V' :e By}.
      { exact (andER (U1 :e Bx) (b1 :e {setprod U1 V' | V' :e By}) HU1_conj). }
      claim Hexists1b: exists V1 :e By, b1 = setprod U1 V1.
      { exact (ReplE By (fun V' => setprod U1 V') b1 Hb1Repl). }
      apply Hexists1b.
      let V1. assume HV1_conj: V1 :e By /\ b1 = setprod U1 V1.
      claim HV1: V1 :e By.
      { exact (andEL (V1 :e By) (b1 = setprod U1 V1) HV1_conj). }
      claim Hb1eq: b1 = setprod U1 V1.
      { exact (andER (V1 :e By) (b1 = setprod U1 V1) HV1_conj). }
      (** Extract U2, V2 from b2 **)
      claim Hexists2: exists U2 :e Bx, b2 :e {setprod U2 V' | V' :e By}.
      { exact (famunionE Bx (fun U' => {setprod U' V' | V' :e By}) b2 Hb2). }
      apply Hexists2.
      let U2. assume HU2_conj: U2 :e Bx /\ b2 :e {setprod U2 V' | V' :e By}.
      claim HU2: U2 :e Bx.
      { exact (andEL (U2 :e Bx) (b2 :e {setprod U2 V' | V' :e By}) HU2_conj). }
      claim Hb2Repl: b2 :e {setprod U2 V' | V' :e By}.
      { exact (andER (U2 :e Bx) (b2 :e {setprod U2 V' | V' :e By}) HU2_conj). }
      claim Hexists2b: exists V2 :e By, b2 = setprod U2 V2.
      { exact (ReplE By (fun V' => setprod U2 V') b2 Hb2Repl). }
      apply Hexists2b.
      let V2. assume HV2_conj: V2 :e By /\ b2 = setprod U2 V2.
      claim HV2: V2 :e By.
      { exact (andEL (V2 :e By) (b2 = setprod U2 V2) HV2_conj). }
      claim Hb2eq: b2 = setprod U2 V2.
      { exact (andER (V2 :e By) (b2 = setprod U2 V2) HV2_conj). }
      (** Show p :e setprod X Y **)
      claim Hb1sub: b1 c= setprod X Y.
      { claim Hb1Power: b1 :e Power (setprod X Y).
        { (** Use same logic as Axiom 1 **)
          claim HBx_sub: Bx c= Power X.
          { exact (andEL (Bx c= Power X) (forall x :e X, exists b :e Bx, x :e b) (andEL (Bx c= Power X /\ (forall x :e X, exists b :e Bx, x :e b)) (forall b1 :e Bx, forall b2 :e Bx, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e Bx, x :e b3 /\ b3 c= b1 :/\: b2) HBx_basis)). }
          claim HBy_sub: By c= Power Y.
          { exact (andEL (By c= Power Y) (forall y :e Y, exists b :e By, y :e b) (andEL (By c= Power Y /\ (forall y :e Y, exists b :e By, y :e b)) (forall b1 :e By, forall b2 :e By, forall y:set, y :e b1 -> y :e b2 -> exists b3 :e By, y :e b3 /\ b3 c= b1 :/\: b2) HBy_basis)). }
          claim HU1subX: U1 c= X.
          { exact (PowerE X U1 (HBx_sub U1 HU1)). }
          claim HV1subY: V1 c= Y.
          { exact (PowerE Y V1 (HBy_sub V1 HV1)). }
          claim HU1V1sub: setprod U1 V1 c= setprod X Y.
          { exact (setprod_Subq U1 V1 X Y HU1subX HV1subY). }
          claim Hb1sub_inner: b1 c= setprod X Y.
          { rewrite Hb1eq. exact HU1V1sub. }
          exact (PowerI (setprod X Y) b1 Hb1sub_inner). }
        exact (PowerE (setprod X Y) b1 Hb1Power). }
      claim Hp_XY: p :e setprod X Y.
      { exact (Hb1sub p Hpb1). }
      (** Extract coordinates x, y from p **)
      claim Hcoords: exists x :e X, exists y :e Y, p :e setprod {x} {y}.
      { exact (setprod_elem_decompose X Y p Hp_XY). }
      apply Hcoords.
      let x. assume Hx_conj: x :e X /\ exists y :e Y, p :e setprod {x} {y}.
      claim Hx: x :e X.
      { exact (andEL (x :e X) (exists y :e Y, p :e setprod {x} {y}) Hx_conj). }
      claim Hy_exists: exists y :e Y, p :e setprod {x} {y}.
      { exact (andER (x :e X) (exists y :e Y, p :e setprod {x} {y}) Hx_conj). }
      apply Hy_exists.
      let y. assume Hy_conj: y :e Y /\ p :e setprod {x} {y}.
      claim Hy: y :e Y.
      { exact (andEL (y :e Y) (p :e setprod {x} {y}) Hy_conj). }
      claim Hp_sing: p :e setprod {x} {y}.
      { exact (andER (y :e Y) (p :e setprod {x} {y}) Hy_conj). }
      (** Show x :e U1 :/\: U2 and y :e V1 :/\: V2 **)
      claim Hp_b1: p :e setprod U1 V1.
      { rewrite <- Hb1eq. exact Hpb1. }
      claim Hp_b2: p :e setprod U2 V2.
      { rewrite <- Hb2eq. exact Hpb2. }
      claim Hxy_U1V1: x :e U1 /\ y :e V1.
      { exact (setprod_coords_in x y U1 V1 p Hp_sing Hp_b1). }
      claim Hxy_U2V2: x :e U2 /\ y :e V2.
      { exact (setprod_coords_in x y U2 V2 p Hp_sing Hp_b2). }
      claim Hx_U1: x :e U1.
      { exact (andEL (x :e U1) (y :e V1) Hxy_U1V1). }
      claim Hy_V1: y :e V1.
      { exact (andER (x :e U1) (y :e V1) Hxy_U1V1). }
      claim Hx_U2: x :e U2.
      { exact (andEL (x :e U2) (y :e V2) Hxy_U2V2). }
      claim Hy_V2: y :e V2.
      { exact (andER (x :e U2) (y :e V2) Hxy_U2V2). }
      (** Use basis intersection property for Bx **)
      claim HBx_intersect: forall b1' :e Bx, forall b2' :e Bx, forall x':set,
        x' :e b1' -> x' :e b2' -> exists b3' :e Bx, x' :e b3' /\ b3' c= b1' :/\: b2'.
      { exact (andER (Bx c= Power X /\ (forall x' :e X, exists b :e Bx, x' :e b))
                     (forall b1' :e Bx, forall b2' :e Bx, forall x':set, x' :e b1' -> x' :e b2' -> exists b3' :e Bx, x' :e b3' /\ b3' c= b1' :/\: b2')
                     HBx_basis). }
      claim HU3_exists: exists U3 :e Bx, x :e U3 /\ U3 c= U1 :/\: U2.
      { exact (HBx_intersect U1 HU1 U2 HU2 x Hx_U1 Hx_U2). }
      apply HU3_exists.
      let U3. assume HU3_conj: U3 :e Bx /\ (x :e U3 /\ U3 c= U1 :/\: U2).
      claim HU3: U3 :e Bx.
      { exact (andEL (U3 :e Bx) (x :e U3 /\ U3 c= U1 :/\: U2) HU3_conj). }
      claim Hx_U3_and_sub: x :e U3 /\ U3 c= U1 :/\: U2.
      { exact (andER (U3 :e Bx) (x :e U3 /\ U3 c= U1 :/\: U2) HU3_conj). }
      claim Hx_U3: x :e U3.
      { exact (andEL (x :e U3) (U3 c= U1 :/\: U2) Hx_U3_and_sub). }
      claim HU3_sub: U3 c= U1 :/\: U2.
      { exact (andER (x :e U3) (U3 c= U1 :/\: U2) Hx_U3_and_sub). }
      (** Use basis intersection property for By **)
      claim HBy_intersect: forall b1' :e By, forall b2' :e By, forall y':set,
        y' :e b1' -> y' :e b2' -> exists b3' :e By, y' :e b3' /\ b3' c= b1' :/\: b2'.
      { exact (andER (By c= Power Y /\ (forall y' :e Y, exists b :e By, y' :e b))
                     (forall b1' :e By, forall b2' :e By, forall y':set, y' :e b1' -> y' :e b2' -> exists b3' :e By, y' :e b3' /\ b3' c= b1' :/\: b2')
                     HBy_basis). }
      claim HV3_exists: exists V3 :e By, y :e V3 /\ V3 c= V1 :/\: V2.
      { exact (HBy_intersect V1 HV1 V2 HV2 y Hy_V1 Hy_V2). }
      apply HV3_exists.
      let V3. assume HV3_conj: V3 :e By /\ (y :e V3 /\ V3 c= V1 :/\: V2).
      claim HV3: V3 :e By.
      { exact (andEL (V3 :e By) (y :e V3 /\ V3 c= V1 :/\: V2) HV3_conj). }
      claim Hy_V3_and_sub: y :e V3 /\ V3 c= V1 :/\: V2.
      { exact (andER (V3 :e By) (y :e V3 /\ V3 c= V1 :/\: V2) HV3_conj). }
      claim Hy_V3: y :e V3.
      { exact (andEL (y :e V3) (V3 c= V1 :/\: V2) Hy_V3_and_sub). }
      claim HV3_sub: V3 c= V1 :/\: V2.
      { exact (andER (y :e V3) (V3 c= V1 :/\: V2) Hy_V3_and_sub). }
      (** Show p :e setprod U3 V3 **)
      claim Hx_sing_sub: {x} c= U3.
      { exact (singleton_subset x U3 Hx_U3). }
      claim Hy_sing_sub: {y} c= V3.
      { exact (singleton_subset y V3 Hy_V3). }
      claim HU3V3_super: setprod {x} {y} c= setprod U3 V3.
      { exact (setprod_Subq {x} {y} U3 V3 Hx_sing_sub Hy_sing_sub). }
      claim Hp_U3V3: p :e setprod U3 V3.
      { exact (HU3V3_super p Hp_sing). }
      (** Show setprod U3 V3 c= b1 :/\: b2 **)
      claim Hb1b2_int: b1 :/\: b2 = setprod U1 V1 :/\: setprod U2 V2.
      { rewrite Hb1eq. rewrite Hb2eq. reflexivity. }
      claim Hprod_int: setprod U1 V1 :/\: setprod U2 V2 = setprod (U1 :/\: U2) (V1 :/\: V2).
      { exact (setprod_intersection U1 V1 U2 V2). }
      claim HU3V3_sub: setprod U3 V3 c= setprod (U1 :/\: U2) (V1 :/\: V2).
      { exact (setprod_Subq U3 V3 (U1 :/\: U2) (V1 :/\: V2) HU3_sub HV3_sub). }
      claim HU3V3_sub_b1b2: setprod U3 V3 c= b1 :/\: b2.
      { rewrite Hb1b2_int. rewrite Hprod_int. exact HU3V3_sub. }
      (** Witness setprod U3 V3 **)
      witness (setprod U3 V3).
      prove setprod U3 V3 :e product_basis_from Bx By /\ (p :e setprod U3 V3 /\ setprod U3 V3 c= b1 :/\: b2).
      apply andI.
      + claim HU3V3inRepl: setprod U3 V3 :e {setprod U3 V' | V' :e By}.
        { exact (ReplI By (fun V' => setprod U3 V') V3 HV3). }
        exact (famunionI Bx (fun U' => {setprod U' V' | V' :e By}) U3 (setprod U3 V3) HU3 HU3V3inRepl).
      + apply andI.
        - exact Hp_U3V3.
        - exact HU3V3_sub_b1b2.
  + (** Prove forall U :e Bx, forall V :e By, setprod U V :e product_basis_from Bx By **)
    let U. assume HU: U :e Bx.
    let V. assume HV: V :e By.
    prove setprod U V :e product_basis_from Bx By.
    (** product_basis_from Bx By = \/_ U' :e Bx, {setprod U' V' | V' :e By} **)
    (** Use famunionI with U :e Bx and setprod U V :e {setprod U V' | V' :e By} **)
    claim HUVinRepl: setprod U V :e {setprod U V' | V' :e By}.
    { exact (ReplI By (fun V' => setprod U V') V HV). }
    exact (famunionI Bx (fun U' => {setprod U' V' | V' :e By}) U (setprod U V) HU HUVinRepl).
- (** Part 3: generated_topology (setprod X Y) (product_basis_from Bx By) = product_topology X Tx Y Ty **)
  (** product_topology X Tx Y Ty = generated_topology (setprod X Y) (product_subbasis X Tx Y Ty) **)
  (** product_subbasis X Tx Y Ty uses Tx and Ty, which equal generated_topology X Bx and generated_topology Y By **)
  (** product_basis_from Bx By = {UV | U :e Bx, V :e By} **)
  (** Use the axiom that product basis generates product topology **)
  claim HBx_basis: basis_on X Bx.
  { exact (andEL (basis_on X Bx) (generated_topology X Bx = Tx) HBx). }
  claim HBy_basis: basis_on Y By.
  { exact (andEL (basis_on Y By) (generated_topology Y By = Ty) HBy). }
  claim HTx_eq: generated_topology X Bx = Tx.
  { exact (andER (basis_on X Bx) (generated_topology X Bx = Tx) HBx). }
  claim HTy_eq: generated_topology Y By = Ty.
  { exact (andER (basis_on Y By) (generated_topology Y By = Ty) HBy). }
  exact (product_basis_generates_product_topology X Y Bx By Tx Ty HBx_basis HTx_eq HBy_basis HTy_eq).
Qed.

(** from 15 Definition: projections on a product **) 
(** LATEX VERSION: Define coordinate projection relations  and  from XY. **)
(** FIXED: Projections must use ordered pairs for function graphs: proj maps (x,y)x and proj maps (x,y)y, with graphs {((x,y),x)} and {((x,y),y)}; UPair and setprod x y were incorrect here. **)
Definition projection1 : set -> set -> set := fun X Y =>
  {(p, p 0) | p :e setprod X Y}.
Definition projection2 : set -> set -> set := fun X Y =>
  {(p, p 1) | p :e setprod X Y}.
 
(** SUSPICIOUS DEFINITION: These projection graphs rely on tuple-as-function encoding, so that for `p :e setprod X Y` we can read `p 0` and `p 1` as coordinates. **)

(** from 15 Theorem 15.2: projection preimages form a subbasis **) 
(** LATEX VERSION: The inverse images of opens under projections give a subbasis for the product topology. **)
Theorem product_subbasis_from_projections : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  exists S:set,
    S = product_subbasis X Tx Y Ty /\
    generated_topology (setprod X Y) S = product_topology X Tx Y Ty.
let X Tx Y Ty.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove exists S:set,
    S = product_subbasis X Tx Y Ty /\
    generated_topology (setprod X Y) S = product_topology X Tx Y Ty.
(** Witness S = product_subbasis X Tx Y Ty **)
witness (product_subbasis X Tx Y Ty).
prove product_subbasis X Tx Y Ty = product_subbasis X Tx Y Ty /\
      generated_topology (setprod X Y) (product_subbasis X Tx Y Ty) = product_topology X Tx Y Ty.
apply andI.
- (** S = product_subbasis X Tx Y Ty **)
  reflexivity.
- (** generated_topology (setprod X Y) S = product_topology X Tx Y Ty **)
  (** By definition: product_topology X Tx Y Ty = generated_topology (setprod X Y) (product_subbasis X Tx Y Ty) **)
  reflexivity.
Qed.

(** FIXED: Function-related definitions use ordered pairs, not UPair; functions are sets of ordered pairs (x,y), apply_fun looks up y with (x,y)  f, identity is {(y,y)|yX}. **)
(** SUSPICIOUS DEFINITION: `apply_fun` is based on `Eps_i`, so `function_on` only constrains the chosen values, not that `f` is a genuine functional graph; later results about unions/preimages may require extra axioms. Use `total_function_on` when totality is required. **)
Definition apply_fun : set -> set -> set := fun f x => Eps_i (fun y => (x,y) :e f).
Definition function_on : set -> set -> set -> prop := fun f X Y => forall x:set, x :e X -> apply_fun f x :e Y.
Definition function_space : set -> set -> set := fun X Y => {f :e Power (setprod X Y)|function_on f X Y}.

(** Helper: a functional graph is single valued **)
Definition functional_graph : set -> prop :=
  fun f => forall x y1 y2:set, (x,y1) :e f -> (x,y2) :e f -> y1 = y2.

(** Helper: graph domain restriction **)
Definition graph_domain_subset : set -> set -> prop :=
  fun f X => forall x y:set, (x,y) :e f -> x :e X.

(** Helper: graph range restriction **)
Definition graph_range_subset : set -> set -> prop :=
  fun f Y => forall x y:set, (x,y) :e f -> y :e Y.

(** Helper: a graph comprehension has domain subset of its index set **)
Theorem graph_domain_subset_graph : forall A:set, forall g:set->set,
  graph_domain_subset {(a, g a)|a :e A} A.
let A g.
let x y.
assume Hxy: (x,y) :e {(a, g a)|a :e A}.
prove x :e A.
apply (ReplE_impred A (fun a0:set => (a0, g a0)) (x,y) Hxy (x :e A)).
let a. assume Ha: a :e A.
assume Heq: (x,y) = (a, g a).
claim Hxa: x = a.
{ rewrite <- (tuple_2_0_eq x y).
  rewrite <- (tuple_2_0_eq a (g a)).
  rewrite Heq.
  reflexivity. }
rewrite Hxa.
exact Ha.
Qed.

(** Helper: a constant graph comprehension has domain subset of its index set **)
Theorem graph_domain_subset_const_fun : forall A c:set,
  graph_domain_subset {(a,c)|a :e A} A.
let A c.
let x y.
assume Hxy: (x,y) :e {(a,c)|a :e A}.
prove x :e A.
apply (ReplE_impred A (fun a0:set => (a0,c)) (x,y) Hxy (x :e A)).
let a. assume Ha: a :e A.
assume Heq: (x,y) = (a,c).
claim Hxa: x = a.
{ rewrite <- (tuple_2_0_eq x y).
  rewrite <- (tuple_2_0_eq a c).
  rewrite Heq.
  reflexivity. }
rewrite Hxa.
exact Ha.
Qed.

(** Helper: a graph comprehension has range subset under a pointwise condition **)
Theorem graph_range_subset_graph : forall A Y:set, forall g:set->set,
  (forall a:set, a :e A -> g a :e Y) ->
  graph_range_subset {(a, g a)|a :e A} Y.
let A Y g.
assume HgY: forall a:set, a :e A -> g a :e Y.
let x y.
assume Hxy: (x,y) :e {(a, g a)|a :e A}.
prove y :e Y.
apply (ReplE_impred A (fun a0:set => (a0, g a0)) (x,y) Hxy (y :e Y)).
let a. assume Ha: a :e A.
assume Heq: (x,y) = (a, g a).
claim Hyg: y = g a.
{ rewrite <- (tuple_2_1_eq x y).
  rewrite <- (tuple_2_1_eq a (g a)).
  rewrite Heq.
  reflexivity. }
rewrite Hyg.
exact (HgY a Ha).
Qed.

(** Helper: a constant graph comprehension has range subset **)
Theorem graph_range_subset_const_fun : forall A Y c:set,
  c :e Y ->
  graph_range_subset {(a,c)|a :e A} Y.
let A Y c.
assume HcY: c :e Y.
let x y.
assume Hxy: (x,y) :e {(a,c)|a :e A}.
prove y :e Y.
apply (ReplE_impred A (fun a0:set => (a0,c)) (x,y) Hxy (y :e Y)).
let a. assume Ha: a :e A.
assume Heq: (x,y) = (a,c).
claim Hyc: y = c.
{ rewrite <- (tuple_2_1_eq x y).
  rewrite <- (tuple_2_1_eq a c).
  rewrite Heq.
  reflexivity. }
rewrite Hyc.
exact HcY.
Qed.

(** Helper: a graph comprehension is functional **)
Theorem functional_graph_graph : forall A:set, forall g:set->set,
  functional_graph {(a, g a)|a :e A}.
let A g.
let x y1 y2.
assume H1: (x,y1) :e {(a, g a)|a :e A}.
assume H2: (x,y2) :e {(a, g a)|a :e A}.
apply (ReplE_impred A (fun a0:set => (a0, g a0)) (x,y1) H1 (y1 = y2)).
let a1. assume Ha1: a1 :e A.
assume Heq1: (x,y1) = (a1, g a1).
apply (ReplE_impred A (fun a0:set => (a0, g a0)) (x,y2) H2 (y1 = y2)).
let a2. assume Ha2: a2 :e A.
assume Heq2: (x,y2) = (a2, g a2).
claim Hx1: x = a1.
{ rewrite <- (tuple_2_0_eq x y1).
  rewrite <- (tuple_2_0_eq a1 (g a1)).
  rewrite Heq1.
  reflexivity. }
claim Hx2: x = a2.
{ rewrite <- (tuple_2_0_eq x y2).
  rewrite <- (tuple_2_0_eq a2 (g a2)).
  rewrite Heq2.
  reflexivity. }
claim Ha12: a1 = a2.
{ rewrite <- Hx1.
  rewrite Hx2.
  reflexivity. }
claim Hy1: y1 = g a1.
{ rewrite <- (tuple_2_1_eq x y1).
  rewrite <- (tuple_2_1_eq a1 (g a1)).
  rewrite Heq1.
  reflexivity. }
claim Hy2: y2 = g a2.
{ rewrite <- (tuple_2_1_eq x y2).
  rewrite <- (tuple_2_1_eq a2 (g a2)).
  rewrite Heq2.
  reflexivity. }
rewrite Hy1.
rewrite Hy2.
rewrite <- Ha12.
reflexivity.
Qed.

(** Helper: a constant graph comprehension is functional **)
Theorem functional_graph_const_fun : forall A c:set,
  functional_graph {(a,c)|a :e A}.
let A c.
let x y1 y2.
assume H1: (x,y1) :e {(a,c)|a :e A}.
assume H2: (x,y2) :e {(a,c)|a :e A}.
apply (ReplE_impred A (fun a0:set => (a0,c)) (x,y1) H1 (y1 = y2)).
let a1. assume Ha1: a1 :e A.
assume Heq1: (x,y1) = (a1,c).
apply (ReplE_impred A (fun a0:set => (a0,c)) (x,y2) H2 (y1 = y2)).
let a2. assume Ha2: a2 :e A.
assume Heq2: (x,y2) = (a2,c).
claim Hy1: y1 = c.
{ rewrite <- (tuple_2_1_eq x y1).
  rewrite <- (tuple_2_1_eq a1 c).
  rewrite Heq1.
  reflexivity. }
claim Hy2: y2 = c.
{ rewrite <- (tuple_2_1_eq x y2).
  rewrite <- (tuple_2_1_eq a2 c).
  rewrite Heq2.
  reflexivity. }
rewrite Hy1.
rewrite Hy2.
reflexivity.
Qed.

(** Helper: if a value exists in the graph, apply_fun yields a value in the graph **)
Theorem apply_fun_in_graph_of_ex : forall f x:set,
  (exists y:set, (x,y) :e f) ->
  (x, apply_fun f x) :e f.
let f x.
assume Hex: exists y:set, (x,y) :e f.
prove (x, apply_fun f x) :e f.
exact (Eps_i_ex (fun y:set => (x,y) :e f) Hex).
Qed.

(** Helper: for a functional graph, apply_fun equals any value in the graph **)
Theorem functional_graph_apply_fun_eq : forall f x y:set,
  functional_graph f ->
  (x,y) :e f ->
  apply_fun f x = y.
let f x y.
assume Hfun: functional_graph f.
assume Hxy: (x,y) :e f.
claim Happ: (x, apply_fun f x) :e f.
{ exact (Eps_i_ax (fun y0:set => (x,y0) :e f) y Hxy). }
exact (Hfun x (apply_fun f x) y Happ Hxy).
Qed.

(** Helper: domain subset preserved under binary union **)
Theorem graph_domain_subset_binunion : forall A B f g:set,
  graph_domain_subset f A ->
  graph_domain_subset g B ->
  graph_domain_subset (f :\/: g) (A :\/: B).
let A B f g.
assume Hdf: graph_domain_subset f A.
assume Hdg: graph_domain_subset g B.
let x y.
assume Hxy: (x,y) :e (f :\/: g).
prove x :e (A :\/: B).
apply (binunionE f g (x,y) Hxy).
- assume Hxyf: (x,y) :e f.
  claim HxA: x :e A.
  { exact (Hdf x y Hxyf). }
  exact (binunionI1 A B x HxA).
- assume Hxyg: (x,y) :e g.
  claim HxB: x :e B.
  { exact (Hdg x y Hxyg). }
  exact (binunionI2 A B x HxB).
Qed.

(** Helper: range subset preserved under binary union **)
Theorem graph_range_subset_binunion : forall f g Y:set,
  graph_range_subset f Y ->
  graph_range_subset g Y ->
  graph_range_subset (f :\/: g) Y.
let f g Y.
assume Hrf: graph_range_subset f Y.
assume Hrg: graph_range_subset g Y.
let x y.
assume Hxy: (x,y) :e (f :\/: g).
apply (binunionE f g (x,y) Hxy).
- assume Hxyf: (x,y) :e f.
  exact (Hrf x y Hxyf).
- assume Hxyg: (x,y) :e g.
  exact (Hrg x y Hxyg).
Qed.

(** Helper: build function_on from pointwise totality and range subset **)
Theorem function_on_from_totality_and_range : forall X Y f:set,
  (forall x:set, x :e X -> exists y:set, y :e Y /\ (x,y) :e f) ->
  graph_range_subset f Y ->
  function_on f X Y.
let X Y f.
assume Htot: forall x:set, x :e X -> exists y:set, y :e Y /\ (x,y) :e f.
assume Hrange: graph_range_subset f Y.
let x. assume HxX: x :e X.
prove apply_fun f x :e Y.
claim Hex: exists y:set, (x,y) :e f.
{ apply (Htot x HxX).
  let y. assume Hy: y :e Y /\ (x,y) :e f.
  witness y.
  exact (andER (y :e Y) ((x,y) :e f) Hy). }
claim Hpair: (x, apply_fun f x) :e f.
{ exact (apply_fun_in_graph_of_ex f x Hex). }
exact (Hrange x (apply_fun f x) Hpair).
Qed.

(** Helper: graph of a meta level function as a set of ordered pairs **)
Definition graph : set -> (set -> set) -> set := fun A g => {(a, g a) | a :e A}.

(** Helper: evaluating apply_fun on a graph built by Repl **)
Theorem apply_fun_graph : forall A:set, forall g:set->set, forall a:set,
  a :e A -> apply_fun (graph A g) a = g a.
let A g a.
assume Ha: a :e A.
prove apply_fun (graph A g) a = g a.
prove Eps_i (fun y => (a,y) :e graph A g) = g a.
claim H1: (a, g a) :e graph A g.
{ exact (ReplI A (fun a0:set => (a0, g a0)) a Ha). }
claim H2: (a, Eps_i (fun y => (a,y) :e graph A g)) :e graph A g.
{ exact (Eps_i_ax (fun y => (a,y) :e graph A g) (g a) H1). }
apply (ReplE_impred A (fun a0:set => (a0, g a0))
        (a, Eps_i (fun y => (a,y) :e graph A g)) H2
        (Eps_i (fun y => (a,y) :e graph A g) = g a)).
let a0. assume Ha0: a0 :e A.
assume Heq: (a, Eps_i (fun y => (a,y) :e graph A g)) = (a0, g a0).
claim Ha_eq: a = a0.
{ rewrite <- (tuple_2_0_eq a (Eps_i (fun y => (a,y) :e graph A g))).
  rewrite <- (tuple_2_0_eq a0 (g a0)).
  rewrite Heq.
  reflexivity. }
claim Hy_eq: Eps_i (fun y => (a,y) :e graph A g) = g a0.
{ rewrite <- (tuple_2_1_eq a (Eps_i (fun y => (a,y) :e graph A g))).
  rewrite <- (tuple_2_1_eq a0 (g a0)).
  rewrite Heq.
  reflexivity. }
rewrite Hy_eq.
rewrite <- Ha_eq.
reflexivity.
Qed.

(** Helper: total function graph on X into Y (in addition to function_on) **)
Definition total_function_on : set -> set -> set -> prop := fun f X Y =>
  function_on f X Y /\ forall x:set, x :e X -> exists y:set, y :e Y /\ (x,y) :e f.

(** Helper: total_function_on implies function_on **)
Theorem total_function_on_function_on : forall f X Y:set,
  total_function_on f X Y -> function_on f X Y.
let f X Y.
assume H: total_function_on f X Y.
exact (andEL (function_on f X Y)
             (forall x:set, x :e X -> exists y:set, y :e Y /\ (x,y) :e f)
             H).
Qed.

(** Helper: total_function_on gives a graph witness for each x **)
Theorem total_function_on_totality : forall f X Y:set,
  total_function_on f X Y ->
  forall x:set, x :e X -> exists y:set, y :e Y /\ (x,y) :e f.
let f X Y.
assume H: total_function_on f X Y.
exact (andER (function_on f X Y)
             (forall x:set, x :e X -> exists y:set, y :e Y /\ (x,y) :e f)
             H).
Qed.

(** Helper: total_function_on gives membership of the chosen value in the graph **)
Theorem total_function_on_apply_fun_in_graph : forall f X Y x:set,
  total_function_on f X Y ->
  x :e X ->
  (x, apply_fun f x) :e f.
let f X Y x.
assume Htot: total_function_on f X Y.
assume HxX: x :e X.
prove (x, apply_fun f x) :e f.
claim Hex: exists y:set, y :e Y /\ (x,y) :e f.
{ exact (total_function_on_totality f X Y Htot x HxX). }
set y0 := Eps_i (fun y:set => y :e Y /\ (x,y) :e f).
claim Hy0: y0 :e Y /\ (x,y0) :e f.
{ exact (Eps_i_ex (fun y:set => y :e Y /\ (x,y) :e f) Hex). }
claim Hxy0: (x,y0) :e f.
{ exact (andER (y0 :e Y) ((x,y0) :e f) Hy0). }
exact (Eps_i_ax (fun y:set => (x,y) :e f) y0 Hxy0).
Qed.

(** Helper: total_function_on implies apply_fun lands in Y **)
Theorem total_function_on_apply_fun_in_Y : forall f X Y x:set,
  total_function_on f X Y ->
  x :e X ->
  apply_fun f x :e Y.
let f X Y x.
assume Htot: total_function_on f X Y.
assume HxX: x :e X.
claim Hfun: function_on f X Y.
{ exact (total_function_on_function_on f X Y Htot). }
exact (Hfun x HxX).
Qed.

(** Helper: range subset from totality and functionality **)
Theorem graph_range_subset_from_total_functional : forall A Y f:set,
  graph_domain_subset f A ->
  total_function_on f A Y ->
  functional_graph f ->
  graph_range_subset f Y.
let A Y f.
assume Hdom: graph_domain_subset f A.
assume Htot: total_function_on f A Y.
assume Hfun: functional_graph f.
let x y.
assume Hxy: (x,y) :e f.
prove y :e Y.
claim HxA: x :e A.
{ exact (Hdom x y Hxy). }
claim HappY: apply_fun f x :e Y.
{ exact (total_function_on_apply_fun_in_Y f A Y x Htot HxA). }
claim HappEq: apply_fun f x = y.
{ exact (functional_graph_apply_fun_eq f x y Hfun Hxy). }
rewrite <- HappEq.
exact HappY.
Qed.

(** Helper: constant function as a graph **)
Definition const_fun : set -> set -> set := fun A x => {(a,x) | a :e A}.

(** Helper: apply_fun for const_fun **)
Theorem const_fun_apply : forall A x a:set,
  a :e A ->
  apply_fun (const_fun A x) a = x.
let A x a.
assume Ha: a :e A.
prove apply_fun (const_fun A x) a = x.
prove Eps_i (fun y => (a,y) :e const_fun A x) = x.
claim H1: (a,x) :e const_fun A x.
{ exact (ReplI A (fun a0:set => (a0,x)) a Ha). }
claim H2: (a, Eps_i (fun y => (a,y) :e const_fun A x)) :e const_fun A x.
{ exact (Eps_i_ax (fun y => (a,y) :e const_fun A x) x H1). }
apply (ReplE_impred A (fun a0:set => (a0,x)) (a, Eps_i (fun y => (a,y) :e const_fun A x)) H2).
let a0.
assume Ha0: a0 :e A.
assume Heq: (a, Eps_i (fun y => (a,y) :e const_fun A x)) = (a0,x).
	rewrite <- (tuple_2_1_eq a (Eps_i (fun y => (a,y) :e const_fun A x))) at 1.
	rewrite <- (tuple_2_1_eq a0 x) at 2.
	rewrite Heq.
	reflexivity.
	Qed.

(** Helper: const_fun is total_function_on **)
Theorem const_fun_total_function_on : forall A Y x:set,
  x :e Y -> total_function_on (const_fun A x) A Y.
let A Y x.
assume HxY: x :e Y.
prove function_on (const_fun A x) A Y /\
  forall a:set, a :e A -> exists y:set, y :e Y /\ (a,y) :e const_fun A x.
apply andI.
- (** function_on **)
  let a. assume HaA: a :e A.
  prove apply_fun (const_fun A x) a :e Y.
  claim Happ: apply_fun (const_fun A x) a = x.
  { exact (const_fun_apply A x a HaA). }
  rewrite Happ.
  exact HxY.
- (** totality **)
  let a. assume HaA: a :e A.
  prove exists y:set, y :e Y /\ (a,y) :e const_fun A x.
  witness x.
  apply andI.
  + exact HxY.
  + exact (ReplI A (fun a0:set => (a0,x)) a HaA).
Qed.

		(** Helper: identity function application **)
Theorem identity_function_apply : forall X x:set,
  x :e X -> apply_fun {(y,y) | y :e X} x = x.
let X x. assume Hx: x :e X.
prove apply_fun {(y,y) | y :e X} x = x.
prove Eps_i (fun z => (x,z) :e {(y,y) | y :e X}) = x.
claim H1: (x,x) :e {(y,y) | y :e X}.
{ exact (ReplI X (fun y => (y,y)) x Hx). }
claim H2: (x, Eps_i (fun z => (x,z) :e {(y,y) | y :e X})) :e {(y,y) | y :e X}.
{ exact (Eps_i_ax (fun z => (x,z) :e {(y,y) | y :e X}) x H1). }
apply (ReplE_impred X (fun y => (y,y)) (x, Eps_i (fun z => (x,z) :e {(y,y) | y :e X})) H2).
let y.
assume Hy: y :e X.
assume Heq: (x, Eps_i (fun z => (x,z) :e {(y,y) | y :e X})) = (y,y).
claim Hx_eq: x = y.
{ rewrite <- (tuple_2_0_eq x (Eps_i (fun z => (x,z) :e {(y,y) | y :e X}))).
  rewrite <- (tuple_2_0_eq y y).
  rewrite Heq.
  reflexivity. }
claim Hz_eq: Eps_i (fun z => (x,z) :e {(y,y) | y :e X}) = y.
{ rewrite <- (tuple_2_1_eq x (Eps_i (fun z => (x,z) :e {(y,y) | y :e X}))).
  rewrite <- (tuple_2_1_eq y y).
  rewrite Heq.
  reflexivity. }
rewrite Hz_eq.
rewrite <- Hx_eq.
reflexivity.
Qed.

(** Helper: identity graph is total_function_on **)
Theorem identity_total_function_on : forall X:set,
  total_function_on {(y,y) | y :e X} X X.
let X.
prove function_on {(y,y) | y :e X} X X /\
  forall x:set, x :e X -> exists y:set, y :e X /\ (x,y) :e {(y,y) | y :e X}.
apply andI.
- let x. assume HxX: x :e X.
  prove apply_fun {(y,y) | y :e X} x :e X.
  rewrite (identity_function_apply X x HxX).
  exact HxX.
- let x. assume HxX: x :e X.
  prove exists y:set, y :e X /\ (x,y) :e {(y,y) | y :e X}.
  witness x.
  apply andI.
  + exact HxX.
  + exact (ReplI X (fun y0:set => (y0,y0)) x HxX).
Qed.

Definition const_family : set -> set -> set := fun I X => {(i,X)|i :e I}.

(** Helper: apply_fun for const_family **)
Theorem const_family_apply : forall I X i:set,
  i :e I -> apply_fun (const_family I X) i = X.
let I X i.
assume Hi: i :e I.
prove apply_fun (const_family I X) i = X.
exact (const_fun_apply I X i Hi).
Qed.

Definition product_component : set -> set -> set := fun Xi i => (apply_fun Xi i) 0.
Definition product_component_topology : set -> set -> set := fun Xi i => (apply_fun Xi i) 1.

(** Helper: unfold product_component and product_component_topology **)
Theorem product_component_def : forall Xi i:set,
  product_component Xi i = (apply_fun Xi i) 0.
let Xi i.
prove product_component Xi i = (apply_fun Xi i) 0.
reflexivity.
Qed.

Theorem product_component_topology_def : forall Xi i:set,
  product_component_topology Xi i = (apply_fun Xi i) 1.
let Xi i.
prove product_component_topology Xi i = (apply_fun Xi i) 1.
reflexivity.
Qed.

(** family of spaces as a family of pairs (X_i, T_i) **) 
Definition const_space_family : set -> set -> set -> set := fun I X Tx =>
  {(i,(X,Tx))|i :e I}.

(** Helper: apply_fun for const_space_family **)
Theorem const_space_family_apply : forall I X Tx i:set,
  i :e I -> apply_fun (const_space_family I X Tx) i = (X,Tx).
let I X Tx i.
assume Hi: i :e I.
prove apply_fun (const_space_family I X Tx) i = (X,Tx).
exact (const_fun_apply I (X,Tx) i Hi).
Qed.

Definition space_family_set : set -> set -> set := fun Xi i => (apply_fun Xi i) 0.
Definition space_family_topology : set -> set -> set := fun Xi i => (apply_fun Xi i) 1.

Definition space_family_union : set -> set -> set := fun I Xi =>
  Union {space_family_set Xi i|i :e I}.
Definition topology_family_union : set -> set -> set := fun I Xi =>
  Union {space_family_topology Xi i|i :e I}.

Definition product_space : set -> set -> set := fun I Xi =>
  {f :e Power (setprod I (space_family_union I Xi))|
     function_on f I (space_family_union I Xi) /\
     forall i:set, i :e I -> apply_fun f i :e space_family_set Xi i}.
(** SUSPICIOUS DEFINITION: This uses `function_on`/`apply_fun` (based on `Eps_i`), so membership in `product_space` does not by itself assert that `f` is a genuine functional graph unless paired with separate functional-graph hypotheses. **)
Definition product_cylinder : set -> set -> set -> set -> set :=
  fun I Xi i U =>
    {f :e product_space I Xi | i :e I /\ U :e space_family_topology Xi i /\ apply_fun f i :e U}.
Definition product_subbasis_full : set -> set -> set :=
  fun I Xi => \/_ i :e I, {product_cylinder I Xi i U|U :e space_family_topology Xi i}.
Definition product_topology_full : set -> set -> set := fun I Xi =>
  generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi).
(** FIXED: Was using Power set which generates discrete topology, not box topology; now box_topology is generated from the box_basis (products of opens in each component). **)
Definition box_basis : set -> set -> set := fun I Xi =>
  {B :e Power (product_space I Xi) |
    exists U:set, function_on U I (topology_family_union I Xi) /\
      (forall i:set, i :e I -> apply_fun U i :e space_family_topology Xi i) /\
      B = {f :e product_space I Xi | forall i:set, i :e I -> apply_fun f i :e apply_fun U i}}.
(** SUSPICIOUS DEFINITION: The witness `U` is itself only constrained by `function_on`/`apply_fun`; later proofs about box-basic opens may need explicit functional-graph facts about `U` to avoid Eps-choice pathologies. **)
Definition box_topology : set -> set -> set := fun I Xi =>
  generated_topology (product_space I Xi) (box_basis I Xi).
Definition countable_product_space : set -> set -> set := fun I Xi =>
  product_space I Xi.
Definition countable_product_topology : set -> set -> set := fun I Xi =>
  product_topology_full I Xi.
Definition euclidean_space : set -> set := fun n => product_space n (const_space_family n R R_standard_topology).
Definition euclidean_topology : set -> set := fun n => product_topology_full n (const_space_family n R R_standard_topology).

(** from 15 Example: standard topology on  as product topology **) 
(** LATEX VERSION: The standard topology on  coincides with the product of the standard topologies on . **)
Definition R2_standard_topology : set := product_topology R R_standard_topology R R_standard_topology.

Theorem R2_standard_equals_product :
  R2_standard_topology = product_topology R R_standard_topology R R_standard_topology.
prove R2_standard_topology = product_topology R R_standard_topology R R_standard_topology.
(** R2_standard_topology is defined as product_topology R R_standard_topology R R_standard_topology **)
reflexivity.
Qed.

(** from 16 Definition: subspace topology **) 
(** LATEX VERSION: The subspace topology on YX with topology Tx consists of intersections VY with V open in X. **)
(** SUSPICIOUS DEFINITION: This is phrased as a family of subsets of `Y` (via `Power Y`) with witnesses `V :e Tx`; proofs often need to extract both the witness and the subset fact. **)
Definition subspace_topology : set -> set -> set -> set :=
  fun X Tx Y => {U :e Power Y | exists V :e Tx, U = V :/\: Y}.

(** helper: subspace topology on whole space equals original topology **)
Theorem subspace_topology_whole : forall X Tx:set,
  topology_on X Tx ->
  subspace_topology X Tx X = Tx.
let X Tx.
assume HTx: topology_on X Tx.
prove subspace_topology X Tx X = Tx.
apply set_ext.
- let U. assume HU: U :e subspace_topology X Tx X.
  prove U :e Tx.
  claim Hex: exists V :e Tx, U = V :/\: X.
  { exact (SepE2 (Power X) (fun U0:set => exists V :e Tx, U0 = V :/\: X) U HU). }
  apply Hex.
  let V. assume HVpair.
  claim HV: V :e Tx.
  { exact (andEL (V :e Tx) (U = V :/\: X) HVpair). }
  claim HUeq: U = V :/\: X.
  { exact (andER (V :e Tx) (U = V :/\: X) HVpair). }
  claim HVsub: V c= X.
  { exact (topology_elem_subset X Tx V HTx HV). }
  claim HVeql: V :/\: X = V.
  { exact (binintersect_Subq_eq_1 V X HVsub). }
  claim HUeqV: U = V.
  { rewrite HUeq. exact HVeql. }
  rewrite HUeqV.
  exact HV.
- let U. assume HU: U :e Tx.
  prove U :e subspace_topology X Tx X.
  claim HUsub: U c= X.
  { exact (topology_elem_subset X Tx U HTx HU). }
  claim HUpow: U :e Power X.
  { exact (PowerI X U HUsub). }
  claim Hex: exists V :e Tx, U = V :/\: X.
  { witness U.
    apply andI.
    - exact HU.
    - prove U = U :/\: X.
      rewrite (binintersect_Subq_eq_1 U X HUsub).
      reflexivity. }
  exact (SepI (Power X) (fun U0:set => exists V :e Tx, U0 = V :/\: X) U HUpow Hex).
Qed.

(** from 16: subspace topology is a topology **) 
(** LATEX VERSION: The subspace topology on Y inherits the topology axioms. **)
Theorem subspace_topology_is_topology : forall X Tx Y:set,
  topology_on X Tx -> Y c= X ->
  topology_on Y (subspace_topology X Tx Y).
let X Tx Y.
assume HTx: topology_on X Tx.
assume HY: Y c= X.
prove topology_on Y (subspace_topology X Tx Y).
prove subspace_topology X Tx Y c= Power Y
  /\ Empty :e subspace_topology X Tx Y
  /\ Y :e subspace_topology X Tx Y
  /\ (forall UFam :e Power (subspace_topology X Tx Y), Union UFam :e subspace_topology X Tx Y)
  /\ (forall U :e subspace_topology X Tx Y, forall V :e subspace_topology X Tx Y, U :/\: V :e subspace_topology X Tx Y).
apply andI.
- prove (subspace_topology X Tx Y c= Power Y /\ Empty :e subspace_topology X Tx Y) /\ Y :e subspace_topology X Tx Y /\ (forall UFam :e Power (subspace_topology X Tx Y), Union UFam :e subspace_topology X Tx Y).
  apply andI.
  + prove subspace_topology X Tx Y c= Power Y /\ Empty :e subspace_topology X Tx Y /\ Y :e subspace_topology X Tx Y.
    apply andI.
    * prove subspace_topology X Tx Y c= Power Y /\ Empty :e subspace_topology X Tx Y.
      apply andI.
      { prove subspace_topology X Tx Y c= Power Y.
        let U. assume HU: U :e subspace_topology X Tx Y.
        exact (SepE1 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HU).
      }
      { prove Empty :e subspace_topology X Tx Y.
        claim HEmptyTx: Empty :e Tx.
        { exact (topology_has_empty X Tx HTx). }
        claim HPred: exists V :e Tx, Empty = V :/\: Y.
        { witness Empty.
          apply andI.
          - exact HEmptyTx.
          - prove Empty = Empty :/\: Y.
            claim H1: Empty :/\: Y = Empty.
            { apply Empty_Subq_eq.
              exact (binintersect_Subq_1 Empty Y). }
            rewrite H1.
            reflexivity.
        }
        exact (SepI (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) Empty (Empty_In_Power Y) HPred).
      }
    * prove Y :e subspace_topology X Tx Y.
      claim HXTx: X :e Tx.
      { exact (topology_has_X X Tx HTx). }
      claim HPredY: exists V :e Tx, Y = V :/\: Y.
      { witness X.
        apply andI.
        - exact HXTx.
        - prove Y = X :/\: Y.
          apply set_ext.
          + let y. assume Hy: y :e Y.
            apply binintersectI.
            * exact (HY y Hy).
            * exact Hy.
          + exact (binintersect_Subq_2 X Y).
      }
      exact (SepI (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) Y (Self_In_Power Y) HPredY).
  + prove forall UFam :e Power (subspace_topology X Tx Y), Union UFam :e subspace_topology X Tx Y.
    let UFam. assume HUFam: UFam :e Power (subspace_topology X Tx Y).
    prove Union UFam :e subspace_topology X Tx Y.
    claim HUFamsub: UFam c= subspace_topology X Tx Y.
    { exact (PowerE (subspace_topology X Tx Y) UFam HUFam). }
    set VFam := {V :e Tx | exists U :e UFam, U = V :/\: Y}.
    claim HVFamTx: VFam c= Tx.
    { let V. assume HV: V :e VFam.
      exact (SepE1 Tx (fun V0 => exists U :e UFam, U = V0 :/\: Y) V HV). }
    claim HVFamPower: VFam :e Power Tx.
    { apply PowerI. exact HVFamTx. }
    claim HUnionVFam: Union VFam :e Tx.
    { exact (topology_union_closed X Tx VFam HTx HVFamTx). }
    claim HUnionEq: Union UFam = (Union VFam) :/\: Y.
    { apply set_ext.
      - let x. assume Hx: x :e Union UFam.
        apply UnionE_impred UFam x Hx.
        let U. assume HxU: x :e U. assume HUinFam: U :e UFam.
        claim HUinSubspace: U :e subspace_topology X Tx Y.
        { exact (HUFamsub U HUinFam). }
        claim HUexists: exists V :e Tx, U = V :/\: Y.
        { exact (SepE2 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HUinSubspace). }
        apply HUexists.
        let V. assume HVandEq. apply HVandEq.
        assume HVTx: V :e Tx. assume HUeq: U = V :/\: Y.
        apply binintersectI.
        + prove x :e Union VFam.
          claim HxV: x :e V.
          { claim HxVY: x :e V :/\: Y.
            { rewrite <- HUeq. exact HxU. }
            exact (binintersectE1 V Y x HxVY).
          }
          claim HVinVFam: V :e VFam.
          { apply (SepI Tx (fun V0 => exists U :e UFam, U = V0 :/\: Y) V HVTx).
            witness U. apply andI.
            - exact HUinFam.
            - exact HUeq.
          }
          exact (UnionI VFam x V HxV HVinVFam).
        + prove x :e Y.
          claim HxVY: x :e V :/\: Y.
          { rewrite <- HUeq. exact HxU. }
          exact (binintersectE2 V Y x HxVY).
      - let x. assume Hx: x :e (Union VFam) :/\: Y.
        claim HxUnionV: x :e Union VFam.
        { exact (binintersectE1 (Union VFam) Y x Hx). }
        claim HxY: x :e Y.
        { exact (binintersectE2 (Union VFam) Y x Hx). }
        apply UnionE_impred VFam x HxUnionV.
        let V. assume HxV: x :e V. assume HVinVFam: V :e VFam.
        claim HVexists: exists U :e UFam, U = V :/\: Y.
        { exact (SepE2 Tx (fun V0 => exists U :e UFam, U = V0 :/\: Y) V HVinVFam). }
        apply HVexists.
        let U. assume HUandEq. apply HUandEq.
        assume HUinFam: U :e UFam. assume HUeq: U = V :/\: Y.
        claim HxU: x :e U.
        { rewrite HUeq.
          apply binintersectI.
          - exact HxV.
          - exact HxY.
        }
        exact (UnionI UFam x U HxU HUinFam).
    }
    claim HPredUnion: exists V :e Tx, Union UFam = V :/\: Y.
    { witness (Union VFam).
      apply andI.
      - exact HUnionVFam.
      - exact HUnionEq.
    }
    claim HUnionInPowerY: Union UFam :e Power Y.
    { apply PowerI.
      let x. assume Hx: x :e Union UFam.
      claim HxVY: x :e (Union VFam) :/\: Y.
      { rewrite <- HUnionEq. exact Hx. }
      exact (binintersectE2 (Union VFam) Y x HxVY).
    }
    exact (SepI (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) (Union UFam) HUnionInPowerY HPredUnion).
- prove forall U :e subspace_topology X Tx Y, forall V :e subspace_topology X Tx Y, U :/\: V :e subspace_topology X Tx Y.
  let U. assume HU: U :e subspace_topology X Tx Y.
  let V. assume HV: V :e subspace_topology X Tx Y.
  prove U :/\: V :e subspace_topology X Tx Y.
  claim HUexists: exists V1 :e Tx, U = V1 :/\: Y.
  { exact (SepE2 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HU). }
  claim HVexists: exists V2 :e Tx, V = V2 :/\: Y.
  { exact (SepE2 (Power Y) (fun V0:set => exists V :e Tx, V0 = V :/\: Y) V HV). }
  apply HUexists.
  let V1. assume HV1andEq. apply HV1andEq.
  assume HV1Tx: V1 :e Tx. assume HUeq: U = V1 :/\: Y.
  apply HVexists.
  let V2. assume HV2andEq. apply HV2andEq.
  assume HV2Tx: V2 :e Tx. assume HVeq: V = V2 :/\: Y.
  claim HV1V2: V1 :/\: V2 :e Tx.
  { exact (topology_binintersect_closed X Tx V1 V2 HTx HV1Tx HV2Tx). }
  claim HIntEq: U :/\: V = (V1 :/\: V2) :/\: Y.
  { rewrite HUeq.
    rewrite HVeq.
    prove (V1 :/\: Y) :/\: (V2 :/\: Y) = (V1 :/\: V2) :/\: Y.
    apply set_ext.
    - let x. assume Hx: x :e (V1 :/\: Y) :/\: (V2 :/\: Y).
      claim HxV1Y: x :e V1 :/\: Y.
      { exact (binintersectE1 (V1 :/\: Y) (V2 :/\: Y) x Hx). }
      claim HxV2Y: x :e V2 :/\: Y.
      { exact (binintersectE2 (V1 :/\: Y) (V2 :/\: Y) x Hx). }
      claim HxV1: x :e V1.
      { exact (binintersectE1 V1 Y x HxV1Y). }
      claim HxV2: x :e V2.
      { exact (binintersectE1 V2 Y x HxV2Y). }
      claim HxY: x :e Y.
      { exact (binintersectE2 V1 Y x HxV1Y). }
      apply binintersectI.
      + apply binintersectI.
        * exact HxV1.
        * exact HxV2.
      + exact HxY.
    - let x. assume Hx: x :e (V1 :/\: V2) :/\: Y.
      claim HxV1V2: x :e V1 :/\: V2.
      { exact (binintersectE1 (V1 :/\: V2) Y x Hx). }
      claim HxY: x :e Y.
      { exact (binintersectE2 (V1 :/\: V2) Y x Hx). }
      claim HxV1: x :e V1.
      { exact (binintersectE1 V1 V2 x HxV1V2). }
      claim HxV2: x :e V2.
      { exact (binintersectE2 V1 V2 x HxV1V2). }
      apply binintersectI.
      + apply binintersectI.
        * exact HxV1.
        * exact HxY.
      + apply binintersectI.
        * exact HxV2.
        * exact HxY.
  }
  claim HPredInt: exists W :e Tx, U :/\: V = W :/\: Y.
  { witness (V1 :/\: V2).
    apply andI.
    - exact HV1V2.
    - exact HIntEq.
  }
  claim HIntInPowerY: U :/\: V :e Power Y.
  { apply PowerI.
    let x. assume Hx: x :e U :/\: V.
    claim HxU: x :e U.
    { exact (binintersectE1 U V x Hx). }
    claim HUinPowerY: U :e Power Y.
    { exact (SepE1 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HU). }
    claim HUsub: U c= Y.
    { exact (PowerE Y U HUinPowerY). }
    exact (HUsub x HxU).
  }
  exact (SepI (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) (U :/\: V) HIntInPowerY HPredInt).
Qed.

(** from 16: openness in subspace via ambient openness **) 
(** LATEX VERSION: A set UY is open in the subspace topology iff U = VY for some V open in X. **)
Theorem open_in_subspace_iff : forall X Tx Y U:set,
  topology_on X Tx -> Y c= X -> U c= Y ->
  (open_in Y (subspace_topology X Tx Y) U <->
  exists V :e Tx, U = V :/\: Y).
let X Tx Y U.
assume HTx: topology_on X Tx.
assume HY: Y c= X.
assume HU: U c= Y.
prove open_in Y (subspace_topology X Tx Y) U <-> exists V :e Tx, U = V :/\: Y.
apply iffI.
- assume HopenU: open_in Y (subspace_topology X Tx Y) U.
  prove exists V :e Tx, U = V :/\: Y.
  claim HUinSubspace: U :e subspace_topology X Tx Y.
  { exact (andER (topology_on Y (subspace_topology X Tx Y)) (U :e subspace_topology X Tx Y) HopenU). }
  exact (SepE2 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HUinSubspace).
- assume Hexists: exists V :e Tx, U = V :/\: Y.
  prove open_in Y (subspace_topology X Tx Y) U.
  prove topology_on Y (subspace_topology X Tx Y) /\ U :e subspace_topology X Tx Y.
  apply andI.
  + prove topology_on Y (subspace_topology X Tx Y).
    exact (subspace_topology_is_topology X Tx Y HTx HY).
  + prove U :e subspace_topology X Tx Y.
    claim HUinPowerY: U :e Power Y.
    { apply PowerI. exact HU. }
    exact (SepI (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HUinPowerY Hexists).
Qed.

(** from 16 Lemma 16.1: basis for the subspace topology **) 
(** LATEX VERSION: Lemma 16.1: If B is a basis for Tx, then {bY | bB} is a basis for the subspace topology on Y. **)
Theorem subspace_basis : forall X Tx Y B:set,
  topology_on X Tx ->
  Y c= X ->
  basis_on X B /\ generated_topology X B = Tx ->
  basis_on Y {b :/\: Y | b :e B} /\
  generated_topology Y {b :/\: Y | b :e B} = subspace_topology X Tx Y.
let X Tx Y B.
assume HTx: topology_on X Tx.
assume HYsub: Y c= X.
assume HB: basis_on X B /\ generated_topology X B = Tx.
prove basis_on Y {b :/\: Y | b :e B} /\ generated_topology Y {b :/\: Y | b :e B} = subspace_topology X Tx Y.
(** Use basis_refines_topology with C = {bY | bB} on the subspace topology. **)
claim HBasis: basis_on X B.
{ exact (andEL (basis_on X B) (generated_topology X B = Tx) HB). }
claim HgenEq: generated_topology X B = Tx.
{ exact (andER (basis_on X B) (generated_topology X B = Tx) HB). }
claim HtopSub: topology_on Y (subspace_topology X Tx Y).
{ exact (subspace_topology_is_topology X Tx Y HTx HYsub). }
claim HCsub: forall c :e {b :/\: Y | b :e B}, c :e subspace_topology X Tx Y.
{ let c. assume HcC.
  claim Hexb: exists b :e B, c = b :/\: Y.
  { exact (ReplE B (fun b0:set => b0 :/\: Y) c HcC). }
  apply Hexb.
  let b. assume Hbpair.
  claim HbB: b :e B.
  { exact (andEL (b :e B) (c = b :/\: Y) Hbpair). }
  claim Hceq: c = b :/\: Y.
  { exact (andER (b :e B) (c = b :/\: Y) Hbpair). }
  claim HbGen: b :e generated_topology X B.
  { exact (generated_topology_contains_basis X B HBasis b HbB). }
  claim HbTx: b :e Tx.
  { prove b :e Tx.
    rewrite <- HgenEq.
    exact HbGen. }
  claim HcPowY: c :e Power Y.
  { apply PowerI Y c.
    let y. assume Hyc: y :e c.
    claim HycBY: y :e b :/\: Y.
    { prove y :e b :/\: Y.
      rewrite <- Hceq.
      exact Hyc. }
    exact (binintersectE2 b Y y HycBY). }
  claim HcProp: exists V :e Tx, c = V :/\: Y.
  { witness b.
    apply andI.
    - exact HbTx.
    - exact Hceq. }
  exact (SepI (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) c HcPowY HcProp). }
claim Href: forall U :e subspace_topology X Tx Y, forall x :e U,
  exists Cx :e {b :/\: Y | b :e B}, x :e Cx /\ Cx c= U.
{ let U. assume HU: U :e subspace_topology X Tx Y.
  let x. assume HxU: x :e U.
  claim HUprop: exists V :e Tx, U = V :/\: Y.
  { exact (SepE2 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HU). }
  apply HUprop.
  let V. assume HVpair.
  claim HVTx: V :e Tx.
  { exact (andEL (V :e Tx) (U = V :/\: Y) HVpair). }
  claim HUeq: U = V :/\: Y.
  { exact (andER (V :e Tx) (U = V :/\: Y) HVpair). }
  claim HxVY: x :e V :/\: Y.
  { rewrite <- HUeq. exact HxU. }
  claim HxV: x :e V.
  { exact (binintersectE1 V Y x HxVY). }
  claim HxY: x :e Y.
  { exact (binintersectE2 V Y x HxVY). }
  claim HVGen: V :e generated_topology X B.
  { prove V :e generated_topology X B.
    rewrite HgenEq.
    exact HVTx. }
  claim HVref: forall z :e V, exists b :e B, z :e b /\ b c= V.
  { exact (SepE2 (Power X)
                 (fun U0 : set => forall z0 :e U0, exists b0 :e B, z0 :e b0 /\ b0 c= U0)
                 V
                 HVGen). }
  claim Hexb: exists b :e B, x :e b /\ b c= V.
  { exact (HVref x HxV). }
  apply Hexb.
  let b. assume Hbpair2.
  claim HbB: b :e B.
  { exact (andEL (b :e B) (x :e b /\ b c= V) Hbpair2). }
  claim Hbprop: x :e b /\ b c= V.
  { exact (andER (b :e B) (x :e b /\ b c= V) Hbpair2). }
  claim Hxb: x :e b.
  { exact (andEL (x :e b) (b c= V) Hbprop). }
  claim HbsubV: b c= V.
  { exact (andER (x :e b) (b c= V) Hbprop). }
  set Cx := b :/\: Y.
  witness Cx.
  apply andI.
  - prove Cx :e {b0 :/\: Y | b0 :e B}.
    exact (ReplI B (fun b0:set => b0 :/\: Y) b HbB).
  - apply andI.
    + prove x :e Cx.
      exact (binintersectI b Y x Hxb HxY).
    + prove Cx c= U.
      let y. assume HyCx: y :e Cx.
      claim Hyb: y :e b.
      { exact (binintersectE1 b Y y HyCx). }
      claim HyY: y :e Y.
      { exact (binintersectE2 b Y y HyCx). }
      claim HyV: y :e V.
      { exact (HbsubV y Hyb). }
      claim HyVY: y :e V :/\: Y.
      { exact (binintersectI V Y y HyV HyY). }
      rewrite HUeq.
      exact HyVY. }
exact (basis_refines_topology Y (subspace_topology X Tx Y) {b :/\: Y | b :e B} HtopSub HCsub Href).
Qed.

(** from 16 Lemma 16.2: openness inherited when subspace is open **) 
(** LATEX VERSION: Lemma 16.2: If Y itself is open in X, any set open in the subspace Y is open in X. **)
Theorem open_in_subspace_if_ambient_open : forall X Tx Y U:set,
  topology_on X Tx -> Y :e Tx -> U c= Y ->
  open_in Y (subspace_topology X Tx Y) U ->
  U :e Tx.
let X Tx Y U.
assume HTx: topology_on X Tx.
assume HY: Y :e Tx.
assume HU: U c= Y.
assume HUopen: open_in Y (subspace_topology X Tx Y) U.
prove U :e Tx.
claim HYsub: Y c= X.
{ exact (topology_elem_subset X Tx Y HTx HY). }
claim HUiffExists: open_in Y (subspace_topology X Tx Y) U <-> exists V :e Tx, U = V :/\: Y.
{ exact (open_in_subspace_iff X Tx Y U HTx HYsub HU). }
claim Hexists: exists V :e Tx, U = V :/\: Y.
{ exact (iffEL (open_in Y (subspace_topology X Tx Y) U) (exists V :e Tx, U = V :/\: Y) HUiffExists HUopen). }
apply Hexists.
let V. assume HVandEq. apply HVandEq.
assume HV: V :e Tx. assume HUeq: U = V :/\: Y.
claim HVY: V :/\: Y :e Tx.
{ exact (topology_binintersect_closed X Tx V Y HTx HV HY). }
claim HUinTx: U :e Tx.
{ rewrite HUeq. exact HVY. }
exact HUinTx.
Qed.

(** from 16 Theorem 16.3: product of subspaces equals subspace of product **) 
(** LATEX VERSION: The product topology on AB (with subspace topologies) equals the subspace topology of AB inside XY. **)
Theorem product_subspace_topology : forall X Tx Y Ty A B:set,
  topology_on X Tx -> topology_on Y Ty ->
  A c= X -> B c= Y ->
  product_topology A (subspace_topology X Tx A) B (subspace_topology Y Ty B) =
  subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B).
let X Tx Y Ty A B.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
assume HA: A c= X.
assume HB: B c= Y.
prove product_topology A (subspace_topology X Tx A) B (subspace_topology Y Ty B) =
  subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B).
(** Use the rectangle family (UA)(VB) as a common basis for both topologies. **)
set Bx := {U :/\: A | U :e Tx}.
set By := {V :/\: B | V :e Ty}.
set C := product_basis_from Bx By.

(** First, show Tx generates itself, so Bx generates the subspace topology on A, and similarly for By. **)
claim HgenTx: basis_on X Tx /\ generated_topology X Tx = Tx.
{ prove basis_on X Tx /\ generated_topology X Tx = Tx.
  apply (basis_refines_topology X Tx Tx HTx).
  - let c. assume Hc: c :e Tx.
    exact Hc.
  - let U. assume HU: U :e Tx.
    let x. assume Hx: x :e U.
    prove exists Cx :e Tx, x :e Cx /\ Cx c= U.
    witness U.
    apply andI.
    + exact HU.
    + apply andI.
      * exact Hx.
      * exact (Subq_ref U). }
claim HgenTy: basis_on Y Ty /\ generated_topology Y Ty = Ty.
{ prove basis_on Y Ty /\ generated_topology Y Ty = Ty.
  apply (basis_refines_topology Y Ty Ty HTy).
  - let c. assume Hc: c :e Ty.
    exact Hc.
  - let U. assume HU: U :e Ty.
    let x. assume Hx: x :e U.
    prove exists Cx :e Ty, x :e Cx /\ Cx c= U.
    witness U.
    apply andI.
    + exact HU.
    + apply andI.
      * exact Hx.
      * exact (Subq_ref U). }

claim HBx: basis_on A Bx /\ generated_topology A Bx = subspace_topology X Tx A.
{ exact (subspace_basis X Tx A Tx HTx HA HgenTx). }
claim HBy: basis_on B By /\ generated_topology B By = subspace_topology Y Ty B.
{ exact (subspace_basis Y Ty B Ty HTy HB HgenTy). }

claim HBx_basis: basis_on A Bx.
{ exact (andEL (basis_on A Bx) (generated_topology A Bx = subspace_topology X Tx A) HBx). }
claim HBy_basis: basis_on B By.
{ exact (andEL (basis_on B By) (generated_topology B By = subspace_topology Y Ty B) HBy). }
claim HBx_eq: generated_topology A Bx = subspace_topology X Tx A.
{ exact (andER (basis_on A Bx) (generated_topology A Bx = subspace_topology X Tx A) HBx). }
claim HBy_eq: generated_topology B By = subspace_topology Y Ty B.
{ exact (andER (basis_on B By) (generated_topology B By = subspace_topology Y Ty B) HBy). }

(** Product of subspaces is generated by C. **)
claim Hprod_gen:
  generated_topology (setprod A B) C =
  product_topology A (subspace_topology X Tx A) B (subspace_topology Y Ty B).
{ exact (product_basis_generates_product_topology
          A B Bx By
          (subspace_topology X Tx A) (subspace_topology Y Ty B)
          HBx_basis HBx_eq
          HBy_basis HBy_eq). }

(** Now show that the subspace topology of the product is also generated by C, using basis_refines_topology. **)
claim HABsub: setprod A B c= setprod X Y.
{ exact (setprod_Subq A B X Y HA HB). }
claim HtopProd: topology_on (setprod X Y) (product_topology X Tx Y Ty).
{ exact (product_topology_is_topology X Tx Y Ty HTx HTy). }
claim HtopSubProd: topology_on (setprod A B)
  (subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B)).
{ exact (subspace_topology_is_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B) HtopProd HABsub). }

claim HCsub: forall c :e C,
  c :e subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B).
{ let c. assume HcC.
  claim HexU: exists U :e Bx, c :e {setprod U V|V :e By}.
  { exact (famunionE Bx (fun U0:set => {setprod U0 V|V :e By}) c HcC). }
  apply HexU.
  let U. assume HUconj.
  claim HUbx: U :e Bx.
  { exact (andEL (U :e Bx) (c :e {setprod U V|V :e By}) HUconj). }
  claim HcRepl: c :e {setprod U V|V :e By}.
  { exact (andER (U :e Bx) (c :e {setprod U V|V :e By}) HUconj). }
  claim HexV: exists V :e By, c = setprod U V.
  { exact (ReplE By (fun V0:set => setprod U V0) c HcRepl). }
  apply HexV.
  let V. assume HVconj.
  claim HVby: V :e By.
  { exact (andEL (V :e By) (c = setprod U V) HVconj). }
  claim HcEqUV: c = setprod U V.
  { exact (andER (V :e By) (c = setprod U V) HVconj). }

  claim HexUx: exists U0 :e Tx, U = U0 :/\: A.
  { exact (ReplE Tx (fun U0:set => U0 :/\: A) U HUbx). }
  claim HexVy: exists V0 :e Ty, V = V0 :/\: B.
  { exact (ReplE Ty (fun V0:set => V0 :/\: B) V HVby). }
  apply HexUx.
  let U0. assume HU0conj.
  claim HU0Tx: U0 :e Tx.
  { exact (andEL (U0 :e Tx) (U = U0 :/\: A) HU0conj). }
  claim HUeq: U = U0 :/\: A.
  { exact (andER (U0 :e Tx) (U = U0 :/\: A) HU0conj). }
  apply HexVy.
  let V0. assume HV0conj.
  claim HV0Ty: V0 :e Ty.
  { exact (andEL (V0 :e Ty) (V = V0 :/\: B) HV0conj). }
  claim HVeq: V = V0 :/\: B.
  { exact (andER (V0 :e Ty) (V = V0 :/\: B) HV0conj). }

  set W := setprod U0 V0.
  claim HWsub: W :e product_subbasis X Tx Y Ty.
  { prove W :e product_subbasis X Tx Y Ty.
    claim HWV: rectangle_set U0 V0 :e {rectangle_set U0 V|V :e Ty}.
    { exact (ReplI Ty (fun V1:set => rectangle_set U0 V1) V0 HV0Ty). }
    exact (famunionI Tx (fun U1:set => {rectangle_set U1 V|V :e Ty}) U0 (rectangle_set U0 V0) HU0Tx HWV). }
  claim HBsubbasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
  { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
  claim HWopen: W :e product_topology X Tx Y Ty.
  { exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty)
            HBsubbasis W HWsub). }

  claim HcPow: c :e Power (setprod A B).
  { apply PowerI (setprod A B) c.
    let p. assume Hp: p :e c.
    prove p :e setprod A B.
    claim HpUV: p :e setprod U V.
    { prove p :e setprod U V.
      rewrite <- HcEqUV.
      exact Hp. }
    claim HsubU: U c= A.
    { prove U c= A.
      rewrite HUeq.
      exact (binintersect_Subq_2 U0 A). }
    claim HsubV: V c= B.
    { prove V c= B.
      rewrite HVeq.
      exact (binintersect_Subq_2 V0 B). }
    claim HsubUV: setprod U V c= setprod A B.
    { exact (setprod_Subq U V A B HsubU HsubV). }
    exact (HsubUV p HpUV). }
  claim HcEqSub: c = W :/\: setprod A B.
  { prove c = W :/\: setprod A B.
    rewrite HcEqUV.
    rewrite HUeq.
    rewrite HVeq.
    rewrite <- (setprod_intersection U0 V0 A B).
    reflexivity. }
  claim HexW: exists V1 :e product_topology X Tx Y Ty, c = V1 :/\: setprod A B.
  { witness W.
    apply andI.
    - exact HWopen.
    - exact HcEqSub. }
  exact (SepI (Power (setprod A B))
              (fun U1:set => exists V1 :e product_topology X Tx Y Ty, U1 = V1 :/\: setprod A B)
              c
              HcPow
              HexW). }

claim Href: forall U1 :e subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B),
  forall p :e U1,
  exists Cx :e C, p :e Cx /\ Cx c= U1.
{ let U1. assume HU1: U1 :e subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B).
  let p. assume HpU1: p :e U1.
  claim HU1sub: U1 c= setprod A B.
  { exact (PowerE (setprod A B) U1 (SepE1 (Power (setprod A B))
                (fun U0:set => exists V0 :e product_topology X Tx Y Ty, U0 = V0 :/\: setprod A B)
                U1 HU1)). }
  claim HpAB: p :e setprod A B.
  { exact (HU1sub p HpU1). }
  claim HU1prop: exists W :e product_topology X Tx Y Ty, U1 = W :/\: setprod A B.
  { exact (SepE2 (Power (setprod A B))
                 (fun U0:set => exists V0 :e product_topology X Tx Y Ty, U0 = V0 :/\: setprod A B)
                 U1 HU1). }
  apply HU1prop.
  let W. assume HWconj.
  claim HWopen: W :e product_topology X Tx Y Ty.
  { exact (andEL (W :e product_topology X Tx Y Ty) (U1 = W :/\: setprod A B) HWconj). }
  claim HU1eq: U1 = W :/\: setprod A B.
  { exact (andER (W :e product_topology X Tx Y Ty) (U1 = W :/\: setprod A B) HWconj). }
  claim HpWAB: p :e W :/\: setprod A B.
  { rewrite <- HU1eq. exact HpU1. }
  claim HpW: p :e W.
  { exact (binintersectE1 W (setprod A B) p HpWAB). }

  claim HWgen: W :e generated_topology (setprod X Y) (product_subbasis X Tx Y Ty).
  { exact HWopen. }
  claim HWref: forall z :e W, exists b :e product_subbasis X Tx Y Ty, z :e b /\ b c= W.
  { exact (SepE2 (Power (setprod X Y))
                 (fun U0 : set => forall z0 :e U0, exists b0 :e product_subbasis X Tx Y Ty, z0 :e b0 /\ b0 c= U0)
                 W
                 HWgen). }
  claim Hexb: exists b :e product_subbasis X Tx Y Ty, p :e b /\ b c= W.
  { exact (HWref p HpW). }
  apply Hexb.
  let b. assume Hbconj.
  claim HbSub: b :e product_subbasis X Tx Y Ty.
  { exact (andEL (b :e product_subbasis X Tx Y Ty) (p :e b /\ b c= W) Hbconj). }
  claim Hbprop: p :e b /\ b c= W.
  { exact (andER (b :e product_subbasis X Tx Y Ty) (p :e b /\ b c= W) Hbconj). }
  claim Hpb: p :e b.
  { exact (andEL (p :e b) (b c= W) Hbprop). }
  claim HbsubW: b c= W.
  { exact (andER (p :e b) (b c= W) Hbprop). }

  claim HexU: exists U0 :e Tx, b :e {rectangle_set U0 V|V :e Ty}.
  { exact (famunionE Tx (fun U0:set => {rectangle_set U0 V|V :e Ty}) b HbSub). }
  apply HexU.
  let U0. assume HU0conj.
  claim HU0Tx: U0 :e Tx.
  { exact (andEL (U0 :e Tx) (b :e {rectangle_set U0 V|V :e Ty}) HU0conj). }
  claim HbRepl: b :e {rectangle_set U0 V|V :e Ty}.
  { exact (andER (U0 :e Tx) (b :e {rectangle_set U0 V|V :e Ty}) HU0conj). }
  claim HexV: exists V0 :e Ty, b = rectangle_set U0 V0.
  { exact (ReplE Ty (fun V0:set => rectangle_set U0 V0) b HbRepl). }
  apply HexV.
  let V0. assume HV0conj.
  claim HV0Ty: V0 :e Ty.
  { exact (andEL (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }
  claim Hbeq: b = rectangle_set U0 V0.
  { exact (andER (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }

  set Cx := setprod (U0 :/\: A) (V0 :/\: B).
  witness Cx.
  apply andI.
  - prove Cx :e C.
    claim HU0Bx: U0 :/\: A :e Bx.
    { exact (ReplI Tx (fun U1:set => U1 :/\: A) U0 HU0Tx). }
    claim HV0By: V0 :/\: B :e By.
    { exact (ReplI Ty (fun V1:set => V1 :/\: B) V0 HV0Ty). }
    claim HcxRepl: setprod (U0 :/\: A) (V0 :/\: B) :e {setprod (U0 :/\: A) V|V :e By}.
    { exact (ReplI By (fun V1:set => setprod (U0 :/\: A) V1) (V0 :/\: B) HV0By). }
    exact (famunionI Bx (fun U1:set => {setprod U1 V|V :e By}) (U0 :/\: A)
            (setprod (U0 :/\: A) (V0 :/\: B)) HU0Bx HcxRepl).
  - apply andI.
    + prove p :e Cx.
      claim HpInInter: p :e (rectangle_set U0 V0) :/\: setprod A B.
      { prove p :e (rectangle_set U0 V0) :/\: setprod A B.
        apply binintersectI.
        - prove p :e rectangle_set U0 V0.
          rewrite <- Hbeq.
          exact Hpb.
        - exact HpAB. }
      rewrite <- (setprod_intersection U0 V0 A B).
      exact HpInInter.
    + prove Cx c= U1.
      claim HCx_sub_b: Cx c= rectangle_set U0 V0.
      { exact (setprod_Subq (U0 :/\: A) (V0 :/\: B) U0 V0 (binintersect_Subq_1 U0 A) (binintersect_Subq_1 V0 B)). }
      claim HCx_sub_W: Cx c= W.
      { claim HrectSubb: rectangle_set U0 V0 c= b.
        { prove rectangle_set U0 V0 c= b.
          rewrite <- Hbeq.
          exact (Subq_ref b). }
        exact (Subq_tra Cx (rectangle_set U0 V0) W HCx_sub_b
                 (Subq_tra (rectangle_set U0 V0) b W HrectSubb HbsubW)). }
      claim HCx_sub_AB: Cx c= setprod A B.
      { exact (setprod_Subq (U0 :/\: A) (V0 :/\: B) A B (binintersect_Subq_2 U0 A) (binintersect_Subq_2 V0 B)). }
      claim HCx_sub_WAB: Cx c= W :/\: setprod A B.
      { exact (binintersect_Subq_max W (setprod A B) Cx HCx_sub_W HCx_sub_AB). }
      rewrite HU1eq.
      exact HCx_sub_WAB. }

claim HsubEq:
  generated_topology (setprod A B) C =
  subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B).
{ exact (andER (basis_on (setprod A B) C)
               (generated_topology (setprod A B) C = subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B))
               (basis_refines_topology (setprod A B)
                 (subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B))
                 C
                 HtopSubProd
                 HCsub
                 Href)). }

(** Conclude by identifying both sides with generated_topology (setprod A B) C. **)
rewrite <- Hprod_gen.
rewrite HsubEq.
reflexivity.
Qed.

(** from 16 Example 3: ordered square versus subspace topology **) 
(** LATEX VERSION: Example 3: The order topology on the ordered square differs from the subspace topology inherited from the dictionary order on . **)
(** FIXED: Unit interval [0,1] = {x  R | 0  x  1}, using negated strict inequality: x  0 means ~(x < 0) and x  1 means ~(1 < x). **)
Definition unit_interval : set := {x :e R | ~(Rlt x 0) /\ ~(Rlt 1 x)}.

(** helper: unit_interval is a subset of R **)
(** LATEX VERSION: The unit interval [0,1] is a subset of the real line. **)
Theorem unit_interval_sub_R : unit_interval c= R.
let x. assume Hx: x :e unit_interval.
exact (SepE1 R (fun x0:set => ~(Rlt x0 0) /\ ~(Rlt 1 x0)) x Hx).
Qed.

(** helper: eps_1 is a real number **)
Theorem eps_1_in_R : eps_ 1 :e R.
prove eps_ 1 :e R.
claim H1omega: 1 :e omega.
{ exact (nat_p_omega 1 nat_1). }
claim Heps1SNoS: eps_ 1 :e SNoS_ omega.
{ exact (SNo_eps_SNoS_omega 1 H1omega). }
exact (SNoS_omega_real (eps_ 1) Heps1SNoS).
Qed.

(** helper: eps_1 is strictly between 0 and 1 in R **)
Theorem eps_1_pos_R : Rlt 0 (eps_ 1).
prove Rlt 0 (eps_ 1).
claim H1omega: 1 :e omega.
{ exact (nat_p_omega 1 nat_1). }
exact (RltI 0 (eps_ 1) real_0 eps_1_in_R (SNo_eps_pos 1 H1omega)).
Qed.

(** helper: eps_1 is less than 1 in R **)
Theorem eps_1_lt1_R : Rlt (eps_ 1) 1.
prove Rlt (eps_ 1) 1.
claim H1omega: 1 :e omega.
{ exact (nat_p_omega 1 nat_1). }
claim H0Ord: ordinal 0.
{ exact (nat_p_ordinal 0 nat_0). }
claim H0in1: 0 :e 1.
{ exact (ordinal_0_In_ordsucc 0 H0Ord). }
claim HepsLtE0: eps_ 1 < eps_ 0.
{ exact (SNo_eps_decr 1 H1omega 0 H0in1). }
claim HepsLt1S: (eps_ 1) < 1.
{ rewrite <- (eps_0_1) at 2.
  exact HepsLtE0. }
exact (RltI (eps_ 1) 1 eps_1_in_R real_1 HepsLt1S).
Qed.

(** helper: 0 is in the unit interval **)
Theorem zero_in_unit_interval : 0 :e unit_interval.
prove 0 :e unit_interval.
claim H0R: 0 :e R.
{ exact real_0. }
claim Hnlt00: ~(Rlt 0 0).
{ exact (not_Rlt_refl 0 H0R). }
claim H0lt1: Rlt 0 1.
{ exact (RltI 0 1 real_0 real_1 SNoLt_0_1). }
claim Hnlt10: ~(Rlt 1 0).
{ exact (not_Rlt_sym 0 1 H0lt1). }
exact (SepI R (fun t:set => ~(Rlt t 0) /\ ~(Rlt 1 t))
           0 H0R
           (andI (~(Rlt 0 0)) (~(Rlt 1 0)) Hnlt00 Hnlt10)).
Qed.

(** helper: 1 is in the unit interval **)
Theorem one_in_unit_interval : 1 :e unit_interval.
prove 1 :e unit_interval.
claim H1R: 1 :e R.
{ exact real_1. }
claim H0lt1: Rlt 0 1.
{ exact (RltI 0 1 real_0 real_1 SNoLt_0_1). }
claim Hnlt10: ~(Rlt 1 0).
{ exact (not_Rlt_sym 0 1 H0lt1). }
claim Hnlt11: ~(Rlt 1 1).
{ exact (not_Rlt_refl 1 H1R). }
exact (SepI R (fun t:set => ~(Rlt t 0) /\ ~(Rlt 1 t))
           1 H1R
           (andI (~(Rlt 1 0)) (~(Rlt 1 1)) Hnlt10 Hnlt11)).
Qed.

(** helper: eps_1 is in the unit interval **)
Theorem eps_1_in_unit_interval : eps_ 1 :e unit_interval.
prove eps_ 1 :e unit_interval.
claim Hnlt_eps10: ~(Rlt (eps_ 1) 0).
{ exact (not_Rlt_sym 0 (eps_ 1) eps_1_pos_R). }
claim Hnlt_1eps1: ~(Rlt 1 (eps_ 1)).
{ exact (not_Rlt_sym (eps_ 1) 1 eps_1_lt1_R). }
exact (SepI R (fun t:set => ~(Rlt t 0) /\ ~(Rlt 1 t))
           (eps_ 1) eps_1_in_R
           (andI (~(Rlt (eps_ 1) 0)) (~(Rlt 1 (eps_ 1))) Hnlt_eps10 Hnlt_1eps1)).
Qed.

(** helper: 2 is not in the unit interval **)
(** LATEX VERSION: 2 is not in [0,1]. **)
Theorem two_not_in_unit_interval : 2 /:e unit_interval.
assume H2I: 2 :e unit_interval.
prove False.
claim H2R: 2 :e R.
{ exact (SepE1 R (fun x0:set => ~(Rlt x0 0) /\ ~(Rlt 1 x0)) 2 H2I). }
claim Hprop: ~(Rlt 1 2).
{ claim Hconj: ~(Rlt 2 0) /\ ~(Rlt 1 2).
  { exact (SepE2 R (fun x0:set => ~(Rlt x0 0) /\ ~(Rlt 1 x0)) 2 H2I). }
  exact (andER (~(Rlt 2 0)) (~(Rlt 1 2)) Hconj). }
claim H12: Rlt 1 2.
{ exact (RltI 1 2 real_1 H2R SNoLt_1_2). }
exact (Hprop H12).
Qed.

(** helper: 2 is a real number **)
(** LATEX VERSION: 2 is a real number. **)
Theorem two_in_R : 2 :e R.
prove 2 :e R.
claim HsumR: add_SNo 1 1 :e R.
{ exact (real_add_SNo 1 real_1 1 real_1). }
rewrite <- add_SNo_1_1_2.
exact HsumR.
Qed.

(** helper: unit interval is a proper subset of R **)
(** LATEX VERSION: [0,1] is not all of . **)
Theorem unit_interval_neq_R : unit_interval <> R.
assume Heq: unit_interval = R.
prove False.
claim H2I: 2 :e unit_interval.
{ rewrite Heq.
  exact two_in_R. }
exact (two_not_in_unit_interval H2I).
Qed.

(** helper: standard topology on the unit interval as a subspace of R **)
(** LATEX VERSION: Equip [0,1] with the subspace topology inherited from the standard topology on R. **)
Definition unit_interval_topology : set :=
  subspace_topology R R_standard_topology unit_interval.
Theorem unit_interval_topology_on : topology_on unit_interval unit_interval_topology.
prove topology_on unit_interval unit_interval_topology.
exact (subspace_topology_is_topology R R_standard_topology unit_interval
         R_standard_topology_is_topology
         unit_interval_sub_R).
Qed.

(** helper: flip map t |-> 1 + -t on the unit interval, used for reversing paths **)
Definition flip_unit_interval : set :=
  {(t, add_SNo 1 (minus_SNo t)) | t :e unit_interval}.

(** helper: application of flip_unit_interval **)
Theorem flip_unit_interval_apply : forall t:set,
  t :e unit_interval ->
  apply_fun flip_unit_interval t = add_SNo 1 (minus_SNo t).
let t.
assume Ht: t :e unit_interval.
prove apply_fun flip_unit_interval t = add_SNo 1 (minus_SNo t).
prove Eps_i (fun z => (t,z) :e flip_unit_interval) = add_SNo 1 (minus_SNo t).
claim H1: (t, add_SNo 1 (minus_SNo t)) :e flip_unit_interval.
{ exact (ReplI unit_interval (fun t0:set => (t0, add_SNo 1 (minus_SNo t0))) t Ht). }
claim H2: (t, Eps_i (fun z => (t,z) :e flip_unit_interval)) :e flip_unit_interval.
{ exact (Eps_i_ax (fun z => (t,z) :e flip_unit_interval) (add_SNo 1 (minus_SNo t)) H1). }
apply (ReplE_impred unit_interval (fun t0:set => (t0, add_SNo 1 (minus_SNo t0)))
        (t, Eps_i (fun z => (t,z) :e flip_unit_interval)) H2).
let y.
assume Hy: y :e unit_interval.
assume Heq: (t, Eps_i (fun z => (t,z) :e flip_unit_interval)) = (y, add_SNo 1 (minus_SNo y)).
claim Ht_eq: t = y.
{ rewrite <- (tuple_2_0_eq t (Eps_i (fun z => (t,z) :e flip_unit_interval))).
  rewrite <- (tuple_2_0_eq y (add_SNo 1 (minus_SNo y))).
  rewrite Heq.
  reflexivity. }
claim Hz_eq: Eps_i (fun z => (t,z) :e flip_unit_interval) = add_SNo 1 (minus_SNo y).
{ rewrite <- (tuple_2_1_eq t (Eps_i (fun z => (t,z) :e flip_unit_interval))).
  rewrite <- (tuple_2_1_eq y (add_SNo 1 (minus_SNo y))).
  rewrite Heq.
  reflexivity. }
rewrite Hz_eq.
rewrite <- Ht_eq.
reflexivity.
Qed.

(** helper: flip_unit_interval maps into R **)
Theorem flip_unit_interval_in_R : forall t:set,
  t :e unit_interval ->
  apply_fun flip_unit_interval t :e R.
let t.
assume Ht: t :e unit_interval.
prove apply_fun flip_unit_interval t :e R.
claim HtR: t :e R.
{ exact (unit_interval_sub_R t Ht). }
claim HmR: minus_SNo t :e R.
{ exact (real_minus_SNo t HtR). }
claim HaddR: add_SNo 1 (minus_SNo t) :e R.
{ exact (real_add_SNo 1 real_1 (minus_SNo t) HmR). }
rewrite (flip_unit_interval_apply t Ht).
exact HaddR.
Qed.

(** helper: flip_unit_interval at endpoints **)
Theorem flip_unit_interval_at_0 : apply_fun flip_unit_interval 0 = 1.
prove apply_fun flip_unit_interval 0 = 1.
claim H0I: 0 :e unit_interval.
{ exact zero_in_unit_interval. }
rewrite (flip_unit_interval_apply 0 H0I).
rewrite minus_SNo_0.
exact (add_SNo_0R 1 SNo_1).
Qed.

Theorem flip_unit_interval_at_1 : apply_fun flip_unit_interval 1 = 0.
prove apply_fun flip_unit_interval 1 = 0.
claim H1I: 1 :e unit_interval.
{ exact one_in_unit_interval. }
rewrite (flip_unit_interval_apply 1 H1I).
exact (add_SNo_minus_SNo_rinv 1 SNo_1).
Qed.

(** helper: flip_unit_interval is a self-map of the unit interval (placeholder) **)
Theorem flip_unit_interval_function_on :
  function_on flip_unit_interval unit_interval unit_interval.
let t.
assume HtI: t :e unit_interval.
prove apply_fun flip_unit_interval t :e unit_interval.
claim HtR: t :e R.
{ exact (unit_interval_sub_R t HtI). }
claim Htprop: ~(Rlt t 0) /\ ~(Rlt 1 t).
{ exact (SepE2 R (fun x0:set => ~(Rlt x0 0) /\ ~(Rlt 1 x0)) t HtI). }
claim Hnlt_t0: ~(Rlt t 0).
{ exact (andEL (~(Rlt t 0)) (~(Rlt 1 t)) Htprop). }
claim Hnlt_1t: ~(Rlt 1 t).
{ exact (andER (~(Rlt t 0)) (~(Rlt 1 t)) Htprop). }
claim HmR: minus_SNo t :e R.
{ exact (real_minus_SNo t HtR). }
rewrite (flip_unit_interval_apply t HtI).
prove (add_SNo 1 (minus_SNo t)) :e unit_interval.
claim HsumR: add_SNo 1 (minus_SNo t) :e R.
{ exact (real_add_SNo 1 real_1 (minus_SNo t) HmR). }
claim HtS: SNo t.
{ exact (real_SNo t HtR). }
claim Hm1R: minus_SNo 1 :e R.
{ exact (real_minus_SNo 1 real_1). }
claim Hm1S: SNo (minus_SNo 1).
{ exact (real_SNo (minus_SNo 1) Hm1R). }
claim HmtS: SNo (minus_SNo t).
{ exact (real_SNo (minus_SNo t) HmR). }

(** lower bound: ~( (1 + (-t)) < 0 ), using add_SNo cancellation **)
claim Hnlt_sum0: ~(Rlt (add_SNo 1 (minus_SNo t)) 0).
{ assume Hlt: Rlt (add_SNo 1 (minus_SNo t)) 0.
  prove False.
  claim HltS: (add_SNo 1 (minus_SNo t)) < 0.
  { exact (RltE_lt (add_SNo 1 (minus_SNo t)) 0 Hlt). }
  claim HltS1: (add_SNo 1 (minus_SNo t)) < (add_SNo 1 (minus_SNo 1)).
  { rewrite (add_SNo_minus_SNo_rinv 1 SNo_1).
    exact HltS. }
  claim Hmtltm1: (minus_SNo t) < (minus_SNo 1).
  { exact (add_SNo_Lt2_cancel 1 (minus_SNo t) (minus_SNo 1) SNo_1 HmtS Hm1S HltS1). }
  claim H1ltmm: 1 < minus_SNo (minus_SNo t).
  { exact (minus_SNo_Lt_contra2 (minus_SNo t) 1 HmtS SNo_1 Hmtltm1). }
  claim H1ltt: 1 < t.
  { rewrite <- (minus_SNo_invol t HtS).
    exact H1ltmm. }
  claim H1lt: Rlt 1 t.
  { exact (RltI 1 t real_1 HtR H1ltt). }
  exact (Hnlt_1t H1lt). }

(** upper bound: ~( 1 < (1 + (-t)) ), using add_SNo cancellation **)
claim Hnlt_1sum: ~(Rlt 1 (add_SNo 1 (minus_SNo t))).
{ assume Hlt: Rlt 1 (add_SNo 1 (minus_SNo t)).
  prove False.
  claim HltS: 1 < (add_SNo 1 (minus_SNo t)).
  { exact (RltE_lt 1 (add_SNo 1 (minus_SNo t)) Hlt). }
  claim HltS1: (add_SNo 1 0) < (add_SNo 1 (minus_SNo t)).
  { rewrite (add_SNo_0R 1 SNo_1).
    exact HltS. }
  claim H0ltmt: 0 < (minus_SNo t).
  { exact (add_SNo_Lt2_cancel 1 0 (minus_SNo t) SNo_1 SNo_0 HmtS HltS1). }
  claim Htltm0: t < minus_SNo 0.
  { exact (minus_SNo_Lt_contra2 0 t SNo_0 HtS H0ltmt). }
  claim Htlt0S: t < 0.
  { rewrite <- minus_SNo_0.
    exact Htltm0. }
  claim Htlt0: Rlt t 0.
  { exact (RltI t 0 HtR real_0 Htlt0S). }
  exact (Hnlt_t0 Htlt0). }

exact (SepI R (fun x0:set => ~(Rlt x0 0) /\ ~(Rlt 1 x0))
           (add_SNo 1 (minus_SNo t)) HsumR
           (andI (~(Rlt (add_SNo 1 (minus_SNo t)) 0))
                 (~(Rlt 1 (add_SNo 1 (minus_SNo t))))
                 Hnlt_sum0 Hnlt_1sum)).
Qed.

(** helper: neighborhoods of eps_ 1 in the unit interval contain other points **)
(** LATEX VERSION: Any open set in the unit interval topology containing 1/2 contains a point different from 1/2. **)
Theorem unit_interval_open_neighborhood_has_other_point : forall U0:set,
  U0 :e unit_interval_topology ->
  eps_ 1 :e U0 ->
  exists x:set, x :e U0 /\ x <> eps_ 1.
let U0.
assume HU0Tx: U0 :e unit_interval_topology.
assume HepsU0: eps_ 1 :e U0.
claim Hut: unit_interval_topology = subspace_topology R R_standard_topology unit_interval.
{ reflexivity. }
claim HU0Sub: U0 :e subspace_topology R R_standard_topology unit_interval.
{ rewrite <- Hut. exact HU0Tx. }
claim HU0Pow: U0 :e Power unit_interval.
{ exact (SepE1 (Power unit_interval)
               (fun U:set => exists V :e R_standard_topology, U = V :/\: unit_interval)
               U0 HU0Sub). }
claim HU0subI: U0 c= unit_interval.
{ exact (PowerE unit_interval U0 HU0Pow). }
claim HepsI: eps_ 1 :e unit_interval.
{ exact (HU0subI (eps_ 1) HepsU0). }
claim HepsR: eps_ 1 :e R.
{ exact (unit_interval_sub_R (eps_ 1) HepsI). }
claim H1omega: 1 :e omega.
{ exact (nat_p_omega 1 nat_1). }
claim HepsS: SNo (eps_ 1).
{ exact (real_SNo (eps_ 1) HepsR). }
claim HepsPosS: 0 < (eps_ 1).
{ exact (SNo_eps_pos 1 H1omega). }
claim H0ltEps: Rlt 0 (eps_ 1).
{ exact (RltI 0 (eps_ 1) real_0 HepsR HepsPosS). }
claim H0Ord: ordinal 0.
{ exact (nat_p_ordinal 0 nat_0). }
claim H0in1: 0 :e 1.
{ exact (ordinal_0_In_ordsucc 0 H0Ord). }
claim HepsLt1S: (eps_ 1) < 1.
{ claim HepsLtE0: eps_ 1 < eps_ 0.
  { exact (SNo_eps_decr 1 H1omega 0 H0in1). }
  rewrite <- (eps_0_1) at 2.
  exact HepsLtE0. }
claim HepsLt1: Rlt (eps_ 1) 1.
{ exact (RltI (eps_ 1) 1 HepsR real_1 HepsLt1S). }
claim HexV: exists V :e R_standard_topology, U0 = V :/\: unit_interval.
{ exact (SepE2 (Power unit_interval)
               (fun U:set => exists V :e R_standard_topology, U = V :/\: unit_interval)
               U0 HU0Sub). }
apply HexV.
let V.
assume HVpair.
claim HV: V :e R_standard_topology.
{ exact (andEL (V :e R_standard_topology) (U0 = V :/\: unit_interval) HVpair). }
claim HU0eq: U0 = V :/\: unit_interval.
{ exact (andER (V :e R_standard_topology) (U0 = V :/\: unit_interval) HVpair). }
claim HepsV: eps_ 1 :e V.
{ claim HepsCap: eps_ 1 :e V :/\: unit_interval.
  { rewrite <- HU0eq. exact HepsU0. }
  apply (binintersectE V unit_interval (eps_ 1) HepsCap).
  assume HepsV0 HepsI0.
  exact HepsV0. }
claim HrTopDef: R_standard_topology = generated_topology R R_standard_basis.
{ reflexivity. }
claim HVgen: V :e generated_topology R R_standard_basis.
{ rewrite <- HrTopDef. exact HV. }
claim HVprop: forall x :e V, exists b :e R_standard_basis, x :e b /\ b c= V.
{ exact (SepE2 (Power R)
               (fun U:set => forall x0 :e U, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U)
               V HVgen). }
claim Hexb: exists b :e R_standard_basis, eps_ 1 :e b /\ b c= V.
{ exact (HVprop (eps_ 1) HepsV). }
apply Hexb.
let b.
assume Hbpair.
claim HbB: b :e R_standard_basis.
{ exact (andEL (b :e R_standard_basis) (eps_ 1 :e b /\ b c= V) Hbpair). }
claim Hbprop: eps_ 1 :e b /\ b c= V.
{ exact (andER (b :e R_standard_basis) (eps_ 1 :e b /\ b c= V) Hbpair). }
claim Hepsb: eps_ 1 :e b.
{ exact (andEL (eps_ 1 :e b) (b c= V) Hbprop). }
claim HbsubV: b c= V.
{ exact (andER (eps_ 1 :e b) (b c= V) Hbprop). }
claim Hexa: exists a :e R, b :e {open_interval a bb|bb :e R}.
{ exact (famunionE R (fun a0:set => {open_interval a0 bb|bb :e R}) b HbB). }
apply Hexa.
let a.
assume Hapair.
claim HaR: a :e R.
{ exact (andEL (a :e R) (b :e {open_interval a bb|bb :e R}) Hapair). }
claim HbFam: b :e {open_interval a bb|bb :e R}.
{ exact (andER (a :e R) (b :e {open_interval a bb|bb :e R}) Hapair). }
claim Hexbb: exists bb :e R, b = open_interval a bb.
{ exact (ReplE R (fun bb0:set => open_interval a bb0) b HbFam). }
apply Hexbb.
let bb.
assume Hbbpair.
claim HbbR: bb :e R.
{ exact (andEL (bb :e R) (b = open_interval a bb) Hbbpair). }
claim Hbeq: b = open_interval a bb.
{ exact (andER (bb :e R) (b = open_interval a bb) Hbbpair). }
claim HepsInInt: eps_ 1 :e open_interval a bb.
{ rewrite <- Hbeq. exact Hepsb. }
claim HepsIntProp: Rlt a (eps_ 1) /\ Rlt (eps_ 1) bb.
{ exact (SepE2 R (fun t:set => Rlt a t /\ Rlt t bb) (eps_ 1) HepsInInt). }
claim HaLtEps: Rlt a (eps_ 1).
{ exact (andEL (Rlt a (eps_ 1)) (Rlt (eps_ 1) bb) HepsIntProp). }
claim HepsLtbb: Rlt (eps_ 1) bb.
{ exact (andER (Rlt a (eps_ 1)) (Rlt (eps_ 1) bb) HepsIntProp). }
claim HaS: SNo a.
{ exact (real_SNo a HaR). }
claim HbbS: SNo bb.
{ exact (real_SNo bb HbbR). }
apply (SNoLt_trichotomy_or_impred bb 1 HbbS SNo_1 (exists x:set, x :e U0 /\ x <> eps_ 1)).
- assume HbbLt1S: bb < 1.
  claim HbbLt1: Rlt bb 1.
  { exact (RltI bb 1 HbbR real_1 HbbLt1S). }
  apply (rational_dense_between_reals (eps_ 1) bb HepsR HbbR HepsLtbb).
  let q.
  assume Hqpair.
  claim HqQ: q :e rational_numbers.
  { exact (andEL (q :e rational_numbers) (Rlt (eps_ 1) q /\ Rlt q bb) Hqpair). }
  claim Hqprop: Rlt (eps_ 1) q /\ Rlt q bb.
  { exact (andER (q :e rational_numbers) (Rlt (eps_ 1) q /\ Rlt q bb) Hqpair). }
  claim HepsLtq: Rlt (eps_ 1) q.
  { exact (andEL (Rlt (eps_ 1) q) (Rlt q bb) Hqprop). }
  claim HqLtbb: Rlt q bb.
  { exact (andER (Rlt (eps_ 1) q) (Rlt q bb) Hqprop). }
  claim HqR: q :e R.
  { exact (rational_numbers_in_R q HqQ). }
  claim HaLtq: Rlt a q.
  { exact (Rlt_tra a (eps_ 1) q HaLtEps HepsLtq). }
  claim HqInb: q :e b.
  { rewrite Hbeq.
    claim Hqconj: Rlt a q /\ Rlt q bb.
    { apply andI.
      - exact HaLtq.
      - exact HqLtbb. }
    exact (SepI R (fun t:set => Rlt a t /\ Rlt t bb) q HqR Hqconj). }
  claim HqInV: q :e V.
  { exact (HbsubV q HqInb). }
  claim H0ltq: Rlt 0 q.
  { exact (Rlt_tra 0 (eps_ 1) q H0ltEps HepsLtq). }
  claim HqLt1: Rlt q 1.
  { exact (Rlt_tra q bb 1 HqLtbb HbbLt1). }
  claim Hnltq0: ~(Rlt q 0).
  { exact (not_Rlt_sym 0 q H0ltq). }
  claim Hnlt1q: ~(Rlt 1 q).
  { exact (not_Rlt_sym q 1 HqLt1). }
  claim HqInI: q :e unit_interval.
  { claim Hqconj: ~(Rlt q 0) /\ ~(Rlt 1 q).
    { apply andI.
      - exact Hnltq0.
      - exact Hnlt1q. }
    exact (SepI R (fun x0:set => ~(Rlt x0 0) /\ ~(Rlt 1 x0)) q HqR Hqconj). }
  claim HqInU0: q :e U0.
  { rewrite HU0eq.
    apply binintersectI.
    - exact HqInV.
    - exact HqInI. }
  witness q.
  apply andI.
  * exact HqInU0.
  * prove q <> eps_ 1.
    assume Heq: q = eps_ 1.
    claim Hbad: Rlt (eps_ 1) (eps_ 1).
    { rewrite <- Heq at 2. exact HepsLtq. }
    exact ((not_Rlt_refl (eps_ 1) HepsR) Hbad).
- assume HbbEq: bb = 1.
  apply (rational_dense_between_reals (eps_ 1) 1 HepsR real_1 HepsLt1).
  let q.
  assume Hqpair.
  claim HqQ: q :e rational_numbers.
  { exact (andEL (q :e rational_numbers) (Rlt (eps_ 1) q /\ Rlt q 1) Hqpair). }
  claim Hqprop: Rlt (eps_ 1) q /\ Rlt q 1.
  { exact (andER (q :e rational_numbers) (Rlt (eps_ 1) q /\ Rlt q 1) Hqpair). }
  claim HepsLtq: Rlt (eps_ 1) q.
  { exact (andEL (Rlt (eps_ 1) q) (Rlt q 1) Hqprop). }
  claim HqLt1: Rlt q 1.
  { exact (andER (Rlt (eps_ 1) q) (Rlt q 1) Hqprop). }
  claim HqR: q :e R.
  { exact (rational_numbers_in_R q HqQ). }
  claim HaLtq: Rlt a q.
  { exact (Rlt_tra a (eps_ 1) q HaLtEps HepsLtq). }
  claim HqLtbb: Rlt q bb.
  { rewrite HbbEq. exact HqLt1. }
  claim HqInb: q :e b.
  { rewrite Hbeq.
    claim Hqconj: Rlt a q /\ Rlt q bb.
    { apply andI.
      - exact HaLtq.
      - exact HqLtbb. }
    exact (SepI R (fun t:set => Rlt a t /\ Rlt t bb) q HqR Hqconj). }
  claim HqInV: q :e V.
  { exact (HbsubV q HqInb). }
  claim H0ltq: Rlt 0 q.
  { exact (Rlt_tra 0 (eps_ 1) q H0ltEps HepsLtq). }
  claim Hnltq0: ~(Rlt q 0).
  { exact (not_Rlt_sym 0 q H0ltq). }
  claim Hnlt1q: ~(Rlt 1 q).
  { exact (not_Rlt_sym q 1 HqLt1). }
  claim HqInI: q :e unit_interval.
  { claim Hqconj: ~(Rlt q 0) /\ ~(Rlt 1 q).
    { apply andI.
      - exact Hnltq0.
      - exact Hnlt1q. }
    exact (SepI R (fun x0:set => ~(Rlt x0 0) /\ ~(Rlt 1 x0)) q HqR Hqconj). }
  claim HqInU0: q :e U0.
  { rewrite HU0eq.
    apply binintersectI.
    - exact HqInV.
    - exact HqInI. }
  witness q.
  apply andI.
  * exact HqInU0.
  * prove q <> eps_ 1.
    assume Heq: q = eps_ 1.
    claim Hbad: Rlt (eps_ 1) (eps_ 1).
    { rewrite <- Heq at 2. exact HepsLtq. }
    exact ((not_Rlt_refl (eps_ 1) HepsR) Hbad).
- assume H1LtbbS: 1 < bb.
  claim H1Ltbb: Rlt 1 bb.
  { exact (RltI 1 bb real_1 HbbR H1LtbbS). }
  apply (rational_dense_between_reals (eps_ 1) 1 HepsR real_1 HepsLt1).
  let q.
  assume Hqpair.
  claim HqQ: q :e rational_numbers.
  { exact (andEL (q :e rational_numbers) (Rlt (eps_ 1) q /\ Rlt q 1) Hqpair). }
  claim Hqprop: Rlt (eps_ 1) q /\ Rlt q 1.
  { exact (andER (q :e rational_numbers) (Rlt (eps_ 1) q /\ Rlt q 1) Hqpair). }
  claim HepsLtq: Rlt (eps_ 1) q.
  { exact (andEL (Rlt (eps_ 1) q) (Rlt q 1) Hqprop). }
  claim HqLt1: Rlt q 1.
  { exact (andER (Rlt (eps_ 1) q) (Rlt q 1) Hqprop). }
  claim HqR: q :e R.
  { exact (rational_numbers_in_R q HqQ). }
  claim HaLtq: Rlt a q.
  { exact (Rlt_tra a (eps_ 1) q HaLtEps HepsLtq). }
  claim HqLtbb: Rlt q bb.
  { exact (Rlt_tra q 1 bb HqLt1 H1Ltbb). }
  claim HqInb: q :e b.
  { rewrite Hbeq.
    claim Hqconj: Rlt a q /\ Rlt q bb.
    { apply andI.
      - exact HaLtq.
      - exact HqLtbb. }
    exact (SepI R (fun t:set => Rlt a t /\ Rlt t bb) q HqR Hqconj). }
  claim HqInV: q :e V.
  { exact (HbsubV q HqInb). }
  claim H0ltq: Rlt 0 q.
  { exact (Rlt_tra 0 (eps_ 1) q H0ltEps HepsLtq). }
  claim Hnltq0: ~(Rlt q 0).
  { exact (not_Rlt_sym 0 q H0ltq). }
  claim Hnlt1q: ~(Rlt 1 q).
  { exact (not_Rlt_sym q 1 HqLt1). }
  claim HqInI: q :e unit_interval.
  { claim Hqconj: ~(Rlt q 0) /\ ~(Rlt 1 q).
    { apply andI.
      - exact Hnltq0.
      - exact Hnlt1q. }
    exact (SepI R (fun x0:set => ~(Rlt x0 0) /\ ~(Rlt 1 x0)) q HqR Hqconj). }
  claim HqInU0: q :e U0.
  { rewrite HU0eq.
    apply binintersectI.
    - exact HqInV.
    - exact HqInI. }
  witness q.
  apply andI.
  * exact HqInU0.
  * prove q <> eps_ 1.
    assume Heq: q = eps_ 1.
    claim Hbad: Rlt (eps_ 1) (eps_ 1).
    { rewrite <- Heq at 2. exact HepsLtq. }
    exact ((not_Rlt_refl (eps_ 1) HepsR) Hbad).
Qed.
Definition ordered_square : set := setprod unit_interval unit_interval.
(** helper: basis for the dictionary order topology on II, using the dictionary comparison on RR **)
Definition ordered_square_order_basis : set :=
  ({I :e Power ordered_square | exists a :e ordered_square, exists b :e ordered_square,
        I = {x :e ordered_square | order_rel (setprod R R) a x /\ order_rel (setprod R R) x b}}
   :\/:
   {I :e Power ordered_square | exists b :e ordered_square,
        I = {x :e ordered_square | order_rel (setprod R R) x b}}
   :\/:
   {I :e Power ordered_square | exists a :e ordered_square,
        I = {x :e ordered_square | order_rel (setprod R R) a x}}).

Definition ordered_square_topology : set := generated_topology ordered_square ordered_square_order_basis.
(** LATEX VERSION: The vertical strip {1/2}(1/2,1] inside II. **)
Definition ordered_square_open_strip : set :=
  {p :e ordered_square|exists y:set, p = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y)}.
Definition ordered_square_subspace_topology : set :=
  subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square.

(** helper: ordered square is a proper subset of RR **)
(** LATEX VERSION: II is a proper subset of . **)
Theorem ordered_square_neq_setprod_R_R : ordered_square <> setprod R R.
assume Heq: ordered_square = setprod R R.
prove False.
set p := (2,2).
claim HpRR: p :e setprod R R.
{ exact (tuple_2_setprod_by_pair_Sigma R R 2 2 two_in_R two_in_R). }
claim HpOS: p :e ordered_square.
{ rewrite Heq.
  exact HpRR. }
claim HpSing: p :e setprod {2} {2}.
{ exact (tuple_2_setprod_by_pair_Sigma {2} {2} 2 2 (SingI 2) (SingI 2)). }
claim Hcoords: 2 :e unit_interval /\ 2 :e unit_interval.
{ exact (setprod_coords_in 2 2 unit_interval unit_interval p HpSing HpOS). }
claim H2I: 2 :e unit_interval.
{ exact (andEL (2 :e unit_interval) (2 :e unit_interval) Hcoords). }
exact (two_not_in_unit_interval H2I).
Qed.

(** helper: ordered square as a standard subspace is the product topology **)
(** LATEX VERSION: The standard subspace topology on II agrees with the product topology on II. **)
Theorem ordered_square_standard_subspace_equals_product :
  subspace_topology (setprod R R) R2_standard_topology ordered_square =
  product_topology unit_interval unit_interval_topology unit_interval unit_interval_topology.
prove subspace_topology (setprod R R) R2_standard_topology ordered_square =
  product_topology unit_interval unit_interval_topology unit_interval unit_interval_topology.
claim Hsq: ordered_square = setprod unit_interval unit_interval.
{ reflexivity. }
claim Hut: unit_interval_topology = subspace_topology R R_standard_topology unit_interval.
{ reflexivity. }
rewrite Hsq.
rewrite Hut.
rewrite R2_standard_equals_product.
(** rewrite the product topology as a subspace of the product using `product_subspace_topology` **)
rewrite (product_subspace_topology
          R R_standard_topology
          R R_standard_topology
          unit_interval unit_interval
          R_standard_topology_is_topology R_standard_topology_is_topology
          unit_interval_sub_R unit_interval_sub_R).
reflexivity.
Qed.

Theorem ordered_square_not_subspace_dictionary :
  ordered_square_topology <> subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square.
prove ordered_square_topology <> subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square.
assume Heq: ordered_square_topology =
  subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square.
prove False.
set U := ordered_square_open_strip.

(** U is open in the dictionary order subspace topology **)
claim HUdic: U :e subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square.
{ claim HUsub: U c= ordered_square.
  { let p. assume Hp: p :e U.
    exact (SepE1 ordered_square
                 (fun p0:set => exists y:set, p0 = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y))
                 p Hp). }
  claim HUpow: U :e Power ordered_square.
  { exact (PowerI ordered_square U HUsub). }
  set a := (eps_ 1, eps_ 1).
  set b := (eps_ 1, 2).
  set V := {p :e setprod R R | order_rel (setprod R R) a p /\ order_rel (setprod R R) p b}.

  claim HVopen: V :e R2_dictionary_order_topology.
  { claim HdefR2: R2_dictionary_order_topology = order_topology (setprod R R).
    { reflexivity. }
    rewrite HdefR2.
    claim HdefOT: order_topology (setprod R R) =
      generated_topology (setprod R R) (order_topology_basis (setprod R R)).
    { reflexivity. }
    rewrite HdefOT.
    set X := setprod R R.
    set B := order_topology_basis X.
    claim HBasis: basis_on X B.
    { exact (order_topology_basis_is_basis X). }
    claim HVinB: V :e B.
    { set Bint := {I :e Power X | exists a0 :e X, exists b0 :e X,
                    I = {x :e X | order_rel X a0 x /\ order_rel X x b0}}.
      set Blow := {I :e Power X | exists b0 :e X, I = {x :e X | order_rel X x b0}}.
      set Bup := {I :e Power X | exists a0 :e X, I = {x :e X | order_rel X a0 x}}.
      claim HdefB: B = (Bint :\/: Blow :\/: Bup).
      { reflexivity. }
      rewrite HdefB.
      claim HVsubX: V c= X.
      { let p. assume Hp: p :e V.
        exact (SepE1 X (fun p0:set => order_rel X a p0 /\ order_rel X p0 b) p Hp). }
      claim HVpow: V :e Power X.
      { exact (PowerI X V HVsubX). }
      claim HaX: a :e X.
      { exact (tuple_2_setprod_by_pair_Sigma R R (eps_ 1) (eps_ 1) eps_1_in_R eps_1_in_R). }
      claim HbX: b :e X.
      { exact (tuple_2_setprod_by_pair_Sigma R R (eps_ 1) 2 eps_1_in_R two_in_R). }
      claim HVpred: exists a0 :e X, exists b0 :e X,
        V = {x :e X | order_rel X a0 x /\ order_rel X x b0}.
      { witness a.
        apply andI.
        - exact HaX.
        - witness b.
          apply andI.
          + exact HbX.
          + reflexivity. }
      claim HVinBint: V :e Bint.
      { exact (SepI (Power X)
                   (fun I0:set => exists a0 :e X, exists b0 :e X,
                        I0 = {x :e X | order_rel X a0 x /\ order_rel X x b0})
                   V HVpow HVpred). }
      claim HVinAB: V :e (Bint :\/: Blow).
      { exact (binunionI1 Bint Blow V HVinBint). }
      exact (binunionI1 (Bint :\/: Blow) Bup V HVinAB). }
    exact (basis_in_generated X B V HBasis HVinB). }

  claim HeqU: U = V :/\: ordered_square.
  { apply set_ext.
    - let p. assume HpU: p :e U.
      prove p :e V :/\: ordered_square.
      claim HpSq: p :e ordered_square.
      { exact (HUsub p HpU). }
      claim Hexy: exists y:set, p = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y).
      { exact (SepE2 ordered_square
                   (fun p0:set => exists y:set, p0 = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y))
                   p HpU). }
      apply Hexy.
      let y. assume Hyprop.
      claim Hpair: (p = (eps_ 1,y) /\ Rlt (eps_ 1) y).
      { exact (andEL (p = (eps_ 1,y) /\ Rlt (eps_ 1) y) (~(Rlt 1 y)) Hyprop). }
      claim Hpy: p = (eps_ 1,y).
      { exact (andEL (p = (eps_ 1,y)) (Rlt (eps_ 1) y) Hpair). }
      claim Hey: Rlt (eps_ 1) y.
      { exact (andER (p = (eps_ 1,y)) (Rlt (eps_ 1) y) Hpair). }
      claim Hnlt1y: ~(Rlt 1 y).
      { exact (andER (p = (eps_ 1,y) /\ Rlt (eps_ 1) y) (~(Rlt 1 y)) Hyprop). }
      claim HyR: y :e R.
      { exact (RltE_right (eps_ 1) y Hey). }
      claim Hylt2: Rlt y 2.
      { (** y <= 1 and 1 < 2 gives y < 2 **)
        claim HyS: SNo y.
        { exact (real_SNo y HyR). }
        claim H1S: SNo 1.
        { exact (real_SNo 1 real_1). }
        claim H2S: SNo 2.
        { exact (real_SNo 2 two_in_R). }
        claim HnltS: ~(1 < y).
        { assume Hlt: 1 < y.
          claim H1y: Rlt 1 y.
          { exact (RltI 1 y real_1 HyR Hlt). }
          exact (Hnlt1y H1y). }
        apply (SNoLt_trichotomy_or_impred y 1 HyS H1S (Rlt y 2)).
        - assume Hylt1S: y < 1.
          claim Hylt2S: y < 2.
          { exact (SNoLt_tra y 1 2 HyS H1S H2S Hylt1S SNoLt_1_2). }
          exact (RltI y 2 HyR two_in_R Hylt2S).
        - assume Hyeq: y = 1.
          rewrite Hyeq.
          exact (RltI 1 2 real_1 two_in_R SNoLt_1_2).
        - assume H1ltyS: 1 < y.
          apply FalseE.
          exact (HnltS H1ltyS). }
      claim HpV: p :e V.
      { rewrite Hpy.
        claim HpRR: (eps_ 1,y) :e setprod R R.
        { exact (tuple_2_setprod_by_pair_Sigma R R (eps_ 1) y eps_1_in_R HyR). }
        claim Hord1: order_rel (setprod R R) a (eps_ 1,y).
        { apply (order_rel_setprod_R_R_intro (eps_ 1) (eps_ 1) (eps_ 1) y).
          apply orIR.
          apply andI.
          - reflexivity.
          - exact Hey. }
        claim Hord2: order_rel (setprod R R) (eps_ 1,y) b.
        { apply (order_rel_setprod_R_R_intro (eps_ 1) y (eps_ 1) 2).
          apply orIR.
          apply andI.
          - reflexivity.
          - exact Hylt2. }
        claim Hpconj: order_rel (setprod R R) a (eps_ 1,y) /\ order_rel (setprod R R) (eps_ 1,y) b.
        { exact (andI (order_rel (setprod R R) a (eps_ 1,y))
                      (order_rel (setprod R R) (eps_ 1,y) b)
                      Hord1 Hord2). }
        exact (SepI (setprod R R)
                    (fun p0:set => order_rel (setprod R R) a p0 /\ order_rel (setprod R R) p0 b)
                    (eps_ 1,y) HpRR Hpconj). }
      apply binintersectI.
      - exact HpV.
      - exact HpSq.
	    - let p. assume HpCap: p :e V :/\: ordered_square.
	      prove p :e U.
	      claim HpV: p :e V.
	      { exact (binintersectE1 V ordered_square p HpCap). }
	      claim HpSq: p :e ordered_square.
	      { exact (binintersectE2 V ordered_square p HpCap). }
	      claim HpRR: p :e setprod R R.
	      { exact (SepE1 (setprod R R)
	                   (fun p0:set => order_rel (setprod R R) a p0 /\ order_rel (setprod R R) p0 b)
	                   p
	                   HpV). }
	      claim HpEta: p = (p 0, p 1).
	      { exact (setprod_eta R R p HpRR). }
	      claim Hpord: order_rel (setprod R R) a p /\ order_rel (setprod R R) p b.
	      { exact (SepE2 (setprod R R)
	                     (fun p0:set => order_rel (setprod R R) a p0 /\ order_rel (setprod R R) p0 b)
	                     p
	                     HpV). }
	      claim Hord1: order_rel (setprod R R) a p.
	      { exact (andEL (order_rel (setprod R R) a p)
	                     (order_rel (setprod R R) p b)
	                     Hpord). }
	      claim Hord2: order_rel (setprod R R) p b.
	      { exact (andER (order_rel (setprod R R) a p)
	                     (order_rel (setprod R R) p b)
	                     Hpord). }
	      claim Hex_ap: exists a1 a2 b1 b2:set,
	        a = (a1, a2) /\ p = (b1, b2) /\ (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)).
	      { exact (order_rel_setprod_R_R_unfold a p Hord1). }
	      claim Hex_pb: exists a1 a2 b1 b2:set,
	        p = (a1, a2) /\ b = (b1, b2) /\ (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)).
	      { exact (order_rel_setprod_R_R_unfold p b Hord2). }
	      claim Hdisj1p: Rlt (eps_ 1) (p 0) \/ ((eps_ 1) = (p 0) /\ Rlt (eps_ 1) (p 1)).
	      { apply Hex_ap.
	        let a1. assume Hex_a2.
	        apply Hex_a2.
	        let a2. assume Hex_b1.
	        apply Hex_b1.
	        let b1. assume Hex_b2.
	        apply Hex_b2.
	        let b2. assume Hap.
	        claim Hcore1: a = (a1, a2) /\ p = (b1, b2).
	        { exact (andEL (a = (a1, a2) /\ p = (b1, b2))
	                      (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))
	                      Hap). }
	        claim HaEq: a = (a1, a2).
	        { exact (andEL (a = (a1, a2)) (p = (b1, b2)) Hcore1). }
	        claim HpEq: p = (b1, b2).
	        { exact (andER (a = (a1, a2)) (p = (b1, b2)) Hcore1). }
	        claim Hdisj1: Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2).
	        { exact (andER (a = (a1, a2) /\ p = (b1, b2))
	                      (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))
	                      Hap). }
	        claim HaDef: a = (eps_ 1, eps_ 1).
	        { reflexivity. }
	        claim Haa: (eps_ 1, eps_ 1) = (a1, a2).
	        { rewrite HaDef at 1.
	          exact HaEq. }
	        claim HaCoords: (eps_ 1) = a1 /\ (eps_ 1) = a2.
	        { exact (tuple_eq_coords (eps_ 1) (eps_ 1) a1 a2 Haa). }
	        claim Ha1eq: a1 = eps_ 1.
	        { symmetry.
	          exact (andEL ((eps_ 1) = a1) ((eps_ 1) = a2) HaCoords). }
	        claim Ha2eq: a2 = eps_ 1.
	        { symmetry.
	          exact (andER ((eps_ 1) = a1) ((eps_ 1) = a2) HaCoords). }
	        claim Hbb: (b1, b2) = (p 0, p 1).
	        { rewrite <- HpEq at 1.
	          exact HpEta. }
	        claim HbCoords: b1 = p 0 /\ b2 = p 1.
	        { exact (tuple_eq_coords b1 b2 (p 0) (p 1) Hbb). }
	        claim Hb1eq: b1 = p 0.
	        { exact (andEL (b1 = p 0) (b2 = p 1) HbCoords). }
	        claim Hb2eq: b2 = p 1.
	        { exact (andER (b1 = p 0) (b2 = p 1) HbCoords). }
	        apply (Hdisj1 (Rlt (eps_ 1) (p 0) \/ ((eps_ 1) = (p 0) /\ Rlt (eps_ 1) (p 1)))).
	        - assume Hlt: Rlt a1 b1.
	          apply orIL.
	          prove Rlt (eps_ 1) (p 0).
		          claim Htmp: Rlt (eps_ 1) b1.
		          { rewrite <- Ha1eq at 1.
		            exact Hlt. }
	          rewrite <- Hb1eq at 1.
	          exact Htmp.
	        - assume Hc: a1 = b1 /\ Rlt a2 b2.
	          claim Ha1b1: a1 = b1.
	          { exact (andEL (a1 = b1) (Rlt a2 b2) Hc). }
	          claim Ha2b2: Rlt a2 b2.
	          { exact (andER (a1 = b1) (Rlt a2 b2) Hc). }
	          claim Heq0: (eps_ 1) = (p 0).
	          { prove (eps_ 1) = (p 0).
	            claim Heq1: (eps_ 1) = b1.
	            { rewrite <- Ha1eq at 1.
	              exact Ha1b1. }
		            rewrite <- Hb1eq at 1.
	            exact Heq1. }
	          claim Hlt1: Rlt (eps_ 1) (p 1).
	          { prove Rlt (eps_ 1) (p 1).
		            claim Htmp2: Rlt (eps_ 1) b2.
		            { rewrite <- Ha2eq at 1.
		              exact Ha2b2. }
		            rewrite <- Hb2eq at 1.
	            exact Htmp2. }
	          apply orIR.
	          exact (andI ((eps_ 1) = (p 0)) (Rlt (eps_ 1) (p 1)) Heq0 Hlt1). }
	      claim Hdisj2p: Rlt (p 0) (eps_ 1) \/ ((p 0) = (eps_ 1) /\ Rlt (p 1) 2).
	      { apply Hex_pb.
	        let c1. assume Hex_c2.
	        apply Hex_c2.
	        let c2. assume Hex_d1.
	        apply Hex_d1.
	        let d1. assume Hex_d2.
	        apply Hex_d2.
	        let d2. assume Hpb.
	        claim Hcore2: p = (c1, c2) /\ b = (d1, d2).
	        { exact (andEL (p = (c1, c2) /\ b = (d1, d2))
	                      (Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2))
	                      Hpb). }
	        claim HpEq2: p = (c1, c2).
	        { exact (andEL (p = (c1, c2)) (b = (d1, d2)) Hcore2). }
	        claim HbEq: b = (d1, d2).
	        { exact (andER (p = (c1, c2)) (b = (d1, d2)) Hcore2). }
	        claim Hdisj2: Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2).
	        { exact (andER (p = (c1, c2) /\ b = (d1, d2))
	                      (Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2))
	                      Hpb). }
	        claim Hpc: (c1, c2) = (p 0, p 1).
	        { rewrite <- HpEq2 at 1.
	          exact HpEta. }
	        claim HpCoords: c1 = p 0 /\ c2 = p 1.
	        { exact (tuple_eq_coords c1 c2 (p 0) (p 1) Hpc). }
	        claim Hc1eq: c1 = p 0.
	        { exact (andEL (c1 = p 0) (c2 = p 1) HpCoords). }
	        claim Hc2eq: c2 = p 1.
	        { exact (andER (c1 = p 0) (c2 = p 1) HpCoords). }
	        claim HbDef: b = (eps_ 1, 2).
	        { reflexivity. }
	        claim Hbd: (eps_ 1, 2) = (d1, d2).
	        { rewrite HbDef at 1.
	          exact HbEq. }
	        claim HbCoords: (eps_ 1) = d1 /\ 2 = d2.
	        { exact (tuple_eq_coords (eps_ 1) 2 d1 d2 Hbd). }
	        claim Hd1eq: d1 = eps_ 1.
	        { symmetry.
	          exact (andEL ((eps_ 1) = d1) (2 = d2) HbCoords). }
	        claim Hd2eq: d2 = 2.
	        { symmetry.
	          exact (andER ((eps_ 1) = d1) (2 = d2) HbCoords). }
	        apply (Hdisj2 (Rlt (p 0) (eps_ 1) \/ ((p 0) = (eps_ 1) /\ Rlt (p 1) 2))).
	        - assume Hlt: Rlt c1 d1.
	          apply orIL.
	          prove Rlt (p 0) (eps_ 1).
	          claim Htmp: Rlt (p 0) d1.
	          { rewrite <- Hc1eq at 1.
	            exact Hlt. }
		          rewrite <- Hd1eq at 1.
	          exact Htmp.
	        - assume Hc: c1 = d1 /\ Rlt c2 d2.
	          claim Hc1d1: c1 = d1.
	          { exact (andEL (c1 = d1) (Rlt c2 d2) Hc). }
	          claim Hc2d2: Rlt c2 d2.
	          { exact (andER (c1 = d1) (Rlt c2 d2) Hc). }
	          claim Heq0: (p 0) = (eps_ 1).
	          { prove (p 0) = (eps_ 1).
		            claim Heq1: (p 0) = d1.
		            { rewrite <- Hc1eq at 1.
		              exact Hc1d1. }
		            rewrite <- Hd1eq at 1.
	            exact Heq1. }
	          claim Hlt1: Rlt (p 1) 2.
	          { prove Rlt (p 1) 2.
	            claim Htmp2: Rlt (p 1) d2.
	            { rewrite <- Hc2eq at 1.
	              exact Hc2d2. }
		            rewrite <- Hd2eq at 1.
	            exact Htmp2. }
	          apply orIR.
	          exact (andI ((p 0) = (eps_ 1)) (Rlt (p 1) 2) Heq0 Hlt1). }
	      claim Hp0eq: (p 0) = (eps_ 1).
	      { apply (Hdisj2p ((p 0) = (eps_ 1))).
	        - assume Hp0lt: Rlt (p 0) (eps_ 1).
	          apply FalseE.
	          apply (Hdisj1p False).
	          + assume Hepslt: Rlt (eps_ 1) (p 0).
	            exact ((not_Rlt_sym (eps_ 1) (p 0) Hepslt) Hp0lt).
	          + assume Hc: (eps_ 1) = (p 0) /\ Rlt (eps_ 1) (p 1).
	            claim Heq: (p 0) = (eps_ 1).
	            { symmetry.
	              exact (andEL ((eps_ 1) = (p 0)) (Rlt (eps_ 1) (p 1)) Hc). }
		            claim Hbad: Rlt (eps_ 1) (eps_ 1).
		            { rewrite <- Heq at 1.
		              exact Hp0lt. }
	            exact ((not_Rlt_refl (eps_ 1) eps_1_in_R) Hbad).
	        - assume Hc: (p 0) = (eps_ 1) /\ Rlt (p 1) 2.
	          exact (andEL ((p 0) = (eps_ 1)) (Rlt (p 1) 2) Hc). }
	      claim Hey: Rlt (eps_ 1) (p 1).
	      { apply (Hdisj1p (Rlt (eps_ 1) (p 1))).
	        - assume Hepslt: Rlt (eps_ 1) (p 0).
	          apply FalseE.
		          claim Hbad: Rlt (eps_ 1) (eps_ 1).
		          { rewrite <- Hp0eq at 2.
		            exact Hepslt. }
	          exact ((not_Rlt_refl (eps_ 1) eps_1_in_R) Hbad).
	        - assume Hc: (eps_ 1) = (p 0) /\ Rlt (eps_ 1) (p 1).
	          exact (andER ((eps_ 1) = (p 0)) (Rlt (eps_ 1) (p 1)) Hc). }
	      claim HyU: (p 1) :e unit_interval.
	      { exact (ap1_Sigma unit_interval (fun _ : set => unit_interval) p HpSq). }
	      claim Hnlt1y: ~(Rlt 1 (p 1)).
	      { exact (andER (~(Rlt (p 1) 0)) (~(Rlt 1 (p 1)))
	                    (SepE2 R (fun t:set => ~(Rlt t 0) /\ ~(Rlt 1 t)) (p 1) HyU)). }
	      apply (SepI ordered_square
	                  (fun p0:set => exists y:set, p0 = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y))
	                  p
	                  HpSq).
	      witness (p 1).
	      prove p = (eps_ 1, p 1) /\ Rlt (eps_ 1) (p 1) /\ ~(Rlt 1 (p 1)).
	      apply andI.
	      - prove p = (eps_ 1, p 1) /\ Rlt (eps_ 1) (p 1).
	        apply andI.
		        + prove p = (eps_ 1, p 1).
		          rewrite HpEta at 1.
		          rewrite Hp0eq.
		          reflexivity.
	        + exact Hey.
	      - exact Hnlt1y. }

  claim Hex: exists W :e R2_dictionary_order_topology, U = W :/\: ordered_square.
  { witness V.
    apply andI.
    - exact HVopen.
    - exact HeqU. }
  exact (SepI (Power ordered_square)
              (fun U0:set => exists W :e R2_dictionary_order_topology, U0 = W :/\: ordered_square)
              U HUpow Hex). }

claim HUord: U :e ordered_square_topology.
{ rewrite Heq.
  exact HUdic. }

claim HUnord: ~(U :e ordered_square_topology).
{ assume HU: U :e ordered_square_topology.
  prove False.
  claim HUgt: U :e generated_topology ordered_square ordered_square_order_basis.
  { claim HdefT: ordered_square_topology = generated_topology ordered_square ordered_square_order_basis.
    { reflexivity. }
    rewrite <- HdefT.
    exact HU. }
  claim HUpoint: forall x :e U, exists I :e ordered_square_order_basis, x :e I /\ I c= U.
  { exact (SepE2 (Power ordered_square)
                 (fun U0:set => forall x :e U0, exists b0 :e ordered_square_order_basis, x :e b0 /\ b0 c= U0)
                 U
                 HUgt). }
  set p0 := (eps_ 1, 1).
  claim Hp0Sq: p0 :e ordered_square.
  { exact (tuple_2_setprod_by_pair_Sigma unit_interval unit_interval (eps_ 1) 1 eps_1_in_unit_interval one_in_unit_interval). }
  claim Hp0U: p0 :e U.
  { apply (SepI ordered_square
                (fun p:set => exists y:set, p = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y))
                p0
                Hp0Sq).
    witness 1.
    prove p0 = (eps_ 1,1) /\ Rlt (eps_ 1) 1 /\ ~(Rlt 1 1).
    apply andI.
    - prove p0 = (eps_ 1,1) /\ Rlt (eps_ 1) 1.
      apply andI.
      + reflexivity.
      + exact eps_1_lt1_R.
    - exact (not_Rlt_refl 1 real_1). }
  claim HexI: exists I :e ordered_square_order_basis, p0 :e I /\ I c= U.
  { exact (HUpoint p0 Hp0U). }
  apply HexI.
  let I. assume HIprop.
  apply HIprop.
  assume HIbas HIcore.
  apply HIcore.
  assume Hp0I HIU.
  set Bint := {J :e Power ordered_square | exists a :e ordered_square, exists b :e ordered_square,
        J = {x :e ordered_square | order_rel (setprod R R) a x /\ order_rel (setprod R R) x b}}.
  set Blow := {J :e Power ordered_square | exists b :e ordered_square,
        J = {x :e ordered_square | order_rel (setprod R R) x b}}.
  set Bup := {J :e Power ordered_square | exists a :e ordered_square,
        J = {x :e ordered_square | order_rel (setprod R R) a x}}.
  claim HIcase: I :e ((Bint :\/: Blow) :\/: Bup).
  { claim Hdef: ordered_square_order_basis = ((Bint :\/: Blow) :\/: Bup).
    { reflexivity. }
    rewrite <- Hdef.
    exact HIbas. }
  apply (binunionE (Bint :\/: Blow) Bup I HIcase).
  - assume HIleft: I :e (Bint :\/: Blow).
    apply (binunionE Bint Blow I HIleft).
    + assume HIint: I :e Bint.
      claim HIint_ex: exists a :e ordered_square, exists b :e ordered_square,
        I = {x :e ordered_square | order_rel (setprod R R) a x /\ order_rel (setprod R R) x b}.
      { exact (SepE2 (Power ordered_square)
                     (fun J0:set => exists a :e ordered_square, exists b :e ordered_square,
                       J0 = {x :e ordered_square | order_rel (setprod R R) a x /\ order_rel (setprod R R) x b})
                     I
                     HIint). }
      apply HIint_ex.
      let a. assume Ha_prop.
      apply Ha_prop.
      assume HaSq Hexb.
      apply Hexb.
      let b. assume Hb_prop.
      apply Hb_prop.
      assume HbSq HeqI.
      claim Hp0I': p0 :e {x :e ordered_square | order_rel (setprod R R) a x /\ order_rel (setprod R R) x b}.
      { rewrite <- HeqI.
        exact Hp0I. }
      claim Hp0ord: order_rel (setprod R R) a p0 /\ order_rel (setprod R R) p0 b.
      { exact (SepE2 ordered_square
                     (fun x:set => order_rel (setprod R R) a x /\ order_rel (setprod R R) x b)
                     p0
                     Hp0I'). }
      claim Hord2: order_rel (setprod R R) p0 b.
      { exact (andER (order_rel (setprod R R) a p0)
                     (order_rel (setprod R R) p0 b)
                     Hp0ord). }
      claim HbEta: b = (b 0, b 1).
      { exact (setprod_eta unit_interval unit_interval b HbSq). }
      claim Hb0U: (b 0) :e unit_interval.
      { exact (ap0_Sigma unit_interval (fun _ : set => unit_interval) b HbSq). }
      claim Hb1U: (b 1) :e unit_interval.
      { exact (ap1_Sigma unit_interval (fun _ : set => unit_interval) b HbSq). }
      claim Hb0R: (b 0) :e R.
      { exact (SepE1 R (fun t:set => ~(Rlt t 0) /\ ~(Rlt 1 t)) (b 0) Hb0U). }
      claim Hb0prop: ~(Rlt 1 (b 0)).
      { exact (andER (~(Rlt (b 0) 0)) (~(Rlt 1 (b 0)))
                    (SepE2 R (fun t:set => ~(Rlt t 0) /\ ~(Rlt 1 t)) (b 0) Hb0U)). }
      claim Hb1prop: ~(Rlt 1 (b 1)).
      { exact (andER (~(Rlt (b 1) 0)) (~(Rlt 1 (b 1)))
                    (SepE2 R (fun t:set => ~(Rlt t 0) /\ ~(Rlt 1 t)) (b 1) Hb1U)). }
      claim Hepsltb0: Rlt (eps_ 1) (b 0).
      { claim Hex_pb: exists c1 c2 d1 d2:set,
          p0 = (c1, c2) /\ b = (d1, d2) /\ (Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2)).
        { exact (order_rel_setprod_R_R_unfold p0 b Hord2). }
        apply Hex_pb.
        let c1. assume Hc2.
        apply Hc2.
        let c2. assume Hd1.
        apply Hd1.
        let d1. assume Hd2.
        apply Hd2.
        let d2. assume Hcore.
        claim Hpb: p0 = (c1, c2) /\ b = (d1, d2).
        { exact (andEL (p0 = (c1, c2) /\ b = (d1, d2))
                      (Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2))
                      Hcore). }
        claim Hp0Eq: p0 = (c1, c2).
        { exact (andEL (p0 = (c1, c2)) (b = (d1, d2)) Hpb). }
        claim HbEq: b = (d1, d2).
        { exact (andER (p0 = (c1, c2)) (b = (d1, d2)) Hpb). }
        claim Hdisj: Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2).
        { exact (andER (p0 = (c1, c2) /\ b = (d1, d2))
                      (Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2))
                      Hcore). }
        claim Hp0def: p0 = (eps_ 1, 1).
        { reflexivity. }
        claim Hp0c: (eps_ 1, 1) = (c1, c2).
        { rewrite Hp0def at 1.
          exact Hp0Eq. }
        claim Hp0coords: (eps_ 1) = c1 /\ 1 = c2.
        { exact (tuple_eq_coords (eps_ 1) 1 c1 c2 Hp0c). }
        claim Hc1eq: c1 = eps_ 1.
        { symmetry.
          exact (andEL ((eps_ 1) = c1) (1 = c2) Hp0coords). }
        claim HbD: (d1, d2) = (b 0, b 1).
        { rewrite <- HbEq at 1.
          exact HbEta. }
        claim Hbcoords: d1 = b 0 /\ d2 = b 1.
        { exact (tuple_eq_coords d1 d2 (b 0) (b 1) HbD). }
        claim Hd1eq: d1 = b 0.
        { exact (andEL (d1 = b 0) (d2 = b 1) Hbcoords). }
        apply (Hdisj (Rlt (eps_ 1) (b 0))).
        - assume Hlt: Rlt c1 d1.
          rewrite <- Hc1eq at 1.
	          rewrite <- Hd1eq at 1.
          exact Hlt.
        - assume Hc: c1 = d1 /\ Rlt c2 d2.
          apply FalseE.
          claim H1lt: Rlt 1 (b 1).
          { claim Heqcd: c1 = d1.
            { exact (andEL (c1 = d1) (Rlt c2 d2) Hc). }
            claim Hlt2: Rlt c2 d2.
            { exact (andER (c1 = d1) (Rlt c2 d2) Hc). }
            claim Hc2eq: c2 = 1.
            { symmetry.
              exact (andER ((eps_ 1) = c1) (1 = c2) Hp0coords). }
            claim Hd2eq: d2 = b 1.
            { exact (andER (d1 = b 0) (d2 = b 1) Hbcoords). }
            claim H1lt_d2: Rlt 1 d2.
            { rewrite <- Hc2eq at 1.
              exact Hlt2. }
            rewrite <- Hd2eq at 1.
            exact H1lt_d2. }
          exact (Hb1prop H1lt). }
      apply (rational_dense_between_reals (eps_ 1) (b 0) eps_1_in_R Hb0R Hepsltb0).
      let q. assume Hq_prop.
      apply Hq_prop.
      assume HqQ HqIneq.
      claim HqR: q :e R.
      { exact (rational_numbers_in_R q HqQ). }
      claim Hepsltq: Rlt (eps_ 1) q.
      { exact (andEL (Rlt (eps_ 1) q) (Rlt q (b 0)) HqIneq). }
      claim Hqltb0: Rlt q (b 0).
      { exact (andER (Rlt (eps_ 1) q) (Rlt q (b 0)) HqIneq). }
      claim HqU: q :e unit_interval.
      { apply (SepI R (fun t:set => ~(Rlt t 0) /\ ~(Rlt 1 t)) q HqR).
        apply andI.
        - prove ~(Rlt q 0).
          assume Hq0: Rlt q 0.
          claim H0q: Rlt 0 q.
          { exact (Rlt_tra 0 (eps_ 1) q eps_1_pos_R Hepsltq). }
          exact ((not_Rlt_sym 0 q H0q) Hq0).
        - prove ~(Rlt 1 q).
          assume H1q: Rlt 1 q.
          claim H1b0: Rlt 1 (b 0).
          { exact (Rlt_tra 1 q (b 0) H1q Hqltb0). }
          exact (Hb0prop H1b0). }
      set z := (q,0).
      claim HzSq: z :e ordered_square.
      { exact (tuple_2_setprod unit_interval unit_interval q HqU 0 zero_in_unit_interval). }
      claim HaEta: a = (a 0, a 1).
      { exact (setprod_eta unit_interval unit_interval a HaSq). }
      claim Ha0U: (a 0) :e unit_interval.
      { exact (ap0_Sigma unit_interval (fun _ : set => unit_interval) a HaSq). }
      claim Ha0R: (a 0) :e R.
      { exact (SepE1 R (fun t:set => ~(Rlt t 0) /\ ~(Rlt 1 t)) (a 0) Ha0U). }
      claim Hord1: order_rel (setprod R R) a p0.
      { exact (andEL (order_rel (setprod R R) a p0)
                     (order_rel (setprod R R) p0 b)
                     Hp0ord). }
      claim Hex_ap: exists c1 c2 d1 d2:set,
        a = (c1, c2) /\ p0 = (d1, d2) /\ (Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2)).
      { exact (order_rel_setprod_R_R_unfold a p0 Hord1). }
      claim Ha0ltq: Rlt (a 0) q.
      { apply Hex_ap.
        let c1. assume Hc2.
        apply Hc2.
        let c2. assume Hd1.
        apply Hd1.
        let d1. assume Hd2.
        apply Hd2.
        let d2. assume Hcore.
        claim Hap: a = (c1, c2) /\ p0 = (d1, d2).
        { exact (andEL (a = (c1, c2) /\ p0 = (d1, d2))
                      (Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2))
                      Hcore). }
        claim HaEq: a = (c1, c2).
        { exact (andEL (a = (c1, c2)) (p0 = (d1, d2)) Hap). }
        claim Hp0Eq: p0 = (d1, d2).
        { exact (andER (a = (c1, c2)) (p0 = (d1, d2)) Hap). }
        claim Hdisj: Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2).
        { exact (andER (a = (c1, c2) /\ p0 = (d1, d2))
                      (Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2))
                      Hcore). }
        claim HaC: (c1, c2) = (a 0, a 1).
        { rewrite <- HaEq at 1.
          exact HaEta. }
        claim HaCcoords: c1 = a 0 /\ c2 = a 1.
        { exact (tuple_eq_coords c1 c2 (a 0) (a 1) HaC). }
        claim Hc1eq: c1 = a 0.
        { exact (andEL (c1 = a 0) (c2 = a 1) HaCcoords). }
        claim Hp0def: p0 = (eps_ 1, 1).
        { reflexivity. }
        claim Hp0D: (eps_ 1, 1) = (d1, d2).
        { rewrite Hp0def at 1.
          exact Hp0Eq. }
        claim Hp0Dcoords: (eps_ 1) = d1 /\ 1 = d2.
        { exact (tuple_eq_coords (eps_ 1) 1 d1 d2 Hp0D). }
        claim Hd1eq: d1 = eps_ 1.
        { symmetry.
          exact (andEL ((eps_ 1) = d1) (1 = d2) Hp0Dcoords). }
        apply (Hdisj (Rlt (a 0) q)).
        - assume Hlt: Rlt c1 d1.
          claim Hlt1: Rlt (a 0) (eps_ 1).
          { rewrite <- Hc1eq at 1.
		            rewrite <- Hd1eq at 1.
            exact Hlt. }
          exact (Rlt_tra (a 0) (eps_ 1) q Hlt1 Hepsltq).
        - assume Hc: c1 = d1 /\ Rlt c2 d2.
          claim Heq: c1 = d1.
          { exact (andEL (c1 = d1) (Rlt c2 d2) Hc). }
          claim Ha0eq: (a 0) = (eps_ 1).
          { prove (a 0) = (eps_ 1).
            rewrite <- Hc1eq at 1.
		            rewrite <- Hd1eq at 1.
            exact Heq. }
          rewrite Ha0eq at 1.
          exact Hepsltq. }
      claim HzInI: z :e I.
      { rewrite HeqI.
        apply (SepI ordered_square
                    (fun x:set => order_rel (setprod R R) a x /\ order_rel (setprod R R) x b)
                    z
                    HzSq).
        apply andI.
        - prove order_rel (setprod R R) a z.
          rewrite HaEta.
          apply (order_rel_setprod_R_R_intro (a 0) (a 1) q 0).
          apply orIL.
          exact Ha0ltq.
        - prove order_rel (setprod R R) z b.
          rewrite HbEta.
          apply (order_rel_setprod_R_R_intro q 0 (b 0) (b 1)).
          apply orIL.
          exact Hqltb0. }
      claim HzU: z :e U.
      { exact (HIU z HzInI). }
      claim HzNotU: ~(z :e U).
      { assume HzU'.
        claim Hexy: exists y:set, z = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y).
        { exact (SepE2 ordered_square
                     (fun p:set => exists y:set, p = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y))
                     z
                     HzU'). }
        apply Hexy.
        let y. assume Hyprop.
        claim Hpair: z = (eps_ 1,y) /\ Rlt (eps_ 1) y.
        { exact (andEL (z = (eps_ 1,y) /\ Rlt (eps_ 1) y) (~(Rlt 1 y)) Hyprop). }
        claim HzEq: z = (eps_ 1,y).
        { exact (andEL (z = (eps_ 1,y)) (Rlt (eps_ 1) y) Hpair). }
        claim Hcoords: q = eps_ 1 /\ 0 = y.
        { exact (tuple_eq_coords q 0 (eps_ 1) y HzEq). }
        claim Hqeq: q = eps_ 1.
        { exact (andEL (q = eps_ 1) (0 = y) Hcoords). }
        claim Hbad: Rlt (eps_ 1) (eps_ 1).
        { rewrite <- Hqeq at 2.
          exact Hepsltq. }
        exact ((not_Rlt_refl (eps_ 1) eps_1_in_R) Hbad). }
      exact (HzNotU HzU).
    + assume HIlow: I :e Blow.
      claim HIlow_ex: exists b :e ordered_square,
        I = {x :e ordered_square | order_rel (setprod R R) x b}.
      { exact (SepE2 (Power ordered_square)
                     (fun J0:set => exists b0 :e ordered_square,
                       J0 = {x :e ordered_square | order_rel (setprod R R) x b0})
                     I
                     HIlow). }
      apply HIlow_ex.
      let b. assume Hbprop.
      apply Hbprop.
      assume HbSq HeqI.
      claim Hp0I': p0 :e {x :e ordered_square | order_rel (setprod R R) x b}.
      { rewrite <- HeqI.
        exact Hp0I. }
      claim Hord2: order_rel (setprod R R) p0 b.
      { exact (SepE2 ordered_square (fun x:set => order_rel (setprod R R) x b) p0 Hp0I'). }
      claim HbEta: b = (b 0, b 1).
      { exact (setprod_eta unit_interval unit_interval b HbSq). }
      claim Hb0U: (b 0) :e unit_interval.
      { exact (ap0_Sigma unit_interval (fun _ : set => unit_interval) b HbSq). }
      claim Hb1U: (b 1) :e unit_interval.
      { exact (ap1_Sigma unit_interval (fun _ : set => unit_interval) b HbSq). }
      claim Hb0R: (b 0) :e R.
      { exact (SepE1 R (fun t:set => ~(Rlt t 0) /\ ~(Rlt 1 t)) (b 0) Hb0U). }
      claim Hb0prop: ~(Rlt 1 (b 0)).
      { exact (andER (~(Rlt (b 0) 0)) (~(Rlt 1 (b 0)))
                    (SepE2 R (fun t:set => ~(Rlt t 0) /\ ~(Rlt 1 t)) (b 0) Hb0U)). }
      claim Hb1prop: ~(Rlt 1 (b 1)).
      { exact (andER (~(Rlt (b 1) 0)) (~(Rlt 1 (b 1)))
                    (SepE2 R (fun t:set => ~(Rlt t 0) /\ ~(Rlt 1 t)) (b 1) Hb1U)). }
      claim Hepsltb0: Rlt (eps_ 1) (b 0).
      { claim Hex_pb: exists c1 c2 d1 d2:set,
          p0 = (c1, c2) /\ b = (d1, d2) /\ (Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2)).
        { exact (order_rel_setprod_R_R_unfold p0 b Hord2). }
        apply Hex_pb.
        let c1. assume Hc2.
        apply Hc2.
        let c2. assume Hd1.
        apply Hd1.
        let d1. assume Hd2.
        apply Hd2.
        let d2. assume Hcore.
        claim Hpb: p0 = (c1, c2) /\ b = (d1, d2).
        { exact (andEL (p0 = (c1, c2) /\ b = (d1, d2))
                      (Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2))
                      Hcore). }
        claim Hp0Eq: p0 = (c1, c2).
        { exact (andEL (p0 = (c1, c2)) (b = (d1, d2)) Hpb). }
        claim HbEq: b = (d1, d2).
        { exact (andER (p0 = (c1, c2)) (b = (d1, d2)) Hpb). }
        claim Hdisj: Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2).
        { exact (andER (p0 = (c1, c2) /\ b = (d1, d2))
                      (Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2))
                      Hcore). }
        claim Hp0def: p0 = (eps_ 1, 1).
        { reflexivity. }
        claim Hp0c: (eps_ 1, 1) = (c1, c2).
        { rewrite Hp0def at 1.
          exact Hp0Eq. }
        claim Hp0coords: (eps_ 1) = c1 /\ 1 = c2.
        { exact (tuple_eq_coords (eps_ 1) 1 c1 c2 Hp0c). }
        claim Hc1eq: c1 = eps_ 1.
        { symmetry.
          exact (andEL ((eps_ 1) = c1) (1 = c2) Hp0coords). }
        claim HbD: (d1, d2) = (b 0, b 1).
        { rewrite <- HbEq at 1.
          exact HbEta. }
        claim Hbcoords: d1 = b 0 /\ d2 = b 1.
        { exact (tuple_eq_coords d1 d2 (b 0) (b 1) HbD). }
        claim Hd1eq: d1 = b 0.
        { exact (andEL (d1 = b 0) (d2 = b 1) Hbcoords). }
        apply (Hdisj (Rlt (eps_ 1) (b 0))).
        - assume Hlt: Rlt c1 d1.
          rewrite <- Hc1eq at 1.
	          rewrite <- Hd1eq at 1.
          exact Hlt.
        - assume Hc: c1 = d1 /\ Rlt c2 d2.
          apply FalseE.
	          claim H1lt: Rlt 1 (b 1).
	          { claim Hlt2: Rlt c2 d2.
	            { exact (andER (c1 = d1) (Rlt c2 d2) Hc). }
	            claim Hc2eq: c2 = 1.
	            { symmetry.
	              exact (andER ((eps_ 1) = c1) (1 = c2) Hp0coords). }
	            claim Hd2eq: d2 = b 1.
	            { exact (andER (d1 = b 0) (d2 = b 1) Hbcoords). }
	            claim H1lt_d2: Rlt 1 d2.
	            { rewrite <- Hc2eq at 1.
	              exact Hlt2. }
	            rewrite <- Hd2eq at 1.
	            exact H1lt_d2. }
	          exact (Hb1prop H1lt). }
      apply (rational_dense_between_reals (eps_ 1) (b 0) eps_1_in_R Hb0R Hepsltb0).
      let q. assume Hq_prop.
      apply Hq_prop.
      assume HqQ HqIneq.
      claim HqR: q :e R.
      { exact (rational_numbers_in_R q HqQ). }
      claim Hepsltq: Rlt (eps_ 1) q.
      { exact (andEL (Rlt (eps_ 1) q) (Rlt q (b 0)) HqIneq). }
      claim Hqltb0: Rlt q (b 0).
      { exact (andER (Rlt (eps_ 1) q) (Rlt q (b 0)) HqIneq). }
      claim HqU: q :e unit_interval.
      { apply (SepI R (fun t:set => ~(Rlt t 0) /\ ~(Rlt 1 t)) q HqR).
        apply andI.
        - prove ~(Rlt q 0).
          assume Hq0: Rlt q 0.
          claim H0q: Rlt 0 q.
          { exact (Rlt_tra 0 (eps_ 1) q eps_1_pos_R Hepsltq). }
          exact ((not_Rlt_sym 0 q H0q) Hq0).
        - prove ~(Rlt 1 q).
          assume H1q: Rlt 1 q.
          claim H1b0: Rlt 1 (b 0).
          { exact (Rlt_tra 1 q (b 0) H1q Hqltb0). }
          exact (Hb0prop H1b0). }
      set z := (q,0).
      claim HzSq: z :e ordered_square.
      { exact (tuple_2_setprod unit_interval unit_interval q HqU 0 zero_in_unit_interval). }
      claim HzInI: z :e I.
      { rewrite HeqI.
        apply (SepI ordered_square (fun x:set => order_rel (setprod R R) x b) z HzSq).
        rewrite HbEta.
        apply (order_rel_setprod_R_R_intro q 0 (b 0) (b 1)).
        apply orIL.
        exact Hqltb0. }
      claim HzU: z :e U.
      { exact (HIU z HzInI). }
      claim HzNotU: ~(z :e U).
      { assume HzU'.
        claim Hexy: exists y:set, z = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y).
        { exact (SepE2 ordered_square
                     (fun p:set => exists y:set, p = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y))
                     z
                     HzU'). }
        apply Hexy.
        let y. assume Hyprop.
        claim Hpair: z = (eps_ 1,y) /\ Rlt (eps_ 1) y.
        { exact (andEL (z = (eps_ 1,y) /\ Rlt (eps_ 1) y) (~(Rlt 1 y)) Hyprop). }
        claim HzEq: z = (eps_ 1,y).
        { exact (andEL (z = (eps_ 1,y)) (Rlt (eps_ 1) y) Hpair). }
        claim Hcoords: q = eps_ 1 /\ 0 = y.
        { exact (tuple_eq_coords q 0 (eps_ 1) y HzEq). }
        claim Hqeq: q = eps_ 1.
        { exact (andEL (q = eps_ 1) (0 = y) Hcoords). }
        claim Hbad: Rlt (eps_ 1) (eps_ 1).
        { rewrite <- Hqeq at 2.
          exact Hepsltq. }
        exact ((not_Rlt_refl (eps_ 1) eps_1_in_R) Hbad). }
      exact (HzNotU HzU).
  - assume HIup: I :e Bup.
    claim HIup_ex: exists a :e ordered_square,
      I = {x :e ordered_square | order_rel (setprod R R) a x}.
    { exact (SepE2 (Power ordered_square)
                   (fun J0:set => exists a0 :e ordered_square,
                     J0 = {x :e ordered_square | order_rel (setprod R R) a0 x})
                   I
                   HIup). }
    apply HIup_ex.
    let a. assume Haprop.
    apply Haprop.
    assume HaSq HeqI.
    claim Hp0I': p0 :e {x :e ordered_square | order_rel (setprod R R) a x}.
    { rewrite <- HeqI.
      exact Hp0I. }
    claim Hord1: order_rel (setprod R R) a p0.
    { exact (SepE2 ordered_square (fun x:set => order_rel (setprod R R) a x) p0 Hp0I'). }
    claim HaEta: a = (a 0, a 1).
    { exact (setprod_eta unit_interval unit_interval a HaSq). }
    claim Ha0U: (a 0) :e unit_interval.
    { exact (ap0_Sigma unit_interval (fun _ : set => unit_interval) a HaSq). }
    claim Ha0R: (a 0) :e R.
    { exact (SepE1 R (fun t:set => ~(Rlt t 0) /\ ~(Rlt 1 t)) (a 0) Ha0U). }
    claim Ha0lt1: Rlt (a 0) 1.
    { claim Hex_ap: exists c1 c2 d1 d2:set,
        a = (c1, c2) /\ p0 = (d1, d2) /\ (Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2)).
      { exact (order_rel_setprod_R_R_unfold a p0 Hord1). }
      apply Hex_ap.
      let c1. assume Hc2.
      apply Hc2.
      let c2. assume Hd1.
      apply Hd1.
      let d1. assume Hd2.
      apply Hd2.
      let d2. assume Hcore.
      claim Hap: a = (c1, c2) /\ p0 = (d1, d2).
      { exact (andEL (a = (c1, c2) /\ p0 = (d1, d2))
                    (Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2))
                    Hcore). }
      claim HaEq: a = (c1, c2).
      { exact (andEL (a = (c1, c2)) (p0 = (d1, d2)) Hap). }
      claim Hp0Eq: p0 = (d1, d2).
      { exact (andER (a = (c1, c2)) (p0 = (d1, d2)) Hap). }
      claim Hdisj: Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2).
      { exact (andER (a = (c1, c2) /\ p0 = (d1, d2))
                    (Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2))
                    Hcore). }
      claim HaC: (c1, c2) = (a 0, a 1).
      { rewrite <- HaEq at 1.
        exact HaEta. }
      claim HaCcoords: c1 = a 0 /\ c2 = a 1.
      { exact (tuple_eq_coords c1 c2 (a 0) (a 1) HaC). }
      claim Hc1eq: c1 = a 0.
      { exact (andEL (c1 = a 0) (c2 = a 1) HaCcoords). }
      claim Hp0def: p0 = (eps_ 1, 1).
      { reflexivity. }
      claim Hp0D: (eps_ 1, 1) = (d1, d2).
      { rewrite Hp0def at 1.
        exact Hp0Eq. }
      claim Hp0Dcoords: (eps_ 1) = d1 /\ 1 = d2.
      { exact (tuple_eq_coords (eps_ 1) 1 d1 d2 Hp0D). }
      claim Hd1eq: d1 = eps_ 1.
      { symmetry.
        exact (andEL ((eps_ 1) = d1) (1 = d2) Hp0Dcoords). }
      apply (Hdisj (Rlt (a 0) 1)).
      - assume Hlt: Rlt c1 d1.
        claim Ha0lteps: Rlt (a 0) (eps_ 1).
        { rewrite <- Hc1eq at 1.
	          rewrite <- Hd1eq at 1.
          exact Hlt. }
        exact (Rlt_tra (a 0) (eps_ 1) 1 Ha0lteps eps_1_lt1_R).
      - assume Hc: c1 = d1 /\ Rlt c2 d2.
        claim Heq: c1 = d1.
        { exact (andEL (c1 = d1) (Rlt c2 d2) Hc). }
        claim Ha0eq: (a 0) = (eps_ 1).
        { prove (a 0) = (eps_ 1).
          rewrite <- Hc1eq at 1.
	          rewrite <- Hd1eq at 1.
          exact Heq. }
        rewrite Ha0eq at 1.
        exact eps_1_lt1_R. }
    set z := (1,0).
    claim HzSq: z :e ordered_square.
    { exact (tuple_2_setprod unit_interval unit_interval 1 one_in_unit_interval 0 zero_in_unit_interval). }
    claim HzInI: z :e I.
    { rewrite HeqI.
      apply (SepI ordered_square (fun x:set => order_rel (setprod R R) a x) z HzSq).
      rewrite HaEta.
      apply (order_rel_setprod_R_R_intro (a 0) (a 1) 1 0).
      apply orIL.
      exact Ha0lt1. }
    claim HzU: z :e U.
    { exact (HIU z HzInI). }
    claim HzNotU: ~(z :e U).
    { assume HzU'.
      claim Hexy: exists y:set, z = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y).
      { exact (SepE2 ordered_square
                   (fun p:set => exists y:set, p = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y))
                   z
                   HzU'). }
      apply Hexy.
      let y. assume Hyprop.
      claim Hpair: z = (eps_ 1,y) /\ Rlt (eps_ 1) y.
      { exact (andEL (z = (eps_ 1,y) /\ Rlt (eps_ 1) y) (~(Rlt 1 y)) Hyprop). }
      claim HzEq: z = (eps_ 1,y).
      { exact (andEL (z = (eps_ 1,y)) (Rlt (eps_ 1) y) Hpair). }
      claim Hcoords: 1 = eps_ 1 /\ 0 = y.
      { exact (tuple_eq_coords 1 0 (eps_ 1) y HzEq). }
      claim H1eq: 1 = eps_ 1.
      { exact (andEL (1 = eps_ 1) (0 = y) Hcoords). }
      claim Hbad: Rlt (eps_ 1) (eps_ 1).
      { rewrite <- H1eq at 2.
        exact eps_1_lt1_R. }
      exact ((not_Rlt_refl (eps_ 1) eps_1_in_R) Hbad). }
    exact (HzNotU HzU). }

exact (HUnord HUord).
Qed.

(** from 16 Theorem 16.4: convex subspaces share the order topology **) 
(** LATEX VERSION: Theorem 16.4: A convex subset Y of an ordered set X inherits the order topology as a subspace topology. **)
(** Helper: order interval (a,b) in an ordered set **)
Definition order_interval : set -> set -> set -> set := fun X a b =>
  {x :e X | order_rel X a x /\ order_rel X x b}.

(** Helper: order intervals are subsets of the ambient set **)
Theorem order_interval_subset : forall X a b:set,
  order_interval X a b c= X.
let X a b.
let x.
assume Hx: x :e order_interval X a b.
exact (SepE1 X (fun x0:set => order_rel X a x0 /\ order_rel X x0 b) x Hx).
Qed.

(** Helper: eliminator for order_interval membership **)
Theorem order_intervalE : forall X a b x:set,
  x :e order_interval X a b ->
  x :e X /\ (order_rel X a x /\ order_rel X x b).
let X a b x.
assume Hx: x :e order_interval X a b.
apply andI.
- exact (SepE1 X (fun x0:set => order_rel X a x0 /\ order_rel X x0 b) x Hx).
- exact (SepE2 X (fun x0:set => order_rel X a x0 /\ order_rel X x0 b) x Hx).
Qed.

(** Helper: introduction rule for order_interval membership **)
Theorem order_intervalI : forall X a b x:set,
  x :e X ->
  order_rel X a x ->
  order_rel X x b ->
  x :e order_interval X a b.
let X a b x.
assume HxX: x :e X.
assume Hax: order_rel X a x.
assume Hxb: order_rel X x b.
exact (SepI X (fun x0:set => order_rel X a x0 /\ order_rel X x0 b)
            x HxX (andI (order_rel X a x) (order_rel X x b) Hax Hxb)).
Qed.

(** Helper: convex subset definition used in Theorem 16.4 **)
Definition convex_in : set -> set -> prop := fun X Y =>
  Y c= X /\
  forall a b:set, a :e Y -> b :e Y -> order_interval X a b c= Y.

(** Helper: extract Y c= X from convex_in **)
Theorem convex_in_subset : forall X Y:set,
  convex_in X Y -> Y c= X.
let X Y.
assume H: convex_in X Y.
exact (andEL (Y c= X)
             (forall a b:set, a :e Y -> b :e Y -> order_interval X a b c= Y)
             H).
Qed.

(** Helper: extract the interval closure property from convex_in **)
Theorem convex_in_interval_property : forall X Y:set,
  convex_in X Y ->
  forall a b:set, a :e Y -> b :e Y -> order_interval X a b c= Y.
let X Y.
assume H: convex_in X Y.
exact (andER (Y c= X)
             (forall a b:set, a :e Y -> b :e Y -> order_interval X a b c= Y)
             H).
Qed.

Theorem convex_subspace_order_topology : forall X Y:set,
  convex_in X Y ->
  order_topology Y = subspace_topology X (order_topology X) Y.
let X Y.
assume Hconv: convex_in X Y.
prove order_topology Y = subspace_topology X (order_topology X) Y.
apply set_ext.
- let U. assume HU: U :e order_topology Y.
  prove U :e subspace_topology X (order_topology X) Y.
(** SUSPICIOUS DEFINITION: This requires unfolding generated_topology and showing that order-topology basis elements in Y arise as intersections with corresponding basis elements in X, using convexity; the detailed proof is not yet written here. **)
  admit.
- let U. assume HU: U :e subspace_topology X (order_topology X) Y.
  prove U :e order_topology Y.
(** SUSPICIOUS DEFINITION: Converse direction also requires translating subspace basic opens back to order-topology basics in Y; currently admitted. **)
  admit.
Qed.

(** helper: intersection with a subset can drop the larger set **) 
Theorem binintersect_right_absorb_subset : forall W Y A:set,
  A c= Y -> (W :/\: Y) :/\: A = W :/\: A.
let W Y A.
assume Hsub: A c= Y.
apply set_ext.
- let x. assume Hx: x :e (W :/\: Y) :/\: A.
  claim Hpair : x :e W :/\: Y /\ x :e A.
  { exact (binintersectE (W :/\: Y) A x Hx). }
  claim HWY : x :e W :/\: Y.
  { exact (andEL (x :e W :/\: Y) (x :e A) Hpair). }
  claim HA : x :e A.
  { exact (andER (x :e W :/\: Y) (x :e A) Hpair). }
  claim HWYpair : x :e W /\ x :e Y.
  { exact (binintersectE W Y x HWY). }
  claim HW : x :e W.
  { exact (andEL (x :e W) (x :e Y) HWYpair). }
  apply binintersectI.
  * exact HW.
  * exact HA.
- let x. assume Hx: x :e W :/\: A.
  claim Hpair : x :e W /\ x :e A.
  { exact (binintersectE W A x Hx). }
  claim HW : x :e W.
  { exact (andEL (x :e W) (x :e A) Hpair). }
  claim HA : x :e A.
  { exact (andER (x :e W) (x :e A) Hpair). }
  claim HY : x :e Y.
  { exact (Hsub x HA). }
  claim HWY : x :e W :/\: Y.
  { exact (binintersectI W Y x HW HY). }
  apply binintersectI.
  * exact HWY.
  * exact HA.
Qed.

(** from 16 Exercise 1: subspace of subspace inherits same topology **)
(** LATEX VERSION: Exercise 1: Subspace of a subspace has the same topology as taking the subspace directly. **)
Theorem ex16_1_subspace_transitive : forall X Tx Y A:set,
  topology_on X Tx -> Y c= X -> A c= Y ->
  subspace_topology Y (subspace_topology X Tx Y) A =
  subspace_topology X Tx A.
let X Tx Y A.
assume Htop: topology_on X Tx.
assume HY: Y c= X.
assume HA: A c= Y.
prove subspace_topology Y (subspace_topology X Tx Y) A = subspace_topology X Tx A.
(** Strategy: Prove both sides equal {W  Power A | VTx, W = VA} using binintersect_right_absorb_subset: (VY)A = VA when AY **)
apply set_ext.
- let W.
  assume HW: W :e subspace_topology Y (subspace_topology X Tx Y) A.
  prove W :e subspace_topology X Tx A.
  (** W  subspace_topology Y (subspace_topology X Tx Y) A means W  Power A and exists U(subspace_topology X Tx Y) with W = U  A. **)
  claim HWPowerA: W :e Power A.
  { exact (SepE1 (Power A) (fun U0:set => exists U :e subspace_topology X Tx Y, U0 = U :/\: A) W HW). }
  claim HWexists: exists U :e subspace_topology X Tx Y, W = U :/\: A.
  { exact (SepE2 (Power A) (fun U0:set => exists U :e subspace_topology X Tx Y, U0 = U :/\: A) W HW). }
  apply HWexists.
  let U.
  assume HU: U :e subspace_topology X Tx Y /\ W = U :/\: A.
  claim HUinSubY: U :e subspace_topology X Tx Y.
  { exact (andEL (U :e subspace_topology X Tx Y) (W = U :/\: A) HU). }
  claim HWeqUA: W = U :/\: A.
  { exact (andER (U :e subspace_topology X Tx Y) (W = U :/\: A) HU). }
  (** U  subspace_topology X Tx Y means U  Power Y  VTx, U = V  Y **)
  claim HUPowerY: U :e Power Y.
  { exact (SepE1 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HUinSubY). }
  claim HUexists: exists V :e Tx, U = V :/\: Y.
  { exact (SepE2 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HUinSubY). }
  apply HUexists.
  let V.
  assume HV: V :e Tx /\ U = V :/\: Y.
  claim HVinTx: V :e Tx.
  { exact (andEL (V :e Tx) (U = V :/\: Y) HV). }
  claim HUeqVY: U = V :/\: Y.
  { exact (andER (V :e Tx) (U = V :/\: Y) HV). }
  (** Now W = U  A = (V  Y)  A = V  A by binintersect_right_absorb_subset **)
  claim HWeqVA: W = V :/\: A.
  { rewrite HWeqUA.
    rewrite HUeqVY.
    exact (binintersect_right_absorb_subset V Y A HA). }
  (** So W  {W  Power A | VTx, W = VA} = subspace_topology X Tx A **)
  claim HWPred: exists V0 :e Tx, W = V0 :/\: A.
  { witness V.
    apply andI.
    - exact HVinTx.
    - exact HWeqVA. }
  exact (SepI (Power A) (fun W0:set => exists V0 :e Tx, W0 = V0 :/\: A) W HWPowerA HWPred).
- let W.
  assume HW: W :e subspace_topology X Tx A.
  prove W :e subspace_topology Y (subspace_topology X Tx Y) A.
  (** W  subspace_topology X Tx A means W  Power A  VTx, W = V  A **)
  claim HWPowerA: W :e Power A.
  { exact (SepE1 (Power A) (fun W0:set => exists V :e Tx, W0 = V :/\: A) W HW). }
  claim HWexists: exists V :e Tx, W = V :/\: A.
  { exact (SepE2 (Power A) (fun W0:set => exists V :e Tx, W0 = V :/\: A) W HW). }
  apply HWexists.
  let V.
  assume HV: V :e Tx /\ W = V :/\: A.
  claim HVinTx: V :e Tx.
  { exact (andEL (V :e Tx) (W = V :/\: A) HV). }
  claim HWeqVA: W = V :/\: A.
  { exact (andER (V :e Tx) (W = V :/\: A) HV). }
  (** Set U = V  Y. Then U  subspace_topology X Tx Y, and W = U  A **)
  set U := V :/\: Y.
  claim HUinSubY: U :e subspace_topology X Tx Y.
  { claim HUPowerY: U :e Power Y.
    { exact (PowerI Y U (binintersect_Subq_2 V Y)). }
    claim HUPred: exists V0 :e Tx, U = V0 :/\: Y.
    { witness V.
      apply andI.
      - exact HVinTx.
      - reflexivity. }
    exact (SepI (Power Y) (fun U0:set => exists V0 :e Tx, U0 = V0 :/\: Y) U HUPowerY HUPred). }
  claim HWeqUA: W = U :/\: A.
  { rewrite HWeqVA.
    symmetry.
    exact (binintersect_right_absorb_subset V Y A HA). }
  (** So W  {W  Power A | U(subspace_topology X Tx Y), W = UA} **)
  claim HWPred: exists U0 :e subspace_topology X Tx Y, W = U0 :/\: A.
  { witness U.
    apply andI.
    - exact HUinSubY.
    - exact HWeqUA. }
  exact (SepI (Power A) (fun W0:set => exists U0 :e subspace_topology X Tx Y, W0 = U0 :/\: A) W HWPowerA HWPred).
Qed.

(** from 16 Exercise 2: fineness relation passes to subspaces **)
(** LATEX VERSION: Exercise 2: If T'T on X, then the induced subspace topology from T' on Y is contained in that from T. **)
Theorem ex16_2_finer_subspaces : forall X T T' Y:set,
  topology_on X T -> topology_on X T' -> T' c= T -> Y c= X ->
  subspace_topology X T' Y c= subspace_topology X T Y.
let X T T' Y.
assume Htop: topology_on X T.
assume Htop': topology_on X T'.
assume Hfiner: T' c= T.
assume HY: Y c= X.
prove subspace_topology X T' Y c= subspace_topology X T Y.
(** Strategy: If W  subspace_topology X T' Y, then W = V'  Y for some V'  T'; since T'  T, V'  T, so W  subspace_topology X T Y. **)
let W.
assume HW: W :e subspace_topology X T' Y.
prove W :e subspace_topology X T Y.
(** W  subspace_topology X T' Y means W  Power Y  V'T', W = V'  Y **)
claim HWPowerY: W :e Power Y.
{ exact (SepE1 (Power Y) (fun W0:set => exists V :e T', W0 = V :/\: Y) W HW). }
claim HWexists: exists V :e T', W = V :/\: Y.
{ exact (SepE2 (Power Y) (fun W0:set => exists V :e T', W0 = V :/\: Y) W HW). }
apply HWexists.
let V'.
assume HV': V' :e T' /\ W = V' :/\: Y.
claim HV'inT': V' :e T'.
{ exact (andEL (V' :e T') (W = V' :/\: Y) HV'). }
claim HWeqV'Y: W = V' :/\: Y.
{ exact (andER (V' :e T') (W = V' :/\: Y) HV'). }
(** Since T'  T, we have V'  T **)
claim HV'inT: V' :e T.
{ exact (Hfiner V' HV'inT'). }
(** So W = V'  Y with V'  T, meaning W  subspace_topology X T Y **)
claim HWPred: exists V :e T, W = V :/\: Y.
{ witness V'.
  apply andI.
  - exact HV'inT.
  - exact HWeqV'Y. }
exact (SepI (Power Y) (fun W0:set => exists V :e T, W0 = V :/\: Y) W HWPowerY HWPred).
Qed.

(** Helper: subspace topology respects equality of ambient topologies **)
Theorem subspace_topology_eq_of_eq : forall X T T' Y:set,
  T = T' ->
  subspace_topology X T Y = subspace_topology X T' Y.
let X T T' Y.
assume Heq: T = T'.
prove subspace_topology X T Y = subspace_topology X T' Y.
rewrite Heq.
reflexivity.
Qed.

(** from 16 Exercise 3: openness of specific sets in subspace [-1,1] **)
(** LATEX VERSION: Exercise 3: Determine openness in subspace [-1,1]; formalized as existence of ambient open V with U=VY. **)
(** LATEX VERSION: A={x|1/2<|x|<1}, B={x|1/2<|x|<=1}, C={x|1/2<=|x|<1}, D={x|1/2<=|x|<=1}, E={x|0<|x|<1 and 1/x not in Zplus}. **)
Definition one_half : set := inv_nat 2.
Definition interval_A : set := {x :e R | one_half < abs_SNo x /\ abs_SNo x < 1}.
Definition interval_B : set := {x :e R | one_half < abs_SNo x /\ ~(1 < abs_SNo x)}.
Definition interval_C : set := {x :e R | ~(abs_SNo x < one_half) /\ abs_SNo x < 1}.
Definition interval_D : set := {x :e R | ~(abs_SNo x < one_half) /\ ~(1 < abs_SNo x)}.
Definition interval_E : set := {x :e R | 0 < abs_SNo x /\ abs_SNo x < 1 /\ ~ (div_SNo 1 x :e Zplus)}.

Theorem ex16_3_open_sets_subspace : forall X Tx Y:set,
  topology_on X Tx -> Y c= X ->
  forall U:set, open_in Y (subspace_topology X Tx Y) U -> exists V:set, open_in X Tx V /\ U = V :/\: Y.
let X Tx Y.
assume Htop: topology_on X Tx.
assume HY: Y c= X.
let U.
assume HU: open_in Y (subspace_topology X Tx Y) U.
prove exists V:set, open_in X Tx V /\ U = V :/\: Y.
  (** open_in Y (subspace_topology X Tx Y) U means topology_on Y (subspace_topology X Tx Y) and U  subspace_topology X Tx Y. **)
claim HtopY: topology_on Y (subspace_topology X Tx Y).
{ exact (andEL (topology_on Y (subspace_topology X Tx Y)) (U :e subspace_topology X Tx Y) HU). }
claim HUinSub: U :e subspace_topology X Tx Y.
{ exact (andER (topology_on Y (subspace_topology X Tx Y)) (U :e subspace_topology X Tx Y) HU). }
(** U  subspace_topology X Tx Y means U  Power Y  VTx, U = V  Y **)
claim HUPowerY: U :e Power Y.
{ exact (SepE1 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HUinSub). }
claim HUexists: exists V :e Tx, U = V :/\: Y.
{ exact (SepE2 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HUinSub). }
apply HUexists.
let V.
assume HV: V :e Tx /\ U = V :/\: Y.
claim HVinTx: V :e Tx.
{ exact (andEL (V :e Tx) (U = V :/\: Y) HV). }
claim HUeqVY: U = V :/\: Y.
{ exact (andER (V :e Tx) (U = V :/\: Y) HV). }
(** Now open_in X Tx V means topology_on X Tx  V  Tx, both of which we have **)
claim HVopen: open_in X Tx V.
{ exact (andI (topology_on X Tx) (V :e Tx) Htop HVinTx). }
witness V.
apply andI.
- exact HVopen.
- exact HUeqVY.
Qed.

(** from 16 Exercise 4: projections are open maps **)
(** LATEX VERSION: Exercise 4: Projections from a product are open maps. **)
Definition projection_image1 : set -> set -> set -> set :=
  fun X Y U => {x :e X | exists y:set, (x,y) :e U}.
Definition projection_image2 : set -> set -> set -> set :=
  fun X Y U => {y :e Y | exists x:set, (x,y) :e U}.

(** helper: nonempty set has an element **)
Theorem nonempty_has_element : forall V:set, V <> Empty -> exists y:set, y :e V.
let V. assume Hne: V <> Empty.
apply (xm (exists y:set, y :e V)).
- assume Hex. exact Hex.
- assume Hno: ~(exists y:set, y :e V).
  claim HVsub: V c= Empty.
  { let y. assume Hy: y :e V.
    prove y :e Empty.
    apply FalseE.
    claim Hexy: exists z:set, z :e V.
    { witness y. exact Hy. }
    exact (Hno Hexy). }
  claim HVEmpty: V = Empty.
  { exact (Empty_Subq_eq V HVsub). }
  apply FalseE.
  exact (Hne HVEmpty).
Qed.

(** helper: set with an element is nonempty **)
Theorem elem_implies_nonempty : forall V y:set, y :e V -> V <> Empty.
let V y.
assume Hy: y :e V.
prove V <> Empty.
assume HV: V = Empty.
claim HyE: y :e Empty.
{ rewrite <- HV.
  exact Hy. }
exact (EmptyE y HyE).
Qed.

(** helper: projection of a rectangle to the first coordinate **)
Theorem projection_image1_rectangle_nonempty : forall X Y U V:set,
  U c= X ->
  V c= Y ->
  V <> Empty ->
  projection_image1 X Y (setprod U V) = U.
let X Y U V.
assume HUsub: U c= X.
assume HVsub: V c= Y.
assume HVne: V <> Empty.
set y0 := Eps_i (fun y:set => y :e V).
claim Hexy: exists y:set, y :e V.
{ exact (nonempty_has_element V HVne). }
claim Hy0: y0 :e V.
{ exact (Eps_i_ex (fun y:set => y :e V) Hexy). }
apply set_ext.
- let x. assume Hx: x :e projection_image1 X Y (setprod U V).
  prove x :e U.
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0:set => exists y:set, (x0,y) :e setprod U V) x Hx). }
  claim Hex: exists y:set, (x,y) :e setprod U V.
  { exact (SepE2 X (fun x0:set => exists y:set, (x0,y) :e setprod U V) x Hx). }
  apply Hex.
  let y. assume Hxy: (x,y) :e setprod U V.
  claim Hx0: ((x,y) 0) :e U.
  { exact (ap0_Sigma U (fun _:set => V) (x,y) Hxy). }
  rewrite <- (tuple_2_0_eq x y).
  exact Hx0.
- let x. assume HxU: x :e U.
  prove x :e projection_image1 X Y (setprod U V).
  claim HxX: x :e X.
  { exact (HUsub x HxU). }
  claim Hpred: exists y:set, (x,y) :e setprod U V.
  { witness y0.
    exact (lamI2 U (fun _:set => V) x HxU y0 Hy0). }
  exact (SepI X (fun x0:set => exists y:set, (x0,y) :e setprod U V) x HxX Hpred).
Qed.

Theorem projection_image1_rectangle_empty : forall X Y U:set,
  projection_image1 X Y (setprod U Empty) = Empty.
let X Y U.
apply set_ext.
- let x. assume Hx: x :e projection_image1 X Y (setprod U Empty).
  prove x :e Empty.
  claim Hex: exists y:set, (x,y) :e setprod U Empty.
  { exact (SepE2 X (fun x0:set => exists y:set, (x0,y) :e setprod U Empty) x Hx). }
  apply Hex.
  let y. assume Hxy: (x,y) :e setprod U Empty.
  claim HyEmpty: ((x,y) 1) :e Empty.
  { exact (ap1_Sigma U (fun _:set => Empty) (x,y) Hxy). }
  claim HyE: y :e Empty.
  { prove y :e Empty.
    rewrite <- (tuple_2_1_eq x y).
    exact HyEmpty. }
  apply FalseE.
  exact (EmptyE y HyE).
- let x. assume Hx: x :e Empty.
  apply (EmptyE x Hx).
Qed.

(** helper: projection of a rectangle to the second coordinate **)
Theorem projection_image2_rectangle_nonempty : forall X Y U V:set,
  U c= X ->
  V c= Y ->
  U <> Empty ->
  projection_image2 X Y (setprod U V) = V.
let X Y U V.
assume HUsub: U c= X.
assume HVsub: V c= Y.
assume HUne: U <> Empty.
set x0 := Eps_i (fun x:set => x :e U).
claim Hexx: exists x:set, x :e U.
{ exact (nonempty_has_element U HUne). }
claim Hx0: x0 :e U.
{ exact (Eps_i_ex (fun x:set => x :e U) Hexx). }
apply set_ext.
- let y. assume Hy: y :e projection_image2 X Y (setprod U V).
  prove y :e V.
  claim HyY: y :e Y.
  { exact (SepE1 Y (fun y0:set => exists x:set, (x,y0) :e setprod U V) y Hy). }
  claim Hex: exists x:set, (x,y) :e setprod U V.
  { exact (SepE2 Y (fun y0:set => exists x:set, (x,y0) :e setprod U V) y Hy). }
  apply Hex.
  let x. assume Hxy: (x,y) :e setprod U V.
  claim Hy1: ((x,y) 1) :e V.
  { exact (ap1_Sigma U (fun _:set => V) (x,y) Hxy). }
  rewrite <- (tuple_2_1_eq x y).
  exact Hy1.
- let y. assume HyV: y :e V.
  prove y :e projection_image2 X Y (setprod U V).
  claim HyY: y :e Y.
  { exact (HVsub y HyV). }
  claim Hpred: exists x:set, (x,y) :e setprod U V.
  { witness x0.
    exact (lamI2 U (fun _:set => V) x0 Hx0 y HyV). }
  exact (SepI Y (fun y0:set => exists x:set, (x,y0) :e setprod U V) y HyY Hpred).
Qed.

Theorem projection_image2_rectangle_empty : forall X Y V:set,
  projection_image2 X Y (setprod Empty V) = Empty.
let X Y V.
apply set_ext.
- let y. assume Hy: y :e projection_image2 X Y (setprod Empty V).
  prove y :e Empty.
  claim Hex: exists x:set, (x,y) :e setprod Empty V.
  { exact (SepE2 Y (fun y0:set => exists x:set, (x,y0) :e setprod Empty V) y Hy). }
  apply Hex.
  let x. assume Hxy: (x,y) :e setprod Empty V.
  claim HxEmpty: ((x,y) 0) :e Empty.
  { exact (ap0_Sigma Empty (fun _:set => V) (x,y) Hxy). }
  claim HxE: x :e Empty.
  { prove x :e Empty.
    rewrite <- (tuple_2_0_eq x y).
    exact HxEmpty. }
  apply FalseE.
  exact (EmptyE x HxE).
- let y. assume Hy: y :e Empty.
  apply (EmptyE y Hy).
Qed.

Theorem ex16_4_projections_open : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  forall U:set, U :e product_topology X Tx Y Ty ->
    open_in X Tx (projection_image1 X Y U) /\ open_in Y Ty (projection_image2 X Y U).
let X Tx Y Ty.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
let U.
assume HU: U :e product_topology X Tx Y Ty.
prove open_in X Tx (projection_image1 X Y U) /\ open_in Y Ty (projection_image2 X Y U).
apply andI.
- prove open_in X Tx (projection_image1 X Y U).
  prove topology_on X Tx /\ projection_image1 X Y U :e Tx.
  apply andI.
  + exact HTx.
  + (** represent U as a union of product subbasis elements **)
    claim HtopProd: topology_on (setprod X Y) (product_topology X Tx Y Ty).
    { exact (product_topology_is_topology X Tx Y Ty HTx HTy). }
    claim HUopen: open_in (setprod X Y) (product_topology X Tx Y Ty) U.
    { exact (andI (topology_on (setprod X Y) (product_topology X Tx Y Ty)) (U :e product_topology X Tx Y Ty) HtopProd HU). }
    claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
    { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
    claim HexFam: exists Fam :e Power (product_subbasis X Tx Y Ty), Union Fam = U.
    { exact (open_sets_as_unions_of_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis U HUopen). }
    apply HexFam.
    let Fam. assume HFampair.
    claim HFamPow: Fam :e Power (product_subbasis X Tx Y Ty).
    { exact (andEL (Fam :e Power (product_subbasis X Tx Y Ty)) (Union Fam = U) HFampair). }
    claim HUnionEq: Union Fam = U.
    { exact (andER (Fam :e Power (product_subbasis X Tx Y Ty)) (Union Fam = U) HFampair). }
    set P1Fam := {projection_image1 X Y b|b :e Fam}.
    claim HP1open: open_in X Tx (Union P1Fam).
    { apply (union_open X Tx P1Fam HTx).
      let W. assume HW: W :e P1Fam.
      prove open_in X Tx W.
      claim Hexb: exists b :e Fam, W = projection_image1 X Y b.
      { exact (ReplE Fam (fun b0:set => projection_image1 X Y b0) W HW). }
      apply Hexb.
      let b. assume Hbpair.
      claim HbFam: b :e Fam.
      { exact (andEL (b :e Fam) (W = projection_image1 X Y b) Hbpair). }
      claim HWeq: W = projection_image1 X Y b.
      { exact (andER (b :e Fam) (W = projection_image1 X Y b) Hbpair). }
      claim HbSub: b :e product_subbasis X Tx Y Ty.
      { exact (PowerE (product_subbasis X Tx Y Ty) Fam HFamPow b HbFam). }
      claim HexU0: exists U0 :e Tx, b :e {rectangle_set U0 V|V :e Ty}.
      { exact (famunionE Tx (fun U0:set => {rectangle_set U0 V|V :e Ty}) b HbSub). }
      apply HexU0.
      let U0. assume HU0conj.
      claim HU0Tx: U0 :e Tx.
      { exact (andEL (U0 :e Tx) (b :e {rectangle_set U0 V|V :e Ty}) HU0conj). }
      claim HbRepl: b :e {rectangle_set U0 V|V :e Ty}.
      { exact (andER (U0 :e Tx) (b :e {rectangle_set U0 V|V :e Ty}) HU0conj). }
      claim HexV0: exists V0 :e Ty, b = rectangle_set U0 V0.
      { exact (ReplE Ty (fun V0:set => rectangle_set U0 V0) b HbRepl). }
      apply HexV0.
      let V0. assume HV0conj.
      claim HV0Ty: V0 :e Ty.
      { exact (andEL (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }
      claim Hbeq: b = rectangle_set U0 V0.
      { exact (andER (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }
      claim HU0subX: U0 c= X.
      { exact (topology_elem_subset X Tx U0 HTx HU0Tx). }
      claim HV0subY: V0 c= Y.
      { exact (topology_elem_subset Y Ty V0 HTy HV0Ty). }
      apply (xm (V0 = Empty)).
      - assume HV0E: V0 = Empty.
        claim HWEmpty: W = Empty.
        { prove W = Empty.
          rewrite HWeq.
          rewrite Hbeq.
          rewrite HV0E.
          exact (projection_image1_rectangle_empty X Y U0). }
        rewrite HWEmpty.
        exact (andI (topology_on X Tx) (Empty :e Tx) HTx (topology_has_empty X Tx HTx)).
      - assume HV0NE: ~(V0 = Empty).
        claim HV0ne: V0 <> Empty.
        { exact HV0NE. }
        claim HWU0: W = U0.
        { prove W = U0.
          rewrite HWeq.
          rewrite Hbeq.
          exact (projection_image1_rectangle_nonempty X Y U0 V0 HU0subX HV0subY HV0ne). }
        rewrite HWU0.
        exact (andI (topology_on X Tx) (U0 :e Tx) HTx HU0Tx). }
    claim HP1inTx: Union P1Fam :e Tx.
    { exact (andER (topology_on X Tx) (Union P1Fam :e Tx) HP1open). }
    claim HUnionP1: Union P1Fam = projection_image1 X Y (Union Fam).
    { apply set_ext.
      - let x. assume Hx: x :e Union P1Fam.
        claim HexW: exists W:set, x :e W /\ W :e P1Fam.
        { exact (UnionE P1Fam x Hx). }
        apply HexW.
        let W. assume HWconj.
        claim HxW: x :e W.
        { exact (andEL (x :e W) (W :e P1Fam) HWconj). }
        claim HWPF: W :e P1Fam.
        { exact (andER (x :e W) (W :e P1Fam) HWconj). }
        claim Hexb: exists b :e Fam, W = projection_image1 X Y b.
        { exact (ReplE Fam (fun b0:set => projection_image1 X Y b0) W HWPF). }
        apply Hexb.
        let b. assume Hbpair.
        claim HbFam: b :e Fam.
        { exact (andEL (b :e Fam) (W = projection_image1 X Y b) Hbpair). }
        claim HWeq: W = projection_image1 X Y b.
        { exact (andER (b :e Fam) (W = projection_image1 X Y b) Hbpair). }
        claim HxP1b: x :e projection_image1 X Y b.
        { rewrite <- HWeq. exact HxW. }
        claim HxX: x :e X.
        { exact (SepE1 X (fun x0:set => exists y:set, (x0,y) :e b) x HxP1b). }
        claim Hexy: exists y:set, (x,y) :e b.
        { exact (SepE2 X (fun x0:set => exists y:set, (x0,y) :e b) x HxP1b). }
        claim Hpred: exists y:set, (x,y) :e Union Fam.
        { apply Hexy.
          let y. assume Hxy: (x,y) :e b.
          claim HbInUnion: (x,y) :e Union Fam.
          { exact (UnionI Fam (x,y) b Hxy HbFam). }
          witness y.
          exact HbInUnion. }
        exact (SepI X (fun x0:set => exists y:set, (x0,y) :e Union Fam) x HxX Hpred).
      - let x. assume Hx: x :e projection_image1 X Y (Union Fam).
        prove x :e Union P1Fam.
        claim HxX: x :e X.
        { exact (SepE1 X (fun x0:set => exists y:set, (x0,y) :e Union Fam) x Hx). }
        claim Hexy: exists y:set, (x,y) :e Union Fam.
        { exact (SepE2 X (fun x0:set => exists y:set, (x0,y) :e Union Fam) x Hx). }
        apply Hexy.
        let y. assume HxyUnion: (x,y) :e Union Fam.
        apply UnionE_impred Fam (x,y) HxyUnion.
        let b. assume Hxyb HbFam.
        claim HbPF: projection_image1 X Y b :e P1Fam.
        { exact (ReplI Fam (fun b0:set => projection_image1 X Y b0) b HbFam). }
        claim HxP1b: x :e projection_image1 X Y b.
        { claim Hpred: exists y0:set, (x,y0) :e b.
          { witness y.
            exact Hxyb. }
          exact (SepI X (fun x0:set => exists y0:set, (x0,y0) :e b) x HxX Hpred). }
        exact (UnionI P1Fam x (projection_image1 X Y b) HxP1b HbPF). }
    rewrite <- HUnionEq.
    rewrite <- HUnionP1.
    exact HP1inTx.
- prove open_in Y Ty (projection_image2 X Y U).
  prove topology_on Y Ty /\ projection_image2 X Y U :e Ty.
  apply andI.
  + exact HTy.
  + claim HtopProd: topology_on (setprod X Y) (product_topology X Tx Y Ty).
    { exact (product_topology_is_topology X Tx Y Ty HTx HTy). }
    claim HUopen: open_in (setprod X Y) (product_topology X Tx Y Ty) U.
    { exact (andI (topology_on (setprod X Y) (product_topology X Tx Y Ty)) (U :e product_topology X Tx Y Ty) HtopProd HU). }
    claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
    { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
    claim HexFam: exists Fam :e Power (product_subbasis X Tx Y Ty), Union Fam = U.
    { exact (open_sets_as_unions_of_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis U HUopen). }
    apply HexFam.
    let Fam. assume HFampair.
    claim HFamPow: Fam :e Power (product_subbasis X Tx Y Ty).
    { exact (andEL (Fam :e Power (product_subbasis X Tx Y Ty)) (Union Fam = U) HFampair). }
    claim HUnionEq: Union Fam = U.
    { exact (andER (Fam :e Power (product_subbasis X Tx Y Ty)) (Union Fam = U) HFampair). }
    set P2Fam := {projection_image2 X Y b|b :e Fam}.
    claim HP2open: open_in Y Ty (Union P2Fam).
    { apply (union_open Y Ty P2Fam HTy).
      let W. assume HW: W :e P2Fam.
      prove open_in Y Ty W.
      claim Hexb: exists b :e Fam, W = projection_image2 X Y b.
      { exact (ReplE Fam (fun b0:set => projection_image2 X Y b0) W HW). }
      apply Hexb.
      let b. assume Hbpair.
      claim HbFam: b :e Fam.
      { exact (andEL (b :e Fam) (W = projection_image2 X Y b) Hbpair). }
      claim HWeq: W = projection_image2 X Y b.
      { exact (andER (b :e Fam) (W = projection_image2 X Y b) Hbpair). }
      claim HbSub: b :e product_subbasis X Tx Y Ty.
      { exact (PowerE (product_subbasis X Tx Y Ty) Fam HFamPow b HbFam). }
      claim HexU0: exists U0 :e Tx, b :e {rectangle_set U0 V|V :e Ty}.
      { exact (famunionE Tx (fun U0:set => {rectangle_set U0 V|V :e Ty}) b HbSub). }
      apply HexU0.
      let U0. assume HU0conj.
      claim HU0Tx: U0 :e Tx.
      { exact (andEL (U0 :e Tx) (b :e {rectangle_set U0 V|V :e Ty}) HU0conj). }
      claim HbRepl: b :e {rectangle_set U0 V|V :e Ty}.
      { exact (andER (U0 :e Tx) (b :e {rectangle_set U0 V|V :e Ty}) HU0conj). }
      claim HexV0: exists V0 :e Ty, b = rectangle_set U0 V0.
      { exact (ReplE Ty (fun V0:set => rectangle_set U0 V0) b HbRepl). }
      apply HexV0.
      let V0. assume HV0conj.
      claim HV0Ty: V0 :e Ty.
      { exact (andEL (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }
      claim Hbeq: b = rectangle_set U0 V0.
      { exact (andER (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }
      claim HU0subX: U0 c= X.
      { exact (topology_elem_subset X Tx U0 HTx HU0Tx). }
      claim HV0subY: V0 c= Y.
      { exact (topology_elem_subset Y Ty V0 HTy HV0Ty). }
      apply (xm (U0 = Empty)).
      - assume HU0E: U0 = Empty.
        claim HWEmpty: W = Empty.
        { prove W = Empty.
          rewrite HWeq.
          rewrite Hbeq.
          rewrite HU0E.
          exact (projection_image2_rectangle_empty X Y V0). }
        rewrite HWEmpty.
        exact (andI (topology_on Y Ty) (Empty :e Ty) HTy (topology_has_empty Y Ty HTy)).
      - assume HU0NE: ~(U0 = Empty).
        claim HUne: U0 <> Empty.
        { exact HU0NE. }
        claim HWV0: W = V0.
        { prove W = V0.
          rewrite HWeq.
          rewrite Hbeq.
          exact (projection_image2_rectangle_nonempty X Y U0 V0 HU0subX HV0subY HUne). }
        rewrite HWV0.
        exact (andI (topology_on Y Ty) (V0 :e Ty) HTy HV0Ty). }
    claim HP2inTy: Union P2Fam :e Ty.
    { exact (andER (topology_on Y Ty) (Union P2Fam :e Ty) HP2open). }
    claim HUnionP2: Union P2Fam = projection_image2 X Y (Union Fam).
    { apply set_ext.
      - let y. assume Hy: y :e Union P2Fam.
        claim HexW: exists W:set, y :e W /\ W :e P2Fam.
        { exact (UnionE P2Fam y Hy). }
        apply HexW.
        let W. assume HWconj.
        claim HyW: y :e W.
        { exact (andEL (y :e W) (W :e P2Fam) HWconj). }
        claim HWPF: W :e P2Fam.
        { exact (andER (y :e W) (W :e P2Fam) HWconj). }
        claim Hexb: exists b :e Fam, W = projection_image2 X Y b.
        { exact (ReplE Fam (fun b0:set => projection_image2 X Y b0) W HWPF). }
        apply Hexb.
        let b. assume Hbpair.
        claim HbFam: b :e Fam.
        { exact (andEL (b :e Fam) (W = projection_image2 X Y b) Hbpair). }
        claim HWeq: W = projection_image2 X Y b.
        { exact (andER (b :e Fam) (W = projection_image2 X Y b) Hbpair). }
        claim HyP2b: y :e projection_image2 X Y b.
        { rewrite <- HWeq. exact HyW. }
        claim HyY: y :e Y.
        { exact (SepE1 Y (fun y0:set => exists x:set, (x,y0) :e b) y HyP2b). }
        claim Hexx: exists x:set, (x,y) :e b.
        { exact (SepE2 Y (fun y0:set => exists x:set, (x,y0) :e b) y HyP2b). }
        claim Hpred: exists x:set, (x,y) :e Union Fam.
        { apply Hexx.
          let x. assume Hxy: (x,y) :e b.
          claim HbInUnion: (x,y) :e Union Fam.
          { exact (UnionI Fam (x,y) b Hxy HbFam). }
          witness x.
          exact HbInUnion. }
        exact (SepI Y (fun y0:set => exists x:set, (x,y0) :e Union Fam) y HyY Hpred).
      - let y. assume Hy: y :e projection_image2 X Y (Union Fam).
        prove y :e Union P2Fam.
        claim HyY: y :e Y.
        { exact (SepE1 Y (fun y0:set => exists x:set, (x,y0) :e Union Fam) y Hy). }
        claim Hexx: exists x:set, (x,y) :e Union Fam.
        { exact (SepE2 Y (fun y0:set => exists x:set, (x,y0) :e Union Fam) y Hy). }
        apply Hexx.
        let x. assume HxyUnion: (x,y) :e Union Fam.
        apply UnionE_impred Fam (x,y) HxyUnion.
        let b. assume Hxyb HbFam.
        claim HbPF: projection_image2 X Y b :e P2Fam.
        { exact (ReplI Fam (fun b0:set => projection_image2 X Y b0) b HbFam). }
        claim HyP2b: y :e projection_image2 X Y b.
        { claim Hpred: exists x0:set, (x0,y) :e b.
          { witness x.
            exact Hxyb. }
          exact (SepI Y (fun y0:set => exists x0:set, (x0,y0) :e b) y HyY Hpred). }
        exact (UnionI P2Fam y (projection_image2 X Y b) HyP2b HbPF). }
    rewrite <- HUnionEq.
    rewrite <- HUnionP2.
    exact HP2inTy.
Qed.

(** from 16 Exercise 5(a): product topology monotonicity **)
(** LATEX VERSION: Exercise 5(a): If TT' and UU', then the product topology from T,U is contained in that from T',U'. **)
Theorem ex16_5a_product_monotone : forall X T T' Y U U':set,
  X <> Empty -> Y <> Empty ->
  topology_on X T -> topology_on X T' -> topology_on Y U -> topology_on Y U' ->
  T c= T' /\ U c= U' ->
  product_topology X T Y U c= product_topology X T' Y U'.
	let X T T' Y U U'.
	assume HXne: X <> Empty.
	assume HYne: Y <> Empty.
	assume HTx: topology_on X T.
	assume HTx': topology_on X T'.
	assume HTy: topology_on Y U.
	assume HTy': topology_on Y U'.
	assume Hfiner: T c= T' /\ U c= U'.
	prove product_topology X T Y U c= product_topology X T' Y U'.
	claim HBasis: basis_on (setprod X Y) (product_subbasis X T Y U).
	{ exact (product_subbasis_is_basis X T Y U HTx HTy). }
	claim HTprod': topology_on (setprod X Y) (product_topology X T' Y U').
	{ exact (product_topology_is_topology X T' Y U' HTx' HTy'). }
	apply (generated_topology_finer (setprod X Y) (product_subbasis X T Y U) (product_topology X T' Y U') HBasis HTprod').
	let b. assume Hb: b :e product_subbasis X T Y U.
	prove b :e product_topology X T' Y U'.
	claim HexU0: exists U0 :e T, b :e {rectangle_set U0 V|V :e U}.
	{ exact (famunionE T (fun U0:set => {rectangle_set U0 V|V :e U}) b Hb). }
	apply HexU0.
	let U0. assume HU0conj.
	claim HU0T: U0 :e T.
	{ exact (andEL (U0 :e T) (b :e {rectangle_set U0 V|V :e U}) HU0conj). }
	claim HbRepl: b :e {rectangle_set U0 V|V :e U}.
	{ exact (andER (U0 :e T) (b :e {rectangle_set U0 V|V :e U}) HU0conj). }
	claim HexV0: exists V0 :e U, b = rectangle_set U0 V0.
	{ exact (ReplE U (fun V0:set => rectangle_set U0 V0) b HbRepl). }
	apply HexV0.
	let V0. assume HV0conj.
	claim HV0U: V0 :e U.
	{ exact (andEL (V0 :e U) (b = rectangle_set U0 V0) HV0conj). }
	claim Hbeq: b = rectangle_set U0 V0.
	{ exact (andER (V0 :e U) (b = rectangle_set U0 V0) HV0conj). }
	claim HU0sub: U0 :e T'.
	{ claim HTsub: T c= T'.
	  { exact (andEL (T c= T') (U c= U') Hfiner). }
	  exact (HTsub U0 HU0T). }
	claim HV0sub: V0 :e U'.
	{ claim HUsub: U c= U'.
	  { exact (andER (T c= T') (U c= U') Hfiner). }
	  exact (HUsub V0 HV0U). }
	claim HBasis': basis_on (setprod X Y) (product_subbasis X T' Y U').
	{ exact (product_subbasis_is_basis X T' Y U' HTx' HTy'). }
	claim HbSub': b :e product_subbasis X T' Y U'.
	{ prove b :e product_subbasis X T' Y U'.
	  claim HbV: rectangle_set U0 V0 :e {rectangle_set U0 V|V :e U'}.
	  { exact (ReplI U' (fun V1:set => rectangle_set U0 V1) V0 HV0sub). }
	  rewrite Hbeq.
	  exact (famunionI T' (fun U1:set => {rectangle_set U1 V|V :e U'}) U0 (rectangle_set U0 V0) HU0sub HbV). }
	exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X T' Y U') HBasis' b HbSub').
Qed.

(** from 16 Exercise 5(b): converse question about product fineness **)
(** LATEX VERSION: Exercise 5(b): If product topology from T,U is contained in that from T',U', then TT' and UU'. **)
Theorem ex16_5b_product_converse : forall X T T' Y U U':set,
  X <> Empty -> Y <> Empty ->
  topology_on X T -> topology_on X T' -> topology_on Y U -> topology_on Y U' ->
  product_topology X T Y U c= product_topology X T' Y U' ->
  T c= T' /\ U c= U'.
	let X T T' Y U U'.
	assume HXne: X <> Empty.
	assume HYne: Y <> Empty.
	assume HTx: topology_on X T.
	assume HTx': topology_on X T'.
	assume HTy: topology_on Y U.
	assume HTy': topology_on Y U'.
	assume Hprod: product_topology X T Y U c= product_topology X T' Y U'.
	prove T c= T' /\ U c= U'.
	apply andI.
	- (** show T c= T' using openness of projection_image1 **)
	  let V. assume HV: V :e T.
	  prove V :e T'.
	  claim HVsubX: V c= X.
	  { exact (topology_elem_subset X T V HTx HV). }
	  claim HYsubY: Y c= Y.
	  { let y. assume Hy: y :e Y. exact Hy. }
	  claim HYU: Y :e U.
	  { exact (topology_has_X Y U HTy). }
	  claim HbSub: rectangle_set V Y :e product_subbasis X T Y U.
	  { prove rectangle_set V Y :e product_subbasis X T Y U.
	    claim HbV: rectangle_set V Y :e {rectangle_set V W|W :e U}.
	    { exact (ReplI U (fun W1:set => rectangle_set V W1) Y HYU). }
	    exact (famunionI T (fun U0:set => {rectangle_set U0 W|W :e U}) V (rectangle_set V Y) HV HbV). }
	  claim HBasis: basis_on (setprod X Y) (product_subbasis X T Y U).
	  { exact (product_subbasis_is_basis X T Y U HTx HTy). }
	  claim HbOpen: rectangle_set V Y :e product_topology X T Y U.
	  { exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X T Y U) HBasis (rectangle_set V Y) HbSub). }
	  claim HbOpen': rectangle_set V Y :e product_topology X T' Y U'.
	  { exact (Hprod (rectangle_set V Y) HbOpen). }
	  claim HprojOpen: open_in X T' (projection_image1 X Y (rectangle_set V Y)).
	  { exact (andEL (open_in X T' (projection_image1 X Y (rectangle_set V Y))) (open_in Y U' (projection_image2 X Y (rectangle_set V Y)))
	                 (ex16_4_projections_open X T' Y U' HTx' HTy' (rectangle_set V Y) HbOpen')). }
	  claim HVeqProj: projection_image1 X Y (rectangle_set V Y) = V.
	  { exact (projection_image1_rectangle_nonempty X Y V Y HVsubX HYsubY HYne). }
	  claim HVinT': projection_image1 X Y (rectangle_set V Y) :e T'.
	  { exact (andER (topology_on X T') (projection_image1 X Y (rectangle_set V Y) :e T') HprojOpen). }
	  rewrite <- HVeqProj.
	  exact HVinT'.
	- (** show U c= U' using openness of projection_image2 **)
	  let W. assume HW: W :e U.
	  prove W :e U'.
	  claim HWsubY: W c= Y.
	  { exact (topology_elem_subset Y U W HTy HW). }
	  claim HXsubX: X c= X.
	  { let x. assume Hx: x :e X. exact Hx. }
	  claim HX_T: X :e T.
	  { exact (topology_has_X X T HTx). }
	  claim HbSub: rectangle_set X W :e product_subbasis X T Y U.
	  { prove rectangle_set X W :e product_subbasis X T Y U.
	    claim HbW: rectangle_set X W :e {rectangle_set X V|V :e U}.
	    { exact (ReplI U (fun V1:set => rectangle_set X V1) W HW). }
	    exact (famunionI T (fun U0:set => {rectangle_set U0 V|V :e U}) X (rectangle_set X W) HX_T HbW). }
	  claim HBasis: basis_on (setprod X Y) (product_subbasis X T Y U).
	  { exact (product_subbasis_is_basis X T Y U HTx HTy). }
	  claim HbOpen: rectangle_set X W :e product_topology X T Y U.
	  { exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X T Y U) HBasis (rectangle_set X W) HbSub). }
	  claim HbOpen': rectangle_set X W :e product_topology X T' Y U'.
	  { exact (Hprod (rectangle_set X W) HbOpen). }
	  claim HprojOpen: open_in Y U' (projection_image2 X Y (rectangle_set X W)).
	  { exact (andER (open_in X T' (projection_image1 X Y (rectangle_set X W))) (open_in Y U' (projection_image2 X Y (rectangle_set X W)))
	                 (ex16_4_projections_open X T' Y U' HTx' HTy' (rectangle_set X W) HbOpen')). }
	  claim HWeqProj: projection_image2 X Y (rectangle_set X W) = W.
	  { exact (projection_image2_rectangle_nonempty X Y X W HXsubX HWsubY HXne). }
	  claim HWinU': projection_image2 X Y (rectangle_set X W) :e U'.
	  { exact (andER (topology_on Y U') (projection_image2 X Y (rectangle_set X W) :e U') HprojOpen). }
	  rewrite <- HWeqProj.
	  exact HWinU'.
Qed.

(** from 16 Exercise 6: rational rectangles form a basis for  **)
(** LATEX VERSION: Exercise 6: Rational rectangles form a basis generating the standard topology on . **)
Definition rational_rectangle_basis : set :=
  {r :e Power (setprod R R) |
     exists a b c d:set,
       a :e rational_numbers /\ b :e rational_numbers /\
       c :e rational_numbers /\ d :e rational_numbers /\
       r = setprod (open_interval a b) (open_interval c d)}.

(** helper: open intervals are standard-open when endpoints are real **)
(** LATEX VERSION: Since the standard basis contains all open intervals (a,b) with a,b in R, such intervals are open in the standard topology. **)
Theorem open_interval_in_R_standard_topology_endpoints : forall a b:set,
  a :e R -> b :e R -> open_interval a b :e R_standard_topology.
let a b.
assume HaR: a :e R.
assume HbR: b :e R.
claim HbFam : open_interval a b :e {open_interval a b0|b0 :e R}.
{ exact (ReplI R (fun b0:set => open_interval a b0) b HbR). }
claim HbStd : open_interval a b :e R_standard_basis.
{ exact (famunionI R (fun a0:set => {open_interval a0 b0|b0 :e R}) a (open_interval a b) HaR HbFam). }
exact (generated_topology_contains_basis R R_standard_basis R_standard_basis_is_basis_local (open_interval a b) HbStd).
Qed.

(** helper: rational open intervals are in the rational-interval basis **)
Theorem open_interval_in_rational_open_intervals_basis : forall q1 q2:set,
  q1 :e rational_numbers -> q2 :e rational_numbers ->
  open_interval q1 q2 :e rational_open_intervals_basis.
let q1 q2.
assume Hq1Q: q1 :e rational_numbers.
assume Hq2Q: q2 :e rational_numbers.
claim Hq2fam : open_interval q1 q2 :e {open_interval q1 q2'|q2' :e rational_numbers}.
{ exact (ReplI rational_numbers (fun q2' : set => open_interval q1 q2') q2 Hq2Q). }
exact (famunionI rational_numbers
                 (fun q1' : set => {open_interval q1' q2'|q2' :e rational_numbers})
                 q1
                 (open_interval q1 q2)
                 Hq1Q
                 Hq2fam).
Qed.

(** helper: eliminate membership in rational_open_intervals_basis **)
Theorem rational_open_intervals_basisE : forall b:set,
  b :e rational_open_intervals_basis ->
  exists q1, exists q2, (q1 :e rational_numbers /\ q2 :e rational_numbers /\ b = open_interval q1 q2).
let b. assume Hb: b :e rational_open_intervals_basis.
apply (famunionE_impred rational_numbers
         (fun q1 : set => {open_interval q1 q2|q2 :e rational_numbers})
         b
         Hb
         (exists q1, exists q2, (q1 :e rational_numbers /\ q2 :e rational_numbers /\ b = open_interval q1 q2))).
let q1.
assume Hq1Q: q1 :e rational_numbers.
assume Hbq1: b :e {open_interval q1 q2|q2 :e rational_numbers}.
apply (ReplE_impred rational_numbers (fun q2:set => open_interval q1 q2)
         b Hbq1
         (exists q1, exists q2, (q1 :e rational_numbers /\ q2 :e rational_numbers /\ b = open_interval q1 q2))).
let q2.
assume Hq2Q: q2 :e rational_numbers.
assume Heq: b = open_interval q1 q2.
witness q1.
witness q2.
apply andI.
- apply andI.
  + exact Hq1Q.
  + exact Hq2Q.
- exact Heq.
Qed.

(** helper: rational rectangles are exactly products of rational open intervals **)
(** LATEX VERSION: Rational rectangles (q1,q2)(r1,r2) form the product basis from the rational-interval basis on each coordinate. **)
Theorem rational_rectangle_basis_eq_product_basis_from :
  rational_rectangle_basis =
    product_basis_from rational_open_intervals_basis rational_open_intervals_basis.
apply set_ext.
- let r. assume Hr: r :e rational_rectangle_basis.
  prove r :e product_basis_from rational_open_intervals_basis rational_open_intervals_basis.
  claim Hex: exists a b c d:set,
    a :e rational_numbers /\ b :e rational_numbers /\
    c :e rational_numbers /\ d :e rational_numbers /\
    r = setprod (open_interval a b) (open_interval c d).
  { exact (SepE2 (Power (setprod R R))
                 (fun r0:set => exists a b c d:set,
                   a :e rational_numbers /\ b :e rational_numbers /\
                   c :e rational_numbers /\ d :e rational_numbers /\
                   r0 = setprod (open_interval a b) (open_interval c d))
                 r
                 Hr). }
  apply Hex.
  let a. assume H1.
  apply H1.
  let b. assume H2.
  apply H2.
  let c. assume H3.
  apply H3.
  let d. assume H4.
  claim Hcore:
    a :e rational_numbers /\ b :e rational_numbers /\
    c :e rational_numbers /\ d :e rational_numbers /\
    r = setprod (open_interval a b) (open_interval c d).
  { exact H4. }
  (** conjunction is left-associative: ((((aQ /\ bQ) /\ cQ) /\ dQ) /\ eq) **)
  claim Hleft : (((a :e rational_numbers /\ b :e rational_numbers) /\ c :e rational_numbers) /\ d :e rational_numbers)
                /\ r = setprod (open_interval a b) (open_interval c d).
  { exact Hcore. }
  claim Hfour : ((a :e rational_numbers /\ b :e rational_numbers) /\ c :e rational_numbers) /\ d :e rational_numbers.
  { exact (andEL (((a :e rational_numbers /\ b :e rational_numbers) /\ c :e rational_numbers) /\ d :e rational_numbers)
                 (r = setprod (open_interval a b) (open_interval c d))
                 Hleft). }
  claim Hreq : r = setprod (open_interval a b) (open_interval c d).
  { exact (andER (((a :e rational_numbers /\ b :e rational_numbers) /\ c :e rational_numbers) /\ d :e rational_numbers)
                 (r = setprod (open_interval a b) (open_interval c d))
                 Hleft). }
  claim Hthree : (a :e rational_numbers /\ b :e rational_numbers) /\ c :e rational_numbers.
  { exact (andEL ((a :e rational_numbers /\ b :e rational_numbers) /\ c :e rational_numbers)
                 (d :e rational_numbers)
                 Hfour). }
  claim HdQ : d :e rational_numbers.
  { exact (andER ((a :e rational_numbers /\ b :e rational_numbers) /\ c :e rational_numbers)
                 (d :e rational_numbers)
                 Hfour). }
  claim Hab : a :e rational_numbers /\ b :e rational_numbers.
  { exact (andEL (a :e rational_numbers /\ b :e rational_numbers)
                 (c :e rational_numbers)
                 Hthree). }
  claim HcQ : c :e rational_numbers.
  { exact (andER (a :e rational_numbers /\ b :e rational_numbers)
                 (c :e rational_numbers)
                 Hthree). }
  claim HaQ : a :e rational_numbers.
  { exact (andEL (a :e rational_numbers) (b :e rational_numbers) Hab). }
  claim HbQ : b :e rational_numbers.
  { exact (andER (a :e rational_numbers) (b :e rational_numbers) Hab). }
  claim HUinBx: open_interval a b :e rational_open_intervals_basis.
  { exact (open_interval_in_rational_open_intervals_basis a b HaQ HbQ). }
  claim HVinBy: open_interval c d :e rational_open_intervals_basis.
  { exact (open_interval_in_rational_open_intervals_basis c d HcQ HdQ). }
  claim HRepl: setprod (open_interval a b) (open_interval c d)
    :e {setprod (open_interval a b) V | V :e rational_open_intervals_basis}.
  { exact (ReplI rational_open_intervals_basis
                 (fun V:set => setprod (open_interval a b) V)
                 (open_interval c d)
                 HVinBy). }
  rewrite Hreq.
  exact (famunionI rational_open_intervals_basis
                   (fun U:set => {setprod U V | V :e rational_open_intervals_basis})
                   (open_interval a b)
                   (setprod (open_interval a b) (open_interval c d))
                   HUinBx
                   HRepl).
- let r. assume Hr: r :e product_basis_from rational_open_intervals_basis rational_open_intervals_basis.
  prove r :e rational_rectangle_basis.
  claim HexU: exists U :e rational_open_intervals_basis,
    r :e {setprod U V | V :e rational_open_intervals_basis}.
  { exact (famunionE rational_open_intervals_basis
           (fun U:set => {setprod U V | V :e rational_open_intervals_basis})
           r
           Hr). }
  apply HexU.
  let U. assume HUcore.
  claim HU: U :e rational_open_intervals_basis.
  { exact (andEL (U :e rational_open_intervals_basis)
                 (r :e {setprod U V | V :e rational_open_intervals_basis})
                 HUcore). }
  claim HrRepl: r :e {setprod U V | V :e rational_open_intervals_basis}.
  { exact (andER (U :e rational_open_intervals_basis)
                 (r :e {setprod U V | V :e rational_open_intervals_basis})
                 HUcore). }
  claim HexV: exists V :e rational_open_intervals_basis, r = setprod U V.
  { exact (ReplE rational_open_intervals_basis (fun V0:set => setprod U V0) r HrRepl). }
  apply HexV.
  let V. assume HVcore.
	  claim HV: V :e rational_open_intervals_basis.
	  { exact (andEL (V :e rational_open_intervals_basis) (r = setprod U V) HVcore). }
	  claim Hreq: r = setprod U V.
	  { exact (andER (V :e rational_open_intervals_basis) (r = setprod U V) HVcore). }
	  claim HexUab: exists a, exists b, (a :e rational_numbers /\ b :e rational_numbers /\ U = open_interval a b).
	  { exact (rational_open_intervals_basisE U HU). }
	  claim HexVcd: exists c, exists d, (c :e rational_numbers /\ d :e rational_numbers /\ V = open_interval c d).
	  { exact (rational_open_intervals_basisE V HV). }
	  apply HexUab.
	  let a. assume Ha2.
	  apply Ha2.
	  let b. assume Hab.
	  apply HexVcd.
	  let c. assume Hc2.
	  apply Hc2.
	  let d. assume Hcd.
	  claim HabLeft: a :e rational_numbers /\ b :e rational_numbers.
	  { exact (andEL (a :e rational_numbers /\ b :e rational_numbers)
	                 (U = open_interval a b)
	                 Hab). }
	  claim HUeq: U = open_interval a b.
	  { exact (andER (a :e rational_numbers /\ b :e rational_numbers)
	                 (U = open_interval a b)
	                 Hab). }
	  claim HaQ: a :e rational_numbers.
	  { exact (andEL (a :e rational_numbers) (b :e rational_numbers) HabLeft). }
	  claim HbQ: b :e rational_numbers.
	  { exact (andER (a :e rational_numbers) (b :e rational_numbers) HabLeft). }
	  claim HcdLeft: c :e rational_numbers /\ d :e rational_numbers.
	  { exact (andEL (c :e rational_numbers /\ d :e rational_numbers)
	                 (V = open_interval c d)
	                 Hcd). }
	  claim HVeql: V = open_interval c d.
	  { exact (andER (c :e rational_numbers /\ d :e rational_numbers)
	                 (V = open_interval c d)
	                 Hcd). }
	  claim HcQ: c :e rational_numbers.
	  { exact (andEL (c :e rational_numbers) (d :e rational_numbers) HcdLeft). }
	  claim HdQ: d :e rational_numbers.
	  { exact (andER (c :e rational_numbers) (d :e rational_numbers) HcdLeft). }
	  claim HUsubR: U c= R.
	  { rewrite HUeq.
	    exact (open_interval_Subq_R a b). }
  claim HVsubR: V c= R.
  { rewrite HVeql.
    exact (open_interval_Subq_R c d). }
  claim HrectSubRR: setprod U V c= setprod R R.
  { exact (setprod_Subq U V R R HUsubR HVsubR). }
  claim HrectPow: setprod U V :e Power (setprod R R).
  { exact (PowerI (setprod R R) (setprod U V) HrectSubRR). }
	  claim HexDef: exists a0 b0 c0 d0:set,
	    a0 :e rational_numbers /\ b0 :e rational_numbers /\
	    c0 :e rational_numbers /\ d0 :e rational_numbers /\
	    setprod U V = setprod (open_interval a0 b0) (open_interval c0 d0).
	  { witness a. witness b. witness c. witness d.
	    apply andI.
	    - apply andI.
	      + apply andI.
	        * apply andI.
	          { exact HaQ. }
	          { exact HbQ. }
	        * exact HcQ.
	      + exact HdQ.
	    - rewrite HUeq. rewrite HVeql. reflexivity. }
	  rewrite Hreq.
	  exact (SepI (Power (setprod R R))
	              (fun r0:set => exists a0 b0 c0 d0:set,
	                a0 :e rational_numbers /\ b0 :e rational_numbers /\
                c0 :e rational_numbers /\ d0 :e rational_numbers /\
                r0 = setprod (open_interval a0 b0) (open_interval c0 d0))
              (setprod U V)
              HrectPow
              HexDef).
Qed.

Theorem ex16_6_rational_rectangles_basis :
  basis_on (setprod R R) rational_rectangle_basis /\
  generated_topology (setprod R R) rational_rectangle_basis = R2_standard_topology.
set B := rational_open_intervals_basis.
claim HBpkg: basis_on R B /\ generated_topology R B = R_standard_topology.
{ exact ex13_8a_rational_intervals_basis_standard. }
claim HBbasis: basis_on R B.
{ exact (andEL (basis_on R B) (generated_topology R B = R_standard_topology) HBpkg). }
claim HBeq: generated_topology R B = R_standard_topology.
{ exact (andER (basis_on R B) (generated_topology R B = R_standard_topology) HBpkg). }
apply andI.
- rewrite rational_rectangle_basis_eq_product_basis_from.
  exact (product_basis_from_is_basis_on R R B B R_standard_topology R_standard_topology
         HBbasis HBeq HBbasis HBeq).
- (** reduce to product-basis theorem using equality of bases **)
  rewrite rational_rectangle_basis_eq_product_basis_from.
  rewrite R2_standard_equals_product.
  exact (product_basis_generates_product_topology R R B B R_standard_topology R_standard_topology
         HBbasis HBeq HBbasis HBeq).
Qed.

(** from 16 Exercise 7: convex subset implies interval or ray? **) 
(** LATEX VERSION: Exercise 7: Let X be an ordered set. If Y is a proper subset of X that is convex in X, does it follow that Y is an interval or a ray in X. **)
Definition closed_interval_in : set -> set -> set -> set := fun X a b =>
  {x :e X | (x = a \/ order_rel X a x) /\ (x = b \/ order_rel X x b)}.

Definition halfopen_interval_left_in : set -> set -> set -> set := fun X a b =>
  {x :e X | (x = a \/ order_rel X a x) /\ order_rel X x b}.

Definition halfopen_interval_right_in : set -> set -> set -> set := fun X a b =>
  {x :e X | order_rel X a x /\ (x = b \/ order_rel X x b)}.

Definition closed_ray_upper : set -> set -> set := fun X a =>
  {x :e X | x = a \/ order_rel X a x}.

Definition closed_ray_lower : set -> set -> set := fun X a =>
  {x :e X | x = a \/ order_rel X x a}.

Definition interval_in : set -> set -> set -> set -> prop := fun X a b Y =>
  Y = order_interval X a b
  \/ Y = halfopen_interval_left_in X a b
  \/ Y = halfopen_interval_right_in X a b
  \/ Y = closed_interval_in X a b.

Definition ray_in : set -> set -> set -> prop := fun X a Y =>
  Y = open_ray_upper X a
  \/ Y = closed_ray_upper X a
  \/ Y = open_ray_lower X a
  \/ Y = closed_ray_lower X a.

Definition interval_or_ray_in : set -> set -> prop := fun X Y =>
  (exists a b:set, a :e X /\ b :e X /\ interval_in X a b Y)
  \/ (exists a:set, a :e X /\ ray_in X a Y).

(** Counterexample pattern inside Q: points with q^2 < 2 form a convex set with no endpoint in Q. **)
Definition Q_sqrt2_cut : set := {q :e rational_numbers | mul_SNo q q < 2}.

(** helper for 16 Exercise 7: 2 is a rational number **)
(** LATEX VERSION: The number 2 is rational (2 = 2/1). **)
Theorem two_in_rational_numbers : 2 :e rational_numbers.
prove 2 :e rational.
claim H2omega: 2 :e omega.
{ exact (nat_p_omega 2 nat_2). }
claim H2SNoS: 2 :e SNoS_ omega.
{ exact (omega_SNoS_omega 2 H2omega). }
claim H2real: 2 :e real.
{ exact (SNoS_omega_real 2 H2SNoS). }
claim H2int: 2 :e int.
{ exact (Subq_omega_int 2 H2omega). }
claim H1omega: 1 :e omega.
{ exact (nat_p_omega 1 nat_1). }
claim H1not0: 1 /:e {0}.
{ assume H1: 1 :e {0}.
  prove False.
  claim Heq: 1 = 0.
  { exact (SingE 0 1 H1). }
  exact (neq_1_0 Heq). }
claim H1nonzero: 1 :e omega :\: {0}.
{ exact (setminusI omega {0} 1 H1omega H1not0). }
claim Hrecip1: recip_SNo 1 = 1.
{ claim H1neq0: 1 <> 0.
  { exact neq_1_0. }
  claim Hinv: mul_SNo 1 (recip_SNo 1) = 1.
  { exact (recip_SNo_invR 1 SNo_1 H1neq0). }
  rewrite <- (mul_SNo_oneL (recip_SNo 1) (SNo_recip_SNo 1 SNo_1)) at 1.
  exact Hinv. }
claim Heq2: 2 = div_SNo 2 1.
{ claim Hdivdef: div_SNo 2 1 = mul_SNo 2 (recip_SNo 1).
  { reflexivity. }
  rewrite Hdivdef.
  rewrite Hrecip1.
  rewrite (mul_SNo_oneR 2 SNo_2).
  reflexivity. }
claim Hex: exists m :e int, exists n :e omega :\: {0}, 2 = div_SNo m n.
{ witness 2.
  apply andI.
  - exact H2int.
  - witness 1.
    apply andI.
    + exact H1nonzero.
    + exact Heq2. }
exact (SepI real (fun x:set => exists m :e int, exists n :e omega :\: {0}, x = div_SNo m n) 2 H2real Hex).
Qed.

(** helper for 16 Exercise 7: 2 is not in the sqrt(2)-cut **)
(** LATEX VERSION: Since 2^2 is not < 2, we have 2  {qQ | q^2 < 2}. **)
Theorem two_not_in_Q_sqrt2_cut : 2 /:e Q_sqrt2_cut.
assume H2: 2 :e Q_sqrt2_cut.
prove False.
claim H2Q: 2 :e rational_numbers.
{ exact (SepE1 rational_numbers (fun q:set => mul_SNo q q < 2) 2 H2). }
claim Hlt: mul_SNo 2 2 < 2.
{ exact (SepE2 rational_numbers (fun q:set => mul_SNo q q < 2) 2 H2). }
claim Hpos2: 0 < 2.
{ exact SNoLt_0_2. }
claim H12: 1 < 2.
{ exact SNoLt_1_2. }
claim H1mul: mul_SNo 1 2 < mul_SNo 2 2.
{ exact (pos_mul_SNo_Lt' 1 2 2 SNo_1 SNo_2 SNo_2 Hpos2 H12). }
claim H2lt22: 2 < mul_SNo 2 2.
{ rewrite <- (mul_SNo_oneL 2 SNo_2) at 1.
  exact H1mul. }
claim H2lt2: 2 < 2.
{ exact (SNoLt_tra 2 (mul_SNo 2 2) 2 SNo_2 (SNo_mul_SNo 2 2 SNo_2 SNo_2) SNo_2 H2lt22 Hlt). }
exact ((SNoLt_irref 2) H2lt2).
Qed.

(** helper for 16 Exercise 7: minus two is not in the sqrt(2)-cut **)
(** LATEX VERSION: Since (-2)^2 is not < 2, we have -2  {qQ | q^2 < 2}. **)
Theorem minus_two_not_in_Q_sqrt2_cut : minus_SNo 2 /:e Q_sqrt2_cut.
assume Hm2: minus_SNo 2 :e Q_sqrt2_cut.
prove False.
claim Hm2lt: mul_SNo (minus_SNo 2) (minus_SNo 2) < 2.
{ exact (SepE2 rational_numbers (fun q:set => mul_SNo q q < 2) (minus_SNo 2) Hm2). }
claim H22lt: mul_SNo 2 2 < 2.
{ prove mul_SNo 2 2 < 2.
  rewrite <- (mul_SNo_minus_minus 2 2 SNo_2 SNo_2) at 1.
  exact Hm2lt. }
claim H2Q: 2 :e rational_numbers.
{ exact two_in_rational_numbers. }
claim H2cut: 2 :e Q_sqrt2_cut.
{ exact (SepI rational_numbers (fun q:set => mul_SNo q q < 2) 2 H2Q H22lt). }
exact (two_not_in_Q_sqrt2_cut H2cut).
Qed.

(** helper for 16 Exercise 7: Q_sqrt2_cut is a proper subset of Q **)
(** LATEX VERSION: The sqrt(2)-cut is not all of Q (for instance 2 is not in it). **)
Theorem Q_sqrt2_cut_neq_Q : Q_sqrt2_cut <> rational_numbers.
assume Heq: Q_sqrt2_cut = rational_numbers.
prove False.
claim H2inQ: 2 :e rational_numbers.
{ exact two_in_rational_numbers. }
claim H2inCut: 2 :e Q_sqrt2_cut.
{ rewrite Heq.
  exact H2inQ. }
exact (two_not_in_Q_sqrt2_cut H2inCut).
Qed.

(** helper for 16 Exercise 7: cut subset property **)
(** LATEX VERSION: The set {qQ | q^2<2} is a subset of Q. **)
Theorem Q_sqrt2_cut_sub_Q : Q_sqrt2_cut c= rational_numbers.
let q. assume Hq: q :e Q_sqrt2_cut.
prove q :e rational_numbers.
exact (SepE1 rational_numbers (fun q0:set => mul_SNo q0 q0 < 2) q Hq).
Qed.

(** helper for 16 Exercise 7: 0 is in the cut **)
(** LATEX VERSION: Since 0^2<2, we have 0  {qQ | q^2<2}. **)
Theorem zero_in_Q_sqrt2_cut : 0 :e Q_sqrt2_cut.
prove 0 :e Q_sqrt2_cut.
claim H0Q: 0 :e rational_numbers.
{ exact zero_in_rational_numbers. }
claim H00: mul_SNo 0 0 = 0.
{ exact (mul_SNo_zeroL 0 SNo_0). }
claim Hlt: mul_SNo 0 0 < 2.
{ rewrite H00.
  exact SNoLt_0_2. }
exact (SepI rational_numbers (fun q:set => mul_SNo q q < 2) 0 H0Q Hlt).
Qed.

(** helper for 16 Exercise 7: convexity of the sqrt(2) cut in Q **)
(** LATEX VERSION: The set {qQ | q^2<2} is convex in Q. **)
(** helper: if x lies strictly between two cut points, then x is in the cut **)
Theorem Q_sqrt2_cut_between_square : forall a b x:set,
  a :e Q_sqrt2_cut ->
  b :e Q_sqrt2_cut ->
  x :e rational_numbers ->
  Rlt a x ->
  Rlt x b ->
  mul_SNo x x < 2.
let a b x.
assume Ha: a :e Q_sqrt2_cut.
assume Hb: b :e Q_sqrt2_cut.
assume HxQ: x :e rational_numbers.
assume Hax: Rlt a x.
assume Hxb: Rlt x b.
claim HaQ: a :e rational_numbers.
{ exact (SepE1 rational_numbers (fun q:set => mul_SNo q q < 2) a Ha). }
claim HbQ: b :e rational_numbers.
{ exact (SepE1 rational_numbers (fun q:set => mul_SNo q q < 2) b Hb). }
claim Haa: mul_SNo a a < 2.
{ exact (SepE2 rational_numbers (fun q:set => mul_SNo q q < 2) a Ha). }
claim Hbb: mul_SNo b b < 2.
{ exact (SepE2 rational_numbers (fun q:set => mul_SNo q q < 2) b Hb). }
claim HaR: a :e R.
{ exact (rational_numbers_in_R a HaQ). }
claim HbR: b :e R.
{ exact (rational_numbers_in_R b HbQ). }
claim HxR: x :e R.
{ exact (rational_numbers_in_R x HxQ). }
claim HaS: SNo a.
{ exact (real_SNo a HaR). }
claim HbS: SNo b.
{ exact (real_SNo b HbR). }
claim HxS: SNo x.
{ exact (real_SNo x HxR). }
claim Haxlt: a < x.
{ exact (RltE_lt a x Hax). }
claim Hxblt: x < b.
{ exact (RltE_lt x b Hxb). }
(** split on the position of x relative to 0 using trichotomy **)
apply (SNoLt_trichotomy_or_impred x 0 HxS SNo_0 (mul_SNo x x < 2)).
- assume Hxlt0: x < 0.
  claim Halt0: a < 0.
  { exact (SNoLt_tra a x 0 HaS HxS SNo_0 Haxlt Hxlt0). }
  claim HnegxS: SNo (minus_SNo x).
  { exact (SNo_minus_SNo x HxS). }
  claim HnegaS: SNo (minus_SNo a).
  { exact (SNo_minus_SNo a HaS). }
  claim Hnegxltnega: minus_SNo x < minus_SNo a.
  { exact (minus_SNo_Lt_contra a x HaS HxS Haxlt). }
  claim H0ltnegx: 0 < minus_SNo x.
  { claim Hm0: minus_SNo 0 < minus_SNo x.
    { exact (minus_SNo_Lt_contra x 0 HxS SNo_0 Hxlt0). }
    rewrite <- (minus_SNo_0) at 1.
    exact Hm0. }
  claim H0ltnega: 0 < minus_SNo a.
  { claim Hm0: minus_SNo 0 < minus_SNo a.
    { exact (minus_SNo_Lt_contra a 0 HaS SNo_0 Halt0). }
    rewrite <- (minus_SNo_0) at 1.
    exact Hm0. }
  claim Hsq: mul_SNo (minus_SNo x) (minus_SNo x) < mul_SNo (minus_SNo a) (minus_SNo a).
  { exact (pos_mul_SNo_Lt2 (minus_SNo x) (minus_SNo x) (minus_SNo a) (minus_SNo a)
            HnegxS HnegxS HnegaS HnegaS
            H0ltnegx H0ltnegx Hnegxltnega Hnegxltnega). }
  claim Hxxlt: mul_SNo x x < mul_SNo a a.
  { prove mul_SNo x x < mul_SNo a a.
    rewrite <- (mul_SNo_minus_minus x x HxS HxS) at 1.
    rewrite <- (mul_SNo_minus_minus a a HaS HaS) at 1.
    exact Hsq. }
  claim HxxS: SNo (mul_SNo x x).
  { exact (SNo_mul_SNo x x HxS HxS). }
  claim HaaS: SNo (mul_SNo a a).
  { exact (SNo_mul_SNo a a HaS HaS). }
  exact (SNoLt_tra (mul_SNo x x) (mul_SNo a a) 2 HxxS HaaS SNo_2 Hxxlt Haa).
- assume Hxeq0: x = 0.
  rewrite Hxeq0.
  rewrite (mul_SNo_zeroL 0 SNo_0).
  exact SNoLt_0_2.
- assume H0ltx: 0 < x.
  claim H0ltb: 0 < b.
  { exact (SNoLt_tra 0 x b SNo_0 HxS HbS H0ltx Hxblt). }
  claim Hsq: mul_SNo x x < mul_SNo b b.
  { exact (pos_mul_SNo_Lt2 x x b b HxS HxS HbS HbS H0ltx H0ltx Hxblt Hxblt). }
  claim HxxS: SNo (mul_SNo x x).
  { exact (SNo_mul_SNo x x HxS HxS). }
  claim HbbS: SNo (mul_SNo b b).
  { exact (SNo_mul_SNo b b HbS HbS). }
  exact (SNoLt_tra (mul_SNo x x) (mul_SNo b b) 2 HxxS HbbS SNo_2 Hsq Hbb).
Qed.

Theorem Q_sqrt2_cut_convex : convex_in rational_numbers Q_sqrt2_cut.
prove convex_in rational_numbers Q_sqrt2_cut.
(** convex_in X Y = Y c= X /\ interval-closure property **)
prove Q_sqrt2_cut c= rational_numbers /\
     forall a b:set, a :e Q_sqrt2_cut -> b :e Q_sqrt2_cut ->
       order_interval rational_numbers a b c= Q_sqrt2_cut.
apply andI.
- exact Q_sqrt2_cut_sub_Q.
- let a b.
  assume Ha: a :e Q_sqrt2_cut.
  assume Hb: b :e Q_sqrt2_cut.
  claim HaQ: a :e rational_numbers.
  { exact (SepE1 rational_numbers (fun q:set => mul_SNo q q < 2) a Ha). }
  claim HbQ: b :e rational_numbers.
  { exact (SepE1 rational_numbers (fun q:set => mul_SNo q q < 2) b Hb). }
  claim Haa: mul_SNo a a < 2.
  { exact (SepE2 rational_numbers (fun q:set => mul_SNo q q < 2) a Ha). }
  claim Hbb: mul_SNo b b < 2.
  { exact (SepE2 rational_numbers (fun q:set => mul_SNo q q < 2) b Hb). }
  prove order_interval rational_numbers a b c= Q_sqrt2_cut.
  let x. assume Hx: x :e order_interval rational_numbers a b.
  prove x :e Q_sqrt2_cut.
  claim HxQ: x :e rational_numbers.
  { exact (SepE1 rational_numbers
                 (fun x0:set => order_rel rational_numbers a x0 /\ order_rel rational_numbers x0 b)
                 x
                 Hx). }
  claim HxRel: order_rel rational_numbers a x /\ order_rel rational_numbers x b.
  { exact (SepE2 rational_numbers
                 (fun x0:set => order_rel rational_numbers a x0 /\ order_rel rational_numbers x0 b)
                 x
                 Hx). }
  claim Hax: order_rel rational_numbers a x.
  { exact (andEL (order_rel rational_numbers a x) (order_rel rational_numbers x b) HxRel). }
  claim Hxb: order_rel rational_numbers x b.
  { exact (andER (order_rel rational_numbers a x) (order_rel rational_numbers x b) HxRel). }
  claim Haxlt: Rlt a x.
  { exact (order_rel_Q_implies_Rlt a x Hax). }
  claim Hxblt: Rlt x b.
  { exact (order_rel_Q_implies_Rlt x b Hxb). }
  claim Hxx: mul_SNo x x < 2.
  { exact (Q_sqrt2_cut_between_square a b x Ha Hb HxQ Haxlt Hxblt). }
  exact (SepI rational_numbers (fun q:set => mul_SNo q q < 2) x HxQ Hxx).
Qed.

(** helper for 16 Exercise 7: the sqrt2 cut has no maximum element in Q **)
(** LATEX VERSION: The cut {qQ | q^2<2} has no endpoint in Q. **)
Theorem Q_sqrt2_cut_no_max : forall q:set,
  q :e Q_sqrt2_cut -> exists r:set, r :e Q_sqrt2_cut /\ Rlt q r.
let q. assume Hq: q :e Q_sqrt2_cut.
prove exists r:set, r :e Q_sqrt2_cut /\ Rlt q r.
claim HqQ: q :e rational_numbers.
{ exact (SepE1 rational_numbers (fun q0:set => mul_SNo q0 q0 < 2) q Hq). }
claim HqR: q :e R.
{ exact (rational_numbers_in_R q HqQ). }
claim HqS: SNo q.
{ exact (real_SNo q HqR). }
claim Hqq: mul_SNo q q < 2.
{ exact (SepE2 rational_numbers (fun q0:set => mul_SNo q0 q0 < 2) q Hq). }
(** split on q relative to 0 **)
apply (SNoLt_trichotomy_or_impred q 0 HqS SNo_0 (exists r:set, r :e Q_sqrt2_cut /\ Rlt q r)).
- assume Hqlt0: q < 0.
  witness 0.
  apply andI.
  + exact zero_in_Q_sqrt2_cut.
  + exact (RltI q 0 HqR real_0 Hqlt0).
- assume Hqeq0: q = 0.
  witness 1.
  apply andI.
  + (** 1 is in the cut **)
    claim H1Q: 1 :e rational_numbers.
    { exact one_in_rational_numbers. }
    claim H11: mul_SNo 1 1 < 2.
    { prove mul_SNo 1 1 < 2.
      rewrite (mul_SNo_oneL 1 SNo_1).
      exact SNoLt_1_2. }
    exact (SepI rational_numbers (fun q0:set => mul_SNo q0 q0 < 2) 1 H1Q H11).
  + (** q<1 **)
    claim H1R: 1 :e R.
    { exact (rational_numbers_in_R 1 one_in_rational_numbers). }
    rewrite Hqeq0.
    exact (RltI 0 1 real_0 H1R SNoLt_0_1).
- assume H0ltq: 0 < q.
  (** define sqrt(2) and use density of Q in R **)
  set s2 := sqrt_SNo_nonneg 2.
  claim Hs2Def: s2 = sqrt_SNo_nonneg 2.
  { reflexivity. }
  claim H2R: 2 :e R.
  { exact (rational_numbers_in_R 2 two_in_rational_numbers). }
  claim H0le2: 0 <= 2.
  { exact (SNoLtLe 0 2 SNoLt_0_2). }
  claim Hs2R: s2 :e R.
  { exact (sqrt_SNo_nonneg_real 2 H2R H0le2). }
  claim Hs2S: SNo s2.
  { exact (real_SNo s2 Hs2R). }
  claim Hs2nonneg: 0 <= s2.
  { exact (sqrt_SNo_nonneg_nonneg 2 SNo_2 H0le2). }
  claim Hs2sq: mul_SNo s2 s2 = 2.
  { prove mul_SNo s2 s2 = 2.
    rewrite Hs2Def at 1.
    rewrite Hs2Def at 2.
    exact (sqrt_SNo_nonneg_sqr 2 SNo_2 H0le2). }
  (** show q < s2 (otherwise q^2 >= 2 or q = sqrt(2) irrational) **)
  claim Hqlts2: q < s2.
  { apply (SNoLt_trichotomy_or_impred q s2 HqS Hs2S (q < s2)).
    - assume Hlt: q < s2.
      exact Hlt.
    - assume Heq: q = s2.
      apply FalseE.
      claim Hirr: s2 :e real :\: rational.
      { exact sqrt_2_irrational. }
      claim Hnotrat: s2 /:e rational.
      { exact (setminusE2 real rational s2 Hirr). }
      claim Hs2Q: s2 :e rational_numbers.
      { rewrite <- Heq. exact HqQ. }
      claim HdefQ: rational_numbers = rational.
      { reflexivity. }
      claim Hs2rat: s2 :e rational.
      { rewrite <- HdefQ. exact Hs2Q. }
      exact (Hnotrat Hs2rat).
    - assume Hs2ltq: s2 < q.
      apply FalseE.
      (** get 0 < s2 from 0 <= s2 and s2 <> 0 **)
      claim Hs2neq0: s2 <> 0.
      { assume Hs2eq0: s2 = 0.
        apply neq_2_0.
        rewrite <- Hs2sq.
        rewrite Hs2eq0.
        rewrite (mul_SNo_zeroL 0 SNo_0).
        reflexivity. }
      claim H0lts2: 0 < s2.
      { claim Hdisj: 0 < s2 \/ 0 = s2.
        { exact (SNoLeE 0 s2 SNo_0 Hs2S Hs2nonneg). }
        apply Hdisj.
        - assume Hlt0: 0 < s2.
          exact Hlt0.
	        - assume Heq0: 0 = s2.
	          apply FalseE.
	          claim Hs2eq0: s2 = 0.
	          { rewrite <- Heq0.
	            reflexivity. }
	          exact (Hs2neq0 Hs2eq0). }
      claim HqqS: SNo (mul_SNo q q).
      { exact (SNo_mul_SNo q q HqS HqS). }
      claim Hs2s2S: SNo (mul_SNo s2 s2).
      { exact (SNo_mul_SNo s2 s2 Hs2S Hs2S). }
      claim Hs2s2ltqq: mul_SNo s2 s2 < mul_SNo q q.
      { exact (pos_mul_SNo_Lt2 s2 s2 q q Hs2S Hs2S HqS HqS H0lts2 H0lts2 Hs2ltq Hs2ltq). }
      claim H2ltqq: 2 < mul_SNo q q.
      { rewrite <- Hs2sq at 1.
        exact Hs2s2ltqq. }
      claim H2lt2: 2 < 2.
      { exact (SNoLt_tra 2 (mul_SNo q q) 2 SNo_2 HqqS SNo_2 H2ltqq Hqq). }
      exact ((SNoLt_irref 2) H2lt2). }
  claim Hqs2: Rlt q s2.
  { exact (RltI q s2 HqR Hs2R Hqlts2). }
  apply (rational_dense_between_reals q s2 HqR Hs2R Hqs2).
  let r. assume Hrpair.
  apply Hrpair.
  assume HrQ: r :e rational_numbers.
  assume Hrlt: Rlt q r /\ Rlt r s2.
  claim Hqr: Rlt q r.
  { exact (andEL (Rlt q r) (Rlt r s2) Hrlt). }
  claim Hrs2: Rlt r s2.
  { exact (andER (Rlt q r) (Rlt r s2) Hrlt). }
  (** show r is in the cut using r<s2 and s2^2=2 **)
  claim HrR: r :e R.
  { exact (rational_numbers_in_R r HrQ). }
  claim HrS: SNo r.
  { exact (real_SNo r HrR). }
  claim Hqrrlt: q < r.
  { exact (RltE_lt q r Hqr). }
  claim Hrs2lt: r < s2.
  { exact (RltE_lt r s2 Hrs2). }
  claim H0ltr: 0 < r.
  { exact (SNoLt_tra 0 q r SNo_0 HqS HrS H0ltq Hqrrlt). }
  claim Hrrlt2: mul_SNo r r < 2.
  { prove mul_SNo r r < 2.
	    claim Hrrlts2: mul_SNo r r < mul_SNo s2 s2.
	    { exact (pos_mul_SNo_Lt2 r r s2 s2 HrS HrS Hs2S Hs2S H0ltr H0ltr Hrs2lt Hrs2lt). }
	    rewrite <- Hs2sq.
	    exact Hrrlts2. }
  claim HrCut: r :e Q_sqrt2_cut.
  { exact (SepI rational_numbers (fun q0:set => mul_SNo q0 q0 < 2) r HrQ Hrrlt2). }
  witness r.
  exact (andI (r :e Q_sqrt2_cut) (Rlt q r) HrCut Hqr).
Qed.

(** helper for 16 Exercise 7: the sqrt2 cut is closed under negation **)
(** LATEX VERSION: If q^2<2 then (-q)^2<2, so the cut is symmetric. **)
Theorem Q_sqrt2_cut_neg_closed : forall q:set,
  q :e Q_sqrt2_cut -> minus_SNo q :e Q_sqrt2_cut.
let q. assume Hq: q :e Q_sqrt2_cut.
prove minus_SNo q :e Q_sqrt2_cut.
claim HqQ: q :e rational_numbers.
{ exact (SepE1 rational_numbers (fun q0:set => mul_SNo q0 q0 < 2) q Hq). }
claim Hqq: mul_SNo q q < 2.
{ exact (SepE2 rational_numbers (fun q0:set => mul_SNo q0 q0 < 2) q Hq). }
claim HqR: q :e R.
{ exact (rational_numbers_in_R q HqQ). }
claim HqS: SNo q.
{ exact (real_SNo q HqR). }
claim HnegQ: minus_SNo q :e rational_numbers.
{ exact (rational_minus_SNo q HqQ). }
claim HnegR: minus_SNo q :e R.
{ exact (rational_numbers_in_R (minus_SNo q) HnegQ). }
claim HnegS: SNo (minus_SNo q).
{ exact (real_SNo (minus_SNo q) HnegR). }
claim Hnegneg: mul_SNo (minus_SNo q) (minus_SNo q) < 2.
{ prove mul_SNo (minus_SNo q) (minus_SNo q) < 2.
  rewrite (mul_SNo_minus_minus q q HqS HqS).
  exact Hqq. }
exact (SepI rational_numbers (fun q0:set => mul_SNo q0 q0 < 2) (minus_SNo q) HnegQ Hnegneg).
Qed.

(** helper for 16 Exercise 7: the sqrt2 cut has no minimum element in Q **)
(** LATEX VERSION: The cut {qQ | q^2<2} has no endpoint in Q. **)
Theorem Q_sqrt2_cut_no_min : forall q:set,
  q :e Q_sqrt2_cut -> exists r:set, r :e Q_sqrt2_cut /\ Rlt r q.
let q. assume Hq: q :e Q_sqrt2_cut.
prove exists r:set, r :e Q_sqrt2_cut /\ Rlt r q.
claim HnegqCut: minus_SNo q :e Q_sqrt2_cut.
{ exact (Q_sqrt2_cut_neg_closed q Hq). }
apply (Q_sqrt2_cut_no_max (minus_SNo q) HnegqCut).
let r. assume Hrconj.
claim HrCut: r :e Q_sqrt2_cut.
{ exact (andEL (r :e Q_sqrt2_cut) (Rlt (minus_SNo q) r) Hrconj). }
claim Hlt: Rlt (minus_SNo q) r.
{ exact (andER (r :e Q_sqrt2_cut) (Rlt (minus_SNo q) r) Hrconj). }
set s := minus_SNo r.
claim HsCut: s :e Q_sqrt2_cut.
{ exact (Q_sqrt2_cut_neg_closed r HrCut). }
claim HrQ: r :e rational_numbers.
{ exact (SepE1 rational_numbers (fun q0:set => mul_SNo q0 q0 < 2) r HrCut). }
claim HqQ: q :e rational_numbers.
{ exact (SepE1 rational_numbers (fun q0:set => mul_SNo q0 q0 < 2) q Hq). }
claim HrR: r :e R.
{ exact (rational_numbers_in_R r HrQ). }
claim HqR: q :e R.
{ exact (rational_numbers_in_R q HqQ). }
claim HrS: SNo r.
{ exact (real_SNo r HrR). }
claim HnegqR: minus_SNo q :e R.
{ exact (rational_numbers_in_R (minus_SNo q) (SepE1 rational_numbers (fun q0:set => mul_SNo q0 q0 < 2) (minus_SNo q) HnegqCut)). }
claim HnegqS: SNo (minus_SNo q).
{ exact (real_SNo (minus_SNo q) HnegqR). }
claim HltS: minus_SNo q < r.
{ exact (RltE_lt (minus_SNo q) r Hlt). }
claim Hneglt: minus_SNo r < minus_SNo (minus_SNo q).
{ exact (minus_SNo_Lt_contra (minus_SNo q) r HnegqS HrS HltS). }
claim Hslt: s < q.
{ claim Hinv: minus_SNo (minus_SNo q) = q.
  { exact (minus_SNo_invol q (real_SNo q HqR)). }
  rewrite <- Hinv.
  exact Hneglt. }
claim HsR: s :e R.
{ exact (rational_numbers_in_R s (SepE1 rational_numbers (fun q0:set => mul_SNo q0 q0 < 2) s HsCut)). }
claim Hsq: Rlt s q.
{ exact (RltI s q HsR HqR Hslt). }
witness s.
exact (andI (s :e Q_sqrt2_cut) (Rlt s q) HsCut Hsq).
Qed.

(** helper for 16 Exercise 7: the sqrt(2) cut in Q is not an interval or ray (endpoints must lie in Q) **)
(** LATEX VERSION: {qQ | q^2<2} is not an interval or ray in Q since it has no endpoint in Q. **)
Theorem Q_sqrt2_cut_not_interval_or_ray :
  ~ interval_or_ray_in rational_numbers Q_sqrt2_cut.
assume H: interval_or_ray_in rational_numbers Q_sqrt2_cut.
prove False.
(** interval_or_ray_in X Y = (exists a b, interval_in ...) \/ (exists a, ray_in ...) **)
apply H.
- assume Hinterval: exists a b:set, a :e rational_numbers /\ b :e rational_numbers /\ interval_in rational_numbers a b Q_sqrt2_cut.
  apply Hinterval.
  let a. assume Hexb.
  apply Hexb.
  let b. assume Hab.
  claim HabQ: a :e rational_numbers /\ b :e rational_numbers.
  { exact (andEL (a :e rational_numbers /\ b :e rational_numbers) (interval_in rational_numbers a b Q_sqrt2_cut) Hab). }
  claim HaQ: a :e rational_numbers.
  { exact (andEL (a :e rational_numbers) (b :e rational_numbers) HabQ). }
  claim HbQ: b :e rational_numbers.
  { exact (andER (a :e rational_numbers) (b :e rational_numbers) HabQ). }
  claim Hint: interval_in rational_numbers a b Q_sqrt2_cut.
  { exact (andER (a :e rational_numbers /\ b :e rational_numbers) (interval_in rational_numbers a b Q_sqrt2_cut) Hab). }
  claim H0cut: 0 :e Q_sqrt2_cut.
  { exact zero_in_Q_sqrt2_cut. }
  apply Hint.
  - assume Hleft3: Q_sqrt2_cut = order_interval rational_numbers a b
                \/ Q_sqrt2_cut = halfopen_interval_left_in rational_numbers a b
                \/ Q_sqrt2_cut = halfopen_interval_right_in rational_numbers a b.
    apply Hleft3.
    + assume Hleft2: Q_sqrt2_cut = order_interval rational_numbers a b
                  \/ Q_sqrt2_cut = halfopen_interval_left_in rational_numbers a b.
      apply Hleft2.
      * assume HeqOI: Q_sqrt2_cut = order_interval rational_numbers a b.
        (** use sqrt(2) to refute existence of rational endpoints a<b with {qQ|q^2<2} = (a,b) **)
        claim H0in: 0 :e order_interval rational_numbers a b.
        { rewrite <- HeqOI. exact H0cut. }
        claim H0pred: order_rel rational_numbers a 0 /\ order_rel rational_numbers 0 b.
        { exact (SepE2 rational_numbers
                       (fun x0:set => order_rel rational_numbers a x0 /\ order_rel rational_numbers x0 b)
                       0
                       H0in). }
        claim Ha0: order_rel rational_numbers a 0.
        { exact (andEL (order_rel rational_numbers a 0) (order_rel rational_numbers 0 b) H0pred). }
        claim H0b: order_rel rational_numbers 0 b.
        { exact (andER (order_rel rational_numbers a 0) (order_rel rational_numbers 0 b) H0pred). }
        claim HaR: a :e R.
        { exact (rational_numbers_in_R a HaQ). }
        claim HbR: b :e R.
        { exact (rational_numbers_in_R b HbQ). }
        claim HaS: SNo a.
        { exact (real_SNo a HaR). }
        claim HbS: SNo b.
        { exact (real_SNo b HbR). }
        claim Halt0: Rlt a 0.
        { exact (order_rel_Q_implies_Rlt a 0 Ha0). }
        claim H0blt: Rlt 0 b.
        { exact (order_rel_Q_implies_Rlt 0 b H0b). }
        set s2 := sqrt_SNo_nonneg 2.
        claim H2R: 2 :e R.
        { exact (rational_numbers_in_R 2 two_in_rational_numbers). }
        claim H0le2: 0 <= 2.
        { exact (SNoLtLe 0 2 SNoLt_0_2). }
        claim Hs2R: s2 :e R.
        { exact (sqrt_SNo_nonneg_real 2 H2R H0le2). }
        claim Hs2S: SNo s2.
        { exact (real_SNo s2 Hs2R). }
        claim Hs2nonneg: 0 <= s2.
        { exact (sqrt_SNo_nonneg_nonneg 2 SNo_2 H0le2). }
        claim Hs2sq: mul_SNo s2 s2 = 2.
        { exact (sqrt_SNo_nonneg_sqr 2 SNo_2 H0le2). }
        claim Hs2neq0: s2 <> 0.
        { assume Hs2eq0: s2 = 0.
          apply neq_2_0.
          rewrite <- Hs2sq.
          rewrite Hs2eq0.
          rewrite (mul_SNo_zeroL 0 SNo_0).
          reflexivity. }
        claim H0lts2: 0 < s2.
        { claim Hdisj: 0 < s2 \/ 0 = s2.
          { exact (SNoLeE 0 s2 SNo_0 Hs2S Hs2nonneg). }
          apply Hdisj.
          - assume Hlt0: 0 < s2.
            exact Hlt0.
          - assume Heq0: 0 = s2.
            apply FalseE.
            claim Hs2eq0: s2 = 0.
            { rewrite <- Heq0. reflexivity. }
            exact (Hs2neq0 Hs2eq0). }
        (** compare b to sqrt(2) **)
        apply (SNoLt_trichotomy_or_impred b s2 HbS Hs2S False).
        - assume Hblts2: b < s2.
          claim Hbs2: Rlt b s2.
          { exact (RltI b s2 HbR Hs2R Hblts2). }
          (** choose q with b<q<s2, then q is in the interval so should be in the cut, but q<b from interval membership **)
          apply (rational_dense_between_reals b s2 HbR Hs2R Hbs2).
          let q. assume Hqpair. apply Hqpair.
          assume HqQ: q :e rational_numbers.
          assume HqProp: Rlt b q /\ Rlt q s2.
          claim Hbq: Rlt b q.
          { exact (andEL (Rlt b q) (Rlt q s2) HqProp). }
          claim Hqs2: Rlt q s2.
          { exact (andER (Rlt b q) (Rlt q s2) HqProp). }
          claim HqR: q :e R.
          { exact (rational_numbers_in_R q HqQ). }
          claim HqS: SNo q.
          { exact (real_SNo q HqR). }
          claim H0q: Rlt 0 q.
          { exact (Rlt_tra 0 b q H0blt Hbq). }
          claim H0ltq: 0 < q.
          { exact (RltE_lt 0 q H0q). }
          claim Hqlts2: q < s2.
          { exact (RltE_lt q s2 Hqs2). }
          claim Hqqlt2: mul_SNo q q < 2.
          { claim Hqqs2: mul_SNo q q < mul_SNo s2 s2.
            { exact (pos_mul_SNo_Lt2 q q s2 s2 HqS HqS Hs2S Hs2S H0ltq H0ltq Hqlts2 Hqlts2). }
            rewrite <- Hs2sq.
            exact Hqqs2. }
          claim HqCut: q :e Q_sqrt2_cut.
          { exact (SepI rational_numbers (fun q0:set => mul_SNo q0 q0 < 2) q HqQ Hqqlt2). }
          claim HqInI: q :e order_interval rational_numbers a b.
          { rewrite <- HeqOI. exact HqCut. }
          claim HqPred: order_rel rational_numbers a q /\ order_rel rational_numbers q b.
          { exact (SepE2 rational_numbers
                         (fun x0:set => order_rel rational_numbers a x0 /\ order_rel rational_numbers x0 b)
                         q
                         HqInI). }
          claim Hqb: order_rel rational_numbers q b.
          { exact (andER (order_rel rational_numbers a q) (order_rel rational_numbers q b) HqPred). }
          claim Hqblt: Rlt q b.
          { exact (order_rel_Q_implies_Rlt q b Hqb). }
          exact ((not_Rlt_sym b q Hbq) Hqblt).
        - assume Hbeq: b = s2.
          (** b is rational, so sqrt(2) would be rational, contradiction **)
          claim Hirr: s2 :e real :\: rational.
          { exact sqrt_2_irrational. }
          claim Hnotrat: s2 /:e rational.
          { exact (setminusE2 real rational s2 Hirr). }
          claim Hs2Q: s2 :e rational_numbers.
          { rewrite <- Hbeq. exact HbQ. }
          claim HdefQ: rational_numbers = rational.
          { reflexivity. }
          claim Hs2rat: s2 :e rational.
          { rewrite <- HdefQ. exact Hs2Q. }
          exact (Hnotrat Hs2rat).
        - assume Hs2ltb: s2 < b.
          claim Hs2b: Rlt s2 b.
          { exact (RltI s2 b Hs2R HbR Hs2ltb). }
          (** choose q with s2<q<b; q is in the interval so must be in the cut, but then q^2<2 contradicts s2<q **)
          apply (rational_dense_between_reals s2 b Hs2R HbR Hs2b).
          let q. assume Hqpair. apply Hqpair.
          assume HqQ: q :e rational_numbers.
          assume HqProp: Rlt s2 q /\ Rlt q b.
          claim Hs2q: Rlt s2 q.
          { exact (andEL (Rlt s2 q) (Rlt q b) HqProp). }
          claim Hqb: Rlt q b.
          { exact (andER (Rlt s2 q) (Rlt q b) HqProp). }
          claim HqR: q :e R.
          { exact (rational_numbers_in_R q HqQ). }
          claim HqS: SNo q.
          { exact (real_SNo q HqR). }
          claim Hs2ltq: s2 < q.
          { exact (RltE_lt s2 q Hs2q). }
          claim H0ltq: 0 < q.
          { exact (SNoLt_tra 0 s2 q SNo_0 Hs2S HqS H0lts2 Hs2ltq). }
          claim Haq: Rlt a q.
          { claim H0q: Rlt 0 q.
            { exact (RltI 0 q real_0 HqR H0ltq). }
            exact (Rlt_tra a 0 q Halt0 H0q). }
          claim Haqrel: order_rel rational_numbers a q.
          { exact (Rlt_implies_order_rel_Q a q Haq). }
          claim Hqbrep: order_rel rational_numbers q b.
          { exact (Rlt_implies_order_rel_Q q b Hqb). }
          claim HqInI: q :e order_interval rational_numbers a b.
          { exact (SepI rational_numbers
                         (fun x0:set => order_rel rational_numbers a x0 /\ order_rel rational_numbers x0 b)
                         q
                         HqQ
                         (andI (order_rel rational_numbers a q) (order_rel rational_numbers q b) Haqrel Hqbrep)). }
          claim HqCut: q :e Q_sqrt2_cut.
          { rewrite HeqOI. exact HqInI. }
          claim Hqqlt2: mul_SNo q q < 2.
          { exact (SepE2 rational_numbers (fun q0:set => mul_SNo q0 q0 < 2) q HqCut). }
          claim Hs2s2ltqq: mul_SNo s2 s2 < mul_SNo q q.
          { exact (pos_mul_SNo_Lt2 s2 s2 q q Hs2S Hs2S HqS HqS H0lts2 H0lts2 Hs2ltq Hs2ltq). }
          claim H2ltqq: 2 < mul_SNo q q.
          { rewrite <- Hs2sq at 1.
            exact Hs2s2ltqq. }
          claim HqqS: SNo (mul_SNo q q).
          { exact (SNo_mul_SNo q q HqS HqS). }
          claim H2lt2: 2 < 2.
          { exact (SNoLt_tra 2 (mul_SNo q q) 2 SNo_2 HqqS SNo_2 H2ltqq Hqqlt2). }
          exact ((SNoLt_irref 2) H2lt2).
      * assume HeqHL: Q_sqrt2_cut = halfopen_interval_left_in rational_numbers a b.
        (** derive order_rel a b from 0 in the interval **)
        claim H0in: 0 :e halfopen_interval_left_in rational_numbers a b.
        { rewrite <- HeqHL. exact H0cut. }
        claim H0pred: (0 = a \/ order_rel rational_numbers a 0) /\ order_rel rational_numbers 0 b.
        { exact (SepE2 rational_numbers (fun x0:set => (x0 = a \/ order_rel rational_numbers a x0) /\ order_rel rational_numbers x0 b) 0 H0in). }
        claim H0ab: 0 = a \/ order_rel rational_numbers a 0.
        { exact (andEL (0 = a \/ order_rel rational_numbers a 0) (order_rel rational_numbers 0 b) H0pred). }
        claim H0b: order_rel rational_numbers 0 b.
        { exact (andER (0 = a \/ order_rel rational_numbers a 0) (order_rel rational_numbers 0 b) H0pred). }
        claim Hab: order_rel rational_numbers a b.
        { apply H0ab.
          - assume H0eq: 0 = a.
            rewrite <- H0eq.
            exact H0b.
          - assume Ha0: order_rel rational_numbers a 0.
            claim Halt0: Rlt a 0.
            { exact (order_rel_Q_implies_Rlt a 0 Ha0). }
            claim H0blt: Rlt 0 b.
            { exact (order_rel_Q_implies_Rlt 0 b H0b). }
            claim Hablt: Rlt a b.
            { exact (Rlt_tra a 0 b Halt0 H0blt). }
            exact (Rlt_implies_order_rel_Q a b Hablt). }
        (** show a is in the cut, then contradict no-minimum by pulling r<a back into the interval **)
        claim HainI: a :e halfopen_interval_left_in rational_numbers a b.
        { claim Heqaa: a = a.
          { reflexivity. }
          claim Hleft: a = a \/ order_rel rational_numbers a a.
          { exact (orIL (a = a) (order_rel rational_numbers a a) Heqaa). }
          exact (SepI rational_numbers
                     (fun x0:set => (x0 = a \/ order_rel rational_numbers a x0) /\ order_rel rational_numbers x0 b)
                     a
                     HaQ
                     (andI (a = a \/ order_rel rational_numbers a a)
                           (order_rel rational_numbers a b)
                           Hleft
                           Hab)). }
        claim HainCut: a :e Q_sqrt2_cut.
        { rewrite HeqHL. exact HainI. }
        apply (Q_sqrt2_cut_no_min a HainCut).
        let r. assume Hrconj.
        claim HrCut: r :e Q_sqrt2_cut.
        { exact (andEL (r :e Q_sqrt2_cut) (Rlt r a) Hrconj). }
        claim Hrlt: Rlt r a.
        { exact (andER (r :e Q_sqrt2_cut) (Rlt r a) Hrconj). }
        claim HrInI: r :e halfopen_interval_left_in rational_numbers a b.
        { rewrite <- HeqHL. exact HrCut. }
        claim HrPred: (r = a \/ order_rel rational_numbers a r) /\ order_rel rational_numbers r b.
        { exact (SepE2 rational_numbers
                     (fun x0:set => (x0 = a \/ order_rel rational_numbers a x0) /\ order_rel rational_numbers x0 b)
                     r
                     HrInI). }
        claim HrLeft: r = a \/ order_rel rational_numbers a r.
        { exact (andEL (r = a \/ order_rel rational_numbers a r) (order_rel rational_numbers r b) HrPred). }
        apply HrLeft.
	        - assume Hreq: r = a.
	          apply (not_Rlt_refl a (rational_numbers_in_R a HaQ)).
	          rewrite <- Hreq at 1.
	          exact Hrlt.
        - assume Hrel: order_rel rational_numbers a r.
          claim Halt: Rlt a r.
          { exact (order_rel_Q_implies_Rlt a r Hrel). }
          exact ((not_Rlt_sym r a Hrlt) Halt).
    + assume HeqHR: Q_sqrt2_cut = halfopen_interval_right_in rational_numbers a b.
      (** derive order_rel a b from 0 in the interval **)
      claim H0in: 0 :e halfopen_interval_right_in rational_numbers a b.
      { rewrite <- HeqHR. exact H0cut. }
      claim H0pred: order_rel rational_numbers a 0 /\ (0 = b \/ order_rel rational_numbers 0 b).
      { exact (SepE2 rational_numbers (fun x0:set => order_rel rational_numbers a x0 /\ (x0 = b \/ order_rel rational_numbers x0 b)) 0 H0in). }
      claim Ha0: order_rel rational_numbers a 0.
      { exact (andEL (order_rel rational_numbers a 0) (0 = b \/ order_rel rational_numbers 0 b) H0pred). }
      claim H0b: 0 = b \/ order_rel rational_numbers 0 b.
      { exact (andER (order_rel rational_numbers a 0) (0 = b \/ order_rel rational_numbers 0 b) H0pred). }
      claim Hab: order_rel rational_numbers a b.
      { apply H0b.
        - assume H0eq: 0 = b.
          rewrite <- H0eq.
          exact Ha0.
        - assume Hrel: order_rel rational_numbers 0 b.
          claim Halt0: Rlt a 0.
          { exact (order_rel_Q_implies_Rlt a 0 Ha0). }
          claim H0blt: Rlt 0 b.
          { exact (order_rel_Q_implies_Rlt 0 b Hrel). }
          claim Hablt: Rlt a b.
          { exact (Rlt_tra a 0 b Halt0 H0blt). }
          exact (Rlt_implies_order_rel_Q a b Hablt). }
      (** show b is in the cut, then contradict no-maximum by pushing r>b back into the interval **)
      claim HbinI: b :e halfopen_interval_right_in rational_numbers a b.
      { claim Heqbb: b = b.
        { reflexivity. }
        claim Hright: b = b \/ order_rel rational_numbers b b.
        { exact (orIL (b = b) (order_rel rational_numbers b b) Heqbb). }
        exact (SepI rational_numbers
                   (fun x0:set => order_rel rational_numbers a x0 /\ (x0 = b \/ order_rel rational_numbers x0 b))
                   b
                   HbQ
                   (andI (order_rel rational_numbers a b)
                         (b = b \/ order_rel rational_numbers b b)
                         Hab
                         Hright)). }
      claim HbinCut: b :e Q_sqrt2_cut.
      { rewrite HeqHR. exact HbinI. }
      apply (Q_sqrt2_cut_no_max b HbinCut).
      let r. assume Hrconj.
      claim HrCut: r :e Q_sqrt2_cut.
      { exact (andEL (r :e Q_sqrt2_cut) (Rlt b r) Hrconj). }
      claim HbR: Rlt b r.
      { exact (andER (r :e Q_sqrt2_cut) (Rlt b r) Hrconj). }
      claim HrInI: r :e halfopen_interval_right_in rational_numbers a b.
      { rewrite <- HeqHR. exact HrCut. }
      claim HrPred: order_rel rational_numbers a r /\ (r = b \/ order_rel rational_numbers r b).
      { exact (SepE2 rational_numbers (fun x0:set => order_rel rational_numbers a x0 /\ (x0 = b \/ order_rel rational_numbers x0 b)) r HrInI). }
      claim HrRight: r = b \/ order_rel rational_numbers r b.
      { exact (andER (order_rel rational_numbers a r) (r = b \/ order_rel rational_numbers r b) HrPred). }
      apply HrRight.
      - assume Hreq: r = b.
        apply (not_Rlt_refl b (rational_numbers_in_R b HbQ)).
        rewrite <- Hreq at 2.
        exact HbR.
      - assume Hrel: order_rel rational_numbers r b.
        claim Hrltb: Rlt r b.
        { exact (order_rel_Q_implies_Rlt r b Hrel). }
        exact ((not_Rlt_sym b r HbR) Hrltb).
	  - assume HeqCI: Q_sqrt2_cut = closed_interval_in rational_numbers a b.
	    (** derive (b=a \/ a<b) from 0 in the interval **)
	    claim H0in: 0 :e closed_interval_in rational_numbers a b.
	    { rewrite <- HeqCI. exact H0cut. }
	    claim H0pred: (0 = a \/ order_rel rational_numbers a 0) /\ (0 = b \/ order_rel rational_numbers 0 b).
	    { exact (SepE2 rational_numbers
	                   (fun x0:set => (x0 = a \/ order_rel rational_numbers a x0) /\ (x0 = b \/ order_rel rational_numbers x0 b))
	                   0
	                   H0in). }
	    claim H0a: 0 = a \/ order_rel rational_numbers a 0.
	    { exact (andEL (0 = a \/ order_rel rational_numbers a 0) (0 = b \/ order_rel rational_numbers 0 b) H0pred). }
	    claim H0b: 0 = b \/ order_rel rational_numbers 0 b.
	    { exact (andER (0 = a \/ order_rel rational_numbers a 0) (0 = b \/ order_rel rational_numbers 0 b) H0pred). }
	    claim Habdisj: b = a \/ order_rel rational_numbers a b.
	    { apply H0a.
	      - assume H0eq: 0 = a.
	        apply H0b.
	        + assume H0eqb: 0 = b.
	          claim Hab: b = a.
	          { rewrite <- H0eq.
	            rewrite <- H0eqb.
	            reflexivity. }
	          exact (orIL (b = a) (order_rel rational_numbers a b) Hab).
	        + assume H0rel: order_rel rational_numbers 0 b.
	          claim H0blt: Rlt 0 b.
	          { exact (order_rel_Q_implies_Rlt 0 b H0rel). }
	          claim Hablt: Rlt a b.
	          { rewrite <- H0eq. exact H0blt. }
	          claim Hab: order_rel rational_numbers a b.
	          { exact (Rlt_implies_order_rel_Q a b Hablt). }
	          exact (orIR (b = a) (order_rel rational_numbers a b) Hab).
	      - assume Ha0: order_rel rational_numbers a 0.
	        claim Halt0: Rlt a 0.
	        { exact (order_rel_Q_implies_Rlt a 0 Ha0). }
	        apply H0b.
	        + assume H0eqb: 0 = b.
	          claim Hablt: Rlt a b.
	          { rewrite <- H0eqb. exact Halt0. }
	          claim Hab: order_rel rational_numbers a b.
	          { exact (Rlt_implies_order_rel_Q a b Hablt). }
	          exact (orIR (b = a) (order_rel rational_numbers a b) Hab).
	        + assume H0rel: order_rel rational_numbers 0 b.
	          claim H0blt: Rlt 0 b.
	          { exact (order_rel_Q_implies_Rlt 0 b H0rel). }
	          claim Hablt: Rlt a b.
	          { exact (Rlt_tra a 0 b Halt0 H0blt). }
	          claim Hab: order_rel rational_numbers a b.
	          { exact (Rlt_implies_order_rel_Q a b Hablt). }
	          exact (orIR (b = a) (order_rel rational_numbers a b) Hab). }
	    (** show b is in the cut, then contradict no-maximum by pushing r>b back into the interval **)
	    claim HbinI: b :e closed_interval_in rational_numbers a b.
	    { claim Heqbb: b = b.
	      { reflexivity. }
	      claim Hright: b = b \/ order_rel rational_numbers b b.
	      { exact (orIL (b = b) (order_rel rational_numbers b b) Heqbb). }
	      exact (SepI rational_numbers
	                 (fun x0:set => (x0 = a \/ order_rel rational_numbers a x0) /\ (x0 = b \/ order_rel rational_numbers x0 b))
	                 b
	                 HbQ
	                 (andI (b = a \/ order_rel rational_numbers a b)
	                       (b = b \/ order_rel rational_numbers b b)
	                       Habdisj
	                       Hright)). }
	    claim HbinCut: b :e Q_sqrt2_cut.
	    { rewrite HeqCI. exact HbinI. }
	    apply (Q_sqrt2_cut_no_max b HbinCut).
	    let r. assume Hrconj.
	    claim HrCut: r :e Q_sqrt2_cut.
	    { exact (andEL (r :e Q_sqrt2_cut) (Rlt b r) Hrconj). }
	    claim HbR: Rlt b r.
	    { exact (andER (r :e Q_sqrt2_cut) (Rlt b r) Hrconj). }
	    claim HrInI: r :e closed_interval_in rational_numbers a b.
	    { rewrite <- HeqCI. exact HrCut. }
	    claim HrPred: (r = a \/ order_rel rational_numbers a r) /\ (r = b \/ order_rel rational_numbers r b).
	    { exact (SepE2 rational_numbers
	                   (fun x0:set => (x0 = a \/ order_rel rational_numbers a x0) /\ (x0 = b \/ order_rel rational_numbers x0 b))
	                   r
	                   HrInI). }
	    claim HrRight: r = b \/ order_rel rational_numbers r b.
	    { exact (andER (r = a \/ order_rel rational_numbers a r) (r = b \/ order_rel rational_numbers r b) HrPred). }
	    apply HrRight.
	    - assume Hreq: r = b.
	      apply (not_Rlt_refl b (rational_numbers_in_R b HbQ)).
	      rewrite <- Hreq at 2.
	      exact HbR.
	    - assume Hrel: order_rel rational_numbers r b.
	      claim Hrltb: Rlt r b.
	      { exact (order_rel_Q_implies_Rlt r b Hrel). }
	      exact ((not_Rlt_sym b r HbR) Hrltb).
- assume Hray: exists a:set, a :e rational_numbers /\ ray_in rational_numbers a Q_sqrt2_cut.
  apply Hray.
  let a. assume Hpair.
  claim HaQ: a :e rational_numbers.
  { exact (andEL (a :e rational_numbers) (ray_in rational_numbers a Q_sqrt2_cut) Hpair). }
  claim Hrayin: ray_in rational_numbers a Q_sqrt2_cut.
  { exact (andER (a :e rational_numbers) (ray_in rational_numbers a Q_sqrt2_cut) Hpair). }
  claim H0cut: 0 :e Q_sqrt2_cut.
  { exact zero_in_Q_sqrt2_cut. }
  claim H2Q: 2 :e rational_numbers.
  { exact two_in_rational_numbers. }
  claim Hm2Q: minus_SNo 2 :e rational_numbers.
  { exact (rational_minus_SNo 2 H2Q). }
  claim Hm2lt0: minus_SNo 2 < 0.
  { prove minus_SNo 2 < 0.
    rewrite <- (minus_SNo_0) at 2.
    exact (minus_SNo_Lt_contra 0 2 SNo_0 SNo_2 SNoLt_0_2). }
  (** eliminate the four ray forms using 0 in the cut and +-2 outside the cut **)
  apply Hrayin.
  - assume Hleft: Q_sqrt2_cut = open_ray_upper rational_numbers a
                \/ Q_sqrt2_cut = closed_ray_upper rational_numbers a
                \/ Q_sqrt2_cut = open_ray_lower rational_numbers a.
    apply Hleft.
    + assume Hup: Q_sqrt2_cut = open_ray_upper rational_numbers a
                \/ Q_sqrt2_cut = closed_ray_upper rational_numbers a.
      apply Hup.
      * assume HeqU: Q_sqrt2_cut = open_ray_upper rational_numbers a.
        claim H0in: 0 :e open_ray_upper rational_numbers a.
        { rewrite <- HeqU. exact H0cut. }
        claim Hrel: order_rel rational_numbers a 0.
        { exact (SepE2 rational_numbers (fun x0:set => order_rel rational_numbers a x0) 0 H0in). }
        claim Ha0: Rlt a 0.
        { exact (order_rel_Q_implies_Rlt a 0 Hrel). }
        claim H02: Rlt 0 2.
        { exact (RltI 0 2 real_0 (rational_numbers_in_R 2 H2Q) SNoLt_0_2). }
        claim Ha2: Rlt a 2.
        { exact (Rlt_tra a 0 2 Ha0 H02). }
        claim Hrel2: order_rel rational_numbers a 2.
        { exact (Rlt_implies_order_rel_Q a 2 Ha2). }
        claim H2in: 2 :e open_ray_upper rational_numbers a.
        { exact (SepI rational_numbers (fun x0:set => order_rel rational_numbers a x0) 2 H2Q Hrel2). }
        claim H2cut: 2 :e Q_sqrt2_cut.
        { rewrite HeqU. exact H2in. }
        exact (two_not_in_Q_sqrt2_cut H2cut).
      * assume HeqU: Q_sqrt2_cut = closed_ray_upper rational_numbers a.
        claim H0in: 0 :e closed_ray_upper rational_numbers a.
        { rewrite <- HeqU. exact H0cut. }
        claim Hrel0: 0 = a \/ order_rel rational_numbers a 0.
        { exact (SepE2 rational_numbers (fun x0:set => x0 = a \/ order_rel rational_numbers a x0) 0 H0in). }
        apply Hrel0.
        - assume H0eq: 0 = a.
           claim H02: Rlt 0 2.
           { exact (RltI 0 2 real_0 (rational_numbers_in_R 2 H2Q) SNoLt_0_2). }
           claim Ha2: Rlt a 2.
           { rewrite <- H0eq. exact H02. }
           claim Hrel2: order_rel rational_numbers a 2.
           { exact (Rlt_implies_order_rel_Q a 2 Ha2). }
           claim H2in: 2 :e closed_ray_upper rational_numbers a.
           { exact (SepI rational_numbers (fun x0:set => x0 = a \/ order_rel rational_numbers a x0) 2 H2Q (orIR (2 = a) (order_rel rational_numbers a 2) Hrel2)). }
           claim H2cut: 2 :e Q_sqrt2_cut.
           { rewrite HeqU. exact H2in. }
           exact (two_not_in_Q_sqrt2_cut H2cut).
        - assume Hrel: order_rel rational_numbers a 0.
           claim Ha0: Rlt a 0.
           { exact (order_rel_Q_implies_Rlt a 0 Hrel). }
           claim H02: Rlt 0 2.
           { exact (RltI 0 2 real_0 (rational_numbers_in_R 2 H2Q) SNoLt_0_2). }
           claim Ha2: Rlt a 2.
           { exact (Rlt_tra a 0 2 Ha0 H02). }
           claim Hrel2: order_rel rational_numbers a 2.
           { exact (Rlt_implies_order_rel_Q a 2 Ha2). }
           claim H2in: 2 :e closed_ray_upper rational_numbers a.
           { exact (SepI rational_numbers (fun x0:set => x0 = a \/ order_rel rational_numbers a x0) 2 H2Q (orIR (2 = a) (order_rel rational_numbers a 2) Hrel2)). }
           claim H2cut: 2 :e Q_sqrt2_cut.
           { rewrite HeqU. exact H2in. }
           exact (two_not_in_Q_sqrt2_cut H2cut).
    + assume HeqL: Q_sqrt2_cut = open_ray_lower rational_numbers a.
      claim H0in: 0 :e open_ray_lower rational_numbers a.
      { rewrite <- HeqL. exact H0cut. }
      claim Hrel0: order_rel rational_numbers 0 a.
      { exact (SepE2 rational_numbers (fun x0:set => order_rel rational_numbers x0 a) 0 H0in). }
      claim H0a: Rlt 0 a.
      { exact (order_rel_Q_implies_Rlt 0 a Hrel0). }
      claim Hm20: Rlt (minus_SNo 2) 0.
      { exact (RltI (minus_SNo 2) 0 (rational_numbers_in_R (minus_SNo 2) Hm2Q) real_0 Hm2lt0). }
      claim Hm2a: Rlt (minus_SNo 2) a.
      { exact (Rlt_tra (minus_SNo 2) 0 a Hm20 H0a). }
      claim Hrelm2: order_rel rational_numbers (minus_SNo 2) a.
      { exact (Rlt_implies_order_rel_Q (minus_SNo 2) a Hm2a). }
      claim Hm2in: minus_SNo 2 :e open_ray_lower rational_numbers a.
      { exact (SepI rational_numbers (fun x0:set => order_rel rational_numbers x0 a) (minus_SNo 2) Hm2Q Hrelm2). }
      claim Hm2cut: minus_SNo 2 :e Q_sqrt2_cut.
      { rewrite HeqL. exact Hm2in. }
      exact (minus_two_not_in_Q_sqrt2_cut Hm2cut).
  - assume HeqL: Q_sqrt2_cut = closed_ray_lower rational_numbers a.
    claim H0in: 0 :e closed_ray_lower rational_numbers a.
    { rewrite <- HeqL. exact H0cut. }
    claim Hrel0: 0 = a \/ order_rel rational_numbers 0 a.
    { exact (SepE2 rational_numbers (fun x0:set => x0 = a \/ order_rel rational_numbers x0 a) 0 H0in). }
    apply Hrel0.
    + assume H0eq: 0 = a.
      claim Hm20: Rlt (minus_SNo 2) 0.
      { exact (RltI (minus_SNo 2) 0 (rational_numbers_in_R (minus_SNo 2) Hm2Q) real_0 Hm2lt0). }
      claim Hm2a: Rlt (minus_SNo 2) a.
      { rewrite <- H0eq. exact Hm20. }
      claim Hrelm2: order_rel rational_numbers (minus_SNo 2) a.
      { exact (Rlt_implies_order_rel_Q (minus_SNo 2) a Hm2a). }
      claim Hm2in: minus_SNo 2 :e closed_ray_lower rational_numbers a.
      { exact (SepI rational_numbers (fun x0:set => x0 = a \/ order_rel rational_numbers x0 a) (minus_SNo 2) Hm2Q
                (orIR ((minus_SNo 2) = a) (order_rel rational_numbers (minus_SNo 2) a) Hrelm2)). }
      claim Hm2cut: minus_SNo 2 :e Q_sqrt2_cut.
      { rewrite HeqL. exact Hm2in. }
      exact (minus_two_not_in_Q_sqrt2_cut Hm2cut).
    + assume Hrel: order_rel rational_numbers 0 a.
      claim H0a: Rlt 0 a.
      { exact (order_rel_Q_implies_Rlt 0 a Hrel). }
      claim Hm20: Rlt (minus_SNo 2) 0.
      { exact (RltI (minus_SNo 2) 0 (rational_numbers_in_R (minus_SNo 2) Hm2Q) real_0 Hm2lt0). }
      claim Hm2a: Rlt (minus_SNo 2) a.
      { exact (Rlt_tra (minus_SNo 2) 0 a Hm20 H0a). }
      claim Hrelm2: order_rel rational_numbers (minus_SNo 2) a.
      { exact (Rlt_implies_order_rel_Q (minus_SNo 2) a Hm2a). }
      claim Hm2in: minus_SNo 2 :e closed_ray_lower rational_numbers a.
      { exact (SepI rational_numbers (fun x0:set => x0 = a \/ order_rel rational_numbers x0 a) (minus_SNo 2) Hm2Q
                (orIR ((minus_SNo 2) = a) (order_rel rational_numbers (minus_SNo 2) a) Hrelm2)). }
      claim Hm2cut: minus_SNo 2 :e Q_sqrt2_cut.
      { rewrite HeqL. exact Hm2in. }
      exact (minus_two_not_in_Q_sqrt2_cut Hm2cut).
Qed.

Theorem ex16_7_convex_interval_or_ray :
  exists X Y:set, convex_in X Y /\ Y <> X /\ ~ interval_or_ray_in X Y.
prove exists X Y:set, convex_in X Y /\ Y <> X /\ ~ interval_or_ray_in X Y.
witness rational_numbers.
witness Q_sqrt2_cut.
prove convex_in rational_numbers Q_sqrt2_cut /\ Q_sqrt2_cut <> rational_numbers /\ ~ interval_or_ray_in rational_numbers Q_sqrt2_cut.
apply andI.
  - apply andI.
    + exact Q_sqrt2_cut_convex.
    + exact Q_sqrt2_cut_neq_Q.
  - exact Q_sqrt2_cut_not_interval_or_ray.
Qed.

(** from 16 Exercise 8: lines as subspaces of lower limit products **)
(** LATEX VERSION: Exercise 8: If L is a straight line in the plane, describe the topology L inherits as a subspace of R_lR and as a subspace of R_lR_l. In each case it is a familiar topology. **)
(** NOTE: Formal statement currently deferred to Theorem ex16_8_lines_in_lower_limit_products, placed after Definition homeomorphism. **)

(** from 16 Exercise 9: dictionary order topology on  equals _d   **) 
(** LATEX VERSION: Exercise 9: The dictionary order topology on  is the same as the product topology _d; compare it with the standard topology. **)
Theorem ex16_9_dictionary_equals_product :
  R2_dictionary_order_topology = product_topology R (discrete_topology R) R R_standard_topology
  /\ R2_dictionary_order_topology <> R2_standard_topology.
prove R2_dictionary_order_topology = product_topology R (discrete_topology R) R R_standard_topology /\ R2_dictionary_order_topology <> R2_standard_topology.
apply andI.
- claim Heq: R2_dictionary_order_topology = product_topology R (discrete_topology R) R R_standard_topology.
  { admit. }
  exact Heq.
- admit.
Qed.

(** from 16 Exercise 10: compare topologies on II **) 
(** LATEX VERSION: Exercise 10: Compare ordered square topology, dictionary subspace topology, and product topology on II. **)
Theorem ex16_10_compare_topologies_on_square :
  ordered_square_topology <> subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square /\
  subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square <>
    product_topology unit_interval unit_interval_topology unit_interval unit_interval_topology.
prove ordered_square_topology <> subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square /\ subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square <> product_topology unit_interval unit_interval_topology unit_interval unit_interval_topology.
apply andI.
- exact ordered_square_not_subspace_dictionary.
- (** show the dictionary-order subspace topology differs from the product topology **)
  set Tdic := subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square.
  set Tprod := product_topology unit_interval unit_interval_topology unit_interval unit_interval_topology.
  prove Tdic <> Tprod.
  assume Heq: Tdic = Tprod.
  set U := ordered_square_open_strip.
  claim HUdic: U :e Tdic.
  { (** U is open in the dictionary-order subspace topology by Example 3 **)
    prove U :e Tdic.
    (** show U is a subset of ordered_square, hence U is in Power ordered_square **)
    claim HUsub: U c= ordered_square.
    { let p. assume Hp: p :e U.
      exact (SepE1 ordered_square
                   (fun p0:set => exists y:set, p0 = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y))
                   p
                   Hp). }
    claim HUpow: U :e Power ordered_square.
    { exact (PowerI ordered_square U HUsub). }
    (** define an open interval V in the dictionary order on RR with Vordered_square = U **)
    set a := (eps_ 1, eps_ 1).
    set b := (eps_ 1, 2).
    set V := {p :e setprod R R |
                order_rel (setprod R R) a p /\ order_rel (setprod R R) p b}.
    claim HVTx: V :e R2_dictionary_order_topology.
    { prove V :e R2_dictionary_order_topology.
      (** unfold R2_dictionary_order_topology and order_topology **)
      claim HdefR2: R2_dictionary_order_topology = order_topology (setprod R R).
      { reflexivity. }
      rewrite HdefR2.
      claim HdefOT: order_topology (setprod R R) =
        generated_topology (setprod R R) (order_topology_basis (setprod R R)).
      { reflexivity. }
      rewrite HdefOT.
      claim HBasis: basis_on (setprod R R) (order_topology_basis (setprod R R)).
      { exact (order_topology_basis_is_basis (setprod R R)). }
      (** V is a basis element: an open interval (a,b) in the dictionary order **)
      claim HVinB: V :e order_topology_basis (setprod R R).
      { (** abbreviate the three families in the definition of order_topology_basis **)
        set X := setprod R R.
        set Fint := {I :e Power X | exists a0 :e X, exists b0 :e X,
                      I = {x :e X | order_rel X a0 x /\ order_rel X x b0}}.
        set Flow := {I :e Power X | exists b0 :e X, I = {x :e X | order_rel X x b0}}.
        set Fup  := {I :e Power X | exists a0 :e X, I = {x :e X | order_rel X a0 x}}.
        claim HbasisDef: order_topology_basis X = (Fint :\/: Flow :\/: Fup).
        { reflexivity. }
        rewrite HbasisDef.
        (** V belongs to Fint by construction **)
        claim HVsubX: V c= X.
        { let p. assume Hp: p :e V.
          exact (SepE1 X
                       (fun p0:set => order_rel X a p0 /\ order_rel X p0 b)
                       p
                       Hp). }
        claim HVpowX: V :e Power X.
        { exact (PowerI X V HVsubX). }
        (** show a and b are points of X **)
        claim H1omega: 1 :e omega.
        { exact (nat_p_omega 1 nat_1). }
        claim Heps1SNoS: eps_ 1 :e SNoS_ omega.
        { exact (SNo_eps_SNoS_omega 1 H1omega). }
	        claim Heps1R: eps_ 1 :e R.
	        { exact (SNoS_omega_real (eps_ 1) Heps1SNoS). }
	        claim H2R: 2 :e R.
	        { (** 2 is real, hence an element of R **)
	          claim H2real: 2 :e real.
	          { rewrite <- add_SNo_1_1_2.
	            exact (real_add_SNo 1 real_1 1 real_1). }
	          claim HdefR: R = real.
	          { reflexivity. }
	          rewrite HdefR.
	          exact H2real. }
	        claim HaX: a :e X.
	        { prove (eps_ 1, eps_ 1) :e setprod R R.
	          exact (tuple_2_setprod R R (eps_ 1) Heps1R (eps_ 1) Heps1R). }
        claim HbX: b :e X.
        { prove (eps_ 1, 2) :e setprod R R.
          exact (tuple_2_setprod R R (eps_ 1) Heps1R 2 H2R). }
        claim HVex: exists a0 :e X, exists b0 :e X,
          V = {x :e X | order_rel X a0 x /\ order_rel X x b0}.
        { witness a.
          prove a :e X /\ exists b0 :e X, V = {x :e X | order_rel X a x /\ order_rel X x b0}.
          apply andI.
          - exact HaX.
          - witness b.
            prove b :e X /\ V = {x :e X | order_rel X a x /\ order_rel X x b}.
            apply andI.
            + exact HbX.
            + reflexivity. }
        claim HVinF: V :e Fint.
        { exact (SepI (Power X)
                      (fun I0:set => exists a0 :e X, exists b0 :e X,
                                     I0 = {x :e X | order_rel X a0 x /\ order_rel X x b0})
                      V
                      HVpowX
                      HVex). }
        (** inject into the left-associated union (Fint :\/: Flow) :\/: Fup **)
        claim HVinLeft: V :e (Fint :\/: Flow).
        { exact (binunionI1 Fint Flow V HVinF). }
        exact (binunionI1 (Fint :\/: Flow) Fup V HVinLeft).
      }
      exact (generated_topology_contains_basis (setprod R R)
                                              (order_topology_basis (setprod R R))
                                              HBasis
                                              V
                                              HVinB).
    }
    claim HeqU: U = V :/\: ordered_square.
    { (** this is the key set identity from Example 3 **)
      apply set_ext.
      - let p. assume HpU: p :e U.
        prove p :e V :/\: ordered_square.
        claim HpSq: p :e ordered_square.
        { exact (SepE1 ordered_square
                     (fun p0:set => exists y:set, p0 = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y))
                     p
                     HpU). }
        claim Hexy: exists y:set, p = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y).
        { exact (SepE2 ordered_square
                     (fun p0:set => exists y:set, p0 = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y))
                     p
                     HpU). }
	        apply Hexy.
	        let y. assume Hyprop.
	        (** conjunction is left-associative: (A /\ B) /\ C **)
	        claim Hpair: (p = (eps_ 1,y) /\ Rlt (eps_ 1) y).
	        { exact (andEL (p = (eps_ 1,y) /\ Rlt (eps_ 1) y)
	                      (~(Rlt 1 y))
	                      Hyprop). }
	        claim Hyle1: ~(Rlt 1 y).
	        { exact (andER (p = (eps_ 1,y) /\ Rlt (eps_ 1) y)
	                      (~(Rlt 1 y))
	                      Hyprop). }
	        claim Hpy: p = (eps_ 1,y).
	        { exact (andEL (p = (eps_ 1,y))
	                      (Rlt (eps_ 1) y)
	                      Hpair). }
	        claim Hey: Rlt (eps_ 1) y.
	        { exact (andER (p = (eps_ 1,y))
	                      (Rlt (eps_ 1) y)
	                      Hpair). }
	        claim Heps1R: eps_ 1 :e R.
	        { exact (RltE_left (eps_ 1) y Hey). }
	        claim HyR: y :e R.
	        { exact (RltE_right (eps_ 1) y Hey). }
        (** build p :e V **)
        claim HpV: p :e V.
        { prove p :e V.
          claim HpRR: p :e setprod R R.
          { rewrite Hpy.
            exact (tuple_2_setprod R R (eps_ 1) Heps1R y HyR). }
	          claim Hord1: order_rel (setprod R R) a p.
	          { (** use the defining disjunction for order_rel and inject to the last case **)
	            prove (setprod R R = R /\ Rlt a p)
	              \/
	              (setprod R R = rational_numbers /\ Rlt a p)
	              \/
	              (setprod R R = omega /\ a :e p)
	              \/
	              (setprod R R = omega :\: {0} /\ a :e p)
	              \/
	              (setprod R R = setprod 2 omega /\
	               exists i m j n:set,
	                 i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
	                 a = (i, m) /\ p = (j, n) /\
	                 (i :e j \/ (i = j /\ m :e n)))
	              \/
	              (setprod R R = setprod R R /\
	               exists a1 a2 b1 b2:set,
	                 a = (a1, a2) /\ p = (b1, b2) /\
	                 (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))).
	            apply orIR.
	            prove (setprod R R = setprod R R /\
	                   exists a1 a2 b1 b2:set,
	                     a = (a1, a2) /\ p = (b1, b2) /\
	                     (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))).
	            apply andI.
	            - reflexivity.
	            - witness (eps_ 1).
              witness (eps_ 1).
              witness (eps_ 1).
              witness y.
              prove a = (eps_ 1, eps_ 1) /\ p = (eps_ 1, y) /\
                    (Rlt (eps_ 1) (eps_ 1) \/ ((eps_ 1) = (eps_ 1) /\ Rlt (eps_ 1) y)).
              apply andI.
              + apply andI.
                * reflexivity.
                * exact Hpy.
              + apply orIR.
                apply andI.
                * reflexivity.
                * exact Hey. }
	          claim Hord2: order_rel (setprod R R) p b.
	          { prove (setprod R R = R /\ Rlt p b)
	              \/
	              (setprod R R = rational_numbers /\ Rlt p b)
	              \/
	              (setprod R R = omega /\ p :e b)
	              \/
	              (setprod R R = omega :\: {0} /\ p :e b)
	              \/
	              (setprod R R = setprod 2 omega /\
	               exists i m j n:set,
	                 i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
	                 p = (i, m) /\ b = (j, n) /\
	                 (i :e j \/ (i = j /\ m :e n)))
	              \/
	              (setprod R R = setprod R R /\
	               exists a1 a2 b1 b2:set,
	                 p = (a1, a2) /\ b = (b1, b2) /\
	                 (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))).
	            apply orIR.
	            prove (setprod R R = setprod R R /\
	                   exists a1 a2 b1 b2:set,
	                     p = (a1, a2) /\ b = (b1, b2) /\
	                     (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))).
	            apply andI.
	            - reflexivity.
	            - (** derive Rlt y 2 from y <= 1 and 1 < 2 **)
              claim HdefR: R = real.
              { reflexivity. }
              claim H1R: 1 :e R.
              { rewrite HdefR. exact real_1. }
              claim H2R: 2 :e R.
              { claim H2real: 2 :e real.
                { rewrite <- add_SNo_1_1_2.
                  exact (real_add_SNo 1 real_1 1 real_1). }
                rewrite HdefR.
                exact H2real. }
	              claim H12: Rlt 1 2.
	              { exact (RltI 1 2 H1R H2R SNoLt_1_2). }
	              claim Hy2: Rlt y 2.
	              { (** derive y < 2 by trichotomy, using that ~(1 < y) **)
	                claim Hyreal: y :e real.
	                { rewrite <- HdefR.
	                  exact HyR. }
	                claim H2real: 2 :e real.
	                { rewrite <- HdefR.
	                  exact H2R. }
	                claim HyS: SNo y.
	                { exact (real_SNo y Hyreal). }
	                claim H2S: SNo 2.
	                { exact (real_SNo 2 H2real). }
	                apply (SNoLt_trichotomy_or_impred y 2 HyS H2S (Rlt y 2)).
	                - assume Hylt: y < 2.
	                  exact (RltI y 2 HyR H2R Hylt).
		                - assume Hyeq: y = 2.
		                  apply FalseE.
		                  claim H1y: Rlt 1 y.
		                  { rewrite Hyeq.
		                    exact H12. }
		                  exact (Hyle1 H1y).
	                - assume H2lty: 2 < y.
	                  apply FalseE.
	                  claim H2y: Rlt 2 y.
	                  { exact (RltI 2 y H2R HyR H2lty). }
	                  claim H1y: Rlt 1 y.
	                  { exact (Rlt_tra 1 2 y H12 H2y). }
	                  exact (Hyle1 H1y). }
              witness (eps_ 1).
              witness y.
              witness (eps_ 1).
              witness 2.
              prove p = (eps_ 1, y) /\ b = (eps_ 1, 2) /\
                    (Rlt (eps_ 1) (eps_ 1) \/ ((eps_ 1) = (eps_ 1) /\ Rlt y 2)).
              apply andI.
              + apply andI.
                * exact Hpy.
                * reflexivity.
              + apply orIR.
                apply andI.
                * reflexivity.
                * exact Hy2. }
          exact (SepI (setprod R R)
                      (fun p0:set => order_rel (setprod R R) a p0 /\ order_rel (setprod R R) p0 b)
                      p
                      HpRR
                      (andI (order_rel (setprod R R) a p)
                            (order_rel (setprod R R) p b)
                            Hord1
                            Hord2)). }
        exact (binintersectI V ordered_square p HpV HpSq).
      - let p. assume Hp: p :e V :/\: ordered_square.
        prove p :e U.
        (** reduce to the defining predicate for U in the Sep **)
        claim HpPair: p :e V /\ p :e ordered_square.
        { exact (binintersectE V ordered_square p Hp). }
	        claim HpSq: p :e ordered_square.
	        { exact (andER (p :e V) (p :e ordered_square) HpPair). }
	        claim Hexists: exists y:set, p = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y).
	        { (** extract a coordinate representation of p from HpSq **)
	          claim HsqDef: ordered_square = setprod unit_interval unit_interval.
	          { reflexivity. }
	          claim HpProd: p :e setprod unit_interval unit_interval.
	          { rewrite <- HsqDef.
	            exact HpSq. }
            claim HpV: p :e V.
            { exact (andEL (p :e V) (p :e ordered_square) HpPair). }
            claim Hpord: order_rel (setprod R R) a p /\ order_rel (setprod R R) p b.
            { exact (SepE2 (setprod R R)
                           (fun p0:set => order_rel (setprod R R) a p0 /\ order_rel (setprod R R) p0 b)
                           p
                           HpV). }
            claim Hord1: order_rel (setprod R R) a p.
            { exact (andEL (order_rel (setprod R R) a p)
                          (order_rel (setprod R R) p b)
                          Hpord). }
            claim Hord2: order_rel (setprod R R) p b.
            { exact (andER (order_rel (setprod R R) a p)
                          (order_rel (setprod R R) p b)
                          Hpord). }
            claim Hex_ap: exists a1 a2 b1 b2:set,
              a = (a1, a2) /\ p = (b1, b2) /\ (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)).
            { exact (order_rel_setprod_R_R_unfold a p Hord1). }
            claim Hex_pb: exists a1 a2 b1 b2:set,
              p = (a1, a2) /\ b = (b1, b2) /\ (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)).
            { exact (order_rel_setprod_R_R_unfold p b Hord2). }
	          set y := proj1 p.
	          claim HyU: y :e unit_interval.
	          { exact (proj1_Sigma unit_interval (fun _ : set => unit_interval) p HpProd). }
	          (** from y :e unit_interval, obtain ~(Rlt 1 y) **)
	          claim Hyprop: ~(Rlt 1 y).
	          { exact (andER (~(Rlt y 0)) (~(Rlt 1 y))
	                        (SepE2 R (fun t:set => ~(Rlt t 0) /\ ~(Rlt 1 t)) y HyU)). }
	          witness y.
	          (** the remaining identification of the first coordinate and the strict inequality are the key work **)
	          prove p = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y).
            claim Heps1R: (eps_ 1) :e R.
            { claim H1omega: 1 :e omega.
              { exact (nat_p_omega 1 nat_1). }
              claim Heps1SNoS: eps_ 1 :e SNoS_ omega.
              { exact (SNo_eps_SNoS_omega 1 H1omega). }
              exact (SNoS_omega_real (eps_ 1) Heps1SNoS). }
	            claim HpFirst: p = (eps_ 1, y) /\ Rlt (eps_ 1) y.
	            { apply Hex_ap.
	              let a1. assume Hex_a2.
	              apply Hex_a2.
	              let a2. assume Hex_b1.
	              apply Hex_b1.
	              let b1. assume Hex_b2.
	              apply Hex_b2.
	              let b2. assume Hap.
	              claim Hcore1: a = (a1, a2) /\ p = (b1, b2).
	              { exact (andEL (a = (a1, a2) /\ p = (b1, b2))
	                            (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))
	                            Hap). }
              claim HaEq: a = (a1, a2).
              { exact (andEL (a = (a1, a2)) (p = (b1, b2)) Hcore1). }
              claim HpEq: p = (b1, b2).
              { exact (andER (a = (a1, a2)) (p = (b1, b2)) Hcore1). }
              claim Hdisj1: Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2).
              { exact (andER (a = (a1, a2) /\ p = (b1, b2))
                            (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))
                            Hap). }
              (** normalize a1 and a2 using a = (eps_ 1, eps_ 1) **)
              claim HaDef: a = (eps_ 1, eps_ 1).
              { reflexivity. }
              claim Ha0: a 0 = eps_ 1.
              { rewrite HaDef.
                exact (tuple_2_0_eq (eps_ 1) (eps_ 1)). }
              claim Ha1: a 1 = eps_ 1.
              { rewrite HaDef.
                exact (tuple_2_1_eq (eps_ 1) (eps_ 1)). }
              claim Ha0': a 0 = a1.
              { rewrite HaEq.
                exact (tuple_2_0_eq a1 a2). }
	              claim Ha1': a 1 = a2.
	              { rewrite HaEq.
	                exact (tuple_2_1_eq a1 a2). }
	              claim Ha1eq: a1 = eps_ 1.
	              { prove a1 = eps_ 1.
	                rewrite <- Ha0'.
	                exact Ha0. }
	              claim Ha2eq: a2 = eps_ 1.
	              { prove a2 = eps_ 1.
	                rewrite <- Ha1'.
	                exact Ha1. }
	              claim Hdisj1': Rlt (eps_ 1) b1 \/ ((eps_ 1) = b1 /\ Rlt (eps_ 1) b2).
	              { apply (Hdisj1 (Rlt (eps_ 1) b1 \/ ((eps_ 1) = b1 /\ Rlt (eps_ 1) b2))).
	                - assume Hlt: Rlt a1 b1.
	                  apply orIL.
	                  prove Rlt (eps_ 1) b1.
	                  rewrite <- Ha1eq at 1.
	                  exact Hlt.
	                - assume Hc: a1 = b1 /\ Rlt a2 b2.
	                  claim Ha1b1: a1 = b1.
	                  { exact (andEL (a1 = b1) (Rlt a2 b2) Hc). }
	                  claim Ha2b2: Rlt a2 b2.
	                  { exact (andER (a1 = b1) (Rlt a2 b2) Hc). }
	                  claim Heq: (eps_ 1) = b1.
	                  { prove (eps_ 1) = b1.
	                    rewrite <- Ha1eq at 1.
	                    exact Ha1b1. }
	                  claim Hltb2: Rlt (eps_ 1) b2.
	                  { prove Rlt (eps_ 1) b2.
	                    rewrite <- Ha2eq at 1.
	                    exact Ha2b2. }
	                  apply orIR.
	                  exact (andI ((eps_ 1) = b1) (Rlt (eps_ 1) b2) Heq Hltb2). }
	              (** extract coordinate information for p<b **)
	              apply Hex_pb.
	              let c1. assume Hex_c2.
	              apply Hex_c2.
	              let c2. assume Hex_d1.
	              apply Hex_d1.
	              let d1. assume Hex_d2.
	              apply Hex_d2.
	              let d2. assume Hpb.
	              claim Hcore2: p = (c1, c2) /\ b = (d1, d2).
	              { exact (andEL (p = (c1, c2) /\ b = (d1, d2))
	                            (Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2))
	                            Hpb). }
              claim HpEq2: p = (c1, c2).
              { exact (andEL (p = (c1, c2)) (b = (d1, d2)) Hcore2). }
              claim HbEq: b = (d1, d2).
              { exact (andER (p = (c1, c2)) (b = (d1, d2)) Hcore2). }
              claim Hdisj2: Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2).
              { exact (andER (p = (c1, c2) /\ b = (d1, d2))
                            (Rlt c1 d1 \/ (c1 = d1 /\ Rlt c2 d2))
                            Hpb). }
              claim Hp0b1: p 0 = b1.
              { rewrite HpEq.
                exact (tuple_2_0_eq b1 b2). }
	              claim Hp0c1: p 0 = c1.
	              { rewrite HpEq2.
	                exact (tuple_2_0_eq c1 c2). }
	              claim Hc1eq: c1 = b1.
	              { prove c1 = b1.
	                rewrite <- Hp0c1 at 1.
	                exact Hp0b1. }
              claim Hp1b2: p 1 = b2.
              { rewrite HpEq.
                exact (tuple_2_1_eq b1 b2). }
	              claim Hp1c2: p 1 = c2.
	              { rewrite HpEq2.
	                exact (tuple_2_1_eq c1 c2). }
	              claim Hc2eq: c2 = b2.
	              { prove c2 = b2.
	                rewrite <- Hp1c2 at 1.
	                exact Hp1b2. }
              claim HbDef: b = (eps_ 1, 2).
              { reflexivity. }
              claim Hb0: b 0 = eps_ 1.
              { rewrite HbDef.
                exact (tuple_2_0_eq (eps_ 1) 2). }
              claim Hb1: b 1 = 2.
              { rewrite HbDef.
                exact (tuple_2_1_eq (eps_ 1) 2). }
              claim Hb0': b 0 = d1.
              { rewrite HbEq.
                exact (tuple_2_0_eq d1 d2). }
	              claim Hb1': b 1 = d2.
	              { rewrite HbEq.
	                exact (tuple_2_1_eq d1 d2). }
	              claim Hd1eq: d1 = eps_ 1.
	              { prove d1 = eps_ 1.
	                rewrite <- Hb0' at 1.
	                exact Hb0. }
	              claim Hd2eq: d2 = 2.
	              { prove d2 = 2.
	                rewrite <- Hb1' at 1.
	                exact Hb1. }
	              claim Hdisj2': Rlt b1 (eps_ 1) \/ (b1 = eps_ 1 /\ Rlt b2 2).
	              { apply (Hdisj2 (Rlt b1 (eps_ 1) \/ (b1 = eps_ 1 /\ Rlt b2 2))).
	                - assume Hlt: Rlt c1 d1.
		                  apply orIL.
		                  prove Rlt b1 (eps_ 1).
		                  rewrite <- Hc1eq at 1.
		                  rewrite <- Hd1eq.
		                  exact Hlt.
	                - assume Hc: c1 = d1 /\ Rlt c2 d2.
	                  claim Hc1d1: c1 = d1.
	                  { exact (andEL (c1 = d1) (Rlt c2 d2) Hc). }
	                  claim Hc2d2: Rlt c2 d2.
	                  { exact (andER (c1 = d1) (Rlt c2 d2) Hc). }
		                  claim Hb1eq: b1 = eps_ 1.
		                  { prove b1 = eps_ 1.
		                    rewrite <- Hc1eq at 1.
		                    rewrite <- Hd1eq.
		                    exact Hc1d1. }
		                  claim Hb2lt: Rlt b2 2.
		                  { prove Rlt b2 2.
		                    rewrite <- Hc2eq at 1.
		                    rewrite <- Hd2eq.
		                    exact Hc2d2. }
	                  apply orIR.
	                  exact (andI (b1 = eps_ 1) (Rlt b2 2) Hb1eq Hb2lt). }
	              (** compute y = b2 **)
	              claim HyP1: y = p 1.
	              { rewrite <- (proj1_ap_1 p).
	                reflexivity. }
	              claim HyEq: y = b2.
	              { prove y = b2.
	                rewrite HyP1.
	                exact Hp1b2. }
	              (** finish by eliminating the two-way disjunction for a<p **)
	              apply (Hdisj1' (p = (eps_ 1, y) /\ Rlt (eps_ 1) y)).
	              - assume Hlt: Rlt (eps_ 1) b1.
	                apply FalseE.
	                apply (Hdisj2' False).
	                - assume Hlt2: Rlt b1 (eps_ 1).
	                  exact ((not_Rlt_sym (eps_ 1) b1 Hlt) Hlt2).
	                - assume Hc: b1 = eps_ 1 /\ Rlt b2 2.
                  claim Hb1eq: b1 = eps_ 1.
                  { exact (andEL (b1 = eps_ 1) (Rlt b2 2) Hc). }
                  claim Hbad: Rlt (eps_ 1) (eps_ 1).
                  { rewrite <- Hb1eq at 2.
                    exact Hlt. }
                  exact ((not_Rlt_refl (eps_ 1) Heps1R) Hbad).
	              - assume Hc: (eps_ 1) = b1 /\ Rlt (eps_ 1) b2.
	                claim Heq: (eps_ 1) = b1.
	                { exact (andEL ((eps_ 1) = b1) (Rlt (eps_ 1) b2) Hc). }
	                claim Hltb2: Rlt (eps_ 1) b2.
	                { exact (andER ((eps_ 1) = b1) (Rlt (eps_ 1) b2) Hc). }
	                claim HpEq0: p = (eps_ 1, b2).
	                { prove p = (eps_ 1, b2).
	                  rewrite Heq.
	                  exact HpEq. }
	                claim HpEq1: p = (eps_ 1, y).
	                { prove p = (eps_ 1, y).
	                  rewrite HyEq.
	                  exact HpEq0. }
	                claim Hylt: Rlt (eps_ 1) y.
	                { rewrite HyEq.
	                  exact Hltb2. }
	                exact (andI (p = (eps_ 1, y)) (Rlt (eps_ 1) y) HpEq1 Hylt). }
            apply andI.
            - exact HpFirst.
            - exact Hyprop. }
	        exact (SepI ordered_square
	                    (fun p0:set => exists y:set, p0 = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y))
	                    p
	                    HpSq
	                    Hexists).
    }
    claim Hex: exists W :e R2_dictionary_order_topology, U = W :/\: ordered_square.
    { witness V.
      apply andI.
      - exact HVTx.
      - exact HeqU. }
    exact (SepI (Power ordered_square)
                (fun U0:set => exists W :e R2_dictionary_order_topology, U0 = W :/\: ordered_square)
                U
                HUpow
                Hex).
  }
  claim HUprod: U :e Tprod.
  { rewrite <- Heq.
    exact HUdic.
  }
  claim HUnprod: ~(U :e Tprod).
  { (** U is not open in the product (standard) topology on II **)
    assume HUin: U :e Tprod.
	    set p0 := (eps_ 1, 1).
	    (** show p0 :e U **)
	    claim Hp0U: p0 :e U.
	    { (** eps_ 1 and 1 are in the unit interval **)
	      claim H1omega: 1 :e omega.
	      { exact (nat_p_omega 1 nat_1). }
	      claim Heps1SNoS: eps_ 1 :e SNoS_ omega.
	      { exact (SNo_eps_SNoS_omega 1 H1omega). }
      claim Heps1R: eps_ 1 :e R.
      { exact (SNoS_omega_real (eps_ 1) Heps1SNoS). }
      claim HdefR: R = real.
      { reflexivity. }
      claim H1R: 1 :e R.
      { rewrite HdefR. exact real_1. }
      claim H0R: 0 :e R.
      { rewrite HdefR. exact real_0. }
      claim H0in1: 0 :e 1.
      { claim H0Ord: ordinal 0.
        { exact (nat_p_ordinal 0 nat_0). }
        exact (ordinal_0_In_ordsucc 0 H0Ord). }
      claim Heps1lt1: eps_ 1 < 1.
      { claim Heps1ltE0: eps_ 1 < eps_ 0.
        { exact (SNo_eps_decr 1 H1omega 0 H0in1). }
        rewrite <- (eps_0_1) at 2.
        exact Heps1ltE0. }
      claim Heps1lt1R: Rlt (eps_ 1) 1.
      { exact (RltI (eps_ 1) 1 Heps1R H1R Heps1lt1). }
      claim H0lt1: Rlt 0 1.
      { exact (RltI 0 1 H0R H1R SNoLt_0_1). }
      claim H0lteps1: Rlt 0 (eps_ 1).
      { exact (RltI 0 (eps_ 1) H0R Heps1R (SNo_eps_pos 1 H1omega)). }
      claim Hnlt_eps10: ~(Rlt (eps_ 1) 0).
      { exact (not_Rlt_sym 0 (eps_ 1) H0lteps1). }
      claim Hnlt_1eps1: ~(Rlt 1 (eps_ 1)).
      { exact (not_Rlt_sym (eps_ 1) 1 Heps1lt1R). }
      claim Hnlt_10: ~(Rlt 1 0).
      { exact (not_Rlt_sym 0 1 H0lt1). }
      claim Hnlt_11: ~(Rlt 1 1).
      { exact (not_Rlt_refl 1 H1R). }
      claim Heps1U: (eps_ 1) :e unit_interval.
      { exact (SepI R (fun t:set => ~(Rlt t 0) /\ ~(Rlt 1 t))
                   (eps_ 1)
                   Heps1R
                   (andI (~(Rlt (eps_ 1) 0)) (~(Rlt 1 (eps_ 1))) Hnlt_eps10 Hnlt_1eps1)). }
      claim H1U: 1 :e unit_interval.
	      { exact (SepI R (fun t:set => ~(Rlt t 0) /\ ~(Rlt 1 t))
	                   1
	                   H1R
	                   (andI (~(Rlt 1 0)) (~(Rlt 1 1)) Hnlt_10 Hnlt_11)). }
	      claim Hp0Sq: p0 :e ordered_square.
	      { prove (eps_ 1, 1) :e setprod unit_interval unit_interval.
	        exact (tuple_2_setprod unit_interval unit_interval (eps_ 1) Heps1U 1 H1U). }
	      claim Hp0Ex: exists y:set, p0 = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y).
	      { witness 1.
	        prove p0 = (eps_ 1,1) /\ Rlt (eps_ 1) 1 /\ ~(Rlt 1 1).
	        apply andI.
	        - apply andI.
	          + reflexivity.
	          + exact Heps1lt1R.
	        - exact Hnlt_11. }
	      exact (SepI ordered_square
	                  (fun q:set => exists y:set, q = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y))
	                  p0
	                  Hp0Sq
	                  Hp0Ex).
	    }
    (** use the defining refinement property of generated_topology for Tprod **)
    set X1 := setprod unit_interval unit_interval.
    set B1 := product_subbasis unit_interval unit_interval_topology unit_interval unit_interval_topology.
    claim HTdef: Tprod = generated_topology X1 B1.
    { reflexivity. }
    claim HUgen: U :e generated_topology X1 B1.
    { rewrite <- HTdef.
      exact HUin. }
    claim Href: forall x :e U, exists b :e B1, x :e b /\ b c= U.
    { exact (SepE2 (Power X1)
                   (fun U0:set => forall x :e U0, exists b :e B1, x :e b /\ b c= U0)
                   U
                   HUgen). }
    (** obtain a product-subbasis rectangle b with p0 :e b and b c= U **)
    claim Href0: exists b :e B1, p0 :e b /\ b c= U.
    { exact (Href p0 Hp0U). }
    (** destruct the subbasis element containing p0 **)
    apply Href0.
    let b0. assume Hb0pair.
    apply Hb0pair.
    assume Hb0B: b0 :e B1.
    assume Hb0core: p0 :e b0 /\ b0 c= U.
    claim Hp0b0: p0 :e b0.
    { exact (andEL (p0 :e b0) (b0 c= U) Hb0core). }
    claim Hb0subU: b0 c= U.
    { exact (andER (p0 :e b0) (b0 c= U) Hb0core). }
    (** expand membership in product_subbasis to obtain a rectangle representation **)
    apply (famunionE unit_interval_topology
                     (fun U0:set => {rectangle_set U0 V|V :e unit_interval_topology})
                     b0
                     Hb0B).
    let U0. assume HU0pair.
    apply HU0pair.
    assume HU0Tx: U0 :e unit_interval_topology.
    assume Hb0Repl: b0 :e {rectangle_set U0 V|V :e unit_interval_topology}.
    apply (ReplE unit_interval_topology (fun V0:set => rectangle_set U0 V0) b0 Hb0Repl).
    let V0. assume HV0pair.
    apply HV0pair.
    assume HV0Ty: V0 :e unit_interval_topology.
	    assume Hb0eq: b0 = rectangle_set U0 V0.
	    claim Hp0rect: p0 :e rectangle_set U0 V0.
	    { rewrite <- Hb0eq.
	      exact Hp0b0. }
    (** extract coordinate membership eps_1:e U0 and 1:e V0 **)
    claim Hp00: p0 0 = eps_ 1.
    { claim Hp0def: p0 = (eps_ 1, 1).
      { reflexivity. }
      rewrite Hp0def.
      exact (tuple_2_0_eq (eps_ 1) 1). }
    claim Hp01: p0 1 = 1.
    { claim Hp0def: p0 = (eps_ 1, 1).
      { reflexivity. }
      rewrite Hp0def.
      exact (tuple_2_1_eq (eps_ 1) 1). }
    claim HepsU0: (eps_ 1) :e U0.
    { claim Hp0U0: (p0 0) :e U0.
      { exact (ap0_Sigma U0 (fun _ : set => V0) p0 Hp0rect). }
      rewrite <- Hp00.
      exact Hp0U0. }
	    claim H1V0: 1 :e V0.
	    { claim Hp0V0: (p0 1) :e V0.
	      { exact (ap1_Sigma U0 (fun _ : set => V0) p0 Hp0rect). }
	      rewrite <- Hp01.
	      exact Hp0V0. }
	    (** choose another x in U0 distinct from eps_ 1 and form (x,1) in the rectangle **)
	    claim Hexother: exists x:set, x :e U0 /\ x <> eps_ 1.
	    { exact (unit_interval_open_neighborhood_has_other_point U0 HU0Tx HepsU0). }
	    apply Hexother.
	    let x. assume Hxpair.
	    claim HxU0: x :e U0.
	    { exact (andEL (x :e U0) (x <> eps_ 1) Hxpair). }
	    claim Hxneq: x <> eps_ 1.
	    { exact (andER (x :e U0) (x <> eps_ 1) Hxpair). }
	    set p1 := (x,1).
		    claim Hp1b0: p1 :e b0.
		    { rewrite Hb0eq.
		      prove p1 :e rectangle_set U0 V0.
		      exact (tuple_2_rectangle_set U0 V0 x 1 HxU0 H1V0). }
	    claim Hp1U: p1 :e U.
	    { exact (Hb0subU p1 Hp1b0). }
	    (** from p1:e U, extract p1=(eps_ 1,y) and compare first coordinates **)
	    claim Hstrip: exists y:set, p1 = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y).
	    { exact (SepE2 ordered_square
	                   (fun q:set => exists y:set, q = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y))
	                   p1
	                   Hp1U). }
		    apply Hstrip.
		    let y. assume Hyprop.
		    claim Hycore: p1 = (eps_ 1,y) /\ Rlt (eps_ 1) y.
		    { exact (andEL (p1 = (eps_ 1,y) /\ Rlt (eps_ 1) y)
		                  (~(Rlt 1 y))
		                  Hyprop). }
		    claim HyPair: p1 = (eps_ 1,y).
		    { exact (andEL (p1 = (eps_ 1,y))
		                  (Rlt (eps_ 1) y)
		                  Hycore). }
	    claim Hp10: p1 0 = x.
	    { claim Hp1def: p1 = (x,1).
	      { reflexivity. }
	      rewrite Hp1def.
	      exact (tuple_2_0_eq x 1). }
	    claim Hp10': p1 0 = eps_ 1.
	    { rewrite HyPair.
	      exact (tuple_2_0_eq (eps_ 1) y). }
	    claim Hxeq: x = eps_ 1.
	    { rewrite <- Hp10.
	      exact Hp10'. }
	    apply FalseE.
	    exact (Hxneq Hxeq).
	  }
	  exact (HUnprod HUprod).
Qed.

(** from 17 Definition: interior and closure of a set **) 
(** LATEX VERSION: Interior of A is union of opens inside A; closure of A consists of points whose every open neighborhood meets A. **)
Definition interior_of : set -> set -> set -> set := fun X T A =>
  {x :e X | exists U:set, U :e T /\ x :e U /\ U c= A}.
Definition closure_of : set -> set -> set -> set := fun X T A =>
  {x :e X | forall U:set, U :e T -> x :e U -> U :/\: A <> Empty}.

(** Helper: A is a subset of its closure **)
Theorem subset_of_closure : forall X Tx A:set,
  topology_on X Tx -> A c= X -> A c= closure_of X Tx A.
let X Tx A.
assume Htop: topology_on X Tx.
assume HA: A c= X.
prove A c= closure_of X Tx A.
let x. assume Hx: x :e A.
prove x :e closure_of X Tx A.
(** Show x :e X and for all U open containing x, U  A   **)
claim HxX: x :e X.
{ exact (HA x Hx). }
claim Hcond: forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
{ let U. assume HU: U :e Tx. assume HxU: x :e U.
  prove U :/\: A <> Empty.
  assume Hempty: U :/\: A = Empty.
  (** Derive contradiction: x :e U and x :e A, so x :e U  A **)
  claim HxUA: x :e U :/\: A.
  { exact (binintersectI U A x HxU Hx). }
  claim HxEmpty: x :e Empty.
  { rewrite <- Hempty. exact HxUA. }
  exact (EmptyE x HxEmpty). }
exact (SepI X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x HxX Hcond).
Qed.

(** Helper: Closure is monotone **)
Theorem closure_monotone : forall X Tx A B:set,
  topology_on X Tx -> A c= B -> B c= X -> closure_of X Tx A c= closure_of X Tx B.
let X Tx A B.
assume Htop: topology_on X Tx.
assume HAB: A c= B.
assume HB: B c= X.
prove closure_of X Tx A c= closure_of X Tx B.
let x. assume Hx: x :e closure_of X Tx A.
prove x :e closure_of X Tx B.
(** x satisfies: x :e X and for all U open containing x, U  A   **)
claim HxX: x :e X.
{ exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx). }
claim HcondA: forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
{ exact (SepE2 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx). }
(** Need to show: for all U open containing x, U  B   **)
claim HcondB: forall U:set, U :e Tx -> x :e U -> U :/\: B <> Empty.
{ let U. assume HU: U :e Tx. assume HxU: x :e U.
  prove U :/\: B <> Empty.
  (** We know U  A  , and A  B, so U  A  U  B **)
  claim HUA_ne: U :/\: A <> Empty.
  { exact (HcondA U HU HxU). }
  assume Hempty: U :/\: B = Empty.
  (** Show U  A =  by showing U  A  U  B =  **)
  claim HUA_sub_UB: U :/\: A c= U :/\: B.
  { let y. assume Hy: y :e U :/\: A.
    claim HyU: y :e U.
    { exact (binintersectE1 U A y Hy). }
    claim HyA: y :e A.
    { exact (binintersectE2 U A y Hy). }
    claim HyB: y :e B.
    { exact (HAB y HyA). }
    exact (binintersectI U B y HyU HyB). }
  claim HUA_empty: U :/\: A = Empty.
  { apply Empty_Subq_eq.
    claim HUB_sub_Empty: U :/\: B c= Empty.
    { rewrite Hempty. exact (Subq_ref Empty). }
    exact (Subq_tra (U :/\: A) (U :/\: B) Empty HUA_sub_UB HUB_sub_Empty). }
  exact (HUA_ne HUA_empty). }
exact (SepI X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: B <> Empty) x HxX HcondB).
Qed.

(** Helper: interior of A is contained in A **)
Theorem interior_subset : forall X Tx A:set,
  topology_on X Tx -> interior_of X Tx A c= A.
let X Tx A.
assume Htop: topology_on X Tx.
prove interior_of X Tx A c= A.
let x. assume Hx: x :e interior_of X Tx A.
prove x :e A.
claim Hexists: exists U:set, U :e Tx /\ x :e U /\ U c= A.
{ exact (SepE2 X (fun x0 => exists U:set, U :e Tx /\ x0 :e U /\ U c= A) x Hx). }
apply Hexists.
let U. assume HU_conj: U :e Tx /\ x :e U /\ U c= A.
(** Conjunction is left-associative: ((U :e Tx /\ x :e U) /\ U c= A) **)
claim HU_and_x: U :e Tx /\ x :e U.
{ exact (andEL (U :e Tx /\ x :e U) (U c= A) HU_conj). }
claim HUsub: U c= A.
{ exact (andER (U :e Tx /\ x :e U) (U c= A) HU_conj). }
claim HxU: x :e U.
{ exact (andER (U :e Tx) (x :e U) HU_and_x). }
exact (HUsub x HxU).
Qed.

(** Helper: interior is monotone **)
Theorem interior_monotone : forall X Tx A B:set,
  topology_on X Tx -> A c= B -> interior_of X Tx A c= interior_of X Tx B.
let X Tx A B.
assume Htop: topology_on X Tx.
assume HAB: A c= B.
prove interior_of X Tx A c= interior_of X Tx B.
let x. assume Hx: x :e interior_of X Tx A.
prove x :e interior_of X Tx B.
claim HxX: x :e X.
{ exact (SepE1 X (fun x0 => exists U:set, U :e Tx /\ x0 :e U /\ U c= A) x Hx). }
claim Hexists: exists U:set, U :e Tx /\ x :e U /\ U c= A.
{ exact (SepE2 X (fun x0 => exists U:set, U :e Tx /\ x0 :e U /\ U c= A) x Hx). }
apply Hexists.
let U. assume HU_conj: U :e Tx /\ x :e U /\ U c= A.
(** Conjunction is left-associative: ((U :e Tx /\ x :e U) /\ U c= A) **)
claim HU_and_x: U :e Tx /\ x :e U.
{ exact (andEL (U :e Tx /\ x :e U) (U c= A) HU_conj). }
claim HUsub_A: U c= A.
{ exact (andER (U :e Tx /\ x :e U) (U c= A) HU_conj). }
claim HU: U :e Tx.
{ exact (andEL (U :e Tx) (x :e U) HU_and_x). }
claim HxU: x :e U.
{ exact (andER (U :e Tx) (x :e U) HU_and_x). }
claim HUsub_B: U c= B.
{ exact (Subq_tra U A B HUsub_A HAB). }
(** Now construct the witness for x :e interior_of X Tx B **)
claim Hwitness: U :e Tx /\ x :e U /\ U c= B.
{ apply andI.
  - apply andI.
    + exact HU.
    + exact HxU.
  - exact HUsub_B. }
claim Hexists_B: exists V:set, V :e Tx /\ x :e V /\ V c= B.
{ witness U.
  exact Hwitness. }
exact (SepI X (fun x0 => exists V:set, V :e Tx /\ x0 :e V /\ V c= B) x HxX Hexists_B).
Qed.

(** Helper: open sets equal their interior **)
Theorem open_interior_eq : forall X Tx U:set,
  topology_on X Tx -> U :e Tx -> interior_of X Tx U = U.
let X Tx U.
assume Htop: topology_on X Tx.
assume HU: U :e Tx.
prove interior_of X Tx U = U.
apply set_ext.
- (** interior(U)  U **)
  exact (interior_subset X Tx U Htop).
- (** U  interior(U) **)
  let x. assume Hx: x :e U.
  prove x :e interior_of X Tx U.
  claim HUsub: U c= X.
  { exact (topology_elem_subset X Tx U Htop HU). }
  claim HxX: x :e X.
  { exact (HUsub x Hx). }
  claim Hwitness: U :e Tx /\ x :e U /\ U c= U.
  { apply andI.
    - apply andI.
      + exact HU.
      + exact Hx.
    - exact (Subq_ref U). }
  claim Hexists: exists V:set, V :e Tx /\ x :e V /\ V c= U.
  { witness U.
    exact Hwitness. }
  exact (SepI X (fun x0 => exists V:set, V :e Tx /\ x0 :e V /\ V c= U) x HxX Hexists).
Qed.

(** Helper: interior of empty set is empty **)
Theorem interior_of_empty : forall X Tx:set,
  topology_on X Tx -> interior_of X Tx Empty = Empty.
let X Tx.
assume Htop: topology_on X Tx.
prove interior_of X Tx Empty = Empty.
apply set_ext.
- (** interior(Empty)  Empty **)
  exact (interior_subset X Tx Empty Htop).
- (** Empty  interior(Empty) **)
  exact (Subq_Empty (interior_of X Tx Empty)).
Qed.

(** Helper: interior of whole space is the space **)
Theorem interior_of_space : forall X Tx:set,
  topology_on X Tx -> interior_of X Tx X = X.
let X Tx.
assume Htop: topology_on X Tx.
prove interior_of X Tx X = X.
claim HXopen: X :e Tx.
{ exact (topology_has_X X Tx Htop). }
exact (open_interior_eq X Tx X Htop HXopen).
Qed.

(** Helper: interior is open **)
Theorem interior_is_open : forall X Tx A:set,
  topology_on X Tx -> A c= X -> interior_of X Tx A :e Tx.
let X Tx A.
assume Htop: topology_on X Tx.
assume HA: A c= X.
prove interior_of X Tx A :e Tx.
  (** Strategy: interior(A) is the union of all open sets contained in A; the union of a family of open sets is open. **)
set F := {U :e Tx | U c= A}.
claim Hint_eq_union: interior_of X Tx A = Union F.
{ apply set_ext.
  - (** interior(A)  Union(F) **)
    let x. assume Hx: x :e interior_of X Tx A.
    prove x :e Union F.
    claim HxX: x :e X.
    { exact (SepE1 X (fun x0 => exists U:set, U :e Tx /\ x0 :e U /\ U c= A) x Hx). }
    claim Hexists: exists U:set, U :e Tx /\ x :e U /\ U c= A.
    { exact (SepE2 X (fun x0 => exists U:set, U :e Tx /\ x0 :e U /\ U c= A) x Hx). }
    apply Hexists.
    let U. assume HU_conj: U :e Tx /\ x :e U /\ U c= A.
    claim HU_and_x: U :e Tx /\ x :e U.
    { exact (andEL (U :e Tx /\ x :e U) (U c= A) HU_conj). }
    claim HUsub: U c= A.
    { exact (andER (U :e Tx /\ x :e U) (U c= A) HU_conj). }
    claim HU: U :e Tx.
    { exact (andEL (U :e Tx) (x :e U) HU_and_x). }
    claim HxU: x :e U.
    { exact (andER (U :e Tx) (x :e U) HU_and_x). }
    claim HUinF: U :e F.
    { apply SepI.
      - exact HU.
      - exact HUsub. }
    exact (UnionI F x U HxU HUinF).
  - (** Union(F)  interior(A) **)
    let x. assume Hx: x :e Union F.
    prove x :e interior_of X Tx A.
    apply (UnionE_impred F x Hx (x :e interior_of X Tx A)).
    let U. assume HxU: x :e U. assume HUinF: U :e F.
    claim HU: U :e Tx.
    { exact (SepE1 Tx (fun U0 => U0 c= A) U HUinF). }
    claim HUsub: U c= A.
    { exact (SepE2 Tx (fun U0 => U0 c= A) U HUinF). }
    claim HUsub_X: U c= X.
    { exact (topology_elem_subset X Tx U Htop HU). }
    claim HxX: x :e X.
    { exact (HUsub_X x HxU). }
    claim Hwitness: U :e Tx /\ x :e U /\ U c= A.
    { apply andI.
      - apply andI.
        + exact HU.
        + exact HxU.
      - exact HUsub. }
    claim Hexists: exists V:set, V :e Tx /\ x :e V /\ V c= A.
    { witness U. exact Hwitness. }
    exact (SepI X (fun x0 => exists V:set, V :e Tx /\ x0 :e V /\ V c= A) x HxX Hexists). }
(** Now show Union F is open **)
claim HF_sub_Tx: F c= Tx.
{ let U. assume HU: U :e F.
  exact (SepE1 Tx (fun U0 => U0 c= A) U HU). }
claim Hunion_in_Tx: Union F :e Tx.
{ exact (topology_union_closed X Tx F Htop HF_sub_Tx). }
(** By Hint_eq_union, interior_of X Tx A = Union F, so interior is open **)
(** Use equality: if A = B and B :e Tx, then A :e Tx **)
claim Heq_substitution: forall S T:set, S = T -> T :e Tx -> S :e Tx.
{ let S T. assume HeqST: S = T. assume HTinTx: T :e Tx.
  (** Rewrite S as T in the goal S :e Tx **)
  prove S :e Tx.
  claim HST_equiv: forall P:set -> prop, P T -> P S.
  { let P. assume HPT: P T.
    (** Use symmetry of equality and substitution **)
    prove P S.
    rewrite HeqST.
    exact HPT. }
  exact (HST_equiv (fun X0 => X0 :e Tx) HTinTx). }
exact (Heq_substitution (interior_of X Tx A) (Union F) Hint_eq_union Hunion_in_Tx).
Qed.

(** Helper: union of interiors contained in interior of union **)
Theorem interior_union_contains_union_interiors : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  interior_of X Tx A :\/: interior_of X Tx B c= interior_of X Tx (A :\/: B).
let X Tx A B.
assume Htop: topology_on X Tx.
assume HA: A c= X.
assume HB: B c= X.
prove interior_of X Tx A :\/: interior_of X Tx B c= interior_of X Tx (A :\/: B).
(** Use monotonicity: A  AB and B  AB **)
claim HAB_union_A: A c= A :\/: B.
{ let x. assume Hx: x :e A. exact (binunionI1 A B x Hx). }
claim HAB_union_B: B c= A :\/: B.
{ let x. assume Hx: x :e B. exact (binunionI2 A B x Hx). }
claim HAB_sub: A :\/: B c= X.
{ let x. assume Hx: x :e A :\/: B.
  apply (binunionE A B x Hx).
  - assume HxA: x :e A. exact (HA x HxA).
  - assume HxB: x :e B. exact (HB x HxB). }
claim HintA: interior_of X Tx A c= interior_of X Tx (A :\/: B).
{ exact (interior_monotone X Tx A (A :\/: B) Htop HAB_union_A). }
claim HintB: interior_of X Tx B c= interior_of X Tx (A :\/: B).
{ exact (interior_monotone X Tx B (A :\/: B) Htop HAB_union_B). }
let x. assume Hx: x :e interior_of X Tx A :\/: interior_of X Tx B.
apply (binunionE (interior_of X Tx A) (interior_of X Tx B) x Hx).
- assume HxA: x :e interior_of X Tx A. exact (HintA x HxA).
- assume HxB: x :e interior_of X Tx B. exact (HintB x HxB).
Qed.

(** Helper: interior of intersection contains intersection of interiors **)
Theorem interior_intersection_contains_intersection : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  interior_of X Tx (A :/\: B) c= interior_of X Tx A :/\: interior_of X Tx B.
let X Tx A B.
assume Htop: topology_on X Tx.
assume HA: A c= X.
assume HB: B c= X.
prove interior_of X Tx (A :/\: B) c= interior_of X Tx A :/\: interior_of X Tx B.
(** Use monotonicity: A  B  A and A  B  B **)
claim HAB_A: A :/\: B c= A.
{ exact (binintersect_Subq_1 A B). }
claim HAB_B: A :/\: B c= B.
{ exact (binintersect_Subq_2 A B). }
claim HintAB_A: interior_of X Tx (A :/\: B) c= interior_of X Tx A.
{ exact (interior_monotone X Tx (A :/\: B) A Htop HAB_A). }
claim HintAB_B: interior_of X Tx (A :/\: B) c= interior_of X Tx B.
{ exact (interior_monotone X Tx (A :/\: B) B Htop HAB_B). }
let x. assume Hx: x :e interior_of X Tx (A :/\: B).
apply binintersectI.
- exact (HintAB_A x Hx).
- exact (HintAB_B x Hx).
Qed.

(** Helper: interior of intersection of open sets **)
Theorem interior_intersection_of_opens : forall X Tx U V:set,
  topology_on X Tx -> U :e Tx -> V :e Tx ->
  interior_of X Tx (U :/\: V) = U :/\: V.
let X Tx U V.
assume Htop: topology_on X Tx.
assume HU: U :e Tx.
assume HV: V :e Tx.
prove interior_of X Tx (U :/\: V) = U :/\: V.
(** Strategy: U  V is open (by topology axioms), and open sets equal their interior **)
claim HUV_open: U :/\: V :e Tx.
{ exact (lemma_intersection_two_open X Tx U V Htop HU HV). }
exact (open_interior_eq X Tx (U :/\: V) Htop HUV_open).
Qed.

(** Helper: interior is idempotent **)
Theorem interior_idempotent : forall X Tx A:set,
  topology_on X Tx -> A c= X -> interior_of X Tx (interior_of X Tx A) = interior_of X Tx A.
let X Tx A.
assume Htop: topology_on X Tx.
assume HA: A c= X.
prove interior_of X Tx (interior_of X Tx A) = interior_of X Tx A.
(** Strategy: interior(A) is open, and open sets equal their interior **)
claim HintA_open: interior_of X Tx A :e Tx.
{ exact (interior_is_open X Tx A Htop HA). }
exact (open_interior_eq X Tx (interior_of X Tx A) Htop HintA_open).
Qed.

(** Helper: interior-closure duality **)

Theorem not_in_closure_has_disjoint_open : forall X Tx A x:set,
  topology_on X Tx -> A c= X -> x :e X -> x /:e closure_of X Tx A ->
  exists U:set, U :e Tx /\ x :e U /\ U :/\: A = Empty.
let X Tx A x.
assume Htop: topology_on X Tx.
assume HA: A c= X.
assume HxX: x :e X.
assume Hxnotcl: x /:e closure_of X Tx A.
prove exists U:set, U :e Tx /\ x :e U /\ U :/\: A = Empty.
(** By definition, x  cl(A) means x  X and U open, x  U  U  A   **)
(** Since x  cl(A) and x  X, there must exist U open with x  U and U  A =  **)
apply (xm (exists U:set, U :e Tx /\ x :e U /\ U :/\: A = Empty)).
- assume H. exact H.
- assume Hnoex: ~(exists U:set, U :e Tx /\ x :e U /\ U :/\: A = Empty).
  (** Then U open, x  U  U  A  , which means x  cl(A) **)
  apply FalseE.
  apply Hxnotcl.
  prove x :e closure_of X Tx A.
  prove x :e {y :e X | forall U:set, U :e Tx -> y :e U -> U :/\: A <> Empty}.
  apply SepI.
  + exact HxX.
  + prove forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
    let U. assume HU: U :e Tx. assume HxU: x :e U.
    prove U :/\: A <> Empty.
    assume Heq: U :/\: A = Empty.
    apply Hnoex.
    witness U.
    prove U :e Tx /\ x :e U /\ U :/\: A = Empty.
    apply andI.
    * apply andI.
      + exact HU.
      + exact HxU.
    * exact Heq.
Qed.

Theorem closure_is_closed : forall X Tx A:set,
  topology_on X Tx -> A c= X -> closed_in X Tx (closure_of X Tx A).
let X Tx A.
assume Htop: topology_on X Tx.
assume HA: A c= X.
prove closed_in X Tx (closure_of X Tx A).
(** Strategy: Show X \ cl(A) is open by showing it's a union of open sets **)
(** For each x  X \ cl(A), there exists open U with x  U and U  A =  **)
(** Then X \ cl(A) = {U : x  X \ cl(A)}, which is open **)
prove topology_on X Tx /\ (closure_of X Tx A c= X /\ exists U :e Tx, closure_of X Tx A = X :\: U).
apply andI.
- exact Htop.
- prove closure_of X Tx A c= X /\ exists U :e Tx, closure_of X Tx A = X :\: U.
  apply andI.
  + (** closure(A)  X **)
    prove closure_of X Tx A c= X.
    let x. assume Hx: x :e closure_of X Tx A.
    exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx).
  + (** Prove X \ cl(A) is open **)
    set Complement := X :\: closure_of X Tx A.
    set OpenFamily := {U :e Tx | U :/\: A = Empty}.
    claim Hcomp_eq: Complement = Union OpenFamily.
    { apply set_ext.
      - (** Complement  Union OpenFamily **)
        let x. assume Hx: x :e Complement.
        prove x :e Union OpenFamily.
        claim HxX: x :e X.
        { exact (setminusE1 X (closure_of X Tx A) x Hx). }
        claim Hxnotcl: x /:e closure_of X Tx A.
        { exact (setminusE2 X (closure_of X Tx A) x Hx). }
        claim Hexists: exists U:set, U :e Tx /\ x :e U /\ U :/\: A = Empty.
        { exact (not_in_closure_has_disjoint_open X Tx A x Htop HA HxX Hxnotcl). }
        apply Hexists.
        let U. assume HU_parts.
        claim HU_and_xU: U :e Tx /\ x :e U.
        { exact (andEL (U :e Tx /\ x :e U) (U :/\: A = Empty) HU_parts). }
        claim HU: U :e Tx.
        { exact (andEL (U :e Tx) (x :e U) HU_and_xU). }
        claim HxU: x :e U.
        { exact (andER (U :e Tx) (x :e U) HU_and_xU). }
        claim HUdisj: U :/\: A = Empty.
        { exact (andER (U :e Tx /\ x :e U) (U :/\: A = Empty) HU_parts). }
        claim HUinFam: U :e OpenFamily.
        { exact (SepI Tx (fun V => V :/\: A = Empty) U HU HUdisj). }
        exact (UnionI OpenFamily x U HxU HUinFam).
      - (** Union OpenFamily  Complement **)
        let x. assume Hx: x :e Union OpenFamily.
        prove x :e Complement.
        apply (UnionE_impred OpenFamily x Hx).
        let U. assume HxU: x :e U. assume HUFam: U :e OpenFamily.
        claim HU: U :e Tx.
        { exact (SepE1 Tx (fun V => V :/\: A = Empty) U HUFam). }
        claim HUdisj: U :/\: A = Empty.
        { exact (SepE2 Tx (fun V => V :/\: A = Empty) U HUFam). }
        claim HUsub: U c= X.
        { exact (topology_elem_subset X Tx U Htop HU). }
        claim HxX: x :e X.
        { exact (HUsub x HxU). }
        apply setminusI.
        + exact HxX.
        + assume Hxcl: x :e closure_of X Tx A.
          claim Hcond: forall V:set, V :e Tx -> x :e V -> V :/\: A <> Empty.
          { exact (SepE2 X (fun y => forall V:set, V :e Tx -> y :e V -> V :/\: A <> Empty) x Hxcl). }
          claim Hcontra: U :/\: A <> Empty.
          { exact (Hcond U HU HxU). }
          exact (Hcontra HUdisj). }
    claim Hopen_subset: OpenFamily c= Tx.
    { let U. assume HU: U :e OpenFamily.
      exact (SepE1 Tx (fun V => V :/\: A = Empty) U HU). }
    claim Hcomp_open: Complement :e Tx.
    { rewrite Hcomp_eq.
      exact (topology_union_closed X Tx OpenFamily Htop Hopen_subset). }
    witness Complement.
    apply andI.
    * exact Hcomp_open.
    * (** closure(A) = X \ Complement **)
      apply set_ext.
      + let x. assume Hx: x :e closure_of X Tx A.
        prove x :e X :\: Complement.
        claim HxX: x :e X.
        { exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx). }
        apply setminusI.
        * exact HxX.
        * assume Hxcomp: x :e Complement.
          claim Hxnotcl: x /:e closure_of X Tx A.
          { exact (setminusE2 X (closure_of X Tx A) x Hxcomp). }
          exact (Hxnotcl Hx).
      + let x. assume Hx: x :e X :\: Complement.
        prove x :e closure_of X Tx A.
        claim HxX: x :e X.
        { exact (setminusE1 X Complement x Hx). }
        claim Hxnotcomp: x /:e Complement.
        { exact (setminusE2 X Complement x Hx). }
        apply (xm (x :e closure_of X Tx A)).
        * assume H. exact H.
        * assume Hxnotcl: x /:e closure_of X Tx A.
          apply FalseE.
          apply Hxnotcomp.
          apply setminusI.
          - exact HxX.
          - exact Hxnotcl.
Qed.

Theorem interior_closure_complement_duality : forall X Tx A:set,
  topology_on X Tx -> A c= X ->
  interior_of X Tx A = X :\: closure_of X Tx (X :\: A).
let X Tx A.
assume Htop: topology_on X Tx.
assume HA: A c= X.
prove interior_of X Tx A = X :\: closure_of X Tx (X :\: A).
(** Strategy: int(A) is the largest open subset of A; X \\ cl(X\\A) is open (complement of closed), and we show it equals int(A). **)
claim HXA_sub: X :\: A c= X.
{ let x. assume Hx: x :e X :\: A.
  exact (setminusE1 X A x Hx). }
(** cl(X\A) is closed, so X \ cl(X\A) is open **)
claim Hclosed: closed_in X Tx (closure_of X Tx (X :\: A)).
{ exact (closure_is_closed X Tx (X :\: A) Htop HXA_sub). }
(** Extract that there exists U open with cl(X\A) = X \ U, so X \ cl(X\A) = U is open **)
claim Hclosed_parts: topology_on X Tx /\ (closure_of X Tx (X :\: A) c= X /\ exists U :e Tx, closure_of X Tx (X :\: A) = X :\: U).
{ exact Hclosed. }
claim Hexists: exists U :e Tx, closure_of X Tx (X :\: A) = X :\: U.
{ claim Hpart2: closure_of X Tx (X :\: A) c= X /\ exists U :e Tx, closure_of X Tx (X :\: A) = X :\: U.
  { exact (andER (topology_on X Tx) (closure_of X Tx (X :\: A) c= X /\ exists U :e Tx, closure_of X Tx (X :\: A) = X :\: U) Hclosed_parts). }
  exact (andER (closure_of X Tx (X :\: A) c= X) (exists U :e Tx, closure_of X Tx (X :\: A) = X :\: U) Hpart2). }
apply Hexists.
let U. assume HU_conj: U :e Tx /\ closure_of X Tx (X :\: A) = X :\: U.
claim HU_open: U :e Tx.
{ exact (andEL (U :e Tx) (closure_of X Tx (X :\: A) = X :\: U) HU_conj). }
claim Heq_clXA: closure_of X Tx (X :\: A) = X :\: U.
{ exact (andER (U :e Tx) (closure_of X Tx (X :\: A) = X :\: U) HU_conj). }
(** Now show X \ cl(X\A) = U **)
claim HcompU: X :\: closure_of X Tx (X :\: A) = U.
{ apply set_ext.
  - let x. assume Hx: x :e X :\: closure_of X Tx (X :\: A).
    prove x :e U.
    claim HxX: x :e X.
    { exact (setminusE1 X (closure_of X Tx (X :\: A)) x Hx). }
    claim Hxnotcl: x /:e closure_of X Tx (X :\: A).
    { exact (setminusE2 X (closure_of X Tx (X :\: A)) x Hx). }
    (** From Heq_clXA: cl(X\A) = X \ U, so x  cl(X\A) means x  X \ U, i.e., x  U **)
    apply (xm (x :e U)).
    + assume H. exact H.
    + assume HxnotU: x /:e U.
      apply FalseE.
      apply Hxnotcl.
      (** x  X and x  U, so x  X \ U = cl(X\A) **)
      claim HxXminusU: x :e X :\: U.
      { apply setminusI. exact HxX. exact HxnotU. }
      (** Use Heq_clXA: cl(X\A) = X \ U **)
      prove x :e closure_of X Tx (X :\: A).
      rewrite Heq_clXA.
      exact HxXminusU.
  - let x. assume Hx: x :e U.
    prove x :e X :\: closure_of X Tx (X :\: A).
    claim HUsub: U c= X.
    { exact (topology_elem_subset X Tx U Htop HU_open). }
    claim HxX: x :e X.
    { exact (HUsub x Hx). }
    apply setminusI.
    + exact HxX.
    + assume Hxcl: x :e closure_of X Tx (X :\: A).
      (** From Heq_clXA: cl(X\A) = X \ U, so x  cl(X\A) means x  X \ U, so x  U **)
      claim HxXminusU: x :e X :\: U.
      { rewrite <- Heq_clXA. exact Hxcl. }
      claim HxnotU: x /:e U.
      { exact (setminusE2 X U x HxXminusU). }
      exact (HxnotU Hx). }
(** Now show U  A **)
claim HUsub_A: U c= A.
{ let x. assume Hx: x :e U.
  prove x :e A.
  claim HUsub: U c= X.
  { exact (topology_elem_subset X Tx U Htop HU_open). }
  claim HxX: x :e X.
  { exact (HUsub x Hx). }
  apply (xm (x :e A)).
  - assume H. exact H.
  - assume HxnotA: x /:e A.
    (** Then x  X \ A, so x  cl(X\A) = X \ U, so x  U, contradiction **)
    apply FalseE.
    claim HxXminusA: x :e X :\: A.
    { apply setminusI. exact HxX. exact HxnotA. }
    claim Hxincl: x :e closure_of X Tx (X :\: A).
    { exact (subset_of_closure X Tx (X :\: A) Htop HXA_sub x HxXminusA). }
    claim HxXminusU: x :e X :\: U.
    { rewrite <- Heq_clXA. exact Hxincl. }
    claim HxnotU: x /:e U.
    { exact (setminusE2 X U x HxXminusU). }
    exact (HxnotU Hx). }
(** Finally show int(A) = U **)
claim Hint_eq_U: interior_of X Tx A = U.
{ apply set_ext.
- (** int(A)  U **)
  let x. assume Hx: x :e interior_of X Tx A.
  prove x :e U.
  claim HxX: x :e X.
  { exact (SepE1 X (fun y => exists V:set, V :e Tx /\ y :e V /\ V c= A) x Hx). }
  claim Hexists_V: exists V:set, V :e Tx /\ x :e V /\ V c= A.
  { exact (SepE2 X (fun y => exists V:set, V :e Tx /\ y :e V /\ V c= A) x Hx). }
  apply Hexists_V.
  let V. assume HV_conj.
  claim HV_and_xV: V :e Tx /\ x :e V.
  { exact (andEL (V :e Tx /\ x :e V) (V c= A) HV_conj). }
  claim HV: V :e Tx.
  { exact (andEL (V :e Tx) (x :e V) HV_and_xV). }
  claim HxV: x :e V.
  { exact (andER (V :e Tx) (x :e V) HV_and_xV). }
  claim HVsub: V c= A.
  { exact (andER (V :e Tx /\ x :e V) (V c= A) HV_conj). }
  (** Show x  cl(X\A), which means x  U **)
  apply (xm (x :e U)).
  + assume H. exact H.
  + assume HxnotU: x /:e U.
    (** Then x  X \ U = cl(X\A), but V is open with x  V  A, so V  (X\A) = , contradiction **)
    apply FalseE.
    claim HxXminusU: x :e X :\: U.
    { apply setminusI. exact HxX. exact HxnotU. }
    claim Hxcl: x :e closure_of X Tx (X :\: A).
    { rewrite Heq_clXA. exact HxXminusU. }
    (** x  cl(X\A) means V  (X\A)   **)
    claim Hcond: forall W:set, W :e Tx -> x :e W -> W :/\: (X :\: A) <> Empty.
    { exact (SepE2 X (fun y => forall W:set, W :e Tx -> y :e W -> W :/\: (X :\: A) <> Empty) x Hxcl). }
    claim HVmeets: V :/\: (X :\: A) <> Empty.
    { exact (Hcond V HV HxV). }
    (** But V  A, so V  (X\A) =  **)
    claim HVdisj: V :/\: (X :\: A) = Empty.
    { apply set_ext.
      - let y. assume Hy: y :e V :/\: (X :\: A).
        prove y :e Empty.
        claim HyV: y :e V.
        { exact (binintersectE1 V (X :\: A) y Hy). }
        claim HyXminusA: y :e X :\: A.
        { exact (binintersectE2 V (X :\: A) y Hy). }
        claim HyA: y :e A.
        { exact (HVsub y HyV). }
        claim HynotA: y /:e A.
        { exact (setminusE2 X A y HyXminusA). }
        apply FalseE.
        exact (HynotA HyA).
      - exact (Subq_Empty (V :/\: (X :\: A))). }
    exact (HVmeets HVdisj).
- (** U  int(A) **)
  let x. assume Hx: x :e U.
  prove x :e interior_of X Tx A.
  claim HUsub: U c= X.
  { exact (topology_elem_subset X Tx U Htop HU_open). }
  claim HxX: x :e X.
  { exact (HUsub x Hx). }
  prove x :e {y :e X | exists V:set, V :e Tx /\ y :e V /\ V c= A}.
  apply SepI.
  + exact HxX.
  + prove exists V:set, V :e Tx /\ x :e V /\ V c= A.
    witness U.
    prove U :e Tx /\ x :e U /\ U c= A.
    apply andI.
    * apply andI.
      - exact HU_open.
      - exact Hx.
    * exact HUsub_A. }
(** Now use HcompU to get the final result **)
prove interior_of X Tx A = X :\: closure_of X Tx (X :\: A).
rewrite HcompU.
exact Hint_eq_U.
Qed.


(** Helper: closure contains the set **)
Theorem closure_contains_set : forall X Tx A:set,
  topology_on X Tx -> A c= X -> A c= closure_of X Tx A.
let X Tx A.
assume Htop: topology_on X Tx.
assume HA: A c= X.
exact (subset_of_closure X Tx A Htop HA).
Qed.

(** Helper: closure is in X **)
Theorem closure_in_space : forall X Tx A:set,
  topology_on X Tx -> closure_of X Tx A c= X.
let X Tx A.
assume Htop: topology_on X Tx.
prove closure_of X Tx A c= X.
let x. assume Hx: x :e closure_of X Tx A.
prove x :e X.
exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx).
Qed.

(** Helper: closure is contained in any closed superset **)
Theorem closure_subset_of_closed_superset : forall X Tx A C:set,
  topology_on X Tx ->
  A c= C ->
  closed_in X Tx C ->
  closure_of X Tx A c= C.
let X Tx A C.
assume Htop: topology_on X Tx.
assume HAC: A c= C.
assume HC: closed_in X Tx C.
prove closure_of X Tx A c= C.
let x. assume Hx: x :e closure_of X Tx A.
prove x :e C.
apply (xm (x :e C)).
- assume HxC: x :e C. exact HxC.
- assume HxnotC: x /:e C.
  claim HCparts: C c= X /\ exists U :e Tx, C = X :\: U.
  { exact (andER (topology_on X Tx) (C c= X /\ exists U :e Tx, C = X :\: U) HC). }
  claim HxX: x :e X.
  { exact (closure_in_space X Tx A Htop x Hx). }
  claim HcondA: forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
  { exact (SepE2 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx). }
  apply (andER (C c= X) (exists U :e Tx, C = X :\: U) HCparts).
  let U. assume HUconj: U :e Tx /\ C = X :\: U.
  claim HU: U :e Tx.
  { exact (andEL (U :e Tx) (C = X :\: U) HUconj). }
  claim HCeq: C = X :\: U.
  { exact (andER (U :e Tx) (C = X :\: U) HUconj). }
  claim HxU: x :e U.
  { apply (xm (x :e U)).
    - assume H. exact H.
    - assume HxnotU: x /:e U.
      apply FalseE.
      apply HxnotC.
      claim HxXU: x :e X :\: U.
      { exact (setminusI X U x HxX HxnotU). }
      rewrite HCeq.
      exact HxXU. }
  claim HUAne: U :/\: A <> Empty.
  { exact (HcondA U HU HxU). }
  claim HUAempty: U :/\: A = Empty.
  { apply Empty_Subq_eq.
    let y. assume Hy: y :e U :/\: A.
    prove y :e Empty.
    claim HyU: y :e U.
    { exact (binintersectE1 U A y Hy). }
    claim HyA: y :e A.
    { exact (binintersectE2 U A y Hy). }
    claim HyC: y :e C.
    { exact (HAC y HyA). }
    claim HyXU: y :e X :\: U.
    { rewrite <- HCeq. exact HyC. }
    claim HynotU: y /:e U.
    { exact (setminusE2 X U y HyXU). }
    apply FalseE.
    exact (HynotU HyU). }
  apply FalseE.
  exact (HUAne HUAempty).
Qed.

(** Helper: closure of union contains union of closures **)
Theorem closure_union_contains_union_closures : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  closure_of X Tx A :\/: closure_of X Tx B c= closure_of X Tx (A :\/: B).
let X Tx A B.
assume Htop: topology_on X Tx.
assume HA: A c= X.
assume HB: B c= X.
prove closure_of X Tx A :\/: closure_of X Tx B c= closure_of X Tx (A :\/: B).
(** Use monotonicity of closure with A c= AB and B c= AB **)
claim HAB_union: A c= A :\/: B.
{ let x. assume Hx: x :e A. exact (binunionI1 A B x Hx). }
claim HBB_union: B c= A :\/: B.
{ let x. assume Hx: x :e B. exact (binunionI2 A B x Hx). }
claim HAB_sub: A :\/: B c= X.
{ let x. assume Hx: x :e A :\/: B.
  apply (binunionE A B x Hx).
  - assume HxA: x :e A. exact (HA x HxA).
  - assume HxB: x :e B. exact (HB x HxB). }
claim HclA: closure_of X Tx A c= closure_of X Tx (A :\/: B).
{ exact (closure_monotone X Tx A (A :\/: B) Htop HAB_union HAB_sub). }
claim HclB: closure_of X Tx B c= closure_of X Tx (A :\/: B).
{ exact (closure_monotone X Tx B (A :\/: B) Htop HBB_union HAB_sub). }
let x. assume Hx: x :e closure_of X Tx A :\/: closure_of X Tx B.
apply (binunionE (closure_of X Tx A) (closure_of X Tx B) x Hx).
- assume HxA: x :e closure_of X Tx A. exact (HclA x HxA).
- assume HxB: x :e closure_of X Tx B. exact (HclB x HxB).
Qed.

(** Helper: closure of empty set is empty **)
Theorem closure_of_empty : forall X Tx:set,
  topology_on X Tx -> closure_of X Tx Empty = Empty.
let X Tx.
assume Htop: topology_on X Tx.
prove closure_of X Tx Empty = Empty.
apply set_ext.
- prove closure_of X Tx Empty c= Empty.
  let x. assume Hx: x :e closure_of X Tx Empty.
  prove x :e Empty.
  (** x :e closure means: x :e X and for all U open with x :e U, U  Empty  Empty; but U  Empty = Empty, so this is impossible. **)
  apply (SepE X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: Empty <> Empty) x Hx).
  assume HxX: x :e X.
  assume Hcond: forall U:set, U :e Tx -> x :e U -> U :/\: Empty <> Empty.
  (** Get X itself as an open set containing x **)
  claim HXopen: X :e Tx.
  { exact (topology_has_X X Tx Htop). }
  claim HXne: X :/\: Empty <> Empty.
  { exact (Hcond X HXopen HxX). }
  (** But X  Empty = Empty **)
  claim HXempty: X :/\: Empty = Empty.
  { apply set_ext.
    - let y. assume Hy: y :e X :/\: Empty.
      exact (binintersectE2 X Empty y Hy).
    - exact (Subq_Empty (X :/\: Empty)). }
  apply HXne.
  exact HXempty.
- exact (Subq_Empty (closure_of X Tx Empty)).
Qed.

(** Helper: closure of the whole space is the space itself **)
Theorem closure_of_space : forall X Tx:set,
  topology_on X Tx -> closure_of X Tx X = X.
let X Tx.
assume Htop: topology_on X Tx.
prove closure_of X Tx X = X.
apply set_ext.
- exact (closure_in_space X Tx X Htop).
- exact (subset_of_closure X Tx X Htop (Subq_ref X)).
Qed.

(** Helper: union of two closed sets is closed **)
Theorem union_of_closed_is_closed : forall X Tx C D:set,
  topology_on X Tx -> closed_in X Tx C -> closed_in X Tx D ->
  closed_in X Tx (C :\/: D).
let X Tx C D.
assume Htop: topology_on X Tx.
assume HC: closed_in X Tx C.
assume HD: closed_in X Tx D.
prove closed_in X Tx (C :\/: D).
  (** C = X \\ U and D = X \\ V for some open U,V; then C  D = X \\ (U  V) and U  V is open. **)
prove topology_on X Tx /\ (C :\/: D c= X /\ exists W :e Tx, C :\/: D = X :\: W).
apply andI.
- exact Htop.
- claim HC_parts: C c= X /\ exists U :e Tx, C = X :\: U.
  { exact (andER (topology_on X Tx) (C c= X /\ exists U :e Tx, C = X :\: U) HC). }
  claim HD_parts: D c= X /\ exists V :e Tx, D = X :\: V.
  { exact (andER (topology_on X Tx) (D c= X /\ exists V :e Tx, D = X :\: V) HD). }
  claim HC_sub: C c= X.
  { exact (andEL (C c= X) (exists U :e Tx, C = X :\: U) HC_parts). }
  claim HD_sub: D c= X.
  { exact (andEL (D c= X) (exists V :e Tx, D = X :\: V) HD_parts). }
  claim HCex: exists U :e Tx, C = X :\: U.
  { exact (andER (C c= X) (exists U :e Tx, C = X :\: U) HC_parts). }
  claim HDex: exists V :e Tx, D = X :\: V.
  { exact (andER (D c= X) (exists V :e Tx, D = X :\: V) HD_parts). }
  apply andI.
  + (** C  D  X **)
    let x. assume Hx: x :e C :\/: D.
    apply (binunionE C D x Hx).
    * assume HxC: x :e C. exact (HC_sub x HxC).
    * assume HxD: x :e D. exact (HD_sub x HxD).
  + (** exists W :e Tx, C  D = X \ W **)
    apply HCex.
    let U. assume HU_conj: U :e Tx /\ C = X :\: U.
    claim HU: U :e Tx.
    { exact (andEL (U :e Tx) (C = X :\: U) HU_conj). }
    claim HCeq: C = X :\: U.
    { exact (andER (U :e Tx) (C = X :\: U) HU_conj). }
    apply HDex.
    let V. assume HV_conj: V :e Tx /\ D = X :\: V.
    claim HV: V :e Tx.
    { exact (andEL (V :e Tx) (D = X :\: V) HV_conj). }
    claim HDeq: D = X :\: V.
    { exact (andER (V :e Tx) (D = X :\: V) HV_conj). }
    (** Set W = U  V, which is open **)
    set W := U :/\: V.
    claim HW_open: W :e Tx.
    { exact (lemma_intersection_two_open X Tx U V Htop HU HV). }
	    witness W.
	    apply andI.
	    * exact HW_open.
	    * (** Prove C  D = X \ W using De Morgan lemma **)
	      prove C :\/: D = X :\: W.
	      rewrite HCeq.
	      rewrite HDeq.
	      claim HWdef: W = U :/\: V.
	      { reflexivity. }
	      rewrite HWdef.
	      rewrite (setminus_binintersect_eq_binunion X U V).
	      reflexivity.
Qed.

(** Helper: Empty is closed **)
Theorem empty_is_closed : forall X Tx:set,
  topology_on X Tx -> closed_in X Tx Empty.
let X Tx.
assume Htop: topology_on X Tx.
prove closed_in X Tx Empty.
(** Empty = X \ X, and X is open **)
prove topology_on X Tx /\ (Empty c= X /\ exists U :e Tx, Empty = X :\: U).
apply andI.
- exact Htop.
- apply andI.
  + exact (Subq_Empty X).
  + witness X.
    apply andI.
    * exact (topology_has_X X Tx Htop).
    * prove Empty = X :\: X.
      apply set_ext.
      - exact (Subq_Empty (X :\: X)).
      - let x. assume Hx: x :e X :\: X.
        claim HxX: x :e X.
        { exact (setminusE1 X X x Hx). }
        claim HxnotX: x /:e X.
        { exact (setminusE2 X X x Hx). }
        prove x :e Empty.
        apply FalseE.
        exact (HxnotX HxX).
Qed.

(** Helper: X is closed **)
Theorem space_is_closed : forall X Tx:set,
  topology_on X Tx -> closed_in X Tx X.
let X Tx.
assume Htop: topology_on X Tx.
prove closed_in X Tx X.
(** X = X \ Empty, and Empty is open **)
prove topology_on X Tx /\ (X c= X /\ exists U :e Tx, X = X :\: U).
apply andI.
- exact Htop.
- apply andI.
  + exact (Subq_ref X).
  + witness Empty.
    apply andI.
    * exact (topology_has_empty X Tx Htop).
    * prove X = X :\: Empty.
      apply set_ext.
      - let x. assume Hx: x :e X.
        apply setminusI.
        + exact Hx.
        + assume Hcontra: x :e Empty.
          exact (EmptyE x Hcontra False).
      - let x. assume Hx: x :e X :\: Empty.
        exact (setminusE1 X Empty x Hx).
Qed.

(** Helper: binary union as union of pair family **)
Theorem binunion_eq_Union_UPair : forall U V:set, U :\/: V = Union (UPair U V).
let U V.
apply set_ext.
- let x. assume Hx: x :e U :\/: V.
  apply (binunionE U V x Hx).
  + assume HxU: x :e U.
    apply (UnionI (UPair U V) x U HxU).
    exact (UPairI1 U V).
  + assume HxV: x :e V.
    apply (UnionI (UPair U V) x V HxV).
    exact (UPairI2 U V).
- let x. assume Hx: x :e Union (UPair U V).
  apply (UnionE_impred (UPair U V) x Hx (x :e U :\/: V)).
  let Z. assume HxZ: x :e Z. assume HZin: Z :e UPair U V.
  apply (UPairE Z U V HZin).
  + assume HZeqU: Z = U.
    claim HxU: x :e U.
    { rewrite <- HZeqU. exact HxZ. }
    exact (binunionI1 U V x HxU).
  + assume HZeqV: Z = V.
    claim HxV: x :e V.
    { rewrite <- HZeqV. exact HxZ. }
    exact (binunionI2 U V x HxV).
Qed.

(** Helper: union of a pair family equals binary union **)
Theorem Union_UPair_eq_binunion : forall U V:set, Union (UPair U V) = U :\/: V.
let U V.
rewrite (binunion_eq_Union_UPair U V).
reflexivity.
Qed.

(** Helper: Binary union of open sets is open **)
Theorem lemma_union_two_open : forall X T U V:set,
  topology_on X T -> U :e T -> V :e T -> U :\/: V :e T.
let X T U V.
assume HT: topology_on X T.
assume HU: U :e T.
assume HV: V :e T.
prove U :\/: V :e T.
claim HUFamSub: UPair U V c= T.
{ let W. assume HW: W :e UPair U V.
  apply (UPairE W U V HW).
  - assume HWeqU. rewrite HWeqU. exact HU.
  - assume HWeqV. rewrite HWeqV. exact HV. }
claim HUnion: Union (UPair U V) :e T.
{ exact (topology_union_closed X T (UPair U V) HT HUFamSub). }
rewrite <- (Union_UPair_eq_binunion U V).
exact HUnion.
Qed.

(** Helper: intersection of two closed sets is closed **)
Theorem intersection_of_closed_is_closed : forall X Tx C D:set,
  topology_on X Tx -> closed_in X Tx C -> closed_in X Tx D ->
  closed_in X Tx (C :/\: D).
let X Tx C D.
assume Htop: topology_on X Tx.
assume HC: closed_in X Tx C.
assume HD: closed_in X Tx D.
prove closed_in X Tx (C :/\: D).
  (** C = X \\ U and D = X \\ V for some open U,V; then C  D = (X\\U)  (X\\V) = X \\ (U  V) and U  V is open. **)
prove topology_on X Tx /\ (C :/\: D c= X /\ exists W :e Tx, C :/\: D = X :\: W).
apply andI.
- exact Htop.
- claim HC_parts: C c= X /\ exists U :e Tx, C = X :\: U.
  { exact (andER (topology_on X Tx) (C c= X /\ exists U :e Tx, C = X :\: U) HC). }
  claim HD_parts: D c= X /\ exists V :e Tx, D = X :\: V.
  { exact (andER (topology_on X Tx) (D c= X /\ exists V :e Tx, D = X :\: V) HD). }
  claim HC_sub: C c= X.
  { exact (andEL (C c= X) (exists U :e Tx, C = X :\: U) HC_parts). }
  claim HCex: exists U :e Tx, C = X :\: U.
  { exact (andER (C c= X) (exists U :e Tx, C = X :\: U) HC_parts). }
  claim HDex: exists V :e Tx, D = X :\: V.
  { exact (andER (D c= X) (exists V :e Tx, D = X :\: V) HD_parts). }
  apply andI.
  + (** C  D  X **)
    let x. assume Hx: x :e C :/\: D.
    claim HxC: x :e C.
    { exact (binintersectE1 C D x Hx). }
    exact (HC_sub x HxC).
  + (** exists W :e Tx, C  D = X \ W **)
    apply HCex.
    let U. assume HU_conj: U :e Tx /\ C = X :\: U.
    claim HU: U :e Tx.
    { exact (andEL (U :e Tx) (C = X :\: U) HU_conj). }
    claim HCeq: C = X :\: U.
    { exact (andER (U :e Tx) (C = X :\: U) HU_conj). }
    apply HDex.
    let V. assume HV_conj: V :e Tx /\ D = X :\: V.
    claim HV: V :e Tx.
    { exact (andEL (V :e Tx) (D = X :\: V) HV_conj). }
      claim HDeq: D = X :\: V.
      { exact (andER (V :e Tx) (D = X :\: V) HV_conj). }
      (** Set W = U  V, which is open **)
      set W := U :\/: V.
      claim HW_open: W :e Tx.
      { exact (lemma_union_two_open X Tx U V Htop HU HV). }
      witness W.
      apply andI.
      * exact HW_open.
      * (** Prove C  D = X \ W using De Morgan lemma **)
        prove C :/\: D = X :\: W.
	      rewrite HCeq.
	      rewrite HDeq.
	      claim HWdef: W = U :\/: V.
	      { reflexivity. }
	      rewrite HWdef.
	      rewrite <- (setminus_binunion_eq_binintersect X U V).
	      reflexivity.
Qed.

Theorem closed_closure_eq : forall X Tx C:set,
  topology_on X Tx -> closed_in X Tx C -> closure_of X Tx C = C.
let X Tx C.
assume Htop: topology_on X Tx.
assume HC: closed_in X Tx C.
prove closure_of X Tx C = C.
(** closed_in means there exists U :e Tx such that C = X :\: U **)
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (C c= X /\ exists U :e Tx, C = X :\: U) HC). }
claim HCsub_and_ex: C c= X /\ exists U :e Tx, C = X :\: U.
{ exact (andER (topology_on X Tx) (C c= X /\ exists U :e Tx, C = X :\: U) HC). }
claim HCsub: C c= X.
{ exact (andEL (C c= X) (exists U :e Tx, C = X :\: U) HCsub_and_ex). }
apply set_ext.
- (** closure(C)  C **)
  prove closure_of X Tx C c= C.
  (** We show: x  closure(C) implies x  C; otherwise x  X \\ C and X \\ C is open, contradicting that every open neighborhood of x meets C. **)
  let x. assume Hx: x :e closure_of X Tx C.
  prove x :e C.
  (** Use excluded middle **)
  apply (xm (x :e C)).
  + assume HxC: x :e C. exact HxC.
  + assume HxnotC: x /:e C.
    (** Get the open U such that C = X \ U **)
    claim Hex: exists U :e Tx, C = X :\: U.
    { exact (andER (C c= X) (exists U :e Tx, C = X :\: U) HCsub_and_ex). }
    apply Hex.
    let U. assume HU_conj: U :e Tx /\ C = X :\: U.
    claim HU: U :e Tx.
    { exact (andEL (U :e Tx) (C = X :\: U) HU_conj). }
    claim HCeq: C = X :\: U.
    { exact (andER (U :e Tx) (C = X :\: U) HU_conj). }
    (** x  closure(C) means x  X and every open containing x meets C **)
    claim HxX: x :e X.
    { exact (closure_in_space X Tx C Htop x Hx). }
    claim Hcond: forall V:set, V :e Tx -> x :e V -> V :/\: C <> Empty.
    { exact (SepE2 X (fun x0 => forall V:set, V :e Tx -> x0 :e V -> V :/\: C <> Empty) x Hx). }
    (** Since x  C and C = X \ U, we have x  U **)
    claim HxU: x :e U.
    { (** x  X and x  C = X \ U implies x  U **)
      apply (xm (x :e U)).
      - assume H. exact H.
      - assume HxnotU: x /:e U.
        (** Then x  X \ U = C, contradicting x  C **)
        apply HxnotC.
        claim HxXU: x :e X :\: U.
        { apply setminusI. exact HxX. exact HxnotU. }
        rewrite HCeq. exact HxXU. }
    (** Now U is open, x  U, so U  C  Empty by Hcond **)
    claim HUC_ne: U :/\: C <> Empty.
    { exact (Hcond U HU HxU). }
    (** But U  C = Empty since C = X \ U **)
    claim HUC_empty: U :/\: C = Empty.
    { apply set_ext.
      - let y. assume Hy: y :e U :/\: C.
        prove y :e Empty.
        claim HyU: y :e U.
        { exact (binintersectE1 U C y Hy). }
        claim HyC: y :e C.
        { exact (binintersectE2 U C y Hy). }
        (** C = X \ U, so y  C means y  X and y  U **)
        claim HyXU: y :e X :\: U.
        { rewrite <- HCeq. exact HyC. }
        claim HynotU: y /:e U.
        { exact (setminusE2 X U y HyXU). }
        (** Contradiction: y  U and y  U **)
        apply FalseE.
        exact (HynotU HyU).
      - exact (Subq_Empty (U :/\: C)). }
    (** Contradiction **)
    apply FalseE.
    exact (HUC_ne HUC_empty).
- (** C  closure(C) **)
  exact (subset_of_closure X Tx C Htop HCsub).
Qed.

(** Helper: closure of intersection of closed sets **)
Theorem closure_intersection_of_closed : forall X Tx C D:set,
  topology_on X Tx -> closed_in X Tx C -> closed_in X Tx D ->
  closure_of X Tx (C :/\: D) = C :/\: D.
let X Tx C D.
assume Htop: topology_on X Tx.
assume HC: closed_in X Tx C.
assume HD: closed_in X Tx D.
prove closure_of X Tx (C :/\: D) = C :/\: D.
(** Strategy: C  D is closed (by intersection_of_closed_is_closed), so closure(C  D) = C  D **)
claim HCD_closed: closed_in X Tx (C :/\: D).
{ exact (intersection_of_closed_is_closed X Tx C D Htop HC HD). }
claim HCD_sub: C :/\: D c= X.
{ let x. assume Hx: x :e C :/\: D.
  claim HxC: x :e C.
  { exact (binintersectE1 C D x Hx). }
  claim HC_sub: C c= X.
  { exact (andEL (C c= X) (exists U :e Tx, C = X :\: U)
           (andER (topology_on X Tx) (C c= X /\ exists U :e Tx, C = X :\: U) HC)). }
  exact (HC_sub x HxC). }
apply set_ext.
- (** closure(C  D)  C  D **)
  let x. assume Hx: x :e closure_of X Tx (C :/\: D).
  prove x :e C :/\: D.
  rewrite <- (closed_closure_eq X Tx (C :/\: D) Htop HCD_closed).
  exact Hx.
- (** C  D  closure(C  D) **)
  exact (subset_of_closure X Tx (C :/\: D) Htop HCD_sub).
Qed.

(** Helper: closure of union of closed sets **)
Theorem closure_union_of_closed : forall X Tx C D:set,
  topology_on X Tx -> closed_in X Tx C -> closed_in X Tx D ->
  closure_of X Tx (C :\/: D) = C :\/: D.
let X Tx C D.
assume Htop: topology_on X Tx.
assume HC: closed_in X Tx C.
assume HD: closed_in X Tx D.
prove closure_of X Tx (C :\/: D) = C :\/: D.
(** Strategy: C  D is closed (by closed set axioms), so closure(C  D) = C  D **)
(** First need to show C  D is closed, then apply closed_closure_eq **)
(** First prove that union of two closed sets is closed **)
claim HCD_closed: closed_in X Tx (C :\/: D).
{ exact (union_of_closed_is_closed X Tx C D Htop HC HD). }
(** Now prove closure(C  D) = C  D directly **)
claim HCD_sub: C :\/: D c= X.
{ let x. assume Hx: x :e C :\/: D.
  apply (binunionE C D x Hx).
  - assume HxC: x :e C.
    claim HC_sub: C c= X.
    { exact (andEL (C c= X) (exists U :e Tx, C = X :\: U)
             (andER (topology_on X Tx) (C c= X /\ exists U :e Tx, C = X :\: U) HC)). }
    exact (HC_sub x HxC).
  - assume HxD: x :e D.
    claim HD_sub: D c= X.
    { exact (andEL (D c= X) (exists V :e Tx, D = X :\: V)
             (andER (topology_on X Tx) (D c= X /\ exists V :e Tx, D = X :\: V) HD)). }
    exact (HD_sub x HxD). }
(** Prove closure(C  D) = C  D by double inclusion **)
apply set_ext.
- (** closure(C  D)  C  D **)
  (** Since C  D is closed, closure(C  D)  C  D **)
  let x. assume Hx: x :e closure_of X Tx (C :\/: D).
  prove x :e C :\/: D.
  rewrite <- (closed_closure_eq X Tx (C :\/: D) Htop HCD_closed).
  exact Hx.
- (** C  D  closure(C  D) **)
  exact (subset_of_closure X Tx (C :\/: D) Htop HCD_sub).
Qed.

(** Helper: closure is idempotent **)
Theorem closure_idempotent : forall X Tx A:set,
  topology_on X Tx -> A c= X -> closure_of X Tx (closure_of X Tx A) = closure_of X Tx A.
let X Tx A.
assume Htop: topology_on X Tx.
assume HA: A c= X.
prove closure_of X Tx (closure_of X Tx A) = closure_of X Tx A.
(** Strategy: cl(cl(A)) is the closure of a closed set, so equals itself **)
(** Equivalently: cl(A) is closed, and closed sets equal their closure **)
claim HclA_sub: closure_of X Tx A c= X.
{ exact (closure_in_space X Tx A Htop). }
(** To show cl(cl(A)) = cl(A), use that cl(A)  cl(cl(A)) and cl(cl(A))  cl(A) **)
apply set_ext.
- (** cl(cl(A))  cl(A) **)
  (** Since cl(A) is closed, cl(cl(A)) = cl(A), so cl(cl(A))  cl(A) **)
  claim HclA_closed: closed_in X Tx (closure_of X Tx A).
  { exact (closure_is_closed X Tx A Htop HA). }
  claim Heq: closure_of X Tx (closure_of X Tx A) = closure_of X Tx A.
  { exact (closed_closure_eq X Tx (closure_of X Tx A) Htop HclA_closed). }
  let x. assume Hx: x :e closure_of X Tx (closure_of X Tx A).
  rewrite <- Heq.
  exact Hx.
- (** cl(A)  cl(cl(A)) **)
  exact (subset_of_closure X Tx (closure_of X Tx A) Htop HclA_sub).
Qed.

(** Helper: closure of intersection is subset of intersection of closures **)
Theorem closure_intersection_contained : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  closure_of X Tx (A :/\: B) c= closure_of X Tx A :/\: closure_of X Tx B.
let X Tx A B.
assume Htop: topology_on X Tx.
assume HA: A c= X.
assume HB: B c= X.
prove closure_of X Tx (A :/\: B) c= closure_of X Tx A :/\: closure_of X Tx B.
(** Use monotonicity: A  B  A and A  B  B **)
claim HAB_A: A :/\: B c= A.
{ exact (binintersect_Subq_1 A B). }
claim HAB_B: A :/\: B c= B.
{ exact (binintersect_Subq_2 A B). }
claim HAB_X: A :/\: B c= X.
{ let x. assume Hx: x :e A :/\: B.
  exact (HA x (binintersectE1 A B x Hx)). }
claim HclAB_A: closure_of X Tx (A :/\: B) c= closure_of X Tx A.
{ exact (closure_monotone X Tx (A :/\: B) A Htop HAB_A HA). }
claim HclAB_B: closure_of X Tx (A :/\: B) c= closure_of X Tx B.
{ exact (closure_monotone X Tx (A :/\: B) B Htop HAB_B HB). }
let x. assume Hx: x :e closure_of X Tx (A :/\: B).
apply binintersectI.
- exact (HclAB_A x Hx).
- exact (HclAB_B x Hx).
Qed.

(** Helper: closed sets equal their closure **)

(** from 17 Theorem 17.1: properties of closed sets **)
(** LATEX VERSION: Theorem 17.1: Closed sets contain X and , are closed under arbitrary intersections and finite unions. **)
Theorem closed_sets_axioms : forall X T:set,
  topology_on X T ->
  let C := {X :\: U|U :e T} in
    X :e C /\ Empty :e C /\
    (forall F:set, F :e Power C -> intersection_of_family X F :e C) /\
    (forall A B:set, A :e C -> B :e C -> A :\/: B :e C).
let X T.
assume HT: topology_on X T.
prove let C := {X :\: U|U :e T} in
    X :e C /\ Empty :e C /\
    (forall F:set, F :e Power C -> intersection_of_family X F :e C) /\
    (forall A B:set, A :e C -> B :e C -> A :\/: B :e C).
set C := {X :\: U|U :e T}.
prove X :e C /\ Empty :e C /\
    (forall F:set, F :e Power C -> intersection_of_family X F :e C) /\
    (forall A B:set, A :e C -> B :e C -> A :\/: B :e C).
  (** Strategy: Use De Morgan laws and topology axioms: X = X\\,  = X\\X, intersections of complements are complements of unions, and unions of complements are complements of intersections. **)
claim Hempty_in_T: Empty :e T.
{ exact (topology_has_empty X T HT). }
claim HX_in_T: X :e T.
{ exact (topology_has_X X T HT). }
(** Build the 4-way conjunction left-to-right **)
claim Hpart1: X :e C.
{ (** Use ReplEq: need to show exists U :e T such that X = X :\: U **)
  prove X :e {X :\: U|U :e T}.
  apply (ReplEq T (fun U => X :\: U) X).
  assume _ H. apply H.
  witness Empty.
  apply andI.
  * exact Hempty_in_T.
  * prove X = X :\: Empty.
    apply set_ext.
    - let x. assume Hx: x :e X.
      apply setminusI.
      + exact Hx.
      + assume Hcontra: x :e Empty.
        exact (EmptyE x Hcontra False).
    - let x. assume Hx: x :e X :\: Empty.
      exact (setminusE1 X Empty x Hx). }
claim Hpart2: X :e C /\ Empty :e C.
{ apply andI.
  - exact Hpart1.
  - prove Empty :e {X :\: U|U :e T}.
    apply (ReplEq T (fun U => X :\: U) Empty).
    assume _ H. apply H.
    witness X.
    apply andI.
    * exact HX_in_T.
    * prove Empty = X :\: X.
      apply set_ext.
      - let x. assume Hx: x :e Empty.
        exact (EmptyE x Hx (x :e X :\: X)).
      - let x. assume Hx: x :e X :\: X.
        claim HxX: x :e X.
        { exact (setminusE1 X X x Hx). }
        claim HxnotX: x /:e X.
        { exact (setminusE2 X X x Hx). }
        apply FalseE.
        exact (HxnotX HxX).
}
claim Hpart3: (X :e C /\ Empty :e C) /\ (forall F:set, F :e Power C -> intersection_of_family X F :e C).
{ apply andI.
  - exact Hpart2.
  - (** Arbitrary intersections: (X\U) = X \ (U) **)
    let F. assume HF: F :e Power C.
    prove intersection_of_family X F :e C.
    (** Handle empty case separately **)
    apply (xm (F = Empty)).
    + assume HFempty: F = Empty.
      (** With new definition:  = X since all x in X vacuously satisfy "forall U :e Empty, x :e U" **)
      claim Hintersect_empty: intersection_of_family X F = X.
      { rewrite HFempty.
        (** intersection_of_family X  = {x :e X | forall U :e , x :e U} = X since condition is vacuous **)
        apply set_ext.
        - let x. assume Hx: x :e intersection_of_family X Empty.
          exact (SepE1 X (fun y => forall U0:set, U0 :e Empty -> y :e U0) x Hx).
        - let x. assume Hx: x :e X.
          (** Show x :e intersection_of_family X Empty **)
          claim Hvacuous: forall U0:set, U0 :e Empty -> x :e U0.
          { let U0. assume HU: U0 :e Empty.
            apply FalseE.
            exact (EmptyE U0 HU).
          }
          exact (SepI X (fun y => forall U0:set, U0 :e Empty -> y :e U0) x Hx Hvacuous).
      }
      rewrite Hintersect_empty.
      exact (andEL (X :e C) (Empty :e C) Hpart2).
    + assume HFnonempty: F <> Empty.
      (** Extract the family of open sets: G = {U :e T | X \ U :e F} **)
      set G := {U :e T | X :\: U :e F}.
      (** Show F = X \ G **)
      prove intersection_of_family X F :e {X :\: U|U :e T}.
    apply (ReplEq T (fun U => X :\: U) (intersection_of_family X F)).
    assume _ H. apply H.
    witness (Union G).
    apply andI.
    * (** G :e T **)
      claim HGsub: G c= T.
      { let U. assume HU: U :e G.
        exact (SepE1 T (fun U0 => X :\: U0 :e F) U HU). }
      exact (topology_union_closed X T G HT HGsub).
    * (** F = X \ G by De Morgan **)
      prove intersection_of_family X F = X :\: Union G.
      apply set_ext.
      - (** F  X \ G **)
        let x. assume Hx: x :e intersection_of_family X F.
        prove x :e X :\: Union G.
        apply setminusI.
        + (** x  X: directly from new definition of intersection_of_family X F **)
          exact (SepE1 X (fun y => forall U0:set, U0 :e F -> y :e U0) x Hx).
        + (** x  G **)
          assume Hcontra: x :e Union G.
          apply (UnionE_impred G x Hcontra).
          let U. assume HxU: x :e U. assume HUG: U :e G.
          claim HXminusU_in_F: X :\: U :e F.
          { exact (SepE2 T (fun U0 => X :\: U0 :e F) U HUG). }
          claim Hxall: forall Y :e F, x :e Y.
          { exact (SepE2 X (fun y => forall U0:set, U0 :e F -> y :e U0) x Hx). }
          claim Hx_in_XminusU: x :e X :\: U.
          { exact (Hxall (X :\: U) HXminusU_in_F). }
          claim HxnotU: x /:e U.
          { exact (setminusE2 X U x Hx_in_XminusU). }
          exact (HxnotU HxU).
      - (** X \ G  F **)
        let x. assume Hx: x :e X :\: Union G.
        prove x :e intersection_of_family X F.
        claim HxX: x :e X.
        { exact (setminusE1 X (Union G) x Hx). }
        claim HxnotUG: x /:e Union G.
        { exact (setminusE2 X (Union G) x Hx). }
        (** Show x  X and forall Y :e F, x :e Y **)
        prove x :e {y :e X|forall U0:set, U0 :e F -> y :e U0}.
        apply SepI.
        + (** x  X: already have this **)
          exact HxX.
        + (** forall Y :e F, x :e Y **)
          let Y. assume HYF: Y :e F.
          prove x :e Y.
          claim HYC: Y :e C.
          { exact (PowerE C F HF Y HYF). }
          apply (ReplE T (fun U => X :\: U) Y HYC).
          let U. assume H. apply H.
          assume HU: U :e T. assume HYeq: Y = X :\: U.
          claim HUG: U :e G.
          { apply SepI.
            - exact HU.
            - prove X :\: U :e F.
              rewrite <- HYeq. exact HYF. }
          claim HxnotU: x /:e U.
          { assume Hcontra: x :e U.
            apply HxnotUG.
            exact (UnionI G x U Hcontra HUG). }
          rewrite HYeq.
          apply setminusI.
          * exact HxX.
          * exact HxnotU.
}
apply andI.
- exact Hpart3.
- (** Binary unions: (X\U)  (X\V) = X \ (U  V) **)
  let A B. assume HA: A :e C. assume HB: B :e C.
  prove A :\/: B :e C.
  (** A = X \ U for some U  T **)
  apply (ReplE T (fun U => X :\: U) A HA).
  let U. assume H1. apply H1.
  assume HU: U :e T. assume HAeq: A = X :\: U.
  (** B = X \ V for some V  T **)
  apply (ReplE T (fun U => X :\: U) B HB).
  let V. assume H2. apply H2.
  assume HV: V :e T. assume HBeq: B = X :\: V.
  (** Show A  B = X \ (U  V) and U  V  T **)
  prove A :\/: B :e {X :\: W|W :e T}.
  apply (ReplEq T (fun W => X :\: W) (A :\/: B)).
  assume _ H. apply H.
  witness (U :/\: V).
  apply andI.
  * (** U  V  T **)
    exact (topology_binintersect_closed X T U V HT HU HV).
  * (** A  B = X \ (U  V) by De Morgan **)
    prove A :\/: B = X :\: (U :/\: V).
    rewrite HAeq. rewrite HBeq.
    apply set_ext.
    + (** (X\U)  (X\V)  X \ (U  V) **)
      let x. assume Hx: x :e (X :\: U) :\/: (X :\: V).
      apply (binunionE (X :\: U) (X :\: V) x Hx).
      - assume HxA: x :e X :\: U.
        claim HxX: x :e X.
        { exact (setminusE1 X U x HxA). }
        claim HxnotU: x /:e U.
        { exact (setminusE2 X U x HxA). }
        apply setminusI.
        * exact HxX.
        * assume Hcontra: x :e U :/\: V.
          claim HxU: x :e U.
          { exact (binintersectE1 U V x Hcontra). }
          exact (HxnotU HxU).
      - assume HxB: x :e X :\: V.
        claim HxX: x :e X.
        { exact (setminusE1 X V x HxB). }
        claim HxnotV: x /:e V.
        { exact (setminusE2 X V x HxB). }
        apply setminusI.
        * exact HxX.
        * assume Hcontra: x :e U :/\: V.
          claim HxV: x :e V.
          { exact (binintersectE2 U V x Hcontra). }
          exact (HxnotV HxV).
    + (** X \ (U  V)  (X\U)  (X\V) **)
      let x. assume Hx: x :e X :\: (U :/\: V).
      claim HxX: x :e X.
      { exact (setminusE1 X (U :/\: V) x Hx). }
      claim HxnotUV: x /:e U :/\: V.
      { exact (setminusE2 X (U :/\: V) x Hx). }
      (** x  U  V means x  U or x  V **)
      apply (xm (x :e U)).
      - assume HxU: x :e U.
        (** Then x  V, so x  X \ V **)
        claim HxnotV: x /:e V.
        { assume HxV: x :e V.
          apply HxnotUV.
          exact (binintersectI U V x HxU HxV). }
        apply binunionI2.
        exact (setminusI X V x HxX HxnotV).
      - assume HxnotU: x /:e U.
        (** Then x  X \ U **)
        apply binunionI1.
        exact (setminusI X U x HxX HxnotU).
Qed.

(** from 17 Theorem 17.2: closed sets in subspaces as intersections **) 
(** LATEX VERSION: Closed sets in a subspace are precisely intersections of the subspace with closed sets of the ambient space. **)
Theorem closed_in_subspace_iff_intersection : forall X Tx Y A:set,
  topology_on X Tx -> Y c= X ->
  (closed_in Y (subspace_topology X Tx Y) A <->
   exists C:set, closed_in X Tx C /\ A = C :/\: Y).
let X Tx Y A.
assume HTx: topology_on X Tx.
assume HY: Y c= X.
prove closed_in Y (subspace_topology X Tx Y) A <-> exists C:set, closed_in X Tx C /\ A = C :/\: Y.
apply iffI.
- assume HAclosed: closed_in Y (subspace_topology X Tx Y) A.
  prove exists C:set, closed_in X Tx C /\ A = C :/\: Y.
  claim HTsubspace: topology_on Y (subspace_topology X Tx Y).
  { exact (subspace_topology_is_topology X Tx Y HTx HY). }
  claim HAdef: topology_on Y (subspace_topology X Tx Y) /\ (A c= Y /\ exists U :e subspace_topology X Tx Y, A = Y :\: U).
  { exact HAclosed. }
  claim HAandEx: A c= Y /\ exists U :e subspace_topology X Tx Y, A = Y :\: U.
  { exact (andER (topology_on Y (subspace_topology X Tx Y)) (A c= Y /\ exists U :e subspace_topology X Tx Y, A = Y :\: U) HAdef). }
  claim HexU: exists U :e subspace_topology X Tx Y, A = Y :\: U.
  { exact (andER (A c= Y) (exists U :e subspace_topology X Tx Y, A = Y :\: U) HAandEx). }
  apply HexU.
  let U. assume HandEq. apply HandEq.
  assume HUsubspace: U :e subspace_topology X Tx Y.
  assume HAeq: A = Y :\: U.
  claim HUexV: exists V :e Tx, U = V :/\: Y.
  { exact (SepE2 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HUsubspace). }
  apply HUexV.
  let V. assume HVandEq. apply HVandEq.
  assume HV: V :e Tx. assume HUeq: U = V :/\: Y.
  set C := X :\: V.
  claim HCclosed: closed_in X Tx C.
  { prove topology_on X Tx /\ (C c= X /\ exists W :e Tx, C = X :\: W).
    apply andI.
    - exact HTx.
    - apply andI.
      + exact (setminus_Subq X V).
      + witness V.
        apply andI.
        * exact HV.
        * reflexivity.
  }
  claim HAeqC: A = C :/\: Y.
  { rewrite HAeq.
    rewrite HUeq.
    prove Y :\: (V :/\: Y) = (X :\: V) :/\: Y.
    apply set_ext.
    - let x. assume Hx: x :e Y :\: (V :/\: Y).
      claim HxY: x :e Y.
      { exact (setminusE1 Y (V :/\: Y) x Hx). }
      claim HxnotVY: x /:e V :/\: Y.
      { exact (setminusE2 Y (V :/\: Y) x Hx). }
      claim HxnotV: x /:e V.
      { assume HxV: x :e V.
        apply HxnotVY.
        apply binintersectI.
        - exact HxV.
        - exact HxY.
      }
      claim HxX: x :e X.
      { exact (HY x HxY). }
      apply binintersectI.
      + apply setminusI.
        * exact HxX.
        * exact HxnotV.
      + exact HxY.
    - let x. assume Hx: x :e (X :\: V) :/\: Y.
      claim HxXV: x :e X :\: V.
      { exact (binintersectE1 (X :\: V) Y x Hx). }
      claim HxY: x :e Y.
      { exact (binintersectE2 (X :\: V) Y x Hx). }
      claim HxnotV: x /:e V.
      { exact (setminusE2 X V x HxXV). }
      apply setminusI.
      + exact HxY.
      + assume HxVY: x :e V :/\: Y.
        apply HxnotV.
        exact (binintersectE1 V Y x HxVY).
  }
  witness C.
  apply andI.
  - exact HCclosed.
  - exact HAeqC.
- assume Hexists: exists C:set, closed_in X Tx C /\ A = C :/\: Y.
  prove closed_in Y (subspace_topology X Tx Y) A.
  apply Hexists.
  let C. assume HCandEq. apply HCandEq.
  assume HCclosed: closed_in X Tx C.
  assume HAeq: A = C :/\: Y.
  claim HTsubspace: topology_on Y (subspace_topology X Tx Y).
  { exact (subspace_topology_is_topology X Tx Y HTx HY). }
  claim HCdef: topology_on X Tx /\ (C c= X /\ exists V :e Tx, C = X :\: V).
  { exact HCclosed. }
  claim HCandEx: C c= X /\ exists V :e Tx, C = X :\: V.
  { exact (andER (topology_on X Tx) (C c= X /\ exists V :e Tx, C = X :\: V) HCdef). }
  claim HexV: exists V :e Tx, C = X :\: V.
  { exact (andER (C c= X) (exists V :e Tx, C = X :\: V) HCandEx). }
  apply HexV.
  let V. assume HVandEq. apply HVandEq.
  assume HV: V :e Tx. assume HCeq: C = X :\: V.
  set U := V :/\: Y.
  claim HUsubspace: U :e subspace_topology X Tx Y.
  { claim HUinPowerY: U :e Power Y.
    { apply PowerI.
      exact (binintersect_Subq_2 V Y). }
    claim HPred: exists W :e Tx, U = W :/\: Y.
    { witness V.
      apply andI.
      - exact HV.
      - reflexivity.
    }
    exact (SepI (Power Y) (fun U0:set => exists W :e Tx, U0 = W :/\: Y) U HUinPowerY HPred).
  }
  claim HAeqYU: A = Y :\: U.
  { rewrite HAeq.
    rewrite HCeq.
    prove (X :\: V) :/\: Y = Y :\: (V :/\: Y).
    apply set_ext.
    - let x. assume Hx: x :e (X :\: V) :/\: Y.
      claim HxXV: x :e X :\: V.
      { exact (binintersectE1 (X :\: V) Y x Hx). }
      claim HxY: x :e Y.
      { exact (binintersectE2 (X :\: V) Y x Hx). }
      claim HxnotV: x /:e V.
      { exact (setminusE2 X V x HxXV). }
      apply setminusI.
      + exact HxY.
      + assume HxVY: x :e V :/\: Y.
        apply HxnotV.
        exact (binintersectE1 V Y x HxVY).
    - let x. assume Hx: x :e Y :\: (V :/\: Y).
      claim HxY: x :e Y.
      { exact (setminusE1 Y (V :/\: Y) x Hx). }
      claim HxnotVY: x /:e V :/\: Y.
      { exact (setminusE2 Y (V :/\: Y) x Hx). }
      claim HxnotV: x /:e V.
      { assume HxV: x :e V.
        apply HxnotVY.
        apply binintersectI.
        - exact HxV.
        - exact HxY.
      }
      claim HxX: x :e X.
      { exact (HY x HxY). }
      apply binintersectI.
      + apply setminusI.
        * exact HxX.
        * exact HxnotV.
      + exact HxY.
  }
  claim HAsub: A c= Y.
  { rewrite HAeq.
    exact (binintersect_Subq_2 C Y). }
  prove topology_on Y (subspace_topology X Tx Y) /\ (A c= Y /\ exists U :e subspace_topology X Tx Y, A = Y :\: U).
  apply andI.
  - exact HTsubspace.
  - apply andI.
    + exact HAsub.
    + witness U.
      apply andI.
      * exact HUsubspace.
      * exact HAeqYU.
Qed.

(** from 17 Theorem 17.3: closedness passes up when subspace is closed **) 
(** LATEX VERSION: If Y is closed in X, a set closed in the subspace Y is closed in X. **)
Theorem closed_in_closed_subspace : forall X Tx Y A:set,
  topology_on X Tx -> closed_in X Tx Y ->
  closed_in Y (subspace_topology X Tx Y) A ->
  closed_in X Tx A.
let X Tx Y A.
assume HTx: topology_on X Tx.
assume HY: closed_in X Tx Y.
assume HA: closed_in Y (subspace_topology X Tx Y) A.
prove closed_in X Tx A.
  (** Strategy: A = C  Y with C closed in X; write C = X\\U and Y = X\\V, then A = X\\(UV) and UV is open. **)
claim HYsub: Y c= X.
{ exact (andEL (Y c= X) (exists U :e Tx, Y = X :\: U) (andER (topology_on X Tx) (Y c= X /\ exists U :e Tx, Y = X :\: U) HY)). }
claim Hexists: exists C:set, closed_in X Tx C /\ A = C :/\: Y.
{ apply (iffEL (closed_in Y (subspace_topology X Tx Y) A) (exists C:set, closed_in X Tx C /\ A = C :/\: Y) (closed_in_subspace_iff_intersection X Tx Y A HTx HYsub)).
  exact HA. }
apply Hexists.
let C.
assume HCandA: closed_in X Tx C /\ A = C :/\: Y.
claim HCclosed: closed_in X Tx C.
{ exact (andEL (closed_in X Tx C) (A = C :/\: Y) HCandA). }
claim HAeq: A = C :/\: Y.
{ exact (andER (closed_in X Tx C) (A = C :/\: Y) HCandA). }
(** C is closed in X, so C = X \ U for some U  Tx **)
claim HCexists: exists U :e Tx, C = X :\: U.
{ exact (andER (C c= X) (exists U :e Tx, C = X :\: U) (andER (topology_on X Tx) (C c= X /\ exists U :e Tx, C = X :\: U) HCclosed)). }
apply HCexists.
let U.
assume HU: U :e Tx /\ C = X :\: U.
claim HUinTx: U :e Tx.
{ exact (andEL (U :e Tx) (C = X :\: U) HU). }
claim HCeq: C = X :\: U.
{ exact (andER (U :e Tx) (C = X :\: U) HU). }
(** Y is closed in X, so Y = X \ V for some V  Tx **)
claim HYexists: exists V :e Tx, Y = X :\: V.
{ exact (andER (Y c= X) (exists V :e Tx, Y = X :\: V) (andER (topology_on X Tx) (Y c= X /\ exists V :e Tx, Y = X :\: V) HY)). }
apply HYexists.
let V.
assume HV: V :e Tx /\ Y = X :\: V.
claim HVinTx: V :e Tx.
{ exact (andEL (V :e Tx) (Y = X :\: V) HV). }
claim HYeq: Y = X :\: V.
{ exact (andER (V :e Tx) (Y = X :\: V) HV). }
(** Now A = C  Y = (X\U)  (X\V) = X \ (UV) **)
claim HAeqSetminus: A = (X :\: U) :/\: (X :\: V).
{ rewrite HAeq.
  rewrite HCeq.
  rewrite HYeq.
  reflexivity. }
(** Prove (X\U)  (X\V) = X \ (UV) by set extensionality **)
claim HDeM: (X :\: U) :/\: (X :\: V) = X :\: (U :\/: V).
{ apply set_ext.
  - let x.
    assume Hx: x :e (X :\: U) :/\: (X :\: V).
    prove x :e X :\: (U :\/: V).
    claim HxXU: x :e X :\: U.
    { exact (binintersectE1 (X :\: U) (X :\: V) x Hx). }
    claim HxXV: x :e X :\: V.
    { exact (binintersectE2 (X :\: U) (X :\: V) x Hx). }
    claim HxX: x :e X.
    { exact (setminusE1 X U x HxXU). }
    claim HxninU: x /:e U.
    { exact (setminusE2 X U x HxXU). }
    claim HxninV: x /:e V.
    { exact (setminusE2 X V x HxXV). }
    apply setminusI.
    + exact HxX.
    + assume HxUV: x :e U :\/: V.
      prove False.
      apply (binunionE U V x HxUV).
      * assume HxU: x :e U.
        exact (HxninU HxU).
      * assume HxV: x :e V.
        exact (HxninV HxV).
  - let x.
    assume Hx: x :e X :\: (U :\/: V).
    prove x :e (X :\: U) :/\: (X :\: V).
    claim HxX: x :e X.
    { exact (setminusE1 X (U :\/: V) x Hx). }
    claim HxninUV: x /:e U :\/: V.
    { exact (setminusE2 X (U :\/: V) x Hx). }
    apply binintersectI.
    + prove x :e X :\: U.
      apply setminusI.
      * exact HxX.
      * assume HxU: x :e U.
        prove False.
        claim HxUV: x :e U :\/: V.
        { exact (binunionI1 U V x HxU). }
        exact (HxninUV HxUV).
    + prove x :e X :\: V.
      apply setminusI.
      * exact HxX.
      * assume HxV: x :e V.
        prove False.
        claim HxUV: x :e U :\/: V.
        { exact (binunionI2 U V x HxV). }
        exact (HxninUV HxUV). }
(** So A = X \ (UV), and since U,V  Tx, we have UV  Tx **)
  claim HUV: U :\/: V :e Tx.
  { exact (lemma_union_two_open X Tx U V HTx HUinTx HVinTx). }
  (** Now A = X \ (UV) where UV  Tx **)
  claim HAeqFinal: A = X :\: (U :\/: V).
  { rewrite HAeqSetminus.
    exact HDeM. }
(** Therefore A is closed in X **)
prove topology_on X Tx /\ (A c= X /\ exists U0 :e Tx, A = X :\: U0).
apply andI.
- exact HTx.
- apply andI.
  + prove A c= X.
    rewrite HAeqFinal.
    exact (setminus_Subq X (U :\/: V)).
  + prove exists U0 :e Tx, A = X :\: U0.
    witness (U :\/: V).
    apply andI.
    * exact HUV.
    * exact HAeqFinal.
Qed.

(** from 17 Theorem 17.4: closure in subspace equals intersection **)
(** LATEX VERSION: Closure in a subspace equals the ambient closure intersected with the subspace. **)
Theorem closure_in_subspace : forall X Tx Y A:set,
  topology_on X Tx -> Y c= X -> A c= Y ->
  closure_of Y (subspace_topology X Tx Y) A = (closure_of X Tx A) :/\: Y.
let X Tx Y A.
assume HTx: topology_on X Tx.
assume HY: Y c= X.
assume HA: A c= Y.
prove closure_of Y (subspace_topology X Tx Y) A = (closure_of X Tx A) :/\: Y.
claim HTy: topology_on Y (subspace_topology X Tx Y).
{ exact (subspace_topology_is_topology X Tx Y HTx HY). }
apply set_ext.
- (** closure_of Y (subspace_topology X Tx Y) A c= (closure_of X Tx A) :/\: Y **)
  let y. assume Hy: y :e closure_of Y (subspace_topology X Tx Y) A.
  prove y :e (closure_of X Tx A) :/\: Y.
  claim HyY: y :e Y.
  { exact (SepE1 Y (fun y0 => forall U:set, U :e subspace_topology X Tx Y -> y0 :e U -> U :/\: A <> Empty) y Hy). }
  claim HysubCond: forall U:set, U :e subspace_topology X Tx Y -> y :e U -> U :/\: A <> Empty.
  { exact (SepE2 Y (fun y0 => forall U:set, U :e subspace_topology X Tx Y -> y0 :e U -> U :/\: A <> Empty) y Hy). }
  apply binintersectI.
  + (** y :e closure_of X Tx A **)
    prove y :e closure_of X Tx A.
    claim HyX: y :e X.
    { exact (HY y HyY). }
    claim HyCond: forall V:set, V :e Tx -> y :e V -> V :/\: A <> Empty.
    { let V. assume HV: V :e Tx. assume HyV: y :e V.
      prove V :/\: A <> Empty.
      set U := V :/\: Y.
      claim HU: U :e subspace_topology X Tx Y.
      { claim HUinPower: U :e Power Y.
        { apply PowerI. exact (binintersect_Subq_2 V Y). }
        claim HPred: exists W :e Tx, U = W :/\: Y.
        { witness V. apply andI. exact HV. reflexivity. }
        exact (SepI (Power Y) (fun U0 => exists W :e Tx, U0 = W :/\: Y) U HUinPower HPred). }
      claim HyU: y :e U.
      { apply binintersectI. exact HyV. exact HyY. }
      claim HUA_ne: U :/\: A <> Empty.
      { exact (HysubCond U HU HyU). }
      prove V :/\: A <> Empty.
      assume HVA_empty: V :/\: A = Empty.
      claim HUA_sub_VA: U :/\: A c= V :/\: A.
      { let z. assume Hz: z :e U :/\: A.
        claim HzU: z :e U.
        { exact (binintersectE1 U A z Hz). }
        claim HzV: z :e V.
        { exact (binintersectE1 V Y z HzU). }
        claim HzA: z :e A.
        { exact (binintersectE2 U A z Hz). }
        exact (binintersectI V A z HzV HzA). }
      claim HUA_sub_Empty: U :/\: A c= Empty.
      { rewrite <- HVA_empty. exact HUA_sub_VA. }
      claim HUA_empty: U :/\: A = Empty.
      { exact (Empty_Subq_eq (U :/\: A) HUA_sub_Empty). }
      exact (HUA_ne HUA_empty). }
    exact (SepI X (fun y0 => forall V:set, V :e Tx -> y0 :e V -> V :/\: A <> Empty) y HyX HyCond).
  + exact HyY.
- (** (closure_of X Tx A) :/\: Y c= closure_of Y (subspace_topology X Tx Y) A **)
  let y. assume Hy: y :e (closure_of X Tx A) :/\: Y.
  prove y :e closure_of Y (subspace_topology X Tx Y) A.
  claim HyClX: y :e closure_of X Tx A.
  { exact (binintersectE1 (closure_of X Tx A) Y y Hy). }
  claim HyY: y :e Y.
  { exact (binintersectE2 (closure_of X Tx A) Y y Hy). }
  claim HyXCond: forall V:set, V :e Tx -> y :e V -> V :/\: A <> Empty.
  { exact (SepE2 X (fun y0 => forall V:set, V :e Tx -> y0 :e V -> V :/\: A <> Empty) y HyClX). }
  claim HySubCond: forall U:set, U :e subspace_topology X Tx Y -> y :e U -> U :/\: A <> Empty.
  { let U. assume HU: U :e subspace_topology X Tx Y. assume HyU: y :e U.
    prove U :/\: A <> Empty.
    claim HUex: exists V :e Tx, U = V :/\: Y.
    { exact (SepE2 (Power Y) (fun U0 => exists V :e Tx, U0 = V :/\: Y) U HU). }
    apply HUex.
    let V. assume HVandEq. apply HVandEq.
    assume HV: V :e Tx. assume HUeq: U = V :/\: Y.
    claim HyV: y :e V.
    { claim HyVY: y :e V :/\: Y.
      { rewrite <- HUeq. exact HyU. }
      exact (binintersectE1 V Y y HyVY). }
    claim HVA_ne: V :/\: A <> Empty.
    { exact (HyXCond V HV HyV). }
    rewrite HUeq.
    prove (V :/\: Y) :/\: A <> Empty.
    assume HVYAempty: (V :/\: Y) :/\: A = Empty.
    (** If (V  Y)  A is empty but V  A is nonempty, we derive a contradiction using A  Y to move a witness into Y. **)
    claim HVA_sub_VYA: V :/\: (Y :/\: A) c= V :/\: A.
    { let z. assume Hz: z :e V :/\: (Y :/\: A).
      claim HzV: z :e V.
      { exact (binintersectE1 V (Y :/\: A) z Hz). }
      claim HzYA: z :e Y :/\: A.
      { exact (binintersectE2 V (Y :/\: A) z Hz). }
      claim HzA: z :e A.
      { exact (binintersectE2 Y A z HzYA). }
      exact (binintersectI V A z HzV HzA). }
    claim HVYAeq: V :/\: (Y :/\: A) = (V :/\: Y) :/\: A.
    { apply set_ext.
      - let z. assume Hz: z :e V :/\: (Y :/\: A).
        claim HzV: z :e V.
        { exact (binintersectE1 V (Y :/\: A) z Hz). }
        claim HzYA: z :e Y :/\: A.
        { exact (binintersectE2 V (Y :/\: A) z Hz). }
        claim HzY: z :e Y.
        { exact (binintersectE1 Y A z HzYA). }
        claim HzA: z :e A.
        { exact (binintersectE2 Y A z HzYA). }
        claim HzVY: z :e V :/\: Y.
        { exact (binintersectI V Y z HzV HzY). }
        exact (binintersectI (V :/\: Y) A z HzVY HzA).
      - let z. assume Hz: z :e (V :/\: Y) :/\: A.
        claim HzVY: z :e V :/\: Y.
        { exact (binintersectE1 (V :/\: Y) A z Hz). }
        claim HzV: z :e V.
        { exact (binintersectE1 V Y z HzVY). }
        claim HzY: z :e Y.
        { exact (binintersectE2 V Y z HzVY). }
        claim HzA: z :e A.
        { exact (binintersectE2 (V :/\: Y) A z Hz). }
        claim HzYA: z :e Y :/\: A.
        { exact (binintersectI Y A z HzY HzA). }
        exact (binintersectI V (Y :/\: A) z HzV HzYA). }
    claim HVYAempty2: V :/\: (Y :/\: A) = Empty.
    { rewrite HVYAeq. exact HVYAempty. }
    (** We know V  A is nonempty; to contradict emptiness of V  (Y  A) we need a witness in A to also lie in Y (using A  Y). **)
    (** Key issue: need A  Y (or restate with A  Y) so that a witness w  A is also in Y. **)
    (** Alternative: use y :e closure implies y in closure of A :/\: Y **)
    (** Since we have V :/\: A <> Empty, pick witness w **)
    claim Hex_w: exists w:set, w :e V :/\: A.
    { apply (dneg (exists w:set, w :e V :/\: A)).
      assume Hnot: ~(exists w:set, w :e V :/\: A).
      claim HVAempty: V :/\: A = Empty.
      { apply Empty_Subq_eq.
        let w. assume Hw: w :e V :/\: A.
        apply FalseE.
        apply Hnot.
        witness w. exact Hw.
      }
      exact (HVA_ne HVAempty).
    }
    apply Hex_w.
    let w. assume Hw: w :e V :/\: A.
    (** w :e V and w :e A. Since A c= Y, we have w :e Y, so w :e V :/\: (Y :/\: A), contradicting HVYAempty2. **)
    claim HwV: w :e V.
    { exact (binintersectE1 V A w Hw). }
    claim HwA: w :e A.
    { exact (binintersectE2 V A w Hw). }
    claim HwY: w :e Y.
    { exact (HA w HwA). }
    claim HwYA: w :e Y :/\: A.
    { exact (binintersectI Y A w HwY HwA). }
    claim HwVYA: w :e V :/\: (Y :/\: A).
    { exact (binintersectI V (Y :/\: A) w HwV HwYA). }
    claim HVYAnonempty: V :/\: (Y :/\: A) <> Empty.
    { assume HVYAempty_contra: V :/\: (Y :/\: A) = Empty.
      claim Hwempty: w :e Empty.
      { rewrite <- HVYAempty_contra. exact HwVYA. }
      exact (EmptyE w Hwempty False). }
    exact (HVYAnonempty HVYAempty2).
    }
  exact (SepI Y (fun y0 => forall U:set, U :e subspace_topology X Tx Y -> y0 :e U -> U :/\: A <> Empty) y HyY HySubCond).
Qed.

(** from 17 Theorem 17.5: closure via neighborhoods/basis **) 
(** LATEX VERSION: Characterization of closure: x is in closure of A iff every open neighborhood of x meets A. **)
Theorem closure_characterization : forall X Tx A x:set,
  topology_on X Tx -> x :e X ->
  (x :e closure_of X Tx A <-> (forall U :e Tx, x :e U -> U :/\: A <> Empty)).
let X Tx A x.
assume HTx: topology_on X Tx.
assume HxX: x :e X.
prove x :e closure_of X Tx A <-> (forall U :e Tx, x :e U -> U :/\: A <> Empty).
(** Strategy: unfold definition of closure_of using SepE and SepI **)
apply iffI.
- assume Hx: x :e closure_of X Tx A.
  prove forall U :e Tx, x :e U -> U :/\: A <> Empty.
  (** closure_of X Tx A = {x :e X | forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty} **)
  exact (SepE2 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx).
- assume Hcond: forall U :e Tx, x :e U -> U :/\: A <> Empty.
  prove x :e closure_of X Tx A.
  (** Have x :e X as hypothesis; just need to apply SepI with x and the condition **)
  exact (SepI X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x HxX Hcond).
Qed.

(** from 17 Corollary 17.7: closed iff contains all limit points **) 
(** LATEX VERSION: Limit point x of A means every neighborhood of x contains a point of A different from x; closure equals A plus its limit points. **)
Definition limit_point_of : set -> set -> set -> set -> prop := fun X Tx A x =>
  topology_on X Tx /\ x :e X /\
  forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
Definition limit_points_of : set -> set -> set -> set := fun X Tx A => {x :e X|limit_point_of X Tx A x}.

(** LATEX VERSION: Corollary 17.7: The closure of A equals A together with all its limit points. **)
Theorem closure_equals_set_plus_limit_points : forall X Tx A:set,
  topology_on X Tx -> A c= X ->
  closure_of X Tx A = A :\/: limit_points_of X Tx A.
let X Tx A.
assume HTx: topology_on X Tx.
assume HA: A c= X.
prove closure_of X Tx A = A :\/: limit_points_of X Tx A.
  (** Strategy: cl(A) = A  lim(A) by double inclusion: A  cl(A), lim(A)  cl(A), and if x  cl(A) with x  A then x is a limit point. **)
apply set_ext.
- (** cl(A)  A  lim(A) **)
  let x. assume Hx: x :e closure_of X Tx A.
  prove x :e A :\/: limit_points_of X Tx A.
  apply (xm (x :e A)).
  + assume HxA: x :e A.
    apply binunionI1.
    exact HxA.
  + assume HxnotA: x /:e A.
    (** Show x is a limit point **)
    apply binunionI2.
    prove x :e limit_points_of X Tx A.
    prove x :e {y :e X|limit_point_of X Tx A y}.
    claim HxX: x :e X.
    { exact (closure_in_space X Tx A HTx x Hx). }
    claim Hcond: forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
    { exact (SepE2 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx). }
    apply SepI.
    * exact HxX.
    * prove limit_point_of X Tx A x.
      prove topology_on X Tx /\ x :e X /\ forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
      apply andI.
      - apply andI.
        + exact HTx.
        + exact HxX.
      - prove forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
          let U. assume HU: U :e Tx. assume HxU: x :e U.
          prove exists y:set, y :e A /\ y <> x /\ y :e U.
          claim HUne: U :/\: A <> Empty.
          { exact (Hcond U HU HxU). }
          claim Hexists: exists y:set, y :e U :/\: A.
          { apply (xm (exists y:set, y :e U :/\: A)).
            - assume H. exact H.
            - assume Hnoex: ~(exists y:set, y :e U :/\: A).
              apply FalseE.
              apply HUne.
              apply set_ext.
              + let y. assume Hy: y :e U :/\: A.
                apply FalseE.
                apply Hnoex.
                witness y. exact Hy.
              + exact (Subq_Empty (U :/\: A)). }
          apply Hexists.
          let y. assume Hy: y :e U :/\: A.
          witness y.
          claim HyU: y :e U.
          { exact (binintersectE1 U A y Hy). }
          claim HyA: y :e A.
          { exact (binintersectE2 U A y Hy). }
          prove y :e A /\ y <> x /\ y :e U.
          apply andI.
          - apply andI.
            + exact HyA.
            + prove y <> x.
              assume Heq: y = x.
              apply HxnotA.
              rewrite <- Heq.
              exact HyA.
          - exact HyU.
- (** A  lim(A)  cl(A) **)
  let x. assume Hx: x :e A :\/: limit_points_of X Tx A.
  prove x :e closure_of X Tx A.
  apply (binunionE A (limit_points_of X Tx A) x Hx).
  + assume HxA: x :e A.
    (** Show x  cl(A) directly. Need x  X first. **)
    apply (xm (x :e X)).
    * assume HxX: x :e X.
      (** Now show for all U open containing x, U  A   **)
      prove x :e {y :e X | forall U:set, U :e Tx -> y :e U -> U :/\: A <> Empty}.
      apply SepI.
      - exact HxX.
      - prove forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
        let U. assume HU: U :e Tx. assume HxU: x :e U.
        assume Hempty: U :/\: A = Empty.
        (** x  U and x  A, so x  U  A, contradiction **)
        claim HxUA: x :e U :/\: A.
        { apply binintersectI. exact HxU. exact HxA. }
        claim HxEmpty: x :e Empty.
        { rewrite <- Hempty. exact HxUA. }
        exact (EmptyE x HxEmpty).
    * assume HxnotX: x /:e X.
      (** x  X but x  A. But we have A  X, so x  A implies x  X, contradiction. **)
      apply FalseE.
      claim HxX: x :e X.
      { exact (HA x HxA). }
      exact (HxnotX HxX).
  + assume Hxlim: x :e limit_points_of X Tx A.
    (** x is a limit point, so for all U open containing x, exists y  A with y  x in U, thus U  A   **)
    claim Hlimparts: x :e X /\ limit_point_of X Tx A x.
    { exact (SepE X (fun y => limit_point_of X Tx A y) x Hxlim). }
    claim HxX: x :e X.
    { exact (andEL (x :e X) (limit_point_of X Tx A x) Hlimparts). }
    claim Hlim: limit_point_of X Tx A x.
    { exact (andER (x :e X) (limit_point_of X Tx A x) Hlimparts). }
    claim Hlim_cond: forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
    { claim Hlim_full: topology_on X Tx /\ x :e X /\ forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
      { exact Hlim. }
      exact (andER (topology_on X Tx /\ x :e X) (forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U) Hlim_full). }
    prove x :e {y :e X | forall U:set, U :e Tx -> y :e U -> U :/\: A <> Empty}.
    apply SepI.
    * exact HxX.
    * prove forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
      let U. assume HU: U :e Tx. assume HxU: x :e U.
      prove U :/\: A <> Empty.
      claim Hexists: exists y:set, y :e A /\ y <> x /\ y :e U.
      { exact (Hlim_cond U HU HxU). }
      apply Hexists.
      let y. assume Hy_parts: y :e A /\ y <> x /\ y :e U.
      (** Extract components from (y :e A /\ y <> x) /\ y :e U **)
      claim Hy_left: y :e A /\ y <> x.
      { exact (andEL (y :e A /\ y <> x) (y :e U) Hy_parts). }
      claim HyA: y :e A.
      { exact (andEL (y :e A) (y <> x) Hy_left). }
      claim HyU: y :e U.
      { exact (andER (y :e A /\ y <> x) (y :e U) Hy_parts). }
      assume Heq: U :/\: A = Empty.
      claim HyUA: y :e U :/\: A.
      { apply binintersectI. exact HyU. exact HyA. }
      claim HyEmpty: y :e Empty.
      { rewrite <- Heq. exact HyUA. }
      exact (EmptyE y HyEmpty).
Qed.

(** from 17: closed sets contain all limit points **)
(** LATEX VERSION: A set A is closed iff it contains all its limit points. **)
Theorem closed_iff_contains_limit_points : forall X Tx A:set,
  topology_on X Tx -> A c= X ->
  (closed_in X Tx A <-> limit_points_of X Tx A c= A).
let X Tx A.
assume HTx: topology_on X Tx.
assume HA: A c= X.
prove closed_in X Tx A <-> limit_points_of X Tx A c= A.
(** Strategy: A closed iff cl(A) = A iff A  lim(A) = A iff lim(A)  A **)
apply iffI.
- (** Forward: If A closed, then lim(A)  A **)
  assume HAclosed: closed_in X Tx A.
  prove limit_points_of X Tx A c= A.
  let x. assume Hx: x :e limit_points_of X Tx A.
  prove x :e A.
  (** A is closed means cl(A) = A. We have cl(A) = A  lim(A), so A = A  lim(A), thus lim(A)  A. **)
  claim Heq_cl: closure_of X Tx A = A.
  { exact (closed_closure_eq X Tx A HTx HAclosed). }
  (** Use closure_equals_set_plus_limit_points: cl(A) = A  lim(A) **)
  claim Heq_union: closure_of X Tx A = A :\/: limit_points_of X Tx A.
  { exact (closure_equals_set_plus_limit_points X Tx A HTx HA). }
  (** From Heq_cl: A = cl(A), and Heq_union: cl(A) = A  lim(A), we get A = A  lim(A) **)
  (** So x  lim(A) implies x  A  lim(A) = A **)
  claim HxclA: x :e closure_of X Tx A.
  { rewrite Heq_union. apply binunionI2. exact Hx. }
  claim HxA: x :e A.
  { rewrite <- Heq_cl. exact HxclA. }
  exact HxA.
- (** Backward: If lim(A)  A, then A closed **)
  assume Hlim_sub: limit_points_of X Tx A c= A.
  prove closed_in X Tx A.
  (** Strategy: use cl(A)=Alim(A) and lim(A)A to get cl(A)=A; since cl(A) is closed, A is closed. **)
  claim Heq_union: closure_of X Tx A = A :\/: limit_points_of X Tx A.
  { exact (closure_equals_set_plus_limit_points X Tx A HTx HA). }
  (** Show A  lim(A) = A when lim(A)  A **)
  claim Hunion_eq: A :\/: limit_points_of X Tx A = A.
  { apply set_ext.
    - let x. assume Hx: x :e A :\/: limit_points_of X Tx A.
      prove x :e A.
      apply (binunionE A (limit_points_of X Tx A) x Hx).
      + assume HxA: x :e A. exact HxA.
      + assume Hxlim: x :e limit_points_of X Tx A.
        exact (Hlim_sub x Hxlim).
    - let x. assume HxA: x :e A.
      prove x :e A :\/: limit_points_of X Tx A.
      apply binunionI1. exact HxA. }
  (** Therefore cl(A) = A **)
  claim HclA_eq: closure_of X Tx A = A.
  { rewrite Heq_union. exact Hunion_eq. }
  (** cl(A) is closed by closure_is_closed **)
  claim HclA_closed: closed_in X Tx (closure_of X Tx A).
  { exact (closure_is_closed X Tx A HTx HA). }
  (** Since A = cl(A) and cl(A) is closed, A is closed **)
  prove closed_in X Tx A.
  rewrite <- HclA_eq.
  exact HclA_closed.
Qed.

(** from 17 Definition: Hausdorff and T1 spaces **) 
(** LATEX VERSION: Hausdorff (T): distinct points have disjoint neighborhoods; T: all finite sets closed. **)
Definition Hausdorff_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
    exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.

(** Helper: extract topology_on from Hausdorff_space **)
Theorem Hausdorff_space_topology : forall X Tx:set,
  Hausdorff_space X Tx -> topology_on X Tx.
let X Tx.
assume H: Hausdorff_space X Tx.
exact (andEL (topology_on X Tx)
             (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
               exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
             H).
Qed.

(** Helper: extract the separation axiom from Hausdorff_space **)
Theorem Hausdorff_space_separation : forall X Tx x1 x2:set,
  Hausdorff_space X Tx -> x1 :e X -> x2 :e X -> x1 <> x2 ->
  exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
let X Tx x1 x2.
assume H: Hausdorff_space X Tx.
assume Hx1: x1 :e X.
assume Hx2: x2 :e X.
assume Hneq: x1 <> x2.
claim Hsep: forall a b:set, a :e X -> b :e X -> a <> b ->
  exists U V:set, U :e Tx /\ V :e Tx /\ a :e U /\ b :e V /\ U :/\: V = Empty.
{ exact (andER (topology_on X Tx)
               (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               H). }
exact (Hsep x1 x2 Hx1 Hx2 Hneq).
Qed.

(** FIXED: Quantifier scope error; T1_space requires finite subsets of X to be closed (F  X -> finite F -> closed_in X Tx F), not all finite sets. **)
Definition T1_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\ (forall F:set, F c= X -> finite F -> closed_in X Tx F).

(** Helper: extract topology_on from T1_space **)
Theorem T1_space_topology : forall X Tx:set,
  T1_space X Tx -> topology_on X Tx.
let X Tx.
assume H: T1_space X Tx.
exact (andEL (topology_on X Tx)
             (forall F:set, F c= X -> finite F -> closed_in X Tx F)
             H).
Qed.

(** Helper: extract finite closedness axiom from T1_space **)
Theorem T1_space_finite_closed : forall X Tx F:set,
  T1_space X Tx -> F c= X -> finite F -> closed_in X Tx F.
let X Tx F.
assume H: T1_space X Tx.
assume HFsub: F c= X.
assume HFfin: finite F.
claim Hfin: forall G:set, G c= X -> finite G -> closed_in X Tx G.
{ exact (andER (topology_on X Tx)
               (forall G:set, G c= X -> finite G -> closed_in X Tx G)
               H). }
exact (Hfin F HFsub HFfin).
Qed.

(** helper: in a Hausdorff space, the complement of a singleton is open **)
Theorem Hausdorff_singleton_complement_open : forall X Tx x:set,
  Hausdorff_space X Tx -> x :e X -> X :\: {x} :e Tx.
let X Tx x.
assume HH: Hausdorff_space X Tx.
assume HxX: x :e X.
prove X :\: {x} :e Tx.
claim Htop: topology_on X Tx.
{ exact (Hausdorff_space_topology X Tx HH). }
claim HSep: forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
  exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
{ let x1 x2.
  assume Hx1: x1 :e X.
  assume Hx2: x2 :e X.
  assume Hneq: x1 <> x2.
  exact (Hausdorff_space_separation X Tx x1 x2 HH Hx1 Hx2 Hneq). }
(** family of open sets missing x, indexed by points y in X with y<>x **)
set UFam := {V :e Power X |
  exists y:set,
    y :e X /\ y <> x /\ V :e Tx /\ y :e V /\ x /:e V}.
claim HUFam_sub: UFam c= Tx.
{ let V. assume HV: V :e UFam.
  claim HVpred: exists y:set, y :e X /\ y <> x /\ V :e Tx /\ y :e V /\ x /:e V.
  { exact (SepE2 (Power X)
                 (fun V0 : set =>
                   exists y:set, y :e X /\ y <> x /\ V0 :e Tx /\ y :e V0 /\ x /:e V0)
                 V
                 HV). }
  apply HVpred.
  let y. assume Hy_conj: y :e X /\ y <> x /\ V :e Tx /\ y :e V /\ x /:e V.
  claim H0: ((y :e X /\ y <> x) /\ V :e Tx) /\ y :e V.
  { exact (andEL (((y :e X /\ y <> x) /\ V :e Tx) /\ y :e V) (x /:e V) Hy_conj). }
  claim H1: (y :e X /\ y <> x) /\ V :e Tx.
  { exact (andEL ((y :e X /\ y <> x) /\ V :e Tx) (y :e V) H0). }
  exact (andER (y :e X /\ y <> x) (V :e Tx) H1). }
claim HUnionOpen: Union UFam :e Tx.
{ exact (topology_union_closed X Tx UFam Htop HUFam_sub). }
claim HUnionEq: Union UFam = X :\: {x}.
{ apply set_ext.
  - let z. assume Hz: z :e Union UFam.
    prove z :e X :\: {x}.
    apply (UnionE_impred UFam z Hz (z :e X :\: {x})).
    let V. assume HzV: z :e V. assume HV: V :e UFam.
    claim HVpow: V :e Power X.
    { exact (SepE1 (Power X)
                   (fun V0 : set =>
                     exists y:set, y :e X /\ y <> x /\ V0 :e Tx /\ y :e V0 /\ x /:e V0)
                   V
                   HV). }
    claim HVsubX: V c= X.
    { exact (PowerE X V HVpow). }
    claim HzX: z :e X.
    { exact (HVsubX z HzV). }
    claim HVpred: exists y:set, y :e X /\ y <> x /\ V :e Tx /\ y :e V /\ x /:e V.
    { exact (SepE2 (Power X)
                   (fun V0 : set =>
                     exists y:set, y :e X /\ y <> x /\ V0 :e Tx /\ y :e V0 /\ x /:e V0)
                   V
                   HV). }
	    apply HVpred.
	    let y. assume Hy_conj: y :e X /\ y <> x /\ V :e Tx /\ y :e V /\ x /:e V.
	    claim HxNotV: x /:e V.
	    { exact (andER (((y :e X /\ y <> x) /\ V :e Tx) /\ y :e V) (x /:e V) Hy_conj). }
	    claim HznotSing: z /:e {x}.
	    { assume HzSing: z :e {x}.
	      claim Hzeq: z = x.
      { exact (SingE x z HzSing). }
      claim HxV: x :e V.
      { rewrite <- Hzeq. exact HzV. }
      exact (HxNotV HxV). }
    exact (setminusI X {x} z HzX HznotSing).
  - let z. assume Hz: z :e X :\: {x}.
    prove z :e Union UFam.
    claim HzX: z :e X.
    { exact (setminusE1 X {x} z Hz). }
    claim HznotSing: z /:e {x}.
    { exact (setminusE2 X {x} z Hz). }
    claim Hzneq: z <> x.
    { assume Hzeq: z = x.
      claim HzSing: z :e {x}.
      { rewrite Hzeq. exact (SingI x). }
      exact (HznotSing HzSing). }
    claim HexUV: exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ z :e V /\ U :/\: V = Empty.
    { exact (HSep x z HxX HzX (neq_i_sym z x Hzneq)). }
    apply HexUV.
    let U. assume HexV: exists V:set, U :e Tx /\ V :e Tx /\ x :e U /\ z :e V /\ U :/\: V = Empty.
    apply HexV.
    let V. assume Hconj: U :e Tx /\ V :e Tx /\ x :e U /\ z :e V /\ U :/\: V = Empty.
    claim Hconj1: ((U :e Tx /\ V :e Tx) /\ x :e U) /\ z :e V.
    { exact (andEL (((U :e Tx /\ V :e Tx) /\ x :e U) /\ z :e V) (U :/\: V = Empty) Hconj). }
    claim HUVempty: U :/\: V = Empty.
    { exact (andER (((U :e Tx /\ V :e Tx) /\ x :e U) /\ z :e V) (U :/\: V = Empty) Hconj). }
    claim Hconj2: (U :e Tx /\ V :e Tx) /\ x :e U.
    { exact (andEL ((U :e Tx /\ V :e Tx) /\ x :e U) (z :e V) Hconj1). }
    claim HUV1: U :e Tx /\ V :e Tx.
    { exact (andEL (U :e Tx /\ V :e Tx) (x :e U) Hconj2). }
    claim HxU: x :e U.
    { exact (andER (U :e Tx /\ V :e Tx) (x :e U) Hconj2). }
    claim HVTx: V :e Tx.
    { exact (andER (U :e Tx) (V :e Tx) HUV1). }
    claim HzV: z :e V.
    { exact (andER ((U :e Tx /\ V :e Tx) /\ x :e U) (z :e V) Hconj1). }
    claim HxNotV: x /:e V.
    { assume HxV: x :e V.
      claim HxUV: x :e U :/\: V.
      { exact (binintersectI U V x HxU HxV). }
      claim HxEmp: x :e Empty.
      { rewrite <- HUVempty. exact HxUV. }
      exact (EmptyE x HxEmp False). }
    claim HVpow: V :e Power X.
    { claim HTsub: Tx c= Power X.
      { exact (topology_subset_axiom X Tx Htop). }
      exact (HTsub V HVTx). }
    claim HVin: V :e UFam.
    { apply (SepI (Power X)
                  (fun V0 : set =>
                    exists y:set, y :e X /\ y <> x /\ V0 :e Tx /\ y :e V0 /\ x /:e V0)
                  V
                  HVpow).
      witness z.
      apply andI.
      { apply andI.
        { apply andI.
          { apply andI.
            exact HzX.
            exact Hzneq. }
          exact HVTx. }
        exact HzV. }
      { exact HxNotV. } }
    exact (UnionI UFam z V HzV HVin).
}
rewrite <- HUnionEq.
exact HUnionOpen.
Qed.

(** helper: in a Hausdorff space, singletons are closed **)
Theorem Hausdorff_singletons_closed : forall X Tx x:set,
  Hausdorff_space X Tx -> x :e X -> closed_in X Tx {x}.
let X Tx x.
assume HH: Hausdorff_space X Tx.
assume HxX: x :e X.
prove closed_in X Tx {x}.
claim Htop: topology_on X Tx.
{ exact (Hausdorff_space_topology X Tx HH). }
claim HxSub: {x} c= X.
{ let y. assume Hy: y :e {x}.
  claim Hyeq: y = x.
  { exact (SingE x y Hy). }
  rewrite Hyeq. exact HxX. }
claim HUopen: X :\: {x} :e Tx.
{ exact (Hausdorff_singleton_complement_open X Tx x HH HxX). }
claim Hclosed: closed_in X Tx (X :\: (X :\: {x})).
{ exact (closed_of_open_complement X Tx (X :\: {x}) Htop HUopen). }
claim Heq: X :\: (X :\: {x}) = {x}.
{ exact (setminus_setminus_eq X {x} HxSub). }
rewrite <- Heq.
exact Hclosed.
Qed.

(** from 17 Theorem 17.8: finite sets closed in Hausdorff **) 
(** LATEX VERSION: In any Hausdorff space, every finite subset is closed. **)
Theorem finite_sets_closed_in_Hausdorff : forall X Tx:set,
  Hausdorff_space X Tx -> forall F:set, F c= X -> finite F -> closed_in X Tx F.
let X Tx.
assume HH: Hausdorff_space X Tx.
let F.
assume HFsub: F c= X.
assume HF: finite F.
prove closed_in X Tx F.
claim Htop: topology_on X Tx.
{ exact (Hausdorff_space_topology X Tx HH). }
claim Hclosed_empty: closed_in X Tx Empty.
{ exact (empty_is_closed X Tx Htop). }
claim Hall: forall F0:set, finite F0 -> (F0 c= X -> closed_in X Tx F0).
{ exact (finite_ind
           (fun F0:set => F0 c= X -> closed_in X Tx F0)
           (fun _ => Hclosed_empty)
           (fun F0 y:set =>
              fun HFin0 HyNotin IH =>
                fun HsubUnion =>
                  union_of_closed_is_closed X Tx F0 {y} Htop
                    (IH (fun z Hz => HsubUnion z (binunionI1 F0 {y} z Hz)))
                    (Hausdorff_singletons_closed X Tx y HH
                      (HsubUnion y (binunionI2 F0 {y} y (SingI y)))))
         ). }
exact ((Hall F HF) HFsub).
Qed.

(** from 17 Theorem 17.9: limit points in T1 spaces have infinite neighborhoods **) 
(** LATEX VERSION: In T spaces, x is a limit point of A iff every neighborhood of x meets A in infinitely many points. **)
Theorem limit_points_infinite_neighborhoods : forall X Tx A x:set,
  T1_space X Tx ->
  x :e X ->
  (limit_point_of X Tx A x <->
  (forall U :e Tx, x :e U -> infinite (U :/\: A))).
let X Tx A x.
assume HT1: T1_space X Tx.
assume HxX: x :e X.
prove limit_point_of X Tx A x <-> (forall U :e Tx, x :e U -> infinite (U :/\: A)).
claim Htop: topology_on X Tx.
{ exact (T1_space_topology X Tx HT1). }
claim Hfinite_closed: forall F:set, F c= X -> finite F -> closed_in X Tx F.
{ let F. assume HFsub. assume HFfin.
  exact (T1_space_finite_closed X Tx F HT1 HFsub HFfin). }
apply iffI.
- (** limit point gives infinite intersections **)
  assume Hlim: limit_point_of X Tx A x.
  prove forall U :e Tx, x :e U -> infinite (U :/\: A).
  let U. assume HU: U :e Tx. assume HxU: x :e U.
  prove infinite (U :/\: A).
  prove ~finite (U :/\: A).
  assume Hfin: finite (U :/\: A).
  claim Hnbr: forall W:set, W :e Tx -> x :e W -> exists y:set, y :e A /\ y <> x /\ y :e W.
  { exact (andER (topology_on X Tx /\ x :e X) (forall W:set, W :e Tx -> x :e W -> exists y:set, y :e A /\ y <> x /\ y :e W)
           Hlim). }
  apply (xm (x :e A)).
  + (** case x in A: remove all other A-points from U **)
    assume HxA: x :e A.
    set F := (U :/\: A) :\: {x}.
    claim HFsub: F c= U :/\: A.
    { exact (setminus_Subq (U :/\: A) {x}). }
    claim HFfin: finite F.
    { exact (Subq_finite (U :/\: A) Hfin F HFsub). }
    claim HFsubX: F c= X.
    { let z. assume HzF: z :e F.
      claim HzUA: z :e U :/\: A.
      { exact (setminusE1 (U :/\: A) {x} z HzF). }
      claim HzU: z :e U.
      { exact (binintersectE1 U A z HzUA). }
      claim HUsubX: U c= X.
      { exact (topology_elem_subset X Tx U Htop HU). }
      exact (HUsubX z HzU). }
    claim HFclosed: closed_in X Tx F.
    { exact (Hfinite_closed F HFsubX HFfin). }
    claim HXFopen: open_in X Tx (X :\: F).
    { exact (open_of_closed_complement X Tx F HFclosed). }
    claim HXF: X :\: F :e Tx.
    { exact (andER (topology_on X Tx) (X :\: F :e Tx) HXFopen). }
    set V := U :/\: (X :\: F).
    claim HV: V :e Tx.
    { exact (topology_binintersect_closed X Tx U (X :\: F) Htop HU HXF). }
    claim HxnotF: x /:e F.
    { assume HxF: x :e F.
      claim HxnotSing: x /:e {x}.
      { exact (setminusE2 (U :/\: A) {x} x HxF). }
      exact (HxnotSing (SingI x)). }
    claim HxXF: x :e X :\: F.
    { exact (setminusI X F x HxX HxnotF). }
    claim HxV: x :e V.
    { exact (binintersectI U (X :\: F) x HxU HxXF). }
	    apply (Hnbr V HV HxV).
	    let y. assume Hyconj: y :e A /\ y <> x /\ y :e V.
	    claim HyAneq: y :e A /\ y <> x.
	    { exact (andEL (y :e A /\ y <> x) (y :e V) Hyconj). }
	    claim HyA: y :e A.
	    { exact (andEL (y :e A) (y <> x) HyAneq). }
	    claim Hyneq: y <> x.
	    { exact (andER (y :e A) (y <> x) HyAneq). }
	    claim HyV: y :e V.
	    { exact (andER (y :e A /\ y <> x) (y :e V) Hyconj). }
    claim HyU: y :e U.
    { exact (binintersectE1 U (X :\: F) y HyV). }
    claim HyXF: y :e X :\: F.
    { exact (binintersectE2 U (X :\: F) y HyV). }
    claim HyNotF: y /:e F.
    { exact (setminusE2 X F y HyXF). }
    claim HyUA: y :e U :/\: A.
    { exact (binintersectI U A y HyU HyA). }
    claim HyNotSing: y /:e {x}.
    { assume HySing: y :e {x}.
      claim Hyeq: y = x.
      { exact (SingE x y HySing). }
      exact (Hyneq Hyeq). }
    claim HyF: y :e F.
    { exact (setminusI (U :/\: A) {x} y HyUA HyNotSing). }
    exact (HyNotF HyF).
  + (** case x not in A: remove all A-points from U **)
    assume HxnotA: x /:e A.
    set F := U :/\: A.
    claim HFsubX: F c= X.
    { let z. assume HzF: z :e F.
      claim HzU: z :e U.
      { exact (binintersectE1 U A z HzF). }
      claim HUsubX: U c= X.
      { exact (topology_elem_subset X Tx U Htop HU). }
      exact (HUsubX z HzU). }
    claim HFclosed: closed_in X Tx F.
    { exact (Hfinite_closed F HFsubX Hfin). }
    claim HXFopen: open_in X Tx (X :\: F).
    { exact (open_of_closed_complement X Tx F HFclosed). }
    claim HXF: X :\: F :e Tx.
    { exact (andER (topology_on X Tx) (X :\: F :e Tx) HXFopen). }
    set V := U :/\: (X :\: F).
    claim HV: V :e Tx.
    { exact (topology_binintersect_closed X Tx U (X :\: F) Htop HU HXF). }
    claim HxnotF: x /:e F.
    { assume HxF: x :e F.
      claim HxA': x :e A.
      { exact (binintersectE2 U A x HxF). }
      exact (HxnotA HxA'). }
    claim HxXF: x :e X :\: F.
    { exact (setminusI X F x HxX HxnotF). }
    claim HxV: x :e V.
    { exact (binintersectI U (X :\: F) x HxU HxXF). }
	    apply (Hnbr V HV HxV).
	    let y. assume Hyconj: y :e A /\ y <> x /\ y :e V.
	    claim HyAneq: y :e A /\ y <> x.
	    { exact (andEL (y :e A /\ y <> x) (y :e V) Hyconj). }
	    claim HyA: y :e A.
	    { exact (andEL (y :e A) (y <> x) HyAneq). }
	    claim Hyneq: y <> x.
	    { exact (andER (y :e A) (y <> x) HyAneq). }
	    claim HyV: y :e V.
	    { exact (andER (y :e A /\ y <> x) (y :e V) Hyconj). }
    claim HyU: y :e U.
    { exact (binintersectE1 U (X :\: F) y HyV). }
    claim HyXF: y :e X :\: F.
    { exact (binintersectE2 U (X :\: F) y HyV). }
    claim HyNotF: y /:e F.
    { exact (setminusE2 X F y HyXF). }
    claim HyF: y :e F.
    { exact (binintersectI U A y HyU HyA). }
    exact (HyNotF HyF).
- (** infinite intersections give limit point **)
  assume Hinf: forall U :e Tx, x :e U -> infinite (U :/\: A).
  prove limit_point_of X Tx A x.
  prove topology_on X Tx /\ x :e X /\ forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
  apply andI.
  - apply andI.
    + exact Htop.
    + exact HxX.
  - let U. assume HU: U :e Tx. assume HxU: x :e U.
    claim HinfUA: infinite (U :/\: A).
    { exact (Hinf U HU HxU). }
    claim Hnotfin: ~finite (U :/\: A).
    { exact HinfUA. }
    apply (xm (exists y:set, y :e U :/\: A /\ y <> x)).
    + assume Hex. apply Hex.
      let y. assume Hypair.
      witness y.
      claim HyUA: y :e U :/\: A.
      { exact (andEL (y :e U :/\: A) (y <> x) Hypair). }
      claim Hyneq: y <> x.
      { exact (andER (y :e U :/\: A) (y <> x) Hypair). }
      claim HyU: y :e U.
      { exact (binintersectE1 U A y HyUA). }
      claim HyA: y :e A.
      { exact (binintersectE2 U A y HyUA). }
      apply andI.
      - apply andI.
        + exact HyA.
        + exact Hyneq.
      - exact HyU.
    + assume Hno: ~(exists y:set, y :e U :/\: A /\ y <> x).
      claim HsubSing: U :/\: A c= {x}.
      { let y. assume HyUA: y :e U :/\: A.
        apply (xm (y = x)).
        - assume Heq: y = x.
          rewrite Heq.
          exact (SingI x).
        - assume Hneq: ~(y = x).
          apply FalseE.
          apply Hno.
          witness y.
          apply andI.
          - exact HyUA.
          - assume Heq: y = x.
            exact (Hneq Heq). }
	      claim HfinUA: finite (U :/\: A).
	      { exact (Subq_finite {x} (Sing_finite x) (U :/\: A) HsubSing). }
	      apply FalseE.
	      exact (Hnotfin HfinUA).
Qed.

(** from 17 Theorem 17.10: uniqueness of limits in Hausdorff spaces **) 
(** LATEX VERSION: In Hausdorff spaces, sequences (or nets) have at most one limit. **)
Theorem Hausdorff_unique_limits : forall X Tx seq x y:set,
  Hausdorff_space X Tx ->
  x :e X ->
  y :e X ->
  x <> y ->
  function_on seq omega X ->
  (forall U:set, U :e Tx -> x :e U -> exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U) ->
  (forall U:set, U :e Tx -> y :e U -> exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U) ->
  False.
let X Tx seq x y.
assume HH: Hausdorff_space X Tx.
assume HxX: x :e X.
assume HyX: y :e X.
assume Hneq: x <> y.
assume Hseq: function_on seq omega X.
assume Hx: forall U:set, U :e Tx -> x :e U -> exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U.
assume Hy: forall U:set, U :e Tx -> y :e U -> exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U.
prove False.
  (** Strategy: separate x and y by disjoint opens U,V; convergence forces the sequence eventually in U and eventually in V, contradicting U  V = . **)
(** Extract topology and separation property **)
claim HTx: topology_on X Tx.
{ exact (Hausdorff_space_topology X Tx HH). }
claim HSep: forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 -> exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
{ let x1 x2.
  assume Hx1: x1 :e X.
  assume Hx2: x2 :e X.
  assume Hneq12: x1 <> x2.
  exact (Hausdorff_space_separation X Tx x1 x2 HH Hx1 Hx2 Hneq12). }
(** Apply separation to x and y **)
claim HexUV: exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ y :e V /\ U :/\: V = Empty.
{ exact (HSep x y HxX HyX Hneq). }
(** Handle nested existentials - need to carefully unpack structure **)
(** Unpack the existential for U and V **)
apply HexUV.
let U. assume HexV: exists V:set, U :e Tx /\ V :e Tx /\ x :e U /\ y :e V /\ U :/\: V = Empty.
apply HexV.
let V. assume Hconj: U :e Tx /\ V :e Tx /\ x :e U /\ y :e V /\ U :/\: V = Empty.
(** Extract all the conjuncts - remember /\ is left-associative **)
(** Hconj is: (((U :e Tx /\ V :e Tx) /\ x :e U) /\ y :e V) /\ U :/\: V = Empty **)
claim HU: U :e Tx.
{ exact (andEL (U :e Tx) (V :e Tx)
         (andEL (U :e Tx /\ V :e Tx) (x :e U)
          (andEL (U :e Tx /\ V :e Tx /\ x :e U) (y :e V)
           (andEL (U :e Tx /\ V :e Tx /\ x :e U /\ y :e V) (U :/\: V = Empty) Hconj)))). }
claim HV: V :e Tx.
{ exact (andER (U :e Tx) (V :e Tx)
         (andEL (U :e Tx /\ V :e Tx) (x :e U)
          (andEL (U :e Tx /\ V :e Tx /\ x :e U) (y :e V)
           (andEL (U :e Tx /\ V :e Tx /\ x :e U /\ y :e V) (U :/\: V = Empty) Hconj)))). }
claim HxU: x :e U.
{ exact (andER (U :e Tx /\ V :e Tx) (x :e U)
          (andEL (U :e Tx /\ V :e Tx /\ x :e U) (y :e V)
           (andEL (U :e Tx /\ V :e Tx /\ x :e U /\ y :e V) (U :/\: V = Empty) Hconj))). }
claim HyV: y :e V.
{ exact (andER (U :e Tx /\ V :e Tx /\ x :e U) (y :e V)
           (andEL (U :e Tx /\ V :e Tx /\ x :e U /\ y :e V) (U :/\: V = Empty) Hconj)). }
claim HUV_empty: U :/\: V = Empty.
{ exact (andER (U :e Tx /\ V :e Tx /\ x :e U /\ y :e V) (U :/\: V = Empty) Hconj). }
(** Now we have U, V open, disjoint, x :e U, y :e V **)
(** Sequence converges to x: eventually in U **)
claim HexNx: exists Nx:set, Nx :e omega /\ forall n:set, n :e omega -> Nx c= n -> apply_fun seq n :e U.
{ exact (Hx U HU HxU). }
apply HexNx.
let Nx. assume HNx_and_conv.
claim HNx: Nx :e omega.
{ exact (andEL (Nx :e omega) (forall n:set, n :e omega -> Nx c= n -> apply_fun seq n :e U) HNx_and_conv). }
claim Hconv_x: forall n:set, n :e omega -> Nx c= n -> apply_fun seq n :e U.
{ exact (andER (Nx :e omega) (forall n:set, n :e omega -> Nx c= n -> apply_fun seq n :e U) HNx_and_conv). }
(** Sequence converges to y: eventually in V **)
claim HexNy: exists Ny:set, Ny :e omega /\ forall n:set, n :e omega -> Ny c= n -> apply_fun seq n :e V.
{ exact (Hy V HV HyV). }
apply HexNy.
let Ny. assume HNy_and_conv.
claim HNy: Ny :e omega.
{ exact (andEL (Ny :e omega) (forall n:set, n :e omega -> Ny c= n -> apply_fun seq n :e V) HNy_and_conv). }
claim Hconv_y: forall n:set, n :e omega -> Ny c= n -> apply_fun seq n :e V.
{ exact (andER (Ny :e omega) (forall n:set, n :e omega -> Ny c= n -> apply_fun seq n :e V) HNy_and_conv). }
(** Take n = ordsucc (Nx  Ny), which is >= both Nx and Ny **)
(** Since Nx, Ny are ordinals in omega, Nx  Ny = max(Nx, Ny) **)
set N := ordsucc (Nx :\/: Ny).
claim HN_omega: N :e omega.
{ claim Hmax_omega: Nx :\/: Ny :e omega.
  { (** Nx  Ny is the max of two elements of omega, hence in omega **)
    apply (xm (Nx :e Ny)).
    - assume HNx_in_Ny: Nx :e Ny.
      (** If Nx < Ny, then Nx  Ny = Ny **)
      claim Hmax_eq_Ny: Nx :\/: Ny = Ny.
      { (** Nx  Ny since Nx :e Ny and Ny is an ordinal (transitive) **)
        claim HNx_sub_Ny: Nx c= Ny.
        { (** Ny is a natural, hence ordinal, hence TransSet **)
          claim HNy_nat: nat_p Ny.
          { exact (omega_nat_p Ny HNy). }
          claim HNy_ord: ordinal Ny.
          { exact (nat_p_ordinal Ny HNy_nat). }
          claim HNy_trans: TransSet Ny.
          { exact (andEL (TransSet Ny) (forall beta :e Ny, TransSet beta) HNy_ord). }
          (** Now use TransSet property: x :e Ny implies x c= Ny **)
          exact (HNy_trans Nx HNx_in_Ny).
        }
        apply set_ext.
        - (** Nx :\/: Ny c= Ny **)
          claim HNy_refl: Ny c= Ny.
          { exact (Subq_ref Ny). }
          exact (binunion_Subq_min Nx Ny Ny HNx_sub_Ny HNy_refl).
        - (** Ny c= Nx :\/: Ny **)
          exact (binunion_Subq_2 Nx Ny).
      }
      rewrite Hmax_eq_Ny.
      exact HNy.
    - assume HNx_nin_Ny: Nx /:e Ny.
      (** If Nx >= Ny, then Ny  Nx **)
      claim HNy_sub_or_eq_Nx: Ny c= Nx.
      { (** In omega, if Nx /:e Ny, then Ny :e Nx or Ny = Nx (trichotomy) **)
        (** Use ordinal trichotomy: Nx and Ny are ordinals since they're in omega **)
        claim HNx_nat: nat_p Nx.
        { exact (omega_nat_p Nx HNx). }
        claim HNy_nat: nat_p Ny.
        { exact (omega_nat_p Ny HNy). }
        claim HNx_ord: ordinal Nx.
        { exact (nat_p_ordinal Nx HNx_nat). }
        claim HNy_ord: ordinal Ny.
        { exact (nat_p_ordinal Ny HNy_nat). }
        (** Apply ordinal_In_Or_Subq: either Nx :e Ny or Ny c= Nx **)
        claim Hcases: Nx :e Ny \/ Ny c= Nx.
        { exact (ordinal_In_Or_Subq Nx Ny HNx_ord HNy_ord). }
        (** We have Nx /:e Ny, so must have Ny c= Nx **)
        apply (Hcases (Ny c= Nx)).
        - assume HNx_in_Ny: Nx :e Ny.
          apply FalseE.
          exact (HNx_nin_Ny HNx_in_Ny).
        - assume H. exact H.
      }
      claim Hmax_eq_Nx: Nx :\/: Ny = Nx.
      { apply set_ext.
        - (** Nx :\/: Ny c= Nx **)
          claim HNx_refl: Nx c= Nx.
          { exact (Subq_ref Nx). }
          exact (binunion_Subq_min Nx Ny Nx HNx_refl HNy_sub_or_eq_Nx).
        - (** Nx c= Nx :\/: Ny **)
          exact (binunion_Subq_1 Nx Ny).
      }
      rewrite Hmax_eq_Nx.
      exact HNx.
  }
  exact (omega_ordsucc (Nx :\/: Ny) Hmax_omega).
}
claim HNx_sub_N: Nx c= N.
{ (** Nx  Nx  Ny  ordsucc(Nx  Ny) **)
  claim HNx_sub_union: Nx c= Nx :\/: Ny.
  { exact (binunion_Subq_1 Nx Ny). }
  claim Hunion_sub_ordsucc: Nx :\/: Ny c= ordsucc (Nx :\/: Ny).
  { exact (ordsuccI1 (Nx :\/: Ny)). }
  exact (Subq_tra Nx (Nx :\/: Ny) (ordsucc (Nx :\/: Ny)) HNx_sub_union Hunion_sub_ordsucc).
}
claim HNy_sub_N: Ny c= N.
{ (** Ny  Nx  Ny  ordsucc(Nx  Ny) **)
  claim HNy_sub_union: Ny c= Nx :\/: Ny.
  { exact (binunion_Subq_2 Nx Ny). }
  claim Hunion_sub_ordsucc: Nx :\/: Ny c= ordsucc (Nx :\/: Ny).
  { exact (ordsuccI1 (Nx :\/: Ny)). }
  exact (Subq_tra Ny (Nx :\/: Ny) (ordsucc (Nx :\/: Ny)) HNy_sub_union Hunion_sub_ordsucc).
}
(** Then apply_fun seq N is in both U and V **)
claim Hseq_N_in_U: apply_fun seq N :e U.
{ exact (Hconv_x N HN_omega HNx_sub_N). }
claim Hseq_N_in_V: apply_fun seq N :e V.
{ exact (Hconv_y N HN_omega HNy_sub_N). }
(** So apply_fun seq N :e U  V **)
claim Hseq_N_in_UV: apply_fun seq N :e U :/\: V.
{ exact (binintersectI U V (apply_fun seq N) Hseq_N_in_U Hseq_N_in_V). }
(** But U  V = , so apply_fun seq N :e , which is False **)
claim Hseq_N_in_empty: apply_fun seq N :e Empty.
{ rewrite <- HUV_empty. exact Hseq_N_in_UV. }
exact (EmptyE (apply_fun seq N) Hseq_N_in_empty False).
Qed.

(** from 17 Theorem 17.11: Hausdorff stability under constructions **) 
(** LATEX VERSION: Products of Hausdorff spaces are Hausdorff. **)
Theorem Hausdorff_stability : forall X Tx Y Ty:set,
  Hausdorff_space X Tx /\ Hausdorff_space Y Ty ->
  Hausdorff_space (setprod X Y) (product_topology X Tx Y Ty).
let X Tx Y Ty.
assume H: Hausdorff_space X Tx /\ Hausdorff_space Y Ty.
prove Hausdorff_space (setprod X Y) (product_topology X Tx Y Ty).
(** Strategy: Same as ex17_11_product_Hausdorff - use rectangles to separate distinct points **)
(** Extract components from Hausdorff definitions **)
claim HX: Hausdorff_space X Tx.
{ exact (andEL (Hausdorff_space X Tx) (Hausdorff_space Y Ty) H). }
claim HY: Hausdorff_space Y Ty.
{ exact (andER (Hausdorff_space X Tx) (Hausdorff_space Y Ty) H). }
claim HTx: topology_on X Tx.
{ exact (Hausdorff_space_topology X Tx HX). }
claim HTy: topology_on Y Ty.
{ exact (Hausdorff_space_topology Y Ty HY). }
claim HSepX: forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 -> exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
{ let x1 x2.
  assume Hx1: x1 :e X.
  assume Hx2: x2 :e X.
  assume Hneq12: x1 <> x2.
  exact (Hausdorff_space_separation X Tx x1 x2 HX Hx1 Hx2 Hneq12). }
claim HSepY: forall y1 y2:set, y1 :e Y -> y2 :e Y -> y1 <> y2 -> exists U V:set, U :e Ty /\ V :e Ty /\ y1 :e U /\ y2 :e V /\ U :/\: V = Empty.
{ let y1 y2.
  assume Hy1: y1 :e Y.
  assume Hy2: y2 :e Y.
  assume Hneq12: y1 <> y2.
  exact (Hausdorff_space_separation Y Ty y1 y2 HY Hy1 Hy2 Hneq12). }
(** Build Hausdorff property for product **)
claim HTProd: topology_on (setprod X Y) (product_topology X Tx Y Ty).
{ exact (product_topology_is_topology X Tx Y Ty HTx HTy). }
prove topology_on (setprod X Y) (product_topology X Tx Y Ty) /\
      (forall p1 p2:set, p1 :e setprod X Y -> p2 :e setprod X Y -> p1 <> p2 ->
       exists U V:set, U :e product_topology X Tx Y Ty /\ V :e product_topology X Tx Y Ty /\
                       p1 :e U /\ p2 :e V /\ U :/\: V = Empty).
apply andI.
- exact HTProd.
- let p1 p2. assume Hp1: p1 :e setprod X Y. assume Hp2: p2 :e setprod X Y. assume Hne: p1 <> p2.
  prove exists U V:set, U :e product_topology X Tx Y Ty /\ V :e product_topology X Tx Y Ty /\
                        p1 :e U /\ p2 :e V /\ U :/\: V = Empty.
  (** Decompose p1 = (x1,y1), p2 = (x2,y2) **)
  apply (Sigma_E X (fun _ : set => Y) p1 Hp1).
  let x1. assume Hx1_pair.
  apply Hx1_pair.
  assume Hx1X Hexy1.
  apply Hexy1.
  let y1. assume Hy1_pair.
  apply Hy1_pair.
  assume Hy1Y Hp1eq.
  apply (Sigma_E X (fun _ : set => Y) p2 Hp2).
  let x2. assume Hx2_pair.
  apply Hx2_pair.
  assume Hx2X Hexy2.
  apply Hexy2.
  let y2. assume Hy2_pair.
  apply Hy2_pair.
  assume Hy2Y Hp2eq.
  (** Split by whether x-coordinates coincide **)
  apply (xm (x1 = x2)).
  - assume Hx12: x1 = x2.
    claim Hy12: y1 <> y2.
    { assume HyEq: y1 = y2.
      claim HpEq: p1 = p2.
      { rewrite Hp1eq.
        rewrite Hp2eq.
        rewrite Hx12.
        rewrite HyEq.
        reflexivity. }
      exact (Hne HpEq). }
    (** Separate by y-coordinate using opens in Ty **)
    apply (HSepY y1 y2 Hy1Y Hy2Y Hy12).
    let U. assume HexV.
    apply HexV.
    let V. assume HUV_conj.
    apply HUV_conj.
    assume Hcore HUVempty.
    apply Hcore.
    assume Hcore2 Hy2V.
    apply Hcore2.
    assume Hcore3 Hy1U.
    apply Hcore3.
    assume HU HV.
    set R1 := rectangle_set X U.
    set R2 := rectangle_set X V.
    witness R1.
    witness R2.
    prove R1 :e product_topology X Tx Y Ty /\ R2 :e product_topology X Tx Y Ty /\ p1 :e R1 /\ p2 :e R2 /\ R1 :/\: R2 = Empty.
    apply andI.
    + apply andI.
      * apply andI.
        { apply andI.
          (** R1 open in product topology **)
          - claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
            { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
            claim HXTx: X :e Tx.
            { exact (topology_has_X X Tx HTx). }
            claim HR1sub: R1 :e product_subbasis X Tx Y Ty.
            { prove R1 :e product_subbasis X Tx Y Ty.
              claim HR1fam: rectangle_set X U :e {rectangle_set X V0|V0 :e Ty}.
              { exact (ReplI Ty (fun V0:set => rectangle_set X V0) U HU). }
              exact (famunionI Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) X (rectangle_set X U) HXTx HR1fam). }
            exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis R1 HR1sub).
          (** R2 open in product topology **)
          - claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
            { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
            claim HXTx: X :e Tx.
            { exact (topology_has_X X Tx HTx). }
            claim HR2sub: R2 :e product_subbasis X Tx Y Ty.
            { prove R2 :e product_subbasis X Tx Y Ty.
              claim HR2fam: rectangle_set X V :e {rectangle_set X V0|V0 :e Ty}.
              { exact (ReplI Ty (fun V0:set => rectangle_set X V0) V HV). }
              exact (famunionI Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) X (rectangle_set X V) HXTx HR2fam). }
            exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis R2 HR2sub). }
        (** p1 in R1 **)
        { rewrite Hp1eq.
          exact (pair_Sigma X (fun _ : set => U) x1 Hx1X y1 Hy1U). }
      (** p2 in R2 **)
      * rewrite Hp2eq.
        rewrite <- Hx12 at 1.
        exact (pair_Sigma X (fun _ : set => V) x1 Hx1X y2 Hy2V).
    (** disjointness of rectangles **)
    + prove R1 :/\: R2 = Empty.
      apply set_ext.
      { let p. assume Hp: p :e R1 :/\: R2.
        prove p :e Empty.
        apply FalseE.
        claim HpR1: p :e R1.
        { exact (binintersectE1 R1 R2 p Hp). }
        claim HpR2: p :e R2.
        { exact (binintersectE2 R1 R2 p Hp). }
        claim Hcoords1: exists x :e X, exists y :e U, p :e setprod {x} {y}.
        { exact (setprod_elem_decompose X U p HpR1). }
        apply Hcoords1.
        let x. assume Hx_pair.
        claim HxX': x :e X.
        { exact (andEL (x :e X) (exists y0 :e U, p :e setprod {x} {y0}) Hx_pair). }
        claim Hexy: exists y0 :e U, p :e setprod {x} {y0}.
        { exact (andER (x :e X) (exists y0 :e U, p :e setprod {x} {y0}) Hx_pair). }
        apply Hexy.
        let y. assume Hy_pair.
        claim HyU': y :e U.
        { exact (andEL (y :e U) (p :e setprod {x} {y}) Hy_pair). }
        claim Hpsing1: p :e setprod {x} {y}.
        { exact (andER (y :e U) (p :e setprod {x} {y}) Hy_pair). }
        claim Hcoords2: exists x0 :e X, exists y0 :e V, p :e setprod {x0} {y0}.
        { exact (setprod_elem_decompose X V p HpR2). }
        apply Hcoords2.
        let x0. assume Hx0_pair.
        claim Hexy0: exists y0 :e V, p :e setprod {x0} {y0}.
        { exact (andER (x0 :e X) (exists y0 :e V, p :e setprod {x0} {y0}) Hx0_pair). }
        apply Hexy0.
        let y0. assume Hy0_pair.
        claim Hpsing2: p :e setprod {x0} {y0}.
        { exact (andER (y0 :e V) (p :e setprod {x0} {y0}) Hy0_pair). }
        claim HyV': y :e V.
        { exact (andER (x :e X) (y :e V) (setprod_coords_in x y X V p Hpsing1 HpR2)). }
        claim HyUV: y :e U :/\: V.
        { exact (binintersectI U V y HyU' HyV'). }
        claim HyE: y :e Empty.
        { rewrite <- HUVempty. exact HyUV. }
        exact (EmptyE y HyE False). }
      { exact (Subq_Empty (R1 :/\: R2)). }
  - assume Hx12n: x1 <> x2.
    (** Separate by x-coordinate using opens in Tx **)
    apply (HSepX x1 x2 Hx1X Hx2X Hx12n).
    let U. assume HexV.
    apply HexV.
    let V. assume HUV_conj.
    apply HUV_conj.
    assume Hcore HUVempty.
    apply Hcore.
    assume Hcore2 Hx2V.
    apply Hcore2.
    assume Hcore3 Hx1U.
    apply Hcore3.
    assume HU HV.
    set R1 := rectangle_set U Y.
    set R2 := rectangle_set V Y.
    witness R1.
    witness R2.
    prove R1 :e product_topology X Tx Y Ty /\ R2 :e product_topology X Tx Y Ty /\ p1 :e R1 /\ p2 :e R2 /\ R1 :/\: R2 = Empty.
    apply andI.
    + apply andI.
      * apply andI.
        { apply andI.
          (** R1 open in product topology **)
          - claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
            { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
            claim HYTy: Y :e Ty.
            { exact (topology_has_X Y Ty HTy). }
            claim HR1sub: R1 :e product_subbasis X Tx Y Ty.
            { prove R1 :e product_subbasis X Tx Y Ty.
              claim HR1fam: rectangle_set U Y :e {rectangle_set U V0|V0 :e Ty}.
              { exact (ReplI Ty (fun V0:set => rectangle_set U V0) Y HYTy). }
              exact (famunionI Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) U (rectangle_set U Y) HU HR1fam). }
            exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis R1 HR1sub).
          (** R2 open in product topology **)
          - claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
            { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
            claim HYTy: Y :e Ty.
            { exact (topology_has_X Y Ty HTy). }
            claim HR2sub: R2 :e product_subbasis X Tx Y Ty.
            { prove R2 :e product_subbasis X Tx Y Ty.
              claim HR2fam: rectangle_set V Y :e {rectangle_set V V0|V0 :e Ty}.
              { exact (ReplI Ty (fun V0:set => rectangle_set V V0) Y HYTy). }
              exact (famunionI Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) V (rectangle_set V Y) HV HR2fam). }
            exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis R2 HR2sub). }
        (** p1 in R1 **)
        { rewrite Hp1eq.
          exact (pair_Sigma U (fun _ : set => Y) x1 Hx1U y1 Hy1Y). }
      (** p2 in R2 **)
      * rewrite Hp2eq.
        exact (pair_Sigma V (fun _ : set => Y) x2 Hx2V y2 Hy2Y).
    (** disjointness of rectangles **)
    + prove R1 :/\: R2 = Empty.
      apply set_ext.
      { let p. assume Hp: p :e R1 :/\: R2.
        prove p :e Empty.
        apply FalseE.
        claim HpR1: p :e R1.
        { exact (binintersectE1 R1 R2 p Hp). }
        claim HpR2: p :e R2.
        { exact (binintersectE2 R1 R2 p Hp). }
        claim Hcoords1: exists x :e U, exists y :e Y, p :e setprod {x} {y}.
        { exact (setprod_elem_decompose U Y p HpR1). }
        apply Hcoords1.
        let x. assume Hx_pair.
        claim HxU': x :e U.
        { exact (andEL (x :e U) (exists y0 :e Y, p :e setprod {x} {y0}) Hx_pair). }
        claim Hexy: exists y0 :e Y, p :e setprod {x} {y0}.
        { exact (andER (x :e U) (exists y0 :e Y, p :e setprod {x} {y0}) Hx_pair). }
        apply Hexy.
        let y. assume Hy_pair.
        claim Hpsing1: p :e setprod {x} {y}.
        { exact (andER (y :e Y) (p :e setprod {x} {y}) Hy_pair). }
        claim Hcoords2: exists x0 :e V, exists y0 :e Y, p :e setprod {x0} {y0}.
        { exact (setprod_elem_decompose V Y p HpR2). }
        apply Hcoords2.
        let x0. assume Hx0_pair.
        claim Hexy0: exists y0 :e Y, p :e setprod {x0} {y0}.
        { exact (andER (x0 :e V) (exists y0 :e Y, p :e setprod {x0} {y0}) Hx0_pair). }
        apply Hexy0.
        let y0. assume Hy0_pair.
        claim Hpsing2: p :e setprod {x0} {y0}.
        { exact (andER (y0 :e Y) (p :e setprod {x0} {y0}) Hy0_pair). }
        claim HxV': x :e V.
        { exact (andEL (x :e V) (y :e Y) (setprod_coords_in x y V Y p Hpsing1 HpR2)). }
        claim HxUV: x :e U :/\: V.
        { exact (binintersectI U V x HxU' HxV'). }
        claim HxE: x :e Empty.
        { rewrite <- HUVempty. exact HxUV. }
        exact (EmptyE x HxE False). }
      { exact (Subq_Empty (R1 :/\: R2)). }
Qed.

(** from 17 Exercises 120: closures, boundaries, Hausdorff properties **) 
(** LATEX VERSION: Exercise 1: Given a notion of closed sets satisfying axioms, prove they come from a topology. **)
Theorem ex17_1_topology_from_closed_sets : forall X Tx:set,
  closed_in X Tx X -> (forall A:set, closed_in X Tx A -> closed_in X Tx (X :\: A)) -> topology_on X Tx.
let X Tx.
assume H1: closed_in X Tx X.
assume H2: forall A:set, closed_in X Tx A -> closed_in X Tx (X :\: A).
prove topology_on X Tx.
(** By definition, closed_in X Tx X means topology_on X Tx /\ ... **)
(** So we can extract topology_on X Tx directly from H1 **)
exact (andEL (topology_on X Tx) (X c= X /\ exists U :e Tx, X = X :\: U) H1).
Qed.

(** LATEX VERSION: Exercise 2: If Y is closed in X and A is closed in the subspace Y, then A is closed in X. **)
Theorem ex17_2_closed_in_closed_subspace : forall X Tx Y A:set,
  closed_in X Tx Y -> closed_in Y (subspace_topology X Tx Y) A -> closed_in X Tx A.
let X Tx Y A.
assume HY: closed_in X Tx Y.
assume HA: closed_in Y (subspace_topology X Tx Y) A.
prove closed_in X Tx A.
(** Extract topology_on X Tx from closed_in X Tx Y and apply closed_in_closed_subspace **)
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (Y c= X /\ exists U :e Tx, Y = X :\: U) HY). }
exact (closed_in_closed_subspace X Tx Y A HTx HY HA).
Qed.

(** LATEX VERSION: Exercise 3: Products of closed sets are closed in the product topology. **)
Theorem ex17_3_product_of_closed_sets_closed : forall X Tx Y Ty A B:set,
  closed_in X Tx A -> closed_in Y Ty B ->
  closed_in (setprod X Y) (product_topology X Tx Y Ty) (setprod A B).
let X Tx Y Ty A B.
assume HA: closed_in X Tx A.
assume HB: closed_in Y Ty B.
prove closed_in (setprod X Y) (product_topology X Tx Y Ty) (setprod A B).
  (** Strategy: (XY)\\(AB) = (X\\A)Y  X(Y\\B); X\\A and Y\\B are open, products are open, and unions are open. **)
(** Extract topologies and components from closed_in **)
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (A c= X /\ exists U :e Tx, A = X :\: U) HA). }
claim HTy: topology_on Y Ty.
{ exact (andEL (topology_on Y Ty) (B c= Y /\ exists V :e Ty, B = Y :\: V) HB). }
claim HAparts: A c= X /\ exists U :e Tx, A = X :\: U.
{ exact (andER (topology_on X Tx) (A c= X /\ exists U :e Tx, A = X :\: U) HA). }
claim HBparts: B c= Y /\ exists V :e Ty, B = Y :\: V.
{ exact (andER (topology_on Y Ty) (B c= Y /\ exists V :e Ty, B = Y :\: V) HB). }
claim HAsub: A c= X.
{ exact (andEL (A c= X) (exists U :e Tx, A = X :\: U) HAparts). }
claim HBsub: B c= Y.
{ exact (andEL (B c= Y) (exists V :e Ty, B = Y :\: V) HBparts). }
claim HexU: exists U :e Tx, A = X :\: U.
{ exact (andER (A c= X) (exists U :e Tx, A = X :\: U) HAparts). }
claim HexV: exists V :e Ty, B = Y :\: V.
{ exact (andER (B c= Y) (exists V :e Ty, B = Y :\: V) HBparts). }
(** Build the closed set property for product **)
claim HTProd: topology_on (setprod X Y) (product_topology X Tx Y Ty).
{ exact (product_topology_is_topology X Tx Y Ty HTx HTy). }
prove topology_on (setprod X Y) (product_topology X Tx Y Ty) /\
      (setprod A B c= setprod X Y /\
       exists W :e product_topology X Tx Y Ty, setprod A B = (setprod X Y) :\: W).
	apply andI.
	- exact HTProd.
	- apply andI.
	  + (** AB  XY **)
	    exact (setprod_Subq A B X Y HAsub HBsub).
	  + (** exists open W such that AB = (XY) \ W **)
	    apply HexU.
	    let U. assume HU_conj.
	    claim HUinTx: U :e Tx.
	    { exact (andEL (U :e Tx) (A = X :\: U) HU_conj). }
	    claim HAeq: A = X :\: U.
	    { exact (andER (U :e Tx) (A = X :\: U) HU_conj). }
	    apply HexV.
	    let V. assume HV_conj.
	    claim HVinTy: V :e Ty.
	    { exact (andEL (V :e Ty) (B = Y :\: V) HV_conj). }
	    claim HBeq: B = Y :\: V.
	    { exact (andER (V :e Ty) (B = Y :\: V) HV_conj). }
	    claim HUsubX: U c= X.
	    { exact (topology_elem_subset X Tx U HTx HUinTx). }
	    claim HVsubY: V c= Y.
	    { exact (topology_elem_subset Y Ty V HTy HVinTy). }
	    claim HXminusA: X :\: A = U.
	    { rewrite HAeq at 1.
	      exact (setminus_setminus_eq X U HUsubX). }
	    claim HYminusB: Y :\: B = V.
	    { rewrite HBeq at 1.
	      exact (setminus_setminus_eq Y V HVsubY). }
	    set W1 := setprod (X :\: A) Y.
	    set W2 := setprod X (Y :\: B).
	    set W := W1 :\/: W2.
	    witness W.
	    apply andI.
	    - (** W is open in product topology **)
	      claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
	      { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
	      claim HW1sub: W1 :e product_subbasis X Tx Y Ty.
	      { prove W1 :e product_subbasis X Tx Y Ty.
	        rewrite HXminusA.
	        claim HYTy: Y :e Ty.
	        { exact (topology_has_X Y Ty HTy). }
	        claim HW1fam: rectangle_set U Y :e {rectangle_set U V0|V0 :e Ty}.
	        { exact (ReplI Ty (fun V0:set => rectangle_set U V0) Y HYTy). }
	        exact (famunionI Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) U (rectangle_set U Y) HUinTx HW1fam). }
	      claim HW2sub: W2 :e product_subbasis X Tx Y Ty.
	      { prove W2 :e product_subbasis X Tx Y Ty.
	        rewrite HYminusB.
	        claim HXTx: X :e Tx.
	        { exact (topology_has_X X Tx HTx). }
	        claim HW2fam: rectangle_set X V :e {rectangle_set X V0|V0 :e Ty}.
	        { exact (ReplI Ty (fun V0:set => rectangle_set X V0) V HVinTy). }
	        exact (famunionI Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) X (rectangle_set X V) HXTx HW2fam). }
	      claim HW1open: W1 :e product_topology X Tx Y Ty.
	      { exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis W1 HW1sub). }
	      claim HW2open: W2 :e product_topology X Tx Y Ty.
	      { exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis W2 HW2sub). }
	      exact (lemma_union_two_open (setprod X Y) (product_topology X Tx Y Ty) W1 W2 HTProd HW1open HW2open).
	    - (** AB is complement of W **)
	      prove setprod A B = setprod X Y :\: W.
	      apply set_ext.
	      + let p. assume Hp: p :e setprod A B.
	        prove p :e setprod X Y :\: W.
	        claim HpXY: p :e setprod X Y.
	        { exact ((setprod_Subq A B X Y HAsub HBsub) p Hp). }
	        claim Hexab: exists x :e A, exists y :e B, p :e setprod {x} {y}.
	        { exact (setprod_elem_decompose A B p Hp). }
		        claim HpNotW: p /:e W.
		        { apply Hexab.
		          let x. assume Hx_conj.
		          claim HxA': x :e A.
		          { exact (andEL (x :e A) (exists y0 :e B, p :e setprod {x} {y0}) Hx_conj). }
		          claim Hexy: exists y0 :e B, p :e setprod {x} {y0}.
		          { exact (andER (x :e A) (exists y0 :e B, p :e setprod {x} {y0}) Hx_conj). }
		          apply Hexy.
		          let y. assume Hy_conj.
		          claim HyB: y :e B.
		          { exact (andEL (y :e B) (p :e setprod {x} {y}) Hy_conj). }
		          claim Hpsing: p :e setprod {x} {y}.
		          { exact (andER (y :e B) (p :e setprod {x} {y}) Hy_conj). }
		          assume HpW: p :e W.
		          apply (binunionE W1 W2 p HpW).
		          - assume HpW1: p :e W1.
		            claim Hxy: x :e (X :\: A) /\ y :e Y.
		            { exact (setprod_coords_in x y (X :\: A) Y p Hpsing HpW1). }
		            claim HxXA: x :e X :\: A.
		            { exact (andEL (x :e X :\: A) (y :e Y) Hxy). }
		            exact ((setminusE2 X A x HxXA) HxA').
	          - assume HpW2: p :e W2.
	            claim Hxy: x :e X /\ y :e (Y :\: B).
	            { exact (setprod_coords_in x y X (Y :\: B) p Hpsing HpW2). }
	            claim HyYB: y :e Y :\: B.
	            { exact (andER (x :e X) (y :e Y :\: B) Hxy). }
		            exact ((setminusE2 Y B y HyYB) HyB). }
		        exact (setminusI (setprod X Y) W p HpXY HpNotW).
	      + let p. assume Hp: p :e setprod X Y :\: W.
	        prove p :e setprod A B.
	        claim HpXY: p :e setprod X Y.
	        { exact (setminusE1 (setprod X Y) W p Hp). }
	        claim HpNotW: p /:e W.
	        { exact (setminusE2 (setprod X Y) W p Hp). }
		        claim Hexxy: exists x :e X, exists y :e Y, p :e setprod {x} {y}.
		        { exact (setprod_elem_decompose X Y p HpXY). }
		        apply Hexxy.
		        let x. assume Hx_conj.
		        claim HxX: x :e X.
		        { exact (andEL (x :e X) (exists y0 :e Y, p :e setprod {x} {y0}) Hx_conj). }
		        claim Hexy: exists y0 :e Y, p :e setprod {x} {y0}.
		        { exact (andER (x :e X) (exists y0 :e Y, p :e setprod {x} {y0}) Hx_conj). }
		        apply Hexy.
		        let y. assume Hy_conj.
		        claim HyY: y :e Y.
		        { exact (andEL (y :e Y) (p :e setprod {x} {y}) Hy_conj). }
		        claim Hpsing: p :e setprod {x} {y}.
		        { exact (andER (y :e Y) (p :e setprod {x} {y}) Hy_conj). }
		        claim HxA: x :e A.
	        { apply (xm (x :e A)).
	          - assume H. exact H.
	          - assume HxNotA: ~(x :e A).
	            claim HxXA: x :e X :\: A.
	            { exact (setminusI X A x HxX HxNotA). }
	            claim HxSingSub: {x} c= X :\: A.
	            { exact (singleton_subset x (X :\: A) HxXA). }
	            claim HySingSub: {y} c= Y.
	            { exact (singleton_subset y Y HyY). }
	            claim HpW1: p :e W1.
	            { claim Hsub: setprod {x} {y} c= W1.
	              { exact (setprod_Subq {x} {y} (X :\: A) Y HxSingSub HySingSub). }
	              exact (Hsub p Hpsing). }
	            apply FalseE.
	            exact (HpNotW (binunionI1 W1 W2 p HpW1)). }
	        claim HyB: y :e B.
	        { apply (xm (y :e B)).
	          - assume H. exact H.
	          - assume HyNotB: ~(y :e B).
	            claim HyYB: y :e Y :\: B.
	            { exact (setminusI Y B y HyY HyNotB). }
	            claim HySingSub: {y} c= Y :\: B.
	            { exact (singleton_subset y (Y :\: B) HyYB). }
	            claim HxSingSub: {x} c= X.
	            { exact (singleton_subset x X HxX). }
	            claim HpW2: p :e W2.
	            { claim Hsub: setprod {x} {y} c= W2.
	              { exact (setprod_Subq {x} {y} X (Y :\: B) HxSingSub HySingSub). }
	              exact (Hsub p Hpsing). }
	            apply FalseE.
	            exact (HpNotW (binunionI2 W1 W2 p HpW2)). }
	        claim HxSingSubA: {x} c= A.
	        { exact (singleton_subset x A HxA). }
	        claim HySingSubB: {y} c= B.
	        { exact (singleton_subset y B HyB). }
	        claim HpAB: p :e setprod A B.
	        { claim Hsub: setprod {x} {y} c= setprod A B.
	          { exact (setprod_Subq {x} {y} A B HxSingSubA HySingSubB). }
	          exact (Hsub p Hpsing). }
	        exact HpAB.
Qed.

(** LATEX VERSION: Exercise 4: For open U and closed A, U\\A is open and A\\U is closed. **)
Theorem ex17_4_open_minus_closed_and_closed_minus_open : forall X Tx U A:set,
  topology_on X Tx -> open_in X Tx U -> closed_in X Tx A ->
  open_in X Tx (U :\: A) /\ closed_in X Tx (A :\: U).
let X Tx U A.
assume Htop: topology_on X Tx.
assume HU: open_in X Tx U.
assume HA: closed_in X Tx A.
prove open_in X Tx (U :\: A) /\ closed_in X Tx (A :\: U).
(** Strategy: U\A = U  V for some V open (from A = X\V); A\U = A  (X\U) closed **)
claim HUtop: U :e Tx.
{ exact (andER (topology_on X Tx) (U :e Tx) HU). }
claim HAdef: A c= X /\ (exists V :e Tx, A = X :\: V).
{ exact (andER (topology_on X Tx) (A c= X /\ (exists V :e Tx, A = X :\: V)) HA). }
claim HexV: exists V :e Tx, A = X :\: V.
{ exact (andER (A c= X) (exists V :e Tx, A = X :\: V) HAdef). }
apply HexV.
let V. assume HVandEq. apply HVandEq.
assume HV: V :e Tx.
assume HAeq: A = X :\: V.
apply andI.
- prove open_in X Tx (U :\: A).
  (** U :\: A = U :\: (X :\: V) = U :/\: V when U c= X **)
  claim HUsub: U c= X.
  { exact (topology_elem_subset X Tx U Htop HUtop). }
  claim HUminusA_eq_UinterV: U :\: A = U :/\: V.
  { rewrite HAeq.
    apply set_ext.
    + let x. assume Hx: x :e U :\: (X :\: V).
      claim HxU: x :e U.
      { exact (setminusE1 U (X :\: V) x Hx). }
      claim HxnotXV: x /:e X :\: V.
      { exact (setminusE2 U (X :\: V) x Hx). }
      claim HxV: x :e V.
      { claim HxX: x :e X.
        { exact (HUsub x HxU). }
        apply xm (x :e V).
        * assume Hv. exact Hv.
        * assume Hnv.
          apply FalseE.
          apply HxnotXV.
          exact (setminusI X V x HxX Hnv). }
      exact (binintersectI U V x HxU HxV).
    + let x. assume Hx: x :e U :/\: V.
      claim HxU: x :e U.
      { exact (binintersectE1 U V x Hx). }
      claim HxV: x :e V.
      { exact (binintersectE2 U V x Hx). }
      claim HxnotXV: x /:e X :\: V.
      { assume H. apply (setminusE2 X V x H). exact HxV. }
      exact (setminusI U (X :\: V) x HxU HxnotXV). }
  rewrite HUminusA_eq_UinterV.
  claim HUinterV: U :/\: V :e Tx.
  { exact (topology_binintersect_closed X Tx U V Htop HUtop HV). }
  exact (andI (topology_on X Tx) (U :/\: V :e Tx) Htop HUinterV).
- prove closed_in X Tx (A :\: U).
  (** A :\: U = (X :\: V) :\: U = X :\: (V :\/: U), and V :\/: U is open **)
  claim HAsub: A c= X.
  { exact (andEL (A c= X) (exists V0 :e Tx, A = X :\: V0) HAdef). }
  claim HAminusU_sub: A :\: U c= X.
  { let x. assume Hx. claim HxA: x :e A. { exact (setminusE1 A U x Hx). }
    exact (HAsub x HxA). }
  claim HVU: V :\/: U :e Tx.
  { exact (lemma_union_two_open X Tx V U Htop HV HUtop). }
  claim HAminusU_eq_XminusVU: A :\: U = X :\: (V :\/: U).
  { rewrite HAeq.
    apply set_ext.
    + let x. assume Hx: x :e (X :\: V) :\: U.
      claim HxXV: x :e X :\: V.
      { exact (setminusE1 (X :\: V) U x Hx). }
      claim HxnotU: x /:e U.
      { exact (setminusE2 (X :\: V) U x Hx). }
      claim HxX: x :e X.
      { exact (setminusE1 X V x HxXV). }
      claim HxnotV: x /:e V.
      { exact (setminusE2 X V x HxXV). }
      claim HxnotVU: x /:e V :\/: U.
      { assume H. apply (binunionE V U x H).
        - assume HxV. exact (HxnotV HxV).
        - assume HxU. exact (HxnotU HxU). }
      exact (setminusI X (V :\/: U) x HxX HxnotVU).
    + let x. assume Hx: x :e X :\: (V :\/: U).
      claim HxX: x :e X.
      { exact (setminusE1 X (V :\/: U) x Hx). }
      claim HxnotVU: x /:e V :\/: U.
      { exact (setminusE2 X (V :\/: U) x Hx). }
      claim HxnotV: x /:e V.
      { assume HxV. apply HxnotVU. exact (binunionI1 V U x HxV). }
      claim HxnotU: x /:e U.
      { assume HxU. apply HxnotVU. exact (binunionI2 V U x HxU). }
      claim HxXV: x :e X :\: V.
      { exact (setminusI X V x HxX HxnotV). }
      exact (setminusI (X :\: V) U x HxXV HxnotU). }
  claim HPred: exists W :e Tx, A :\: U = X :\: W.
  { witness (V :\/: U).
    apply andI.
    - exact HVU.
    - exact HAminusU_eq_XminusVU. }
  exact (andI (topology_on X Tx) (A :\: U c= X /\ (exists W :e Tx, A :\: U = X :\: W)) Htop (andI (A :\: U c= X) (exists W :e Tx, A :\: U = X :\: W) HAminusU_sub HPred)).
Qed.

(** LATEX VERSION: Exercise 5: Let X be an ordered set in the order topology. Show that cl((a,b)) c= [a,b]. Under what conditions does equality hold **)
Theorem ex17_5_closure_of_interval_in_order_topology : forall X a b:set,
  closure_of X (order_topology X) (order_interval X a b) c= closed_interval_in X a b.
let X a b.
prove closure_of X (order_topology X) (order_interval X a b) c= closed_interval_in X a b.
set Tx := order_topology X.
claim HTx: topology_on X Tx.
{ exact (order_topology_is_topology X). }
claim Hsub: order_interval X a b c= closed_interval_in X a b.
{ let x. assume Hx: x :e order_interval X a b.
  prove x :e closed_interval_in X a b.
  claim Hxpack: x :e X /\ (order_rel X a x /\ order_rel X x b).
  { exact (order_intervalE X a b x Hx). }
  claim HxX: x :e X.
  { exact (andEL (x :e X) (order_rel X a x /\ order_rel X x b) Hxpack). }
  claim Hrel: order_rel X a x /\ order_rel X x b.
  { exact (andER (x :e X) (order_rel X a x /\ order_rel X x b) Hxpack). }
	  claim Hax: order_rel X a x.
	  { exact (andEL (order_rel X a x) (order_rel X x b) Hrel). }
	  claim Hxb: order_rel X x b.
	  { exact (andER (order_rel X a x) (order_rel X x b) Hrel). }
	  claim Hci_def: closed_interval_in X a b =
	    {x0 :e X | (x0 = a \/ order_rel X a x0) /\ (x0 = b \/ order_rel X x0 b)}.
	  { reflexivity. }
	  rewrite Hci_def.
	  apply (SepI X
	    (fun x0:set => (x0 = a \/ order_rel X a x0) /\ (x0 = b \/ order_rel X x0 b))
	    x HxX).
	  apply andI.
	  - exact (orIR (x = a) (order_rel X a x) Hax).
	  - exact (orIR (x = b) (order_rel X x b) Hxb). }
claim Hclosed: closed_in X Tx (closed_interval_in X a b).
{ admit. }
exact (closure_subset_of_closed_superset X Tx (order_interval X a b) (closed_interval_in X a b)
  HTx Hsub Hclosed).
Qed.

(** Helper definition for Exercise 5: no immediate successor and predecessor endpoints **)
Definition no_immediate_successor : set -> set -> prop := fun X a =>
  forall c:set, c :e X -> order_rel X a c ->
    exists x:set, x :e X /\ order_rel X a x /\ order_rel X x c.

Definition no_immediate_predecessor : set -> set -> prop := fun X b =>
  forall c:set, c :e X -> order_rel X c b ->
    exists x:set, x :e X /\ order_rel X c x /\ order_rel X x b.

(** LATEX VERSION: Exercise 5: Equality holds when the endpoints are limit points of (a,b) from within X, e.g. in a dense order without gaps **)
Theorem ex17_5_closure_of_interval_eq_conditions : forall X a b:set,
  a :e X -> b :e X -> order_rel X a b ->
  no_immediate_successor X a ->
  no_immediate_predecessor X b ->
  closure_of X (order_topology X) (order_interval X a b) = closed_interval_in X a b.
let X a b.
assume Ha: a :e X.
assume Hb: b :e X.
assume Hab: order_rel X a b.
assume Hsucc: no_immediate_successor X a.
assume Hpred: no_immediate_predecessor X b.
prove closure_of X (order_topology X) (order_interval X a b) = closed_interval_in X a b.
admit.
Qed.

(** Helper: closure is idempotent and closed **)
(** LATEX VERSION: Closure is closed and idempotent: cl(cl(A)) = cl(A), and cl(A) is closed **)
Theorem closure_idempotent_and_closed : forall X Tx A:set,
  topology_on X Tx ->
  closure_of X Tx (closure_of X Tx A) = closure_of X Tx A /\
  closed_in X Tx (closure_of X Tx A).
let X Tx A.
assume Htop: topology_on X Tx.
prove closure_of X Tx (closure_of X Tx A) = closure_of X Tx A /\ closed_in X Tx (closure_of X Tx A).
(** Strategy: Prove part 2 first (cl(A) is closed), then use it for part 1 (idempotence) **)
set clA := closure_of X Tx A.
claim HclA_sub: clA c= X.
{ let x. assume Hx: x :e clA.
  prove x :e X.
  exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx). }
(** To show clA is closed we want closure_is_closed, but that yields closed_in X Tx (closure_of X Tx clA); we instead prove closed_in X Tx clA directly via the closure definition. **)
apply andI.
- (** cl(cl(A)) = cl(A) - idempotence follows from closure being closed **)
  prove closure_of X Tx clA = clA.
  claim HclA_closed: closed_in X Tx clA.
  { (** Apply closure_is_closed with (A :/\: X) instead of A **)
    (** Since closure_of X Tx (A :/\: X) = closure_of X Tx A, and (A :/\: X) c= X **)
    claim HAX_sub: A :/\: X c= X.
    { exact (binintersect_Subq_2 A X). }
    claim Heq_closure: closure_of X Tx (A :/\: X) = closure_of X Tx A.
    { apply set_ext.
      - let x. assume Hx: x :e closure_of X Tx (A :/\: X).
        prove x :e closure_of X Tx A.
        claim HxX: x :e X.
        { exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: (A :/\: X) <> Empty) x Hx). }
        claim Hcond: forall U:set, U :e Tx -> x :e U -> U :/\: (A :/\: X) <> Empty.
        { exact (SepE2 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: (A :/\: X) <> Empty) x Hx). }
        claim Hpred: forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
        { let U. assume HU: U :e Tx. assume HxU: x :e U.
          claim HUX: U c= X.
          { exact (topology_elem_subset X Tx U Htop HU). }
          claim Hinter1: U :/\: (A :/\: X) <> Empty.
          { exact (Hcond U HU HxU). }
          (** U :/\: (A :/\: X) = (U :/\: A) :/\: X, but since U c= X, this equals U :/\: A **)
          claim Heq_inter: U :/\: (A :/\: X) = U :/\: A.
          { apply set_ext.
            - let y. assume Hy: y :e U :/\: (A :/\: X).
              claim HyU: y :e U.
              { exact (binintersectE1 U (A :/\: X) y Hy). }
              claim HyAX: y :e A :/\: X.
              { exact (binintersectE2 U (A :/\: X) y Hy). }
              claim HyA: y :e A.
              { exact (binintersectE1 A X y HyAX). }
              exact (binintersectI U A y HyU HyA).
            - let y. assume Hy: y :e U :/\: A.
              claim HyU: y :e U.
              { exact (binintersectE1 U A y Hy). }
              claim HyA: y :e A.
              { exact (binintersectE2 U A y Hy). }
              claim HyX: y :e X.
              { exact (HUX y HyU). }
              claim HyAX: y :e A :/\: X.
              { exact (binintersectI A X y HyA HyX). }
              exact (binintersectI U (A :/\: X) y HyU HyAX). }
          rewrite <- Heq_inter.
          exact Hinter1. }
        exact (SepI X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x HxX Hpred).
      - let x. assume Hx: x :e closure_of X Tx A.
        prove x :e closure_of X Tx (A :/\: X).
        claim HxX: x :e X.
        { exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx). }
        claim Hcond: forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
        { exact (SepE2 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx). }
        claim Hpred: forall U:set, U :e Tx -> x :e U -> U :/\: (A :/\: X) <> Empty.
        { let U. assume HU: U :e Tx. assume HxU: x :e U.
          claim HUX: U c= X.
          { exact (topology_elem_subset X Tx U Htop HU). }
          claim Hinter1: U :/\: A <> Empty.
          { exact (Hcond U HU HxU). }
          claim Heq_inter: U :/\: (A :/\: X) = U :/\: A.
          { apply set_ext.
            - let y. assume Hy: y :e U :/\: (A :/\: X).
              claim HyU: y :e U.
              { exact (binintersectE1 U (A :/\: X) y Hy). }
              claim HyAX: y :e A :/\: X.
              { exact (binintersectE2 U (A :/\: X) y Hy). }
              claim HyA: y :e A.
              { exact (binintersectE1 A X y HyAX). }
              exact (binintersectI U A y HyU HyA).
            - let y. assume Hy: y :e U :/\: A.
              claim HyU: y :e U.
              { exact (binintersectE1 U A y Hy). }
              claim HyA: y :e A.
              { exact (binintersectE2 U A y Hy). }
              claim HyX: y :e X.
              { exact (HUX y HyU). }
              claim HyAX: y :e A :/\: X.
              { exact (binintersectI A X y HyA HyX). }
              exact (binintersectI U (A :/\: X) y HyU HyAX). }
          rewrite Heq_inter.
          exact Hinter1. }
        exact (SepI X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: (A :/\: X) <> Empty) x HxX Hpred).
    }
    rewrite <- Heq_closure.
    exact (closure_is_closed X Tx (A :/\: X) Htop HAX_sub).
  }
  exact (closed_closure_eq X Tx clA Htop HclA_closed).
- (** cl(A) is closed **)
  prove closed_in X Tx clA.
  (** Same proof as above **)
  claim HAX_sub: A :/\: X c= X.
  { exact (binintersect_Subq_2 A X). }
  claim Heq_closure: closure_of X Tx (A :/\: X) = closure_of X Tx A.
  { apply set_ext.
    - let x. assume Hx: x :e closure_of X Tx (A :/\: X).
      prove x :e closure_of X Tx A.
      claim HxX: x :e X.
      { exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: (A :/\: X) <> Empty) x Hx). }
      claim Hcond: forall U:set, U :e Tx -> x :e U -> U :/\: (A :/\: X) <> Empty.
      { exact (SepE2 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: (A :/\: X) <> Empty) x Hx). }
      claim Hpred: forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
      { let U. assume HU: U :e Tx. assume HxU: x :e U.
        claim HUX: U c= X.
        { exact (topology_elem_subset X Tx U Htop HU). }
        claim Hinter1: U :/\: (A :/\: X) <> Empty.
        { exact (Hcond U HU HxU). }
        claim Heq_inter: U :/\: (A :/\: X) = U :/\: A.
        { apply set_ext.
          - let y. assume Hy: y :e U :/\: (A :/\: X).
            claim HyU: y :e U.
            { exact (binintersectE1 U (A :/\: X) y Hy). }
            claim HyAX: y :e A :/\: X.
            { exact (binintersectE2 U (A :/\: X) y Hy). }
            claim HyA: y :e A.
            { exact (binintersectE1 A X y HyAX). }
            exact (binintersectI U A y HyU HyA).
          - let y. assume Hy: y :e U :/\: A.
            claim HyU: y :e U.
            { exact (binintersectE1 U A y Hy). }
            claim HyA: y :e A.
            { exact (binintersectE2 U A y Hy). }
            claim HyX: y :e X.
            { exact (HUX y HyU). }
            claim HyAX: y :e A :/\: X.
            { exact (binintersectI A X y HyA HyX). }
            exact (binintersectI U (A :/\: X) y HyU HyAX). }
        rewrite <- Heq_inter.
        exact Hinter1. }
      exact (SepI X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x HxX Hpred).
    - let x. assume Hx: x :e closure_of X Tx A.
      prove x :e closure_of X Tx (A :/\: X).
      claim HxX: x :e X.
      { exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx). }
      claim Hcond: forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
      { exact (SepE2 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx). }
      claim Hpred: forall U:set, U :e Tx -> x :e U -> U :/\: (A :/\: X) <> Empty.
      { let U. assume HU: U :e Tx. assume HxU: x :e U.
        claim HUX: U c= X.
        { exact (topology_elem_subset X Tx U Htop HU). }
        claim Hinter1: U :/\: A <> Empty.
        { exact (Hcond U HU HxU). }
        claim Heq_inter: U :/\: (A :/\: X) = U :/\: A.
        { apply set_ext.
          - let y. assume Hy: y :e U :/\: (A :/\: X).
            claim HyU: y :e U.
            { exact (binintersectE1 U (A :/\: X) y Hy). }
            claim HyAX: y :e A :/\: X.
            { exact (binintersectE2 U (A :/\: X) y Hy). }
            claim HyA: y :e A.
            { exact (binintersectE1 A X y HyAX). }
            exact (binintersectI U A y HyU HyA).
          - let y. assume Hy: y :e U :/\: A.
            claim HyU: y :e U.
            { exact (binintersectE1 U A y Hy). }
            claim HyA: y :e A.
            { exact (binintersectE2 U A y Hy). }
            claim HyX: y :e X.
            { exact (HUX y HyU). }
            claim HyAX: y :e A :/\: X.
            { exact (binintersectI A X y HyA HyX). }
            exact (binintersectI U (A :/\: X) y HyU HyAX). }
        rewrite Heq_inter.
        exact Hinter1. }
      exact (SepI X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: (A :/\: X) <> Empty) x HxX Hpred).
  }
  rewrite <- Heq_closure.
  exact (closure_is_closed X Tx (A :/\: X) Htop HAX_sub).
Qed.

(** from 17 Exercise 6(a): monotonicity of closure **)
(** LATEX VERSION: If A c= B then cl(A) c= cl(B). **)
Theorem ex17_6a_closure_monotone : forall X Tx A B:set,
  topology_on X Tx -> A c= B -> B c= X -> closure_of X Tx A c= closure_of X Tx B.
let X Tx A B.
assume Htop: topology_on X Tx.
assume HAB: A c= B.
assume HB: B c= X.
prove closure_of X Tx A c= closure_of X Tx B.
exact (closure_monotone X Tx A B Htop HAB HB).
Qed.

(** from 17 Exercise 6(b): closure of a union **)
(** LATEX VERSION: cl(A :\/: B) = cl(A) :\/: cl(B). **)
Theorem ex17_6b_closure_binunion : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  closure_of X Tx (A :\/: B) = closure_of X Tx A :\/: closure_of X Tx B.
let X Tx A B.
assume Htop: topology_on X Tx.
assume HA: A c= X.
assume HB: B c= X.
prove closure_of X Tx (A :\/: B) = closure_of X Tx A :\/: closure_of X Tx B.
set clA := closure_of X Tx A.
set clB := closure_of X Tx B.
apply set_ext.
- (** closure(AB) c= cl(A)  cl(B) **)
  claim Hsup: closure_of X Tx (A :\/: B) c= clA :\/: clB.
  { (** clA  clB is closed and contains A  B **)
    claim HclA_closed: closed_in X Tx clA.
    { claim Hc: closure_of X Tx (closure_of X Tx A) = closure_of X Tx A /\ closed_in X Tx (closure_of X Tx A).
      { exact (closure_idempotent_and_closed X Tx A Htop). }
      exact (andER (closure_of X Tx (closure_of X Tx A) = closure_of X Tx A) (closed_in X Tx (closure_of X Tx A)) Hc). }
    claim HclB_closed: closed_in X Tx clB.
    { claim Hc: closure_of X Tx (closure_of X Tx B) = closure_of X Tx B /\ closed_in X Tx (closure_of X Tx B).
      { exact (closure_idempotent_and_closed X Tx B Htop). }
      exact (andER (closure_of X Tx (closure_of X Tx B) = closure_of X Tx B) (closed_in X Tx (closure_of X Tx B)) Hc). }
    claim HclUnionClosed: closed_in X Tx (clA :\/: clB).
    { exact (union_of_closed_is_closed X Tx clA clB Htop HclA_closed HclB_closed). }
    claim HABsub: A :\/: B c= clA :\/: clB.
    { let y. assume Hy: y :e A :\/: B.
      apply (binunionE A B y Hy).
      - assume HyA: y :e A.
        claim HyclA: y :e clA.
        { exact (subset_of_closure X Tx A Htop HA y HyA). }
        exact (binunionI1 clA clB y HyclA).
      - assume HyB: y :e B.
        claim HyclB: y :e clB.
        { exact (subset_of_closure X Tx B Htop HB y HyB). }
        exact (binunionI2 clA clB y HyclB). }
    exact (closure_subset_of_closed_superset X Tx (A :\/: B) (clA :\/: clB) Htop HABsub HclUnionClosed). }
  let x. assume Hx: x :e closure_of X Tx (A :\/: B).
  exact (Hsup x Hx).
- (** cl(A)  cl(B) c= closure(AB) **)
  claim Hsub: clA :\/: clB c= closure_of X Tx (A :\/: B).
  { exact (closure_union_contains_union_closures X Tx A B Htop HA HB). }
  exact Hsub.
Qed.

(** from 17 Exercise 6(c): closure of an arbitrary union contains union of closures **)
(** LATEX VERSION: cl(Union A_alpha) c=?; always have cl(Union A_alpha) c>= Union cl(A_alpha). **)
Theorem ex17_6c_closure_Union_contains_Union_closures : forall X Tx Fam:set,
  topology_on X Tx ->
  (forall A:set, A :e Fam -> A c= X) ->
  Union {closure_of X Tx A|A :e Fam} c= closure_of X Tx (Union Fam).
let X Tx Fam.
assume Htop: topology_on X Tx.
assume HFsub: forall A:set, A :e Fam -> A c= X.
prove Union {closure_of X Tx A|A :e Fam} c= closure_of X Tx (Union Fam).
set ClFam := {closure_of X Tx A|A :e Fam}.
claim HUnionSubX: Union Fam c= X.
{ let x. assume Hx: x :e Union Fam.
  apply (UnionE_impred Fam x Hx).
  let A. assume HxA. assume HAFam.
  exact ((HFsub A HAFam) x HxA). }
let x. assume Hx: x :e Union ClFam.
prove x :e closure_of X Tx (Union Fam).
apply (UnionE_impred ClFam x Hx).
let W. assume HxW. assume HWClFam.
apply (ReplE Fam (fun A:set => closure_of X Tx A) W HWClFam).
let A. assume HAconj.
claim HAFam: A :e Fam.
{ exact (andEL (A :e Fam) (W = closure_of X Tx A) HAconj). }
claim HWeq: W = closure_of X Tx A.
{ exact (andER (A :e Fam) (W = closure_of X Tx A) HAconj). }
claim HxclA: x :e closure_of X Tx A.
{ rewrite <- HWeq. exact HxW. }
claim HASubUnion: A c= Union Fam.
{ let y. assume Hy: y :e A.
  exact (UnionI Fam y A Hy HAFam). }
claim HxclUnion: x :e closure_of X Tx (Union Fam).
{ exact (closure_monotone X Tx A (Union Fam) Htop HASubUnion HUnionSubX x HxclA). }
exact HxclUnion.
Qed.

(** from 17 Exercise 7: critique the attempted proof about closures of unions **)
(** LATEX VERSION: Criticize the proof that cl(Union A_alpha) c= Union cl(A_alpha). **)
Theorem ex17_7_counterexample_union_closure :
  exists X Tx Fam:set,
    topology_on X Tx /\
    (forall A:set, A :e Fam -> A c= X) /\
    ~ (closure_of X Tx (Union Fam) c= Union {closure_of X Tx A|A :e Fam}).
claim HXomega: 0 :e omega.
{ exact (nat_p_omega 0 nat_0). }
witness omega.
witness (finite_complement_topology omega).
set X := omega.
set Tx := finite_complement_topology omega.
set Fam := {{n}|n :e X :\: {0}}.
witness Fam.
prove topology_on X Tx /\ (forall A:set, A :e Fam -> A c= X) /\ ~ (closure_of X Tx (Union Fam) c= Union {closure_of X Tx A|A :e Fam}).
apply andI.
- (** topology and subset property **)
  apply andI.
  + exact (finite_complement_topology_on X).
  + (** every member of Fam is a subset of X **)
    let A. assume HA: A :e Fam.
    prove A c= X.
    apply (ReplE (X :\: {0}) (fun n:set => {n}) A HA).
    let n. assume Hnconj.
    claim HninX0: n :e X :\: {0}.
    { exact (andEL (n :e X :\: {0}) (A = {n}) Hnconj). }
    claim HAeq: A = {n}.
    { exact (andER (n :e X :\: {0}) (A = {n}) Hnconj). }
    rewrite HAeq.
    let x. assume Hx: x :e {n}.
    claim HxEq: x = n.
    { exact (SingE n x Hx). }
    rewrite HxEq.
    exact (setminusE1 X {0} n HninX0).
- (** counterexample element: 0 **)
  prove ~ (closure_of X Tx (Union Fam) c= Union {closure_of X Tx A|A :e Fam}).
  assume Hsub: closure_of X Tx (Union Fam) c= Union {closure_of X Tx A|A :e Fam}.
    set ClFam := {closure_of X Tx A|A :e Fam}.
    claim Htop: topology_on X Tx.
    { exact (finite_complement_topology_on X). }
    (** Union Fam = X\\{0} **)
    claim HUnionEq: Union Fam = X :\: {0}.
    { apply set_ext.
      - let x. assume Hx: x :e Union Fam.
        prove x :e X :\: {0}.
        apply (UnionE_impred Fam x Hx).
        let A. assume HxA. assume HAFam.
        apply (ReplE (X :\: {0}) (fun n:set => {n}) A HAFam).
        let n. assume Hnconj.
        claim HninX0: n :e X :\: {0}.
        { exact (andEL (n :e X :\: {0}) (A = {n}) Hnconj). }
        claim HAeq: A = {n}.
        { exact (andER (n :e X :\: {0}) (A = {n}) Hnconj). }
        claim HxEq: x = n.
        { claim HxSing: x :e {n}.
          { rewrite <- HAeq. exact HxA. }
          exact (SingE n x HxSing). }
        rewrite HxEq.
        exact HninX0.
      - let x. assume Hx: x :e X :\: {0}.
        prove x :e Union Fam.
        claim HSingFam: {x} :e Fam.
        { exact (ReplI (X :\: {0}) (fun n:set => {n}) x Hx). }
        exact (UnionI Fam x {x} (SingI x) HSingFam).
    }
    (** X\\{0} is infinite, so Union Fam is infinite **)
    claim HsubXX: X c= X.
    { let x. assume Hx: x :e X. exact Hx. }
    claim Hatleast: atleastp omega X.
    { exact (Subq_atleastp omega X HsubXX). }
    claim HinfX: infinite X.
    { exact (atleastp_omega_infinite X Hatleast). }
    claim HinfUnion: infinite (Union Fam).
    { rewrite HUnionEq.
      exact (infinite_remove1 X HinfX 0). }
    (** 0 is in closure(Union Fam) **)
    claim H0in_closure: 0 :e closure_of X Tx (Union Fam).
    { apply (iffER (0 :e closure_of X Tx (Union Fam))
                   (forall U :e Tx, 0 :e U -> U :/\: (Union Fam) <> Empty)
                   (closure_characterization X Tx (Union Fam) 0 Htop HXomega)).
      let U. assume HU: U :e Tx. assume H0U: 0 :e U.
      prove U :/\: (Union Fam) <> Empty.
      claim HUdata: finite (X :\: U) \/ U = Empty.
      { exact (SepE2 (Power X) (fun U0:set => finite (X :\: U0) \/ U0 = Empty) U HU). }
      apply HUdata (U :/\: (Union Fam) <> Empty).
      - assume HUfin: finite (X :\: U).
        prove U :/\: (Union Fam) <> Empty.
        assume Hinter: U :/\: (Union Fam) = Empty.
        (** show Union Fam  X\\U, hence finite, contradiction **)
        claim Hsub: Union Fam c= X :\: U.
        { let x. assume HxUFam: x :e Union Fam.
          prove x :e X :\: U.
          claim HxX: x :e X.
          { apply (UnionE_impred Fam x HxUFam).
            let A. assume HxA. assume HAFam.
            apply (ReplE (X :\: {0}) (fun n:set => {n}) A HAFam).
            let n. assume Hnconj.
            claim HninX0: n :e X :\: {0}.
            { exact (andEL (n :e X :\: {0}) (A = {n}) Hnconj). }
            claim HAeq: A = {n}.
            { exact (andER (n :e X :\: {0}) (A = {n}) Hnconj). }
            claim HxEq: x = n.
            { claim HxSing: x :e {n}.
              { rewrite <- HAeq. exact HxA. }
              exact (SingE n x HxSing). }
            rewrite HxEq.
            exact (setminusE1 X {0} n HninX0). }
          claim HxnotU: x /:e U.
          { assume HxU: x :e U.
            claim HxInter: x :e U :/\: (Union Fam).
            { apply binintersectI.
              - exact HxU.
              - exact HxUFam. }
            claim HxEmpty: x :e Empty.
            { rewrite <- Hinter. exact HxInter. }
            exact (EmptyE x HxEmpty). }
          exact (setminusI X U x HxX HxnotU). }
        claim HfinUFam: finite (Union Fam).
        { exact (Subq_finite (X :\: U) HUfin (Union Fam) Hsub). }
        apply HinfUnion.
        exact HfinUFam.
      - assume HUempty: U = Empty.
        prove U :/\: (Union Fam) <> Empty.
        assume Hinter: U :/\: (Union Fam) = Empty.
        claim HUne: U <> Empty.
        { exact (elem_implies_nonempty U 0 H0U). }
        apply FalseE.
        exact (HUne HUempty). }
    (** 0 is not in the union of the closures **)
    claim H0not_union_closures: 0 /:e Union ClFam.
    { assume H0in: 0 :e Union ClFam.
      apply (UnionE_impred ClFam 0 H0in).
      let W. assume H0W: 0 :e W. assume HWCl: W :e ClFam.
      apply (ReplE Fam (fun A:set => closure_of X Tx A) W HWCl).
      let A. assume HAconj.
      claim HAFam: A :e Fam.
      { exact (andEL (A :e Fam) (W = closure_of X Tx A) HAconj). }
      claim HWeq: W = closure_of X Tx A.
      { exact (andER (A :e Fam) (W = closure_of X Tx A) HAconj). }
      claim H0clA: 0 :e closure_of X Tx A.
      { rewrite <- HWeq. exact H0W. }
      apply (ReplE (X :\: {0}) (fun n:set => {n}) A HAFam).
      let n. assume Hnconj.
      claim HninX0: n :e X :\: {0}.
      { exact (andEL (n :e X :\: {0}) (A = {n}) Hnconj). }
      claim HAeq: A = {n}.
      { exact (andER (n :e X :\: {0}) (A = {n}) Hnconj). }
      claim HninX: n :e X.
      { exact (setminusE1 X {0} n HninX0). }
      claim HSingSub: {n} c= X.
      { let x. assume Hx: x :e {n}.
        claim HxEq: x = n.
        { exact (SingE n x Hx). }
        rewrite HxEq.
        exact HninX. }
      claim Hclosed: closed_in X Tx {n}.
      { prove topology_on X Tx /\ ({n} c= X /\ exists U :e Tx, {n} = X :\: U).
        apply andI.
        - exact Htop.
        - apply andI.
          + exact HSingSub.
          + witness (X :\: {n}).
            apply andI.
            * (** X\\{n} is open in the finite complement topology **)
              claim HUpow: (X :\: {n}) :e Power X.
              { exact (setminus_In_Power X {n}). }
              claim HfinComp: finite (X :\: (X :\: {n})).
              { rewrite (setminus_setminus_eq X {n} HSingSub).
                exact (Sing_finite n). }
              exact (SepI (Power X) (fun U0:set => finite (X :\: U0) \/ U0 = Empty)
                          (X :\: {n})
                          HUpow
                          (orIL (finite (X :\: (X :\: {n}))) ((X :\: {n}) = Empty) HfinComp)).
            * (** {n} = X\\(X\\{n}) **)
              rewrite (setminus_setminus_eq X {n} HSingSub).
              reflexivity. }
      claim Heq_cl: closure_of X Tx {n} = {n}.
      { exact (closed_closure_eq X Tx {n} Htop Hclosed). }
      claim H0clSing: 0 :e closure_of X Tx {n}.
      { rewrite <- HAeq. exact H0clA. }
      claim H0inSing: 0 :e {n}.
      { rewrite <- Heq_cl. exact H0clSing. }
      claim H0eqn: 0 = n.
      { exact (SingE n 0 H0inSing). }
      claim Hn0: n = 0.
      { rewrite <- H0eqn. reflexivity. }
      claim Hnnot0: n /:e {0}.
      { exact (setminusE2 X {0} n HninX0). }
      claim Hnin0: n :e {0}.
      { rewrite Hn0. exact (SingI 0). }
      exact (Hnnot0 Hnin0). }
    (** contradict the assumed subset **)
    claim H0in_right: 0 :e Union ClFam.
    { exact (Hsub 0 H0in_closure). }
    exact (H0not_union_closures H0in_right).
Qed.

(** from 17 Exercise 8(a): closure of intersection is contained in intersection of closures **)
(** LATEX VERSION: Determine whether cl(A :/\\: B) = cl(A) :/\\: cl(B); always have inclusion c= . **)
Theorem ex17_8a_closure_intersection_Subq_intersection_closures : forall X Tx A B:set,
  topology_on X Tx ->
  closure_of X Tx (A :/\: B) c= closure_of X Tx A :/\: closure_of X Tx B.
let X Tx A B.
assume Htop: topology_on X Tx.
prove closure_of X Tx (A :/\: B) c= closure_of X Tx A :/\: closure_of X Tx B.
(** Strategy: x  cl(AB) implies every open neighborhood meets AB, hence meets A and meets B, so x  cl(A)  cl(B). **)
let x.
assume Hx: x :e closure_of X Tx (A :/\: B).
prove x :e closure_of X Tx A :/\: closure_of X Tx B.
claim HxX: x :e X.
{ exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: (A :/\: B) <> Empty) x Hx). }
claim HxAB: forall U:set, U :e Tx -> x :e U -> U :/\: (A :/\: B) <> Empty.
{ exact (SepE2 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: (A :/\: B) <> Empty) x Hx). }
apply binintersectI.
- prove x :e closure_of X Tx A.
  claim HxA: x :e X /\ (forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty).
  { apply andI.
    + exact HxX.
    + let U. assume HU: U :e Tx. assume HxU: x :e U.
      prove U :/\: A <> Empty.
      claim HABne: U :/\: (A :/\: B) <> Empty.
      { exact (HxAB U HU HxU). }
      assume Hempty: U :/\: A = Empty.
      apply HABne.
      apply Empty_Subq_eq.
      let y. assume Hy: y :e U :/\: (A :/\: B).
      claim HyU: y :e U.
      { exact (binintersectE1 U (A :/\: B) y Hy). }
      claim HyAB: y :e A :/\: B.
      { exact (binintersectE2 U (A :/\: B) y Hy). }
      claim HyA: y :e A.
      { exact (binintersectE1 A B y HyAB). }
      claim HyUA: y :e U :/\: A.
      { apply binintersectI.
        - exact HyU.
        - exact HyA. }
      rewrite <- Hempty. exact HyUA.
  }
  exact (SepI X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x HxX (andER (x :e X) (forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty) HxA)).
- prove x :e closure_of X Tx B.
  claim HxB: x :e X /\ (forall U:set, U :e Tx -> x :e U -> U :/\: B <> Empty).
  { apply andI.
    + exact HxX.
    + let U. assume HU: U :e Tx. assume HxU: x :e U.
      prove U :/\: B <> Empty.
      claim HABne: U :/\: (A :/\: B) <> Empty.
      { exact (HxAB U HU HxU). }
      assume Hempty: U :/\: B = Empty.
      apply HABne.
      apply Empty_Subq_eq.
      let y. assume Hy: y :e U :/\: (A :/\: B).
      claim HyU: y :e U.
      { exact (binintersectE1 U (A :/\: B) y Hy). }
      claim HyAB: y :e A :/\: B.
      { exact (binintersectE2 U (A :/\: B) y Hy). }
      claim HyB: y :e B.
      { exact (binintersectE2 A B y HyAB). }
      claim HyUB: y :e U :/\: B.
      { apply binintersectI.
        - exact HyU.
        - exact HyB. }
      rewrite <- Hempty. exact HyUB.
  }
  exact (SepI X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: B <> Empty) x HxX (andER (x :e X) (forall U:set, U :e Tx -> x :e U -> U :/\: B <> Empty) HxB)).
Qed.

(** from 17 Exercise 8(b): closure of an arbitrary intersection and intersection of closures **)
(** LATEX VERSION: Determine whether cl(Intersection A_alpha) = Intersection cl(A_alpha); always have inclusion c= . **)
Theorem ex17_8b_closure_intersection_family_Subq_intersection_closures : forall X Tx Fam:set,
  topology_on X Tx ->
  (forall A:set, A :e Fam -> A c= X) ->
  closure_of X Tx (intersection_of_family X Fam) c=
    intersection_of_family X {closure_of X Tx A|A :e Fam}.
let X Tx Fam.
assume Htop: topology_on X Tx.
assume HFsub: forall A:set, A :e Fam -> A c= X.
prove closure_of X Tx (intersection_of_family X Fam) c= intersection_of_family X {closure_of X Tx A|A :e Fam}.
set Aint := intersection_of_family X Fam.
set ClFam := {closure_of X Tx A|A :e Fam}.
claim HAintSubX: Aint c= X.
{ let x. assume Hx: x :e Aint.
  exact (SepE1 X (fun x0 => forall U:set, U :e Fam -> x0 :e U) x Hx). }
let x. assume Hx: x :e closure_of X Tx Aint.
prove x :e intersection_of_family X ClFam.
claim HxX: x :e X.
{ exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: Aint <> Empty) x Hx). }
claim Hdef: intersection_of_family X ClFam = {x0 :e X|forall U:set, U :e ClFam -> x0 :e U}.
{ reflexivity. }
rewrite Hdef.
apply SepI.
- exact HxX.
- let W. assume HW: W :e ClFam.
  prove x :e W.
  apply (ReplE Fam (fun A:set => closure_of X Tx A) W HW).
  let A. assume HAconj.
  claim HAFam: A :e Fam.
  { exact (andEL (A :e Fam) (W = closure_of X Tx A) HAconj). }
  claim HWeq: W = closure_of X Tx A.
  { exact (andER (A :e Fam) (W = closure_of X Tx A) HAconj). }
  claim HAintSubA: Aint c= A.
  { let y. assume Hy: y :e Aint.
    claim Hcond: forall U:set, U :e Fam -> y :e U.
    { exact (SepE2 X (fun x0 => forall U:set, U :e Fam -> x0 :e U) y Hy). }
    exact (Hcond A HAFam). }
  claim HxclA: x :e closure_of X Tx A.
  { exact (closure_monotone X Tx Aint A Htop HAintSubA (HFsub A HAFam) x Hx). }
  rewrite HWeq.
  exact HxclA.
Qed.

(** from 17 Exercise 8(c): closure of set difference **)
(** LATEX VERSION: Determine whether cl(A-B) = cl(A) - cl(B); at least cl(A-B) c= cl(A). **)
Theorem ex17_8c_closure_setminus_Subq_closure_left : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  closure_of X Tx (A :\: B) c= closure_of X Tx A.
let X Tx A B.
assume Htop: topology_on X Tx.
assume HA: A c= X.
assume HB: B c= X.
prove closure_of X Tx (A :\: B) c= closure_of X Tx A.
claim Hsub: A :\: B c= A.
{ let x. assume Hx: x :e A :\: B.
  exact (setminusE1 A B x Hx). }
exact (closure_monotone X Tx (A :\: B) A Htop Hsub HA).
Qed.

(** from 17 Exercise 8(c): counterexample to equality cl(A-B) = cl(A) - cl(B) **)
(** LATEX VERSION: Give an example where the equality fails. **)
Theorem ex17_8c_counterexample_equality_fails :
  exists X Tx A B:set,
    topology_on X Tx /\
    A c= X /\ B c= X /\
    closure_of X Tx (A :\: B) <> (closure_of X Tx A :\: closure_of X Tx B).
set X0 := {0} :\/: {1}.
set Tx0 := indiscrete_topology X0.
set A0 := X0.
set B0 := {0}.
witness X0.
witness Tx0.
witness A0.
witness B0.
prove topology_on X0 Tx0 /\ A0 c= X0 /\ B0 c= X0 /\ closure_of X0 Tx0 (A0 :\: B0) <> (closure_of X0 Tx0 A0 :\: closure_of X0 Tx0 B0).
apply andI.
- apply andI.
  - apply andI.
    + exact (indiscrete_topology_on X0).
    + exact (Subq_ref X0).
  - (** B0 c= X0 **)
    let x. assume Hx: x :e B0.
    prove x :e X0.
    claim Hxeq: x = 0.
    { exact (SingE 0 x Hx). }
    rewrite Hxeq.
    exact (binunionI1 {0} {1} 0 (SingI 0)).
- (** inequality **)
  assume Heq: closure_of X0 Tx0 (A0 :\: B0) = (closure_of X0 Tx0 A0 :\: closure_of X0 Tx0 B0).
  (** show 0 in left **)
  claim H0X0: 0 :e X0.
  { exact (binunionI1 {0} {1} 0 (SingI 0)). }
  claim H0in_left: 0 :e closure_of X0 Tx0 (A0 :\: B0).
  { apply (iffER (0 :e closure_of X0 Tx0 (A0 :\: B0))
                 (forall U :e Tx0, 0 :e U -> U :/\: (A0 :\: B0) <> Empty)
                 (closure_characterization X0 Tx0 (A0 :\: B0) 0 (indiscrete_topology_on X0) H0X0)).
    let U. assume HU: U :e Tx0.
    assume H0U: 0 :e U.
    prove U :/\: (A0 :\: B0) <> Empty.
    (** In the indiscrete topology, U is either Empty or X0; since 0 in U, we must have U = X0 **)
    claim HUcases: U = Empty \/ U = X0.
    { claim HU': U :e indiscrete_topology X0.
      { exact HU. }
      exact (iffEL (U :e indiscrete_topology X0) (U = Empty \/ U = X0) (indiscrete_open_iff X0 U) HU'). }
	    apply HUcases.
	    - assume HUe: U = Empty.
	      apply FalseE.
	      claim H0notU: 0 /:e U.
	      { rewrite HUe.
	        exact (EmptyE 0). }
	      exact (H0notU H0U).
	    - assume HUX: U = X0.
	      rewrite HUX.
      (** witness 1 in X0 \\ {0} **)
      claim H1X0: 1 :e X0.
      { exact (binunionI2 {0} {1} 1 (SingI 1)). }
      claim H1notB0: 1 /:e B0.
      { assume H1B0: 1 :e B0.
        claim H10: 1 = 0.
        { exact (SingE 0 1 H1B0). }
        exact (neq_1_0 H10). }
      claim H1in: 1 :e A0 :\: B0.
      { apply setminusI.
        - exact H1X0.
        - exact H1notB0. }
      claim H1in_inter: 1 :e X0 :/\: (A0 :\: B0).
      { exact (binintersectI X0 (A0 :\: B0) 1 H1X0 H1in). }
      exact (elem_implies_nonempty (X0 :/\: (A0 :\: B0)) 1 H1in_inter). }
  (** show 0 not in right **)
  claim H0in_clB: 0 :e closure_of X0 Tx0 B0.
  { claim HB0sub: B0 c= X0.
    { let x. assume Hx: x :e B0.
      prove x :e X0.
      claim Hxeq: x = 0.
      { exact (SingE 0 x Hx). }
      rewrite Hxeq.
      exact (binunionI1 {0} {1} 0 (SingI 0)). }
    exact (subset_of_closure X0 Tx0 B0 (indiscrete_topology_on X0) HB0sub 0 (SingI 0)). }
  claim H0not_right: 0 /:e (closure_of X0 Tx0 A0 :\: closure_of X0 Tx0 B0).
  { assume H0R: 0 :e (closure_of X0 Tx0 A0 :\: closure_of X0 Tx0 B0).
    claim H0not_clB: 0 /:e closure_of X0 Tx0 B0.
    { exact (setminusE2 (closure_of X0 Tx0 A0) (closure_of X0 Tx0 B0) 0 H0R). }
    exact (H0not_clB H0in_clB). }
  (** contradiction via equality **)
  apply H0not_right.
  rewrite <- Heq.
  exact H0in_left.
Qed.

(** LATEX VERSION: Exercise 9: Closure of AB in product is product of closures. **)
Theorem ex17_9_closure_of_product_subset : forall X Y Tx Ty A B:set,
  topology_on X Tx -> topology_on Y Ty ->
  closure_of (setprod X Y) (product_topology X Tx Y Ty) (setprod A B) =
    setprod (closure_of X Tx A) (closure_of Y Ty B).
let X Y Tx Ty A B.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove closure_of (setprod X Y) (product_topology X Tx Y Ty) (setprod A B) = setprod (closure_of X Tx A) (closure_of Y Ty B).
set Xprod := setprod X Y.
set Tprod := product_topology X Tx Y Ty.
set P := setprod A B.
set clA := closure_of X Tx A.
set clB := closure_of Y Ty B.
apply set_ext.
- let p. assume Hp: p :e closure_of Xprod Tprod P.
  prove p :e setprod clA clB.
  claim HpXprod: p :e Xprod.
  { exact (SepE1 Xprod (fun p0 => forall W:set, W :e Tprod -> p0 :e W -> W :/\: P <> Empty) p Hp). }
  claim Hpcl: forall W:set, W :e Tprod -> p :e W -> W :/\: P <> Empty.
  { exact (SepE2 Xprod (fun p0 => forall W:set, W :e Tprod -> p0 :e W -> W :/\: P <> Empty) p Hp). }
  apply (setprod_elem_decompose X Y p HpXprod).
  let x. assume Hxconj.
  claim HxX: x :e X.
  { exact (andEL (x :e X) (exists y :e Y, p :e setprod {x} {y}) Hxconj). }
  apply (andER (x :e X) (exists y :e Y, p :e setprod {x} {y}) Hxconj).
  let y. assume Hyconj.
  claim HyY: y :e Y.
  { exact (andEL (y :e Y) (p :e setprod {x} {y}) Hyconj). }
  claim HpXYsing: p :e setprod {x} {y}.
  { exact (andER (y :e Y) (p :e setprod {x} {y}) Hyconj). }
  (** show x :e clA **)
  claim HxclA: x :e clA.
  { prove x :e closure_of X Tx A.
    claim Hxcond: forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
    { let U. assume HU: U :e Tx. assume HxU: x :e U.
      (** apply closure condition in product to the open rectangle UY **)
      set WY := rectangle_set U Y.
      claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
      { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
      claim HYopen: Y :e Ty.
      { exact (topology_has_X Y Ty HTy). }
      claim HWYsub: WY :e product_subbasis X Tx Y Ty.
      { prove WY :e product_subbasis X Tx Y Ty.
        claim HWYV: rectangle_set U Y :e {rectangle_set U V|V :e Ty}.
        { exact (ReplI Ty (fun V1:set => rectangle_set U V1) Y HYopen). }
        exact (famunionI Tx (fun U1:set => {rectangle_set U1 V|V :e Ty}) U (rectangle_set U Y) HU HWYV). }
      claim HWYopen: WY :e Tprod.
      { exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty)
                HBasis WY HWYsub). }
      claim HpWY: p :e WY.
      { (** {x}{y}  UY, hence p  UY **)
        claim Hsx: {x} c= U.
        { exact (singleton_subset x U HxU). }
        claim Hsy: {y} c= Y.
        { exact (singleton_subset y Y HyY). }
        claim Hsub: setprod {x} {y} c= setprod U Y.
        { exact (setprod_Subq {x} {y} U Y Hsx Hsy). }
        exact (Hsub p HpXYsing). }
      claim Hnonemp: WY :/\: P <> Empty.
      { exact (Hpcl WY HWYopen HpWY). }
      apply (nonempty_has_element (WY :/\: P) Hnonemp).
      let q. assume HqInt.
      (** from q  (UY)  (AB), get a  UA **)
      claim HqWY: q :e WY.
      { exact (binintersectE1 WY P q HqInt). }
      claim HqP: q :e P.
      { exact (binintersectE2 WY P q HqInt). }
      apply (setprod_elem_decompose A B q HqP).
      let a. assume Haconj.
      claim HaA: a :e A.
      { exact (andEL (a :e A) (exists b :e B, q :e setprod {a} {b}) Haconj). }
      apply (andER (a :e A) (exists b :e B, q :e setprod {a} {b}) Haconj).
      let b. assume Hbconj.
      claim HbB: b :e B.
      { exact (andEL (b :e B) (q :e setprod {a} {b}) Hbconj). }
      claim Hqabsing: q :e setprod {a} {b}.
      { exact (andER (b :e B) (q :e setprod {a} {b}) Hbconj). }
      claim Hcoords: a :e U /\ b :e Y.
      { exact (setprod_coords_in a b U Y q Hqabsing HqWY). }
      claim HaU: a :e U.
      { exact (andEL (a :e U) (b :e Y) Hcoords). }
      claim HaUA: a :e U :/\: A.
      { exact (binintersectI U A a HaU HaA). }
      prove U :/\: A <> Empty.
      assume Hempty: U :/\: A = Empty.
      claim HaE: a :e Empty.
      { rewrite <- Hempty. exact HaUA. }
      exact (EmptyE a HaE). }
    exact (SepI X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x HxX Hxcond). }
  (** show y :e clB **)
  claim HyclB: y :e clB.
  { prove y :e closure_of Y Ty B.
    claim Hycond: forall V:set, V :e Ty -> y :e V -> V :/\: B <> Empty.
    { let V. assume HV: V :e Ty. assume HyV: y :e V.
      set WX := rectangle_set X V.
      claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
      { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
      claim HXopen: X :e Tx.
      { exact (topology_has_X X Tx HTx). }
      claim HWXsub: WX :e product_subbasis X Tx Y Ty.
      { prove WX :e product_subbasis X Tx Y Ty.
        claim HWXV: rectangle_set X V :e {rectangle_set X V0|V0 :e Ty}.
        { exact (ReplI Ty (fun V1:set => rectangle_set X V1) V HV). }
        exact (famunionI Tx (fun U1:set => {rectangle_set U1 V0|V0 :e Ty}) X (rectangle_set X V) HXopen HWXV). }
      claim HWXopen: WX :e Tprod.
      { exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty)
                HBasis WX HWXsub). }
      claim HpWX: p :e WX.
      { claim Hsx: {x} c= X.
        { exact (singleton_subset x X HxX). }
        claim Hsy: {y} c= V.
        { exact (singleton_subset y V HyV). }
        claim Hsub: setprod {x} {y} c= setprod X V.
        { exact (setprod_Subq {x} {y} X V Hsx Hsy). }
        exact (Hsub p HpXYsing). }
      claim Hnonemp: WX :/\: P <> Empty.
      { exact (Hpcl WX HWXopen HpWX). }
      apply (nonempty_has_element (WX :/\: P) Hnonemp).
      let q. assume HqInt.
      claim HqWX: q :e WX.
      { exact (binintersectE1 WX P q HqInt). }
      claim HqP: q :e P.
      { exact (binintersectE2 WX P q HqInt). }
      apply (setprod_elem_decompose A B q HqP).
      let a. assume Haconj.
      claim HaA: a :e A.
      { exact (andEL (a :e A) (exists b :e B, q :e setprod {a} {b}) Haconj). }
      apply (andER (a :e A) (exists b :e B, q :e setprod {a} {b}) Haconj).
      let b. assume Hbconj.
      claim HbB: b :e B.
      { exact (andEL (b :e B) (q :e setprod {a} {b}) Hbconj). }
      claim Hqabsing: q :e setprod {a} {b}.
      { exact (andER (b :e B) (q :e setprod {a} {b}) Hbconj). }
      claim Hcoords: a :e X /\ b :e V.
      { exact (setprod_coords_in a b X V q Hqabsing HqWX). }
      claim HbV: b :e V.
      { exact (andER (a :e X) (b :e V) Hcoords). }
      claim HbVB: b :e V :/\: B.
      { exact (binintersectI V B b HbV HbB). }
      prove V :/\: B <> Empty.
      assume Hempty: V :/\: B = Empty.
      claim HbE: b :e Empty.
      { rewrite <- Hempty. exact HbVB. }
      exact (EmptyE b HbE). }
    exact (SepI Y (fun y0 => forall V:set, V :e Ty -> y0 :e V -> V :/\: B <> Empty) y HyY Hycond). }
  (** conclude p  clAclB using {x}{y}  clAclB **)
  claim Hsx: {x} c= clA.
  { exact (singleton_subset x clA HxclA). }
  claim Hsy: {y} c= clB.
  { exact (singleton_subset y clB HyclB). }
  claim Hsub: setprod {x} {y} c= setprod clA clB.
  { exact (setprod_Subq {x} {y} clA clB Hsx Hsy). }
  exact (Hsub p HpXYsing).
- let p. assume Hp: p :e setprod clA clB.
  prove p :e closure_of Xprod Tprod P.
  claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
  { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
  claim HTprod: topology_on (setprod X Y) Tprod.
  { exact (product_topology_is_topology X Tx Y Ty HTx HTy). }
  (** decompose p into xclA, yclB and p{x}{y} **)
  apply (setprod_elem_decompose clA clB p Hp).
  let x. assume Hxconj.
  claim HxclA: x :e clA.
  { exact (andEL (x :e clA) (exists y :e clB, p :e setprod {x} {y}) Hxconj). }
  apply (andER (x :e clA) (exists y :e clB, p :e setprod {x} {y}) Hxconj).
  let y. assume Hyconj.
  claim HyclB: y :e clB.
  { exact (andEL (y :e clB) (p :e setprod {x} {y}) Hyconj). }
  claim HpXYsing: p :e setprod {x} {y}.
  { exact (andER (y :e clB) (p :e setprod {x} {y}) Hyconj). }
  (** show p  XY to satisfy closure_of's carrier condition **)
  claim HclAsubX: clA c= X.
  { exact (closure_in_space X Tx A HTx). }
  claim HclBsubY: clB c= Y.
  { exact (closure_in_space Y Ty B HTy). }
  claim HpXprod: p :e Xprod.
  { claim Hsub: setprod clA clB c= setprod X Y.
    { exact (setprod_Subq clA clB X Y HclAsubX HclBsubY). }
    exact (Hsub p Hp). }
  (** main closure condition for p **)
  claim Hpcond: forall W:set, W :e Tprod -> p :e W -> W :/\: P <> Empty.
  { let W. assume HW: W :e Tprod. assume HpW: p :e W.
    (** from openness of W, extract rectangle basis element b containing p, b  W **)
    claim HWgen: W :e generated_topology (setprod X Y) (product_subbasis X Tx Y Ty).
    { exact HW. }
    claim HWprop: forall p0 :e W, exists b :e product_subbasis X Tx Y Ty, p0 :e b /\ b c= W.
    { exact (SepE2 (Power (setprod X Y))
                   (fun U0:set => forall p0 :e U0, exists b :e product_subbasis X Tx Y Ty, p0 :e b /\ b c= U0)
                   W HWgen). }
    claim Hexb: exists b :e product_subbasis X Tx Y Ty, p :e b /\ b c= W.
    { exact (HWprop p HpW). }
    apply Hexb.
    let b. assume Hbconj.
    claim HbSub: b :e product_subbasis X Tx Y Ty.
    { exact (andEL (b :e product_subbasis X Tx Y Ty) (p :e b /\ b c= W) Hbconj). }
    claim Hpb: p :e b.
    { exact (andEL (p :e b) (b c= W) (andER (b :e product_subbasis X Tx Y Ty) (p :e b /\ b c= W) Hbconj)). }
    claim HbW: b c= W.
    { exact (andER (p :e b) (b c= W) (andER (b :e product_subbasis X Tx Y Ty) (p :e b /\ b c= W) Hbconj)). }
    (** decode b as rectangle_set U0 V0 **)
    apply (famunionE Tx (fun U1:set => {rectangle_set U1 V|V :e Ty}) b HbSub).
    let U0. assume HU0conj.
    claim HU0Tx: U0 :e Tx.
    { exact (andEL (U0 :e Tx) (b :e {rectangle_set U0 V|V :e Ty}) HU0conj). }
    claim HbInRepl: b :e {rectangle_set U0 V|V :e Ty}.
    { exact (andER (U0 :e Tx) (b :e {rectangle_set U0 V|V :e Ty}) HU0conj). }
    apply (ReplE Ty (fun V:set => rectangle_set U0 V) b HbInRepl).
    let V0. assume HV0conj.
    claim HV0Ty: V0 :e Ty.
    { exact (andEL (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }
    claim Hbeq: b = rectangle_set U0 V0.
    { exact (andER (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }
    claim HpbRect: p :e rectangle_set U0 V0.
    { rewrite <- Hbeq.
      exact Hpb. }
    (** from p  {x}{y} and p  U0V0, get xU0 and yV0 **)
    claim Hcoords: x :e U0 /\ y :e V0.
    { exact (setprod_coords_in x y U0 V0 p HpXYsing HpbRect). }
    claim HxU0: x :e U0.
    { exact (andEL (x :e U0) (y :e V0) Hcoords). }
    claim HyV0: y :e V0.
    { exact (andER (x :e U0) (y :e V0) Hcoords). }
    (** use x  clA to get U0A nonempty **)
    claim HxclAprop: forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
    { exact (SepE2 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x HxclA). }
    claim HU0Ane: U0 :/\: A <> Empty.
    { exact (HxclAprop U0 HU0Tx HxU0). }
    apply (nonempty_has_element (U0 :/\: A) HU0Ane).
    let a. assume HaUA.
    claim HaU0: a :e U0.
    { exact (binintersectE1 U0 A a HaUA). }
    claim HaA: a :e A.
    { exact (binintersectE2 U0 A a HaUA). }
    (** use y  clB to get V0B nonempty **)
    claim HyclBprop: forall V:set, V :e Ty -> y :e V -> V :/\: B <> Empty.
    { exact (SepE2 Y (fun y0 => forall V:set, V :e Ty -> y0 :e V -> V :/\: B <> Empty) y HyclB). }
    claim HV0Bne: V0 :/\: B <> Empty.
    { exact (HyclBprop V0 HV0Ty HyV0). }
    apply (nonempty_has_element (V0 :/\: B) HV0Bne).
    let b0. assume HbVB.
    claim HbV0: b0 :e V0.
    { exact (binintersectE1 V0 B b0 HbVB). }
    claim HbB: b0 :e B.
    { exact (binintersectE2 V0 B b0 HbVB). }
	    (** now (a,b0)  (U0V0)  W and (a,b0)  AB **)
	    set q := (a,b0).
	    claim HqRect: q :e rectangle_set U0 V0.
	    { exact (tuple_2_rectangle_set U0 V0 a b0 HaU0 HbV0). }
	    claim Hqb: q :e b.
	    { rewrite Hbeq.
	      exact HqRect. }
    claim HqW: q :e W.
    { exact (HbW q Hqb). }
    claim HqP: q :e P.
    { exact (tuple_2_setprod_by_pair_Sigma A B a b0 HaA HbB). }
    set I := W :/\: P.
    claim HqInt: q :e W :/\: P.
    { exact (binintersectI W P q HqW HqP). }
    exact (elem_implies_nonempty (W :/\: P) q HqInt). }
  exact (SepI Xprod (fun p0 => forall W:set, W :e Tprod -> p0 :e W -> W :/\: P <> Empty) p HpXprod Hpcond).
Qed.

(** LATEX VERSION: Exercise 10: Order topology is Hausdorff. **)
Theorem ex17_10_order_topology_Hausdorff : forall X:set,
  Hausdorff_space X (order_topology X).
let X.
prove Hausdorff_space X (order_topology X).
admit.
Qed.

(** LATEX VERSION: Exercise 11: Product of Hausdorff spaces is Hausdorff. **)
Theorem ex17_11_product_Hausdorff : forall X Tx Y Ty:set,
  Hausdorff_space X Tx -> Hausdorff_space Y Ty ->
  Hausdorff_space (setprod X Y) (product_topology X Tx Y Ty).
let X Tx Y Ty.
assume HX: Hausdorff_space X Tx.
assume HY: Hausdorff_space Y Ty.
prove Hausdorff_space (setprod X Y) (product_topology X Tx Y Ty).
apply (Hausdorff_stability X Tx Y Ty).
apply andI.
- exact HX.
- exact HY.
Qed.

(** LATEX VERSION: Exercise 12: Subspaces of Hausdorff spaces are Hausdorff. **)
Theorem ex17_12_subspace_Hausdorff : forall X Tx Y:set,
  Hausdorff_space X Tx -> Y c= X -> Hausdorff_space Y (subspace_topology X Tx Y).
let X Tx Y.
assume HX: Hausdorff_space X Tx.
assume HYsubX: Y c= X.
prove Hausdorff_space Y (subspace_topology X Tx Y).
claim HTx: topology_on X Tx.
{ exact (Hausdorff_space_topology X Tx HX). }
claim HTy: topology_on Y (subspace_topology X Tx Y).
{ exact (subspace_topology_is_topology X Tx Y HTx HYsubX). }
prove topology_on Y (subspace_topology X Tx Y) /\
      (forall y1 y2:set, y1 :e Y -> y2 :e Y -> y1 <> y2 ->
       exists U V:set, U :e subspace_topology X Tx Y /\ V :e subspace_topology X Tx Y /\
                       y1 :e U /\ y2 :e V /\ U :/\: V = Empty).
apply andI.
- exact HTy.
- let y1 y2. assume Hy1: y1 :e Y. assume Hy2: y2 :e Y. assume Hne: y1 <> y2.
  prove exists U V:set, U :e subspace_topology X Tx Y /\ V :e subspace_topology X Tx Y /\
                        y1 :e U /\ y2 :e V /\ U :/\: V = Empty.
  (** Strategy: y1,y2 distinct in Y are distinct in X; take disjoint Tx-neighborhoods U',V' and intersect with Y to get disjoint subspace neighborhoods. **)
claim Hsepax:
  forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
    exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
{ let x1 x2.
  assume Hx1: x1 :e X.
  assume Hx2: x2 :e X.
  assume Hneq: x1 <> x2.
  exact (Hausdorff_space_separation X Tx x1 x2 HX Hx1 Hx2 Hneq). }
  claim Hy1X: y1 :e X.
  { exact (HYsubX y1 Hy1). }
  claim Hy2X: y2 :e X.
  { exact (HYsubX y2 Hy2). }
  claim HexistsUV:
    exists U V:set, U :e Tx /\ V :e Tx /\ y1 :e U /\ y2 :e V /\ U :/\: V = Empty.
  { exact (Hsepax y1 y2 Hy1X Hy2X Hne). }
  set U0 := Eps_i (fun U:set => exists V:set, U :e Tx /\ V :e Tx /\ y1 :e U /\ y2 :e V /\ U :/\: V = Empty).
  claim HU0ex:
    exists V:set, U0 :e Tx /\ V :e Tx /\ y1 :e U0 /\ y2 :e V /\ U0 :/\: V = Empty.
  { exact (Eps_i_ex (fun U:set => exists V:set, U :e Tx /\ V :e Tx /\ y1 :e U /\ y2 :e V /\ U :/\: V = Empty)
                    HexistsUV). }
  set V0 := Eps_i (fun V:set => U0 :e Tx /\ V :e Tx /\ y1 :e U0 /\ y2 :e V /\ U0 :/\: V = Empty).
  claim HV0prop:
    U0 :e Tx /\ V0 :e Tx /\ y1 :e U0 /\ y2 :e V0 /\ U0 :/\: V0 = Empty.
  { exact (Eps_i_ex (fun V:set => U0 :e Tx /\ V :e Tx /\ y1 :e U0 /\ y2 :e V /\ U0 :/\: V = Empty)
                    HU0ex). }
  claim HU0Tx: U0 :e Tx.
  { exact (andEL (U0 :e Tx)
                 (V0 :e Tx)
                 (andEL (U0 :e Tx /\ V0 :e Tx)
                        (y1 :e U0)
                        (andEL ((U0 :e Tx /\ V0 :e Tx) /\ y1 :e U0)
                               (y2 :e V0)
                               (andEL (((U0 :e Tx /\ V0 :e Tx) /\ y1 :e U0) /\ y2 :e V0)
                                      (U0 :/\: V0 = Empty)
                                      HV0prop)))). }
  claim HV0Tx: V0 :e Tx.
  { exact (andER (U0 :e Tx)
                 (V0 :e Tx)
                 (andEL (U0 :e Tx /\ V0 :e Tx)
                        (y1 :e U0)
                        (andEL ((U0 :e Tx /\ V0 :e Tx) /\ y1 :e U0)
                               (y2 :e V0)
                               (andEL (((U0 :e Tx /\ V0 :e Tx) /\ y1 :e U0) /\ y2 :e V0)
                                      (U0 :/\: V0 = Empty)
                                      HV0prop)))). }
  claim Hy1U0: y1 :e U0.
  { exact (andER (U0 :e Tx /\ V0 :e Tx)
                 (y1 :e U0)
                 (andEL ((U0 :e Tx /\ V0 :e Tx) /\ y1 :e U0)
                        (y2 :e V0)
                        (andEL (((U0 :e Tx /\ V0 :e Tx) /\ y1 :e U0) /\ y2 :e V0)
                               (U0 :/\: V0 = Empty)
                               HV0prop))). }
  claim Hy2V0: y2 :e V0.
  { exact (andER ((U0 :e Tx /\ V0 :e Tx) /\ y1 :e U0)
                 (y2 :e V0)
                 (andEL (((U0 :e Tx /\ V0 :e Tx) /\ y1 :e U0) /\ y2 :e V0)
                        (U0 :/\: V0 = Empty)
                        HV0prop)). }
  claim Hdisj: U0 :/\: V0 = Empty.
  { exact (andER (((U0 :e Tx /\ V0 :e Tx) /\ y1 :e U0) /\ y2 :e V0)
                 (U0 :/\: V0 = Empty)
                 HV0prop). }
  set U := U0 :/\: Y.
  set V := V0 :/\: Y.
  claim HUinST: U :e subspace_topology X Tx Y.
  { claim HUPowY: U :e Power Y.
    { apply PowerI.
      let z. assume Hz: z :e U.
      exact (binintersectE2 U0 Y z Hz). }
    claim HUdef: exists V' :e Tx, U = V' :/\: Y.
    { witness U0.
      apply andI.
      - exact HU0Tx.
      - reflexivity. }
    exact (SepI (Power Y) (fun U1:set => exists V' :e Tx, U1 = V' :/\: Y) U HUPowY HUdef).
  }
  claim HVinST: V :e subspace_topology X Tx Y.
  { claim HVPowY: V :e Power Y.
    { apply PowerI.
      let z. assume Hz: z :e V.
      exact (binintersectE2 V0 Y z Hz). }
    claim HVdef: exists V' :e Tx, V = V' :/\: Y.
    { witness V0.
      apply andI.
      - exact HV0Tx.
      - reflexivity. }
    exact (SepI (Power Y) (fun U1:set => exists V' :e Tx, U1 = V' :/\: Y) V HVPowY HVdef).
  }
  claim Hy1U: y1 :e U.
  { exact (binintersectI U0 Y y1 Hy1U0 Hy1). }
  claim Hy2V: y2 :e V.
  { exact (binintersectI V0 Y y2 Hy2V0 Hy2). }
  claim HUVempty: U :/\: V = Empty.
  { apply Empty_Subq_eq.
    let z. assume Hz: z :e U :/\: V.
    prove z :e Empty.
    claim HzU: z :e U.
    { exact (binintersectE1 U V z Hz). }
    claim HzV: z :e V.
    { exact (binintersectE2 U V z Hz). }
    claim HzU0: z :e U0.
    { exact (binintersectE1 U0 Y z HzU). }
    claim HzV0: z :e V0.
    { exact (binintersectE1 V0 Y z HzV). }
    claim HzU0V0: z :e U0 :/\: V0.
    { exact (binintersectI U0 V0 z HzU0 HzV0). }
    rewrite <- Hdisj.
    exact HzU0V0.
  }
  witness U.
  witness V.
  apply andI.
  - apply andI.
    + apply andI.
      * apply andI.
        { exact HUinST. }
        { exact HVinST. }
      * exact Hy1U.
    + exact Hy2V.
  - exact HUVempty.
Qed.

(** LATEX VERSION: Exercise 13: Diagonal is closed in XX iff X is Hausdorff. **)
Theorem ex17_13_diagonal_closed_iff_Hausdorff : forall X Tx:set,
  topology_on X Tx ->
  (Hausdorff_space X Tx <->
    closed_in (setprod X X) (product_topology X Tx X Tx) {(x,x)|x :e X}).
let X Tx.
assume Htop: topology_on X Tx.
prove Hausdorff_space X Tx <-> closed_in (setprod X X) (product_topology X Tx X Tx) {(x,x)|x :e X}.
apply iffI.
- assume HH: Hausdorff_space X Tx.
  prove closed_in (setprod X X) (product_topology X Tx X Tx) {(x,x)|x :e X}.
  claim HTx: topology_on X Tx.
  { exact (andEL (topology_on X Tx)
                 (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
                 HH). }
  claim HSep: forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
    exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
  { exact (andER (topology_on X Tx)
                 (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
                 HH). }
  set D := {(t,t)|t :e X}.
  set U := setprod X X :\: D.
  claim HTprod: topology_on (setprod X X) (product_topology X Tx X Tx).
  { exact (product_topology_is_topology X Tx X Tx HTx HTx). }
  claim HDsub: D c= setprod X X.
  { let p. assume HpD: p :e D.
	    apply (ReplE X (fun t:set => (t,t)) p HpD).
	    let x. assume Hxpair.
	    claim HxX: x :e X.
	    { exact (andEL (x :e X) (p = (x,x)) Hxpair). }
	    claim Hpeq: p = (x,x).
	    { exact (andER (x :e X) (p = (x,x)) Hxpair). }
	    rewrite Hpeq.
	    exact (tuple_2_setprod_by_pair_Sigma X X x x HxX HxX). }
  claim HUinProd: U :e product_topology X Tx X Tx.
  { prove U :e product_topology X Tx X Tx.
    prove U :e generated_topology (setprod X X) (product_subbasis X Tx X Tx).
    claim HUPow: U :e Power (setprod X X).
    { apply PowerI (setprod X X) U.
      exact (setminus_Subq (setprod X X) D). }
    claim Hprop: forall p :e U, exists b :e product_subbasis X Tx X Tx, p :e b /\ b c= U.
    { let p. assume HpU: p :e U.
      claim HpXY: p :e setprod X X.
      { exact (setminusE1 (setprod X X) D p HpU). }
      claim HpnotD: p /:e D.
      { exact (setminusE2 (setprod X X) D p HpU). }
      apply (Sigma_E X (fun _ : set => X) p HpXY).
      let x. assume Hxpair.
      apply Hxpair.
      assume HxX Hexy.
      apply Hexy.
      let y. assume Hypair.
      apply Hypair.
      assume HyX Hpeq.
      claim Hxy: x <> y.
      { assume HxyEq: x = y.
        claim HpInD: p :e D.
	        { claim Hex: exists t :e X, p = (t,t).
	          { witness x.
	            apply andI.
	            - exact HxX.
	            - rewrite Hpeq.
	              rewrite <- HxyEq.
	              exact (tuple_pair x x). }
	          exact (iffER (p :e D) (exists t :e X, p = (t,t)) (ReplEq X (fun t:set => (t,t)) p) Hex). }
        exact (HpnotD HpInD). }
      claim HexUV: exists U0 V0:set, U0 :e Tx /\ V0 :e Tx /\ x :e U0 /\ y :e V0 /\ U0 :/\: V0 = Empty.
      { exact (HSep x y HxX HyX Hxy). }
      apply HexUV.
      let U0. assume HexV0.
      apply HexV0.
      let V0. assume HUV_conj.
      apply HUV_conj.
      assume Hleft HUVempty.
      apply Hleft.
      assume Hleft2 HyV0.
      apply Hleft2.
      assume Hleft3 HxU0.
      apply Hleft3.
      assume HU0 HV0.
      set b := rectangle_set U0 V0.
      witness b.
      apply andI.
      - (** b in product_subbasis **)
        prove b :e product_subbasis X Tx X Tx.
        claim HbV: rectangle_set U0 V0 :e {rectangle_set U0 V|V :e Tx}.
        { exact (ReplI Tx (fun V:set => rectangle_set U0 V) V0 HV0). }
        exact (famunionI Tx (fun U1:set => {rectangle_set U1 V|V :e Tx}) U0 (rectangle_set U0 V0) HU0 HbV).
      - apply andI.
        + (** p in b **)
          rewrite Hpeq.
          exact (pair_Sigma U0 (fun _ : set => V0) x HxU0 y HyV0).
        + (** b subset U **)
          prove b c= U.
          let q. assume Hqb: q :e b.
          prove q :e U.
          apply setminusI.
          * (** q in XX **)
            claim HU0subX: U0 c= X.
            { exact (topology_elem_subset X Tx U0 HTx HU0). }
            claim HV0subX: V0 c= X.
            { exact (topology_elem_subset X Tx V0 HTx HV0). }
            exact (setprod_Subq U0 V0 X X HU0subX HV0subX q Hqb).
          * (** q not in D **)
            assume HqD: q :e D.
            apply (ReplE X (fun t:set => (t,t)) q HqD).
            let z. assume Hzconj.
            claim HzX: z :e X.
            { exact (andEL (z :e X) (q = (z,z)) Hzconj). }
            claim Hqeq: q = (z,z).
            { exact (andER (z :e X) (q = (z,z)) Hzconj). }
            claim Hsing: q :e setprod {z} {z}.
            { rewrite Hqeq.
              exact (tuple_2_setprod_by_pair_Sigma {z} {z} z z (SingI z) (SingI z)). }
            claim HzUV: z :e U0 /\ z :e V0.
            { exact (setprod_coords_in z z U0 V0 q Hsing Hqb). }
            claim HzU0: z :e U0.
            { exact (andEL (z :e U0) (z :e V0) HzUV). }
            claim HzV0: z :e V0.
            { exact (andER (z :e U0) (z :e V0) HzUV). }
            claim HzInt: z :e U0 :/\: V0.
            { exact (binintersectI U0 V0 z HzU0 HzV0). }
            claim HzE: z :e Empty.
            { rewrite <- HUVempty. exact HzInt. }
            exact (EmptyE z HzE).
    }
    exact (SepI (Power (setprod X X)) (fun U0:set => forall p0 :e U0, exists b :e product_subbasis X Tx X Tx, p0 :e b /\ b c= U0) U HUPow Hprop). }
  prove topology_on (setprod X X) (product_topology X Tx X Tx) /\ (D c= setprod X X /\ exists W :e product_topology X Tx X Tx, D = setprod X X :\: W).
  apply andI.
  - exact HTprod.
  - apply andI.
    + exact HDsub.
    + witness U.
      apply andI.
      * exact HUinProd.
      * (** D = (XX) \\ U **)
        prove D = setprod X X :\: U.
        rewrite (setminus_setminus_eq (setprod X X) D HDsub).
        reflexivity.
- assume Hclosed: closed_in (setprod X X) (product_topology X Tx X Tx) {(x,x)|x :e X}.
  prove Hausdorff_space X Tx.
  set D := {(t,t)|t :e X}.
  claim HDsub: D c= setprod X X.
  { exact (andEL (D c= setprod X X) (exists U :e product_topology X Tx X Tx, D = setprod X X :\: U)
                 (andER (topology_on (setprod X X) (product_topology X Tx X Tx))
                        (D c= setprod X X /\ exists U :e product_topology X Tx X Tx, D = setprod X X :\: U)
                        Hclosed)). }
  claim HexU: exists U :e product_topology X Tx X Tx, D = setprod X X :\: U.
  { exact (andER (D c= setprod X X) (exists U :e product_topology X Tx X Tx, D = setprod X X :\: U)
                 (andER (topology_on (setprod X X) (product_topology X Tx X Tx))
                        (D c= setprod X X /\ exists U :e product_topology X Tx X Tx, D = setprod X X :\: U)
                        Hclosed)). }
  apply HexU.
  let U. assume HUconj.
  claim HUopen: U :e product_topology X Tx X Tx.
  { exact (andEL (U :e product_topology X Tx X Tx) (D = setprod X X :\: U) HUconj). }
  claim HDeq: D = setprod X X :\: U.
  { exact (andER (U :e product_topology X Tx X Tx) (D = setprod X X :\: U) HUconj). }
  claim HUsubXY: U c= setprod X X.
  { exact (generated_topology_subset (setprod X X) (product_subbasis X Tx X Tx) U HUopen). }
  claim HcompEq: setprod X X :\: D = U.
  { rewrite HDeq.
    exact (setminus_setminus_eq (setprod X X) U HUsubXY). }
  prove topology_on X Tx /\
        forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
          exists U0 V0:set, U0 :e Tx /\ V0 :e Tx /\ x1 :e U0 /\ x2 :e V0 /\ U0 :/\: V0 = Empty.
  apply andI.
  - exact Htop.
  - let x1 x2. assume Hx1X: x1 :e X. assume Hx2X: x2 :e X. assume Hx12: x1 <> x2.
    prove exists U0 V0:set, U0 :e Tx /\ V0 :e Tx /\ x1 :e U0 /\ x2 :e V0 /\ U0 :/\: V0 = Empty.
	    set p := (x1,x2).
    claim HpNotD: p /:e D.
    { assume HpD: p :e D.
	      apply (ReplE X (fun t:set => (t,t)) p HpD).
	      let z. assume Hzconj.
	      claim Hpeq: p = (z,z).
	      { exact (andER (z :e X) (p = (z,z)) Hzconj). }
      claim HpSing: p :e setprod {x1} {x2}.
      { exact (tuple_2_setprod_by_pair_Sigma {x1} {x2} x1 x2 (SingI x1) (SingI x2)). }
      claim HzzIn: (z,z) :e setprod {x1} {x2}.
      { rewrite <- Hpeq.
        exact HpSing. }
      claim HzzSing: (z,z) :e setprod {z} {z}.
      { exact (tuple_2_setprod_by_pair_Sigma {z} {z} z z (SingI z) (SingI z)). }
      claim HzIn: z :e {x1} /\ z :e {x2}.
      { exact (setprod_coords_in z z {x1} {x2} (z,z) HzzSing HzzIn). }
      claim Hzx1: z :e {x1}.
      { exact (andEL (z :e {x1}) (z :e {x2}) HzIn). }
      claim Hzx2: z :e {x2}.
      { exact (andER (z :e {x1}) (z :e {x2}) HzIn). }
      claim HzEqx1: z = x1.
      { exact (SingE x1 z Hzx1). }
      claim HzEqx2: z = x2.
      { exact (SingE x2 z Hzx2). }
      claim Hx12eq: x1 = x2.
      { rewrite <- HzEqx1.
        rewrite HzEqx2.
        reflexivity. }
      exact (Hx12 Hx12eq). }
	    claim HpInU: p :e U.
	    { rewrite <- HcompEq.
	      exact (setminusI (setprod X X) D p
	              (tuple_2_setprod_by_pair_Sigma X X x1 x2 Hx1X Hx2X)
	              HpNotD). }
	    claim HUprop: forall z :e U, exists b :e product_subbasis X Tx X Tx, z :e b /\ b c= U.
	    { exact (SepE2 (Power (setprod X X))
                   (fun U0:set => forall p0 :e U0, exists b :e product_subbasis X Tx X Tx, p0 :e b /\ b c= U0)
                   U HUopen). }
    claim Hexb: exists b :e product_subbasis X Tx X Tx, p :e b /\ b c= U.
    { exact (HUprop p HpInU). }
    apply Hexb.
    let b. assume Hbconj.
    claim HbSub: b :e product_subbasis X Tx X Tx.
    { exact (andEL (b :e product_subbasis X Tx X Tx) (p :e b /\ b c= U) Hbconj). }
    claim Hpb: p :e b.
    { exact (andEL (p :e b) (b c= U) (andER (b :e product_subbasis X Tx X Tx) (p :e b /\ b c= U) Hbconj)). }
    claim HbU: b c= U.
    { exact (andER (p :e b) (b c= U) (andER (b :e product_subbasis X Tx X Tx) (p :e b /\ b c= U) Hbconj)). }
    (** Decode b as a rectangle U0V0 **)
    apply (famunionE Tx (fun U1:set => {rectangle_set U1 V|V :e Tx}) b HbSub).
    let U0. assume HU0conj.
    claim HU0Tx: U0 :e Tx.
    { exact (andEL (U0 :e Tx) (b :e {rectangle_set U0 V|V :e Tx}) HU0conj). }
    claim HbInRepl: b :e {rectangle_set U0 V|V :e Tx}.
    { exact (andER (U0 :e Tx) (b :e {rectangle_set U0 V|V :e Tx}) HU0conj). }
    apply (ReplE Tx (fun V:set => rectangle_set U0 V) b HbInRepl).
    let V0. assume HV0conj.
    claim HV0Tx: V0 :e Tx.
    { exact (andEL (V0 :e Tx) (b = rectangle_set U0 V0) HV0conj). }
    claim Hbeq: b = rectangle_set U0 V0.
    { exact (andER (V0 :e Tx) (b = rectangle_set U0 V0) HV0conj). }
    claim HpbRect: p :e rectangle_set U0 V0.
    { rewrite <- Hbeq.
      exact Hpb. }
    claim HpSing: p :e setprod {x1} {x2}.
    { exact (tuple_2_setprod_by_pair_Sigma {x1} {x2} x1 x2 (SingI x1) (SingI x2)). }
    claim Hcoords: x1 :e U0 /\ x2 :e V0.
    { exact (setprod_coords_in x1 x2 U0 V0 p HpSing HpbRect). }
    claim Hx1U0: x1 :e U0.
    { exact (andEL (x1 :e U0) (x2 :e V0) Hcoords). }
    claim Hx2V0: x2 :e V0.
    { exact (andER (x1 :e U0) (x2 :e V0) Hcoords). }
    (** Show U0  V0 = , otherwise diagonal meets b  U = complement of D **)
    claim HUVempty: U0 :/\: V0 = Empty.
    { apply set_ext.
      - let z. assume Hz: z :e U0 :/\: V0.
        prove z :e Empty.
        apply FalseE.
        claim HzU0: z :e U0.
        { exact (binintersectE1 U0 V0 z Hz). }
        claim HzV0: z :e V0.
        { exact (binintersectE2 U0 V0 z Hz). }
        claim HzX: z :e X.
        { exact (topology_elem_subset X Tx U0 Htop HU0Tx z HzU0). }
	        set q := (z,z).
	        claim HqInb: q :e rectangle_set U0 V0.
	        { exact (tuple_2_rectangle_set U0 V0 z z HzU0 HzV0). }
        claim HqInb0: q :e b.
        { rewrite Hbeq.
          exact HqInb. }
        claim HqInU: q :e U.
        { exact (HbU q HqInb0). }
        claim HqInD: q :e D.
	        { exact (ReplI X (fun t:set => (t,t)) z HzX). }
        claim HqNotU: q /:e U.
        { claim HqXYU: q :e setprod X X :\: U.
          { rewrite <- HDeq.
            exact HqInD. }
          exact (setminusE2 (setprod X X) U q HqXYU). }
        exact (HqNotU HqInU).
      - exact (Subq_Empty (U0 :/\: V0)). }
    witness U0.
    witness V0.
    apply andI.
    - apply andI.
      + apply andI.
        * apply andI.
          { exact HU0Tx. }
          { exact HV0Tx. }
        * exact Hx1U0.
      + exact Hx2V0.
    - exact HUVempty.
Qed.

(** LATEX VERSION: In the finite complement topology on R, to what point or points does the sequence x_n = 1/n converge? **)
(** For this exercise we represent the sequence by n  1/(n+1), so it is a function on omega. **)
Definition seq_one_over_n : set := (fun n :e omega => {inv_nat (ordsucc n)}).

Theorem seq_one_over_n_apply : forall n:set, n :e omega ->
  apply_fun seq_one_over_n n = inv_nat (ordsucc n).
let n. assume Hn: n :e omega.
prove apply_fun seq_one_over_n n = inv_nat (ordsucc n).
set f := seq_one_over_n.
claim HinvIn: inv_nat (ordsucc n) :e {inv_nat (ordsucc n)}.
{ exact (SingI (inv_nat (ordsucc n))). }
claim HpairIn: (n, inv_nat (ordsucc n)) :e f.
{ exact (lamI2 omega (fun k : set => {inv_nat (ordsucc k)}) n Hn (inv_nat (ordsucc n)) HinvIn). }
claim Happair: (n, apply_fun f n) :e f.
{ exact (Eps_i_ax (fun y:set => (n,y) :e f) (inv_nat (ordsucc n)) HpairIn). }
apply (lamE omega (fun k : set => {inv_nat (ordsucc k)}) (n, apply_fun f n) Happair).
let x0. assume Hx0_conj.
apply Hx0_conj.
assume Hx0 Hexy0.
apply Hexy0.
let y0. assume Hy0_conj.
apply Hy0_conj.
assume Hy0 Heq.
claim HeqT: (n, apply_fun f n) = (x0, y0).
{ rewrite <- (tuple_pair x0 y0).
  exact Heq. }
claim H0eq: (n, apply_fun f n) 0 = (x0, y0) 0.
{ rewrite HeqT. reflexivity. }
claim H1eq: (n, apply_fun f n) 1 = (x0, y0) 1.
{ rewrite HeqT. reflexivity. }
claim Hnx0: n = x0.
{ prove n = x0.
  rewrite <- (tuple_2_0_eq n (apply_fun f n)).
  rewrite <- (tuple_2_0_eq x0 y0).
  exact H0eq. }
claim Happ: apply_fun f n = y0.
{ prove apply_fun f n = y0.
  rewrite <- (tuple_2_1_eq n (apply_fun f n)).
  rewrite <- (tuple_2_1_eq x0 y0).
  exact H1eq. }
claim Hy0eq: y0 = inv_nat (ordsucc x0).
{ exact (SingE (inv_nat (ordsucc x0)) y0 Hy0). }
claim Hx0n: x0 = n.
{ rewrite Hnx0. reflexivity. }
rewrite Happ.
rewrite Hy0eq.
rewrite Hx0n.
reflexivity.
Qed.

Theorem inv_nat_ordsucc_inj : forall n m:set,
  n :e omega -> m :e omega -> inv_nat (ordsucc n) = inv_nat (ordsucc m) -> n = m.
let n m.
assume Hn: n :e omega.
assume Hm: m :e omega.
assume Heq: inv_nat (ordsucc n) = inv_nat (ordsucc m).
prove n = m.
claim Hn_ord: ordinal n.
{ exact (ordinal_Hered omega omega_ordinal n Hn). }
claim Hm_ord: ordinal m.
{ exact (ordinal_Hered omega omega_ordinal m Hm). }
claim Hposn: 0 < ordsucc n.
{ exact (ordinal_ordsucc_pos n Hn_ord). }
claim Hposm: 0 < ordsucc m.
{ exact (ordinal_ordsucc_pos m Hm_ord). }
claim Hn1: ordsucc n :e omega.
{ exact (omega_ordsucc n Hn). }
claim Hm1: ordsucc m :e omega.
{ exact (omega_ordsucc m Hm). }
claim HSn: SNo (ordsucc n).
{ exact (omega_SNo (ordsucc n) Hn1). }
claim HSm: SNo (ordsucc m).
{ exact (omega_SNo (ordsucc m) Hm1). }
claim Hposcase_n: inv_nat (ordsucc n) = recip_SNo_pos (ordsucc n).
{ exact (recip_SNo_poscase (ordsucc n) Hposn). }
claim Hposcase_m: inv_nat (ordsucc m) = recip_SNo_pos (ordsucc m).
{ exact (recip_SNo_poscase (ordsucc m) Hposm). }
claim Hpos_eq: recip_SNo_pos (ordsucc n) = recip_SNo_pos (ordsucc m).
{ prove recip_SNo_pos (ordsucc n) = recip_SNo_pos (ordsucc m).
  rewrite <- Hposcase_n.
  rewrite <- Hposcase_m.
  exact Heq. }
claim Hinv_eq: recip_SNo_pos (recip_SNo_pos (ordsucc n)) = recip_SNo_pos (recip_SNo_pos (ordsucc m)).
{ prove recip_SNo_pos (recip_SNo_pos (ordsucc n)) = recip_SNo_pos (recip_SNo_pos (ordsucc m)).
  rewrite Hpos_eq.
  reflexivity. }
claim Hord: ordsucc n = ordsucc m.
{ prove ordsucc n = ordsucc m.
  rewrite <- (recip_SNo_pos_invol (ordsucc n) HSn Hposn).
  rewrite <- (recip_SNo_pos_invol (ordsucc m) HSm Hposm).
  exact Hinv_eq. }
exact (ordsucc_inj n m Hord).
Qed.

Theorem omega_binunion : forall a b:set, a :e omega -> b :e omega -> a :\/: b :e omega.
let a b.
assume Ha: a :e omega.
assume Hb: b :e omega.
prove a :\/: b :e omega.
apply (xm (a :e b)).
- assume Hab: a :e b.
  claim Hsub: a c= b.
  { claim Hb_nat: nat_p b.
    { exact (omega_nat_p b Hb). }
    claim Hb_ord: ordinal b.
    { exact (nat_p_ordinal b Hb_nat). }
    claim Hb_trans: TransSet b.
    { exact (andEL (TransSet b) (forall beta :e b, TransSet beta) Hb_ord). }
    exact (Hb_trans a Hab). }
  claim Heq: a :\/: b = b.
  { apply set_ext.
    - exact (binunion_Subq_min a b b Hsub (Subq_ref b)).
    - exact (binunion_Subq_2 a b). }
  rewrite Heq.
  exact Hb.
- assume Hanb: a /:e b.
  claim Ha_nat: nat_p a.
  { exact (omega_nat_p a Ha). }
  claim Hb_nat: nat_p b.
  { exact (omega_nat_p b Hb). }
  claim Ha_ord: ordinal a.
  { exact (nat_p_ordinal a Ha_nat). }
  claim Hb_ord: ordinal b.
  { exact (nat_p_ordinal b Hb_nat). }
  claim Hcases: a :e b \/ b c= a.
  { exact (ordinal_In_Or_Subq a b Ha_ord Hb_ord). }
  claim Hsub: b c= a.
  { apply (Hcases (b c= a)).
    - assume Hab: a :e b.
      apply FalseE.
      exact (Hanb Hab).
    - assume H. exact H. }
  claim Heq: a :\/: b = a.
  { apply set_ext.
    - exact (binunion_Subq_min a b a (Subq_ref a) Hsub).
    - exact (binunion_Subq_1 a b). }
  rewrite Heq.
  exact Ha.
Qed.

Theorem seq_one_over_n_inj : forall n m:set, n :e omega -> m :e omega ->
  apply_fun seq_one_over_n n = apply_fun seq_one_over_n m -> n = m.
let n m.
assume Hn: n :e omega.
assume Hm: m :e omega.
assume Heq: apply_fun seq_one_over_n n = apply_fun seq_one_over_n m.
prove n = m.
claim HnEq: apply_fun seq_one_over_n n = inv_nat (ordsucc n).
{ exact (seq_one_over_n_apply n Hn). }
claim HmEq: apply_fun seq_one_over_n m = inv_nat (ordsucc m).
{ exact (seq_one_over_n_apply m Hm). }
claim Heq': inv_nat (ordsucc n) = inv_nat (ordsucc m).
{ prove inv_nat (ordsucc n) = inv_nat (ordsucc m).
  rewrite <- HnEq.
  rewrite <- HmEq.
  exact Heq. }
exact (inv_nat_ordsucc_inj n m Hn Hm Heq').
Qed.

Theorem ex17_14_sequence_in_finite_complement_topology : forall x:set,
  x :e R ->
  forall U:set,
    U :e finite_complement_topology R ->
    x :e U ->
    exists N:set, N :e omega /\
      forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n :e U.
let x.
assume HxR: x :e R.
let U.
assume HU: U :e finite_complement_topology R.
assume HxU: x :e U.
prove exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n :e U.
(** let F = R\\U, which is finite since U is nonempty **)
claim HUpow: U :e Power R.
{ exact (SepE1 (Power R) (fun U0:set => finite (R :\: U0) \/ U0 = Empty) U HU). }
claim Hcases: finite (R :\: U) \/ U = Empty.
{ exact (SepE2 (Power R) (fun U0:set => finite (R :\: U0) \/ U0 = Empty) U HU). }
claim HUne: U <> Empty.
{ assume HUe: U = Empty.
  claim HxEmpty: x :e Empty.
  { rewrite <- HUe. exact HxU. }
  exact (EmptyE x HxEmpty). }
claim HF: finite (R :\: U).
{ apply Hcases.
  - assume Hfin. exact Hfin.
  - assume HUe.
    apply FalseE.
    exact (HUne HUe). }
set F := R :\: U.
claim HF_def: F = R :\: U.
{ reflexivity. }
claim HF_fin: finite F.
{ rewrite HF_def. exact HF. }
(** build a bound N so that for all n>=N, the sequence value is not in F **)
claim Hbound: exists N:set, N :e omega /\
  forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n /:e F.
{ apply (finite_ind (fun A:set => exists N:set, N :e omega /\
        forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n /:e A)).
  - (** base **)
    prove exists N:set, N :e omega /\
      forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n /:e Empty.
    witness 0.
    apply andI.
    + exact (nat_p_omega 0 nat_0).
    + let n. assume Hn. assume Hsub.
      exact (EmptyE (apply_fun seq_one_over_n n)).
  - (** step **)
    let A y.
    assume HAfin: finite A.
    assume HynA: y /:e A.
    assume HIA: exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n /:e A.
    prove exists N:set, N :e omega /\
      forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n /:e (A :\/: {y}).
    apply HIA.
    let N0. assume HN0.
    claim HN0o: N0 :e omega.
    { exact (andEL (N0 :e omega) (forall n:set, n :e omega -> N0 c= n -> apply_fun seq_one_over_n n /:e A) HN0). }
    claim HN0prop: forall n:set, n :e omega -> N0 c= n -> apply_fun seq_one_over_n n /:e A.
    { exact (andER (N0 :e omega) (forall n:set, n :e omega -> N0 c= n -> apply_fun seq_one_over_n n /:e A) HN0). }
    (** case split: y occurs as a sequence value or not **)
    apply (xm (exists k:set, k :e omega /\ apply_fun seq_one_over_n k = y)).
    - assume Hexk: exists k:set, k :e omega /\ apply_fun seq_one_over_n k = y.
      apply Hexk.
      let k. assume Hkpair.
      claim Hk: k :e omega.
      { exact (andEL (k :e omega) (apply_fun seq_one_over_n k = y) Hkpair). }
      claim Hkeq: apply_fun seq_one_over_n k = y.
      { exact (andER (k :e omega) (apply_fun seq_one_over_n k = y) Hkpair). }
      set N := ordsucc (N0 :\/: ordsucc k).
      witness N.
      apply andI.
      + (** N in omega **)
        claim Hk1: ordsucc k :e omega.
        { exact (omega_ordsucc k Hk). }
        claim Hmax: N0 :\/: ordsucc k :e omega.
        { exact (omega_binunion N0 (ordsucc k) HN0o Hk1). }
        exact (omega_ordsucc (N0 :\/: ordsucc k) Hmax).
      + let n. assume Hn: n :e omega. assume HNsub: N c= n.
        prove apply_fun seq_one_over_n n /:e (A :\/: {y}).
        (** first, n is beyond N0 so the value is not in A **)
        claim HN0sub: N0 c= n.
        { let t. assume Ht: t :e N0.
          claim HtN: t :e N.
          { claim Htmax: t :e (N0 :\/: ordsucc k).
            { exact (binunionI1 N0 (ordsucc k) t Ht). }
            exact (ordsuccI1 (N0 :\/: ordsucc k) t Htmax). }
          exact (HNsub t HtN). }
        claim HnotA: apply_fun seq_one_over_n n /:e A.
        { exact (HN0prop n Hn HN0sub). }
        (** also, n is beyond k, so the value is not y by injectivity **)
        claim HkInN: k :e N.
        { claim HkInSk: k :e ordsucc k.
          { exact (ordsuccI2 k). }
          claim HkInMax: k :e (N0 :\/: ordsucc k).
          { exact (binunionI2 N0 (ordsucc k) k HkInSk). }
          exact (ordsuccI1 (N0 :\/: ordsucc k) k HkInMax). }
        claim HkInNn: k :e n.
        { exact (HNsub k HkInN). }
	        claim Hneqnk: n <> k.
	        { assume Hnk: n = k.
	          claim Hkin: k :e k.
	          { rewrite <- Hnk at 2. exact HkInNn. }
	          exact (In_irref k Hkin). }
	        claim Hneqval: apply_fun seq_one_over_n n <> y.
	        { assume Hval: apply_fun seq_one_over_n n = y.
	          claim HnEqk: n = k.
	          { claim Hkeq': y = apply_fun seq_one_over_n k.
	            { prove y = apply_fun seq_one_over_n k.
	              symmetry.
	              exact Hkeq. }
	            claim Heqnk: apply_fun seq_one_over_n n = apply_fun seq_one_over_n k.
	            { exact (eq_i_tra (apply_fun seq_one_over_n n) y (apply_fun seq_one_over_n k) Hval Hkeq'). }
	            exact (seq_one_over_n_inj n k Hn Hk Heqnk). }
	          exact (Hneqnk HnEqk). }
        (** combine **)
        assume Hmem: apply_fun seq_one_over_n n :e (A :\/: {y}).
        apply (binunionE' A {y} (apply_fun seq_one_over_n n) False).
        - assume HinA. exact (HnotA HinA).
        - assume HinSing.
          claim Heqv: apply_fun seq_one_over_n n = y.
          { exact (SingE y (apply_fun seq_one_over_n n) HinSing). }
          exact (Hneqval Heqv).
        - exact Hmem.
    - assume Hno: ~(exists k:set, k :e omega /\ apply_fun seq_one_over_n k = y).
      (** N0 already works **)
      witness N0.
      apply andI.
      + exact HN0o.
      + let n. assume Hn: n :e omega. assume HN0sub: N0 c= n.
        prove apply_fun seq_one_over_n n /:e (A :\/: {y}).
        claim HnotA: apply_fun seq_one_over_n n /:e A.
        { exact (HN0prop n Hn HN0sub). }
        claim Hnoty: apply_fun seq_one_over_n n /:e {y}.
        { assume Hin.
          claim Heqv: apply_fun seq_one_over_n n = y.
          { exact (SingE y (apply_fun seq_one_over_n n) Hin). }
          apply Hno.
          witness n.
          apply andI.
          - exact Hn.
          - exact Heqv. }
        assume Hmem: apply_fun seq_one_over_n n :e (A :\/: {y}).
        apply (binunionE' A {y} (apply_fun seq_one_over_n n) False).
        - assume HinA. exact (HnotA HinA).
        - assume HinS. exact (Hnoty HinS).
        - exact Hmem.
  - (** apply to F **)
    exact HF_fin.
}
apply Hbound.
let N. assume HNpair.
claim HN: N :e omega.
{ exact (andEL (N :e omega) (forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n /:e F) HNpair). }
claim HNprop: forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n /:e F.
{ exact (andER (N :e omega) (forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n /:e F) HNpair). }
witness N.
apply andI.
- exact HN.
- let n. assume Hn: n :e omega. assume HNsub: N c= n.
  (** show the value lies in U by contradiction: otherwise it would be in F=R\\U **)
  claim HvalR: apply_fun seq_one_over_n n :e R.
  { rewrite (seq_one_over_n_apply n Hn).
    exact (inv_nat_real (ordsucc n) (omega_ordsucc n Hn)). }
  claim HnotF: apply_fun seq_one_over_n n /:e F.
  { exact (HNprop n Hn HNsub). }
  apply (xm (apply_fun seq_one_over_n n :e U)).
  * assume HvalU. exact HvalU.
  * assume HnotU: ~(apply_fun seq_one_over_n n :e U).
    claim HinF: apply_fun seq_one_over_n n :e F.
    { prove apply_fun seq_one_over_n n :e F.
      rewrite HF_def.
      apply setminusI.
      - exact HvalR.
      - exact HnotU. }
    exact (FalseE (HnotF HinF) (apply_fun seq_one_over_n n :e U)).
Qed.

(** helper: T1_space is equivalent to all singleton subsets being closed **)
Theorem lemma_T1_singletons_closed : forall X Tx:set,
  topology_on X Tx ->
  (T1_space X Tx <-> (forall x:set, x :e X -> closed_in X Tx {x})).
let X Tx.
assume Htop: topology_on X Tx.
prove T1_space X Tx <-> (forall x:set, x :e X -> closed_in X Tx {x}).
apply iffI.
- (** Forward: T1_space  singletons closed **)
  assume HT1: T1_space X Tx.
  prove forall x:set, x :e X -> closed_in X Tx {x}.
  let x.
  assume Hx: x :e X.
  prove closed_in X Tx {x}.
  (** T1_space says all finite subsets of X are closed; {x} is finite, hence closed. **)
  claim Hx_finite: finite {x}.
  { exact (Sing_finite x). }
  claim Hx_sub: {x} c= X.
  { let y. assume Hy: y :e {x}.
    claim Hyeq: y = x.
    { exact (SingE x y Hy). }
    rewrite Hyeq. exact Hx. }
  exact (T1_space_finite_closed X Tx {x} HT1 Hx_sub Hx_finite).
- (** Backward: singletons closed  T1_space **)
  assume Hsing: forall x:set, x :e X -> closed_in X Tx {x}.
  prove T1_space X Tx.
  prove topology_on X Tx /\ (forall F:set, F c= X -> finite F -> closed_in X Tx F).
  apply andI.
  + exact Htop.
  + prove forall F:set, F c= X -> finite F -> closed_in X Tx F.
    let F. assume HFsub: F c= X. assume HF: finite F.
	    prove closed_in X Tx F.
			    (** Strategy: prove finite unions of singletons are closed (use union_of_closed_is_closed and induction on finite sets). **)
		    claim Hclosed_empty: closed_in X Tx Empty.
		    { exact (empty_is_closed X Tx Htop). }
		    claim Hclosed_union: forall A B:set, closed_in X Tx A -> closed_in X Tx B -> closed_in X Tx (A :\/: B).
		    { let A B. assume HA. assume HB.
		      exact (union_of_closed_is_closed X Tx A B Htop HA HB). }
		    claim Hall: forall F0:set, finite F0 -> (F0 c= X -> closed_in X Tx F0).
		    { exact (finite_ind
		               (fun F0:set => F0 c= X -> closed_in X Tx F0)
		               (fun _ => Hclosed_empty)
	               (fun F0 y:set =>
	                  fun HFin0 HyNotin IH =>
                    fun HsubUnion =>
		                      Hclosed_union F0 {y}
		                        (IH (fun z Hz => HsubUnion z (binunionI1 F0 {y} z Hz)))
		                        (Hsing y (HsubUnion y (binunionI2 F0 {y} y (SingI y)))))
		               ). }
	    claim Hspec: F c= X -> closed_in X Tx F.
	    { exact (Hall F HF). }
	    exact (Hspec HFsub).
Qed.

(** helper: in a T1 space, the complement of a singleton is open **)
(** LATEX VERSION: In a T1 space, X\\{x} is open for every xX. **)
Theorem T1_singleton_complement_open : forall X Tx x:set,
  T1_space X Tx -> x :e X -> X :\: {x} :e Tx.
let X Tx x.
assume HT1: T1_space X Tx.
assume HxX: x :e X.
prove X :\: {x} :e Tx.
claim Htop: topology_on X Tx.
{ exact (T1_space_topology X Tx HT1). }
claim Hsing: closed_in X Tx {x}.
{ exact ((iffEL (T1_space X Tx)
                (forall z:set, z :e X -> closed_in X Tx {z})
                (lemma_T1_singletons_closed X Tx Htop) HT1) x HxX). }
claim Hdef: topology_on X Tx /\ ({x} c= X /\ exists U :e Tx, {x} = X :\: U).
{ exact Hsing. }
claim Hsubex: {x} c= X /\ exists U :e Tx, {x} = X :\: U.
{ exact (andER (topology_on X Tx) ({x} c= X /\ exists U :e Tx, {x} = X :\: U) Hdef). }
claim HexU: exists U :e Tx, {x} = X :\: U.
{ exact (andER ({x} c= X) (exists U :e Tx, {x} = X :\: U) Hsubex). }
apply HexU.
let U. assume HUeq.
claim HUinTx: U :e Tx.
{ exact (andEL (U :e Tx) ({x} = X :\: U) HUeq). }
claim Hxeq: {x} = X :\: U.
{ exact (andER (U :e Tx) ({x} = X :\: U) HUeq). }
claim HxnotU: x /:e U.
{ claim HxIn: x :e X :\: U.
  { rewrite <- Hxeq. exact (SingI x). }
  exact (setminusE2 X U x HxIn). }
claim HeqU: U = X :\: {x}.
{ apply set_ext.
  - let z. assume HzU: z :e U.
    prove z :e X :\: {x}.
    claim HzX: z :e X.
    { claim HTsub: Tx c= Power X.
      { exact (topology_subset_axiom X Tx Htop). }
      claim HUPow: U :e Power X.
      { exact (HTsub U HUinTx). }
      claim HUsub: U c= X.
      { exact (PowerE X U HUPow). }
      exact (HUsub z HzU). }
    apply setminusI.
    + exact HzX.
    + assume HzSing: z :e {x}.
      claim Hzeq: z = x.
      { exact (SingE x z HzSing). }
      claim HxU: x :e U.
      { prove x :e U.
        rewrite <- Hzeq.
        exact HzU. }
      exact (HxnotU HxU).
  - let z. assume Hz: z :e X :\: {x}.
    prove z :e U.
    apply (xm (z :e U)).
    + assume HzU: z :e U.
      exact HzU.
    + assume HznotU: z /:e U.
      claim HzIn: z :e X :\: U.
      { exact (setminusI X U z (setminusE1 X {x} z Hz) HznotU). }
      claim HzSing: z :e {x}.
      { rewrite Hxeq. exact HzIn. }
      claim Hfalse: False.
      { exact ((setminusE2 X {x} z Hz) HzSing). }
      apply FalseE.
      exact Hfalse.
	}
rewrite <- HeqU.
exact HUinTx.
Qed.

(** helper: subspaces of T1 spaces are T1 **)
(** LATEX VERSION: If X is T1, then every subspace YX is T1 in the subspace topology. **)
Theorem subspace_T1 : forall X Tx Y:set,
  topology_on X Tx -> Y c= X -> T1_space X Tx -> T1_space Y (subspace_topology X Tx Y).
let X Tx Y.
assume HTx: topology_on X Tx.
assume HY: Y c= X.
assume HT1: T1_space X Tx.
prove T1_space Y (subspace_topology X Tx Y).
claim HTy: topology_on Y (subspace_topology X Tx Y).
{ exact (subspace_topology_is_topology X Tx Y HTx HY). }
apply (iffER (T1_space Y (subspace_topology X Tx Y))
             (forall y:set, y :e Y -> closed_in Y (subspace_topology X Tx Y) {y})
             (lemma_T1_singletons_closed Y (subspace_topology X Tx Y) HTy)).
prove forall y:set, y :e Y -> closed_in Y (subspace_topology X Tx Y) {y}.
let y. assume HyY: y :e Y.
prove closed_in Y (subspace_topology X Tx Y) {y}.
apply (iffER (closed_in Y (subspace_topology X Tx Y) {y})
             (exists C:set, closed_in X Tx C /\ {y} = C :/\: Y)
             (closed_in_subspace_iff_intersection X Tx Y {y} HTx HY)).
witness {y}.
apply andI.
- (** singleton closed in X by T1 **)
  exact ((iffEL (T1_space X Tx)
                (forall z:set, z :e X -> closed_in X Tx {z})
                (lemma_T1_singletons_closed X Tx HTx) HT1) y (HY y HyY)).
- (** {y} = {y}  Y since yY **)
  apply set_ext.
  * let z. assume Hz: z :e {y}.
    prove z :e {y} :/\: Y.
    claim Hzeq: z = y.
    { exact (SingE y z Hz). }
    rewrite Hzeq.
    exact (binintersectI {y} Y y (SingI y) HyY).
  * let z. assume Hz: z :e {y} :/\: Y.
    prove z :e {y}.
    exact (binintersectE1 {y} Y z Hz).
Qed.

(** LATEX VERSION: Exercise 15: Show the T1 axiom is equivalent to the condition that for each pair of points of X, each has a neighborhood not containing the other. **)
Theorem ex17_15_T1_characterization : forall X Tx:set,
  topology_on X Tx ->
  (T1_space X Tx <->
    forall x y:set, x :e X -> y :e X -> x <> y ->
      (exists U:set, U :e Tx /\ x :e U /\ y /:e U) /\
      (exists V:set, V :e Tx /\ y :e V /\ x /:e V)).
let X Tx.
assume Htop: topology_on X Tx.
prove T1_space X Tx <->
    forall x y:set, x :e X -> y :e X -> x <> y ->
      (exists U:set, U :e Tx /\ x :e U /\ y /:e U) /\
      (exists V:set, V :e Tx /\ y :e V /\ x /:e V).
apply iffI.
- assume HT1: T1_space X Tx.
  prove forall x y:set, x :e X -> y :e X -> x <> y ->
      (exists U:set, U :e Tx /\ x :e U /\ y /:e U) /\
      (exists V:set, V :e Tx /\ y :e V /\ x /:e V).
	  claim Hsing_closed: forall z:set, z :e X -> closed_in X Tx {z}.
	  { exact (iffEL (T1_space X Tx) (forall z:set, z :e X -> closed_in X Tx {z})
	                 (lemma_T1_singletons_closed X Tx Htop) HT1). }
  let x y.
  assume HxX: x :e X.
  assume HyX: y :e X.
  assume Hne: x <> y.
  prove (exists U:set, U :e Tx /\ x :e U /\ y /:e U) /\ (exists V:set, V :e Tx /\ y :e V /\ x /:e V).
  apply andI.
  - (** neighborhood of x missing y from closedness of {y} **)
    claim Hcy: closed_in X Tx {y}.
    { exact (Hsing_closed y HyX). }
    claim Hcy2: {y} c= X /\ exists U :e Tx, {y} = X :\: U.
    { exact (andER (topology_on X Tx) ({y} c= X /\ exists U :e Tx, {y} = X :\: U) Hcy). }
    claim HexU: exists U:set, U :e Tx /\ {y} = X :\: U.
    { exact (andER ({y} c= X) (exists U :e Tx, {y} = X :\: U) Hcy2). }
    set U := Eps_i (fun U0:set => U0 :e Tx /\ {y} = X :\: U0).
    claim HUprop: U :e Tx /\ {y} = X :\: U.
    { exact (Eps_i_ex (fun U0:set => U0 :e Tx /\ {y} = X :\: U0) HexU). }
    claim HUopen: U :e Tx.
    { exact (andEL (U :e Tx) ({y} = X :\: U) HUprop). }
    claim Heq: {y} = X :\: U.
    { exact (andER (U :e Tx) ({y} = X :\: U) HUprop). }
    witness U.
    apply andI.
    - apply andI.
      + exact HUopen.
      + (** x is in U since xy and {y}=X\\U **)
        claim Hxnoty: x /:e {y}.
        { assume Hxy: x :e {y}.
          claim Hxyeq: x = y.
          { exact (SingE y x Hxy). }
          exact (Hne Hxyeq). }
        claim Hxnot: x /:e (X :\: U).
        { rewrite <- Heq. exact Hxnoty. }
        apply (xm (x :e U)).
        * assume HxU: x :e U. exact HxU.
        * assume HxnotU: ~(x :e U).
          claim HxXU: x :e X :\: U.
          { exact (setminusI X U x HxX HxnotU). }
          exact (FalseE (Hxnot HxXU) (x :e U)).
    - (** y not in U since y  X\\U = {y} **)
      assume HyU: y :e U.
      claim HySing: y :e {y}.
      { exact (SingI y). }
      claim HyXU: y :e X :\: U.
      { prove y :e X :\: U.
        rewrite <- Heq.
        exact HySing. }
      exact ((setminusE2 X U y HyXU) HyU).
  - (** neighborhood of y missing x from closedness of {x} **)
    claim Hcx: closed_in X Tx {x}.
    { exact (Hsing_closed x HxX). }
    claim Hcx2: {x} c= X /\ exists V :e Tx, {x} = X :\: V.
    { exact (andER (topology_on X Tx) ({x} c= X /\ exists V :e Tx, {x} = X :\: V) Hcx). }
    claim HexV: exists V:set, V :e Tx /\ {x} = X :\: V.
    { exact (andER ({x} c= X) (exists V :e Tx, {x} = X :\: V) Hcx2). }
    set V := Eps_i (fun V0:set => V0 :e Tx /\ {x} = X :\: V0).
    claim HVprop: V :e Tx /\ {x} = X :\: V.
    { exact (Eps_i_ex (fun V0:set => V0 :e Tx /\ {x} = X :\: V0) HexV). }
    claim HVopen: V :e Tx.
    { exact (andEL (V :e Tx) ({x} = X :\: V) HVprop). }
    claim Heq: {x} = X :\: V.
    { exact (andER (V :e Tx) ({x} = X :\: V) HVprop). }
    witness V.
    apply andI.
    - apply andI.
      + exact HVopen.
      + (** y in V since yx and {x}=X\\V **)
	        claim Hynotx: y /:e {x}.
	        { assume Hyx: y :e {x}.
	          claim Hyxeq: y = x.
	          { exact (SingE x y Hyx). }
	          claim Hxyeq: x = y.
	          { rewrite Hyxeq. reflexivity. }
	          exact (Hne Hxyeq). }
        claim Hynot: y /:e (X :\: V).
        { rewrite <- Heq. exact Hynotx. }
        apply (xm (y :e V)).
        * assume HyV: y :e V. exact HyV.
        * assume HynotV: ~(y :e V).
          claim HyXV: y :e X :\: V.
          { exact (setminusI X V y HyX HynotV). }
          exact (FalseE (Hynot HyXV) (y :e V)).
    - (** x not in V since x  X\\V = {x} **)
      assume HxV: x :e V.
      claim HxSing: x :e {x}.
      { exact (SingI x). }
      claim HxXV: x :e X :\: V.
      { prove x :e X :\: V.
        rewrite <- Heq.
        exact HxSing. }
      exact ((setminusE2 X V x HxXV) HxV).
- assume Hsep:
    forall x y:set, x :e X -> y :e X -> x <> y ->
      (exists U:set, U :e Tx /\ x :e U /\ y /:e U) /\
      (exists V:set, V :e Tx /\ y :e V /\ x /:e V).
  prove T1_space X Tx.
  (** it suffices to prove all singletons are closed **)
  apply (iffER (T1_space X Tx) (forall z:set, z :e X -> closed_in X Tx {z})
               (lemma_T1_singletons_closed X Tx Htop)).
  prove forall z:set, z :e X -> closed_in X Tx {z}.
  let x. assume HxX: x :e X.
  prove closed_in X Tx {x}.
  (** show X\\{x} is open as union of all open sets not containing x **)
  set UFam := {U :e Tx|x /:e U}.
  claim HUnionOpen: Union UFam :e Tx.
  { claim HUFamSub: UFam c= Tx.
    { let U. assume HU: U :e UFam.
      exact (SepE1 Tx (fun U0:set => x /:e U0) U HU). }
    exact (topology_union_closed X Tx UFam Htop HUFamSub). }
  claim HUnionEq: Union UFam = X :\: {x}.
	  { apply set_ext.
	    - let y. assume HyU: y :e Union UFam.
	      prove y :e X :\: {x}.
	      claim HyUex: exists W:set, y :e W /\ W :e UFam.
	      { exact (UnionE UFam y HyU). }
	      set U := Eps_i (fun U0:set => y :e U0 /\ U0 :e UFam).
	      claim HUprop: y :e U /\ U :e UFam.
	      { exact (Eps_i_ex (fun U0:set => y :e U0 /\ U0 :e UFam) HyUex). }
      claim HyU0: y :e U.
      { exact (andEL (y :e U) (U :e UFam) HUprop). }
      claim HUin: U :e UFam.
      { exact (andER (y :e U) (U :e UFam) HUprop). }
      claim HUinTx: U :e Tx.
      { exact (SepE1 Tx (fun U0:set => x /:e U0) U HUin). }
      claim HUSubX: U c= X.
      { exact (topology_elem_subset X Tx U Htop HUinTx). }
      claim HyX: y :e X.
      { exact (HUSubX y HyU0). }
      claim Hynotx: y /:e {x}.
      { assume Hyx: y :e {x}.
	        claim Hyxeq: y = x.
	        { exact (SingE x y Hyx). }
		        claim HxnotU: x /:e U.
		        { exact (SepE2 Tx (fun U0:set => x /:e U0) U HUin). }
			        claim HynotU: y /:e U.
			        { assume HyU1: y :e U.
			          claim Hxy: x = y.
			          { prove x = y.
			            symmetry.
			            exact Hyxeq. }
				          claim HxU1: x :e U.
				          { prove x :e U.
				            rewrite Hxy at 1.
				            exact HyU1. }
				          exact (HxnotU HxU1). }
		        exact (HynotU HyU0). }
	      exact (setminusI X {x} y HyX Hynotx).
    - let y. assume HyXx: y :e X :\: {x}.
      prove y :e Union UFam.
      claim HyX: y :e X.
      { exact (setminusE1 X {x} y HyXx). }
	      claim Hynot: y /:e {x}.
	      { exact (setminusE2 X {x} y HyXx). }
	      claim Hyne: y <> x.
	      { assume Heq.
	        claim Hyx: y :e {x}.
	        { prove y :e {x}.
	          rewrite Heq.
	          exact (SingI x). }
	        exact (Hynot Hyx). }
	      claim Hsep_yx: exists V:set, V :e Tx /\ y :e V /\ x /:e V.
	      { exact (andEL (exists V:set, V :e Tx /\ y :e V /\ x /:e V)
	                     (exists U:set, U :e Tx /\ x :e U /\ y /:e U)
	                     (Hsep y x HyX HxX Hyne)). }
      set V := Eps_i (fun V0:set => V0 :e Tx /\ y :e V0 /\ x /:e V0).
	      claim HVprop: V :e Tx /\ y :e V /\ x /:e V.
	      { exact (Eps_i_ex (fun V0:set => V0 :e Tx /\ y :e V0 /\ x /:e V0) Hsep_yx). }
	      claim HVleft: V :e Tx /\ y :e V.
	      { exact (andEL (V :e Tx /\ y :e V) (x /:e V) HVprop). }
	      claim HVinTx: V :e Tx.
	      { exact (andEL (V :e Tx) (y :e V) HVleft). }
	      claim HyV: y :e V.
	      { exact (andER (V :e Tx) (y :e V) HVleft). }
	      claim HxnotV: x /:e V.
	      { exact (andER (V :e Tx /\ y :e V) (x /:e V) HVprop). }
      claim HVinFam: V :e UFam.
      { exact (SepI Tx (fun U0:set => x /:e U0) V HVinTx HxnotV). }
      exact (UnionI UFam y V HyV HVinFam).
  }
  (** {x} is closed as complement of the open set X\\{x} **)
  prove topology_on X Tx /\ ({x} c= X /\ exists U :e Tx, {x} = X :\: U).
  apply andI.
  - exact Htop.
  - apply andI.
    + let z. assume Hz: z :e {x}.
      claim Hzeq: z = x.
      { exact (SingE x z Hz). }
      rewrite Hzeq.
      exact HxX.
	    + witness (Union UFam).
		      apply andI.
		      * exact HUnionOpen.
      * apply set_ext.
        { let z. assume Hz: z :e {x}.
          prove z :e X :\: Union UFam.
          claim Hzeq: z = x.
          { exact (SingE x z Hz). }
          rewrite Hzeq.
          apply setminusI.
          - exact HxX.
          - assume Hxin: x :e Union UFam.
            claim Hxin': x :e X :\: {x}.
            { prove x :e X :\: {x}.
              rewrite <- HUnionEq.
              exact Hxin. }
            exact ((setminusE2 X {x} x Hxin') (SingI x)).
        }
        { let z. assume Hz: z :e X :\: Union UFam.
          prove z :e {x}.
          (** use setminus_setminus_eq with U = Union UFam = X\\{x} **)
          claim HsingSub: {x} c= X.
          { let t. assume Ht: t :e {x}.
            claim Hteq: t = x.
            { exact (SingE x t Ht). }
            rewrite Hteq.
            exact HxX. }
          rewrite <- (setminus_setminus_eq X {x} HsingSub).
          rewrite <- HUnionEq.
          exact Hz.
        }
Qed.

(** LATEX VERSION: Exercise 16(a): Determine the closure of K={1/n : n in Zplus} under each of the five R topologies from 13 Exercise 7. **)
Definition R_nonneg_set : set := {x :e R|0 <= x}.

Theorem ex17_16a_closure_of_K_in_five_topologies :
  closure_of R R_standard_topology K_set = K_set :\/: {0} /\
  closure_of R R_K_topology K_set = K_set /\
  closure_of R R_finite_complement_topology K_set = R /\
  closure_of R R_upper_limit_topology K_set = K_set /\
  closure_of R R_ray_topology K_set = R_nonneg_set.
prove closure_of R R_standard_topology K_set = K_set :\/: {0} /\
  closure_of R R_K_topology K_set = K_set /\
  closure_of R R_finite_complement_topology K_set = R /\
  closure_of R R_upper_limit_topology K_set = K_set /\
  closure_of R R_ray_topology K_set = R_nonneg_set.
admit.
Qed.

(** helper: in the left ray topology, any open set containing 1 contains 0 **)
Theorem ray_topology_contains_0_if_contains_1 : forall U:set,
  U :e R_ray_topology -> 1 :e U -> 0 :e U.
let U.
assume HU: U :e R_ray_topology.
assume H1U: 1 :e U.
prove 0 :e U.
claim HUcases: U = Empty \/ U = R \/ exists a :e R, U = {x :e R|Rlt x a}.
{ exact (SepE2 (Power R) (fun U0 : set => U0 = Empty \/ U0 = R \/ exists a0 :e R, U0 = {x :e R|Rlt x a0}) U HU). }
apply (HUcases (0 :e U)).
- assume HUR: U = Empty \/ U = R.
  apply (HUR (0 :e U)).
  + assume HUe: U = Empty.
    apply FalseE.
    claim H1Empty: 1 :e Empty.
    prove 1 :e Empty.
    rewrite <- HUe at 2.
    exact H1U.
    exact ((EmptyE 1) H1Empty).
  + assume HUeqR: U = R.
    rewrite HUeqR.
    exact real_0.
- assume Hex: exists a :e R, U = {x :e R|Rlt x a}.
  apply Hex.
  let a.
  assume Hapair: a :e R /\ U = {x :e R|Rlt x a}.
  claim HaR: a :e R.
  { exact (andEL (a :e R) (U = {x :e R|Rlt x a}) Hapair). }
  claim HUeq: U = {x :e R|Rlt x a}.
  { exact (andER (a :e R) (U = {x :e R|Rlt x a}) Hapair). }
  rewrite HUeq.
  prove 0 :e {x :e R|Rlt x a}.
  claim H1in: 1 :e {x :e R|Rlt x a}.
  { rewrite <- HUeq.
    exact H1U. }
  claim H1lt: Rlt 1 a.
  { exact (SepE2 R (fun x0:set => Rlt x0 a) 1 H1in). }
  claim H0lt1: Rlt 0 1.
  { exact (RltI 0 1 real_0 real_1 SNoLt_0_1). }
  claim H0lta: Rlt 0 a.
  { exact (Rlt_tra 0 1 a H0lt1 H1lt). }
  exact (SepI R (fun x0:set => Rlt x0 a) 0 real_0 H0lta).
Qed.

(** helper: the left ray topology on R is not Hausdorff **)
Theorem ray_topology_not_Hausdorff : ~Hausdorff_space R R_ray_topology.
assume HH: Hausdorff_space R R_ray_topology.
prove False.
claim Hsep: forall x1 x2:set, x1 :e R -> x2 :e R -> x1 <> x2 ->
  exists U V:set, U :e R_ray_topology /\ V :e R_ray_topology /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
{ exact (andER (topology_on R R_ray_topology)
               (forall x1 x2:set, x1 :e R -> x2 :e R -> x1 <> x2 ->
                 exists U V:set, U :e R_ray_topology /\ V :e R_ray_topology /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }
claim H01ne: 0 <> 1.
{ assume H01eq: 0 = 1.
  claim H00lt: 0 < 0.
  { rewrite H01eq at 2.
    exact SNoLt_0_1. }
  exact ((SNoLt_irref 0) H00lt). }
claim HUVex: exists U V:set, U :e R_ray_topology /\ V :e R_ray_topology /\ 0 :e U /\ 1 :e V /\ U :/\: V = Empty.
{ exact (Hsep 0 1 real_0 real_1 H01ne). }
apply HUVex.
let U.
assume HVex: exists V:set, U :e R_ray_topology /\ V :e R_ray_topology /\ 0 :e U /\ 1 :e V /\ U :/\: V = Empty.
apply HVex.
let V.
assume HUV.
claim HUVleft: (((U :e R_ray_topology /\ V :e R_ray_topology) /\ 0 :e U) /\ 1 :e V).
{ exact (andEL (((U :e R_ray_topology /\ V :e R_ray_topology) /\ 0 :e U) /\ 1 :e V)
               (U :/\: V = Empty)
               HUV). }
claim HUVempty: U :/\: V = Empty.
{ exact (andER (((U :e R_ray_topology /\ V :e R_ray_topology) /\ 0 :e U) /\ 1 :e V)
               (U :/\: V = Empty)
               HUV). }
claim HUVleft2: ((U :e R_ray_topology /\ V :e R_ray_topology) /\ 0 :e U).
{ exact (andEL ((U :e R_ray_topology /\ V :e R_ray_topology) /\ 0 :e U)
               (1 :e V)
               HUVleft). }
claim H1V: 1 :e V.
{ exact (andER ((U :e R_ray_topology /\ V :e R_ray_topology) /\ 0 :e U)
               (1 :e V)
               HUVleft). }
claim HUVleft3: (U :e R_ray_topology /\ V :e R_ray_topology).
{ exact (andEL (U :e R_ray_topology /\ V :e R_ray_topology)
               (0 :e U)
               HUVleft2). }
claim H0U: 0 :e U.
{ exact (andER (U :e R_ray_topology /\ V :e R_ray_topology)
               (0 :e U)
               HUVleft2). }
claim HU: U :e R_ray_topology.
{ exact (andEL (U :e R_ray_topology)
               (V :e R_ray_topology)
               HUVleft3). }
claim HV: V :e R_ray_topology.
{ exact (andER (U :e R_ray_topology)
               (V :e R_ray_topology)
               HUVleft3). }
claim H0V: 0 :e V.
{ exact (ray_topology_contains_0_if_contains_1 V HV H1V). }
claim H0UV: 0 :e U :/\: V.
{ exact (binintersectI U V 0 H0U H0V). }
claim H0Empty: 0 :e Empty.
prove 0 :e Empty.
rewrite <- HUVempty at 2.
exact H0UV.
exact (EmptyE 0 H0Empty).
Qed.

(** helper: the left ray topology on R is not T1 **)
Theorem ray_topology_not_T1 : ~T1_space R R_ray_topology.
assume HT1: T1_space R R_ray_topology.
prove False.
claim Hfinite_closed: forall F:set, F c= R -> finite F -> closed_in R R_ray_topology F.
{ exact (andER (topology_on R R_ray_topology)
               (forall F:set, F c= R -> finite F -> closed_in R R_ray_topology F)
               HT1). }
claim Hsub0: {0} c= R.
{ let x. assume Hx0: x :e {0}.
  claim Hxeq: x = 0.
  { exact (SingE 0 x Hx0). }
  rewrite Hxeq.
  exact real_0. }
claim Hfin0: finite {0}.
{ exact (Sing_finite 0). }
claim Hclosed0: closed_in R R_ray_topology {0}.
{ exact (Hfinite_closed {0} Hsub0 Hfin0). }
claim Hclosed0core: {0} c= R /\ exists U :e R_ray_topology, {0} = R :\: U.
{ exact (andER (topology_on R R_ray_topology)
               ({0} c= R /\ exists U :e R_ray_topology, {0} = R :\: U)
               Hclosed0). }
claim HexUtyped: exists U :e R_ray_topology, {0} = R :\: U.
{ exact (andER ({0} c= R) (exists U :e R_ray_topology, {0} = R :\: U) Hclosed0core). }
apply HexUtyped.
let U.
assume HUrep: U :e R_ray_topology /\ {0} = R :\: U.
claim HU: U :e R_ray_topology.
{ exact (andEL (U :e R_ray_topology) ({0} = R :\: U) HUrep). }
claim Heq: {0} = R :\: U.
{ exact (andER (U :e R_ray_topology) ({0} = R :\: U) HUrep). }
claim H1in: 1 :e U.
{ claim H1not0: 1 /:e {0}.
  { assume H10: 1 :e {0}.
    claim H10eq: 1 = 0.
    { exact (SingE 0 1 H10). }
    claim H00lt: 0 < 0.
    { rewrite <- H10eq at 2.
      exact SNoLt_0_1. }
    exact ((SNoLt_irref 0) H00lt). }
  prove 1 :e U.
  apply (xm (1 :e U)).
  - assume H. exact H.
  - assume HnU: ~(1 :e U).
    claim H1incomp: 1 :e R :\: U.
    { exact (setminusI R U 1 real_1 HnU). }
    claim H1in0: 1 :e {0}.
    { claim Hsubst: forall S T:set, S = T -> 1 :e T -> 1 :e S.
      { let S T.
        assume HeqST: S = T.
        assume H1inT: 1 :e T.
        prove 1 :e S.
        rewrite HeqST.
        exact H1inT. }
      exact (Hsubst {0} (R :\: U) Heq H1incomp). }
    apply FalseE.
    exact (H1not0 H1in0). }
claim H0in: 0 :e U.
{ exact (ray_topology_contains_0_if_contains_1 U HU H1in). }
claim H0incomp: 0 :e R :\: U.
{ rewrite <- Heq.
  exact (SingI 0). }
claim H0not: 0 /:e U.
{ exact (setminusE2 R U 0 H0incomp). }
exact (H0not H0in).
Qed.

(** helper: X minus Empty equals X **)
Theorem setminus_Empty_eq : forall X:set, X :\: Empty = X.
let X.
apply set_ext.
- let x. assume Hx: x :e X :\: Empty.
  exact (setminusE1 X Empty x Hx).
- let x. assume HxX: x :e X.
  exact (setminusI X Empty x HxX (EmptyE x)).
Qed.

(** helper: R is infinite **)
Theorem infinite_R : infinite R.
(** from pre-topology: real is uncountable, so in particular infinite **)
(** LATEX VERSION: Not a numbered item; uses the earlier uncountability result for R to conclude R is infinite. **)
claim Hunc: atleastp omega real /\ ~equip real omega.
{ exact form100_22_real_uncountable. }
claim Hatleast: atleastp omega real.
{ exact (andEL (atleastp omega real) (~equip real omega) Hunc). }
prove infinite R.
exact (atleastp_omega_infinite real Hatleast).
Qed.

(** helper: finite complement topology is T1 **)
Theorem finite_complement_topology_T1 : forall X:set, T1_space X (finite_complement_topology X).
let X.
claim Htop: topology_on X (finite_complement_topology X).
{ exact (finite_complement_topology_on X). }
prove topology_on X (finite_complement_topology X) /\ (forall F:set, F c= X -> finite F -> closed_in X (finite_complement_topology X) F).
apply andI.
- exact Htop.
- let F. assume HFsub: F c= X. assume HFfin: finite F.
  prove closed_in X (finite_complement_topology X) F.
  prove topology_on X (finite_complement_topology X) /\ (F c= X /\ exists U :e finite_complement_topology X, F = X :\: U).
  apply andI.
  + exact Htop.
  + apply andI.
    * exact HFsub.
    * witness (X :\: F).
      apply andI.
      - (** X\\F is open in the finite complement topology **)
        claim HUpow: (X :\: F) :e Power X.
        { exact (setminus_In_Power X F). }
        claim Hfin: finite (X :\: (X :\: F)).
        { rewrite (setminus_setminus_eq X F HFsub).
          exact HFfin. }
        exact (SepI (Power X) (fun U0:set => finite (X :\: U0) \/ U0 = Empty)
                    (X :\: F)
                    HUpow
                    (orIL (finite (X :\: (X :\: F))) ((X :\: F) = Empty) Hfin)).
      - (** F = X\\(X\\F) **)
        rewrite (setminus_setminus_eq X F HFsub).
        reflexivity.
Qed.

(** helper: the finite complement topology on R is not Hausdorff **)
Theorem R_finite_complement_not_Hausdorff : ~Hausdorff_space R R_finite_complement_topology.
assume HH: Hausdorff_space R R_finite_complement_topology.
prove False.
claim Hsep: forall x1 x2:set, x1 :e R -> x2 :e R -> x1 <> x2 ->
  exists U V:set, U :e R_finite_complement_topology /\ V :e R_finite_complement_topology /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
{ exact (andER (topology_on R R_finite_complement_topology)
               (forall x1 x2:set, x1 :e R -> x2 :e R -> x1 <> x2 ->
                 exists U V:set, U :e R_finite_complement_topology /\ V :e R_finite_complement_topology /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }
claim H01ne: 0 <> 1.
{ assume H01eq: 0 = 1.
  claim H00lt: 0 < 0.
  { rewrite H01eq at 2.
    exact SNoLt_0_1. }
  exact ((SNoLt_irref 0) H00lt). }
claim HUVex: exists U V:set, U :e R_finite_complement_topology /\ V :e R_finite_complement_topology /\ 0 :e U /\ 1 :e V /\ U :/\: V = Empty.
{ exact (Hsep 0 1 real_0 real_1 H01ne). }
apply HUVex.
let U.
assume HVex: exists V:set, U :e R_finite_complement_topology /\ V :e R_finite_complement_topology /\ 0 :e U /\ 1 :e V /\ U :/\: V = Empty.
apply HVex.
let V.
assume HUV: U :e R_finite_complement_topology /\ V :e R_finite_complement_topology /\ 0 :e U /\ 1 :e V /\ U :/\: V = Empty.
claim Hleft: (((U :e R_finite_complement_topology /\ V :e R_finite_complement_topology) /\ 0 :e U) /\ 1 :e V).
{ exact (andEL (((U :e R_finite_complement_topology /\ V :e R_finite_complement_topology) /\ 0 :e U) /\ 1 :e V)
               (U :/\: V = Empty)
               HUV). }
claim HUVempty: U :/\: V = Empty.
{ exact (andER (((U :e R_finite_complement_topology /\ V :e R_finite_complement_topology) /\ 0 :e U) /\ 1 :e V)
               (U :/\: V = Empty)
               HUV). }
claim Hleft2: ((U :e R_finite_complement_topology /\ V :e R_finite_complement_topology) /\ 0 :e U).
{ exact (andEL ((U :e R_finite_complement_topology /\ V :e R_finite_complement_topology) /\ 0 :e U) (1 :e V) Hleft). }
claim H1V: 1 :e V.
{ exact (andER ((U :e R_finite_complement_topology /\ V :e R_finite_complement_topology) /\ 0 :e U) (1 :e V) Hleft). }
claim Hpair: (U :e R_finite_complement_topology /\ V :e R_finite_complement_topology).
{ exact (andEL (U :e R_finite_complement_topology /\ V :e R_finite_complement_topology) (0 :e U) Hleft2). }
claim H0U: 0 :e U.
{ exact (andER (U :e R_finite_complement_topology /\ V :e R_finite_complement_topology) (0 :e U) Hleft2). }
claim HU: U :e R_finite_complement_topology.
{ exact (andEL (U :e R_finite_complement_topology) (V :e R_finite_complement_topology) Hpair). }
claim HV: V :e R_finite_complement_topology.
{ exact (andER (U :e R_finite_complement_topology) (V :e R_finite_complement_topology) Hpair). }

(** from HU and H0U, derive finite (R\\U); similarly for V **)
(** LATEX VERSION: Not a numbered item; bookkeeping step using the definition of the finite complement topology. **)
claim HUcases: finite (R :\: U) \/ U = Empty.
{ exact (SepE2 (Power R) (fun U0:set => finite (R :\: U0) \/ U0 = Empty) U HU). }
claim HUfin: finite (R :\: U).
{ apply (HUcases (finite (R :\: U))).
  - assume Hfin. exact Hfin.
  - assume HUe: U = Empty.
    apply FalseE.
    claim H0Empty: 0 :e Empty.
    { rewrite <- HUe at 2.
      exact H0U. }
    exact (EmptyE 0 H0Empty). }
claim HVcases: finite (R :\: V) \/ V = Empty.
{ exact (SepE2 (Power R) (fun U0:set => finite (R :\: U0) \/ U0 = Empty) V HV). }
claim HVfin: finite (R :\: V).
{ apply (HVcases (finite (R :\: V))).
  - assume Hfin. exact Hfin.
  - assume HVe: V = Empty.
    apply FalseE.
    claim H1Empty: 1 :e Empty.
    { rewrite <- HVe at 2.
      exact H1V. }
    exact (EmptyE 1 H1Empty). }

(** then (R\\U)  (R\\V) is finite, and so is R\\(UV) by subset **)
claim HfinUnion: finite ((R :\: U) :\/: (R :\: V)).
{ exact (binunion_finite (R :\: U) HUfin (R :\: V) HVfin). }
claim Hsub: R :\: (U :/\: V) c= (R :\: U) :\/: (R :\: V).
{ let x. assume Hx: x :e R :\: (U :/\: V).
  claim HxR: x :e R.
  { exact (setminusE1 R (U :/\: V) x Hx). }
  claim HxNotUV: x /:e (U :/\: V).
  { exact (setminusE2 R (U :/\: V) x Hx). }
  apply (xm (x :e U)).
  - assume HxU: x :e U.
    claim HxNotV: x /:e V.
    { assume HxV: x :e V.
      claim HxUV: x :e U :/\: V.
      { exact (binintersectI U V x HxU HxV). }
      exact (HxNotUV HxUV). }
    claim HxRV: x :e R :\: V.
    { exact (setminusI R V x HxR HxNotV). }
    exact (binunionI2 (R :\: U) (R :\: V) x HxRV).
  - assume HxNotU: ~(x :e U).
    claim HxRU: x :e R :\: U.
    { exact (setminusI R U x HxR HxNotU). }
    exact (binunionI1 (R :\: U) (R :\: V) x HxRU). }
claim HfinDiff: finite (R :\: (U :/\: V)).
{ exact (Subq_finite ((R :\: U) :\/: (R :\: V)) HfinUnion (R :\: (U :/\: V)) Hsub). }
claim HfinR: finite R.
{ claim HeqR: R :\: (U :/\: V) = R.
  { rewrite HUVempty.
    rewrite (setminus_Empty_eq R).
    reflexivity. }
  rewrite <- HeqR.
  exact HfinDiff. }
exact (infinite_R HfinR).
Qed.

(** helper: the standard topology on R is Hausdorff and T1 **)
Theorem R_standard_topology_Hausdorff : Hausdorff_space R R_standard_topology.
prove Hausdorff_space R R_standard_topology.
rewrite <- (standard_topology_is_order_topology).
exact (ex17_10_order_topology_Hausdorff R).
Qed.

Theorem R_standard_topology_T1 : T1_space R R_standard_topology.
claim Htop: topology_on R R_standard_topology.
{ exact R_standard_topology_is_topology_local. }
apply (iffER (T1_space R R_standard_topology)
             (forall z:set, z :e R -> closed_in R R_standard_topology {z})
             (lemma_T1_singletons_closed R R_standard_topology Htop)).
prove forall z:set, z :e R -> closed_in R R_standard_topology {z}.
let z. assume HzR: z :e R.
prove closed_in R R_standard_topology {z}.
claim HzSub: {z} c= R.
{ let y. assume Hy: y :e {z}.
  claim Heq: y = z.
  { exact (SingE z y Hy). }
  rewrite Heq. exact HzR. }
claim HUopen: R :\: {z} :e R_standard_topology.
{ rewrite (Sing_eq_UPair z).
  exact (R_minus_singleton_in_R_standard_topology z HzR). }
claim Hclosed: closed_in R R_standard_topology (R :\: (R :\: {z})).
{ exact (closed_of_open_complement R R_standard_topology (R :\: {z}) Htop HUopen). }
claim Heq: R :\: (R :\: {z}) = {z}.
{ exact (setminus_setminus_eq R {z} HzSub). }
rewrite <- Heq.
exact Hclosed.
Qed.

(** helper: Hausdorff is preserved by passing to a finer topology **)
Theorem finer_preserves_Hausdorff : forall X Tx Ty:set,
  Hausdorff_space X Tx ->
  topology_on X Ty ->
  Tx c= Ty ->
  Hausdorff_space X Ty.
let X Tx Ty.
assume HH: Hausdorff_space X Tx.
assume HTy: topology_on X Ty.
assume Hsub: Tx c= Ty.
prove Hausdorff_space X Ty.
prove topology_on X Ty /\
  forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
    exists U V:set, U :e Ty /\ V :e Ty /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
apply andI.
- exact HTy.
- claim Hsep: forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
    exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
  { exact (andER (topology_on X Tx)
                 (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
                 HH). }
  let x1 x2.
  assume Hx1: x1 :e X.
  assume Hx2: x2 :e X.
  assume Hne: x1 <> x2.
  apply (Hsep x1 x2 Hx1 Hx2 Hne).
  let U. assume HexV.
  apply HexV.
	  let V. assume HUV.
	  witness U.
	  witness V.
	  claim Hpre: (((U :e Tx /\ V :e Tx) /\ x1 :e U) /\ x2 :e V).
	  { exact (andEL (((U :e Tx /\ V :e Tx) /\ x1 :e U) /\ x2 :e V)
	                 (U :/\: V = Empty)
	                 HUV). }
	  claim Hempty: U :/\: V = Empty.
	  { exact (andER (((U :e Tx /\ V :e Tx) /\ x1 :e U) /\ x2 :e V)
	                 (U :/\: V = Empty)
	                 HUV). }
	  claim Hpre2: ((U :e Tx /\ V :e Tx) /\ x1 :e U).
	  { exact (andEL ((U :e Tx /\ V :e Tx) /\ x1 :e U) (x2 :e V) Hpre). }
	  claim Hx2V: x2 :e V.
	  { exact (andER ((U :e Tx /\ V :e Tx) /\ x1 :e U) (x2 :e V) Hpre). }
	  claim Hpair: (U :e Tx /\ V :e Tx).
	  { exact (andEL (U :e Tx /\ V :e Tx) (x1 :e U) Hpre2). }
	  claim Hx1U: x1 :e U.
	  { exact (andER (U :e Tx /\ V :e Tx) (x1 :e U) Hpre2). }
	  claim HUinTx: U :e Tx.
	  { exact (andEL (U :e Tx) (V :e Tx) Hpair). }
	  claim HVinTx: V :e Tx.
	  { exact (andER (U :e Tx) (V :e Tx) Hpair). }
  claim HUinTy: U :e Ty.
  { exact (Hsub U HUinTx). }
	  claim HVinTy: V :e Ty.
	  { exact (Hsub V HVinTx). }
	  prove U :e Ty /\ V :e Ty /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
	  apply andI.
	  - prove ((U :e Ty /\ V :e Ty) /\ x1 :e U) /\ x2 :e V.
	    apply andI.
	    + prove (U :e Ty /\ V :e Ty) /\ x1 :e U.
	      apply andI.
	      * prove U :e Ty /\ V :e Ty.
	        apply andI.
	        - exact HUinTy.
	        - exact HVinTy.
	      * exact Hx1U.
	    + exact Hx2V.
	  - exact Hempty.
Qed.

(** helper: the upper limit topology on R is Hausdorff and T1 **)
Theorem R_upper_limit_topology_Hausdorff : Hausdorff_space R R_upper_limit_topology.
claim HcontAll: finer_than R_upper_limit_topology R_standard_topology /\
                finer_than R_K_topology R_standard_topology /\
                finer_than R_standard_topology R_finite_complement_topology /\
                finer_than R_standard_topology R_ray_topology.
{ exact ex13_7_R_topology_containments. }
claim Hleft1: (finer_than R_upper_limit_topology R_standard_topology /\
               finer_than R_K_topology R_standard_topology) /\
              finer_than R_standard_topology R_finite_complement_topology.
{ exact (andEL ((finer_than R_upper_limit_topology R_standard_topology /\
                 finer_than R_K_topology R_standard_topology) /\
                finer_than R_standard_topology R_finite_complement_topology)
               (finer_than R_standard_topology R_ray_topology)
               HcontAll). }
claim Hleft2: finer_than R_upper_limit_topology R_standard_topology /\
              finer_than R_K_topology R_standard_topology.
{ exact (andEL (finer_than R_upper_limit_topology R_standard_topology /\
                finer_than R_K_topology R_standard_topology)
               (finer_than R_standard_topology R_finite_complement_topology)
               Hleft1). }
claim Hsub: R_standard_topology c= R_upper_limit_topology.
{ exact (andEL (finer_than R_upper_limit_topology R_standard_topology)
               (finer_than R_K_topology R_standard_topology)
               Hleft2). }
exact (finer_preserves_Hausdorff R R_standard_topology R_upper_limit_topology
       R_standard_topology_Hausdorff
       R_upper_limit_topology_is_topology_local
       Hsub).
Qed.

Theorem R_upper_limit_topology_T1 : T1_space R R_upper_limit_topology.
claim HtopStd: topology_on R R_standard_topology.
{ exact R_standard_topology_is_topology_local. }
claim HtopUpper: topology_on R R_upper_limit_topology.
{ exact R_upper_limit_topology_is_topology_local. }
claim HcontAll: finer_than R_upper_limit_topology R_standard_topology /\
                finer_than R_K_topology R_standard_topology /\
                finer_than R_standard_topology R_finite_complement_topology /\
                finer_than R_standard_topology R_ray_topology.
{ exact ex13_7_R_topology_containments. }
claim Hleft1: (finer_than R_upper_limit_topology R_standard_topology /\
               finer_than R_K_topology R_standard_topology) /\
              finer_than R_standard_topology R_finite_complement_topology.
{ exact (andEL ((finer_than R_upper_limit_topology R_standard_topology /\
                 finer_than R_K_topology R_standard_topology) /\
                finer_than R_standard_topology R_finite_complement_topology)
               (finer_than R_standard_topology R_ray_topology)
               HcontAll). }
claim Hleft2: finer_than R_upper_limit_topology R_standard_topology /\
              finer_than R_K_topology R_standard_topology.
{ exact (andEL (finer_than R_upper_limit_topology R_standard_topology /\
                finer_than R_K_topology R_standard_topology)
               (finer_than R_standard_topology R_finite_complement_topology)
               Hleft1). }
claim Hsub: R_standard_topology c= R_upper_limit_topology.
{ exact (andEL (finer_than R_upper_limit_topology R_standard_topology)
               (finer_than R_K_topology R_standard_topology)
               Hleft2). }
claim HpropStd:
  forall x y:set, x :e R -> y :e R -> x <> y ->
    (exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U) /\
    (exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V).
{ exact (iffEL (T1_space R R_standard_topology)
               (forall x y:set, x :e R -> y :e R -> x <> y ->
                 (exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U) /\
                 (exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V))
               (ex17_15_T1_characterization R R_standard_topology HtopStd)
               R_standard_topology_T1). }
apply (iffER (T1_space R R_upper_limit_topology)
             (forall x y:set, x :e R -> y :e R -> x <> y ->
               (exists U:set, U :e R_upper_limit_topology /\ x :e U /\ y /:e U) /\
               (exists V:set, V :e R_upper_limit_topology /\ y :e V /\ x /:e V))
             (ex17_15_T1_characterization R R_upper_limit_topology HtopUpper)).
let x y.
assume HxR: x :e R.
assume HyR: y :e R.
assume Hne: x <> y.
claim Hprop: (exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U) /\
             (exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V).
{ exact (HpropStd x y HxR HyR Hne). }
apply andI.
- claim HexU: exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U.
  { exact (andEL (exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U)
                 (exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V)
                 Hprop). }
	  apply HexU.
	  let U. assume HU.
	  witness U.
	  claim Hpre: U :e R_standard_topology /\ x :e U.
	  { exact (andEL (U :e R_standard_topology /\ x :e U) (y /:e U) HU). }
	  claim HUinStd: U :e R_standard_topology.
	  { exact (andEL (U :e R_standard_topology) (x :e U) Hpre). }
	  claim HxU: x :e U.
	  { exact (andER (U :e R_standard_topology) (x :e U) Hpre). }
	  claim Hnoty: y /:e U.
	  { exact (andER (U :e R_standard_topology /\ x :e U) (y /:e U) HU). }
	  claim HUinUpper: U :e R_upper_limit_topology.
	  { exact (Hsub U HUinStd). }
	  prove U :e R_upper_limit_topology /\ x :e U /\ y /:e U.
	  apply andI.
	  - prove U :e R_upper_limit_topology /\ x :e U.
	    apply andI.
	    + exact HUinUpper.
	    + exact HxU.
	  - exact Hnoty.
- claim HexV: exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V.
  { exact (andER (exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U)
                 (exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V)
                 Hprop). }
	  apply HexV.
	  let V. assume HV.
	  witness V.
	  claim Hpre: V :e R_standard_topology /\ y :e V.
	  { exact (andEL (V :e R_standard_topology /\ y :e V) (x /:e V) HV). }
	  claim HVinStd: V :e R_standard_topology.
	  { exact (andEL (V :e R_standard_topology) (y :e V) Hpre). }
	  claim HyV: y :e V.
	  { exact (andER (V :e R_standard_topology) (y :e V) Hpre). }
	  claim Hnotx: x /:e V.
	  { exact (andER (V :e R_standard_topology /\ y :e V) (x /:e V) HV). }
	  claim HVinUpper: V :e R_upper_limit_topology.
	  { exact (Hsub V HVinStd). }
	  prove V :e R_upper_limit_topology /\ y :e V /\ x /:e V.
	  apply andI.
	  - prove V :e R_upper_limit_topology /\ y :e V.
	    apply andI.
	    + exact HVinUpper.
	    + exact HyV.
	  - exact Hnotx.
Qed.

(** helper: the K topology on R is Hausdorff and T1 **)
Theorem R_K_topology_Hausdorff : Hausdorff_space R R_K_topology.
claim HcontAll: finer_than R_upper_limit_topology R_standard_topology /\
                finer_than R_K_topology R_standard_topology /\
                finer_than R_standard_topology R_finite_complement_topology /\
                finer_than R_standard_topology R_ray_topology.
{ exact ex13_7_R_topology_containments. }
claim Hleft1: (finer_than R_upper_limit_topology R_standard_topology /\
               finer_than R_K_topology R_standard_topology) /\
              finer_than R_standard_topology R_finite_complement_topology.
{ exact (andEL ((finer_than R_upper_limit_topology R_standard_topology /\
                 finer_than R_K_topology R_standard_topology) /\
                finer_than R_standard_topology R_finite_complement_topology)
               (finer_than R_standard_topology R_ray_topology)
               HcontAll). }
claim Hleft2: finer_than R_upper_limit_topology R_standard_topology /\
              finer_than R_K_topology R_standard_topology.
{ exact (andEL (finer_than R_upper_limit_topology R_standard_topology /\
                finer_than R_K_topology R_standard_topology)
               (finer_than R_standard_topology R_finite_complement_topology)
               Hleft1). }
claim Hsub: R_standard_topology c= R_K_topology.
{ exact (andER (finer_than R_upper_limit_topology R_standard_topology)
               (finer_than R_K_topology R_standard_topology)
               Hleft2). }
exact (finer_preserves_Hausdorff R R_standard_topology R_K_topology
       R_standard_topology_Hausdorff
       R_K_topology_is_topology_local
       Hsub).
Qed.

Theorem R_K_topology_T1 : T1_space R R_K_topology.
claim HtopStd: topology_on R R_standard_topology.
{ exact R_standard_topology_is_topology_local. }
claim HtopK: topology_on R R_K_topology.
{ exact R_K_topology_is_topology_local. }
claim HcontAll: finer_than R_upper_limit_topology R_standard_topology /\
                finer_than R_K_topology R_standard_topology /\
                finer_than R_standard_topology R_finite_complement_topology /\
                finer_than R_standard_topology R_ray_topology.
{ exact ex13_7_R_topology_containments. }
claim Hleft1: (finer_than R_upper_limit_topology R_standard_topology /\
               finer_than R_K_topology R_standard_topology) /\
              finer_than R_standard_topology R_finite_complement_topology.
{ exact (andEL ((finer_than R_upper_limit_topology R_standard_topology /\
                 finer_than R_K_topology R_standard_topology) /\
                finer_than R_standard_topology R_finite_complement_topology)
               (finer_than R_standard_topology R_ray_topology)
               HcontAll). }
claim Hleft2: finer_than R_upper_limit_topology R_standard_topology /\
              finer_than R_K_topology R_standard_topology.
{ exact (andEL (finer_than R_upper_limit_topology R_standard_topology /\
                finer_than R_K_topology R_standard_topology)
               (finer_than R_standard_topology R_finite_complement_topology)
               Hleft1). }
claim Hsub: R_standard_topology c= R_K_topology.
{ exact (andER (finer_than R_upper_limit_topology R_standard_topology)
               (finer_than R_K_topology R_standard_topology)
               Hleft2). }
claim HpropStd:
  forall x y:set, x :e R -> y :e R -> x <> y ->
    (exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U) /\
    (exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V).
{ exact (iffEL (T1_space R R_standard_topology)
               (forall x y:set, x :e R -> y :e R -> x <> y ->
                 (exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U) /\
                 (exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V))
               (ex17_15_T1_characterization R R_standard_topology HtopStd)
               R_standard_topology_T1). }
apply (iffER (T1_space R R_K_topology)
             (forall x y:set, x :e R -> y :e R -> x <> y ->
               (exists U:set, U :e R_K_topology /\ x :e U /\ y /:e U) /\
               (exists V:set, V :e R_K_topology /\ y :e V /\ x /:e V))
             (ex17_15_T1_characterization R R_K_topology HtopK)).
let x y.
assume HxR: x :e R.
assume HyR: y :e R.
assume Hne: x <> y.
claim Hprop: (exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U) /\
             (exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V).
{ exact (HpropStd x y HxR HyR Hne). }
apply andI.
- claim HexU: exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U.
  { exact (andEL (exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U)
                 (exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V)
                 Hprop). }
  apply HexU.
  let U. assume HU.
  witness U.
  claim Hpre: U :e R_standard_topology /\ x :e U.
  { exact (andEL (U :e R_standard_topology /\ x :e U) (y /:e U) HU). }
  claim HUinStd: U :e R_standard_topology.
  { exact (andEL (U :e R_standard_topology) (x :e U) Hpre). }
  claim HxU: x :e U.
  { exact (andER (U :e R_standard_topology) (x :e U) Hpre). }
  claim Hnoty: y /:e U.
  { exact (andER (U :e R_standard_topology /\ x :e U) (y /:e U) HU). }
  claim HUinK: U :e R_K_topology.
  { exact (Hsub U HUinStd). }
  prove U :e R_K_topology /\ x :e U /\ y /:e U.
  apply andI.
  - prove U :e R_K_topology /\ x :e U.
    apply andI.
    + exact HUinK.
    + exact HxU.
  - exact Hnoty.
- claim HexV: exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V.
  { exact (andER (exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U)
                 (exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V)
                 Hprop). }
  apply HexV.
  let V. assume HV.
  witness V.
  claim Hpre: V :e R_standard_topology /\ y :e V.
  { exact (andEL (V :e R_standard_topology /\ y :e V) (x /:e V) HV). }
  claim HVinStd: V :e R_standard_topology.
  { exact (andEL (V :e R_standard_topology) (y :e V) Hpre). }
  claim HyV: y :e V.
  { exact (andER (V :e R_standard_topology) (y :e V) Hpre). }
  claim Hnotx: x /:e V.
  { exact (andER (V :e R_standard_topology /\ y :e V) (x /:e V) HV). }
  claim HVinK: V :e R_K_topology.
  { exact (Hsub V HVinStd). }
  prove V :e R_K_topology /\ y :e V /\ x /:e V.
  apply andI.
  - prove V :e R_K_topology /\ y :e V.
    apply andI.
    + exact HVinK.
    + exact HyV.
  - exact Hnotx.
Qed.

(** LATEX VERSION: Exercise 16(b): For the same five R topologies, determine which satisfy the Hausdorff and the T1 axioms. **)
Theorem ex17_16b_Hausdorff_and_T1_for_five_topologies :
  (Hausdorff_space R R_standard_topology /\ T1_space R R_standard_topology) /\
  (Hausdorff_space R R_upper_limit_topology /\ T1_space R R_upper_limit_topology) /\
  (Hausdorff_space R R_K_topology /\ T1_space R R_K_topology) /\
  (~Hausdorff_space R R_finite_complement_topology /\ T1_space R R_finite_complement_topology) /\
  (~Hausdorff_space R R_ray_topology /\ ~T1_space R R_ray_topology).
prove (Hausdorff_space R R_standard_topology /\ T1_space R R_standard_topology) /\
  (Hausdorff_space R R_upper_limit_topology /\ T1_space R R_upper_limit_topology) /\
  (Hausdorff_space R R_K_topology /\ T1_space R R_K_topology) /\
  (~Hausdorff_space R R_finite_complement_topology /\ T1_space R R_finite_complement_topology) /\
  (~Hausdorff_space R R_ray_topology /\ ~T1_space R R_ray_topology).
apply andI.
- apply andI.
  * prove (Hausdorff_space R R_standard_topology /\ T1_space R R_standard_topology) /\
          (Hausdorff_space R R_upper_limit_topology /\ T1_space R R_upper_limit_topology) /\
          (Hausdorff_space R R_K_topology /\ T1_space R R_K_topology).
	    apply andI.
		    { apply andI.
		      - prove Hausdorff_space R R_standard_topology /\ T1_space R R_standard_topology.
		        apply andI.
		        + exact R_standard_topology_Hausdorff.
		        + exact R_standard_topology_T1.
		      - prove Hausdorff_space R R_upper_limit_topology /\ T1_space R R_upper_limit_topology.
		        apply andI.
		        + exact R_upper_limit_topology_Hausdorff.
		        + exact R_upper_limit_topology_T1.
		    }
		    { prove Hausdorff_space R R_K_topology /\ T1_space R R_K_topology.
		      apply andI.
		      - exact R_K_topology_Hausdorff.
		      - exact R_K_topology_T1.
		    }
	  * prove ~Hausdorff_space R R_finite_complement_topology /\ T1_space R R_finite_complement_topology.
	    apply andI.
	    { exact R_finite_complement_not_Hausdorff. }
	    { exact (finite_complement_topology_T1 R). }
- prove ~Hausdorff_space R R_ray_topology /\ ~T1_space R R_ray_topology.
  apply andI.
  + exact ray_topology_not_Hausdorff.
  + exact ray_topology_not_T1.
Qed.

(** LATEX VERSION: Exercise 17: Compare closures of A=(0,sqrt 2) and B=(sqrt 2,3) in the lower limit topology and the topology generated by the rational half open basis C. **)
(** Helper: basic real membership facts used in Exercise 17 definitions **)
Theorem real_2 : 2 :e R.
prove 2 :e R.
rewrite <- add_SNo_1_1_2.
exact (real_add_SNo 1 real_1 1 real_1).
Qed.

Theorem ordsucc_2_eq_3 : ordsucc 2 = 3.
reflexivity.
Qed.

Theorem add_SNo_2_1_eq_3 : add_SNo 2 1 = 3.
claim H2omega : 2 :e omega.
{ exact (nat_p_omega 2 nat_2). }
rewrite (add_SNo_1_ordsucc 2 H2omega).
rewrite ordsucc_2_eq_3.
reflexivity.
Qed.

Theorem real_3 : 3 :e R.
prove 3 :e R.
rewrite <- add_SNo_2_1_eq_3.
exact (real_add_SNo 2 real_2 1 real_1).
Qed.

Definition sqrt2 : set := sqrt_SNo_nonneg 2.

(** Helper: sqrt2 is real **)
Theorem sqrt2_in_R : sqrt2 :e R.
prove sqrt2 :e R.
exact (sqrt_SNo_nonneg_real 2 real_2 (SNoLtLe 0 2 SNoLt_0_2)).
Qed.

Definition R_C_topology : set := generated_topology R rational_halfopen_intervals_basis.
Definition ex17_17_interval_A : set := open_interval 0 sqrt2.
Definition ex17_17_interval_B : set := open_interval sqrt2 3.
Definition ex17_17_interval_A_closure_lower : set := {x :e R|0 <= x /\ x < sqrt2}.
Definition ex17_17_interval_A_closure_C : set := {x :e R|0 <= x /\ x <= sqrt2}.
Definition ex17_17_interval_B_closure_lower : set := {x :e R|sqrt2 <= x /\ x < 3}.

Theorem ex17_17_closures_of_A_B_in_two_topologies :
  closure_of R R_lower_limit_topology ex17_17_interval_A = ex17_17_interval_A_closure_lower /\
  closure_of R R_C_topology ex17_17_interval_A = ex17_17_interval_A_closure_C /\
  closure_of R R_lower_limit_topology ex17_17_interval_B = ex17_17_interval_B_closure_lower /\
  closure_of R R_C_topology ex17_17_interval_B = ex17_17_interval_B_closure_lower.
prove closure_of R R_lower_limit_topology ex17_17_interval_A = ex17_17_interval_A_closure_lower /\
  closure_of R R_C_topology ex17_17_interval_A = ex17_17_interval_A_closure_C /\
  closure_of R R_lower_limit_topology ex17_17_interval_B = ex17_17_interval_B_closure_lower /\
  closure_of R R_C_topology ex17_17_interval_B = ex17_17_interval_B_closure_lower.
admit.
Qed.

(** LATEX VERSION: Exercise 18: Determine the closures of the subsets A,B,C,D,E of the ordered square listed in the text. **)
Definition ordsq_A : set := {(inv_nat n,0)|n :e omega :\: {0}}.
Definition ordsq_B : set := {(add_SNo 1 (minus_SNo (inv_nat n)),eps_ 1)|n :e omega :\: {0}}.
Definition ordsq_C : set := {p :e ordered_square|exists x:set, p = (x,0) /\ Rlt 0 x /\ Rlt x 1}.
Definition ordsq_D : set := {p :e ordered_square|exists x:set, p = (x,eps_ 1) /\ Rlt 0 x /\ Rlt x 1}.
Definition ordsq_E : set := {p :e ordered_square|exists y:set, p = (eps_ 1,y) /\ Rlt 0 y /\ Rlt y 1}.

Definition ordsq_p01 : set := (0,1).
Definition ordsq_p10 : set := (1,0).
Definition ordsq_E_closure : set := ordsq_E :\/: {(eps_ 1,0)} :\/: {(eps_ 1,1)}.

Theorem ex17_18_closures_in_ordered_square :
  closure_of ordered_square ordered_square_topology ordsq_A = ordsq_A :\/: {ordsq_p01} /\
  closure_of ordered_square ordered_square_topology ordsq_B = ordsq_B :\/: {ordsq_p10} /\
  closure_of ordered_square ordered_square_topology ordsq_C = ordsq_C :\/: {ordsq_p01} :\/: {ordsq_p10} /\
  closure_of ordered_square ordered_square_topology ordsq_D = ordsq_D :\/: ordsq_C :\/: {ordsq_p01} :\/: {ordsq_p10} /\
  closure_of ordered_square ordered_square_topology ordsq_E = ordsq_E_closure.
prove closure_of ordered_square ordered_square_topology ordsq_A = ordsq_A :\/: {ordsq_p01} /\
  closure_of ordered_square ordered_square_topology ordsq_B = ordsq_B :\/: {ordsq_p10} /\
  closure_of ordered_square ordered_square_topology ordsq_C = ordsq_C :\/: {ordsq_p01} :\/: {ordsq_p10} /\
  closure_of ordered_square ordered_square_topology ordsq_D = ordsq_D :\/: ordsq_C :\/: {ordsq_p01} :\/: {ordsq_p10} /\
  closure_of ordered_square ordered_square_topology ordsq_E = ordsq_E_closure.
admit.
Qed.

Definition boundary_of : set -> set -> set -> set := fun X Tx A =>
  closure_of X Tx A :/\: closure_of X Tx (X :\: A).

(** LATEX VERSION: Exercise 19: The boundary of A lies in closure(A) and in closure(X\\A). **)
Theorem ex17_19_boundary_properties : forall X Tx A:set,
  topology_on X Tx ->
  boundary_of X Tx A c= closure_of X Tx A /\
  boundary_of X Tx A c= closure_of X Tx (X :\: A).
let X Tx A.
assume Htop: topology_on X Tx.
prove boundary_of X Tx A c= closure_of X Tx A /\ boundary_of X Tx A c= closure_of X Tx (X :\: A).
(** boundary_of is defined as closure(A)  closure(X\A), so both inclusions follow from binintersect_Subq **)
apply andI.
- prove boundary_of X Tx A c= closure_of X Tx A.
  exact (binintersect_Subq_1 (closure_of X Tx A) (closure_of X Tx (X :\: A))).
- prove boundary_of X Tx A c= closure_of X Tx (X :\: A).
  exact (binintersect_Subq_2 (closure_of X Tx A) (closure_of X Tx (X :\: A))).
Qed.

(** LATEX VERSION: Exercise 20: Boundary of a strip differs between standard and dictionary topologies on . **)
Theorem ex17_20_boundaries_and_interiors_in_R2 :
  boundary_of (setprod R R) R2_standard_topology ordered_square_open_strip <>
  boundary_of (setprod R R) R2_dictionary_order_topology ordered_square_open_strip.
prove boundary_of (setprod R R) R2_standard_topology ordered_square_open_strip <> boundary_of (setprod R R) R2_dictionary_order_topology ordered_square_open_strip.
admit.
Qed.

(** LATEX VERSION: Exercise 21: Kuratowski example in discrete topology gives maximal closure after complement. **)
Theorem ex17_21_Kuratowski_closure_complement_maximal : forall X:set,
  closure_of X (discrete_topology X) (X :\: Empty) = X.
let X.
prove closure_of X (discrete_topology X) (X :\: Empty) = X.
claim Htop: topology_on X (discrete_topology X).
{ exact (discrete_topology_on X). }
claim HXE: X :\: Empty = X.
{ apply set_ext.
  - let x. assume Hx: x :e X :\: Empty.
    exact (setminusE1 X Empty x Hx).
  - let x. assume Hx: x :e X.
    apply setminusI.
    + exact Hx.
    + assume Hfalse: x :e Empty.
      exact (EmptyE x Hfalse). }
(** Rewrite the LHS using HXE **)
rewrite HXE.
(** Now we need to prove closure_of X (discrete_topology X) X = X **)
apply set_ext.
- exact (closure_in_space X (discrete_topology X) X Htop).
- exact (subset_of_closure X (discrete_topology X) X Htop (Subq_ref X)).
Qed.

(** from 18 Definition: continuous map between topological spaces **) 
(** LATEX VERSION: Continuity defined via preimages of open sets being open. **)
Definition preimage_of : set -> set -> set -> set := fun X f V =>
  {x :e X | apply_fun f x :e V}.

(** Helper: preimage of union of a family **)
(** LATEX VERSION: f^{-1}(Union Fam) equals Union of the preimages f^{-1}(V) for V in Fam. **)
Theorem preimage_of_Union : forall X f Fam:set,
  preimage_of X f (Union Fam) = Union {preimage_of X f V|V :e Fam}.
let X f Fam.
apply set_ext.
- let x. assume Hx: x :e preimage_of X f (Union Fam).
  prove x :e Union {preimage_of X f V|V :e Fam}.
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0:set => apply_fun f x0 :e Union Fam) x Hx). }
  claim HfxU: apply_fun f x :e Union Fam.
  { exact (SepE2 X (fun x0:set => apply_fun f x0 :e Union Fam) x Hx). }
  apply (UnionE_impred Fam (apply_fun f x) HfxU).
  let V. assume HfxV: apply_fun f x :e V.
  assume HVFam: V :e Fam.
  claim HxPre: x :e preimage_of X f V.
  { exact (SepI X (fun x0:set => apply_fun f x0 :e V) x HxX HfxV). }
  exact (UnionI {preimage_of X f V0|V0 :e Fam} x (preimage_of X f V) HxPre
               (ReplI Fam (fun V0:set => preimage_of X f V0) V HVFam)).
- let x. assume Hx: x :e Union {preimage_of X f V|V :e Fam}.
  prove x :e preimage_of X f (Union Fam).
  apply (UnionE_impred {preimage_of X f V|V :e Fam} x Hx).
  let W. assume HxW: x :e W.
  assume HW: W :e {preimage_of X f V|V :e Fam}.
  apply (ReplE_impred Fam (fun V0:set => preimage_of X f V0) W HW).
  let V. assume HVFam: V :e Fam.
  assume HWV: W = preimage_of X f V.
  claim HxPre: x :e preimage_of X f V.
  { rewrite <- HWV.
    exact HxW. }
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0:set => apply_fun f x0 :e V) x HxPre). }
  claim HfxV: apply_fun f x :e V.
  { exact (SepE2 X (fun x0:set => apply_fun f x0 :e V) x HxPre). }
  claim HfxU: apply_fun f x :e Union Fam.
  { exact (UnionI Fam (apply_fun f x) V HfxV HVFam). }
  exact (SepI X (fun x0:set => apply_fun f x0 :e Union Fam) x HxX HfxU).
Qed.

(** Helper: preimage of binary intersection **)
(** LATEX VERSION: f^{-1}(UV) = f^{-1}(U)  f^{-1}(V). **)
Theorem preimage_of_binintersect : forall X f U V:set,
  preimage_of X f (U :/\: V) = (preimage_of X f U) :/\: (preimage_of X f V).
let X f U V.
apply set_ext.
- let x. assume Hx: x :e preimage_of X f (U :/\: V).
  prove x :e (preimage_of X f U) :/\: (preimage_of X f V).
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0:set => apply_fun f x0 :e U :/\: V) x Hx). }
  claim HfxUV: apply_fun f x :e U :/\: V.
  { exact (SepE2 X (fun x0:set => apply_fun f x0 :e U :/\: V) x Hx). }
  claim HfxU: apply_fun f x :e U.
  { exact (binintersectE1 U V (apply_fun f x) HfxUV). }
  claim HfxV: apply_fun f x :e V.
  { exact (binintersectE2 U V (apply_fun f x) HfxUV). }
  claim HxPreU: x :e preimage_of X f U.
  { exact (SepI X (fun x0:set => apply_fun f x0 :e U) x HxX HfxU). }
  claim HxPreV: x :e preimage_of X f V.
  { exact (SepI X (fun x0:set => apply_fun f x0 :e V) x HxX HfxV). }
  exact (binintersectI (preimage_of X f U) (preimage_of X f V) x HxPreU HxPreV).
- let x. assume Hx: x :e (preimage_of X f U) :/\: (preimage_of X f V).
  prove x :e preimage_of X f (U :/\: V).
  claim HxPreU: x :e preimage_of X f U.
  { exact (binintersectE1 (preimage_of X f U) (preimage_of X f V) x Hx). }
  claim HxPreV: x :e preimage_of X f V.
  { exact (binintersectE2 (preimage_of X f U) (preimage_of X f V) x Hx). }
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0:set => apply_fun f x0 :e U) x HxPreU). }
  claim HfxU: apply_fun f x :e U.
  { exact (SepE2 X (fun x0:set => apply_fun f x0 :e U) x HxPreU). }
  claim HfxV: apply_fun f x :e V.
  { exact (SepE2 X (fun x0:set => apply_fun f x0 :e V) x HxPreV). }
  claim HfxUV: apply_fun f x :e U :/\: V.
  { exact (binintersectI U V (apply_fun f x) HfxU HfxV). }
  exact (SepI X (fun x0:set => apply_fun f x0 :e U :/\: V) x HxX HfxUV).
Qed.

(** Helper: preimage is monotone under inclusion **)
(** LATEX VERSION: If V subset W then f^{-1}(V) subset f^{-1}(W). **)
Theorem preimage_of_mono : forall X f V W:set,
  V c= W ->
  preimage_of X f V c= preimage_of X f W.
let X f V W.
assume HVW: V c= W.
let x. assume Hx: x :e preimage_of X f V.
prove x :e preimage_of X f W.
claim HxX: x :e X.
{ exact (SepE1 X (fun x0:set => apply_fun f x0 :e V) x Hx). }
claim HfxV: apply_fun f x :e V.
{ exact (SepE2 X (fun x0:set => apply_fun f x0 :e V) x Hx). }
claim HfxW: apply_fun f x :e W.
{ exact (HVW (apply_fun f x) HfxV). }
exact (SepI X (fun x0:set => apply_fun f x0 :e W) x HxX HfxW).
Qed.

(** Helper: preimage of binary union **)
(** LATEX VERSION: f^{-1}(UV) = f^{-1}(U)  f^{-1}(V). **)
Theorem preimage_of_binunion : forall X f U V:set,
  preimage_of X f (U :\/: V) = (preimage_of X f U) :\/: (preimage_of X f V).
let X f U V.
apply set_ext.
- let x. assume Hx: x :e preimage_of X f (U :\/: V).
  prove x :e (preimage_of X f U) :\/: (preimage_of X f V).
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0:set => apply_fun f x0 :e U :\/: V) x Hx). }
  claim HfxUV: apply_fun f x :e U :\/: V.
  { exact (SepE2 X (fun x0:set => apply_fun f x0 :e U :\/: V) x Hx). }
  apply (binunionE U V (apply_fun f x) HfxUV).
  * assume HfxU: apply_fun f x :e U.
    claim HxPreU: x :e preimage_of X f U.
    { exact (SepI X (fun x0:set => apply_fun f x0 :e U) x HxX HfxU). }
    exact (binunionI1 (preimage_of X f U) (preimage_of X f V) x HxPreU).
  * assume HfxV: apply_fun f x :e V.
    claim HxPreV: x :e preimage_of X f V.
    { exact (SepI X (fun x0:set => apply_fun f x0 :e V) x HxX HfxV). }
    exact (binunionI2 (preimage_of X f U) (preimage_of X f V) x HxPreV).
- let x. assume Hx: x :e (preimage_of X f U) :\/: (preimage_of X f V).
  prove x :e preimage_of X f (U :\/: V).
  apply (binunionE (preimage_of X f U) (preimage_of X f V) x Hx).
  * assume HxPreU: x :e preimage_of X f U.
    claim HxX: x :e X.
    { exact (SepE1 X (fun x0:set => apply_fun f x0 :e U) x HxPreU). }
    claim HfxU: apply_fun f x :e U.
    { exact (SepE2 X (fun x0:set => apply_fun f x0 :e U) x HxPreU). }
    claim HfxUV: apply_fun f x :e U :\/: V.
    { exact (binunionI1 U V (apply_fun f x) HfxU). }
    exact (SepI X (fun x0:set => apply_fun f x0 :e U :\/: V) x HxX HfxUV).
  * assume HxPreV: x :e preimage_of X f V.
    claim HxX: x :e X.
    { exact (SepE1 X (fun x0:set => apply_fun f x0 :e V) x HxPreV). }
    claim HfxV: apply_fun f x :e V.
    { exact (SepE2 X (fun x0:set => apply_fun f x0 :e V) x HxPreV). }
    claim HfxUV: apply_fun f x :e U :\/: V.
    { exact (binunionI2 U V (apply_fun f x) HfxV). }
    exact (SepI X (fun x0:set => apply_fun f x0 :e U :\/: V) x HxX HfxUV).
Qed.

(** Helper: preimage of set difference **)
(** LATEX VERSION: f^{-1}(U\\V) = f^{-1}(U)\\f^{-1}(V). **)
Theorem preimage_of_setminus : forall X f U V:set,
  preimage_of X f (U :\: V) = (preimage_of X f U) :\: (preimage_of X f V).
let X f U V.
apply set_ext.
- let x. assume Hx: x :e preimage_of X f (U :\: V).
  prove x :e (preimage_of X f U) :\: (preimage_of X f V).
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0:set => apply_fun f x0 :e U :\: V) x Hx). }
  claim HfxUV: apply_fun f x :e U :\: V.
  { exact (SepE2 X (fun x0:set => apply_fun f x0 :e U :\: V) x Hx). }
  claim HfxU: apply_fun f x :e U.
  { exact (setminusE1 U V (apply_fun f x) HfxUV). }
  claim HfxnotV: apply_fun f x /:e V.
  { exact (setminusE2 U V (apply_fun f x) HfxUV). }
  claim HxPreU: x :e preimage_of X f U.
  { exact (SepI X (fun x0:set => apply_fun f x0 :e U) x HxX HfxU). }
  claim HxnotPreV: x /:e preimage_of X f V.
  { assume HxPreV: x :e preimage_of X f V.
    claim HfxV: apply_fun f x :e V.
    { exact (SepE2 X (fun x0:set => apply_fun f x0 :e V) x HxPreV). }
    exact (HfxnotV HfxV). }
  exact (setminusI (preimage_of X f U) (preimage_of X f V) x HxPreU HxnotPreV).
- let x. assume Hx: x :e (preimage_of X f U) :\: (preimage_of X f V).
  prove x :e preimage_of X f (U :\: V).
  claim HxPreU: x :e preimage_of X f U.
  { exact (setminusE1 (preimage_of X f U) (preimage_of X f V) x Hx). }
  claim HxnotPreV: x /:e preimage_of X f V.
  { exact (setminusE2 (preimage_of X f U) (preimage_of X f V) x Hx). }
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0:set => apply_fun f x0 :e U) x HxPreU). }
  claim HfxU: apply_fun f x :e U.
  { exact (SepE2 X (fun x0:set => apply_fun f x0 :e U) x HxPreU). }
  claim HfxnotV: apply_fun f x /:e V.
  { assume HfxV: apply_fun f x :e V.
    claim HxPreV: x :e preimage_of X f V.
    { exact (SepI X (fun x0:set => apply_fun f x0 :e V) x HxX HfxV). }
    exact (HxnotPreV HxPreV). }
  claim HfxUV: apply_fun f x :e U :\: V.
  { exact (setminusI U V (apply_fun f x) HfxU HfxnotV). }
  exact (SepI X (fun x0:set => apply_fun f x0 :e U :\: V) x HxX HfxUV).
Qed.

(** Helper: preimage of Empty **)
(** LATEX VERSION: f^{-1}() = . **)
Theorem preimage_of_Empty : forall X f:set,
  preimage_of X f Empty = Empty.
let X f.
apply set_ext.
- let x. assume Hx: x :e preimage_of X f Empty.
  prove x :e Empty.
  claim HfxE: apply_fun f x :e Empty.
  { exact (SepE2 X (fun x0:set => apply_fun f x0 :e Empty) x Hx). }
  exact (FalseE ((EmptyE (apply_fun f x)) HfxE) (x :e Empty)).
- let x. assume Hx: x :e Empty.
  prove x :e preimage_of X f Empty.
  apply FalseE.
  exact ((EmptyE x) Hx).
Qed.

(** Helper: preimage of whole codomain under a function_on map **)
(** LATEX VERSION: If f maps X into Y then f^{-1}(Y)=X. **)
Theorem preimage_of_whole : forall X Y f:set,
  function_on f X Y ->
  preimage_of X f Y = X.
let X Y f.
assume Hfun: function_on f X Y.
apply set_ext.
- let x. assume Hx: x :e preimage_of X f Y.
  exact (SepE1 X (fun x0:set => apply_fun f x0 :e Y) x Hx).
- let x. assume HxX: x :e X.
  prove x :e preimage_of X f Y.
  exact (SepI X (fun x0:set => apply_fun f x0 :e Y) x HxX (Hfun x HxX)).
Qed.

(** Helper: preimage of complement (relative to codomain) **)
(** LATEX VERSION: f^{-1}(Y\\V) = X\\f^{-1}(V) when f maps X to Y. **)
Theorem preimage_of_complement : forall X Y f V:set,
  function_on f X Y ->
  preimage_of X f (Y :\: V) = X :\: preimage_of X f V.
let X Y f V.
assume Hfun: function_on f X Y.
rewrite (preimage_of_setminus X f Y V).
rewrite (preimage_of_whole X Y f Hfun).
reflexivity.
Qed.

(** Helper: apply_fun for projections **)
(** LATEX VERSION: For p in XY, proj1(p)=p0 and proj2(p)=p1. **)
Theorem projection1_apply : forall X Y p:set,
  p :e setprod X Y -> apply_fun (projection1 X Y) p = p 0.
let X Y p.
assume Hp: p :e setprod X Y.
prove apply_fun (projection1 X Y) p = p 0.
prove Eps_i (fun z => (p,z) :e projection1 X Y) = p 0.
claim H1: (p, p 0) :e projection1 X Y.
{ exact (ReplI (setprod X Y) (fun q:set => (q, q 0)) p Hp). }
claim H2: (p, Eps_i (fun z => (p,z) :e projection1 X Y)) :e projection1 X Y.
{ exact (Eps_i_ax (fun z => (p,z) :e projection1 X Y) (p 0) H1). }
apply (ReplE_impred (setprod X Y) (fun q:set => (q, q 0))
                     (p, Eps_i (fun z => (p,z) :e projection1 X Y)) H2).
let q.
assume Hq: q :e setprod X Y.
assume Heq: (p, Eps_i (fun z => (p,z) :e projection1 X Y)) = (q, q 0).
claim Hpq: p = q.
{ rewrite <- (tuple_2_0_eq p (Eps_i (fun z => (p,z) :e projection1 X Y))).
  rewrite <- (tuple_2_0_eq q (q 0)).
  rewrite Heq.
  reflexivity. }
claim Hzq0: Eps_i (fun z => (p,z) :e projection1 X Y) = q 0.
{ rewrite <- (tuple_2_1_eq p (Eps_i (fun z => (p,z) :e projection1 X Y))).
  rewrite <- (tuple_2_1_eq q (q 0)).
  rewrite Heq.
  reflexivity. }
claim Hq0p0: q 0 = p 0.
{ rewrite <- Hpq.
  reflexivity. }
rewrite Hzq0.
exact Hq0p0.
Qed.

Theorem projection2_apply : forall X Y p:set,
  p :e setprod X Y -> apply_fun (projection2 X Y) p = p 1.
let X Y p.
assume Hp: p :e setprod X Y.
prove apply_fun (projection2 X Y) p = p 1.
prove Eps_i (fun z => (p,z) :e projection2 X Y) = p 1.
claim H1: (p, p 1) :e projection2 X Y.
{ exact (ReplI (setprod X Y) (fun q:set => (q, q 1)) p Hp). }
claim H2: (p, Eps_i (fun z => (p,z) :e projection2 X Y)) :e projection2 X Y.
{ exact (Eps_i_ax (fun z => (p,z) :e projection2 X Y) (p 1) H1). }
apply (ReplE_impred (setprod X Y) (fun q:set => (q, q 1))
                     (p, Eps_i (fun z => (p,z) :e projection2 X Y)) H2).
let q.
assume Hq: q :e setprod X Y.
assume Heq: (p, Eps_i (fun z => (p,z) :e projection2 X Y)) = (q, q 1).
claim Hpq: p = q.
{ rewrite <- (tuple_2_0_eq p (Eps_i (fun z => (p,z) :e projection2 X Y))).
  rewrite <- (tuple_2_0_eq q (q 1)).
  rewrite Heq.
  reflexivity. }
claim Hzq1: Eps_i (fun z => (p,z) :e projection2 X Y) = q 1.
{ rewrite <- (tuple_2_1_eq p (Eps_i (fun z => (p,z) :e projection2 X Y))).
  rewrite <- (tuple_2_1_eq q (q 1)).
  rewrite Heq.
  reflexivity. }
claim Hq1p1: q 1 = p 1.
{ rewrite <- Hpq.
  reflexivity. }
rewrite Hzq1.
exact Hq1p1.
Qed.

(** Helper: preimages of opens under projections are rectangles **)
(** LATEX VERSION: proj1^{-1}(U)=UY and proj2^{-1}(V)=XV. **)
Theorem preimage_projection1_rectangle : forall X Y U:set,
  U c= X ->
  preimage_of (setprod X Y) (projection1 X Y) U = rectangle_set U Y.
let X Y U.
assume HUsub: U c= X.
apply set_ext.
- let p. assume Hp: p :e preimage_of (setprod X Y) (projection1 X Y) U.
  prove p :e rectangle_set U Y.
  claim HpXY: p :e setprod X Y.
  { exact (SepE1 (setprod X Y) (fun q => apply_fun (projection1 X Y) q :e U) p Hp). }
  claim HprojU: apply_fun (projection1 X Y) p :e U.
  { exact (SepE2 (setprod X Y) (fun q => apply_fun (projection1 X Y) q :e U) p Hp). }
  claim Happ: apply_fun (projection1 X Y) p = p 0.
  { exact (projection1_apply X Y p HpXY). }
  claim Hp0U: p 0 :e U.
  { rewrite <- Happ.
    exact HprojU. }
  claim Hp1Y: p 1 :e Y.
  { exact (ap1_Sigma X (fun _ : set => Y) p HpXY). }
	  claim Heta: p = (p 0, p 1).
	  { exact (setprod_eta X Y p HpXY). }
	  rewrite Heta.
	  exact (tuple_2_rectangle_set U Y (p 0) (p 1) Hp0U Hp1Y).
- let p. assume Hp: p :e rectangle_set U Y.
  prove p :e preimage_of (setprod X Y) (projection1 X Y) U.
  claim HpUY: p :e setprod U Y.
  { exact Hp. }
  claim Hp0U: p 0 :e U.
  { exact (ap0_Sigma U (fun _ : set => Y) p HpUY). }
  claim Hp1Y: p 1 :e Y.
  { exact (ap1_Sigma U (fun _ : set => Y) p HpUY). }
  claim Hp0X: p 0 :e X.
  { exact (HUsub (p 0) Hp0U). }
  claim HpXY: p :e setprod X Y.
  { claim Heta: p = (p 0, p 1).
    { exact (setprod_eta U Y p HpUY). }
    rewrite Heta.
    exact (tuple_2_setprod X Y (p 0) Hp0X (p 1) Hp1Y). }
  claim Hprop: apply_fun (projection1 X Y) p :e U.
  { claim Happ: apply_fun (projection1 X Y) p = p 0.
    { exact (projection1_apply X Y p HpXY). }
    rewrite Happ.
    exact Hp0U. }
  exact (SepI (setprod X Y) (fun q => apply_fun (projection1 X Y) q :e U) p HpXY Hprop).
Qed.

Theorem preimage_projection2_rectangle : forall X Y V:set,
  V c= Y ->
  preimage_of (setprod X Y) (projection2 X Y) V = rectangle_set X V.
let X Y V.
assume HVsub: V c= Y.
apply set_ext.
- let p. assume Hp: p :e preimage_of (setprod X Y) (projection2 X Y) V.
  prove p :e rectangle_set X V.
  claim HpXY: p :e setprod X Y.
  { exact (SepE1 (setprod X Y) (fun q => apply_fun (projection2 X Y) q :e V) p Hp). }
  claim HprojV: apply_fun (projection2 X Y) p :e V.
  { exact (SepE2 (setprod X Y) (fun q => apply_fun (projection2 X Y) q :e V) p Hp). }
  claim Happ: apply_fun (projection2 X Y) p = p 1.
  { exact (projection2_apply X Y p HpXY). }
  claim Hp1V: p 1 :e V.
  { rewrite <- Happ.
    exact HprojV. }
  claim Hp0X: p 0 :e X.
  { exact (ap0_Sigma X (fun _ : set => Y) p HpXY). }
	  claim Heta: p = (p 0, p 1).
	  { exact (setprod_eta X Y p HpXY). }
	  rewrite Heta.
	  exact (tuple_2_rectangle_set X V (p 0) (p 1) Hp0X Hp1V).
- let p. assume Hp: p :e rectangle_set X V.
  prove p :e preimage_of (setprod X Y) (projection2 X Y) V.
  claim HpXV: p :e setprod X V.
  { exact Hp. }
  claim Hp0X: p 0 :e X.
  { exact (ap0_Sigma X (fun _ : set => V) p HpXV). }
  claim Hp1V: p 1 :e V.
  { exact (ap1_Sigma X (fun _ : set => V) p HpXV). }
  claim Hp1Y: p 1 :e Y.
  { exact (HVsub (p 1) Hp1V). }
  claim HpXY: p :e setprod X Y.
  { claim Heta: p = (p 0, p 1).
    { exact (setprod_eta X V p HpXV). }
    rewrite Heta.
    exact (tuple_2_setprod X Y (p 0) Hp0X (p 1) Hp1Y). }
  claim Hprop: apply_fun (projection2 X Y) p :e V.
  { claim Happ: apply_fun (projection2 X Y) p = p 1.
    { exact (projection2_apply X Y p HpXY). }
    rewrite Happ.
    exact Hp1V. }
  exact (SepI (setprod X Y) (fun q => apply_fun (projection2 X Y) q :e V) p HpXY Hprop).
Qed.

(** SUSPICIOUS DEFINITION: `continuous_map` relies on `function_on` via `apply_fun`/`Eps_i`, so it enforces only preimage-openness and codomain membership, not totality of the graph; use `total_function_on` when totality is needed. **)
Definition continuous_map : set -> set -> set -> set -> set -> prop :=
  fun X Tx Y Ty f =>
    topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y /\
    forall V:set, V :e Ty -> preimage_of X f V :e Tx.

(** helper: flip_unit_interval is continuous in the unit interval topology **)
(** NOTE: placed later, after continuity infrastructure **)

(** Helper: extract topology_on X Tx from continuous_map **)
Theorem continuous_map_topology_dom : forall X Tx Y Ty f:set,
  continuous_map X Tx Y Ty f -> topology_on X Tx.
let X Tx Y Ty f.
assume H: continuous_map X Tx Y Ty f.
claim Hleft: (topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y.
{ exact (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               H). }
claim Htops: topology_on X Tx /\ topology_on Y Ty.
{ exact (andEL (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y) Hleft). }
exact (andEL (topology_on X Tx) (topology_on Y Ty) Htops).
Qed.

(** Helper: extract topology_on Y Ty from continuous_map **)
Theorem continuous_map_topology_cod : forall X Tx Y Ty f:set,
  continuous_map X Tx Y Ty f -> topology_on Y Ty.
let X Tx Y Ty f.
assume H: continuous_map X Tx Y Ty f.
claim Hleft: (topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y.
{ exact (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               H). }
claim Htops: topology_on X Tx /\ topology_on Y Ty.
{ exact (andEL (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y) Hleft). }
exact (andER (topology_on X Tx) (topology_on Y Ty) Htops).
Qed.

(** Helper: extract function_on f X Y from continuous_map **)
Theorem continuous_map_function_on : forall X Tx Y Ty f:set,
  continuous_map X Tx Y Ty f -> function_on f X Y.
let X Tx Y Ty f.
assume H: continuous_map X Tx Y Ty f.
claim Hleft: (topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y.
{ exact (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               H). }
exact (andER (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y) Hleft).
Qed.

(** Helper: extract the preimage condition from continuous_map **)
Theorem continuous_map_preimage : forall X Tx Y Ty f:set,
  continuous_map X Tx Y Ty f ->
  forall V:set, V :e Ty -> preimage_of X f V :e Tx.
let X Tx Y Ty f.
assume H: continuous_map X Tx Y Ty f.
exact (andER ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
             (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
             H).
Qed.

(** Helper: restrict the range to a subspace containing f(X) **)
Theorem continuous_map_range_restrict : forall X Tx Y Ty f Z0:set,
  continuous_map X Tx Y Ty f ->
  Z0 c= Y ->
  (forall x:set, x :e X -> apply_fun f x :e Z0) ->
  continuous_map X Tx Z0 (subspace_topology Y Ty Z0) f.
let X Tx Y Ty f Z0.
assume Hcont: continuous_map X Tx Y Ty f.
assume HZ0sub: Z0 c= Y.
assume Himg: forall x:set, x :e X -> apply_fun f x :e Z0.
set Tz0 := subspace_topology Y Ty Z0.
claim HTx: topology_on X Tx.
{ exact (continuous_map_topology_dom X Tx Y Ty f Hcont). }
claim HTy: topology_on Y Ty.
{ exact (continuous_map_topology_cod X Tx Y Ty f Hcont). }
claim HTz0: topology_on Z0 Tz0.
{ exact (subspace_topology_is_topology Y Ty Z0 HTy HZ0sub). }
claim HfunXZ0: function_on f X Z0.
{ let x. assume HxX: x :e X.
  exact (Himg x HxX). }
prove continuous_map X Tx Z0 Tz0 f.
prove topology_on X Tx /\ topology_on Z0 Tz0 /\ function_on f X Z0 /\
      forall B:set, B :e Tz0 -> preimage_of X f B :e Tx.
apply andI.
- apply andI.
  + apply andI.
    * exact HTx.
    * exact HTz0.
  + exact HfunXZ0.
- let B. assume HB: B :e Tz0.
  claim Hex: exists V :e Ty, B = V :/\: Z0.
  { exact (SepE2 (Power Z0) (fun U0:set => exists V :e Ty, U0 = V :/\: Z0) B HB). }
  apply Hex.
  let V. assume HVpair.
  claim HV: V :e Ty.
  { exact (andEL (V :e Ty) (B = V :/\: Z0) HVpair). }
  claim HB_eq: B = V :/\: Z0.
  { exact (andER (V :e Ty) (B = V :/\: Z0) HVpair). }
  claim HeqPre: preimage_of X f B = preimage_of X f V.
  { apply set_ext.
    - let x. assume Hx: x :e preimage_of X f B.
      prove x :e preimage_of X f V.
      claim HxX: x :e X.
      { exact (SepE1 X (fun u:set => apply_fun f u :e B) x Hx). }
      claim HfxB: apply_fun f x :e B.
      { exact (SepE2 X (fun u:set => apply_fun f u :e B) x Hx). }
      claim HfxVZ0: apply_fun f x :e V :/\: Z0.
      { rewrite <- HB_eq.
        exact HfxB. }
      claim HfxV: apply_fun f x :e V.
      { exact (binintersectE1 V Z0 (apply_fun f x) HfxVZ0). }
      exact (SepI X (fun u:set => apply_fun f u :e V) x HxX HfxV).
    - let x. assume Hx: x :e preimage_of X f V.
      prove x :e preimage_of X f B.
      claim HxX: x :e X.
      { exact (SepE1 X (fun u:set => apply_fun f u :e V) x Hx). }
      claim HfxV: apply_fun f x :e V.
      { exact (SepE2 X (fun u:set => apply_fun f u :e V) x Hx). }
      claim HfxZ0: apply_fun f x :e Z0.
      { exact (Himg x HxX). }
      claim HfxB: apply_fun f x :e B.
      { rewrite HB_eq.
        exact (binintersectI V Z0 (apply_fun f x) HfxV HfxZ0). }
      exact (SepI X (fun u:set => apply_fun f u :e B) x HxX HfxB). }
  rewrite HeqPre.
  exact (continuous_map_preimage X Tx Y Ty f Hcont V HV).
Qed.

(** Helper: subbasis criterion for continuity into generated_topology_from_subbasis **)
(** LATEX VERSION: If preimages of all subbasis elements are open, then f is continuous for the topology generated by the subbasis. **)
Theorem continuous_map_from_subbasis : forall X Tx Y S f:set,
  topology_on X Tx ->
  function_on f X Y ->
  subbasis_on Y S ->
  (forall s:set, s :e S -> preimage_of X f s :e Tx) ->
  continuous_map X Tx Y (generated_topology_from_subbasis Y S) f.
let X Tx Y S f.
assume HTx: topology_on X Tx.
assume Hfun: function_on f X Y.
assume HS: subbasis_on Y S.
assume HpreS: forall s:set, s :e S -> preimage_of X f s :e Tx.
set Ty := generated_topology_from_subbasis Y S.
claim HTy: topology_on Y Ty.
{ exact (topology_from_subbasis_is_topology Y S HS). }
(** Define Tpre as sets whose preimages are open. **)
set TpreFam : set := {U0 :e Power Y| preimage_of X f U0 :e Tx}.
claim HTpre: topology_on Y TpreFam.
{ claim HsubPow: TpreFam c= Power Y.
  { let U. assume HU: U :e TpreFam.
    exact (SepE1 (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) U HU). }
  claim Hempty: Empty :e TpreFam.
  { apply (SepI (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) Empty (Empty_In_Power Y)).
    rewrite (preimage_of_Empty X f).
    exact (topology_has_empty X Tx HTx). }
  claim HYin: Y :e TpreFam.
  { apply (SepI (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) Y (Self_In_Power Y)).
    rewrite (preimage_of_whole X Y f Hfun).
    exact (topology_has_X X Tx HTx). }
  claim Hunion: forall UFam :e Power TpreFam, Union UFam :e TpreFam.
  { let UFam. assume HUFamPow: UFam :e Power TpreFam.
    claim HUFsub: UFam c= TpreFam.
    { exact (PowerE TpreFam UFam HUFamPow). }
    claim HUnionPowY: Union UFam :e Power Y.
    { apply PowerI.
      let y. assume Hy: y :e Union UFam.
      apply (UnionE_impred UFam y Hy).
      let U. assume HyU: y :e U. assume HUUF: U :e UFam.
      claim HUTpre: U :e TpreFam.
      { exact (HUFsub U HUUF). }
      claim HUPowY: U :e Power Y.
      { exact (SepE1 (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) U HUTpre). }
      exact (PowerE Y U HUPowY y HyU). }
    apply (SepI (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) (Union UFam) HUnionPowY).
    rewrite (preimage_of_Union X f UFam).
    set PreFam : set := {preimage_of X f U|U :e UFam}.
    claim HPreFamSub: PreFam c= Tx.
    { let W. assume HW: W :e PreFam.
      apply (ReplE_impred UFam (fun U0:set => preimage_of X f U0) W HW (W :e Tx)).
      let U. assume HUUF: U :e UFam. assume HWU: W = preimage_of X f U.
      claim HUTpre: U :e TpreFam.
      { exact (HUFsub U HUUF). }
      claim HpreU: preimage_of X f U :e Tx.
      { exact (SepE2 (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) U HUTpre). }
      rewrite HWU.
      exact HpreU. }
    exact (topology_union_closed X Tx PreFam HTx HPreFamSub). }
  claim Hinter: forall U :e TpreFam, forall V :e TpreFam, U :/\: V :e TpreFam.
  { let U. assume HU: U :e TpreFam.
    let V. assume HV: V :e TpreFam.
    claim HUPow: U :e Power Y.
    { exact (SepE1 (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) U HU). }
    claim HVPow: V :e Power Y.
    { exact (SepE1 (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) V HV). }
    claim HUVPow: U :/\: V :e Power Y.
    { exact (binintersect_Power Y U V HUPow HVPow). }
    apply (SepI (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) (U :/\: V) HUVPow).
    rewrite (preimage_of_binintersect X f U V).
    claim HpreU: preimage_of X f U :e Tx.
    { exact (SepE2 (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) U HU). }
    claim HpreV: preimage_of X f V :e Tx.
    { exact (SepE2 (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) V HV). }
    exact (topology_binintersect_closed X Tx (preimage_of X f U) (preimage_of X f V) HTx HpreU HpreV). }
  claim HTpre_def: topology_on Y TpreFam =
    (TpreFam c= Power Y
     /\ Empty :e TpreFam
     /\ Y :e TpreFam
     /\ (forall UFam :e Power TpreFam, Union UFam :e TpreFam)
     /\ (forall U :e TpreFam, forall V :e TpreFam, U :/\: V :e TpreFam)).
  { reflexivity. }
  rewrite HTpre_def.
  apply andI.
  - apply andI.
    + apply andI.
      * apply andI.
        - exact HsubPow.
        - exact Hempty.
      * exact HYin.
    + exact Hunion.
  - exact Hinter. }
(** S is contained in Tpre, so generated topology is contained in Tpre by minimality. **)
claim HSsub: S c= TpreFam.
{ let s. assume Hs: s :e S.
  prove s :e TpreFam.
  claim HSsubPow: S c= Power Y.
  { exact (andEL (S c= Power Y) (Union S = Y) HS). }
  claim HsPowY: s :e Power Y.
  { exact (HSsubPow s Hs). }
  exact (SepI (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) s HsPowY (HpreS s Hs)). }
claim Hmin: Ty c= TpreFam.
{ exact (topology_generated_by_basis_is_minimal Y S TpreFam HS HTpre HSsub). }
prove continuous_map X Tx Y Ty f.
prove topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y /\ forall V:set, V :e Ty -> preimage_of X f V :e Tx.
apply andI.
- prove (topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y).
  apply andI.
  + prove topology_on X Tx /\ topology_on Y Ty.
    apply andI.
    * exact HTx.
    * exact HTy.
  + exact Hfun.
- let V. assume HV: V :e Ty.
  prove preimage_of X f V :e Tx.
  claim HVTpre: V :e TpreFam.
  { exact (Hmin V HV). }
  exact (SepE2 (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) V HVTpre).
Qed.

(** Helper: continuous_map variant with totality of the graph **)
Definition continuous_map_total : set -> set -> set -> set -> set -> prop :=
  fun X Tx Y Ty f =>
    topology_on X Tx /\ topology_on Y Ty /\ total_function_on f X Y /\
    forall V:set, V :e Ty -> preimage_of X f V :e Tx.

(** Helper: extract topology_on X Tx from continuous_map_total **)
Theorem continuous_map_total_topology_dom : forall X Tx Y Ty f:set,
  continuous_map_total X Tx Y Ty f -> topology_on X Tx.
let X Tx Y Ty f.
assume H: continuous_map_total X Tx Y Ty f.
claim Hleft: (topology_on X Tx /\ topology_on Y Ty) /\ total_function_on f X Y.
{ exact (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ total_function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               H). }
claim Htops: topology_on X Tx /\ topology_on Y Ty.
{ exact (andEL (topology_on X Tx /\ topology_on Y Ty) (total_function_on f X Y) Hleft). }
exact (andEL (topology_on X Tx) (topology_on Y Ty) Htops).
Qed.

(** Helper: extract topology_on Y Ty from continuous_map_total **)
Theorem continuous_map_total_topology_cod : forall X Tx Y Ty f:set,
  continuous_map_total X Tx Y Ty f -> topology_on Y Ty.
let X Tx Y Ty f.
assume H: continuous_map_total X Tx Y Ty f.
claim Hleft: (topology_on X Tx /\ topology_on Y Ty) /\ total_function_on f X Y.
{ exact (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ total_function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               H). }
claim Htops: topology_on X Tx /\ topology_on Y Ty.
{ exact (andEL (topology_on X Tx /\ topology_on Y Ty) (total_function_on f X Y) Hleft). }
exact (andER (topology_on X Tx) (topology_on Y Ty) Htops).
Qed.

(** Helper: extract total_function_on f X Y from continuous_map_total **)
Theorem continuous_map_total_total_function_on : forall X Tx Y Ty f:set,
  continuous_map_total X Tx Y Ty f -> total_function_on f X Y.
let X Tx Y Ty f.
assume H: continuous_map_total X Tx Y Ty f.
claim Hleft: (topology_on X Tx /\ topology_on Y Ty) /\ total_function_on f X Y.
{ exact (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ total_function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               H). }
exact (andER (topology_on X Tx /\ topology_on Y Ty) (total_function_on f X Y) Hleft).
Qed.

(** Helper: extract the preimage condition from continuous_map_total **)
Theorem continuous_map_total_preimage : forall X Tx Y Ty f:set,
  continuous_map_total X Tx Y Ty f ->
  forall V:set, V :e Ty -> preimage_of X f V :e Tx.
let X Tx Y Ty f.
assume H: continuous_map_total X Tx Y Ty f.
exact (andER ((topology_on X Tx /\ topology_on Y Ty) /\ total_function_on f X Y)
             (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
             H).
Qed.

(** Helper: continuous_map_total implies continuous_map **)
Theorem continuous_map_total_imp : forall X Tx Y Ty f:set,
  continuous_map_total X Tx Y Ty f -> continuous_map X Tx Y Ty f.
let X Tx Y Ty f.
assume H: continuous_map_total X Tx Y Ty f.
prove continuous_map X Tx Y Ty f.
prove ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y) /\
  (forall V:set, V :e Ty -> preimage_of X f V :e Tx).
claim Hcore: ((topology_on X Tx /\ topology_on Y Ty) /\ total_function_on f X Y) /\
  (forall V:set, V :e Ty -> preimage_of X f V :e Tx).
{ exact H. }
claim Hleft: (topology_on X Tx /\ topology_on Y Ty) /\ total_function_on f X Y.
{ exact (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ total_function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx) Hcore). }
claim Hright: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
{ exact (andER ((topology_on X Tx /\ topology_on Y Ty) /\ total_function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx) Hcore). }
claim Htops: topology_on X Tx /\ topology_on Y Ty.
{ exact (andEL (topology_on X Tx /\ topology_on Y Ty) (total_function_on f X Y) Hleft). }
claim Htot: total_function_on f X Y.
{ exact (andER (topology_on X Tx /\ topology_on Y Ty) (total_function_on f X Y) Hleft). }
claim Hfun: function_on f X Y.
{ exact (total_function_on_function_on f X Y Htot). }
apply andI.
- apply andI.
  + exact Htops.
  + exact Hfun.
- exact Hright.
Qed.

(** Helper: constant maps are continuous **)
Theorem const_fun_continuous : forall X Tx Y Ty x:set,
  topology_on X Tx -> topology_on Y Ty -> x :e Y ->
  continuous_map X Tx Y Ty (const_fun X x).
let X Tx Y Ty x.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
assume HxY: x :e Y.
prove continuous_map X Tx Y Ty (const_fun X x).
prove topology_on X Tx /\ topology_on Y Ty /\ function_on (const_fun X x) X Y /\
      forall V:set, V :e Ty -> preimage_of X (const_fun X x) V :e Tx.
apply andI.
- (** left: (topology_on X Tx /\ topology_on Y Ty) /\ function_on ... **)
  apply andI.
  + apply andI.
    * exact HTx.
    * exact HTy.
  + (** function_on **)
    let a. assume HaX: a :e X.
    prove apply_fun (const_fun X x) a :e Y.
    claim Happ: apply_fun (const_fun X x) a = x.
    { exact (const_fun_apply X x a HaX). }
    rewrite Happ.
    exact HxY.
- (** preimage condition **)
  let V. assume HV: V :e Ty.
  claim Hcases: x :e V \/ x /:e V.
  { exact (xm (x :e V)). }
  apply (Hcases (preimage_of X (const_fun X x) V :e Tx)).
  + (** case x  V: preimage = X **)
    assume HxV: x :e V.
    claim Heq: preimage_of X (const_fun X x) V = X.
    { apply set_ext.
      - let a. assume Ha: a :e preimage_of X (const_fun X x) V.
        prove a :e X.
        apply (SepE X (fun u => apply_fun (const_fun X x) u :e V) a Ha).
        assume HaX. assume _. exact HaX.
      - let a. assume HaX: a :e X.
        prove a :e preimage_of X (const_fun X x) V.
        prove a :e {u :e X | apply_fun (const_fun X x) u :e V}.
        apply (SepI X (fun u => apply_fun (const_fun X x) u :e V) a HaX).
        claim Happ: apply_fun (const_fun X x) a = x.
        { exact (const_fun_apply X x a HaX). }
        rewrite Happ.
        exact HxV.
    }
    rewrite Heq.
    exact (topology_has_X X Tx HTx).
  + (** case x  V: preimage = Empty **)
    assume HxVn: x /:e V.
    claim Heq: preimage_of X (const_fun X x) V = Empty.
    { apply set_ext.
      - let a. assume Ha: a :e preimage_of X (const_fun X x) V.
        prove a :e Empty.
        apply FalseE.
        apply (SepE X (fun u => apply_fun (const_fun X x) u :e V) a Ha).
        assume HaX. assume Hav.
        claim Happ: apply_fun (const_fun X x) a = x.
        { exact (const_fun_apply X x a HaX). }
        claim HxV: x :e V.
        { rewrite <- Happ. exact Hav. }
        exact (HxVn HxV).
      - let a. assume HaE: a :e Empty.
        prove a :e preimage_of X (const_fun X x) V.
        apply FalseE.
        exact (EmptyE a HaE).
    }
    rewrite Heq.
    exact (topology_has_empty X Tx HTx).
Qed.

(** Helper: constant maps are continuous (total variant) **)
Theorem const_fun_continuous_total : forall X Tx Y Ty x:set,
  topology_on X Tx -> topology_on Y Ty -> x :e Y ->
  continuous_map_total X Tx Y Ty (const_fun X x).
let X Tx Y Ty x.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
assume HxY: x :e Y.
prove continuous_map_total X Tx Y Ty (const_fun X x).
prove ((topology_on X Tx /\ topology_on Y Ty) /\ total_function_on (const_fun X x) X Y) /\
  forall V:set, V :e Ty -> preimage_of X (const_fun X x) V :e Tx.
apply andI.
- apply andI.
  + apply andI.
    * exact HTx.
    * exact HTy.
  + exact (const_fun_total_function_on X Y x HxY).
- claim Hc: continuous_map X Tx Y Ty (const_fun X x).
  { exact (const_fun_continuous X Tx Y Ty x HTx HTy HxY). }
  exact (andER ((topology_on X Tx /\ topology_on Y Ty) /\ function_on (const_fun X x) X Y)
               (forall V:set, V :e Ty -> preimage_of X (const_fun X x) V :e Tx)
               Hc).
Qed.

(** Helper: continuity preserves closed sets **)
Theorem continuous_preserves_closed : forall X Tx Y Ty f:set,
  continuous_map X Tx Y Ty f ->
  forall C:set, closed_in Y Ty C -> closed_in X Tx (preimage_of X f C).
let X Tx Y Ty f.
assume Hcont: continuous_map X Tx Y Ty f.
claim Hpreimg: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
{ exact (andER ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx) Hcont). }
claim Hleft: (topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y.
{ exact (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx) Hcont). }
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (topology_on Y Ty)
               (andEL (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y) Hleft)). }
claim HTy: topology_on Y Ty.
{ exact (andER (topology_on X Tx) (topology_on Y Ty)
               (andEL (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y) Hleft)). }
claim Hf: function_on f X Y.
{ exact (andER (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y) Hleft). }
let C. assume HC: closed_in Y Ty C.
claim Hright: C c= Y /\ exists U :e Ty, C = Y :\: U.
{ exact (andER (topology_on Y Ty) (C c= Y /\ exists U :e Ty, C = Y :\: U) HC). }
claim HCsub: C c= Y.
{ exact (andEL (C c= Y) (exists U :e Ty, C = Y :\: U) Hright). }
claim HU: exists U :e Ty, C = Y :\: U.
{ exact (andER (C c= Y) (exists U :e Ty, C = Y :\: U) Hright). }
apply HU.
let U. assume HU.
apply HU.
assume HUTy: U :e Ty.
assume HCeq: C = Y :\: U.
prove closed_in X Tx (preimage_of X f C).
prove topology_on X Tx /\ (preimage_of X f C c= X /\ exists V :e Tx, preimage_of X f C = X :\: V).
apply andI.
- exact HTx.
- prove preimage_of X f C c= X /\ exists V :e Tx, preimage_of X f C = X :\: V.
  apply andI.
  + prove preimage_of X f C c= X.
    let x. assume Hx: x :e preimage_of X f C.
    prove x :e X.
    exact (SepE1 X (fun x => apply_fun f x :e C) x Hx).
  + prove exists V :e Tx, preimage_of X f C = X :\: V.
    witness (preimage_of X f U).
    apply andI.
  + exact (Hpreimg U HUTy).
  + prove preimage_of X f C = X :\: preimage_of X f U.
    rewrite HCeq.
    prove preimage_of X f (Y :\: U) = X :\: preimage_of X f U.
    apply set_ext.
    * let x. assume Hx: x :e preimage_of X f (Y :\: U).
      prove x :e X :\: preimage_of X f U.
      apply (SepE X (fun x => apply_fun f x :e Y :\: U) x Hx).
      assume HxX: x :e X.
      assume Hfx: apply_fun f x :e Y :\: U.
      apply (setminusE Y U (apply_fun f x) Hfx).
      assume HfxY: apply_fun f x :e Y.
      assume HfxU: apply_fun f x /:e U.
      apply setminusI.
      { exact HxX. }
      { prove x /:e preimage_of X f U.
        assume Hxpre: x :e preimage_of X f U.
        apply (SepE X (fun x => apply_fun f x :e U) x Hxpre).
        assume _. assume HfxU2: apply_fun f x :e U.
        exact (HfxU HfxU2). }
    * let x. assume Hx: x :e X :\: preimage_of X f U.
      prove x :e preimage_of X f (Y :\: U).
      apply (setminusE X (preimage_of X f U) x Hx).
      assume HxX: x :e X.
      assume Hxpre: x /:e preimage_of X f U.
      prove x :e {x :e X | apply_fun f x :e Y :\: U}.
      apply SepI.
      { exact HxX. }
      { prove apply_fun f x :e Y :\: U.
        apply setminusI.
        { exact (Hf x HxX). }
        { prove apply_fun f x /:e U.
          assume HfxU: apply_fun f x :e U.
          claim Hxpre2: x :e preimage_of X f U.
          { exact (SepI X (fun x => apply_fun f x :e U) x HxX HfxU). }
          exact (Hxpre Hxpre2). } }
Qed.

(** Helper: continuity local neighborhood characterization **)
Theorem continuous_local_neighborhood : forall X Tx Y Ty f:set,
  topology_on X Tx -> topology_on Y Ty -> function_on f X Y ->
  (forall V:set, V :e Ty -> preimage_of X f V :e Tx) ->
  forall x:set, x :e X ->
    forall V:set, V :e Ty -> apply_fun f x :e V ->
      exists U:set, U :e Tx /\ x :e U /\ forall u:set, u :e U -> apply_fun f u :e V.
let X Tx Y Ty f.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
assume Hf: function_on f X Y.
assume Hcont: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
let x. assume Hx: x :e X.
let V. assume HV: V :e Ty.
assume Hfx: apply_fun f x :e V.
witness (preimage_of X f V).
apply and3I.
- exact (Hcont V HV).
- prove x :e preimage_of X f V.
  prove x :e {x :e X | apply_fun f x :e V}.
  exact (SepI X (fun x => apply_fun f x :e V) x Hx Hfx).
- let u. assume Hu: u :e preimage_of X f V.
  prove apply_fun f u :e V.
  apply (SepE X (fun x => apply_fun f x :e V) u Hu).
  assume _. assume H. exact H.
Qed.

(** continuity at a point **)
(** LATEX VERSION: f is continuous at x if for every neighborhood V of f(x), there exists neighborhood U of x with f(U)V. **)
(** FIXED: Formalized using open-set neighborhood criterion in the standard topology on R. **)
Definition continuous_at : set -> set -> prop := fun f x =>
  function_on f R R /\ x :e R /\
  forall V:set, V :e R_standard_topology -> apply_fun f x :e V ->
    exists U:set, U :e R_standard_topology /\ x :e U /\ forall u:set, u :e U -> apply_fun f u :e V.

(** from 18 Theorem 18.1: equivalent formulations of continuity **) 
(** LATEX VERSION: Equivalent characterizations of continuity: open-preimage, closed-preimage, neighborhood criterion. **)
Theorem continuity_equiv_forms : forall X Tx Y Ty f:set,
  topology_on X Tx -> topology_on Y Ty ->
  (continuous_map X Tx Y Ty f <->
    function_on f X Y /\
    (forall V:set, V :e Ty -> preimage_of X f V :e Tx) /\
    (forall C:set, closed_in Y Ty C -> closed_in X Tx (preimage_of X f C)) /\
    (forall x:set, x :e X ->
       forall V:set, V :e Ty -> apply_fun f x :e V ->
         exists U:set, U :e Tx /\ x :e U /\ forall u:set, u :e U -> apply_fun f u :e V)).
let X Tx Y Ty f.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove continuous_map X Tx Y Ty f <->
    function_on f X Y /\
    (forall V:set, V :e Ty -> preimage_of X f V :e Tx) /\
    (forall C:set, closed_in Y Ty C -> closed_in X Tx (preimage_of X f C)) /\
    (forall x:set, x :e X ->
       forall V:set, V :e Ty -> apply_fun f x :e V ->
         exists U:set, U :e Tx /\ x :e U /\ forall u:set, u :e U -> apply_fun f u :e V).
apply iffI.
- (** Forward direction: continuous_map implies all three conditions **)
  assume Hf: continuous_map X Tx Y Ty f.
  prove function_on f X Y /\
        (forall V:set, V :e Ty -> preimage_of X f V :e Tx) /\
        (forall C:set, closed_in Y Ty C -> closed_in X Tx (preimage_of X f C)) /\
        (forall x:set, x :e X ->
           forall V:set, V :e Ty -> apply_fun f x :e V ->
             exists U:set, U :e Tx /\ x :e U /\ forall u:set, u :e U -> apply_fun f u :e V).
  (** Extract components from continuous_map definition **)
  claim Hpreimage: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
  { exact (andER (topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y)
                 (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
                 Hf). }
  claim Hfun: function_on f X Y.
  { exact (andER (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y)
                 (andEL (topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y)
                        (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
                        Hf)). }
  (** Build (((Hfun /\ Hpreimage) /\ closed-preimage) /\ neighborhood) **)
  apply andI.
  - apply andI.
    + apply andI.
      * exact Hfun.
      * exact Hpreimage.
    + exact (continuous_preserves_closed X Tx Y Ty f Hf).
  - exact (continuous_local_neighborhood X Tx Y Ty f HTx HTy Hfun Hpreimage).
- (** Backward direction: three conditions imply continuous_map **)
  assume Hconds.
  prove continuous_map X Tx Y Ty f.
	  (** Extract function_on and preimage condition from Hconds, a left-associative conjunction: (((A /\ B) /\ C) /\ D). **)
  claim Habc:
    (function_on f X Y /\ (forall V:set, V :e Ty -> preimage_of X f V :e Tx)) /\
    (forall C:set, closed_in Y Ty C -> closed_in X Tx (preimage_of X f C)).
  { exact (andEL (((function_on f X Y /\ (forall V:set, V :e Ty -> preimage_of X f V :e Tx)) /\
                   (forall C:set, closed_in Y Ty C -> closed_in X Tx (preimage_of X f C))))
                 (forall x:set, x :e X ->
                    forall V:set, V :e Ty -> apply_fun f x :e V ->
                      exists U:set, U :e Tx /\ x :e U /\ forall u:set, u :e U -> apply_fun f u :e V)
                 Hconds). }
  claim Hab:
    function_on f X Y /\ (forall V:set, V :e Ty -> preimage_of X f V :e Tx).
  { exact (andEL (function_on f X Y /\ (forall V:set, V :e Ty -> preimage_of X f V :e Tx))
                 (forall C:set, closed_in Y Ty C -> closed_in X Tx (preimage_of X f C))
                 Habc). }
  claim Hfun: function_on f X Y.
  { exact (andEL (function_on f X Y) (forall V:set, V :e Ty -> preimage_of X f V :e Tx) Hab). }
  claim Hpreimage: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
  { exact (andER (function_on f X Y) (forall V:set, V :e Ty -> preimage_of X f V :e Tx) Hab). }
  (** Build continuous_map from components **)
  prove topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y /\
        (forall V:set, V :e Ty -> preimage_of X f V :e Tx).
  apply andI.
  + apply andI.
    * apply andI.
      - exact HTx.
      - exact HTy.
    * exact Hfun.
  + exact Hpreimage.
Qed.

(** from 18: identity map is continuous **) 
(** LATEX VERSION: Identity map on any space is continuous. **)
(** FIXED: Identity function must use ordered pairs (tuple notation), not UPair. **)
Theorem identity_continuous : forall X Tx:set,
  topology_on X Tx ->
  let id := {(x,x)|x :e X} in
  continuous_map X Tx X Tx id.
let X Tx.
assume HTx: topology_on X Tx.
prove let id := {(x,x)|x :e X} in continuous_map X Tx X Tx id.
set id := {(x,x)|x :e X}.
prove continuous_map X Tx X Tx id.
  (** Strategy: unfold continuous_map; identity is function_on and preimage_of X id V = V for V :e Tx. **)
  (** Unfold: continuous_map = topology_on X Tx /\ topology_on X Tx /\ function_on id X X /\ (forall V, V :e Tx -> preimage_of X id V :e Tx), left-associative. **)
prove topology_on X Tx /\ topology_on X Tx /\ function_on id X X /\
  forall V:set, V :e Tx -> preimage_of X id V :e Tx.
(** Build the conjunction left-to-right **)
claim Hpart1: topology_on X Tx /\ topology_on X Tx.
{ apply andI. exact HTx. exact HTx. }
claim Hpart2: (topology_on X Tx /\ topology_on X Tx) /\ function_on id X X.
{ apply andI.
  - exact Hpart1.
  - (** function_on id X X **)
    prove function_on id X X.
    prove forall x:set, x :e X -> apply_fun id x :e X.
    let x. assume Hx: x :e X.
    prove apply_fun id x :e X.
    (** For x :e X, apply_fun id x = x and hence apply_fun id x :e X. **)
    claim Hid_x: apply_fun id x = x.
    { exact (identity_function_apply X x Hx). }
    rewrite Hid_x.
    exact Hx. }
apply andI.
- exact Hpart2.
- (** forall V:set, V :e Tx -> preimage_of X id V :e Tx **)
  let V. assume HV: V :e Tx.
  prove preimage_of X id V :e Tx.
  (** preimage_of X id V = {x :e X | apply_fun id x :e V} = {x :e X | x :e V} = V (when V c= X) **)
  claim HVsub: V c= X.
  { exact (topology_elem_subset X Tx V HTx HV). }
  claim Hpreimg_eq: preimage_of X id V = V.
  { apply set_ext.
    - let x. assume Hx: x :e preimage_of X id V.
      prove x :e V.
      claim HxX: x :e X.
      { exact (SepE1 X (fun y => apply_fun id y :e V) x Hx). }
      claim Hidx_in_V: apply_fun id x :e V.
      { exact (SepE2 X (fun y => apply_fun id y :e V) x Hx). }
      claim Hidx_eq: apply_fun id x = x.
      { exact (identity_function_apply X x HxX). }
      rewrite <- Hidx_eq.
      exact Hidx_in_V.
    - let x. assume Hx: x :e V.
      prove x :e preimage_of X id V.
      prove x :e {y :e X | apply_fun id y :e V}.
      claim HxX: x :e X.
      { exact (HVsub x Hx). }
      apply SepI.
      + exact HxX.
      + prove apply_fun id x :e V.
        claim Hidx_eq: apply_fun id x = x.
        { exact (identity_function_apply X x HxX). }
        rewrite Hidx_eq.
        exact Hx. }
  rewrite Hpreimg_eq.
  exact HV.
Qed.

 (** from 18: composition of continuous maps is continuous **)
 (** LATEX VERSION: Composition of continuous functions remains continuous. **)
 (** FIXED: Function composition must use ordered pairs (tuple notation), not UPair. **)
Definition compose_fun : set -> set -> set -> set := fun X f g =>
  {(x, apply_fun g (apply_fun f x))|x :e X}.

(** Helper: compose_fun has domain subset X **)
Theorem graph_domain_subset_compose_fun : forall X f g:set,
  graph_domain_subset (compose_fun X f g) X.
let X f g.
exact (graph_domain_subset_graph X (fun x0:set => apply_fun g (apply_fun f x0))).
Qed.

(** Helper: compose_fun is functional **)
Theorem functional_graph_compose_fun : forall X f g:set,
  functional_graph (compose_fun X f g).
let X f g.
exact (functional_graph_graph X (fun x0:set => apply_fun g (apply_fun f x0))).
Qed.

(** Helper: compose_fun maps X into Z if f maps X into Y and g maps Y into Z **)
Theorem function_on_compose_fun : forall X Y Z f g:set,
  function_on f X Y ->
  function_on g Y Z ->
  function_on (compose_fun X f g) X Z.
let X Y Z f g.
assume Hf: function_on f X Y.
assume Hg: function_on g Y Z.
let x. assume HxX: x :e X.
prove apply_fun (compose_fun X f g) x :e Z.
claim HfxY: apply_fun f x :e Y.
{ exact (Hf x HxX). }
claim HgfxZ: apply_fun g (apply_fun f x) :e Z.
{ exact (Hg (apply_fun f x) HfxY). }
claim Hpair: (x, apply_fun g (apply_fun f x)) :e compose_fun X f g.
{ exact (ReplI X (fun x0:set => (x0, apply_fun g (apply_fun f x0))) x HxX). }
claim Hfuncomp: functional_graph (compose_fun X f g).
{ exact (functional_graph_compose_fun X f g). }
claim Happ: apply_fun (compose_fun X f g) x = apply_fun g (apply_fun f x).
{ exact (functional_graph_apply_fun_eq (compose_fun X f g) x (apply_fun g (apply_fun f x)) Hfuncomp Hpair). }
rewrite Happ.
exact HgfxZ.
Qed.

(** Helper: compose_fun is total_function_on under function_on assumptions **)
Theorem total_function_on_compose_fun : forall X Y Z f g:set,
  function_on f X Y ->
  function_on g Y Z ->
  total_function_on (compose_fun X f g) X Z.
let X Y Z f g.
assume Hf: function_on f X Y.
assume Hg: function_on g Y Z.
prove function_on (compose_fun X f g) X Z /\
  forall x:set, x :e X -> exists y:set, y :e Z /\ (x,y) :e compose_fun X f g.
apply andI.
- exact (function_on_compose_fun X Y Z f g Hf Hg).
- let x. assume HxX: x :e X.
  prove exists y:set, y :e Z /\ (x,y) :e compose_fun X f g.
  witness (apply_fun g (apply_fun f x)).
  apply andI.
  * claim HfxY: apply_fun f x :e Y.
    { exact (Hf x HxX). }
    exact (Hg (apply_fun f x) HfxY).
  * exact (ReplI X (fun x0:set => (x0, apply_fun g (apply_fun f x0))) x HxX).
Qed.

(** Helper: apply_fun on composed functions **)
Theorem compose_fun_apply : forall X f g x:set,
  x :e X -> apply_fun (compose_fun X f g) x = apply_fun g (apply_fun f x).
let X f g x. assume Hx.
prove apply_fun (compose_fun X f g) x = apply_fun g (apply_fun f x).
prove apply_fun {(y, apply_fun g (apply_fun f y)) | y :e X} x = apply_fun g (apply_fun f x).
prove Eps_i (fun z => (x, z) :e {(y, apply_fun g (apply_fun f y)) | y :e X}) = apply_fun g (apply_fun f x).
claim H1: (x, apply_fun g (apply_fun f x)) :e {(y, apply_fun g (apply_fun f y)) | y :e X}.
{ exact (ReplI X (fun y => (y, apply_fun g (apply_fun f y))) x Hx). }
claim H2: (x, Eps_i (fun z => (x, z) :e {(y, apply_fun g (apply_fun f y)) | y :e X})) :e {(y, apply_fun g (apply_fun f y)) | y :e X}.
{ exact (Eps_i_ax (fun z => (x, z) :e {(y, apply_fun g (apply_fun f y)) | y :e X}) (apply_fun g (apply_fun f x)) H1). }
apply (ReplE_impred X (fun y => (y, apply_fun g (apply_fun f y))) (x, Eps_i (fun z => (x, z) :e {(y, apply_fun g (apply_fun f y)) | y :e X})) H2).
let y.
assume Hy: y :e X.
assume Heq: (x, Eps_i (fun z => (x, z) :e {(y0, apply_fun g (apply_fun f y0)) | y0 :e X})) = (y, apply_fun g (apply_fun f y)).
claim Hx_eq: x = y.
{ rewrite <- (tuple_2_0_eq x (Eps_i (fun z => (x, z) :e {(y0, apply_fun g (apply_fun f y0)) | y0 :e X}))).
  rewrite <- (tuple_2_0_eq y (apply_fun g (apply_fun f y))).
  rewrite Heq.
  reflexivity. }
claim Hz_eq: Eps_i (fun z => (x, z) :e {(y0, apply_fun g (apply_fun f y0)) | y0 :e X}) = apply_fun g (apply_fun f y).
{ rewrite <- (tuple_2_1_eq x (Eps_i (fun z => (x, z) :e {(y0, apply_fun g (apply_fun f y0)) | y0 :e X}))).
  rewrite <- (tuple_2_1_eq y (apply_fun g (apply_fun f y))).
  rewrite Heq.
  reflexivity. }
rewrite Hz_eq.
rewrite <- Hx_eq.
reflexivity.
Qed.

(** Helper: preimage composition under function_on assumption **)
Theorem preimage_compose_fun : forall X Y f g W:set,
  function_on f X Y ->
  preimage_of X (compose_fun X f g) W = preimage_of X f (preimage_of Y g W).
let X Y f g W.
assume Hfun: function_on f X Y.
apply set_ext.
- let x. assume HxL: x :e preimage_of X (compose_fun X f g) W.
  prove x :e preimage_of X f (preimage_of Y g W).
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0:set => apply_fun (compose_fun X f g) x0 :e W) x HxL). }
  claim HxW: apply_fun (compose_fun X f g) x :e W.
  { exact (SepE2 X (fun x0:set => apply_fun (compose_fun X f g) x0 :e W) x HxL). }
  claim Hcomp: apply_fun (compose_fun X f g) x = apply_fun g (apply_fun f x).
  { exact (compose_fun_apply X f g x HxX). }
  claim HfxY: apply_fun f x :e Y.
  { exact (Hfun x HxX). }
  prove x :e {x0 :e X | apply_fun f x0 :e preimage_of Y g W}.
  claim HfxInPre: apply_fun f x :e preimage_of Y g W.
  { prove apply_fun f x :e {y :e Y | apply_fun g y :e W}.
    claim HgfxW: apply_fun g (apply_fun f x) :e W.
    { rewrite <- Hcomp.
      exact HxW. }
    exact (SepI Y (fun y0:set => apply_fun g y0 :e W) (apply_fun f x) HfxY HgfxW). }
  exact (SepI X (fun x0:set => apply_fun f x0 :e preimage_of Y g W) x HxX HfxInPre).
- let x. assume HxR: x :e preimage_of X f (preimage_of Y g W).
  prove x :e preimage_of X (compose_fun X f g) W.
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0:set => apply_fun f x0 :e preimage_of Y g W) x HxR). }
  claim HfxPre: apply_fun f x :e preimage_of Y g W.
  { exact (SepE2 X (fun x0:set => apply_fun f x0 :e preimage_of Y g W) x HxR). }
  claim HfxY: apply_fun f x :e Y.
  { exact (SepE1 Y (fun y0:set => apply_fun g y0 :e W) (apply_fun f x) HfxPre). }
  claim HgW: apply_fun g (apply_fun f x) :e W.
  { exact (SepE2 Y (fun y0:set => apply_fun g y0 :e W) (apply_fun f x) HfxPre). }
  claim Hcomp: apply_fun (compose_fun X f g) x = apply_fun g (apply_fun f x).
  { exact (compose_fun_apply X f g x HxX). }
  claim HcompW: apply_fun (compose_fun X f g) x :e W.
  { rewrite Hcomp.
    exact HgW. }
  exact (SepI X (fun x0:set => apply_fun (compose_fun X f g) x0 :e W) x HxX HcompW).
Qed.

 Theorem composition_continuous : forall X Tx Y Ty Z Tz f g:set,
   continuous_map X Tx Y Ty f ->
   continuous_map Y Ty Z Tz g ->
   continuous_map X Tx Z Tz (compose_fun X f g).
let X Tx Y Ty Z Tz f g.
assume Hf: continuous_map X Tx Y Ty f.
assume Hg: continuous_map Y Ty Z Tz g.
prove continuous_map X Tx Z Tz (compose_fun X f g).
set gf := compose_fun X f g.
  (** Strategy: show gf continuous by rewriting preimages: (gf)(W) = f(g(W)). **)
(** Extract components from continuous_map definitions **)
(** Hf: topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y /\ (forall V...) **)
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (topology_on Y Ty)
          (andEL (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y)
            (andEL (topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y)
                   (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
                   Hf))). }
claim HTy_from_f: topology_on Y Ty.
{ exact (andER (topology_on X Tx) (topology_on Y Ty)
          (andEL (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y)
            (andEL (topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y)
                   (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
                   Hf))). }
claim Hfun_f: function_on f X Y.
{ exact (andER (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y)
          (andEL (topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y)
                 (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
                 Hf)). }
claim Hpreimg_f: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
{ exact (andER (topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               Hf). }
(** Hg: topology_on Y Ty /\ topology_on Z Tz /\ function_on g Y Z /\ (forall W...) **)
claim HTy: topology_on Y Ty.
{ exact (andEL (topology_on Y Ty) (topology_on Z Tz)
          (andEL (topology_on Y Ty /\ topology_on Z Tz) (function_on g Y Z)
            (andEL (topology_on Y Ty /\ topology_on Z Tz /\ function_on g Y Z)
                   (forall W:set, W :e Tz -> preimage_of Y g W :e Ty)
                   Hg))). }
claim HTz: topology_on Z Tz.
{ exact (andER (topology_on Y Ty) (topology_on Z Tz)
          (andEL (topology_on Y Ty /\ topology_on Z Tz) (function_on g Y Z)
            (andEL (topology_on Y Ty /\ topology_on Z Tz /\ function_on g Y Z)
                   (forall W:set, W :e Tz -> preimage_of Y g W :e Ty)
                   Hg))). }
claim Hfun_g: function_on g Y Z.
{ exact (andER (topology_on Y Ty /\ topology_on Z Tz) (function_on g Y Z)
          (andEL (topology_on Y Ty /\ topology_on Z Tz /\ function_on g Y Z)
                 (forall W:set, W :e Tz -> preimage_of Y g W :e Ty)
                 Hg)). }
claim Hpreimg_g: forall W:set, W :e Tz -> preimage_of Y g W :e Ty.
{ exact (andER (topology_on Y Ty /\ topology_on Z Tz /\ function_on g Y Z)
               (forall W:set, W :e Tz -> preimage_of Y g W :e Ty)
               Hg). }
(** Show gf = gf is continuous **)
(** Need: topology_on X Tx /\ topology_on Z Tz /\ function_on gf X Z /\ (forall W:set, W :e Tz -> preimage_of X gf W :e Tx) **)
(** Build the conjunction left-to-right due to left associativity **)
prove topology_on X Tx /\ topology_on Z Tz /\ function_on gf X Z /\
  (forall W:set, W :e Tz -> preimage_of X gf W :e Tx).
claim Hpart1: topology_on X Tx /\ topology_on Z Tz.
{ apply andI. exact HTx. exact HTz. }
claim Hpart2: (topology_on X Tx /\ topology_on Z Tz) /\ function_on gf X Z.
{ apply andI.
  - exact Hpart1.
  - (** Prove function_on gf X Z **)
    prove forall x:set, x :e X -> apply_fun gf x :e Z.
    let x. assume Hx: x :e X.
    prove apply_fun gf x :e Z.
    (** gf = {(x, apply_fun g (apply_fun f x))|x :e X} **)
    (** So apply_fun gf x should be apply_fun g (apply_fun f x) **)
    (** Since f: X -> Y, we have apply_fun f x :e Y **)
    claim Hfx: apply_fun f x :e Y.
    { exact (Hfun_f x Hx). }
    (** Since g: Y -> Z, we have apply_fun g (apply_fun f x) :e Z **)
    claim Hgfx: apply_fun g (apply_fun f x) :e Z.
    { exact (Hfun_g (apply_fun f x) Hfx). }
    (** Show apply_fun gf x :e Z using compose_fun_apply axiom **)
    claim Hgf_eq: apply_fun gf x = apply_fun g (apply_fun f x).
    { exact (compose_fun_apply X f g x Hx). }
    rewrite Hgf_eq.
    exact Hgfx.
}
apply andI.
- exact Hpart2.
- (** Prove preimages of open sets in Z are open in X **)
  let W. assume HW: W :e Tz.
  prove preimage_of X gf W :e Tx.
  (** Since g is continuous, preimage_of Y g W is open in Ty **)
  claim HgW_open: preimage_of Y g W :e Ty.
  { exact (Hpreimg_g W HW). }
  (** Since f is continuous, preimage_of X f (preimage_of Y g W) is open in Tx **)
  claim HfgW_open: preimage_of X f (preimage_of Y g W) :e Tx.
  { exact (Hpreimg_f (preimage_of Y g W) HgW_open). }
	  (** Show that preimage_of X gf W = preimage_of X f (preimage_of Y g W) **)
	  claim Hpreimg_eq: preimage_of X gf W = preimage_of X f (preimage_of Y g W).
	  { (** Use preimage composition property **)
	    exact (preimage_compose_fun X Y f g W Hfun_f).
	  }
  rewrite Hpreimg_eq.
  exact HfgW_open.
Qed.

(** from 18 Theorem 18.2: rules for constructing continuous functions **) 
(** LATEX VERSION: Theorem 18.2: Constant maps, inclusions, composites, domain restriction, range restriction/expansion, and local continuity formulation. **)
Theorem continuous_construction_rules : forall X Tx Y Ty Z Tz:set,
  topology_on X Tx -> topology_on Y Ty -> topology_on Z Tz ->
  (forall y0:set, y0 :e Y -> continuous_map X Tx Y Ty (const_fun X y0))
  /\
  (forall A:set, A c= X -> continuous_map A (subspace_topology X Tx A) X Tx {(y,y) | y :e A})
  /\
  (forall f g:set, continuous_map X Tx Y Ty f -> continuous_map Y Ty Z Tz g ->
    continuous_map X Tx Z Tz (compose_fun X f g))
  /\
  (forall f A:set, A c= X -> continuous_map X Tx Y Ty f ->
    continuous_map A (subspace_topology X Tx A) Y Ty f)
  /\
  ((forall f Z0:set, continuous_map X Tx Y Ty f -> Z0 c= Y ->
     (forall x:set, x :e X -> apply_fun f x :e Z0) ->
     continuous_map X Tx Z0 (subspace_topology Y Ty Z0) f)
   /\
   (forall f Z0 Tz0:set, continuous_map X Tx Y Ty f -> Y c= Z0 ->
     topology_on Z0 Tz0 -> Ty = subspace_topology Z0 Tz0 Y ->
     continuous_map X Tx Z0 Tz0 f))
  /\
  (forall f:set,
    (exists UFam:set, UFam c= Tx /\ Union UFam = X /\
      (forall U:set, U :e UFam -> continuous_map U (subspace_topology X Tx U) Y Ty f))
    -> continuous_map X Tx Y Ty f).
let X Tx Y Ty Z Tz.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
assume HTz: topology_on Z Tz.
prove (forall y0:set, y0 :e Y -> continuous_map X Tx Y Ty (const_fun X y0))
  /\ (forall A:set, A c= X -> continuous_map A (subspace_topology X Tx A) X Tx {(y,y) | y :e A})
  /\ (forall f g:set, continuous_map X Tx Y Ty f -> continuous_map Y Ty Z Tz g ->
       continuous_map X Tx Z Tz (compose_fun X f g))
  /\ (forall f A:set, A c= X -> continuous_map X Tx Y Ty f ->
       continuous_map A (subspace_topology X Tx A) Y Ty f)
  /\ ((forall f Z0:set, continuous_map X Tx Y Ty f -> Z0 c= Y ->
        (forall x:set, x :e X -> apply_fun f x :e Z0) ->
        continuous_map X Tx Z0 (subspace_topology Y Ty Z0) f)
      /\
      (forall f Z0 Tz0:set, continuous_map X Tx Y Ty f -> Y c= Z0 ->
        topology_on Z0 Tz0 -> Ty = subspace_topology Z0 Tz0 Y ->
        continuous_map X Tx Z0 Tz0 f))
  /\ (forall f:set,
       (exists UFam:set, UFam c= Tx /\ Union UFam = X /\
         (forall U:set, U :e UFam -> continuous_map U (subspace_topology X Tx U) Y Ty f))
       -> continuous_map X Tx Y Ty f).
apply andI.
- (** left: (a) through (e) **)
  apply andI.
  + (** left: (a) through (d) **)
    apply andI.
    * (** left: (a) through (c) **)
      apply andI.
      { (** left: (a) and (b) **)
        apply andI.
        - (** (a) constant functions **)
          let y0. assume Hy0: y0 :e Y.
          exact (const_fun_continuous X Tx Y Ty y0 HTx HTy Hy0).
        - (** (b) inclusion of a subspace is continuous **)
          let A. assume HA: A c= X.
          set j := {(y,y) | y :e A}.
          prove continuous_map A (subspace_topology X Tx A) X Tx j.
          prove topology_on A (subspace_topology X Tx A) /\ topology_on X Tx /\ function_on j A X /\
                forall V:set, V :e Tx -> preimage_of A j V :e subspace_topology X Tx A.
          apply andI.
          - apply andI.
            + apply andI.
              * exact (subspace_topology_is_topology X Tx A HTx HA).
              * exact HTx.
            + let a. assume HaA: a :e A.
              prove apply_fun j a :e X.
              claim Haj: apply_fun j a = a.
              { exact (identity_function_apply A a HaA). }
              rewrite Haj.
              exact (HA a HaA).
          - let V. assume HV: V :e Tx.
            prove preimage_of A j V :e subspace_topology X Tx A.
            claim Heq: preimage_of A j V = V :/\: A.
            { apply set_ext.
              - let a. assume Ha: a :e preimage_of A j V.
                prove a :e V :/\: A.
                claim HaA: a :e A.
                { exact (SepE1 A (fun u:set => apply_fun j u :e V) a Ha). }
                claim Haj: apply_fun j a = a.
                { exact (identity_function_apply A a HaA). }
                claim HaV: a :e V.
                { rewrite <- Haj.
                  exact (SepE2 A (fun u:set => apply_fun j u :e V) a Ha). }
                exact (binintersectI V A a HaV HaA).
              - let a. assume Ha: a :e V :/\: A.
                prove a :e preimage_of A j V.
                claim HaV: a :e V.
                { exact (binintersectE1 V A a Ha). }
                claim HaA: a :e A.
                { exact (binintersectE2 V A a Ha). }
                prove a :e {u :e A | apply_fun j u :e V}.
                apply (SepI A (fun u:set => apply_fun j u :e V) a HaA).
                claim Haj: apply_fun j a = a.
                { exact (identity_function_apply A a HaA). }
                rewrite Haj.
                exact HaV.
            }
            rewrite Heq.
	            claim HVpow: (V :/\: A) :e Power A.
	            { apply PowerI.
	              let a. assume Ha: a :e V :/\: A.
	              exact (binintersectE2 V A a Ha). }
	            claim HexW: exists W :e Tx, V :/\: A = W :/\: A.
	            { witness V.
	              apply andI.
	              - exact HV.
	              - reflexivity. }
	            exact (SepI (Power A) (fun U0:set => exists W :e Tx, U0 = W :/\: A) (V :/\: A) HVpow HexW).
	      }
      { (** (c) composites **)
        let f. let g. assume Hf. assume Hg.
        exact (composition_continuous X Tx Y Ty Z Tz f g Hf Hg).
      }
	    * (** (d) restricting the domain **)
	      let f. let A. assume HA. assume Hf.
	      prove continuous_map A (subspace_topology X Tx A) Y Ty f.
	      claim HTA: topology_on A (subspace_topology X Tx A).
	      { exact (subspace_topology_is_topology X Tx A HTx HA). }
	      claim HpreX: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
	      { exact (andER (((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y))
	                     (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
	                     Hf). }
	      claim Htmp: (topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y.
	      { exact (andEL (((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y))
	                     (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
	                     Hf). }
	      claim HfunXY: function_on f X Y.
	      { exact (andER (topology_on X Tx /\ topology_on Y Ty)
	                     (function_on f X Y)
	                     Htmp). }
	      prove (topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty /\ function_on f A Y)
	            /\ forall V:set, V :e Ty -> preimage_of A f V :e subspace_topology X Tx A.
	      apply andI.
	      - (** topology_on A /\ topology_on Y /\ function_on f A Y **)
	        apply andI.
	        + (** topology_on A /\ topology_on Y **)
	          apply andI.
	          * exact HTA.
	          * exact HTy.
	        + (** function_on f A Y **)
	          let a. assume HaA: a :e A.
	          prove apply_fun f a :e Y.
	          claim HaX: a :e X.
	          { exact (HA a HaA). }
	          exact (HfunXY a HaX).
	      - (** preimage condition in the subspace topology **)
	        let V. assume HV: V :e Ty.
	        prove preimage_of A f V :e subspace_topology X Tx A.
	        claim HWTx: preimage_of X f V :e Tx.
	        { exact (HpreX V HV). }
	        claim Heq: preimage_of A f V = (preimage_of X f V) :/\: A.
	        { apply set_ext.
	          - let a. assume Ha: a :e preimage_of A f V.
	            prove a :e (preimage_of X f V) :/\: A.
	            claim HaA: a :e A.
	            { exact (SepE1 A (fun u:set => apply_fun f u :e V) a Ha). }
	            claim HaX: a :e X.
	            { exact (HA a HaA). }
	            claim HafV: apply_fun f a :e V.
	            { exact (SepE2 A (fun u:set => apply_fun f u :e V) a Ha). }
		            claim HaPreX: a :e preimage_of X f V.
		            { exact (SepI X (fun u:set => apply_fun f u :e V) a HaX HafV). }
	            exact (binintersectI (preimage_of X f V) A a HaPreX HaA).
	          - let a. assume Ha: a :e (preimage_of X f V) :/\: A.
	            prove a :e preimage_of A f V.
	            claim HaPreX: a :e preimage_of X f V.
	            { exact (binintersectE1 (preimage_of X f V) A a Ha). }
	            claim HaA: a :e A.
	            { exact (binintersectE2 (preimage_of X f V) A a Ha). }
	            claim HafV: apply_fun f a :e V.
	            { exact (SepE2 X (fun u:set => apply_fun f u :e V) a HaPreX). }
		            exact (SepI A (fun u:set => apply_fun f u :e V) a HaA HafV).
	        }
	        rewrite Heq.
	        claim Hpow: ((preimage_of X f V) :/\: A) :e Power A.
	        { apply PowerI.
	          let a. assume Ha: a :e (preimage_of X f V) :/\: A.
	          exact (binintersectE2 (preimage_of X f V) A a Ha). }
	        claim HexW: exists W :e Tx, (preimage_of X f V) :/\: A = W :/\: A.
	        { witness (preimage_of X f V).
	          apply andI.
	          - exact HWTx.
	          - reflexivity. }
	        exact (SepI (Power A) (fun U0:set => exists W :e Tx, U0 = W :/\: A)
	                   ((preimage_of X f V) :/\: A) Hpow HexW).
	  + (** (e) restricting or expanding the range **)
	    apply andI.
	    - (** (e) restricting the range to a subspace Z0Y containing f(X) **)
	      let f. let Z0. assume Hf. assume HZ0. assume Himg.
	      prove continuous_map X Tx Z0 (subspace_topology Y Ty Z0) f.
	      (** Extract preimage axiom for f: X -> Y **)
	      claim HpreY: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
	      { exact (andER (((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y))
	                     (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
	                     Hf). }
	      (** Z0 with the subspace topology is a topological space **)
	      claim HTz0: topology_on Z0 (subspace_topology Y Ty Z0).
	      { exact (subspace_topology_is_topology Y Ty Z0 HTy HZ0). }
	      (** function_on f X Z0 **)
	      claim HfunXZ0: function_on f X Z0.
	      { let x. assume HxX: x :e X.
	        exact (Himg x HxX). }
	      (** prove the continuity conjunction **)
	      prove (topology_on X Tx /\ topology_on Z0 (subspace_topology Y Ty Z0) /\ function_on f X Z0)
	            /\ forall B:set, B :e subspace_topology Y Ty Z0 -> preimage_of X f B :e Tx.
	      apply andI.
	      - (** topologies and function_on **)
	        apply andI.
	        + apply andI.
	          * exact HTx.
	          * exact HTz0.
	        + exact HfunXZ0.
	      - let B. assume HB: B :e subspace_topology Y Ty Z0.
	        (** B is of the form V  Z0 for some V open in Y **)
	        claim Hex: exists V :e Ty, B = V :/\: Z0.
	        { exact (SepE2 (Power Z0) (fun U0:set => exists V :e Ty, U0 = V :/\: Z0) B HB). }
	        apply Hex.
	        let V. assume HVpair.
	        claim HV: V :e Ty.
	        { exact (andEL (V :e Ty) (B = V :/\: Z0) HVpair). }
	        claim HB_eq: B = V :/\: Z0.
	        { exact (andER (V :e Ty) (B = V :/\: Z0) HVpair). }
	        claim HeqPre: preimage_of X f B = preimage_of X f V.
	        { apply set_ext.
	          - let x. assume Hx: x :e preimage_of X f B.
	            prove x :e preimage_of X f V.
	            claim HxX: x :e X.
	            { exact (SepE1 X (fun u:set => apply_fun f u :e B) x Hx). }
	            claim HfxB: apply_fun f x :e B.
	            { exact (SepE2 X (fun u:set => apply_fun f u :e B) x Hx). }
	            claim HfxVz0: apply_fun f x :e V :/\: Z0.
	            { rewrite <- HB_eq. exact HfxB. }
	            claim HfxV: apply_fun f x :e V.
	            { exact (binintersectE1 V Z0 (apply_fun f x) HfxVz0). }
	            exact (SepI X (fun u:set => apply_fun f u :e V) x HxX HfxV).
	          - let x. assume Hx: x :e preimage_of X f V.
	            prove x :e preimage_of X f B.
	            claim HxX: x :e X.
	            { exact (SepE1 X (fun u:set => apply_fun f u :e V) x Hx). }
	            claim HfxV: apply_fun f x :e V.
	            { exact (SepE2 X (fun u:set => apply_fun f u :e V) x Hx). }
	            claim HfxZ0: apply_fun f x :e Z0.
	            { exact (HfunXZ0 x HxX). }
	            claim HfxB: apply_fun f x :e B.
	            { rewrite HB_eq.
	              exact (binintersectI V Z0 (apply_fun f x) HfxV HfxZ0). }
	            exact (SepI X (fun u:set => apply_fun f u :e B) x HxX HfxB).
	        }
	        rewrite HeqPre.
	        exact (HpreY V HV).
	    - (** (e) expanding the range: if Y is a subspace of Z0, continuity as XY implies continuity as XZ0 **)
	      let f. let Z0. let Tz0.
	      assume Hf: continuous_map X Tx Y Ty f.
	      assume HYZ0: Y c= Z0.
	      assume HTz0: topology_on Z0 Tz0.
	      assume HTy_eq: Ty = subspace_topology Z0 Tz0 Y.
	      prove continuous_map X Tx Z0 Tz0 f.
	      claim HpreY: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
	      { exact (andER (((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y))
	                     (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
	                     Hf). }
	      claim Htmp: (topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y.
	      { exact (andEL (((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y))
	                     (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
	                     Hf). }
	      claim HfunXY: function_on f X Y.
	      { exact (andER (topology_on X Tx /\ topology_on Y Ty)
	                     (function_on f X Y)
	                     Htmp). }
	      claim HfunXZ0: function_on f X Z0.
	      { let x. assume HxX: x :e X.
	        exact (HYZ0 (apply_fun f x) (HfunXY x HxX)). }
	      prove (topology_on X Tx /\ topology_on Z0 Tz0 /\ function_on f X Z0) /\
	            forall W:set, W :e Tz0 -> preimage_of X f W :e Tx.
	      apply andI.
	      - apply andI.
	        + apply andI.
	          * exact HTx.
	          * exact HTz0.
	        + exact HfunXZ0.
	      - let W. assume HW: W :e Tz0.
	        set B := W :/\: Y.
	        claim HB_inTy: B :e Ty.
	        { rewrite HTy_eq.
	          (** show B is in the subspace topology on Y **)
	          claim HBpow: B :e Power Y.
	          { apply PowerI.
	            let y. assume HyB: y :e B.
	            exact (binintersectE2 W Y y HyB). }
	          claim Hex: exists V :e Tz0, B = V :/\: Y.
	          { witness W.
	            apply andI.
	            - exact HW.
	            - reflexivity. }
	          exact (SepI (Power Y) (fun U0:set => exists V :e Tz0, U0 = V :/\: Y) B HBpow Hex). }
	        claim HeqPre: preimage_of X f W = preimage_of X f B.
	        { apply set_ext.
	          - let x. assume Hx: x :e preimage_of X f W.
	            prove x :e preimage_of X f B.
	            claim HxX: x :e X.
	            { exact (SepE1 X (fun u:set => apply_fun f u :e W) x Hx). }
	            claim HfxW: apply_fun f x :e W.
	            { exact (SepE2 X (fun u:set => apply_fun f u :e W) x Hx). }
	            claim HfxY: apply_fun f x :e Y.
	            { exact (HfunXY x HxX). }
	            claim HfxB: apply_fun f x :e B.
	            { exact (binintersectI W Y (apply_fun f x) HfxW HfxY). }
	            exact (SepI X (fun u:set => apply_fun f u :e B) x HxX HfxB).
	          - let x. assume Hx: x :e preimage_of X f B.
	            prove x :e preimage_of X f W.
	            claim HxX: x :e X.
	            { exact (SepE1 X (fun u:set => apply_fun f u :e B) x Hx). }
	            claim HfxB: apply_fun f x :e B.
	            { exact (SepE2 X (fun u:set => apply_fun f u :e B) x Hx). }
	            claim HfxW: apply_fun f x :e W.
	            { exact (binintersectE1 W Y (apply_fun f x) HfxB). }
	            exact (SepI X (fun u:set => apply_fun f u :e W) x HxX HfxW).
	        }
	        rewrite HeqPre.
	        exact (HpreY B HB_inTy).
- (** (f) local formulation **)
  let f. assume Hloc.
  prove continuous_map X Tx Y Ty f.
  apply Hloc.
	  let UFam. assume HUFconj.
	  claim HUFpair: (UFam c= Tx /\ Union UFam = X) /\ (forall U:set, U :e UFam -> continuous_map U (subspace_topology X Tx U) Y Ty f).
	  { exact HUFconj. }
	  claim HUFsub_union: UFam c= Tx /\ Union UFam = X.
	  { exact (andEL (UFam c= Tx /\ Union UFam = X)
	                 (forall U:set, U :e UFam -> continuous_map U (subspace_topology X Tx U) Y Ty f)
	                 HUFpair). }
	  claim HcontU: forall U:set, U :e UFam -> continuous_map U (subspace_topology X Tx U) Y Ty f.
	  { exact (andER (UFam c= Tx /\ Union UFam = X)
	                 (forall U:set, U :e UFam -> continuous_map U (subspace_topology X Tx U) Y Ty f)
	                 HUFpair). }
	  claim HUFsub: UFam c= Tx.
	  { exact (andEL (UFam c= Tx) (Union UFam = X) HUFsub_union). }
	  claim HUnionEq: Union UFam = X.
	  { exact (andER (UFam c= Tx) (Union UFam = X) HUFsub_union). }
  (** derive function_on f X Y from the local continuity hypotheses **)
  claim HfunXY: function_on f X Y.
  { let x. assume HxX: x :e X.
	    claim HxUnion: x :e Union UFam.
	    { rewrite HUnionEq. exact HxX. }
    apply (UnionE UFam x HxUnion).
    let U. assume HxUconj.
    claim HxU: x :e U.
    { exact (andEL (x :e U) (U :e UFam) HxUconj). }
    claim HUUF: U :e UFam.
    { exact (andER (x :e U) (U :e UFam) HxUconj). }
    claim HcU: continuous_map U (subspace_topology X Tx U) Y Ty f.
    { exact (HcontU U HUUF). }
    claim Htmp: (topology_on U (subspace_topology X Tx U) /\ topology_on Y Ty) /\ function_on f U Y.
    { exact (andEL ((topology_on U (subspace_topology X Tx U) /\ topology_on Y Ty) /\ function_on f U Y)
                   (forall V:set, V :e Ty -> preimage_of U f V :e subspace_topology X Tx U)
                   HcU). }
    claim HfunUY: function_on f U Y.
    { exact (andER (topology_on U (subspace_topology X Tx U) /\ topology_on Y Ty)
                   (function_on f U Y)
                   Htmp). }
    exact (HfunUY x HxU). }
  (** now prove continuity of f by the preimage definition **)
  prove topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y /\
        forall V:set, V :e Ty -> preimage_of X f V :e Tx.
  apply andI.
  - apply andI.
    + apply andI.
      * exact HTx.
      * exact HTy.
    + exact HfunXY.
  - let V. assume HV: V :e Ty.
    set S := preimage_of X f V.
    (** define Fam = {W open in X | W  S} **)
    set Fam := {W :e Power X | W :e Tx /\ W c= S}.
    claim HFamSubTx: Fam c= Tx.
    { let W. assume HW: W :e Fam.
      claim HWpred: W :e Tx /\ W c= S.
      { exact (SepE2 (Power X) (fun W0:set => W0 :e Tx /\ W0 c= S) W HW). }
      exact (andEL (W :e Tx) (W c= S) HWpred). }
    claim HUnionFamEq: Union Fam = S.
    { apply set_ext.
      - let x. assume Hx: x :e Union Fam.
        prove x :e S.
        apply (UnionE Fam x Hx).
        let W. assume HxWconj.
        claim HxW: x :e W.
        { exact (andEL (x :e W) (W :e Fam) HxWconj). }
        claim HWFam: W :e Fam.
        { exact (andER (x :e W) (W :e Fam) HxWconj). }
        claim HWpred: W :e Tx /\ W c= S.
        { exact (SepE2 (Power X) (fun W0:set => W0 :e Tx /\ W0 c= S) W HWFam). }
        claim HWsubS: W c= S.
        { exact (andER (W :e Tx) (W c= S) HWpred). }
        exact (HWsubS x HxW).
      - let x. assume Hx: x :e S.
        prove x :e Union Fam.
        (** choose a cover element U with x  U **)
        claim HxX: x :e X.
        { exact (SepE1 X (fun u:set => apply_fun f u :e V) x Hx). }
	        claim HxUnion: x :e Union UFam.
	        { rewrite HUnionEq. exact HxX. }
        apply (UnionE UFam x HxUnion).
        let U. assume HxUconj.
        claim HxU: x :e U.
        { exact (andEL (x :e U) (U :e UFam) HxUconj). }
        claim HUUF: U :e UFam.
        { exact (andER (x :e U) (U :e UFam) HxUconj). }
        claim HUTx: U :e Tx.
        { exact (HUFsub U HUUF). }
        claim HUSubX: U c= X.
        { exact (topology_elem_subset X Tx U HTx HUTx). }
        claim HcU: continuous_map U (subspace_topology X Tx U) Y Ty f.
        { exact (HcontU U HUUF). }
        (** from continuity on U: preimage_of U f V is open in the subspace topology **)
        claim HpreU: preimage_of U f V :e subspace_topology X Tx U.
        { exact (andER (((topology_on U (subspace_topology X Tx U) /\ topology_on Y Ty) /\ function_on f U Y))
                       (forall V0:set, V0 :e Ty -> preimage_of U f V0 :e subspace_topology X Tx U)
                       HcU
                       V
                       HV). }
        claim HexW0: exists W0 :e Tx, preimage_of U f V = W0 :/\: U.
        { exact (SepE2 (Power U) (fun U0:set => exists W0 :e Tx, U0 = W0 :/\: U) (preimage_of U f V) HpreU). }
        apply HexW0.
        let W0. assume HW0pair.
        claim HW0Tx: W0 :e Tx.
        { exact (andEL (W0 :e Tx) (preimage_of U f V = W0 :/\: U) HW0pair). }
        claim HeqPreU: preimage_of U f V = W0 :/\: U.
        { exact (andER (W0 :e Tx) (preimage_of U f V = W0 :/\: U) HW0pair). }
        set W := W0 :/\: U.
        (** show x  W **)
        claim HfxV: apply_fun f x :e V.
        { exact (SepE2 X (fun u:set => apply_fun f u :e V) x Hx). }
        claim HxPreU: x :e preimage_of U f V.
        { prove x :e {u :e U | apply_fun f u :e V}.
          apply (SepI U (fun u:set => apply_fun f u :e V) x HxU).
          exact HfxV. }
        claim HxW: x :e W.
        { rewrite <- HeqPreU. exact HxPreU. }
        (** show W  Fam and then x  Union Fam by UnionI **)
        claim HWsubS: W c= S.
        { let z. assume Hz: z :e W.
          prove z :e S.
          claim HzU: z :e U.
          { exact (binintersectE2 W0 U z Hz). }
          claim HzX: z :e X.
          { exact (HUSubX z HzU). }
	          claim HzPreU: z :e preimage_of U f V.
	          { rewrite HeqPreU.
	            exact Hz. }
          claim HfzV: apply_fun f z :e V.
          { exact (SepE2 U (fun u:set => apply_fun f u :e V) z HzPreU). }
          exact (SepI X (fun u:set => apply_fun f u :e V) z HzX HfzV). }
        claim HWpow: W :e Power X.
        { apply PowerI.
          let z. assume Hz: z :e W.
          claim HzU: z :e U.
          { exact (binintersectE2 W0 U z Hz). }
          exact (HUSubX z HzU). }
        claim HWFam: W :e Fam.
        { exact (SepI (Power X) (fun W1:set => W1 :e Tx /\ W1 c= S) W HWpow
                 (andI (W :e Tx) (W c= S)
                   (topology_binintersect_closed X Tx W0 U HTx HW0Tx HUTx)
                   HWsubS)). }
        exact (UnionI Fam x W HxW HWFam).
    }
    rewrite <- HUnionFamEq.
    exact (topology_union_closed X Tx Fam HTx HFamSubTx).
Qed.

(** helper: restricting the domain to a subspace preserves continuity **)
(** LATEX VERSION: If f is continuous on X and AX, then f restricted to A is continuous with the subspace topology on A. **)
Theorem continuous_on_subspace_rule : forall X Tx Y Ty f A:set,
  topology_on X Tx -> topology_on Y Ty -> A c= X ->
  continuous_map X Tx Y Ty f ->
  continuous_map A (subspace_topology X Tx A) Y Ty f.
let X Tx Y Ty f A.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
assume HA: A c= X.
assume Hf: continuous_map X Tx Y Ty f.
prove continuous_map A (subspace_topology X Tx A) Y Ty f.
claim HTA: topology_on A (subspace_topology X Tx A).
{ exact (subspace_topology_is_topology X Tx A HTx HA). }
claim HpreX: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
{ exact (andER (((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y))
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               Hf). }
claim Htmp: (topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y.
{ exact (andEL (((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y))
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               Hf). }
claim HfunXY: function_on f X Y.
{ exact (andER (topology_on X Tx /\ topology_on Y Ty)
               (function_on f X Y)
               Htmp). }
prove topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty /\ function_on f A Y /\
  forall V:set, V :e Ty -> preimage_of A f V :e subspace_topology X Tx A.
apply andI.
- apply andI.
  + apply andI.
    * exact HTA.
    * exact HTy.
  + (** function_on f A Y **)
    let a. assume HaA: a :e A.
    prove apply_fun f a :e Y.
    claim HaX: a :e X.
    { exact (HA a HaA). }
    exact (HfunXY a HaX).
- let V. assume HV: V :e Ty.
  prove preimage_of A f V :e subspace_topology X Tx A.
  set U := preimage_of X f V.
  claim HU_open: U :e Tx.
  { exact (HpreX V HV). }
  claim Heq: preimage_of A f V = U :/\: A.
  { apply set_ext.
    - let a. assume Ha: a :e preimage_of A f V.
      prove a :e U :/\: A.
      claim HaA: a :e A.
      { exact (SepE1 A (fun u:set => apply_fun f u :e V) a Ha). }
      claim HaU: a :e U.
      { claim HaX: a :e X.
        { exact (HA a HaA). }
        claim HaV: apply_fun f a :e V.
        { exact (SepE2 A (fun u:set => apply_fun f u :e V) a Ha). }
        exact (SepI X (fun x:set => apply_fun f x :e V) a HaX HaV). }
      exact (binintersectI U A a HaU HaA).
    - let a. assume Ha: a :e U :/\: A.
      prove a :e preimage_of A f V.
      claim HaU: a :e U.
      { exact (binintersectE1 U A a Ha). }
      claim HaA: a :e A.
      { exact (binintersectE2 U A a Ha). }
      claim HaV: apply_fun f a :e V.
      { exact (SepE2 X (fun x:set => apply_fun f x :e V) a HaU). }
      exact (SepI A (fun u:set => apply_fun f u :e V) a HaA HaV).
  }
  rewrite Heq.
  claim HWpow: (U :/\: A) :e Power A.
  { apply PowerI.
    let a. assume Ha: a :e U :/\: A.
    exact (binintersectE2 U A a Ha). }
  claim HexW: exists W :e Tx, U :/\: A = W :/\: A.
  { witness U.
    apply andI.
    - exact HU_open.
    - reflexivity. }
  exact (SepI (Power A) (fun U0:set => exists W :e Tx, U0 = W :/\: A) (U :/\: A) HWpow HexW).
Qed.

(** helper: flip_unit_interval is continuous in the unit interval topology **)
(** LATEX VERSION: The map t |-> 1 - t is continuous on the unit interval I. **)
Theorem flip_unit_interval_continuous :
  continuous_map unit_interval unit_interval_topology unit_interval unit_interval_topology flip_unit_interval.
prove continuous_map unit_interval unit_interval_topology unit_interval unit_interval_topology flip_unit_interval.
set Tx := unit_interval_topology.

(** first prove continuity as a map into R, then restrict the range to unit_interval **)
claim HcontR: continuous_map unit_interval Tx R R_standard_topology flip_unit_interval.
{ set S := open_rays_subbasis R.

  claim HTx: topology_on unit_interval Tx.
  { exact unit_interval_topology_on. }

  claim HfunR: function_on flip_unit_interval unit_interval R.
  { let t. assume Ht: t :e unit_interval.
    exact (flip_unit_interval_in_R t Ht). }

  claim HS: subbasis_on R S.
  { exact (open_rays_subbasis_is_subbasis R). }

  claim Hgen: generated_topology_from_subbasis R S = R_standard_topology.
  { rewrite (open_rays_subbasis_for_order_topology R).
    rewrite standard_topology_is_order_topology.
    reflexivity. }
  rewrite <- Hgen.

  claim Hflip_upper: forall a t:set,
    a :e R -> t :e R ->
    (Rlt a (add_SNo 1 (minus_SNo t)) <-> Rlt t (add_SNo 1 (minus_SNo a))).
  { let a t.
    assume HaR: a :e R.
    assume HtR: t :e R.
    prove (Rlt a (add_SNo 1 (minus_SNo t)) <-> Rlt t (add_SNo 1 (minus_SNo a))).
    apply iffI.
    - assume Hlt: Rlt a (add_SNo 1 (minus_SNo t)).
      prove Rlt t (add_SNo 1 (minus_SNo a)).
      claim HaS: SNo a.
      { exact (real_SNo a HaR). }
      claim HtS: SNo t.
      { exact (real_SNo t HtR). }
      claim HmaS: SNo (minus_SNo a).
      { exact (SNo_minus_SNo a HaS). }
      claim HmtS: SNo (minus_SNo t).
      { exact (SNo_minus_SNo t HtS). }
      claim HsumS: SNo (add_SNo 1 (minus_SNo t)).
      { exact (SNo_add_SNo 1 (minus_SNo t) SNo_1 HmtS). }
      claim HltS: a < add_SNo 1 (minus_SNo t).
      { exact (RltE_lt a (add_SNo 1 (minus_SNo t)) Hlt). }
      claim H1: add_SNo a t < add_SNo (add_SNo 1 (minus_SNo t)) t.
      { exact (add_SNo_Lt1 a t (add_SNo 1 (minus_SNo t)) HaS HtS HsumS HltS). }
      claim HeqR: add_SNo (add_SNo 1 (minus_SNo t)) t = 1.
      { rewrite <- (add_SNo_assoc 1 (minus_SNo t) t SNo_1 HmtS HtS).
        rewrite (add_SNo_minus_SNo_linv t HtS).
        exact (add_SNo_0R 1 SNo_1). }
      claim H2: add_SNo a t < 1.
      { rewrite <- HeqR.
        exact H1. }
      claim H2c: add_SNo t a < 1.
      { rewrite (add_SNo_com t a HtS HaS).
        exact H2. }
      claim Hm1S: SNo (minus_SNo a).
      { exact HmaS. }
      claim H3: add_SNo (add_SNo t a) (minus_SNo a) < add_SNo 1 (minus_SNo a).
      { exact (add_SNo_Lt1 (add_SNo t a) (minus_SNo a) 1
               (SNo_add_SNo t a HtS HaS) Hm1S SNo_1 H2c). }
      claim HeqL: add_SNo (add_SNo t a) (minus_SNo a) = t.
      { rewrite <- (add_SNo_assoc t a (minus_SNo a) HtS HaS Hm1S).
        rewrite (add_SNo_minus_SNo_rinv a HaS).
        exact (add_SNo_0R t HtS). }
      claim H4: t < add_SNo 1 (minus_SNo a).
      { rewrite <- HeqL at 1.
        exact H3. }
      claim Hflip_aR: add_SNo 1 (minus_SNo a) :e R.
      { claim HdefR: R = real.
        { reflexivity. }
        rewrite HdefR.
        claim HaReal: a :e real.
        { rewrite <- HdefR.
          exact HaR. }
        claim HmaReal: (minus_SNo a) :e real.
        { exact (real_minus_SNo a HaReal). }
        exact (real_add_SNo 1 real_1 (minus_SNo a) HmaReal). }
      exact (RltI t (add_SNo 1 (minus_SNo a)) HtR Hflip_aR H4).
    - assume Hlt: Rlt t (add_SNo 1 (minus_SNo a)).
      prove Rlt a (add_SNo 1 (minus_SNo t)).
      claim HaS: SNo a.
      { exact (real_SNo a HaR). }
      claim HtS: SNo t.
      { exact (real_SNo t HtR). }
      claim HmaS: SNo (minus_SNo a).
      { exact (SNo_minus_SNo a HaS). }
      claim HmtS: SNo (minus_SNo t).
      { exact (SNo_minus_SNo t HtS). }
      claim Hflip_aS: SNo (add_SNo 1 (minus_SNo a)).
      { exact (SNo_add_SNo 1 (minus_SNo a) SNo_1 HmaS). }
      claim HltS: t < add_SNo 1 (minus_SNo a).
      { exact (RltE_lt t (add_SNo 1 (minus_SNo a)) Hlt). }
      claim H1: add_SNo t a < add_SNo (add_SNo 1 (minus_SNo a)) a.
      { exact (add_SNo_Lt1 t a (add_SNo 1 (minus_SNo a)) HtS HaS Hflip_aS HltS). }
      claim HeqR: add_SNo (add_SNo 1 (minus_SNo a)) a = 1.
      { rewrite <- (add_SNo_assoc 1 (minus_SNo a) a SNo_1 HmaS HaS).
        rewrite (add_SNo_minus_SNo_linv a HaS).
        exact (add_SNo_0R 1 SNo_1). }
      claim H2: add_SNo t a < 1.
      { rewrite <- HeqR.
        exact H1. }
      claim H2c: add_SNo a t < 1.
      { rewrite (add_SNo_com a t HaS HtS).
        exact H2. }
      claim Hm1S: SNo (minus_SNo t).
      { exact HmtS. }
      claim H3: add_SNo (add_SNo a t) (minus_SNo t) < add_SNo 1 (minus_SNo t).
      { exact (add_SNo_Lt1 (add_SNo a t) (minus_SNo t) 1
               (SNo_add_SNo a t HaS HtS) Hm1S SNo_1 H2c). }
      claim HeqL: add_SNo (add_SNo a t) (minus_SNo t) = a.
      { rewrite <- (add_SNo_assoc a t (minus_SNo t) HaS HtS Hm1S).
        rewrite (add_SNo_minus_SNo_rinv t HtS).
        exact (add_SNo_0R a HaS). }
      claim H4: a < add_SNo 1 (minus_SNo t).
      { rewrite <- HeqL at 1.
        exact H3. }
      claim Hflip_tR: add_SNo 1 (minus_SNo t) :e R.
      { claim HdefR: R = real.
        { reflexivity. }
        rewrite HdefR.
        claim HtReal: t :e real.
        { rewrite <- HdefR.
          exact HtR. }
        claim HmtReal: (minus_SNo t) :e real.
        { exact (real_minus_SNo t HtReal). }
        exact (real_add_SNo 1 real_1 (minus_SNo t) HmtReal). }
      exact (RltI a (add_SNo 1 (minus_SNo t)) HaR Hflip_tR H4). }

  claim Hflip_lower: forall t b:set,
    t :e R -> b :e R ->
    (Rlt (add_SNo 1 (minus_SNo t)) b <-> Rlt (add_SNo 1 (minus_SNo b)) t).
  { let t b.
    assume HtR: t :e R.
    assume HbR: b :e R.
    prove (Rlt (add_SNo 1 (minus_SNo t)) b <-> Rlt (add_SNo 1 (minus_SNo b)) t).
    apply iffI.
    - assume Hlt: Rlt (add_SNo 1 (minus_SNo t)) b.
      prove Rlt (add_SNo 1 (minus_SNo b)) t.
      claim HtS: SNo t.
      { exact (real_SNo t HtR). }
      claim HbS: SNo b.
      { exact (real_SNo b HbR). }
      claim HmtS: SNo (minus_SNo t).
      { exact (SNo_minus_SNo t HtS). }
      claim HmbS: SNo (minus_SNo b).
      { exact (SNo_minus_SNo b HbS). }
      claim HsumS: SNo (add_SNo 1 (minus_SNo t)).
      { exact (SNo_add_SNo 1 (minus_SNo t) SNo_1 HmtS). }
      claim HltS: add_SNo 1 (minus_SNo t) < b.
      { exact (RltE_lt (add_SNo 1 (minus_SNo t)) b Hlt). }
      claim H1: add_SNo (add_SNo 1 (minus_SNo t)) t < add_SNo b t.
      { exact (add_SNo_Lt1 (add_SNo 1 (minus_SNo t)) t b HsumS HtS HbS HltS). }
      claim HeqL: add_SNo (add_SNo 1 (minus_SNo t)) t = 1.
      { rewrite <- (add_SNo_assoc 1 (minus_SNo t) t SNo_1 HmtS HtS).
        rewrite (add_SNo_minus_SNo_linv t HtS).
        exact (add_SNo_0R 1 SNo_1). }
      claim H2: 1 < add_SNo b t.
      { rewrite <- HeqL at 1.
        exact H1. }
      claim H2c: 1 < add_SNo t b.
      { rewrite <- (add_SNo_com b t HbS HtS).
        exact H2. }
      claim Hm1S: SNo (minus_SNo b).
      { exact HmbS. }
      claim H3: add_SNo 1 (minus_SNo b) < add_SNo (add_SNo t b) (minus_SNo b).
      { exact (add_SNo_Lt1 1 (minus_SNo b) (add_SNo t b)
               SNo_1 Hm1S (SNo_add_SNo t b HtS HbS) H2c). }
      claim HeqR: add_SNo (add_SNo t b) (minus_SNo b) = t.
      { rewrite <- (add_SNo_assoc t b (minus_SNo b) HtS HbS Hm1S).
        rewrite (add_SNo_minus_SNo_rinv b HbS).
        exact (add_SNo_0R t HtS). }
      claim H4: add_SNo 1 (minus_SNo b) < t.
      { rewrite <- HeqR.
        exact H3. }
      claim Hflip_bR: add_SNo 1 (minus_SNo b) :e R.
      { claim HdefR: R = real.
        { reflexivity. }
        rewrite HdefR.
        claim HbReal: b :e real.
        { rewrite <- HdefR.
          exact HbR. }
        claim HmbReal: (minus_SNo b) :e real.
        { exact (real_minus_SNo b HbReal). }
        exact (real_add_SNo 1 real_1 (minus_SNo b) HmbReal). }
      exact (RltI (add_SNo 1 (minus_SNo b)) t Hflip_bR HtR H4).
    - assume Hlt: Rlt (add_SNo 1 (minus_SNo b)) t.
      prove Rlt (add_SNo 1 (minus_SNo t)) b.
      claim HtS: SNo t.
      { exact (real_SNo t HtR). }
      claim HbS: SNo b.
      { exact (real_SNo b HbR). }
      claim HmtS: SNo (minus_SNo t).
      { exact (SNo_minus_SNo t HtS). }
      claim HmbS: SNo (minus_SNo b).
      { exact (SNo_minus_SNo b HbS). }
      claim HsumS: SNo (add_SNo 1 (minus_SNo b)).
      { exact (SNo_add_SNo 1 (minus_SNo b) SNo_1 HmbS). }
      claim HltS: add_SNo 1 (minus_SNo b) < t.
      { exact (RltE_lt (add_SNo 1 (minus_SNo b)) t Hlt). }
      claim H1: add_SNo (add_SNo 1 (minus_SNo b)) b < add_SNo t b.
      { exact (add_SNo_Lt1 (add_SNo 1 (minus_SNo b)) b t HsumS HbS HtS HltS). }
      claim HeqL: add_SNo (add_SNo 1 (minus_SNo b)) b = 1.
      { rewrite <- (add_SNo_assoc 1 (minus_SNo b) b SNo_1 HmbS HbS).
        rewrite (add_SNo_minus_SNo_linv b HbS).
        exact (add_SNo_0R 1 SNo_1). }
      claim H2: 1 < add_SNo t b.
      { rewrite <- HeqL at 1.
        exact H1. }
      claim H2c: 1 < add_SNo b t.
      { rewrite <- (add_SNo_com t b HtS HbS).
        exact H2. }
      claim Hm1S: SNo (minus_SNo t).
      { exact HmtS. }
      claim H3: add_SNo 1 (minus_SNo t) < add_SNo (add_SNo b t) (minus_SNo t).
      { exact (add_SNo_Lt1 1 (minus_SNo t) (add_SNo b t)
               SNo_1 Hm1S (SNo_add_SNo b t HbS HtS) H2c). }
      claim HeqR: add_SNo (add_SNo b t) (minus_SNo t) = b.
      { rewrite <- (add_SNo_assoc b t (minus_SNo t) HbS HtS Hm1S).
        rewrite (add_SNo_minus_SNo_rinv t HtS).
        exact (add_SNo_0R b HbS). }
      claim H4: add_SNo 1 (minus_SNo t) < b.
      { rewrite <- HeqR.
        exact H3. }
      claim Hflip_tR: add_SNo 1 (minus_SNo t) :e R.
      { claim HdefR: R = real.
        { reflexivity. }
        rewrite HdefR.
        claim HtReal: t :e real.
        { rewrite <- HdefR.
          exact HtR. }
        claim HmtReal: (minus_SNo t) :e real.
        { exact (real_minus_SNo t HtReal). }
        exact (real_add_SNo 1 real_1 (minus_SNo t) HmtReal). }
      exact (RltI (add_SNo 1 (minus_SNo t)) b Hflip_tR HbR H4). }

  claim HpreS: forall s:set, s :e S -> preimage_of unit_interval flip_unit_interval s :e Tx.
  { let s. assume HsS: s :e S.
    prove preimage_of unit_interval flip_unit_interval s :e Tx.
    apply (binunionE' ({I :e Power R | exists a :e R, I = open_ray_upper R a}
                       :\/:
                       {I :e Power R | exists b :e R, I = open_ray_lower R b})
                      {R}
                      s
                      (preimage_of unit_interval flip_unit_interval s :e Tx)).
    - assume Hs0: s :e ({I :e Power R | exists a :e R, I = open_ray_upper R a}
                        :\/:
                        {I :e Power R | exists b :e R, I = open_ray_lower R b}).
      apply (binunionE' {I :e Power R | exists a :e R, I = open_ray_upper R a}
                        {I :e Power R | exists b :e R, I = open_ray_lower R b}
                        s
                        (preimage_of unit_interval flip_unit_interval s :e Tx)).
      + assume Hsu: s :e {I :e Power R | exists a :e R, I = open_ray_upper R a}.
        claim Hex: exists a :e R, s = open_ray_upper R a.
        { exact (SepE2 (Power R)
                      (fun I0 : set => exists a :e R, I0 = open_ray_upper R a)
                      s Hsu). }
        apply Hex.
        let a. assume Hcore.
        apply Hcore.
        assume HaR: a :e R.
        assume Hseq: s = open_ray_upper R a.
        rewrite Hseq.
        set c := add_SNo 1 (minus_SNo a).
        claim HcR: c :e R.
        { claim HdefR: R = real.
          { reflexivity. }
          rewrite HdefR.
          claim HaReal: a :e real.
          { rewrite <- HdefR.
            exact HaR. }
          claim HmaReal: (minus_SNo a) :e real.
          { exact (real_minus_SNo a HaReal). }
          exact (real_add_SNo 1 real_1 (minus_SNo a) HmaReal). }

        claim HpreEq: preimage_of unit_interval flip_unit_interval (open_ray_upper R a)
                      = (open_ray_lower R c) :/\: unit_interval.
        { apply set_ext.
          - let t. assume Ht: t :e preimage_of unit_interval flip_unit_interval (open_ray_upper R a).
            prove t :e (open_ray_lower R c) :/\: unit_interval.
            claim HtI: t :e unit_interval.
            { exact (SepE1 unit_interval (fun u : set => apply_fun flip_unit_interval u :e open_ray_upper R a) t Ht). }
            claim HtR: t :e R.
            { exact (unit_interval_sub_R t HtI). }
            claim Himg: apply_fun flip_unit_interval t :e open_ray_upper R a.
            { exact (SepE2 unit_interval (fun u : set => apply_fun flip_unit_interval u :e open_ray_upper R a) t Ht). }
            claim Hrel: order_rel R a (apply_fun flip_unit_interval t).
            { exact (SepE2 R (fun x0 : set => order_rel R a x0) (apply_fun flip_unit_interval t) Himg). }
            claim Hrlt: Rlt a (apply_fun flip_unit_interval t).
            { exact (order_rel_R_implies_Rlt a (apply_fun flip_unit_interval t) Hrel). }
            claim Hrlt2: Rlt a (add_SNo 1 (minus_SNo t)).
            { rewrite <- (flip_unit_interval_apply t HtI).
              exact Hrlt. }
            claim Hrlt3: Rlt t c.
            { exact (iffEL (Rlt a (add_SNo 1 (minus_SNo t))) (Rlt t (add_SNo 1 (minus_SNo a)))
                          (Hflip_upper a t HaR HtR) Hrlt2). }
            claim Hrel2: order_rel R t c.
            { exact (Rlt_implies_order_rel_R t c Hrlt3). }
            claim HtRay: t :e open_ray_lower R c.
            { exact (SepI R (fun x0 : set => order_rel R x0 c) t HtR Hrel2). }
            exact (binintersectI (open_ray_lower R c) unit_interval t HtRay HtI).
          - let t. assume Ht: t :e (open_ray_lower R c) :/\: unit_interval.
            prove t :e preimage_of unit_interval flip_unit_interval (open_ray_upper R a).
            claim HtRay: t :e open_ray_lower R c.
            { exact (binintersectE1 (open_ray_lower R c) unit_interval t Ht). }
            claim HtI: t :e unit_interval.
            { exact (binintersectE2 (open_ray_lower R c) unit_interval t Ht). }
            claim HtR: t :e R.
            { exact (unit_interval_sub_R t HtI). }
            claim Hrel: order_rel R t c.
            { exact (SepE2 R (fun x0 : set => order_rel R x0 c) t HtRay). }
            claim Hrlt: Rlt t c.
            { exact (order_rel_R_implies_Rlt t c Hrel). }
            claim Hrlt2: Rlt a (add_SNo 1 (minus_SNo t)).
            { exact (iffER (Rlt a (add_SNo 1 (minus_SNo t))) (Rlt t (add_SNo 1 (minus_SNo a)))
                          (Hflip_upper a t HaR HtR) Hrlt). }
            claim Hrlt3: Rlt a (apply_fun flip_unit_interval t).
            { rewrite (flip_unit_interval_apply t HtI).
              exact Hrlt2. }
            claim Hrel2: order_rel R a (apply_fun flip_unit_interval t).
            { exact (Rlt_implies_order_rel_R a (apply_fun flip_unit_interval t) Hrlt3). }
            claim HimgR: apply_fun flip_unit_interval t :e R.
            { exact (HfunR t HtI). }
            claim Himg: apply_fun flip_unit_interval t :e open_ray_upper R a.
            { exact (SepI R (fun x0 : set => order_rel R a x0) (apply_fun flip_unit_interval t) HimgR Hrel2). }
            exact (SepI unit_interval (fun u : set => apply_fun flip_unit_interval u :e open_ray_upper R a) t HtI Himg). }

        rewrite HpreEq.
        set Z0 := open_ray_lower R c.
        claim HZ0open: Z0 :e R_standard_topology.
        { rewrite <- standard_topology_is_order_topology.
          claim HsRay: Z0 :e open_rays_subbasis R.
          { exact (open_ray_lower_in_open_rays_subbasis R c HcR). }
          exact (open_rays_subbasis_sub_order_topology R Z0 HsRay). }
        claim HZ0cap: Z0 :/\: unit_interval :e Tx.
        { prove Z0 :/\: unit_interval :e {W :e Power unit_interval | exists Z :e R_standard_topology, W = Z :/\: unit_interval}.
          claim Hpow: Z0 :/\: unit_interval :e Power unit_interval.
          { apply PowerI.
            let t. assume Ht: t :e Z0 :/\: unit_interval.
            exact (binintersectE2 Z0 unit_interval t Ht). }
          claim Hex: exists Z :e R_standard_topology, Z0 :/\: unit_interval = Z :/\: unit_interval.
          { witness Z0.
            apply andI.
            - exact HZ0open.
            - reflexivity. }
          exact (SepI (Power unit_interval)
                      (fun W0 : set => exists Z :e R_standard_topology, W0 = Z :/\: unit_interval)
                      (Z0 :/\: unit_interval) Hpow Hex). }
        exact HZ0cap.
      + assume Hsl: s :e {I :e Power R | exists b :e R, I = open_ray_lower R b}.
        claim Hex: exists b :e R, s = open_ray_lower R b.
        { exact (SepE2 (Power R)
                      (fun I0 : set => exists b :e R, I0 = open_ray_lower R b)
                      s Hsl). }
        apply Hex.
        let b. assume Hcore.
        apply Hcore.
        assume HbR: b :e R.
        assume Hseq: s = open_ray_lower R b.
        rewrite Hseq.
        set c := add_SNo 1 (minus_SNo b).
        claim HcR: c :e R.
        { claim HdefR: R = real.
          { reflexivity. }
          rewrite HdefR.
          claim HbReal: b :e real.
          { rewrite <- HdefR.
            exact HbR. }
          claim HmbReal: (minus_SNo b) :e real.
          { exact (real_minus_SNo b HbReal). }
          exact (real_add_SNo 1 real_1 (minus_SNo b) HmbReal). }

        claim HpreEq: preimage_of unit_interval flip_unit_interval (open_ray_lower R b)
                      = (open_ray_upper R c) :/\: unit_interval.
        { apply set_ext.
          - let t. assume Ht: t :e preimage_of unit_interval flip_unit_interval (open_ray_lower R b).
            prove t :e (open_ray_upper R c) :/\: unit_interval.
            claim HtI: t :e unit_interval.
            { exact (SepE1 unit_interval (fun u : set => apply_fun flip_unit_interval u :e open_ray_lower R b) t Ht). }
            claim HtR: t :e R.
            { exact (unit_interval_sub_R t HtI). }
            claim Himg: apply_fun flip_unit_interval t :e open_ray_lower R b.
            { exact (SepE2 unit_interval (fun u : set => apply_fun flip_unit_interval u :e open_ray_lower R b) t Ht). }
            claim Hrel: order_rel R (apply_fun flip_unit_interval t) b.
            { exact (SepE2 R (fun x0 : set => order_rel R x0 b) (apply_fun flip_unit_interval t) Himg). }
            claim Hrlt: Rlt (apply_fun flip_unit_interval t) b.
            { exact (order_rel_R_implies_Rlt (apply_fun flip_unit_interval t) b Hrel). }
            claim Hrlt2: Rlt (add_SNo 1 (minus_SNo t)) b.
            { rewrite <- (flip_unit_interval_apply t HtI).
              exact Hrlt. }
            claim Hrlt3: Rlt c t.
            { exact (iffEL (Rlt (add_SNo 1 (minus_SNo t)) b) (Rlt (add_SNo 1 (minus_SNo b)) t)
                          (Hflip_lower t b HtR HbR) Hrlt2). }
            claim Hrel2: order_rel R c t.
            { exact (Rlt_implies_order_rel_R c t Hrlt3). }
            claim HtRay: t :e open_ray_upper R c.
            { exact (SepI R (fun x0 : set => order_rel R c x0) t HtR Hrel2). }
            exact (binintersectI (open_ray_upper R c) unit_interval t HtRay HtI).
          - let t. assume Ht: t :e (open_ray_upper R c) :/\: unit_interval.
            prove t :e preimage_of unit_interval flip_unit_interval (open_ray_lower R b).
            claim HtRay: t :e open_ray_upper R c.
            { exact (binintersectE1 (open_ray_upper R c) unit_interval t Ht). }
            claim HtI: t :e unit_interval.
            { exact (binintersectE2 (open_ray_upper R c) unit_interval t Ht). }
            claim HtR: t :e R.
            { exact (unit_interval_sub_R t HtI). }
            claim Hrel: order_rel R c t.
            { exact (SepE2 R (fun x0 : set => order_rel R c x0) t HtRay). }
            claim Hrlt: Rlt c t.
            { exact (order_rel_R_implies_Rlt c t Hrel). }
            claim Hrlt2: Rlt (add_SNo 1 (minus_SNo t)) b.
            { exact (iffER (Rlt (add_SNo 1 (minus_SNo t)) b) (Rlt (add_SNo 1 (minus_SNo b)) t)
                          (Hflip_lower t b HtR HbR) Hrlt). }
            claim Hrlt3: Rlt (apply_fun flip_unit_interval t) b.
            { rewrite (flip_unit_interval_apply t HtI).
              exact Hrlt2. }
            claim Hrel2: order_rel R (apply_fun flip_unit_interval t) b.
            { exact (Rlt_implies_order_rel_R (apply_fun flip_unit_interval t) b Hrlt3). }
            claim HimgR: apply_fun flip_unit_interval t :e R.
            { exact (HfunR t HtI). }
            claim Himg: apply_fun flip_unit_interval t :e open_ray_lower R b.
            { exact (SepI R (fun x0 : set => order_rel R x0 b) (apply_fun flip_unit_interval t) HimgR Hrel2). }
            exact (SepI unit_interval (fun u : set => apply_fun flip_unit_interval u :e open_ray_lower R b) t HtI Himg). }

        rewrite HpreEq.
        set Z0 := open_ray_upper R c.
        claim HZ0open: Z0 :e R_standard_topology.
        { rewrite <- standard_topology_is_order_topology.
          claim HsRay: Z0 :e open_rays_subbasis R.
          { exact (open_ray_upper_in_open_rays_subbasis R c HcR). }
          exact (open_rays_subbasis_sub_order_topology R Z0 HsRay). }
        claim HZ0cap: Z0 :/\: unit_interval :e Tx.
        { prove Z0 :/\: unit_interval :e {W :e Power unit_interval | exists Z :e R_standard_topology, W = Z :/\: unit_interval}.
          claim Hpow: Z0 :/\: unit_interval :e Power unit_interval.
          { apply PowerI.
            let t. assume Ht: t :e Z0 :/\: unit_interval.
            exact (binintersectE2 Z0 unit_interval t Ht). }
          claim Hex: exists Z :e R_standard_topology, Z0 :/\: unit_interval = Z :/\: unit_interval.
          { witness Z0.
            apply andI.
            - exact HZ0open.
            - reflexivity. }
          exact (SepI (Power unit_interval)
                      (fun W0 : set => exists Z :e R_standard_topology, W0 = Z :/\: unit_interval)
                      (Z0 :/\: unit_interval) Hpow Hex). }
        exact HZ0cap.
      + exact Hs0.
    - assume HsR: s :e {R}.
      claim Hseq: s = R.
      { exact (SingE R s HsR). }
      rewrite Hseq.
      claim Heq: preimage_of unit_interval flip_unit_interval R = unit_interval.
      { exact (preimage_of_whole unit_interval R flip_unit_interval HfunR). }
      rewrite Heq.
      exact (topology_has_X unit_interval Tx HTx).
    - exact HsS. }

  exact (continuous_map_from_subbasis unit_interval Tx R S flip_unit_interval
          HTx HfunR HS HpreS). }

claim Himg: forall t:set, t :e unit_interval -> apply_fun flip_unit_interval t :e unit_interval.
{ let t. assume Ht: t :e unit_interval.
  exact (flip_unit_interval_function_on t Ht). }

exact (continuous_map_range_restrict unit_interval Tx R R_standard_topology flip_unit_interval unit_interval
        HcontR unit_interval_sub_R Himg).
Qed.

(** from 18 Definition: homeomorphism **) 
(** LATEX VERSION: A homeomorphism is a bijective continuous map whose inverse is continuous. **)
Definition homeomorphism : set -> set -> set -> set -> set -> prop :=
  fun X Tx Y Ty f =>
    continuous_map X Tx Y Ty f /\
    exists g:set, continuous_map Y Ty X Tx g /\
      (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
      (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y).

(** Helper: extract continuous_map from homeomorphism **)
Theorem homeomorphism_continuous : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f -> continuous_map X Tx Y Ty f.
let X Tx Y Ty f.
assume H: homeomorphism X Tx Y Ty f.
exact (andEL (continuous_map X Tx Y Ty f)
             (exists g:set, continuous_map Y Ty X Tx g /\
               (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
               (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y))
             H).
Qed.

(** Helper: extract existence of inverse package from homeomorphism **)
Theorem homeomorphism_inverse_package : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f ->
  exists g:set, continuous_map Y Ty X Tx g /\
    (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
    (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y).
let X Tx Y Ty f.
assume H: homeomorphism X Tx Y Ty f.
exact (andER (continuous_map X Tx Y Ty f)
             (exists g:set, continuous_map Y Ty X Tx g /\
               (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
               (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y))
             H).
Qed.

(** helper: homeomorphism implies both are topological spaces **)
Theorem homeomorphism_topology_left : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f -> topology_on X Tx.
let X Tx Y Ty f.
assume Hhom: homeomorphism X Tx Y Ty f.
exact (continuous_map_topology_dom X Tx Y Ty f (homeomorphism_continuous X Tx Y Ty f Hhom)).
Qed.

Theorem homeomorphism_topology_right : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f -> topology_on Y Ty.
let X Tx Y Ty f.
assume Hhom: homeomorphism X Tx Y Ty f.
exact (continuous_map_topology_cod X Tx Y Ty f (homeomorphism_continuous X Tx Y Ty f Hhom)).
Qed.

(** from 16 Exercise 8: helper definition of straight line by affine equation **)
(** LATEX VERSION: A straight line in RR can be described by an affine equation ax+by=c with not both a and b zero. **)
Definition affine_line_R2 : set -> set -> set -> set :=
  fun a b c =>
    {p :e EuclidPlane |
      add_SNo (mul_SNo a (R2_xcoord p)) (mul_SNo b (R2_ycoord p)) = c}.

(** Helper: affine_line_R2 is a subset of EuclidPlane **)
Theorem affine_line_R2_subset : forall a b c:set, affine_line_R2 a b c c= EuclidPlane.
let a b c.
prove affine_line_R2 a b c c= EuclidPlane.
let p.
assume Hp: p :e affine_line_R2 a b c.
exact (SepE1 EuclidPlane
         (fun p0:set => add_SNo (mul_SNo a (R2_xcoord p0)) (mul_SNo b (R2_ycoord p0)) = c)
         p Hp).
Qed.

(** Helper: affine_line_R2 is in Power EuclidPlane **)
Theorem affine_line_R2_in_Power : forall a b c:set, affine_line_R2 a b c :e Power EuclidPlane.
let a b c.
exact (PowerI EuclidPlane (affine_line_R2 a b c) (affine_line_R2_subset a b c)).
Qed.

(** Helper: affine_line_R2 is a subset of setprod R R **)
Theorem affine_line_R2_subset_R2 : forall a b c:set, affine_line_R2 a b c c= setprod R R.
let a b c.
claim Heq: EuclidPlane = setprod R R.
{ reflexivity. }
rewrite <- Heq.
exact (affine_line_R2_subset a b c).
Qed.

(** Helper: affine_line_R2 is in Power (setprod R R) **)
Theorem affine_line_R2_in_Power_R2 : forall a b c:set, affine_line_R2 a b c :e Power (setprod R R).
let a b c.
exact (PowerI (setprod R R) (affine_line_R2 a b c) (affine_line_R2_subset_R2 a b c)).
Qed.

(** from 16 Exercise 8: parametrizations of affine lines **)
(** LATEX VERSION: For ax+by=c, if b is not zero one can solve for y as a function of x; if b=0 one can solve for x as a constant and parametrize by y. **)
Definition affine_line_R2_param_by_x : set -> set -> set -> set :=
  fun a b c =>
    graph R (fun x:set => (x, div_SNo (add_SNo c (minus_SNo (mul_SNo a x))) b)).

Definition affine_line_R2_param_by_y : set -> set -> set -> set :=
  fun a b c =>
    graph R (fun y:set => (div_SNo c a, y)).

(** Helper: apply_fun on affine_line_R2_param_by_x **)
Theorem affine_line_R2_param_by_x_apply : forall a b c x:set,
  x :e R ->
  apply_fun (affine_line_R2_param_by_x a b c) x =
    (x, div_SNo (add_SNo c (minus_SNo (mul_SNo a x))) b).
let a b c x.
assume HxR: x :e R.
exact (apply_fun_graph R (fun x0:set => (x0, div_SNo (add_SNo c (minus_SNo (mul_SNo a x0))) b)) x HxR).
Qed.
(** Helper: apply_fun on affine_line_R2_param_by_y **)
Theorem affine_line_R2_param_by_y_apply : forall a b c y:set,
  y :e R ->
  apply_fun (affine_line_R2_param_by_y a b c) y = (div_SNo c a, y).
let a b c y.
assume HyR: y :e R.
exact (apply_fun_graph R (fun y0:set => (div_SNo c a, y0)) y HyR).
Qed.

(** Helper: projection2 composed with affine_line_R2_param_by_y is the identity on R **)
Theorem projection2_after_affine_line_R2_param_by_y : forall a b c y:set,
  a :e R -> c :e R -> y :e R ->
  apply_fun (projection2 R R) (apply_fun (affine_line_R2_param_by_y a b c) y) = y.
let a b c y.
assume HaR: a :e R.
assume HcR: c :e R.
assume HyR: y :e R.
rewrite (affine_line_R2_param_by_y_apply a b c y HyR).
set x0 := div_SNo c a.
claim Hx0R: x0 :e R.
{ claim HdefR: R = real.
  { reflexivity. }
  claim HaReal: a :e real.
  { rewrite <- HdefR. exact HaR. }
  claim HcReal: c :e real.
  { rewrite <- HdefR. exact HcR. }
  claim Hx0Real: x0 :e real.
  { exact (real_div_SNo c HcReal a HaReal). }
  rewrite HdefR.
  exact Hx0Real. }
claim Hxy: (x0,y) :e setprod R R.
{ exact (tuple_2_setprod_by_pair_Sigma R R x0 y Hx0R HyR). }
claim Happ2: apply_fun (projection2 R R) (x0,y) = (x0,y) 1.
{ exact (projection2_apply R R (x0,y) Hxy). }
rewrite Happ2.
exact (tuple_2_1_eq x0 y).
Qed.

(** Helper: affine_line_R2_param_by_y after projection2 is identity on the vertical slice **)
Theorem affine_line_R2_param_by_y_after_projection2_on_slice : forall a b c p:set,
  a :e R -> c :e R ->
  p :e setprod {div_SNo c a} R ->
  apply_fun (affine_line_R2_param_by_y a b c) (apply_fun (projection2 R R) p) = p.
let a b c p.
assume HaR: a :e R.
assume HcR: c :e R.
assume Hp: p :e setprod {div_SNo c a} R.
set x0 := div_SNo c a.
claim Hp0Sing: (p 0) :e {x0}.
{ exact (ap0_Sigma {x0} (fun _ : set => R) p Hp). }
claim Hp1R: (p 1) :e R.
{ exact (ap1_Sigma {x0} (fun _ : set => R) p Hp). }
claim Hp0eq: (p 0) = x0.
{ exact (singleton_elem (p 0) x0 Hp0Sing). }
claim Heta: p = (p 0, p 1).
{ exact (setprod_eta {x0} R p Hp). }
claim HpRR: p :e setprod R R.
{ claim HSingSub: {x0} c= R.
  { claim HdefR: R = real.
    { reflexivity. }
    claim HaReal: a :e real.
    { rewrite <- HdefR. exact HaR. }
    claim HcReal: c :e real.
    { rewrite <- HdefR. exact HcR. }
    claim Hx0Real: x0 :e real.
    { exact (real_div_SNo c HcReal a HaReal). }
    claim Hx0R: x0 :e R.
    { rewrite HdefR. exact Hx0Real. }
    exact (singleton_subset x0 R Hx0R). }
  exact (setprod_Subq {x0} R R R HSingSub (Subq_ref R) p Hp). }
claim Happ2: apply_fun (projection2 R R) p = p 1.
{ exact (projection2_apply R R p HpRR). }
rewrite Happ2.
rewrite (affine_line_R2_param_by_y_apply a b c (p 1) Hp1R).
rewrite <- Hp0eq.
rewrite <- Heta.
reflexivity.
Qed.

(** Helper: affine_line_R2_param_by_x maps into EuclidPlane **)
Theorem affine_line_R2_param_by_x_function_on : forall a b c:set,
  a :e R -> b :e R -> c :e R ->
  function_on (affine_line_R2_param_by_x a b c) R EuclidPlane.
let a b c.
assume HaR: a :e R.
assume HbR: b :e R.
assume HcR: c :e R.
let x. assume HxR: x :e R.
prove apply_fun (affine_line_R2_param_by_x a b c) x :e EuclidPlane.
rewrite (affine_line_R2_param_by_x_apply a b c x HxR).
claim HdefR: R = real.
{ reflexivity. }
claim HaReal: a :e real.
{ rewrite <- HdefR. exact HaR. }
claim HbReal: b :e real.
{ rewrite <- HdefR. exact HbR. }
claim HcReal: c :e real.
{ rewrite <- HdefR. exact HcR. }
claim HxReal: x :e real.
{ rewrite <- HdefR. exact HxR. }
claim HmulReal: mul_SNo a x :e real.
{ exact (real_mul_SNo a HaReal x HxReal). }
claim HmReal: minus_SNo (mul_SNo a x) :e real.
{ exact (real_minus_SNo (mul_SNo a x) HmulReal). }
claim HnumReal: add_SNo c (minus_SNo (mul_SNo a x)) :e real.
{ exact (real_add_SNo c HcReal (minus_SNo (mul_SNo a x)) HmReal). }
claim HdivReal: div_SNo (add_SNo c (minus_SNo (mul_SNo a x))) b :e real.
{ exact (real_div_SNo (add_SNo c (minus_SNo (mul_SNo a x))) HnumReal b HbReal). }
claim HdivR: div_SNo (add_SNo c (minus_SNo (mul_SNo a x))) b :e R.
{ rewrite HdefR. exact HdivReal. }
exact (tuple_2_setprod_by_pair_Sigma R R x (div_SNo (add_SNo c (minus_SNo (mul_SNo a x))) b) HxR HdivR).
Qed.

(** Helper: projection1 composed with affine_line_R2_param_by_x is the identity on R **)
Theorem projection1_after_affine_line_R2_param_by_x : forall a b c x:set,
  a :e R -> b :e R -> c :e R -> x :e R ->
  apply_fun (projection1 R R) (apply_fun (affine_line_R2_param_by_x a b c) x) = x.
let a b c x.
assume HaR: a :e R.
assume HbR: b :e R.
assume HcR: c :e R.
assume HxR: x :e R.
set f := affine_line_R2_param_by_x a b c.
claim Hfx: apply_fun f x :e EuclidPlane.
{ exact (affine_line_R2_param_by_x_function_on a b c HaR HbR HcR x HxR). }
claim Happ1: apply_fun (projection1 R R) (apply_fun f x) = (apply_fun f x) 0.
{ exact (projection1_apply R R (apply_fun f x) Hfx). }
rewrite Happ1.
rewrite (affine_line_R2_param_by_x_apply a b c x HxR).
exact (tuple_2_0_eq x (div_SNo (add_SNo c (minus_SNo (mul_SNo a x))) b)).
Qed.

(** Helper: affine_line_R2_param_by_y maps into EuclidPlane **)
Theorem affine_line_R2_param_by_y_function_on : forall a b c:set,
  a :e R -> b :e R -> c :e R ->
  function_on (affine_line_R2_param_by_y a b c) R EuclidPlane.
let a b c.
assume HaR: a :e R.
assume HbR: b :e R.
assume HcR: c :e R.
let y. assume HyR: y :e R.
prove apply_fun (affine_line_R2_param_by_y a b c) y :e EuclidPlane.
rewrite (affine_line_R2_param_by_y_apply a b c y HyR).
claim HdefR: R = real.
{ reflexivity. }
claim HaReal: a :e real.
{ rewrite <- HdefR. exact HaR. }
claim HcReal: c :e real.
{ rewrite <- HdefR. exact HcR. }
claim HdivReal: div_SNo c a :e real.
{ exact (real_div_SNo c HcReal a HaReal). }
claim HdivR: div_SNo c a :e R.
{ rewrite HdefR. exact HdivReal. }
exact (tuple_2_setprod_by_pair_Sigma R R (div_SNo c a) y HdivR HyR).
Qed.

(** Helper: projection1 is continuous for the product topology **)
(** LATEX VERSION: Coordinate projections are continuous for the product topology. **)
Theorem projection1_continuous_in_product : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection1 X Y).
let X Tx Y Ty.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection1 X Y).
prove topology_on (setprod X Y) (product_topology X Tx Y Ty) /\ topology_on X Tx /\
  function_on (projection1 X Y) (setprod X Y) X /\
  forall U:set, U :e Tx -> preimage_of (setprod X Y) (projection1 X Y) U :e product_topology X Tx Y Ty.
apply andI.
- apply andI.
  + apply andI.
    * exact (product_topology_is_topology X Tx Y Ty HTx HTy).
    * exact HTx.
  + (** function_on **)
    let p. assume Hp: p :e setprod X Y.
    prove apply_fun (projection1 X Y) p :e X.
    claim Happ: apply_fun (projection1 X Y) p = p 0.
    { exact (projection1_apply X Y p Hp). }
    rewrite Happ.
    exact (ap0_Sigma X (fun _ : set => Y) p Hp).
- let U. assume HU: U :e Tx.
  prove preimage_of (setprod X Y) (projection1 X Y) U :e product_topology X Tx Y Ty.
  claim HUsub: U c= X.
  { exact (topology_elem_subset X Tx U HTx HU). }
  claim HpreEq: preimage_of (setprod X Y) (projection1 X Y) U = rectangle_set U Y.
  { exact (preimage_projection1_rectangle X Y U HUsub). }
  rewrite HpreEq.
  claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
  { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
  claim HYTy: Y :e Ty.
  { exact (topology_has_X Y Ty HTy). }
  claim HRsub: rectangle_set U Y :e product_subbasis X Tx Y Ty.
  { claim HRfam: rectangle_set U Y :e {rectangle_set U V0|V0 :e Ty}.
    { exact (ReplI Ty (fun V0:set => rectangle_set U V0) Y HYTy). }
    exact (famunionI Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) U (rectangle_set U Y) HU HRfam). }
  exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis (rectangle_set U Y) HRsub).
Qed.

(** Helper: projection2 is continuous for the product topology **)
(** LATEX VERSION: Coordinate projections are continuous for the product topology. **)
Theorem projection2_continuous_in_product : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection2 X Y).
let X Tx Y Ty.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection2 X Y).
prove topology_on (setprod X Y) (product_topology X Tx Y Ty) /\ topology_on Y Ty /\
  function_on (projection2 X Y) (setprod X Y) Y /\
  forall V:set, V :e Ty -> preimage_of (setprod X Y) (projection2 X Y) V :e product_topology X Tx Y Ty.
apply andI.
- apply andI.
  + apply andI.
    * exact (product_topology_is_topology X Tx Y Ty HTx HTy).
    * exact HTy.
  + (** function_on **)
    let p. assume Hp: p :e setprod X Y.
    prove apply_fun (projection2 X Y) p :e Y.
    claim Happ: apply_fun (projection2 X Y) p = p 1.
    { exact (projection2_apply X Y p Hp). }
    rewrite Happ.
    exact (ap1_Sigma X (fun _ : set => Y) p Hp).
- let V. assume HV: V :e Ty.
  prove preimage_of (setprod X Y) (projection2 X Y) V :e product_topology X Tx Y Ty.
  claim HVsub: V c= Y.
  { exact (topology_elem_subset Y Ty V HTy HV). }
  claim HpreEq: preimage_of (setprod X Y) (projection2 X Y) V = rectangle_set X V.
  { exact (preimage_projection2_rectangle X Y V HVsub). }
  rewrite HpreEq.
  claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
  { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
  claim HXTx: X :e Tx.
  { exact (topology_has_X X Tx HTx). }
  claim HRsub: rectangle_set X V :e product_subbasis X Tx Y Ty.
  { claim HRfam: rectangle_set X V :e {rectangle_set X V0|V0 :e Ty}.
    { exact (ReplI Ty (fun V0:set => rectangle_set X V0) V HV). }
    exact (famunionI Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) X (rectangle_set X V) HXTx HRfam). }
  exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis (rectangle_set X V) HRsub).
Qed.

(** Helper: projection2 is continuous on a vertical slice as a subspace **)
(** LATEX VERSION: The projection to the second factor is continuous when restricted to any vertical slice {x0}Y with the subspace topology. **)
Theorem projection2_continuous_on_vertical_slice : forall x0 Tx Ty:set,
  topology_on R Tx -> topology_on R Ty -> x0 :e R ->
  continuous_map (setprod {x0} R)
    (subspace_topology EuclidPlane (product_topology R Tx R Ty) (setprod {x0} R))
    R Ty (projection2 R R).
let x0 Tx Ty.
assume HTx: topology_on R Tx.
assume HTy: topology_on R Ty.
assume Hx0R: x0 :e R.
set X := EuclidPlane.
set A := setprod {x0} R.
set Tprod := product_topology R Tx R Ty.
set Ta := subspace_topology X Tprod A.
claim HTprod: topology_on X Tprod.
{ exact (product_topology_is_topology R Tx R Ty HTx HTy). }
claim HAsub: A c= X.
{ let p. assume HpA: p :e A.
  prove p :e X.
  claim HSingSub: {x0} c= R.
  { exact (singleton_subset x0 R Hx0R). }
  exact (setprod_Subq {x0} R R R HSingSub (Subq_ref R) p HpA). }
claim HTa: topology_on A Ta.
{ exact (subspace_topology_is_topology X Tprod A HTprod HAsub). }
prove continuous_map A Ta R Ty (projection2 R R).
prove topology_on A Ta /\ topology_on R Ty /\ function_on (projection2 R R) A R /\
  forall V:set, V :e Ty -> preimage_of A (projection2 R R) V :e Ta.
apply andI.
- apply andI.
  + apply andI.
    * exact HTa.
    * exact HTy.
  + (** function_on **)
    let p. assume HpA: p :e A.
    prove apply_fun (projection2 R R) p :e R.
    claim HpRR: p :e setprod R R.
    { claim HSingSub: {x0} c= R.
      { exact (singleton_subset x0 R Hx0R). }
      exact (setprod_Subq {x0} R R R HSingSub (Subq_ref R) p HpA). }
    claim Happ: apply_fun (projection2 R R) p = p 1.
    { exact (projection2_apply R R p HpRR). }
    rewrite Happ.
    exact (ap1_Sigma {x0} (fun _ : set => R) p HpA).
- let V. assume HV: V :e Ty.
  prove preimage_of A (projection2 R R) V :e Ta.
  set U := preimage_of X (projection2 R R) V.
  claim HcontFull: continuous_map X Tprod R Ty (projection2 R R).
  { exact (projection2_continuous_in_product R Tx R Ty HTx HTy). }
  claim HUopen: U :e Tprod.
  { exact (continuous_map_preimage X Tprod R Ty (projection2 R R) HcontFull V HV). }
  claim HeqPre: preimage_of A (projection2 R R) V = U :/\: A.
  { apply set_ext.
    - let p. assume Hp: p :e preimage_of A (projection2 R R) V.
      prove p :e U :/\: A.
      claim HpA: p :e A.
      { exact (SepE1 A (fun q:set => apply_fun (projection2 R R) q :e V) p Hp). }
      claim HpRR: p :e setprod R R.
      { claim HSingSub: {x0} c= R.
        { exact (singleton_subset x0 R Hx0R). }
        exact (setprod_Subq {x0} R R R HSingSub (Subq_ref R) p HpA). }
      claim HprojV: apply_fun (projection2 R R) p :e V.
      { exact (SepE2 A (fun q:set => apply_fun (projection2 R R) q :e V) p Hp). }
      claim HpX: p :e X.
      { exact HpRR. }
      claim HpU: p :e U.
      { exact (SepI X (fun q:set => apply_fun (projection2 R R) q :e V) p HpX HprojV). }
      exact (binintersectI U A p HpU HpA).
    - let p. assume Hp: p :e U :/\: A.
      prove p :e preimage_of A (projection2 R R) V.
      claim HpU: p :e U.
      { exact (binintersectE1 U A p Hp). }
      claim HpA: p :e A.
      { exact (binintersectE2 U A p Hp). }
      claim HprojV: apply_fun (projection2 R R) p :e V.
      { exact (SepE2 X (fun q:set => apply_fun (projection2 R R) q :e V) p HpU). }
      exact (SepI A (fun q:set => apply_fun (projection2 R R) q :e V) p HpA HprojV). }
  rewrite HeqPre.
  claim Hpow: (U :/\: A) :e Power A.
  { apply PowerI.
    let p. assume Hp: p :e U :/\: A.
    exact (binintersectE2 U A p Hp). }
  claim HexW: exists W :e Tprod, U :/\: A = W :/\: A.
  { witness U.
    apply andI.
    - exact HUopen.
    - reflexivity. }
  exact (SepI (Power A) (fun U0:set => exists W :e Tprod, U0 = W :/\: A) (U :/\: A) Hpow HexW).
Qed.

(** Helper: affine_line_R2_param_by_y is continuous into product_topology, with the domain using the second-factor topology **)
(** LATEX VERSION: The map y  (x0,y) is continuous into a product topology, since the preimage of each basic rectangle is either the corresponding second-factor open set or empty. **)
Theorem affine_line_R2_param_by_y_continuous_in_product : forall a b c Tx Ty:set,
  topology_on R Tx -> topology_on R Ty ->
  a :e R -> c :e R ->
  continuous_map R Ty EuclidPlane (product_topology R Tx R Ty) (affine_line_R2_param_by_y a b c).
let a b c Tx Ty.
assume HTx: topology_on R Tx.
assume HTy: topology_on R Ty.
assume HaR: a :e R.
assume HcR: c :e R.
set f := affine_line_R2_param_by_y a b c.
set X := EuclidPlane.
set Tprod := product_topology R Tx R Ty.
prove continuous_map R Ty X Tprod f.
prove topology_on R Ty /\ topology_on X Tprod /\ function_on f R X /\
  forall W:set, W :e Tprod -> preimage_of R f W :e Ty.
apply andI.
- apply andI.
  + apply andI.
    * exact HTy.
    * exact (product_topology_is_topology R Tx R Ty HTx HTy).
  + (** function_on **)
    let y. assume HyR: y :e R.
    prove apply_fun f y :e X.
    rewrite (affine_line_R2_param_by_y_apply a b c y HyR).
    claim HdefR: R = real.
    { reflexivity. }
    claim HaReal: a :e real.
    { rewrite <- HdefR. exact HaR. }
    claim HcReal: c :e real.
    { rewrite <- HdefR. exact HcR. }
    claim Hx0Real: div_SNo c a :e real.
    { exact (real_div_SNo c HcReal a HaReal). }
    claim Hx0R: div_SNo c a :e R.
    { rewrite HdefR. exact Hx0Real. }
    exact (tuple_2_setprod_by_pair_Sigma R R (div_SNo c a) y Hx0R HyR).
- let W. assume HW: W :e Tprod.
  prove preimage_of R f W :e Ty.
  claim HBasis: basis_on X (product_subbasis R Tx R Ty).
  { exact (product_subbasis_is_basis R Tx R Ty HTx HTy). }
  claim HWopen: open_in X Tprod W.
  { exact (andI (topology_on X Tprod) (W :e Tprod)
                (product_topology_is_topology R Tx R Ty HTx HTy) HW). }
  apply (open_sets_as_unions_of_basis X (product_subbasis R Tx R Ty) HBasis W HWopen).
  let Fam. assume HFamPair.
  claim HFamPow: Fam :e Power (product_subbasis R Tx R Ty).
  { exact (andEL (Fam :e Power (product_subbasis R Tx R Ty)) (Union Fam = W) HFamPair). }
  claim HUnionEq: Union Fam = W.
  { exact (andER (Fam :e Power (product_subbasis R Tx R Ty)) (Union Fam = W) HFamPair). }
  claim HFamSub: Fam c= product_subbasis R Tx R Ty.
  { exact (PowerE (product_subbasis R Tx R Ty) Fam HFamPow). }
  set PreFam := {preimage_of R f b0|b0 :e Fam}.
  claim HpreEq1: preimage_of R f W = preimage_of R f (Union Fam).
  { rewrite <- HUnionEq.
    reflexivity. }
  claim HpreEq2: preimage_of R f (Union Fam) = Union PreFam.
  { rewrite (preimage_of_Union R f Fam).
    reflexivity. }
  rewrite HpreEq1.
  rewrite HpreEq2.
  claim HPreFamSub: PreFam c= Ty.
  { let P. assume HP: P :e PreFam.
    apply (ReplE_impred Fam (fun b0:set => preimage_of R f b0) P HP).
    let b0. assume Hb0Fam: b0 :e Fam.
    assume HPeq: P = preimage_of R f b0.
    claim Hb0Sub: b0 :e product_subbasis R Tx R Ty.
    { exact (HFamSub b0 Hb0Fam). }
    claim HexU: exists U :e Tx, b0 :e {rectangle_set U V|V :e Ty}.
    { exact (famunionE Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) b0 Hb0Sub). }
    apply HexU.
    let U. assume HUconj: U :e Tx /\ b0 :e {rectangle_set U V|V :e Ty}.
    claim HU: U :e Tx.
    { exact (andEL (U :e Tx) (b0 :e {rectangle_set U V|V :e Ty}) HUconj). }
    claim Hb0Repl: b0 :e {rectangle_set U V|V :e Ty}.
    { exact (andER (U :e Tx) (b0 :e {rectangle_set U V|V :e Ty}) HUconj). }
    claim HexV: exists V :e Ty, b0 = rectangle_set U V.
    { exact (ReplE Ty (fun V0:set => rectangle_set U V0) b0 Hb0Repl). }
    apply HexV.
    let V. assume HVconj: V :e Ty /\ b0 = rectangle_set U V.
    claim HV: V :e Ty.
    { exact (andEL (V :e Ty) (b0 = rectangle_set U V) HVconj). }
    claim Hbeq: b0 = rectangle_set U V.
    { exact (andER (V :e Ty) (b0 = rectangle_set U V) HVconj). }
    rewrite HPeq.
    rewrite Hbeq.
    set x0 := div_SNo c a.
    claim Hx0R: x0 :e R.
    { claim HdefR: R = real.
      { reflexivity. }
      claim HaReal: a :e real.
      { rewrite <- HdefR. exact HaR. }
      claim HcReal: c :e real.
      { rewrite <- HdefR. exact HcR. }
      claim Hx0Real: x0 :e real.
      { exact (real_div_SNo c HcReal a HaReal). }
      rewrite HdefR.
      exact Hx0Real. }
    apply (xm (x0 :e U)).
    - assume Hx0U: x0 :e U.
      claim HVR: V c= R.
      { exact (topology_elem_subset R Ty V HTy HV). }
      claim HeqPre: preimage_of R f (rectangle_set U V) = V.
      { apply set_ext.
        - let y. assume Hy: y :e preimage_of R f (rectangle_set U V).
          prove y :e V.
          claim HyR: y :e R.
          { exact (SepE1 R (fun y0:set => apply_fun f y0 :e rectangle_set U V) y Hy). }
          claim Hfy: apply_fun f y :e rectangle_set U V.
          { exact (SepE2 R (fun y0:set => apply_fun f y0 :e rectangle_set U V) y Hy). }
          claim Happ: apply_fun f y = (x0,y).
          { rewrite (affine_line_R2_param_by_y_apply a b c y HyR).
            reflexivity. }
          claim Hxy: (x0,y) :e rectangle_set U V.
          { rewrite <- Happ.
            exact Hfy. }
          claim HyV0: (x0,y) 1 :e V.
          { exact (ap1_Sigma U (fun _ : set => V) (x0,y) Hxy). }
          claim HyV: y :e V.
          { rewrite <- (tuple_2_1_eq x0 y).
            exact HyV0. }
          exact HyV.
        - let y. assume HyV: y :e V.
          prove y :e preimage_of R f (rectangle_set U V).
          claim HyR: y :e R.
          { exact (HVR y HyV). }
	          claim Hxy: (x0,y) :e rectangle_set U V.
	          { exact (tuple_2_rectangle_set U V x0 y Hx0U HyV). }
          claim Happ: apply_fun f y = (x0,y).
          { rewrite (affine_line_R2_param_by_y_apply a b c y HyR).
            reflexivity. }
          claim Hprop: apply_fun f y :e rectangle_set U V.
          { rewrite Happ.
            exact Hxy. }
          exact (SepI R (fun y0:set => apply_fun f y0 :e rectangle_set U V) y HyR Hprop). }
      rewrite HeqPre.
      exact HV.
    - assume Hx0notU: ~ (x0 :e U).
      claim HeqPre: preimage_of R f (rectangle_set U V) = Empty.
      { apply set_ext.
        - let y. assume Hy: y :e preimage_of R f (rectangle_set U V).
          apply FalseE.
          claim HyR: y :e R.
          { exact (SepE1 R (fun y0:set => apply_fun f y0 :e rectangle_set U V) y Hy). }
          claim Hfy: apply_fun f y :e rectangle_set U V.
          { exact (SepE2 R (fun y0:set => apply_fun f y0 :e rectangle_set U V) y Hy). }
          claim Happ: apply_fun f y = (x0,y).
          { rewrite (affine_line_R2_param_by_y_apply a b c y HyR).
            reflexivity. }
          claim Hxy: (x0,y) :e rectangle_set U V.
          { rewrite <- Happ.
            exact Hfy. }
          claim Hx0U0: (x0,y) 0 :e U.
          { exact (ap0_Sigma U (fun _ : set => V) (x0,y) Hxy). }
          claim Hx0U: x0 :e U.
          { rewrite <- (tuple_2_0_eq x0 y).
            exact Hx0U0. }
          exact (Hx0notU Hx0U).
        - let y. assume Hy: y :e Empty.
          apply FalseE.
          exact (EmptyE y Hy). }
      rewrite HeqPre.
      exact (topology_has_empty R Ty HTy). }
  claim HPreFamPow: PreFam :e Power Ty.
  { apply PowerI.
    exact HPreFamSub. }
  exact (topology_union_axiom R Ty HTy PreFam HPreFamPow).
Qed.

(** Helper: param by x lands in the affine line when b is not zero **)
Theorem affine_line_R2_param_by_x_in_line : forall a b c x:set,
  a :e R -> b :e R -> c :e R -> x :e R ->
  b <> 0 ->
  apply_fun (affine_line_R2_param_by_x a b c) x :e affine_line_R2 a b c.
let a b c x.
assume HaR: a :e R.
assume HbR: b :e R.
assume HcR: c :e R.
assume HxR: x :e R.
assume Hb0: b <> 0.
prove apply_fun (affine_line_R2_param_by_x a b c) x :e affine_line_R2 a b c.
rewrite (affine_line_R2_param_by_x_apply a b c x HxR).
set y := div_SNo (add_SNo c (minus_SNo (mul_SNo a x))) b.
claim Hydef: y = div_SNo (add_SNo c (minus_SNo (mul_SNo a x))) b.
{ reflexivity. }
rewrite <- Hydef.
prove (x,y) :e affine_line_R2 a b c.
claim Hdef: affine_line_R2 a b c =
  {p :e EuclidPlane | add_SNo (mul_SNo a (R2_xcoord p)) (mul_SNo b (R2_ycoord p)) = c}.
{ reflexivity. }
rewrite Hdef.
claim HxyPlane: (x,y) :e EuclidPlane.
{ claim HdefR: R = real.
  { reflexivity. }
  claim HaReal: a :e real.
  { rewrite <- HdefR. exact HaR. }
  claim HbReal: b :e real.
  { rewrite <- HdefR. exact HbR. }
  claim HcReal: c :e real.
  { rewrite <- HdefR. exact HcR. }
  claim HxReal: x :e real.
  { rewrite <- HdefR. exact HxR. }
  claim HmulReal: mul_SNo a x :e real.
  { exact (real_mul_SNo a HaReal x HxReal). }
  claim HmReal: minus_SNo (mul_SNo a x) :e real.
  { exact (real_minus_SNo (mul_SNo a x) HmulReal). }
  claim HnumReal: add_SNo c (minus_SNo (mul_SNo a x)) :e real.
  { exact (real_add_SNo c HcReal (minus_SNo (mul_SNo a x)) HmReal). }
  claim HyReal: y :e real.
  { rewrite Hydef.
    exact (real_div_SNo (add_SNo c (minus_SNo (mul_SNo a x))) HnumReal b HbReal). }
  claim HyR: y :e R.
  { rewrite HdefR. exact HyReal. }
  exact (tuple_2_setprod_by_pair_Sigma R R x y HxR HyR). }

claim Hprop: add_SNo (mul_SNo a (R2_xcoord (x,y))) (mul_SNo b (R2_ycoord (x,y))) = c.
{ claim HdefR: R = real.
  { reflexivity. }
  claim HaReal: a :e real.
  { rewrite <- HdefR. exact HaR. }
  claim HbReal: b :e real.
  { rewrite <- HdefR. exact HbR. }
  claim HcReal: c :e real.
  { rewrite <- HdefR. exact HcR. }
  claim HxReal: x :e real.
  { rewrite <- HdefR. exact HxR. }
  claim HaS: SNo a.
  { exact (real_SNo a HaReal). }
  claim HbS: SNo b.
  { exact (real_SNo b HbReal). }
  claim HcS: SNo c.
  { exact (real_SNo c HcReal). }
  claim HxS: SNo x.
  { exact (real_SNo x HxReal). }
  claim HaxS: SNo (mul_SNo a x).
  { exact (SNo_mul_SNo a x HaS HxS). }
  claim HnumS: SNo (add_SNo c (minus_SNo (mul_SNo a x))).
  { exact (SNo_add_SNo c (minus_SNo (mul_SNo a x)) HcS (SNo_minus_SNo (mul_SNo a x) HaxS)). }
  claim HyS: SNo y.
  { rewrite Hydef.
    exact (SNo_div_SNo (add_SNo c (minus_SNo (mul_SNo a x))) b HnumS HbS). }
  claim Hbmul: mul_SNo b y = add_SNo c (minus_SNo (mul_SNo a x)).
  { rewrite Hydef.
    rewrite (mul_div_SNo_invR (add_SNo c (minus_SNo (mul_SNo a x))) b HnumS HbS Hb0).
    reflexivity. }
  rewrite (R2_xcoord_tuple x y).
  rewrite (R2_ycoord_tuple x y).
  rewrite Hbmul.
  (** simplify ax + (c - ax) = c **)
  claim HaxS2: SNo (mul_SNo a x).
  { exact HaxS. }
  claim HmAxS: SNo (minus_SNo (mul_SNo a x)).
  { exact (SNo_minus_SNo (mul_SNo a x) HaxS2). }
  rewrite (add_SNo_assoc (mul_SNo a x) c (minus_SNo (mul_SNo a x)) HaxS2 HcS HmAxS).
  rewrite (add_SNo_com (mul_SNo a x) c HaxS2 HcS).
  rewrite <- (add_SNo_assoc c (mul_SNo a x) (minus_SNo (mul_SNo a x)) HcS HaxS2 HmAxS).
  rewrite (add_SNo_minus_SNo_rinv (mul_SNo a x) HaxS2).
  exact (add_SNo_0R c HcS). }

exact (SepI EuclidPlane
        (fun p0:set => add_SNo (mul_SNo a (R2_xcoord p0)) (mul_SNo b (R2_ycoord p0)) = c)
        (x,y)
        HxyPlane
        Hprop).
Qed.

(** Helper: affine_line_R2_param_by_x after projection1 is identity on the line (when b is not zero) **)
Theorem affine_line_R2_param_by_x_after_projection1_on_line : forall a b c p:set,
  a :e R -> b :e R -> c :e R -> b <> 0 ->
  p :e affine_line_R2 a b c ->
  apply_fun (affine_line_R2_param_by_x a b c) (apply_fun (projection1 R R) p) = p.
let a b c p.
assume HaR: a :e R.
assume HbR: b :e R.
assume HcR: c :e R.
assume Hbne: b <> 0.
assume Hp: p :e affine_line_R2 a b c.
prove apply_fun (affine_line_R2_param_by_x a b c) (apply_fun (projection1 R R) p) = p.
claim HpRR: p :e setprod R R.
{ exact (affine_line_R2_subset_R2 a b c p Hp). }
claim Hpeta: p = (p 0, p 1).
{ exact (setprod_eta R R p HpRR). }
claim Hp0R: p 0 :e R.
{ exact (ap0_Sigma R (fun _ : set => R) p HpRR). }
claim Hp1R: p 1 :e R.
{ exact (ap1_Sigma R (fun _ : set => R) p HpRR). }
claim Happ1: apply_fun (projection1 R R) p = p 0.
{ exact (projection1_apply R R p HpRR). }
rewrite Happ1.
rewrite (affine_line_R2_param_by_x_apply a b c (p 0) Hp0R).
rewrite Hpeta at 3.
claim Hycoord: div_SNo (add_SNo c (minus_SNo (mul_SNo a (p 0)))) b = p 1.
{ claim HdefR: R = real.
  { reflexivity. }
  claim HaReal: a :e real.
  { rewrite <- HdefR. exact HaR. }
  claim HbReal: b :e real.
  { rewrite <- HdefR. exact HbR. }
  claim HcReal: c :e real.
  { rewrite <- HdefR. exact HcR. }
  claim Hp0Real: p 0 :e real.
  { rewrite <- HdefR. exact Hp0R. }
  claim Hp1Real: p 1 :e real.
  { rewrite <- HdefR. exact Hp1R. }
  claim HaS: SNo a.
  { exact (real_SNo a HaReal). }
  claim HbS: SNo b.
  { exact (real_SNo b HbReal). }
  claim HcS: SNo c.
  { exact (real_SNo c HcReal). }
  claim Hp0S: SNo (p 0).
  { exact (real_SNo (p 0) Hp0Real). }
  claim Hp1S: SNo (p 1).
  { exact (real_SNo (p 1) Hp1Real). }
  claim HaxS: SNo (mul_SNo a (p 0)).
  { exact (SNo_mul_SNo a (p 0) HaS Hp0S). }
  claim HbyS: SNo (mul_SNo b (p 1)).
  { exact (SNo_mul_SNo b (p 1) HbS Hp1S). }
  claim HmAxS: SNo (minus_SNo (mul_SNo a (p 0))).
  { exact (SNo_minus_SNo (mul_SNo a (p 0)) HaxS). }
  claim Hline0:
    add_SNo (mul_SNo a (R2_xcoord p)) (mul_SNo b (R2_ycoord p)) = c.
  { exact (SepE2 EuclidPlane
           (fun p0:set => add_SNo (mul_SNo a (R2_xcoord p0)) (mul_SNo b (R2_ycoord p0)) = c)
           p
           Hp). }
  claim Hline:
    add_SNo (mul_SNo a (p 0)) (mul_SNo b (p 1)) = c.
  { claim Hxcoord: R2_xcoord p = p 0.
    { reflexivity. }
    claim Hycoord0: R2_ycoord p = p 1.
    { reflexivity. }
    rewrite <- Hxcoord.
    rewrite <- Hycoord0.
    exact Hline0. }
  claim HbyEq: add_SNo c (minus_SNo (mul_SNo a (p 0))) = mul_SNo b (p 1).
  { rewrite <- Hline at 1.
    rewrite <- (add_SNo_assoc (mul_SNo a (p 0)) (mul_SNo b (p 1)) (minus_SNo (mul_SNo a (p 0))) HaxS HbyS HmAxS).
    rewrite (add_SNo_com (mul_SNo b (p 1)) (minus_SNo (mul_SNo a (p 0))) HbyS HmAxS) at 1.
    rewrite (add_SNo_assoc (mul_SNo a (p 0)) (minus_SNo (mul_SNo a (p 0))) (mul_SNo b (p 1)) HaxS HmAxS HbyS).
    rewrite (add_SNo_minus_SNo_rinv (mul_SNo a (p 0)) HaxS).
    exact (add_SNo_0L (mul_SNo b (p 1)) HbyS). }
  claim HxtermS: SNo (add_SNo c (minus_SNo (mul_SNo a (p 0)))).
  { exact (SNo_add_SNo c (minus_SNo (mul_SNo a (p 0))) HcS HmAxS). }
  exact (mul_div_SNo_nonzero_eq
    (add_SNo c (minus_SNo (mul_SNo a (p 0))))
    b
    (p 1)
    HxtermS
    HbS
    Hp1S
    Hbne
    HbyEq). }
rewrite Hycoord.
reflexivity.
Qed.

(** Helper: param by y lands in the affine line when b is zero and a is not zero **)
Theorem affine_line_R2_param_by_y_in_line : forall a b c y:set,
  a :e R -> b :e R -> c :e R -> y :e R ->
  b = 0 ->
  a <> 0 ->
  apply_fun (affine_line_R2_param_by_y a b c) y :e affine_line_R2 a b c.
let a b c y.
assume HaR: a :e R.
assume HbR: b :e R.
assume HcR: c :e R.
assume HyR: y :e R.
assume Hb0: b = 0.
assume Ha0: a <> 0.
prove apply_fun (affine_line_R2_param_by_y a b c) y :e affine_line_R2 a b c.
rewrite (affine_line_R2_param_by_y_apply a b c y HyR).
set x0 := div_SNo c a.
prove (x0,y) :e affine_line_R2 a b c.
claim Hdef: affine_line_R2 a b c =
  {p :e EuclidPlane | add_SNo (mul_SNo a (R2_xcoord p)) (mul_SNo b (R2_ycoord p)) = c}.
{ reflexivity. }
rewrite Hdef.
claim HxyPlane: (x0,y) :e EuclidPlane.
{ claim HdefR: R = real.
  { reflexivity. }
  claim HaReal: a :e real.
  { rewrite <- HdefR. exact HaR. }
  claim HcReal: c :e real.
  { rewrite <- HdefR. exact HcR. }
  claim HxReal: x0 :e real.
  { exact (real_div_SNo c HcReal a HaReal). }
  claim HxR: x0 :e R.
  { rewrite HdefR. exact HxReal. }
  exact (tuple_2_setprod_by_pair_Sigma R R x0 y HxR HyR). }

claim Hprop: add_SNo (mul_SNo a (R2_xcoord (x0,y))) (mul_SNo b (R2_ycoord (x0,y))) = c.
{ claim HdefR: R = real.
  { reflexivity. }
  claim HaReal: a :e real.
  { rewrite <- HdefR. exact HaR. }
  claim HbReal: b :e real.
  { rewrite <- HdefR. exact HbR. }
  claim HcReal: c :e real.
  { rewrite <- HdefR. exact HcR. }
  claim HaS: SNo a.
  { exact (real_SNo a HaReal). }
  claim HbS: SNo b.
  { exact (real_SNo b HbReal). }
  claim HcS: SNo c.
  { exact (real_SNo c HcReal). }
  claim Hx0Real: x0 :e real.
  { exact (real_div_SNo c HcReal a HaReal). }
  claim Hx0S: SNo x0.
  { exact (real_SNo x0 Hx0Real). }
  rewrite (R2_xcoord_tuple x0 y).
  rewrite (R2_ycoord_tuple x0 y).
  rewrite Hb0.
  claim HyReal: y :e real.
  { rewrite <- HdefR. exact HyR. }
  claim HyS: SNo y.
  { exact (real_SNo y HyReal). }
  rewrite (mul_SNo_zeroL y HyS).
  rewrite (add_SNo_0R (mul_SNo a x0) (SNo_mul_SNo a x0 HaS Hx0S)).
  (** a times (c/a) equals c **)
  claim Hmul: mul_SNo a x0 = c.
  { claim Hx0def: x0 = div_SNo c a.
    { reflexivity. }
    rewrite Hx0def.
    rewrite (mul_div_SNo_invR c a HcS HaS Ha0).
    reflexivity. }
  exact Hmul. }

exact (SepI EuclidPlane
        (fun p0:set => add_SNo (mul_SNo a (R2_xcoord p0)) (mul_SNo b (R2_ycoord p0)) = c)
        (x0,y)
        HxyPlane
        Hprop).
Qed.

(** Helper: if b=0 then the affine line is the vertical slice {c/a} times R **)
Theorem affine_line_R2_b0_eq_slice : forall a b c:set,
  a :e R -> b :e R -> c :e R ->
  b = 0 ->
  a <> 0 ->
  affine_line_R2 a b c = setprod {div_SNo c a} R.
let a b c.
assume HaR: a :e R.
assume HbR: b :e R.
assume HcR: c :e R.
assume Hb0: b = 0.
assume Ha0: a <> 0.
set x0 := div_SNo c a.
apply set_ext.
- let p. assume Hp: p :e affine_line_R2 a b c.
  prove p :e setprod {x0} R.
  claim HpRR: p :e setprod R R.
  { exact (affine_line_R2_subset_R2 a b c p Hp). }
  claim Hp0R: (p 0) :e R.
  { exact (ap0_Sigma R (fun _ : set => R) p HpRR). }
  claim Hp1R: (p 1) :e R.
  { exact (ap1_Sigma R (fun _ : set => R) p HpRR). }
  claim Heqdef: add_SNo (mul_SNo a (R2_xcoord p)) (mul_SNo b (R2_ycoord p)) = c.
  { exact (SepE2 EuclidPlane
              (fun p0:set => add_SNo (mul_SNo a (R2_xcoord p0)) (mul_SNo b (R2_ycoord p0)) = c)
              p
              Hp). }
  claim Hxdef: R2_xcoord p = p 0.
  { reflexivity. }
  claim Hydef: R2_ycoord p = p 1.
  { reflexivity. }
  claim Hmul: mul_SNo a (p 0) = c.
  { claim Heq0: add_SNo (mul_SNo a (p 0)) (mul_SNo b (p 1)) = c.
    { rewrite <- Hxdef.
      rewrite <- Hydef.
      exact Heqdef. }
    claim HdefR: R = real.
    { reflexivity. }
    claim Hp1Real: (p 1) :e real.
    { rewrite <- HdefR. exact Hp1R. }
    claim Hp1S: SNo (p 1).
    { exact (real_SNo (p 1) Hp1Real). }
    claim Hbterm: mul_SNo b (p 1) = 0.
    { rewrite Hb0.
      exact (mul_SNo_zeroL (p 1) Hp1S). }
    claim Heq2: add_SNo (mul_SNo a (p 0)) 0 = c.
    { claim HlhsEq: add_SNo (mul_SNo a (p 0)) (mul_SNo b (p 1)) = add_SNo (mul_SNo a (p 0)) 0.
      { rewrite Hbterm.
        reflexivity. }
      rewrite <- HlhsEq.
      exact Heq0. }
    claim Hap0: SNo (mul_SNo a (p 0)).
    { claim HaReal: a :e real.
      { rewrite <- HdefR. exact HaR. }
      claim Hp0Real: (p 0) :e real.
      { rewrite <- HdefR. exact Hp0R. }
      exact (SNo_mul_SNo a (p 0) (real_SNo a HaReal) (real_SNo (p 0) Hp0Real)). }
    rewrite <- (add_SNo_0R (mul_SNo a (p 0)) Hap0).
    exact Heq2. }
  claim HdefR: R = real.
  { reflexivity. }
  claim HaReal: a :e real.
  { rewrite <- HdefR. exact HaR. }
  claim HcReal: c :e real.
  { rewrite <- HdefR. exact HcR. }
  claim Hp0Real: (p 0) :e real.
  { rewrite <- HdefR. exact Hp0R. }
  claim HaS: SNo a.
  { exact (real_SNo a HaReal). }
  claim HcS: SNo c.
  { exact (real_SNo c HcReal). }
  claim Hp0S: SNo (p 0).
  { exact (real_SNo (p 0) Hp0Real). }
  claim Hmul2: c = mul_SNo a (p 0).
  { rewrite Hmul.
    reflexivity. }
  claim HdivEq: div_SNo c a = (p 0).
  { exact (mul_div_SNo_nonzero_eq c a (p 0) HcS HaS Hp0S Ha0 Hmul2). }
  claim Hx0def: x0 = div_SNo c a.
  { reflexivity. }
  claim Hx0eq: x0 = (p 0).
  { rewrite Hx0def.
    exact HdivEq. }
  claim Hp0Sing: (p 0) :e {x0}.
  { rewrite <- Hx0eq.
    exact (SingI x0). }
  claim Heta: p = (p 0, p 1).
  { exact (setprod_eta R R p HpRR). }
  rewrite Heta.
  exact (tuple_2_setprod_by_pair_Sigma {x0} R (p 0) (p 1) Hp0Sing Hp1R).
- let p. assume Hp: p :e setprod {x0} R.
  prove p :e affine_line_R2 a b c.
  claim Hp0Sing: (p 0) :e {x0}.
  { exact (ap0_Sigma {x0} (fun _ : set => R) p Hp). }
  claim Hp1R: (p 1) :e R.
  { exact (ap1_Sigma {x0} (fun _ : set => R) p Hp). }
  claim Hp0eq: (p 0) = x0.
  { exact (singleton_elem (p 0) x0 Hp0Sing). }
  claim HpRR: p :e setprod R R.
  { claim HSingSub: {x0} c= R.
    { claim Hx0Real: x0 :e real.
      { claim HdefR: R = real.
        { reflexivity. }
        claim HaReal: a :e real.
        { rewrite <- HdefR. exact HaR. }
        claim HcReal: c :e real.
        { rewrite <- HdefR. exact HcR. }
        exact (real_div_SNo c HcReal a HaReal). }
      claim Hx0R: x0 :e R.
      { claim HdefR: R = real.
        { reflexivity. }
        rewrite HdefR. exact Hx0Real. }
      exact (singleton_subset x0 R Hx0R). }
    exact (setprod_Subq {x0} R R R HSingSub (Subq_ref R) p Hp). }
  claim Hdef: affine_line_R2 a b c =
    {q :e EuclidPlane | add_SNo (mul_SNo a (R2_xcoord q)) (mul_SNo b (R2_ycoord q)) = c}.
  { reflexivity. }
  rewrite Hdef.
  claim HxyPlane: p :e EuclidPlane.
  { claim Heq: EuclidPlane = setprod R R.
    { reflexivity. }
    rewrite Heq.
    exact HpRR. }
  prove p :e {q :e EuclidPlane | add_SNo (mul_SNo a (R2_xcoord q)) (mul_SNo b (R2_ycoord q)) = c}.
  apply (SepI EuclidPlane
          (fun q:set => add_SNo (mul_SNo a (R2_xcoord q)) (mul_SNo b (R2_ycoord q)) = c)
          p
          HxyPlane).
  claim Hxdef: R2_xcoord p = p 0.
  { reflexivity. }
  claim Hydef: R2_ycoord p = p 1.
  { reflexivity. }
  rewrite Hxdef.
  rewrite Hydef.
  rewrite Hb0.
  claim HdefR: R = real.
  { reflexivity. }
  claim HaReal: a :e real.
  { rewrite <- HdefR. exact HaR. }
  claim HcReal: c :e real.
  { rewrite <- HdefR. exact HcR. }
  claim Hp1Real: (p 1) :e real.
  { rewrite <- HdefR. exact Hp1R. }
  claim Hp1S: SNo (p 1).
  { exact (real_SNo (p 1) Hp1Real). }
  rewrite (mul_SNo_zeroL (p 1) Hp1S).
  rewrite Hp0eq.
  claim HaS: SNo a.
  { exact (real_SNo a HaReal). }
  claim HcS: SNo c.
  { exact (real_SNo c HcReal). }
  claim Hx0Real: x0 :e real.
  { exact (real_div_SNo c HcReal a HaReal). }
  claim Hx0S: SNo x0.
  { exact (real_SNo x0 Hx0Real). }
  rewrite (add_SNo_0R (mul_SNo a x0) (SNo_mul_SNo a x0 HaS Hx0S)).
  claim Hmul: mul_SNo a x0 = c.
  { claim Hx0def: x0 = div_SNo c a.
    { reflexivity. }
    rewrite Hx0def.
    rewrite (mul_div_SNo_invR c a HcS HaS Ha0).
    reflexivity. }
  exact Hmul.
Qed.

(** from 16 Exercise 8: helper predicate for negative slope in affine form **)
(** LATEX VERSION: For ax+by=c with b not zero, the slope is negative exactly when a and b have the same sign. **)
Definition same_sign_nonzero_R : set -> set -> prop :=
  fun a b => (Rlt 0 a /\ Rlt 0 b) \/ (Rlt a 0 /\ Rlt b 0).

(** helper for 16 Exercise 8: in the same-sign case, the line graph decreases in y as x increases **)
(** LATEX VERSION: If a and b have the same sign and b is nonzero, then for x1<x2 we have (c-ax2)/b < (c-ax1)/b. **)
Theorem affine_line_R2_param_by_x_y_decreases_same_sign : forall a b c x1 x2:set,
  a :e R -> b :e R -> c :e R ->
  b <> 0 ->
  same_sign_nonzero_R a b ->
  x1 :e R -> x2 :e R ->
  Rlt x1 x2 ->
  Rlt (div_SNo (add_SNo c (minus_SNo (mul_SNo a x2))) b)
      (div_SNo (add_SNo c (minus_SNo (mul_SNo a x1))) b).
let a b c x1 x2.
assume HaR: a :e R.
assume HbR: b :e R.
assume HcR: c :e R.
assume Hbne: b <> 0.
assume Hsign: same_sign_nonzero_R a b.
assume Hx1R: x1 :e R.
assume Hx2R: x2 :e R.
assume Hx12: Rlt x1 x2.
prove Rlt (div_SNo (add_SNo c (minus_SNo (mul_SNo a x2))) b)
          (div_SNo (add_SNo c (minus_SNo (mul_SNo a x1))) b).
claim HdefR: R = real.
{ reflexivity. }
claim HaReal: a :e real.
{ rewrite <- HdefR. exact HaR. }
claim HbReal: b :e real.
{ rewrite <- HdefR. exact HbR. }
claim HcReal: c :e real.
{ rewrite <- HdefR. exact HcR. }
claim Hx1Real: x1 :e real.
{ rewrite <- HdefR. exact Hx1R. }
claim Hx2Real: x2 :e real.
{ rewrite <- HdefR. exact Hx2R. }
claim HaS: SNo a.
{ exact (real_SNo a HaReal). }
claim HbS: SNo b.
{ exact (real_SNo b HbReal). }
claim HcS: SNo c.
{ exact (real_SNo c HcReal). }
claim Hx1S: SNo x1.
{ exact (real_SNo x1 Hx1Real). }
claim Hx2S: SNo x2.
{ exact (real_SNo x2 Hx2Real). }
claim Hx12lt: x1 < x2.
{ exact (RltE_lt x1 x2 Hx12). }
set num1 := add_SNo c (minus_SNo (mul_SNo a x1)).
set num2 := add_SNo c (minus_SNo (mul_SNo a x2)).
claim Hnum1S: SNo num1.
{ exact (SNo_add_SNo c (minus_SNo (mul_SNo a x1)) HcS
          (SNo_minus_SNo (mul_SNo a x1) (SNo_mul_SNo a x1 HaS Hx1S))). }
claim Hnum2S: SNo num2.
{ exact (SNo_add_SNo c (minus_SNo (mul_SNo a x2)) HcS
          (SNo_minus_SNo (mul_SNo a x2) (SNo_mul_SNo a x2 HaS Hx2S))). }
claim Hy1Real: div_SNo (add_SNo c (minus_SNo (mul_SNo a x1))) b :e real.
{ exact (real_div_SNo (add_SNo c (minus_SNo (mul_SNo a x1))) (real_add_SNo c HcReal (minus_SNo (mul_SNo a x1)) (real_minus_SNo (mul_SNo a x1) (real_mul_SNo a HaReal x1 Hx1Real)))
         b HbReal). }
claim Hy2Real: div_SNo (add_SNo c (minus_SNo (mul_SNo a x2))) b :e real.
{ exact (real_div_SNo (add_SNo c (minus_SNo (mul_SNo a x2))) (real_add_SNo c HcReal (minus_SNo (mul_SNo a x2)) (real_minus_SNo (mul_SNo a x2) (real_mul_SNo a HaReal x2 Hx2Real)))
         b HbReal). }
claim Hy1R: div_SNo (add_SNo c (minus_SNo (mul_SNo a x1))) b :e R.
{ rewrite HdefR. exact Hy1Real. }
claim Hy2R: div_SNo (add_SNo c (minus_SNo (mul_SNo a x2))) b :e R.
{ rewrite HdefR. exact Hy2Real. }
apply Hsign.
- (** positive case: 0<a and 0<b **)
  assume Hpos: Rlt 0 a /\ Rlt 0 b.
  claim H0a: Rlt 0 a.
  { exact (andEL (Rlt 0 a) (Rlt 0 b) Hpos). }
  claim H0b: Rlt 0 b.
  { exact (andER (Rlt 0 a) (Rlt 0 b) Hpos). }
  claim H0alt: 0 < a.
  { exact (RltE_lt 0 a H0a). }
  claim H0blt: 0 < b.
  { exact (RltE_lt 0 b H0b). }
  claim Hax1ax2: mul_SNo a x1 < mul_SNo a x2.
  { exact (pos_mul_SNo_Lt a x1 x2 HaS H0alt Hx1S Hx2S Hx12lt). }
  claim HmAx2mAx1: minus_SNo (mul_SNo a x2) < minus_SNo (mul_SNo a x1).
  { exact (minus_SNo_Lt_contra (mul_SNo a x1) (mul_SNo a x2)
            (SNo_mul_SNo a x1 HaS Hx1S) (SNo_mul_SNo a x2 HaS Hx2S) Hax1ax2). }
  claim Hnum2num1: num2 < num1.
  { exact (add_SNo_Lt2 c (minus_SNo (mul_SNo a x2)) (minus_SNo (mul_SNo a x1))
            HcS (SNo_minus_SNo (mul_SNo a x2) (SNo_mul_SNo a x2 HaS Hx2S))
            (SNo_minus_SNo (mul_SNo a x1) (SNo_mul_SNo a x1 HaS Hx1S))
            HmAx2mAx1). }
  claim HrecipPos: 0 < recip_SNo b.
  { exact (recip_SNo_of_pos_is_pos b HbS H0blt). }
  claim HrecipS: SNo (recip_SNo b).
  { exact (SNo_recip_SNo b HbS). }
  claim HdivLt: div_SNo num2 b < div_SNo num1 b.
  { claim Heq2: div_SNo num2 b = mul_SNo num2 (recip_SNo b).
    { reflexivity. }
    claim Heq1: div_SNo num1 b = mul_SNo num1 (recip_SNo b).
    { reflexivity. }
    rewrite Heq2.
    rewrite Heq1.
    exact (pos_mul_SNo_Lt' num2 num1 (recip_SNo b) Hnum2S Hnum1S HrecipS HrecipPos Hnum2num1). }
  exact (RltI (div_SNo num2 b) (div_SNo num1 b) Hy2R Hy1R HdivLt).
- (** negative case: a<0 and b<0 **)
  assume Hneg: Rlt a 0 /\ Rlt b 0.
  claim Ha0: Rlt a 0.
  { exact (andEL (Rlt a 0) (Rlt b 0) Hneg). }
  claim Hb0: Rlt b 0.
  { exact (andER (Rlt a 0) (Rlt b 0) Hneg). }
  claim Halt0: a < 0.
  { exact (RltE_lt a 0 Ha0). }
  claim Hblt0: b < 0.
  { exact (RltE_lt b 0 Hb0). }
  claim Hax2ax1: mul_SNo a x2 < mul_SNo a x1.
  { exact (neg_mul_SNo_Lt a x2 x1 HaS Halt0 Hx2S Hx1S Hx12lt). }
  claim HmAx1mAx2: minus_SNo (mul_SNo a x1) < minus_SNo (mul_SNo a x2).
  { exact (minus_SNo_Lt_contra (mul_SNo a x2) (mul_SNo a x1)
            (SNo_mul_SNo a x2 HaS Hx2S) (SNo_mul_SNo a x1 HaS Hx1S) Hax2ax1). }
  claim Hnum1num2: num1 < num2.
  { exact (add_SNo_Lt2 c (minus_SNo (mul_SNo a x1)) (minus_SNo (mul_SNo a x2))
            HcS (SNo_minus_SNo (mul_SNo a x1) (SNo_mul_SNo a x1 HaS Hx1S))
            (SNo_minus_SNo (mul_SNo a x2) (SNo_mul_SNo a x2 HaS Hx2S))
            HmAx1mAx2). }
  claim HrecipNeg: recip_SNo b < 0.
  { (** recip_SNo b = -recip_SNo_pos (-b) and recip_SNo_pos (-b) is positive **)
    claim HminusbS: SNo (minus_SNo b).
    { exact (SNo_minus_SNo b HbS). }
    claim HminusbPos: 0 < minus_SNo b.
    { (** from b<0 get 0 < -b **)
      claim H0ltminusb: minus_SNo 0 < minus_SNo b.
      { exact (minus_SNo_Lt_contra b 0 HbS SNo_0 Hblt0). }
      prove 0 < minus_SNo b.
      rewrite <- (minus_SNo_0) at 1.
      exact H0ltminusb. }
    claim HrecipPosDef: recip_SNo b = minus_SNo (recip_SNo_pos (minus_SNo b)).
    { rewrite (recip_SNo_negcase b HbS Hblt0).
      reflexivity. }
    claim HtS: SNo (recip_SNo_pos (minus_SNo b)).
    { exact (SNo_recip_SNo_pos (minus_SNo b) HminusbS HminusbPos). }
    claim HtPos: 0 < recip_SNo_pos (minus_SNo b).
    { exact (recip_SNo_pos_is_pos (minus_SNo b) HminusbS HminusbPos). }
    rewrite HrecipPosDef.
    claim HnegT: minus_SNo (recip_SNo_pos (minus_SNo b)) < 0.
    { claim Hmtltm0: minus_SNo (recip_SNo_pos (minus_SNo b)) < minus_SNo 0.
      { exact (minus_SNo_Lt_contra 0 (recip_SNo_pos (minus_SNo b)) SNo_0 HtS HtPos). }
      prove minus_SNo (recip_SNo_pos (minus_SNo b)) < 0.
      rewrite <- (minus_SNo_0) at 1.
      exact Hmtltm0. }
    exact HnegT. }
  claim HrecipS: SNo (recip_SNo b).
  { exact (SNo_recip_SNo b HbS). }
  claim HdivLt: div_SNo num2 b < div_SNo num1 b.
  { claim Heq2: div_SNo num2 b = mul_SNo num2 (recip_SNo b).
    { reflexivity. }
    claim Heq1: div_SNo num1 b = mul_SNo num1 (recip_SNo b).
    { reflexivity. }
    rewrite Heq2.
    rewrite Heq1.
    (** use commutativity and multiply on the left by the negative factor **)
    rewrite (mul_SNo_com num2 (recip_SNo b) Hnum2S HrecipS).
    rewrite (mul_SNo_com num1 (recip_SNo b) Hnum1S HrecipS).
    exact (neg_mul_SNo_Lt (recip_SNo b) num2 num1 HrecipS HrecipNeg Hnum2S Hnum1S Hnum1num2). }
  exact (RltI (div_SNo num2 b) (div_SNo num1 b) Hy2R Hy1R HdivLt).
Qed.

(** Helper for ex16_8_lines_in_lower_limit_products: in the same_sign case, each singleton on the line is open in the R_lower_limit_topology product subspace topology **)
Theorem affine_line_R2_singleton_open_same_sign : forall a b c p:set,
  a :e R -> b :e R -> c :e R ->
  b <> 0 -> same_sign_nonzero_R a b ->
  p :e affine_line_R2 a b c ->
  {p} :e subspace_topology (setprod R R)
    (product_topology R R_lower_limit_topology R R_lower_limit_topology)
    (affine_line_R2 a b c).
let a b c p.
assume HaR: a :e R.
assume HbR: b :e R.
assume HcR: c :e R.
assume Hbne: b <> 0.
assume Hsign: same_sign_nonzero_R a b.
assume HpL: p :e affine_line_R2 a b c.
prove {p} :e subspace_topology (setprod R R)
  (product_topology R R_lower_limit_topology R R_lower_limit_topology)
  (affine_line_R2 a b c).
claim HdefTL:
  subspace_topology (setprod R R)
    (product_topology R R_lower_limit_topology R R_lower_limit_topology)
    (affine_line_R2 a b c)
  = {U0 :e Power (affine_line_R2 a b c) |
       exists V0 :e (product_topology R R_lower_limit_topology R R_lower_limit_topology),
         U0 = V0 :/\: (affine_line_R2 a b c)}.
{ reflexivity. }
rewrite HdefTL.
apply (SepI (Power (affine_line_R2 a b c))
  (fun U0:set => exists V0 :e (product_topology R R_lower_limit_topology R R_lower_limit_topology),
    U0 = V0 :/\: (affine_line_R2 a b c)) {p}).
- apply PowerI (affine_line_R2 a b c) {p}.
  let q. assume Hq: q :e {p}.
  prove q :e affine_line_R2 a b c.
  claim Hqeq: q = p.
  { exact (SingE p q Hq). }
  rewrite Hqeq.
  exact HpL.
- claim HpRR: p :e setprod R R.
  { exact (affine_line_R2_subset_R2 a b c p HpL). }
  set x := p 0.
  set y := p 1.
  claim HxR: x :e R.
  { exact (ap0_Sigma R (fun _ : set => R) p HpRR). }
  claim HyR: y :e R.
  { exact (ap1_Sigma R (fun _ : set => R) p HpRR). }
  claim HdefR: R = real.
  { reflexivity. }
  claim HxReal: x :e real.
  { rewrite <- HdefR. exact HxR. }
  claim HyReal: y :e real.
  { rewrite <- HdefR. exact HyR. }
  claim HxS: SNo x.
  { exact (real_SNo x HxReal). }
  claim HyS: SNo y.
  { exact (real_SNo y HyReal). }
  set x1 := add_SNo x 1.
  set y1 := add_SNo y 1.
  claim Hx1Real: x1 :e real.
  { exact (real_add_SNo x HxReal 1 real_1). }
  claim Hy1Real: y1 :e real.
  { exact (real_add_SNo y HyReal 1 real_1). }
  claim Hx1R: x1 :e R.
  { rewrite HdefR. exact Hx1Real. }
  claim Hy1R: y1 :e R.
  { rewrite HdefR. exact Hy1Real. }
  claim Hx1def: x1 = add_SNo x 1.
  { reflexivity. }
  claim Hy1def: y1 = add_SNo y 1.
  { reflexivity. }
  claim Hxltx1: x < x1.
  { prove x < x1.
    rewrite Hx1def.
    claim H0S: SNo 0.
    { exact SNo_0. }
    claim H1S: SNo 1.
    { exact SNo_1. }
    claim H0lt1: 0 < 1.
    { exact SNoLt_0_1. }
    claim Hx0ltx1: add_SNo x 0 < add_SNo x 1.
    { exact (add_SNo_Lt2 x 0 1 HxS H0S H1S H0lt1). }
    rewrite <- (add_SNo_0R x HxS) at 1.
    exact Hx0ltx1. }
  claim Hylt1: y < y1.
  { prove y < y1.
    rewrite Hy1def.
    claim H0S: SNo 0.
    { exact SNo_0. }
    claim H1S: SNo 1.
    { exact SNo_1. }
    claim H0lt1: 0 < 1.
    { exact SNoLt_0_1. }
    claim Hy0lty1: add_SNo y 0 < add_SNo y 1.
    { exact (add_SNo_Lt2 y 0 1 HyS H0S H1S H0lt1). }
    rewrite <- (add_SNo_0R y HyS) at 1.
    exact Hy0lty1. }
  claim HRlt_x_x1: Rlt x x1.
  { exact (RltI x x1 HxR Hx1R Hxltx1). }
  claim HRlt_y_y1: Rlt y y1.
  { exact (RltI y y1 HyR Hy1R Hylt1). }
  set U := halfopen_interval_left x x1.
  set V := halfopen_interval_left y y1.
  claim HxU: x :e U.
  { exact (halfopen_interval_left_leftmem x x1 HRlt_x_x1). }
  claim HyV: y :e V.
  { exact (halfopen_interval_left_leftmem y y1 HRlt_y_y1). }
  claim HUinBasis: U :e R_lower_limit_basis.
  { prove U :e R_lower_limit_basis.
    claim HUfam: U :e {halfopen_interval_left x b0|b0 :e R}.
    { exact (ReplI R (fun b0:set => halfopen_interval_left x b0) x1 Hx1R). }
    exact (famunionI R (fun a0:set => {halfopen_interval_left a0 b0|b0 :e R}) x U HxR HUfam). }
  claim HVinBasis: V :e R_lower_limit_basis.
  { prove V :e R_lower_limit_basis.
    claim HVfam: V :e {halfopen_interval_left y b0|b0 :e R}.
    { exact (ReplI R (fun b0:set => halfopen_interval_left y b0) y1 Hy1R). }
    exact (famunionI R (fun a0:set => {halfopen_interval_left a0 b0|b0 :e R}) y V HyR HVfam). }
  claim HBasis: basis_on R R_lower_limit_basis.
  { exact R_lower_limit_basis_is_basis_local. }
  claim HUopen: U :e R_lower_limit_topology.
  { exact (generated_topology_contains_basis R R_lower_limit_basis HBasis U HUinBasis). }
  claim HVopen: V :e R_lower_limit_topology.
  { exact (generated_topology_contains_basis R R_lower_limit_basis HBasis V HVinBasis). }
  claim HWsub: rectangle_set U V :e product_subbasis R R_lower_limit_topology R R_lower_limit_topology.
  { prove rectangle_set U V :e product_subbasis R R_lower_limit_topology R R_lower_limit_topology.
    claim HWV: rectangle_set U V :e {rectangle_set U V0|V0 :e R_lower_limit_topology}.
    { exact (ReplI R_lower_limit_topology (fun V0:set => rectangle_set U V0) V HVopen). }
    exact (famunionI R_lower_limit_topology (fun U0:set => {rectangle_set U0 V0|V0 :e R_lower_limit_topology}) U (rectangle_set U V) HUopen HWV). }
  claim HBsub: basis_on (setprod R R) (product_subbasis R R_lower_limit_topology R R_lower_limit_topology).
  { exact (product_subbasis_is_basis R R_lower_limit_topology R R_lower_limit_topology R_lower_limit_topology_is_topology R_lower_limit_topology_is_topology). }
  claim HWopen: rectangle_set U V :e product_topology R R_lower_limit_topology R R_lower_limit_topology.
  { exact (generated_topology_contains_basis (setprod R R) (product_subbasis R R_lower_limit_topology R R_lower_limit_topology) HBsub (rectangle_set U V) HWsub). }
  claim HsingEq: {p} = (rectangle_set U V) :/\: affine_line_R2 a b c.
  { apply set_ext.
    - let q. assume Hq: q :e {p}.
      prove q :e (rectangle_set U V) :/\: affine_line_R2 a b c.
      claim Hqeq: q = p.
      { exact (SingE p q Hq). }
      rewrite Hqeq.
						      apply binintersectI.
						      + claim Hpeta: p = (p 0, p 1).
						        { exact (setprod_eta R R p HpRR). }
						        claim Hxdef: x = p 0.
						        { reflexivity. }
						        claim Hydef: y = p 1.
						        { reflexivity. }
						        claim Hp0U: p 0 :e U.
						        { rewrite <- Hxdef. exact HxU. }
						        claim Hp1V: p 1 :e V.
						        { rewrite <- Hydef. exact HyV. }
						        rewrite Hpeta at 1.
						        rewrite rectangle_set_def.
						        exact (tuple_2_setprod_by_pair_Sigma U V (p 0) (p 1) Hp0U Hp1V).
						      + exact HpL.
				    - let q. assume Hq: q :e (rectangle_set U V) :/\: affine_line_R2 a b c.
				      prove q :e {p}.
      claim HqL: q :e affine_line_R2 a b c.
      { exact (binintersectE2 (rectangle_set U V) (affine_line_R2 a b c) q Hq). }
      claim HqW: q :e rectangle_set U V.
      { exact (binintersectE1 (rectangle_set U V) (affine_line_R2 a b c) q Hq). }
      claim HqUV: q :e setprod U V.
      { exact HqW. }
      set qx := q 0.
      set qy := q 1.
      claim HqRR: q :e setprod R R.
      { exact (affine_line_R2_subset_R2 a b c q HqL). }
      claim HqxR: qx :e R.
      { exact (ap0_Sigma R (fun _ : set => R) q HqRR). }
      claim HqyR: qy :e R.
      { exact (ap1_Sigma R (fun _ : set => R) q HqRR). }
      claim HqxS: SNo qx.
      { claim HqxReal: qx :e real.
        { rewrite <- HdefR. exact HqxR. }
        exact (real_SNo qx HqxReal). }
      claim HqyS: SNo qy.
      { claim HqyReal: qy :e real.
        { rewrite <- HdefR. exact HqyR. }
        exact (real_SNo qy HqyReal). }
      claim HqxU: qx :e U.
      { exact (ap0_Sigma U (fun _ : set => V) q HqUV). }
      claim HqyV: qy :e V.
      { exact (ap1_Sigma U (fun _ : set => V) q HqUV). }
      claim HqxCond: ~(Rlt qx x) /\ Rlt qx x1.
      { exact (SepE2 R (fun t:set => ~(Rlt t x) /\ Rlt t x1) qx HqxU). }
      claim HqyCond: ~(Rlt qy y) /\ Rlt qy y1.
      { exact (SepE2 R (fun t:set => ~(Rlt t y) /\ Rlt t y1) qy HqyV). }
      claim HnotRlt_qx_x: ~(Rlt qx x).
      { exact (andEL (~(Rlt qx x)) (Rlt qx x1) HqxCond). }
      claim HnotRlt_qy_y: ~(Rlt qy y).
      { exact (andEL (~(Rlt qy y)) (Rlt qy y1) HqyCond). }
      claim Hnotlt_qx_x: ~ (qx < x).
      { assume Hlt: qx < x.
        apply HnotRlt_qx_x.
        exact (RltI qx x HqxR HxR Hlt). }
      claim Hqeq: q = p.
      { apply (SNoLt_trichotomy_or_impred qx x HqxS HxS (q = p)).
        - assume Hqxlt: qx < x.
          prove q = p.
          apply FalseE.
          apply Hnotlt_qx_x.
          exact Hqxlt.
        - assume HqxEq: qx = x.
          prove q = p.
          set f := affine_line_R2_param_by_x a b c.
          claim Hpx: apply_fun f x = p.
          { claim Happ1p: apply_fun (projection1 R R) p = x.
            { rewrite (projection1_apply R R p HpRR).
              reflexivity. }
            rewrite <- Happ1p.
            exact (affine_line_R2_param_by_x_after_projection1_on_line a b c p HaR HbR HcR Hbne HpL). }
          claim Hqpx: apply_fun f qx = q.
          { claim Happ1q: apply_fun (projection1 R R) q = qx.
            { rewrite (projection1_apply R R q HqRR).
              reflexivity. }
            rewrite <- Happ1q.
            exact (affine_line_R2_param_by_x_after_projection1_on_line a b c q HaR HbR HcR Hbne HqL). }
          rewrite <- Hqpx.
          rewrite <- Hpx.
          rewrite HqxEq.
          reflexivity.
        - assume Hxlt: x < qx.
          prove q = p.
          apply FalseE.
          set f := affine_line_R2_param_by_x a b c.
          set yx := div_SNo (add_SNo c (minus_SNo (mul_SNo a x))) b.
          set yq := div_SNo (add_SNo c (minus_SNo (mul_SNo a qx))) b.
          claim Hyxdef: yx = div_SNo (add_SNo c (minus_SNo (mul_SNo a x))) b.
          { reflexivity. }
          claim Hyqdef: yq = div_SNo (add_SNo c (minus_SNo (mul_SNo a qx))) b.
          { reflexivity. }
          claim Hpx: apply_fun f x = p.
          { claim Happ1p: apply_fun (projection1 R R) p = x.
            { rewrite (projection1_apply R R p HpRR).
              reflexivity. }
            rewrite <- Happ1p.
            exact (affine_line_R2_param_by_x_after_projection1_on_line a b c p HaR HbR HcR Hbne HpL). }
          claim Hqpx: apply_fun f qx = q.
          { claim Happ1q: apply_fun (projection1 R R) q = qx.
            { rewrite (projection1_apply R R q HqRR).
              reflexivity. }
            rewrite <- Happ1q.
            exact (affine_line_R2_param_by_x_after_projection1_on_line a b c q HaR HbR HcR Hbne HqL). }
          claim Hpeta: p = (x,y).
          { exact (setprod_eta R R p HpRR). }
          claim Hqeta: q = (qx,qy).
          { exact (setprod_eta R R q HqRR). }
          claim HpairP: (x,yx) = (x,y).
          { claim Hfx: apply_fun f x = (x,yx).
            { rewrite (affine_line_R2_param_by_x_apply a b c x HxR).
              rewrite <- Hyxdef.
              reflexivity. }
            rewrite <- Hpeta.
            rewrite <- Hfx.
            exact Hpx. }
          claim HyxEq: yx = y.
          { exact (andER (x = x) (yx = y) (tuple_eq_coords x yx x y HpairP)). }
          claim HpairQ: (qx,yq) = (qx,qy).
          { claim Hfq: apply_fun f qx = (qx,yq).
            { rewrite (affine_line_R2_param_by_x_apply a b c qx HqxR).
              rewrite <- Hyqdef.
              reflexivity. }
            rewrite <- Hqeta.
            rewrite <- Hfq.
            exact Hqpx. }
          claim HyqEq: yq = qy.
          { exact (andER (qx = qx) (yq = qy) (tuple_eq_coords qx yq qx qy HpairQ)). }
          claim HRlt_x_qx: Rlt x qx.
          { exact (RltI x qx HxR HqxR Hxlt). }
          claim HRlt_yq_yx: Rlt yq yx.
          { exact (affine_line_R2_param_by_x_y_decreases_same_sign a b c x qx
                    HaR HbR HcR Hbne Hsign HxR HqxR HRlt_x_qx). }
          claim Hbad: Rlt qy y.
          { rewrite <- HyqEq.
            rewrite <- HyxEq.
            exact HRlt_yq_yx. }
          apply HnotRlt_qy_y.
          exact Hbad. }
      rewrite Hqeq.
      exact (SingI p). }
  witness (rectangle_set U V).
  apply andI.
  - exact HWopen.
  - exact HsingEq.
Qed.

(** Helper for ex16_8_lines_in_lower_limit_products: projection1 into a discrete codomain is continuous on the same_sign affine line **)
Theorem projection1_continuous_on_affine_line_same_sign : forall a b c:set,
  a :e R -> b :e R -> c :e R ->
  b <> 0 -> same_sign_nonzero_R a b ->
  continuous_map (affine_line_R2 a b c)
    (subspace_topology (setprod R R)
      (product_topology R R_lower_limit_topology R R_lower_limit_topology)
      (affine_line_R2 a b c))
    R (discrete_topology R) (projection1 R R).
let a b c.
assume HaR: a :e R.
assume HbR: b :e R.
assume HcR: c :e R.
assume Hbne: b <> 0.
assume Hsign: same_sign_nonzero_R a b.
set g := projection1 R R.
prove continuous_map (affine_line_R2 a b c)
  (subspace_topology (setprod R R)
    (product_topology R R_lower_limit_topology R R_lower_limit_topology)
    (affine_line_R2 a b c))
  R (discrete_topology R) g.
claim HTll: topology_on R R_lower_limit_topology.
{ exact R_lower_limit_topology_is_topology. }
claim HTprod: topology_on (setprod R R)
  (product_topology R R_lower_limit_topology R R_lower_limit_topology).
{ exact (product_topology_is_topology R R_lower_limit_topology R R_lower_limit_topology HTll HTll). }
claim HLsub: affine_line_R2 a b c c= setprod R R.
{ exact (affine_line_R2_subset_R2 a b c). }
claim HTL: topology_on (affine_line_R2 a b c)
  (subspace_topology (setprod R R)
    (product_topology R R_lower_limit_topology R R_lower_limit_topology)
    (affine_line_R2 a b c)).
{ exact (subspace_topology_is_topology (setprod R R)
          (product_topology R R_lower_limit_topology R R_lower_limit_topology)
          (affine_line_R2 a b c) HTprod HLsub). }
claim HTd: topology_on R (discrete_topology R).
{ exact (discrete_topology_on R). }
claim Hfun: function_on g (affine_line_R2 a b c) R.
{ let p. assume HpL: p :e affine_line_R2 a b c.
  prove apply_fun g p :e R.
  claim HpRR: p :e setprod R R.
  { exact (HLsub p HpL). }
  claim Happ: apply_fun g p = p 0.
  { exact (projection1_apply R R p HpRR). }
  rewrite Happ.
  exact (ap0_Sigma R (fun _ : set => R) p HpRR). }
prove topology_on (affine_line_R2 a b c)
    (subspace_topology (setprod R R)
      (product_topology R R_lower_limit_topology R R_lower_limit_topology)
      (affine_line_R2 a b c))
  /\ topology_on R (discrete_topology R)
  /\ function_on g (affine_line_R2 a b c) R
  /\ forall V:set, V :e discrete_topology R ->
       preimage_of (affine_line_R2 a b c) g V :e
         (subspace_topology (setprod R R)
           (product_topology R R_lower_limit_topology R R_lower_limit_topology)
           (affine_line_R2 a b c)).
apply andI.
- apply andI.
  * apply andI.
    + exact HTL.
    + exact HTd.
  * exact Hfun.
- let V. assume HV: V :e discrete_topology R.
  prove preimage_of (affine_line_R2 a b c) g V :e
    (subspace_topology (setprod R R)
      (product_topology R R_lower_limit_topology R R_lower_limit_topology)
      (affine_line_R2 a b c)).
  set S := preimage_of (affine_line_R2 a b c) g V.
  set Fam := {{p0}|p0 :e S}.
  claim HFamSub: Fam c=
    (subspace_topology (setprod R R)
      (product_topology R R_lower_limit_topology R R_lower_limit_topology)
      (affine_line_R2 a b c)).
  { let U. assume HU: U :e Fam.
    prove U :e
      (subspace_topology (setprod R R)
        (product_topology R R_lower_limit_topology R R_lower_limit_topology)
        (affine_line_R2 a b c)).
    claim Hex: exists p0 :e S, U = {p0}.
    { exact (ReplE S (fun p0:set => {p0}) U HU). }
    apply Hex.
    let p0. assume Hp0pair.
    claim Hp0S: p0 :e S.
    { exact (andEL (p0 :e S) (U = {p0}) Hp0pair). }
    claim HUeq: U = {p0}.
    { exact (andER (p0 :e S) (U = {p0}) Hp0pair). }
    rewrite HUeq.
    claim Hp0L: p0 :e affine_line_R2 a b c.
    { exact (SepE1 (affine_line_R2 a b c) (fun u:set => apply_fun g u :e V) p0 Hp0S). }
    exact (affine_line_R2_singleton_open_same_sign a b c p0 HaR HbR HcR Hbne Hsign Hp0L). }
  claim HUnionOpen: Union Fam :e
    (subspace_topology (setprod R R)
      (product_topology R R_lower_limit_topology R R_lower_limit_topology)
      (affine_line_R2 a b c)).
  { exact (topology_union_closed (affine_line_R2 a b c)
            (subspace_topology (setprod R R)
              (product_topology R R_lower_limit_topology R R_lower_limit_topology)
              (affine_line_R2 a b c))
            Fam
            HTL
            HFamSub). }
  claim HUnionEq: Union Fam = S.
  { apply set_ext.
    - let x. assume Hx: x :e Union Fam.
      prove x :e S.
      claim HexU: exists U:set, x :e U /\ U :e Fam.
      { exact (UnionE Fam x Hx). }
      apply HexU.
      let U. assume HUconj.
      claim HxU: x :e U.
      { exact (andEL (x :e U) (U :e Fam) HUconj). }
      claim HUfam: U :e Fam.
      { exact (andER (x :e U) (U :e Fam) HUconj). }
      claim Hex: exists p0 :e S, U = {p0}.
      { exact (ReplE S (fun p0:set => {p0}) U HUfam). }
      apply Hex.
      let p0. assume Hp0pair.
      claim Hp0S: p0 :e S.
      { exact (andEL (p0 :e S) (U = {p0}) Hp0pair). }
      claim HUeq: U = {p0}.
      { exact (andER (p0 :e S) (U = {p0}) Hp0pair). }
      claim HxU2: x :e {p0}.
      { rewrite <- HUeq.
        exact HxU. }
      claim Hxeq: x = p0.
      { exact (SingE p0 x HxU2). }
      rewrite Hxeq.
      exact Hp0S.
    - let x. assume Hx: x :e S.
      prove x :e Union Fam.
      claim HsingFam: {x} :e Fam.
      { exact (ReplI S (fun p0:set => {p0}) x Hx). }
      exact (UnionI Fam x {x} (SingI x) HsingFam). }
  rewrite <- HUnionEq.
  exact HUnionOpen.
Qed.

(** from 16 Exercise 8: topology on a line in R_lR and R_lR_l is familiar **)
(** LATEX VERSION: For a straight line L in the plane, the subspace topology from R_lR and from R_lR_l is a familiar topology on L. **)
Theorem ex16_8_lines_in_lower_limit_products : forall a b c:set,
  a :e R -> b :e R -> c :e R ->
  ~ (a = 0 /\ b = 0) ->
  ( (b = 0 ->
      exists f:set,
        homeomorphism R R_standard_topology (affine_line_R2 a b c)
          (subspace_topology (setprod R R)
             (product_topology R R_lower_limit_topology R R_standard_topology)
             (affine_line_R2 a b c)) f)
    /\ (b <> 0 ->
      exists f:set,
        homeomorphism R R_lower_limit_topology (affine_line_R2 a b c)
          (subspace_topology (setprod R R)
             (product_topology R R_lower_limit_topology R R_standard_topology)
             (affine_line_R2 a b c)) f) )
  /\ ( (b <> 0 /\ same_sign_nonzero_R a b) ->
        exists f:set,
          homeomorphism R (discrete_topology R) (affine_line_R2 a b c)
            (subspace_topology (setprod R R)
               (product_topology R R_lower_limit_topology R R_lower_limit_topology)
               (affine_line_R2 a b c)) f)
     /\ ( (b = 0 \/ ~ same_sign_nonzero_R a b) ->
        exists f:set,
          homeomorphism R R_lower_limit_topology (affine_line_R2 a b c)
            (subspace_topology (setprod R R)
             (product_topology R R_lower_limit_topology R R_lower_limit_topology)
               (affine_line_R2 a b c)) f).
prove forall a b c:set,
  a :e R -> b :e R -> c :e R ->
  ~ (a = 0 /\ b = 0) ->
  ( (b = 0 ->
      exists f:set,
        homeomorphism R R_standard_topology (affine_line_R2 a b c)
          (subspace_topology (setprod R R)
             (product_topology R R_lower_limit_topology R R_standard_topology)
             (affine_line_R2 a b c)) f)
    /\ (b <> 0 ->
      exists f:set,
        homeomorphism R R_lower_limit_topology (affine_line_R2 a b c)
          (subspace_topology (setprod R R)
             (product_topology R R_lower_limit_topology R R_standard_topology)
             (affine_line_R2 a b c)) f) )
  /\ ( (b <> 0 /\ same_sign_nonzero_R a b) ->
        exists f:set,
          homeomorphism R (discrete_topology R) (affine_line_R2 a b c)
            (subspace_topology (setprod R R)
               (product_topology R R_lower_limit_topology R R_lower_limit_topology)
               (affine_line_R2 a b c)) f)
     /\ ( (b = 0 \/ ~ same_sign_nonzero_R a b) ->
        exists f:set,
          homeomorphism R R_lower_limit_topology (affine_line_R2 a b c)
            (subspace_topology (setprod R R)
               (product_topology R R_lower_limit_topology R R_lower_limit_topology)
               (affine_line_R2 a b c)) f).
let a b c.
assume HaR: a :e R.
assume HbR: b :e R.
assume HcR: c :e R.
assume Hnotboth: ~ (a = 0 /\ b = 0).
prove ( (b = 0 ->
      exists f:set,
        homeomorphism R R_standard_topology (affine_line_R2 a b c)
          (subspace_topology (setprod R R)
             (product_topology R R_lower_limit_topology R R_standard_topology)
             (affine_line_R2 a b c)) f)
    /\ (b <> 0 ->
      exists f:set,
        homeomorphism R R_lower_limit_topology (affine_line_R2 a b c)
          (subspace_topology (setprod R R)
             (product_topology R R_lower_limit_topology R R_standard_topology)
             (affine_line_R2 a b c)) f) )
  /\ ( (b <> 0 /\ same_sign_nonzero_R a b) ->
        exists f:set,
          homeomorphism R (discrete_topology R) (affine_line_R2 a b c)
            (subspace_topology (setprod R R)
               (product_topology R R_lower_limit_topology R R_lower_limit_topology)
               (affine_line_R2 a b c)) f)
     /\ ( (b = 0 \/ ~ same_sign_nonzero_R a b) ->
        exists f:set,
          homeomorphism R R_lower_limit_topology (affine_line_R2 a b c)
            (subspace_topology (setprod R R)
               (product_topology R R_lower_limit_topology R R_lower_limit_topology)
               (affine_line_R2 a b c)) f).
apply andI.
  - apply andI.
		  + apply andI.
		    * assume Hb0: b = 0.
		      claim Ha0: a <> 0.
		      { prove ~ (a = 0).
		        assume Ha0eq: a = 0.
		        prove False.
		        apply Hnotboth.
		        apply andI.
		        - exact Ha0eq.
		        - exact Hb0. }
		      set x0 := div_SNo c a.
		      claim HeqLine: affine_line_R2 a b c = setprod {x0} R.
		      { exact (affine_line_R2_b0_eq_slice a b c HaR HbR HcR Hb0 Ha0). }
			      witness (affine_line_R2_param_by_y a b c).
			      rewrite HeqLine.
			      claim HTll: topology_on R R_lower_limit_topology.
			      { exact R_lower_limit_topology_is_topology. }
			      claim HTstd: topology_on R R_standard_topology.
			      { exact R_standard_topology_is_topology. }
			      claim Hx0R: x0 :e R.
			      { claim HdefR: R = real.
			        { reflexivity. }
			        claim HaReal: a :e real.
			        { rewrite <- HdefR. exact HaR. }
			        claim HcReal: c :e real.
			        { rewrite <- HdefR. exact HcR. }
			        claim Hx0Real: x0 :e real.
			        { exact (real_div_SNo c HcReal a HaReal). }
			        rewrite HdefR.
			        exact Hx0Real. }
			      prove continuous_map R R_standard_topology (setprod {x0} R)
			        (subspace_topology (setprod R R)
			           (product_topology R R_lower_limit_topology R R_standard_topology)
			           (setprod {x0} R))
			        (affine_line_R2_param_by_y a b c)
		      /\ exists g:set,
		           continuous_map (setprod {x0} R)
		             (subspace_topology (setprod R R)
		               (product_topology R R_lower_limit_topology R R_standard_topology)
		               (setprod {x0} R))
		             R R_standard_topology g
		           /\ (forall x:set, x :e R -> apply_fun g (apply_fun (affine_line_R2_param_by_y a b c) x) = x)
		           /\ (forall y:set, y :e setprod {x0} R -> apply_fun (affine_line_R2_param_by_y a b c) (apply_fun g y) = y).
			      apply andI.
			      - set f := affine_line_R2_param_by_y a b c.
			        claim HcontProd: continuous_map R R_standard_topology EuclidPlane
			          (product_topology R R_lower_limit_topology R R_standard_topology) f.
			        { exact (affine_line_R2_param_by_y_continuous_in_product a b c
			                  R_lower_limit_topology R_standard_topology HTll HTstd HaR HcR). }
			        claim HsliceSub: (setprod {x0} R) c= EuclidPlane.
			        { let p. assume Hp: p :e setprod {x0} R.
			          claim HSingSub: {x0} c= R.
			          { exact (singleton_subset x0 R Hx0R). }
			          exact (setprod_Subq {x0} R R R HSingSub (Subq_ref R) p Hp). }
			        claim Himg: forall y:set, y :e R -> apply_fun f y :e setprod {x0} R.
			        { let y. assume HyR: y :e R.
			          rewrite (affine_line_R2_param_by_y_apply a b c y HyR).
				          exact (tuple_2_setprod_by_pair_Sigma {x0} R x0 y (SingI x0) HyR). }
			        exact (continuous_map_range_restrict R R_standard_topology EuclidPlane
			                  (product_topology R R_lower_limit_topology R R_standard_topology)
			                  f (setprod {x0} R) HcontProd HsliceSub Himg).
			      - witness (projection2 R R).
			        apply andI.
			        + apply andI.
			          * exact (projection2_continuous_on_vertical_slice x0
			                    R_lower_limit_topology R_standard_topology HTll HTstd Hx0R).
			          * let y. assume HyR: y :e R.
			            exact (projection2_after_affine_line_R2_param_by_y a b c y HaR HcR HyR).
			        + let p. assume Hp: p :e setprod {x0} R.
			          exact (affine_line_R2_param_by_y_after_projection2_on_slice a b c p HaR HcR Hp).
		    * assume Hbne: b <> 0.
		      witness (affine_line_R2_param_by_x a b c).
		      prove continuous_map R R_lower_limit_topology (affine_line_R2 a b c)
		        (subspace_topology (setprod R R)
		           (product_topology R R_lower_limit_topology R R_standard_topology)
		           (affine_line_R2 a b c))
		        (affine_line_R2_param_by_x a b c)
		      /\ exists g:set,
		           continuous_map (affine_line_R2 a b c)
		             (subspace_topology (setprod R R)
		               (product_topology R R_lower_limit_topology R R_standard_topology)
		               (affine_line_R2 a b c))
		             R R_lower_limit_topology g
		           /\ (forall x:set, x :e R -> apply_fun g (apply_fun (affine_line_R2_param_by_x a b c) x) = x)
		           /\ (forall y:set, y :e affine_line_R2 a b c -> apply_fun (affine_line_R2_param_by_x a b c) (apply_fun g y) = y).
		      apply andI.
		      - admit.
		      - witness (projection1 R R).
			        apply andI.
			        + apply andI.
			          * claim HTll: topology_on R R_lower_limit_topology.
			            { exact R_lower_limit_topology_is_topology. }
			            claim HTstd: topology_on R R_standard_topology.
			            { exact R_standard_topology_is_topology. }
			            claim HTprod: topology_on (setprod R R)
			              (product_topology R R_lower_limit_topology R R_standard_topology).
			            { exact (product_topology_is_topology R R_lower_limit_topology R R_standard_topology HTll HTstd). }
			            claim Hproj1Cont:
			              continuous_map (setprod R R)
			                (product_topology R R_lower_limit_topology R R_standard_topology)
			                R R_lower_limit_topology (projection1 R R).
			            { exact (projection1_continuous_in_product R R_lower_limit_topology R R_standard_topology HTll HTstd). }
			            claim Hsub: affine_line_R2 a b c c= setprod R R.
			            { exact (affine_line_R2_subset_R2 a b c). }
			            exact (continuous_on_subspace_rule (setprod R R)
			              (product_topology R R_lower_limit_topology R R_standard_topology)
			              R R_lower_limit_topology (projection1 R R) (affine_line_R2 a b c)
			              HTprod HTll Hsub Hproj1Cont).
			          * let x. assume HxR: x :e R.
			            exact (projection1_after_affine_line_R2_param_by_x a b c x HaR HbR HcR HxR).
			        + let p. assume Hp: p :e affine_line_R2 a b c.
			          exact (affine_line_R2_param_by_x_after_projection1_on_line a b c p HaR HbR HcR Hbne Hp).
		  + assume Hneg: b <> 0 /\ same_sign_nonzero_R a b.
		    witness (affine_line_R2_param_by_x a b c).
		    claim Hbne: b <> 0.
		    { apply Hneg.
		      assume Hbne0 Hsign.
		      exact Hbne0. }
		    claim Hsign: same_sign_nonzero_R a b.
		    { apply Hneg.
		      assume Hbne0 Hsign0.
		      exact Hsign0. }
		    set f := affine_line_R2_param_by_x a b c.
	    prove continuous_map R (discrete_topology R) (affine_line_R2 a b c)
	      (subspace_topology (setprod R R)
	         (product_topology R R_lower_limit_topology R R_lower_limit_topology)
	         (affine_line_R2 a b c)) f
	    /\ exists g:set,
	         continuous_map (affine_line_R2 a b c)
	           (subspace_topology (setprod R R)
	             (product_topology R R_lower_limit_topology R R_lower_limit_topology)
	             (affine_line_R2 a b c))
	           R (discrete_topology R) g
	         /\ (forall x:set, x :e R -> apply_fun g (apply_fun f x) = x)
	         /\ (forall y:set, y :e affine_line_R2 a b c -> apply_fun f (apply_fun g y) = y).
	    apply andI.
	    - (** continuity of f from a discrete domain **)
	      claim HTll: topology_on R R_lower_limit_topology.
	      { exact R_lower_limit_topology_is_topology. }
	      claim HTprod: topology_on (setprod R R)
	        (product_topology R R_lower_limit_topology R R_lower_limit_topology).
	      { exact (product_topology_is_topology R R_lower_limit_topology R R_lower_limit_topology HTll HTll). }
	      claim Hsub: affine_line_R2 a b c c= setprod R R.
	      { exact (affine_line_R2_subset_R2 a b c). }
	      claim HTcod: topology_on (affine_line_R2 a b c)
	        (subspace_topology (setprod R R)
	          (product_topology R R_lower_limit_topology R R_lower_limit_topology)
	          (affine_line_R2 a b c)).
	      { exact (subspace_topology_is_topology (setprod R R)
	        (product_topology R R_lower_limit_topology R R_lower_limit_topology)
	        (affine_line_R2 a b c) HTprod Hsub). }
		      claim Hfun: function_on f R (affine_line_R2 a b c).
		      { let x. assume HxR: x :e R.
		        exact (affine_line_R2_param_by_x_in_line a b c x HaR HbR HcR HxR Hbne). }
		      prove continuous_map R (discrete_topology R) (affine_line_R2 a b c)
		        (subspace_topology (setprod R R)
		          (product_topology R R_lower_limit_topology R R_lower_limit_topology)
		          (affine_line_R2 a b c)) f.
		      claim HTd: topology_on R (discrete_topology R).
		      { exact (discrete_topology_on R). }
		      prove topology_on R (discrete_topology R) /\ topology_on (affine_line_R2 a b c)
		        (subspace_topology (setprod R R)
		          (product_topology R R_lower_limit_topology R R_lower_limit_topology)
		          (affine_line_R2 a b c)) /\ function_on f R (affine_line_R2 a b c) /\
		        forall V:set, V :e (subspace_topology (setprod R R)
		          (product_topology R R_lower_limit_topology R R_lower_limit_topology)
		          (affine_line_R2 a b c)) -> preimage_of R f V :e discrete_topology R.
		      apply andI.
		      - prove (topology_on R (discrete_topology R) /\ topology_on (affine_line_R2 a b c)
		          (subspace_topology (setprod R R)
		            (product_topology R R_lower_limit_topology R R_lower_limit_topology)
		            (affine_line_R2 a b c))) /\ function_on f R (affine_line_R2 a b c).
		        apply andI.
		        * apply andI.
		          + exact HTd.
		          + exact HTcod.
		        * exact Hfun.
		      - let V. assume HV: V :e (subspace_topology (setprod R R)
		          (product_topology R R_lower_limit_topology R R_lower_limit_topology)
		          (affine_line_R2 a b c)).
		        prove preimage_of R f V :e discrete_topology R.
		        claim HsubV: preimage_of R f V c= R.
		        { let x. assume Hx: x :e preimage_of R f V.
		          exact (SepE1 R (fun u:set => apply_fun f u :e V) x Hx). }
		        exact (discrete_open_all R (preimage_of R f V) HsubV).
			    - witness (projection1 R R).
			      apply andI.
			      + apply andI.
				        * exact (projection1_continuous_on_affine_line_same_sign a b c HaR HbR HcR Hbne Hsign).
			        * let x. assume HxR: x :e R.
			          exact (projection1_after_affine_line_R2_param_by_x a b c x HaR HbR HcR HxR).
			      + let p. assume Hp: p :e affine_line_R2 a b c.
			        exact (affine_line_R2_param_by_x_after_projection1_on_line a b c p HaR HbR HcR Hbne Hp).
  - assume Hcase: b = 0 \/ ~ same_sign_nonzero_R a b.
	  claim Hb0case: b = 0 ->
	    exists f:set,
	      homeomorphism R R_lower_limit_topology (affine_line_R2 a b c)
	        (subspace_topology (setprod R R)
	           (product_topology R R_lower_limit_topology R R_lower_limit_topology)
	           (affine_line_R2 a b c)) f.
		  { assume Hb0: b = 0.
		    claim Ha0: a <> 0.
	    { prove ~ (a = 0).
	      assume Ha0eq: a = 0.
	      prove False.
	      apply Hnotboth.
	      apply andI.
	      - exact Ha0eq.
	      - exact Hb0. }
	    set x0 := div_SNo c a.
	    claim HeqLine: affine_line_R2 a b c = setprod {x0} R.
	    { exact (affine_line_R2_b0_eq_slice a b c HaR HbR HcR Hb0 Ha0). }
		    witness (affine_line_R2_param_by_y a b c).
		    rewrite HeqLine.
		    claim HTll: topology_on R R_lower_limit_topology.
		    { exact R_lower_limit_topology_is_topology. }
		    claim Hx0R: x0 :e R.
		    { claim HdefR: R = real.
		      { reflexivity. }
		      claim HaReal: a :e real.
		      { rewrite <- HdefR. exact HaR. }
		      claim HcReal: c :e real.
		      { rewrite <- HdefR. exact HcR. }
		      claim Hx0Real: x0 :e real.
		      { exact (real_div_SNo c HcReal a HaReal). }
		      rewrite HdefR.
		      exact Hx0Real. }
		    prove continuous_map R R_lower_limit_topology (setprod {x0} R)
		      (subspace_topology (setprod R R)
		         (product_topology R R_lower_limit_topology R R_lower_limit_topology)
		         (setprod {x0} R))
		      (affine_line_R2_param_by_y a b c)
	    /\ exists g:set,
	         continuous_map (setprod {x0} R)
	           (subspace_topology (setprod R R)
	             (product_topology R R_lower_limit_topology R R_lower_limit_topology)
	             (setprod {x0} R))
	           R R_lower_limit_topology g
	         /\ (forall x:set, x :e R -> apply_fun g (apply_fun (affine_line_R2_param_by_y a b c) x) = x)
	         /\ (forall y:set, y :e setprod {x0} R -> apply_fun (affine_line_R2_param_by_y a b c) (apply_fun g y) = y).
		    apply andI.
		    - set f := affine_line_R2_param_by_y a b c.
		      claim HcontProd: continuous_map R R_lower_limit_topology EuclidPlane
		        (product_topology R R_lower_limit_topology R R_lower_limit_topology) f.
		      { exact (affine_line_R2_param_by_y_continuous_in_product a b c
		                R_lower_limit_topology R_lower_limit_topology HTll HTll HaR HcR). }
		      claim HsliceSub: (setprod {x0} R) c= EuclidPlane.
		      { let p. assume Hp: p :e setprod {x0} R.
		        claim HSingSub: {x0} c= R.
		        { exact (singleton_subset x0 R Hx0R). }
		        exact (setprod_Subq {x0} R R R HSingSub (Subq_ref R) p Hp). }
		      claim Himg: forall y:set, y :e R -> apply_fun f y :e setprod {x0} R.
		      { let y. assume HyR: y :e R.
		        rewrite (affine_line_R2_param_by_y_apply a b c y HyR).
		        exact (tuple_2_setprod_by_pair_Sigma {x0} R x0 y (SingI x0) HyR). }
		      exact (continuous_map_range_restrict R R_lower_limit_topology EuclidPlane
		                (product_topology R R_lower_limit_topology R R_lower_limit_topology)
		                f (setprod {x0} R) HcontProd HsliceSub Himg).
		    - witness (projection2 R R).
		      apply andI.
		      + apply andI.
		        * exact (projection2_continuous_on_vertical_slice x0
		                  R_lower_limit_topology R_lower_limit_topology HTll HTll Hx0R).
		        * let y. assume HyR: y :e R.
		          exact (projection2_after_affine_line_R2_param_by_y a b c y HaR HcR HyR).
		      + let p. assume Hp: p :e setprod {x0} R.
		        exact (affine_line_R2_param_by_y_after_projection2_on_slice a b c p HaR HcR Hp). }
	  claim Hnotsigncase: ~ same_sign_nonzero_R a b ->
	    exists f:set,
	      homeomorphism R R_lower_limit_topology (affine_line_R2 a b c)
	        (subspace_topology (setprod R R)
	           (product_topology R R_lower_limit_topology R R_lower_limit_topology)
	           (affine_line_R2 a b c)) f.
	  { assume Hnotsign: ~ same_sign_nonzero_R a b.
	    apply (xm (b = 0)).
	    - assume Hb0: b = 0.
	      exact (Hb0case Hb0).
	    - assume Hbne: b <> 0.
	      witness (affine_line_R2_param_by_x a b c).
		      prove continuous_map R R_lower_limit_topology (affine_line_R2 a b c)
		        (subspace_topology (setprod R R)
		           (product_topology R R_lower_limit_topology R R_lower_limit_topology)
		           (affine_line_R2 a b c))
		        (affine_line_R2_param_by_x a b c)
		      /\ exists g:set,
		           continuous_map (affine_line_R2 a b c)
		             (subspace_topology (setprod R R)
		               (product_topology R R_lower_limit_topology R R_lower_limit_topology)
		               (affine_line_R2 a b c))
		             R R_lower_limit_topology g
		           /\ (forall x:set, x :e R -> apply_fun g (apply_fun (affine_line_R2_param_by_x a b c) x) = x)
		           /\ (forall y:set, y :e affine_line_R2 a b c -> apply_fun (affine_line_R2_param_by_x a b c) (apply_fun g y) = y).
		      apply andI.
			      - set f := affine_line_R2_param_by_x a b c.
			        claim HTll: topology_on R R_lower_limit_topology.
			        { exact R_lower_limit_topology_is_topology. }
			        claim HcontProd: continuous_map R R_lower_limit_topology (setprod R R)
			          (product_topology R R_lower_limit_topology R R_lower_limit_topology) f.
			        { admit. }
			        claim Hsub: affine_line_R2 a b c c= setprod R R.
			        { exact (affine_line_R2_subset_R2 a b c). }
			        claim Himg: forall x:set, x :e R -> apply_fun f x :e affine_line_R2 a b c.
			        { let x. assume HxR: x :e R.
			          exact (affine_line_R2_param_by_x_in_line a b c x HaR HbR HcR HxR Hbne). }
			        exact (continuous_map_range_restrict R R_lower_limit_topology (setprod R R)
			          (product_topology R R_lower_limit_topology R R_lower_limit_topology)
			          f (affine_line_R2 a b c) HcontProd Hsub Himg).
		      - witness (projection1 R R).
		        apply andI.
		        + apply andI.
		          * claim HTll: topology_on R R_lower_limit_topology.
	            { exact R_lower_limit_topology_is_topology. }
	            claim HTprod: topology_on (setprod R R)
	              (product_topology R R_lower_limit_topology R R_lower_limit_topology).
	            { exact (product_topology_is_topology R R_lower_limit_topology R R_lower_limit_topology HTll HTll). }
	            claim Hproj1Cont:
	              continuous_map (setprod R R)
	                (product_topology R R_lower_limit_topology R R_lower_limit_topology)
	                R R_lower_limit_topology (projection1 R R).
	            { exact (projection1_continuous_in_product R R_lower_limit_topology R R_lower_limit_topology HTll HTll). }
	            claim Hsub: affine_line_R2 a b c c= setprod R R.
	            { exact (affine_line_R2_subset_R2 a b c). }
	            exact (continuous_on_subspace_rule (setprod R R)
	              (product_topology R R_lower_limit_topology R R_lower_limit_topology)
	              R R_lower_limit_topology (projection1 R R) (affine_line_R2 a b c)
	              HTprod HTll Hsub Hproj1Cont).
	          * let x. assume HxR: x :e R.
	            exact (projection1_after_affine_line_R2_param_by_x a b c x HaR HbR HcR HxR).
	        + let p. assume Hp: p :e affine_line_R2 a b c.
	          exact (affine_line_R2_param_by_x_after_projection1_on_line a b c p HaR HbR HcR Hbne Hp).
	  }
	  exact (Hcase
	    (exists f:set,
	      homeomorphism R R_lower_limit_topology (affine_line_R2 a b c)
	        (subspace_topology (setprod R R)
           (product_topology R R_lower_limit_topology R R_lower_limit_topology)
           (affine_line_R2 a b c)) f)
    Hb0case
    Hnotsigncase).
Qed.

(** helper: homeomorphisms are injective **)
(** LATEX VERSION: A homeomorphism is injective (as it has a two-sided inverse). **)
Theorem homeomorphism_injective : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f ->
  forall x1 x2:set, x1 :e X -> x2 :e X -> apply_fun f x1 = apply_fun f x2 -> x1 = x2.
let X Tx Y Ty f.
assume Hhom: homeomorphism X Tx Y Ty f.
let x1 x2.
assume Hx1X: x1 :e X.
assume Hx2X: x2 :e X.
assume Heq: apply_fun f x1 = apply_fun f x2.
prove x1 = x2.
claim Hexg:
  exists g:set, continuous_map Y Ty X Tx g /\
    (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
    (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y).
{ exact (andER (continuous_map X Tx Y Ty f)
               (exists g:set, continuous_map Y Ty X Tx g /\
                 (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
                 (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y))
               Hhom). }
apply Hexg.
let g. assume Hgprop.
claim Hginv: forall x:set, x :e X -> apply_fun g (apply_fun f x) = x.
{ exact (andER (continuous_map Y Ty X Tx g)
               (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x)
               (andEL (continuous_map Y Ty X Tx g /\
                      (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x))
                     (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y)
                     Hgprop)). }
rewrite <- (Hginv x1 Hx1X).
rewrite <- (Hginv x2 Hx2X).
rewrite Heq.
reflexivity.
Qed.

(** from 18: continuous maps on subspaces **) 
(** LATEX VERSION: Restricting a continuous map to a subspace remains continuous. **)
Theorem continuous_on_subspace : forall X Tx Y Ty f A:set,
  topology_on X Tx -> A c= X ->
  continuous_map X Tx Y Ty f ->
  continuous_map A (subspace_topology X Tx A) Y Ty f.
let X Tx Y Ty f A.
assume HTx: topology_on X Tx.
assume HA: A c= X.
assume Hf: continuous_map X Tx Y Ty f.
prove continuous_map A (subspace_topology X Tx A) Y Ty f.
(** Strategy: f continuous on X means f(V) open in X for each V open in Y; for subspace topology on A, show f(V) is open in subspace_topology by taking U = f(V) in the representation (U :/\: A). **)
(** Extract components from Hf - but we already have HTx as a hypothesis, so we mainly need the others **)
(** Hf: topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y /\ (forall V...) **)
claim HTy: topology_on Y Ty.
{ exact (andER (topology_on X Tx) (topology_on Y Ty)
          (andEL (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y)
            (andEL (topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y)
                   (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
                   Hf))). }
claim Hfun: function_on f X Y.
{ exact (andER (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y)
          (andEL (topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y)
                 (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
                 Hf)). }
claim Hf_preimg: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
{ exact (andER (topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               Hf). }
(** Build continuous_map A (subspace_topology X Tx A) Y Ty f **)
claim HTsubspace: topology_on A (subspace_topology X Tx A).
{ exact (subspace_topology_is_topology X Tx A HTx HA). }
claim Hfun_A: function_on f A Y.
{ prove forall x:set, x :e A -> apply_fun f x :e Y.
  let x. assume HxA: x :e A.
  claim HxX: x :e X.
  { exact (HA x HxA). }
  exact (Hfun x HxX). }
(** Show preimages are open in subspace topology **)
claim Hpreimg_subspace: forall V:set, V :e Ty -> preimage_of A f V :e subspace_topology X Tx A.
{ let V. assume HV: V :e Ty.
  prove preimage_of A f V :e subspace_topology X Tx A.
  (** preimage_of A f V = {x :e A | apply_fun f x :e V} = preimage_of X f V  A **)
  set U := preimage_of X f V.
  claim HU_open: U :e Tx.
  { exact (Hf_preimg V HV). }
  (** Show preimage_of A f V = U  A **)
  claim Hpreimg_eq: preimage_of A f V = U :/\: A.
  { apply set_ext.
    - let x. assume Hx: x :e preimage_of A f V.
      prove x :e U :/\: A.
      claim HxA: x :e A.
      { exact (SepE1 A (fun y => apply_fun f y :e V) x Hx). }
      claim Hfx_V: apply_fun f x :e V.
      { exact (SepE2 A (fun y => apply_fun f y :e V) x Hx). }
      claim HxX: x :e X.
      { exact (HA x HxA). }
      claim HxU: x :e U.
      { exact (SepI X (fun y => apply_fun f y :e V) x HxX Hfx_V). }
      exact (binintersectI U A x HxU HxA).
    - let x. assume Hx: x :e U :/\: A.
      prove x :e preimage_of A f V.
      claim HxU: x :e U.
      { exact (binintersectE1 U A x Hx). }
      claim HxA: x :e A.
      { exact (binintersectE2 U A x Hx). }
      claim Hfx_V: apply_fun f x :e V.
      { exact (SepE2 X (fun y => apply_fun f y :e V) x HxU). }
      exact (SepI A (fun y => apply_fun f y :e V) x HxA Hfx_V). }
  (** Now show preimage_of A f V is in subspace_topology **)
  prove preimage_of A f V :e {W :e Power A | exists Z :e Tx, W = Z :/\: A}.
  claim HpAV_PowerA: preimage_of A f V :e Power A.
  { apply PowerI.
    let x. assume Hx: x :e preimage_of A f V.
    exact (SepE1 A (fun y => apply_fun f y :e V) x Hx). }
  claim Hexists: exists Z :e Tx, preimage_of A f V = Z :/\: A.
  { witness U.
    apply andI.
    - exact HU_open.
    - exact Hpreimg_eq. }
  exact (SepI (Power A) (fun W => exists Z :e Tx, W = Z :/\: A) (preimage_of A f V) HpAV_PowerA Hexists). }
(** Build the full conjunction for continuous_map **)
(** Need: topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty /\ function_on f A Y /\ (forall V:set, V :e Ty -> preimage_of A f V :e subspace_topology X Tx A); this is left-associative: (((A /\ B) /\ C) /\ D). **)
claim Hpart1: topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty.
{ apply andI.
  - exact HTsubspace.
  - exact HTy. }
claim Hpart2: (topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty) /\ function_on f A Y.
{ apply andI.
  - exact Hpart1.
  - exact Hfun_A. }
prove (topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty /\ function_on f A Y) /\
      (forall V:set, V :e Ty -> preimage_of A f V :e subspace_topology X Tx A).
apply andI.
- exact Hpart2.
- exact Hpreimg_subspace.
Qed.

(** from 18: inverse of homeomorphism is continuous **)
(** LATEX VERSION: The inverse of a homeomorphism is continuous. **)
Theorem homeomorphism_inverse_continuous : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f ->
  exists g:set, continuous_map Y Ty X Tx g /\
    (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
    (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y).
let X Tx Y Ty f.
assume Hhom: homeomorphism X Tx Y Ty f.
prove exists g:set, continuous_map Y Ty X Tx g /\
  (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
  (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y).
(** By definition of homeomorphism, the continuous inverse g exists. **)
exact (andER (continuous_map X Tx Y Ty f)
             (exists g:set, continuous_map Y Ty X Tx g /\
                (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
                (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y))
             Hhom).
Qed.

(** Helper: function_on for a pasted total functional map **)
Theorem function_union_on_disjoint_total_functional : forall A B Y f g:set,
  A :/\: B = Empty ->
  graph_domain_subset f A ->
  graph_domain_subset g B ->
  total_function_on f A Y ->
  total_function_on g B Y ->
  functional_graph f ->
  functional_graph g ->
  function_on (f :\/: g) (A :\/: B) Y.
let A B Y f g.
assume Hdisj: A :/\: B = Empty.
assume Hdomf: graph_domain_subset f A.
assume Hdomg: graph_domain_subset g B.
assume Htotf: total_function_on f A Y.
assume Htotg: total_function_on g B Y.
assume Hfunf: functional_graph f.
assume Hfung: functional_graph g.
claim Hrf: graph_range_subset f Y.
{ exact (graph_range_subset_from_total_functional A Y f Hdomf Htotf Hfunf). }
claim Hrg: graph_range_subset g Y.
{ exact (graph_range_subset_from_total_functional B Y g Hdomg Htotg Hfung). }
claim Hrfg: graph_range_subset (f :\/: g) Y.
{ exact (graph_range_subset_binunion f g Y Hrf Hrg). }
claim Htotfg: forall x:set, x :e (A :\/: B) -> exists y:set, y :e Y /\ (x,y) :e (f :\/: g).
{ let x. assume Hx: x :e (A :\/: B).
  apply (binunionE A B x Hx).
  - assume HxA: x :e A.
    apply (total_function_on_totality f A Y Htotf x HxA).
    let y. assume Hy: y :e Y /\ (x,y) :e f.
    witness y.
    apply andI.
    + exact (andEL (y :e Y) ((x,y) :e f) Hy).
    + exact (binunionI1 f g (x,y) (andER (y :e Y) ((x,y) :e f) Hy)).
  - assume HxB: x :e B.
    apply (total_function_on_totality g B Y Htotg x HxB).
    let y. assume Hy: y :e Y /\ (x,y) :e g.
    witness y.
    apply andI.
    + exact (andEL (y :e Y) ((x,y) :e g) Hy).
    + exact (binunionI2 f g (x,y) (andER (y :e Y) ((x,y) :e g) Hy)). }
exact (function_on_from_totality_and_range (A :\/: B) Y (f :\/: g) Htotfg Hrfg).
Qed.

(** Helper: total_function_on for a pasted total functional map **)
Theorem total_function_union_on_disjoint_total_functional : forall A B Y f g:set,
  A :/\: B = Empty ->
  graph_domain_subset f A ->
  graph_domain_subset g B ->
  total_function_on f A Y ->
  total_function_on g B Y ->
  functional_graph f ->
  functional_graph g ->
  total_function_on (f :\/: g) (A :\/: B) Y.
let A B Y f g.
assume Hdisj: A :/\: B = Empty.
assume Hdomf: graph_domain_subset f A.
assume Hdomg: graph_domain_subset g B.
assume Htotf: total_function_on f A Y.
assume Htotg: total_function_on g B Y.
assume Hfunf: functional_graph f.
assume Hfung: functional_graph g.
prove function_on (f :\/: g) (A :\/: B) Y /\
  forall x:set, x :e (A :\/: B) -> exists y:set, y :e Y /\ (x,y) :e (f :\/: g).
apply andI.
- exact (function_union_on_disjoint_total_functional A B Y f g
           Hdisj Hdomf Hdomg Htotf Htotg Hfunf Hfung).
- let x. assume Hx: x :e (A :\/: B).
  prove exists y:set, y :e Y /\ (x,y) :e (f :\/: g).
  apply (binunionE A B x Hx).
  * assume HxA: x :e A.
    apply (total_function_on_totality f A Y Htotf x HxA).
    let y. assume Hy: y :e Y /\ (x,y) :e f.
    witness y.
    apply andI.
    { exact (andEL (y :e Y) ((x,y) :e f) Hy). }
    { exact (binunionI1 f g (x,y) (andER (y :e Y) ((x,y) :e f) Hy)). }
  * assume HxB: x :e B.
    apply (total_function_on_totality g B Y Htotg x HxB).
    let y. assume Hy: y :e Y /\ (x,y) :e g.
    witness y.
    apply andI.
    { exact (andEL (y :e Y) ((x,y) :e g) Hy). }
    { exact (binunionI2 f g (x,y) (andER (y :e Y) ((x,y) :e g) Hy)). }
Qed.

(** Helper: union of functional graphs with disjoint domains is functional **)
Theorem functional_graph_union_disjoint_domains : forall A B f g:set,
  A :/\: B = Empty ->
  graph_domain_subset f A ->
  graph_domain_subset g B ->
  functional_graph f ->
  functional_graph g ->
  functional_graph (f :\/: g).
let A B f g.
assume Hdisj: A :/\: B = Empty.
assume Hdomf: graph_domain_subset f A.
assume Hdomg: graph_domain_subset g B.
assume Hfunf: functional_graph f.
assume Hfung: functional_graph g.
let x y1 y2.
assume H1: (x,y1) :e (f :\/: g).
assume H2: (x,y2) :e (f :\/: g).
apply (binunionE f g (x,y1) H1).
- assume H1f: (x,y1) :e f.
  apply (binunionE f g (x,y2) H2).
  + assume H2f: (x,y2) :e f.
    exact (Hfunf x y1 y2 H1f H2f).
  + assume H2g: (x,y2) :e g.
    claim HxA: x :e A.
    { exact (Hdomf x y1 H1f). }
    claim HxB: x :e B.
    { exact (Hdomg x y2 H2g). }
    claim HxAB: x :e A :/\: B.
    { exact (binintersectI A B x HxA HxB). }
    claim HxE: x :e Empty.
    { rewrite <- Hdisj.
      exact HxAB. }
    apply FalseE.
    exact ((EmptyE x) HxE).
- assume H1g: (x,y1) :e g.
  apply (binunionE f g (x,y2) H2).
  + assume H2f: (x,y2) :e f.
    claim HxB: x :e B.
    { exact (Hdomg x y1 H1g). }
    claim HxA: x :e A.
    { exact (Hdomf x y2 H2f). }
    claim HxAB: x :e A :/\: B.
    { exact (binintersectI A B x HxA HxB). }
    claim HxE: x :e Empty.
    { rewrite <- Hdisj.
      exact HxAB. }
    apply FalseE.
    exact ((EmptyE x) HxE).
  + assume H2g: (x,y2) :e g.
    exact (Hfung x y1 y2 H1g H2g).
Qed.

(** Helper: apply_fun on a pasted total functional map, left side **)
Theorem apply_fun_union_left : forall A B Y f g x:set,
  A :/\: B = Empty ->
  graph_domain_subset f A ->
  graph_domain_subset g B ->
  total_function_on f A Y ->
  total_function_on g B Y ->
  functional_graph f ->
  functional_graph g ->
  x :e A ->
  apply_fun (f :\/: g) x = apply_fun f x.
let A B Y f g x.
assume Hdisj: A :/\: B = Empty.
assume Hdomf: graph_domain_subset f A.
assume Hdomg: graph_domain_subset g B.
assume Htotf: total_function_on f A Y.
assume Htotg: total_function_on g B Y.
assume Hfunf: functional_graph f.
assume Hfung: functional_graph g.
assume HxA: x :e A.
claim Hpairf: (x, apply_fun f x) :e f.
{ exact (total_function_on_apply_fun_in_graph f A Y x Htotf HxA). }
claim HpairU: (x, apply_fun f x) :e (f :\/: g).
{ exact (binunionI1 f g (x, apply_fun f x) Hpairf). }
claim HfunU: functional_graph (f :\/: g).
{ exact (functional_graph_union_disjoint_domains A B f g Hdisj Hdomf Hdomg Hfunf Hfung). }
exact (functional_graph_apply_fun_eq (f :\/: g) x (apply_fun f x) HfunU HpairU).
Qed.

(** Helper: apply_fun on a pasted total functional map, right side **)
Theorem apply_fun_union_right : forall A B Y f g x:set,
  A :/\: B = Empty ->
  graph_domain_subset f A ->
  graph_domain_subset g B ->
  total_function_on f A Y ->
  total_function_on g B Y ->
  functional_graph f ->
  functional_graph g ->
  x :e B ->
  apply_fun (f :\/: g) x = apply_fun g x.
let A B Y f g x.
assume Hdisj: A :/\: B = Empty.
assume Hdomf: graph_domain_subset f A.
assume Hdomg: graph_domain_subset g B.
assume Htotf: total_function_on f A Y.
assume Htotg: total_function_on g B Y.
assume Hfunf: functional_graph f.
assume Hfung: functional_graph g.
assume HxB: x :e B.
claim Hpairg: (x, apply_fun g x) :e g.
{ exact (total_function_on_apply_fun_in_graph g B Y x Htotg HxB). }
claim HpairU: (x, apply_fun g x) :e (f :\/: g).
{ exact (binunionI2 f g (x, apply_fun g x) Hpairg). }
claim HfunU: functional_graph (f :\/: g).
{ exact (functional_graph_union_disjoint_domains A B f g Hdisj Hdomf Hdomg Hfunf Hfung). }
exact (functional_graph_apply_fun_eq (f :\/: g) x (apply_fun g x) HfunU HpairU).
Qed.

(** Helper: preimage decomposition for pasted total functional maps **)
Theorem preimage_of_union_functions_total : forall A B Y f g V:set,
  A :/\: B = Empty ->
  graph_domain_subset f A ->
  graph_domain_subset g B ->
  total_function_on f A Y ->
  total_function_on g B Y ->
  functional_graph f ->
  functional_graph g ->
  preimage_of (A :\/: B) (f :\/: g) V =
    (preimage_of A f V) :\/: (preimage_of B g V).
let A B Y f g V.
assume Hdisj: A :/\: B = Empty.
assume Hdomf: graph_domain_subset f A.
assume Hdomg: graph_domain_subset g B.
assume Htotf: total_function_on f A Y.
assume Htotg: total_function_on g B Y.
assume Hfunf: functional_graph f.
assume Hfung: functional_graph g.
apply set_ext.
- let x. assume Hx: x :e preimage_of (A :\/: B) (f :\/: g) V.
  prove x :e (preimage_of A f V) :\/: (preimage_of B g V).
  claim HxAB: x :e (A :\/: B).
  { exact (SepE1 (A :\/: B) (fun x0:set => apply_fun (f :\/: g) x0 :e V) x Hx). }
  claim HfxV: apply_fun (f :\/: g) x :e V.
  { exact (SepE2 (A :\/: B) (fun x0:set => apply_fun (f :\/: g) x0 :e V) x Hx). }
  apply (binunionE A B x HxAB).
  * assume HxA: x :e A.
    claim Happ: apply_fun (f :\/: g) x = apply_fun f x.
    { exact (apply_fun_union_left A B Y f g x Hdisj Hdomf Hdomg Htotf Htotg Hfunf Hfung HxA). }
    claim Hfx: apply_fun f x :e V.
    { rewrite <- Happ.
      exact HfxV. }
    claim HxPre: x :e preimage_of A f V.
    { exact (SepI A (fun x0:set => apply_fun f x0 :e V) x HxA Hfx). }
    exact (binunionI1 (preimage_of A f V) (preimage_of B g V) x HxPre).
  * assume HxB: x :e B.
    claim Happ: apply_fun (f :\/: g) x = apply_fun g x.
    { exact (apply_fun_union_right A B Y f g x Hdisj Hdomf Hdomg Htotf Htotg Hfunf Hfung HxB). }
    claim Hgx: apply_fun g x :e V.
    { rewrite <- Happ.
      exact HfxV. }
    claim HxPre: x :e preimage_of B g V.
    { exact (SepI B (fun x0:set => apply_fun g x0 :e V) x HxB Hgx). }
    exact (binunionI2 (preimage_of A f V) (preimage_of B g V) x HxPre).
- let x. assume Hx: x :e (preimage_of A f V) :\/: (preimage_of B g V).
  prove x :e preimage_of (A :\/: B) (f :\/: g) V.
  apply (binunionE (preimage_of A f V) (preimage_of B g V) x Hx).
  * assume HxPreA: x :e preimage_of A f V.
    claim HxA: x :e A.
    { exact (SepE1 A (fun x0:set => apply_fun f x0 :e V) x HxPreA). }
    claim HfxV: apply_fun f x :e V.
    { exact (SepE2 A (fun x0:set => apply_fun f x0 :e V) x HxPreA). }
    claim HxAB: x :e A :\/: B.
    { exact (binunionI1 A B x HxA). }
    claim Happ: apply_fun (f :\/: g) x = apply_fun f x.
    { exact (apply_fun_union_left A B Y f g x Hdisj Hdomf Hdomg Htotf Htotg Hfunf Hfung HxA). }
    claim HfgV: apply_fun (f :\/: g) x :e V.
    { rewrite Happ.
      exact HfxV. }
    exact (SepI (A :\/: B) (fun x0:set => apply_fun (f :\/: g) x0 :e V) x HxAB HfgV).
  * assume HxPreB: x :e preimage_of B g V.
    claim HxB: x :e B.
    { exact (SepE1 B (fun x0:set => apply_fun g x0 :e V) x HxPreB). }
    claim HgxV: apply_fun g x :e V.
    { exact (SepE2 B (fun x0:set => apply_fun g x0 :e V) x HxPreB). }
    claim HxAB: x :e A :\/: B.
    { exact (binunionI2 A B x HxB). }
    claim Happ: apply_fun (f :\/: g) x = apply_fun g x.
    { exact (apply_fun_union_right A B Y f g x Hdisj Hdomf Hdomg Htotf Htotg Hfunf Hfung HxB). }
    claim HfgV: apply_fun (f :\/: g) x :e V.
    { rewrite Happ.
      exact HgxV. }
    exact (SepI (A :\/: B) (fun x0:set => apply_fun (f :\/: g) x0 :e V) x HxAB HfgV).
Qed.

(** Helper: unions of open subsets of disjoint open subspaces are open in the union subspace **)
Theorem subspace_union_of_opens : forall X Tx A B U V:set,
  topology_on X Tx -> A :e Tx -> B :e Tx -> A :/\: B = Empty ->
  U :e subspace_topology X Tx A ->
  V :e subspace_topology X Tx B ->
  (U :\/: V) :e subspace_topology X Tx (A :\/: B).
let X Tx A B U V.
assume HTx: topology_on X Tx.
assume HA: A :e Tx.
assume HB: B :e Tx.
assume Hdisj: A :/\: B = Empty.
assume HU: U :e subspace_topology X Tx A.
assume HV: V :e subspace_topology X Tx B.
prove (U :\/: V) :e subspace_topology X Tx (A :\/: B).
(** Unpack U open in subspace A **)
claim HUpowA: U :e Power A.
{ exact (SepE1 (Power A) (fun U0:set => exists W :e Tx, U0 = W :/\: A) U HU). }
claim HUsubA: U c= A.
{ exact (PowerE A U HUpowA). }
claim HexWU: exists W :e Tx, U = W :/\: A.
{ exact (SepE2 (Power A) (fun U0:set => exists W :e Tx, U0 = W :/\: A) U HU). }
apply HexWU.
let WU. assume HWUpair.
claim HWUinTx: WU :e Tx.
{ exact (andEL (WU :e Tx) (U = WU :/\: A) HWUpair). }
claim HUeq: U = WU :/\: A.
{ exact (andER (WU :e Tx) (U = WU :/\: A) HWUpair). }
claim HUAinTx: WU :/\: A :e Tx.
{ exact (topology_binintersect_closed X Tx WU A HTx HWUinTx HA). }
claim HUinTx: U :e Tx.
{ rewrite HUeq. exact HUAinTx. }

(** Unpack V open in subspace B **)
claim HVpowB: V :e Power B.
{ exact (SepE1 (Power B) (fun V0:set => exists W :e Tx, V0 = W :/\: B) V HV). }
claim HVsubB: V c= B.
{ exact (PowerE B V HVpowB). }
claim HexWV: exists W :e Tx, V = W :/\: B.
{ exact (SepE2 (Power B) (fun V0:set => exists W :e Tx, V0 = W :/\: B) V HV). }
apply HexWV.
let WV. assume HWVpair.
claim HWVinTx: WV :e Tx.
{ exact (andEL (WV :e Tx) (V = WV :/\: B) HWVpair). }
claim HVeql: V = WV :/\: B.
{ exact (andER (WV :e Tx) (V = WV :/\: B) HWVpair). }
claim HVBinTx: WV :/\: B :e Tx.
{ exact (topology_binintersect_closed X Tx WV B HTx HWVinTx HB). }
claim HVinTx: V :e Tx.
{ rewrite HVeql. exact HVBinTx. }

(** Hence UV is open in X, and it lies in AB **)
claim HUVinTx: (U :\/: V) :e Tx.
{ exact (topology_binunion_closed X Tx U V HTx HUinTx HVinTx). }
claim HAsubAB: A c= A :\/: B.
{ exact (binunion_Subq_1 A B). }
claim HBsubAB: B c= A :\/: B.
{ exact (binunion_Subq_2 A B). }
claim HUsubAB: U c= A :\/: B.
{ let x. assume Hx: x :e U.
  prove x :e A :\/: B.
  exact (HAsubAB x (HUsubA x Hx)). }
claim HVsubAB: V c= A :\/: B.
{ let x. assume Hx: x :e V.
  prove x :e A :\/: B.
  exact (HBsubAB x (HVsubB x Hx)). }
claim HUVsubAB: (U :\/: V) c= A :\/: B.
{ exact (binunion_Subq_min U V (A :\/: B) HUsubAB HVsubAB). }
claim HUVpowAB: (U :\/: V) :e Power (A :\/: B).
{ exact (PowerI (A :\/: B) (U :\/: V) HUVsubAB). }

(** Apply subspace_topology definition on AB, using witness W = UV **)
claim HPred: exists W :e Tx, (U :\/: V) = W :/\: (A :\/: B).
{ witness (U :\/: V).
  apply andI.
  + exact HUVinTx.
  + prove (U :\/: V) = (U :\/: V) :/\: (A :\/: B).
    claim Heq: (U :\/: V) :/\: (A :\/: B) = (U :\/: V).
    { exact (binintersect_Subq_eq_1 (U :\/: V) (A :\/: B) HUVsubAB). }
    rewrite Heq.
    reflexivity. }
exact (SepI (Power (A :\/: B))
            (fun U0:set => exists W :e Tx, U0 = W :/\: (A :\/: B))
            (U :\/: V) HUVpowAB HPred).
Qed.

(** Helper: pasting lemma variant for total functional maps **)
Theorem pasting_lemma_total_functional : forall X A B Y Tx Ty f g:set,
  topology_on X Tx ->
  A :e Tx -> B :e Tx -> A :/\: B = Empty ->
  graph_domain_subset f A ->
  graph_domain_subset g B ->
  functional_graph f ->
  functional_graph g ->
  continuous_map_total A (subspace_topology X Tx A) Y Ty f ->
  continuous_map_total B (subspace_topology X Tx B) Y Ty g ->
  continuous_map_total (A :\/: B) (subspace_topology X Tx (A :\/: B)) Y Ty (f :\/: g).
let X A B Y Tx Ty f g.
assume HTx: topology_on X Tx.
assume HA: A :e Tx.
assume HB: B :e Tx.
assume Hdisj: A :/\: B = Empty.
assume Hdomf: graph_domain_subset f A.
assume Hdomg: graph_domain_subset g B.
assume Hfunf: functional_graph f.
assume Hfung: functional_graph g.
assume Hf: continuous_map_total A (subspace_topology X Tx A) Y Ty f.
assume Hg: continuous_map_total B (subspace_topology X Tx B) Y Ty g.
prove continuous_map_total (A :\/: B) (subspace_topology X Tx (A :\/: B)) Y Ty (f :\/: g).

(** Extract components from Hf **)
claim Hf_left: (topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty) /\ total_function_on f A Y.
{ exact (andEL ((topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty) /\ total_function_on f A Y)
               (forall V:set, V :e Ty -> preimage_of A f V :e subspace_topology X Tx A) Hf). }
claim Hpreimg_f: forall V:set, V :e Ty -> preimage_of A f V :e subspace_topology X Tx A.
{ exact (andER ((topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty) /\ total_function_on f A Y)
               (forall V:set, V :e Ty -> preimage_of A f V :e subspace_topology X Tx A) Hf). }
claim Hf_tops: topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty.
{ exact (andEL (topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty)
               (total_function_on f A Y) Hf_left). }
claim HTy: topology_on Y Ty.
{ exact (andER (topology_on A (subspace_topology X Tx A)) (topology_on Y Ty) Hf_tops). }
claim Htotf: total_function_on f A Y.
{ exact (andER (topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty)
               (total_function_on f A Y) Hf_left). }

(** Extract components from Hg **)
claim Hg_left: (topology_on B (subspace_topology X Tx B) /\ topology_on Y Ty) /\ total_function_on g B Y.
{ exact (andEL ((topology_on B (subspace_topology X Tx B) /\ topology_on Y Ty) /\ total_function_on g B Y)
               (forall V:set, V :e Ty -> preimage_of B g V :e subspace_topology X Tx B) Hg). }
claim Hpreimg_g: forall V:set, V :e Ty -> preimage_of B g V :e subspace_topology X Tx B.
{ exact (andER ((topology_on B (subspace_topology X Tx B) /\ topology_on Y Ty) /\ total_function_on g B Y)
               (forall V:set, V :e Ty -> preimage_of B g V :e subspace_topology X Tx B) Hg). }
claim Htotg: total_function_on g B Y.
{ exact (andER (topology_on B (subspace_topology X Tx B) /\ topology_on Y Ty)
               (total_function_on g B Y) Hg_left). }

(** Build the topology on A  B **)
claim HAB_sub: A :\/: B c= X.
{ apply binunion_Subq_min.
  - exact (topology_elem_subset X Tx A HTx HA).
  - exact (topology_elem_subset X Tx B HTx HB). }
claim HTsub: topology_on (A :\/: B) (subspace_topology X Tx (A :\/: B)).
{ exact (subspace_topology_is_topology X Tx (A :\/: B) HTx HAB_sub). }

(** Totality of the pasted map **)
claim Htotfg: total_function_on (f :\/: g) (A :\/: B) Y.
{ exact (total_function_union_on_disjoint_total_functional A B Y f g
           Hdisj Hdomf Hdomg Htotf Htotg Hfunf Hfung). }

(** Preimage openness for the pasted map **)
claim Hpreimg_fg: forall V:set, V :e Ty ->
  preimage_of (A :\/: B) (f :\/: g) V :e subspace_topology X Tx (A :\/: B).
{ let V. assume HV: V :e Ty.
  claim Heq: preimage_of (A :\/: B) (f :\/: g) V =
    (preimage_of A f V) :\/: (preimage_of B g V).
  { exact (preimage_of_union_functions_total A B Y f g V
           Hdisj Hdomf Hdomg Htotf Htotg Hfunf Hfung). }
  claim HfV: preimage_of A f V :e subspace_topology X Tx A.
  { exact (Hpreimg_f V HV). }
  claim HgV: preimage_of B g V :e subspace_topology X Tx B.
  { exact (Hpreimg_g V HV). }
  claim Hunion: (preimage_of A f V :\/: preimage_of B g V) :e subspace_topology X Tx (A :\/: B).
  { exact (subspace_union_of_opens X Tx A B (preimage_of A f V) (preimage_of B g V)
           HTx HA HB Hdisj HfV HgV). }
  prove preimage_of (A :\/: B) (f :\/: g) V :e subspace_topology X Tx (A :\/: B).
  rewrite Heq.
  exact Hunion. }

(** Assemble the proof **)
prove ((topology_on (A :\/: B) (subspace_topology X Tx (A :\/: B)) /\ topology_on Y Ty) /\
      total_function_on (f :\/: g) (A :\/: B) Y) /\
      (forall V:set, V :e Ty ->
        preimage_of (A :\/: B) (f :\/: g) V :e subspace_topology X Tx (A :\/: B)).
apply andI.
- apply andI.
  * apply andI.
    { exact HTsub. }
    { exact HTy. }
  * exact Htotfg.
- exact Hpreimg_fg.
Qed.

(** Helper: pasting lemma variant gives continuity in the weaker sense **)
Theorem pasting_lemma_total_functional_imp : forall X A B Y Tx Ty f g:set,
  topology_on X Tx ->
  A :e Tx -> B :e Tx -> A :/\: B = Empty ->
  graph_domain_subset f A ->
  graph_domain_subset g B ->
  functional_graph f ->
  functional_graph g ->
  continuous_map_total A (subspace_topology X Tx A) Y Ty f ->
  continuous_map_total B (subspace_topology X Tx B) Y Ty g ->
  continuous_map (A :\/: B) (subspace_topology X Tx (A :\/: B)) Y Ty (f :\/: g).
let X A B Y Tx Ty f g.
assume HTx: topology_on X Tx.
assume HA: A :e Tx.
assume HB: B :e Tx.
assume Hdisj: A :/\: B = Empty.
assume Hdomf: graph_domain_subset f A.
assume Hdomg: graph_domain_subset g B.
assume Hfunf: functional_graph f.
assume Hfung: functional_graph g.
assume Hf: continuous_map_total A (subspace_topology X Tx A) Y Ty f.
assume Hg: continuous_map_total B (subspace_topology X Tx B) Y Ty g.
prove continuous_map (A :\/: B) (subspace_topology X Tx (A :\/: B)) Y Ty (f :\/: g).
claim Htot: continuous_map_total (A :\/: B) (subspace_topology X Tx (A :\/: B)) Y Ty (f :\/: g).
{ exact (pasting_lemma_total_functional X A B Y Tx Ty f g
         HTx HA HB Hdisj Hdomf Hdomg Hfunf Hfung Hf Hg). }
exact (continuous_map_total_imp (A :\/: B) (subspace_topology X Tx (A :\/: B)) Y Ty (f :\/: g) Htot).
Qed.

(** from 18 Theorem 18.3: pasting lemma **)
(** LATEX VERSION: Let X=AB, where A and B are closed in X. Let f:AY and g:BY be continuous. If f=g on AB, then the combined map h:XY defined by h|A=f and h|B=g is continuous. **)
Theorem pasting_lemma : forall X A B Y Tx Ty f g:set,
  topology_on X Tx ->
  closed_in X Tx A ->
  closed_in X Tx B ->
  A :\/: B = X ->
  continuous_map A (subspace_topology X Tx A) Y Ty f ->
  continuous_map B (subspace_topology X Tx B) Y Ty g ->
  (forall x:set, x :e (A :/\: B) -> apply_fun f x = apply_fun g x) ->
  exists h:set,
    continuous_map X Tx Y Ty h /\
    ((forall x:set, x :e A -> apply_fun h x = apply_fun f x) /\
     (forall x:set, x :e B -> apply_fun h x = apply_fun g x)).
let X A B Y Tx Ty f g.
assume HTx: topology_on X Tx.
assume HclA: closed_in X Tx A.
assume HclB: closed_in X Tx B.
assume HABeq: A :\/: B = X.
assume Hf: continuous_map A (subspace_topology X Tx A) Y Ty f.
assume Hg: continuous_map B (subspace_topology X Tx B) Y Ty g.
assume Hagree: forall x:set, x :e (A :/\: B) -> apply_fun f x = apply_fun g x.

(** Define the pasted graph using a piecewise rule on membership in A **)
set h := graph X (fun x0:set => if x0 :e A then apply_fun f x0 else apply_fun g x0).
witness h.
prove continuous_map X Tx Y Ty h /\
  ((forall x:set, x :e A -> apply_fun h x = apply_fun f x) /\
   (forall x:set, x :e B -> apply_fun h x = apply_fun g x)).

apply andI.
- (** continuity of h **)
  claim HTy: topology_on Y Ty.
  { exact (continuous_map_topology_cod A (subspace_topology X Tx A) Y Ty f Hf). }

  claim Hfunf: function_on f A Y.
  { exact (continuous_map_function_on A (subspace_topology X Tx A) Y Ty f Hf). }
  claim Hfung: function_on g B Y.
  { exact (continuous_map_function_on B (subspace_topology X Tx B) Y Ty g Hg). }

  prove continuous_map X Tx Y Ty h.
  prove topology_on X Tx /\ topology_on Y Ty /\ function_on h X Y /\
        forall V:set, V :e Ty -> preimage_of X h V :e Tx.
  apply andI.
  + (** (topology_on X Tx /\ topology_on Y Ty) /\ function_on h X Y **)
    apply andI.
    * apply andI.
      { exact HTx. }
      { exact HTy. }
    * (** function_on h X Y **)
      let x. assume HxX: x :e X.
      prove apply_fun h x :e Y.
      claim Happ: apply_fun h x = if x :e A then apply_fun f x else apply_fun g x.
      { rewrite (apply_fun_graph X (fun x0:set => if x0 :e A then apply_fun f x0 else apply_fun g x0) x HxX).
        reflexivity. }
      rewrite Happ.
      apply (xm (x :e A)).
      + assume HxA: x :e A.
         rewrite (If_i_1 (x :e A) (apply_fun f x) (apply_fun g x) HxA).
         exact (Hfunf x HxA).
      + assume HxNotA: x /:e A.
         claim HxAB: x :e A :\/: B.
         { rewrite HABeq. exact HxX. }
         apply (binunionE A B x HxAB).
         + assume HxA: x :e A.
             apply FalseE.
             exact (HxNotA HxA).
         + assume HxB: x :e B.
             rewrite (If_i_0 (x :e A) (apply_fun f x) (apply_fun g x) HxNotA).
             exact (Hfung x HxB).

  + (** preimage condition **)
    let V. assume HV: V :e Ty.
    (** preimages in the subspace topologies **)
    claim HpreA: preimage_of A f V :e subspace_topology X Tx A.
    { exact (continuous_map_preimage A (subspace_topology X Tx A) Y Ty f Hf V HV). }
    claim HpreB: preimage_of B g V :e subspace_topology X Tx B.
    { exact (continuous_map_preimage B (subspace_topology X Tx B) Y Ty g Hg V HV). }

    (** choose open sets U0,W0 in X representing these subspace opens **)
    claim HexU0: exists U0 :e Tx, preimage_of A f V = U0 :/\: A.
    { exact (SepE2 (Power A) (fun U:set => exists U0 :e Tx, U = U0 :/\: A) (preimage_of A f V) HpreA). }
    apply HexU0.
    let U0. assume HU0pair.
    claim HU0: U0 :e Tx.
    { exact (andEL (U0 :e Tx) (preimage_of A f V = U0 :/\: A) HU0pair). }
    claim HpreAeq: preimage_of A f V = U0 :/\: A.
    { exact (andER (U0 :e Tx) (preimage_of A f V = U0 :/\: A) HU0pair). }

    claim HexW0: exists W0 :e Tx, preimage_of B g V = W0 :/\: B.
    { exact (SepE2 (Power B) (fun U:set => exists W0 :e Tx, U = W0 :/\: B) (preimage_of B g V) HpreB). }
    apply HexW0.
    let W0. assume HW0pair.
    claim HW0: W0 :e Tx.
    { exact (andEL (W0 :e Tx) (preimage_of B g V = W0 :/\: B) HW0pair). }
    claim HpreBeq: preimage_of B g V = W0 :/\: B.
    { exact (andER (W0 :e Tx) (preimage_of B g V = W0 :/\: B) HW0pair). }

    (** complements are open since A and B are closed **)
    claim HcompAin: open_in X Tx (X :\: A).
    { exact (open_of_closed_complement X Tx A HclA). }
    claim HcompA: (X :\: A) :e Tx.
    { exact (open_in_elem X Tx (X :\: A) HcompAin). }
    claim HcompBin: open_in X Tx (X :\: B).
    { exact (open_of_closed_complement X Tx B HclB). }
    claim HcompB: (X :\: B) :e Tx.
    { exact (open_in_elem X Tx (X :\: B) HcompBin). }

    (** define the open sets U = U0  (X\\A) and W = W0  (X\\B) **)
    set U := U0 :\/: (X :\: A).
    set W := W0 :\/: (X :\: B).
    claim HUopen: U :e Tx.
    { exact (topology_binunion_closed X Tx U0 (X :\: A) HTx HU0 HcompA). }
    claim HWopen: W :e Tx.
    { exact (topology_binunion_closed X Tx W0 (X :\: B) HTx HW0 HcompB). }

    (** main set equality: h^{-1}(V) = U  W **)
    claim Heq: preimage_of X h V = U :/\: W.
    { apply set_ext.
      - let x. assume Hx: x :e preimage_of X h V.
        prove x :e U :/\: W.
        claim HxX: x :e X.
        { exact (SepE1 X (fun x0:set => apply_fun h x0 :e V) x Hx). }
        claim HhxV: apply_fun h x :e V.
        { exact (SepE2 X (fun x0:set => apply_fun h x0 :e V) x Hx). }
        (** show x  U **)
        claim HxU: x :e U.
        { apply (xm (x :e A)).
          + assume HxA: x :e A.
             claim Happ: apply_fun h x = apply_fun f x.
             { rewrite (apply_fun_graph X (fun x0:set => if x0 :e A then apply_fun f x0 else apply_fun g x0) x HxX).
               rewrite (If_i_1 (x :e A) (apply_fun f x) (apply_fun g x) HxA).
               reflexivity. }
             claim HfxV: apply_fun f x :e V.
             { rewrite <- Happ. exact HhxV. }
             claim HxPreA: x :e preimage_of A f V.
             { exact (SepI A (fun x0:set => apply_fun f x0 :e V) x HxA HfxV). }
             claim HxU0A: x :e U0 :/\: A.
             { rewrite <- HpreAeq. exact HxPreA. }
             claim HxU0: x :e U0.
             { exact (binintersectE1 U0 A x HxU0A). }
             exact (binunionI1 U0 (X :\: A) x HxU0).
          + assume HxNotA: x /:e A.
             claim HxXA: x :e (X :\: A).
             { exact (setminusI X A x HxX HxNotA). }
             exact (binunionI2 U0 (X :\: A) x HxXA). }
        (** show x  W **)
        claim HxW: x :e W.
        { apply (xm (x :e B)).
          + assume HxB: x :e B.
             claim HgV: apply_fun g x :e V.
             { apply (xm (x :e A)).
               + assume HxA: x :e A.
                   claim HxAB: x :e A :/\: B.
                   { exact (binintersectI A B x HxA HxB). }
                   claim Heqfg: apply_fun f x = apply_fun g x.
                   { exact (Hagree x HxAB). }
                   claim Happ: apply_fun h x = apply_fun f x.
                   { rewrite (apply_fun_graph X (fun x0:set => if x0 :e A then apply_fun f x0 else apply_fun g x0) x HxX).
                     rewrite (If_i_1 (x :e A) (apply_fun f x) (apply_fun g x) HxA).
                     reflexivity. }
                   claim HfxV: apply_fun f x :e V.
                   { rewrite <- Happ. exact HhxV. }
                   rewrite <- Heqfg.
                   exact HfxV.
               + assume HxNotA: x /:e A.
                   claim Happ: apply_fun h x = apply_fun g x.
                   { rewrite (apply_fun_graph X (fun x0:set => if x0 :e A then apply_fun f x0 else apply_fun g x0) x HxX).
                     rewrite (If_i_0 (x :e A) (apply_fun f x) (apply_fun g x) HxNotA).
                     reflexivity. }
                   rewrite <- Happ.
                   exact HhxV. }
             claim HxPreB: x :e preimage_of B g V.
             { exact (SepI B (fun x0:set => apply_fun g x0 :e V) x HxB HgV). }
             claim HxW0B: x :e W0 :/\: B.
             { rewrite <- HpreBeq. exact HxPreB. }
             claim HxW0: x :e W0.
             { exact (binintersectE1 W0 B x HxW0B). }
             exact (binunionI1 W0 (X :\: B) x HxW0).
          + assume HxNotB: x /:e B.
             claim HxXB: x :e (X :\: B).
             { exact (setminusI X B x HxX HxNotB). }
             exact (binunionI2 W0 (X :\: B) x HxXB). }
        exact (binintersectI U W x HxU HxW).
      - let x. assume Hx: x :e U :/\: W.
        prove x :e preimage_of X h V.
        claim HxU: x :e U.
        { exact (binintersectE1 U W x Hx). }
        claim HxW: x :e W.
        { exact (binintersectE2 U W x Hx). }
        (** show x  X and apply_fun h x  V **)
        apply (xm (x :e A)).
        + assume HxA: x :e A.
           claim HxX: x :e X.
           { claim HA_sub: A c= X.
             { rewrite <- HABeq. exact (binunion_Subq_1 A B). }
             exact (HA_sub x HxA). }
           claim HxU0: x :e U0.
           { apply (binunionE U0 (X :\: A) x HxU).
             + assume HxU0: x :e U0.
                 exact HxU0.
             + assume HxXA: x :e (X :\: A).
                 claim HnotA: x /:e A.
                 { exact (setminusE2 X A x HxXA). }
                 apply FalseE.
                 exact (HnotA HxA). }
             claim HxPreA: x :e preimage_of A f V.
             { claim HxU0A: x :e U0 :/\: A.
               { exact (binintersectI U0 A x HxU0 HxA). }
             rewrite HpreAeq.
             exact HxU0A. }
           claim HfxV: apply_fun f x :e V.
           { exact (SepE2 A (fun x0:set => apply_fun f x0 :e V) x HxPreA). }
           claim Happ: apply_fun h x = apply_fun f x.
           { rewrite (apply_fun_graph X (fun x0:set => if x0 :e A then apply_fun f x0 else apply_fun g x0) x HxX).
             rewrite (If_i_1 (x :e A) (apply_fun f x) (apply_fun g x) HxA).
             reflexivity. }
           prove x :e preimage_of X h V.
           claim HhxV': apply_fun h x :e V.
           { rewrite Happ.
             exact HfxV. }
           exact (SepI X (fun x0:set => apply_fun h x0 :e V) x HxX HhxV').
        + assume HxNotA: x /:e A.
           (** x  X follows from x  U (second disjunct forces xX) **)
           claim HxX: x :e X.
           { apply (binunionE U0 (X :\: A) x HxU).
             + assume HxU0: x :e U0.
                 claim HU0sub: U0 c= X.
                 { exact (topology_elem_subset X Tx U0 HTx HU0). }
                 exact (HU0sub x HxU0).
             + assume HxXA: x :e (X :\: A).
                 exact (setminusE1 X A x HxXA). }
           (** from cover: x  B **)
           claim HxAB: x :e A :\/: B.
           { rewrite HABeq. exact HxX. }
           claim HxB: x :e B.
           { apply (binunionE A B x HxAB).
             + assume HxA: x :e A.
                 apply FalseE.
                 exact (HxNotA HxA).
             + assume HxB: x :e B.
                 exact HxB. }
           (** x  W forces x  W0 (since x  B) **)
           claim HxW0: x :e W0.
           { apply (binunionE W0 (X :\: B) x HxW).
             + assume HxW0: x :e W0.
                 exact HxW0.
             + assume HxXB: x :e (X :\: B).
                 claim HnotB: x /:e B.
                 { exact (setminusE2 X B x HxXB). }
                 apply FalseE.
                 exact (HnotB HxB). }
             claim HxPreB: x :e preimage_of B g V.
             { claim HxW0B: x :e W0 :/\: B.
               { exact (binintersectI W0 B x HxW0 HxB). }
             rewrite HpreBeq.
             exact HxW0B. }
           claim HgV: apply_fun g x :e V.
           { exact (SepE2 B (fun x0:set => apply_fun g x0 :e V) x HxPreB). }
           claim Happ: apply_fun h x = apply_fun g x.
           { rewrite (apply_fun_graph X (fun x0:set => if x0 :e A then apply_fun f x0 else apply_fun g x0) x HxX).
             rewrite (If_i_0 (x :e A) (apply_fun f x) (apply_fun g x) HxNotA).
             reflexivity. }
           prove x :e preimage_of X h V.
           claim HhxV': apply_fun h x :e V.
           { rewrite Happ.
             exact HgV. }
           exact (SepI X (fun x0:set => apply_fun h x0 :e V) x HxX HhxV'). }

    prove preimage_of X h V :e Tx.
    rewrite Heq.
    exact (topology_binintersect_closed X Tx U W HTx HUopen HWopen).

- (** h agrees with f on A and with g on B **)
  apply andI.
  + let x. assume HxA: x :e A.
    (** x  X from cover **)
    claim HxAB: x :e A :\/: B.
    { exact (binunionI1 A B x HxA). }
    claim HxX: x :e X.
    { rewrite <- HABeq. exact HxAB. }
    rewrite (apply_fun_graph X (fun x0:set => if x0 :e A then apply_fun f x0 else apply_fun g x0) x HxX).
    rewrite (If_i_1 (x :e A) (apply_fun f x) (apply_fun g x) HxA).
    reflexivity.
  + let x. assume HxB: x :e B.
    (** x  X from cover **)
    claim HxAB: x :e A :\/: B.
    { exact (binunionI2 A B x HxB). }
    claim HxX: x :e X.
    { rewrite <- HABeq. exact HxAB. }
    apply (xm (x :e A)).
    * assume HxA: x :e A.
      claim HxABi: x :e A :/\: B.
      { exact (binintersectI A B x HxA HxB). }
      claim Heqfg: apply_fun f x = apply_fun g x.
      { exact (Hagree x HxABi). }
      rewrite (apply_fun_graph X (fun x0:set => if x0 :e A then apply_fun f x0 else apply_fun g x0) x HxX).
      rewrite (If_i_1 (x :e A) (apply_fun f x) (apply_fun g x) HxA).
      rewrite Heqfg.
      reflexivity.
    * assume HxNotA: x /:e A.
      rewrite (apply_fun_graph X (fun x0:set => if x0 :e A then apply_fun f x0 else apply_fun g x0) x HxX).
      rewrite (If_i_0 (x :e A) (apply_fun f x) (apply_fun g x) HxNotA).
      reflexivity.
Qed.

(** from 18 Theorem 18.4: maps into products **) 
(** LATEX VERSION: A map into a product is continuous iff its coordinate functions are continuous. **)
Definition pair_map : set -> set -> set -> set := fun A f g =>
  {(a, (apply_fun f a, apply_fun g a)) | a :e A}.

(** Helper: apply_fun for pair_map **)
Theorem pair_map_apply : forall A X Y f g a:set,
  a :e A ->
  apply_fun (pair_map A f g) a = (apply_fun f a, apply_fun g a).
let A X Y f g a.
assume Ha: a :e A.
prove apply_fun (pair_map A f g) a = (apply_fun f a, apply_fun g a).
prove Eps_i (fun z => (a,z) :e pair_map A f g) = (apply_fun f a, apply_fun g a).
claim H1: (a, (apply_fun f a, apply_fun g a)) :e pair_map A f g.
{ exact (ReplI A (fun a0:set => (a0, (apply_fun f a0, apply_fun g a0))) a Ha). }
claim H2: (a, Eps_i (fun z => (a,z) :e pair_map A f g)) :e pair_map A f g.
{ exact (Eps_i_ax (fun z => (a,z) :e pair_map A f g) (apply_fun f a, apply_fun g a) H1). }
apply (ReplE_impred A (fun a0:set => (a0, (apply_fun f a0, apply_fun g a0)))
                     (a, Eps_i (fun z => (a,z) :e pair_map A f g)) H2).
let a0.
assume Ha0: a0 :e A.
assume Heq: (a, Eps_i (fun z => (a,z) :e pair_map A f g)) = (a0, (apply_fun f a0, apply_fun g a0)).
claim Ha_eq: a = a0.
{ rewrite <- (tuple_2_0_eq a (Eps_i (fun z => (a,z) :e pair_map A f g))).
  rewrite <- (tuple_2_0_eq a0 (apply_fun f a0, apply_fun g a0)).
  rewrite Heq.
  reflexivity. }
claim Hz_eq: Eps_i (fun z => (a,z) :e pair_map A f g) = (apply_fun f a0, apply_fun g a0).
{ rewrite <- (tuple_2_1_eq a (Eps_i (fun z => (a,z) :e pair_map A f g))) at 1.
  rewrite <- (tuple_2_1_eq a0 (apply_fun f a0, apply_fun g a0)) at 1.
  rewrite Heq.
  reflexivity. }
rewrite Hz_eq.
rewrite Ha_eq.
reflexivity.
Qed.

Theorem preimage_pair_map_rectangle : forall A X Y f g U V:set,
  preimage_of A (pair_map A f g) (rectangle_set U V) =
    (preimage_of A f U) :/\: (preimage_of A g V).
let A X Y f g U V.
apply set_ext.
- let a. assume Ha: a :e preimage_of A (pair_map A f g) (rectangle_set U V).
  prove a :e (preimage_of A f U) :/\: (preimage_of A g V).
  claim HaA: a :e A.
  { exact (SepE1 A (fun a0:set => apply_fun (pair_map A f g) a0 :e rectangle_set U V) a Ha). }
  claim Himg: apply_fun (pair_map A f g) a :e rectangle_set U V.
  { exact (SepE2 A (fun a0:set => apply_fun (pair_map A f g) a0 :e rectangle_set U V) a Ha). }
  claim Happ: apply_fun (pair_map A f g) a = (apply_fun f a, apply_fun g a).
  { exact (pair_map_apply A X Y f g a HaA). }
  claim HpairIn: (apply_fun f a, apply_fun g a) :e rectangle_set U V.
  { rewrite <- Happ.
    exact Himg. }
  claim Hfst: (apply_fun f a, apply_fun g a) 0 :e U.
  { exact (ap0_Sigma U (fun _ : set => V) (apply_fun f a, apply_fun g a) HpairIn). }
  claim Hsnd: (apply_fun f a, apply_fun g a) 1 :e V.
  { exact (ap1_Sigma U (fun _ : set => V) (apply_fun f a, apply_fun g a) HpairIn). }
  claim HfaU: apply_fun f a :e U.
  { rewrite <- (tuple_2_0_eq (apply_fun f a) (apply_fun g a)).
    exact Hfst. }
  claim HgaV: apply_fun g a :e V.
  { rewrite <- (tuple_2_1_eq (apply_fun f a) (apply_fun g a)).
    exact Hsnd. }
  apply binintersectI.
  + exact (SepI A (fun a0:set => apply_fun f a0 :e U) a HaA HfaU).
  + exact (SepI A (fun a0:set => apply_fun g a0 :e V) a HaA HgaV).
- let a. assume Ha: a :e (preimage_of A f U) :/\: (preimage_of A g V).
  prove a :e preimage_of A (pair_map A f g) (rectangle_set U V).
  claim Haf: a :e preimage_of A f U.
  { exact (binintersectE1 (preimage_of A f U) (preimage_of A g V) a Ha). }
  claim Hag: a :e preimage_of A g V.
  { exact (binintersectE2 (preimage_of A f U) (preimage_of A g V) a Ha). }
  claim HaA: a :e A.
  { exact (SepE1 A (fun a0:set => apply_fun f a0 :e U) a Haf). }
  claim HfaU: apply_fun f a :e U.
  { exact (SepE2 A (fun a0:set => apply_fun f a0 :e U) a Haf). }
  claim HgaV: apply_fun g a :e V.
  { exact (SepE2 A (fun a0:set => apply_fun g a0 :e V) a Hag). }
  claim HpairIn: (apply_fun f a, apply_fun g a) :e rectangle_set U V.
  { exact (tuple_2_rectangle_set U V (apply_fun f a) (apply_fun g a) HfaU HgaV). }
  claim Happ: apply_fun (pair_map A f g) a = (apply_fun f a, apply_fun g a).
  { exact (pair_map_apply A X Y f g a HaA). }
  claim Himg: apply_fun (pair_map A f g) a :e rectangle_set U V.
  { rewrite Happ.
    exact HpairIn. }
  exact (SepI A (fun a0:set => apply_fun (pair_map A f g) a0 :e rectangle_set U V) a HaA Himg).
Qed.

Theorem maps_into_products_axiom : forall A Ta X Tx Y Ty f g:set,
  continuous_map A Ta X Tx f ->
  continuous_map A Ta Y Ty g ->
  continuous_map A Ta (setprod X Y) (product_topology X Tx Y Ty) (pair_map A f g).
let A Ta X Tx Y Ty f g.
assume Hf: continuous_map A Ta X Tx f.
assume Hg: continuous_map A Ta Y Ty g.
claim Hf_mid: (topology_on A Ta /\ topology_on X Tx) /\ function_on f A X.
{ exact (andEL ((topology_on A Ta /\ topology_on X Tx) /\ function_on f A X)
               (forall V:set, V :e Tx -> preimage_of A f V :e Ta)
               Hf). }
claim Hfun_f: function_on f A X.
{ exact (andER (topology_on A Ta /\ topology_on X Tx) (function_on f A X) Hf_mid). }
claim HtopAX: topology_on A Ta /\ topology_on X Tx.
{ exact (andEL (topology_on A Ta /\ topology_on X Tx) (function_on f A X) Hf_mid). }
claim HTa: topology_on A Ta.
{ exact (andEL (topology_on A Ta) (topology_on X Tx) HtopAX). }
claim HTx: topology_on X Tx.
{ exact (andER (topology_on A Ta) (topology_on X Tx) HtopAX). }
claim Hf_pre: forall U:set, U :e Tx -> preimage_of A f U :e Ta.
{ exact (andER ((topology_on A Ta /\ topology_on X Tx) /\ function_on f A X)
               (forall V:set, V :e Tx -> preimage_of A f V :e Ta)
               Hf). }

claim Hg_mid: (topology_on A Ta /\ topology_on Y Ty) /\ function_on g A Y.
{ exact (andEL ((topology_on A Ta /\ topology_on Y Ty) /\ function_on g A Y)
               (forall V:set, V :e Ty -> preimage_of A g V :e Ta)
               Hg). }
claim Hfun_g: function_on g A Y.
{ exact (andER (topology_on A Ta /\ topology_on Y Ty) (function_on g A Y) Hg_mid). }
claim HtopAY: topology_on A Ta /\ topology_on Y Ty.
{ exact (andEL (topology_on A Ta /\ topology_on Y Ty) (function_on g A Y) Hg_mid). }
claim HTy: topology_on Y Ty.
{ exact (andER (topology_on A Ta) (topology_on Y Ty) HtopAY). }
claim Hg_pre: forall V:set, V :e Ty -> preimage_of A g V :e Ta.
{ exact (andER ((topology_on A Ta /\ topology_on Y Ty) /\ function_on g A Y)
               (forall V:set, V :e Ty -> preimage_of A g V :e Ta)
               Hg). }

claim HTprod: topology_on (setprod X Y) (product_topology X Tx Y Ty).
{ exact (product_topology_is_topology X Tx Y Ty HTx HTy). }
claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
{ exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }

prove continuous_map A Ta (setprod X Y) (product_topology X Tx Y Ty) (pair_map A f g).
prove topology_on A Ta /\ topology_on (setprod X Y) (product_topology X Tx Y Ty) /\
  function_on (pair_map A f g) A (setprod X Y) /\
  forall W:set, W :e product_topology X Tx Y Ty -> preimage_of A (pair_map A f g) W :e Ta.
apply andI.
- apply andI.
  + apply andI.
    * exact HTa.
    * exact HTprod.
  + (** function_on **)
    let a. assume HaA: a :e A.
    prove apply_fun (pair_map A f g) a :e setprod X Y.
	    claim Happ: apply_fun (pair_map A f g) a = (apply_fun f a, apply_fun g a).
	    { exact (pair_map_apply A X Y f g a HaA). }
	    rewrite Happ.
	    exact (tuple_2_setprod_by_pair_Sigma X Y (apply_fun f a) (apply_fun g a) (Hfun_f a HaA) (Hfun_g a HaA)).
- let W. assume HW: W :e product_topology X Tx Y Ty.
  prove preimage_of A (pair_map A f g) W :e Ta.
  claim HWopen: open_in (setprod X Y) (product_topology X Tx Y Ty) W.
  { exact (andI (topology_on (setprod X Y) (product_topology X Tx Y Ty)) (W :e product_topology X Tx Y Ty) HTprod HW). }
  apply (open_sets_as_unions_of_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis W HWopen).
  let Fam. assume HFamPair.
  claim HFamPow: Fam :e Power (product_subbasis X Tx Y Ty).
  { exact (andEL (Fam :e Power (product_subbasis X Tx Y Ty)) (Union Fam = W) HFamPair). }
  claim HUnionEq: Union Fam = W.
  { exact (andER (Fam :e Power (product_subbasis X Tx Y Ty)) (Union Fam = W) HFamPair). }
  claim HFamSub: Fam c= product_subbasis X Tx Y Ty.
  { exact (PowerE (product_subbasis X Tx Y Ty) Fam HFamPow). }
  set PreFam := {preimage_of A (pair_map A f g) b|b :e Fam}.
  claim HpreEq1: preimage_of A (pair_map A f g) W = preimage_of A (pair_map A f g) (Union Fam).
  { rewrite <- HUnionEq.
    reflexivity. }
  claim HpreEq2: preimage_of A (pair_map A f g) (Union Fam) = Union PreFam.
  { rewrite (preimage_of_Union A (pair_map A f g) Fam).
    reflexivity. }
  rewrite HpreEq1.
  rewrite HpreEq2.
  claim HPreFamSub: PreFam c= Ta.
  { let P. assume HP: P :e PreFam.
    apply (ReplE_impred Fam (fun b:set => preimage_of A (pair_map A f g) b) P HP).
    let b. assume HbFam: b :e Fam.
    assume HPeq: P = preimage_of A (pair_map A f g) b.
    claim HbSub: b :e product_subbasis X Tx Y Ty.
    { exact (HFamSub b HbFam). }
    claim HexU: exists U :e Tx, b :e {rectangle_set U V|V :e Ty}.
    { exact (famunionE Tx (fun U0:set => {rectangle_set U0 V|V :e Ty}) b HbSub). }
    apply HexU.
    let U. assume HUconj: U :e Tx /\ b :e {rectangle_set U V|V :e Ty}.
    claim HU: U :e Tx.
    { exact (andEL (U :e Tx) (b :e {rectangle_set U V|V :e Ty}) HUconj). }
    claim HbRepl: b :e {rectangle_set U V|V :e Ty}.
    { exact (andER (U :e Tx) (b :e {rectangle_set U V|V :e Ty}) HUconj). }
    claim HexV: exists V :e Ty, b = rectangle_set U V.
    { exact (ReplE Ty (fun V0:set => rectangle_set U V0) b HbRepl). }
    apply HexV.
    let V. assume HVconj: V :e Ty /\ b = rectangle_set U V.
    claim HV: V :e Ty.
    { exact (andEL (V :e Ty) (b = rectangle_set U V) HVconj). }
    claim Hbeq: b = rectangle_set U V.
    { exact (andER (V :e Ty) (b = rectangle_set U V) HVconj). }
    claim HpreRect: preimage_of A (pair_map A f g) b =
      (preimage_of A f U) :/\: (preimage_of A g V).
    { rewrite Hbeq.
      exact (preimage_pair_map_rectangle A X Y f g U V). }
    rewrite HPeq.
    rewrite HpreRect.
    exact (topology_binintersect_closed A Ta (preimage_of A f U) (preimage_of A g V) HTa (Hf_pre U HU) (Hg_pre V HV)). }
  claim HPreFamPow: PreFam :e Power Ta.
  { apply PowerI.
    exact HPreFamSub. }
  exact (topology_union_axiom A Ta HTa PreFam HPreFamPow).
Qed.

Theorem maps_into_products : forall A Ta X Tx Y Ty f g:set,
  continuous_map A Ta X Tx f ->
  continuous_map A Ta Y Ty g ->
  continuous_map A Ta (setprod X Y) (product_topology X Tx Y Ty) (pair_map A f g).
let A Ta X Tx Y Ty f g.
assume Hf: continuous_map A Ta X Tx f.
assume Hg: continuous_map A Ta Y Ty g.
prove continuous_map A Ta (setprod X Y) (product_topology X Tx Y Ty) (pair_map A f g).
exact (maps_into_products_axiom A Ta X Tx Y Ty f g Hf Hg).
Qed.

(** from 19 Definition: product projections and universal property **) 
(** LATEX VERSION: Projection maps from a product space; universal property characterizes the product topology. **)
Definition projection_map1 : set -> set -> set := fun X Y => projection1 X Y.
Definition projection_map2 : set -> set -> set := fun X Y => projection2 X Y.

(** Helper: preimage of a rectangle via projection compositions **)
Theorem preimage_of_rectangle_via_projections : forall A X Y h U V:set,
  function_on h A (setprod X Y) ->
  U c= X -> V c= Y ->
  preimage_of A h (rectangle_set U V) =
    (preimage_of A (compose_fun A h (projection_map1 X Y)) U) :/\:
    (preimage_of A (compose_fun A h (projection_map2 X Y)) V).
let A X Y h U V.
assume Hh: function_on h A (setprod X Y).
assume HU: U c= X.
assume HV: V c= Y.
apply set_ext.
- let a. assume Ha: a :e preimage_of A h (rectangle_set U V).
  prove a :e (preimage_of A (compose_fun A h (projection_map1 X Y)) U) :/\:
            (preimage_of A (compose_fun A h (projection_map2 X Y)) V).
  claim HaA: a :e A.
  { exact (SepE1 A (fun a0:set => apply_fun h a0 :e rectangle_set U V) a Ha). }
  claim Himg: apply_fun h a :e rectangle_set U V.
  { exact (SepE2 A (fun a0:set => apply_fun h a0 :e rectangle_set U V) a Ha). }
  claim HpXY: apply_fun h a :e setprod X Y.
  { exact (Hh a HaA). }
  claim Hp0U: (apply_fun h a) 0 :e U.
  { exact (ap0_Sigma U (fun _ : set => V) (apply_fun h a) Himg). }
  claim Hp1V: (apply_fun h a) 1 :e V.
  { exact (ap1_Sigma U (fun _ : set => V) (apply_fun h a) Himg). }
  claim Happ1: apply_fun (projection_map1 X Y) (apply_fun h a) = (apply_fun h a) 0.
  { exact (projection1_apply X Y (apply_fun h a) HpXY). }
  claim Happ2: apply_fun (projection_map2 X Y) (apply_fun h a) = (apply_fun h a) 1.
  { exact (projection2_apply X Y (apply_fun h a) HpXY). }
  claim Hc1: apply_fun (compose_fun A h (projection_map1 X Y)) a :e U.
  { claim Hcomp: apply_fun (compose_fun A h (projection_map1 X Y)) a =
      apply_fun (projection_map1 X Y) (apply_fun h a).
    { exact (compose_fun_apply A h (projection_map1 X Y) a HaA). }
    rewrite Hcomp.
    rewrite Happ1.
    exact Hp0U. }
  claim Hc2: apply_fun (compose_fun A h (projection_map2 X Y)) a :e V.
  { claim Hcomp: apply_fun (compose_fun A h (projection_map2 X Y)) a =
      apply_fun (projection_map2 X Y) (apply_fun h a).
    { exact (compose_fun_apply A h (projection_map2 X Y) a HaA). }
    rewrite Hcomp.
    rewrite Happ2.
    exact Hp1V. }
  apply binintersectI.
  * exact (SepI A (fun a0:set => apply_fun (compose_fun A h (projection_map1 X Y)) a0 :e U) a HaA Hc1).
  * exact (SepI A (fun a0:set => apply_fun (compose_fun A h (projection_map2 X Y)) a0 :e V) a HaA Hc2).
- let a. assume Ha: a :e (preimage_of A (compose_fun A h (projection_map1 X Y)) U) :/\:
                     (preimage_of A (compose_fun A h (projection_map2 X Y)) V).
  prove a :e preimage_of A h (rectangle_set U V).
  claim Ha1: a :e preimage_of A (compose_fun A h (projection_map1 X Y)) U.
  { exact (binintersectE1 (preimage_of A (compose_fun A h (projection_map1 X Y)) U)
                          (preimage_of A (compose_fun A h (projection_map2 X Y)) V) a Ha). }
  claim Ha2: a :e preimage_of A (compose_fun A h (projection_map2 X Y)) V.
  { exact (binintersectE2 (preimage_of A (compose_fun A h (projection_map1 X Y)) U)
                          (preimage_of A (compose_fun A h (projection_map2 X Y)) V) a Ha). }
  claim HaA: a :e A.
  { exact (SepE1 A (fun a0:set => apply_fun (compose_fun A h (projection_map1 X Y)) a0 :e U) a Ha1). }
  claim HpXY: apply_fun h a :e setprod X Y.
  { exact (Hh a HaA). }
  claim Hc1: apply_fun (compose_fun A h (projection_map1 X Y)) a :e U.
  { exact (SepE2 A (fun a0:set => apply_fun (compose_fun A h (projection_map1 X Y)) a0 :e U) a Ha1). }
  claim Hc2: apply_fun (compose_fun A h (projection_map2 X Y)) a :e V.
  { exact (SepE2 A (fun a0:set => apply_fun (compose_fun A h (projection_map2 X Y)) a0 :e V) a Ha2). }
  claim Hcomp1: apply_fun (compose_fun A h (projection_map1 X Y)) a =
      apply_fun (projection_map1 X Y) (apply_fun h a).
  { exact (compose_fun_apply A h (projection_map1 X Y) a HaA). }
  claim Hcomp2: apply_fun (compose_fun A h (projection_map2 X Y)) a =
      apply_fun (projection_map2 X Y) (apply_fun h a).
  { exact (compose_fun_apply A h (projection_map2 X Y) a HaA). }
  claim Happ1: apply_fun (projection_map1 X Y) (apply_fun h a) = (apply_fun h a) 0.
  { exact (projection1_apply X Y (apply_fun h a) HpXY). }
  claim Happ2: apply_fun (projection_map2 X Y) (apply_fun h a) = (apply_fun h a) 1.
  { exact (projection2_apply X Y (apply_fun h a) HpXY). }
  claim Hp0U: (apply_fun h a) 0 :e U.
  { rewrite <- Happ1.
    rewrite <- Hcomp1.
    exact Hc1. }
  claim Hp1V: (apply_fun h a) 1 :e V.
  { rewrite <- Happ2.
    rewrite <- Hcomp2.
    exact Hc2. }
  claim Heta: apply_fun h a = ((apply_fun h a) 0, (apply_fun h a) 1).
  { exact (setprod_eta X Y (apply_fun h a) HpXY). }
	  claim HpUV: apply_fun h a :e setprod U V.
	  { rewrite Heta.
	    exact (tuple_2_setprod_by_pair_Sigma U V ((apply_fun h a) 0) ((apply_fun h a) 1) Hp0U Hp1V). }
  prove a :e preimage_of A h (rectangle_set U V).
  exact (SepI A (fun a0:set => apply_fun h a0 :e rectangle_set U V) a HaA HpUV).
Qed.

(** Helper: projection maps are continuous **)
Theorem projection_maps_continuous : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y) /\
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y).
let X Tx Y Ty.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y) /\
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y).
apply andI.
- (** projection_map1 **)
  prove continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y).
  prove topology_on (setprod X Y) (product_topology X Tx Y Ty) /\ topology_on X Tx /\
    function_on (projection_map1 X Y) (setprod X Y) X /\
    forall V:set, V :e Tx -> preimage_of (setprod X Y) (projection_map1 X Y) V :e product_topology X Tx Y Ty.
  apply andI.
  - apply andI.
    + apply andI.
      * exact (product_topology_is_topology X Tx Y Ty HTx HTy).
      * exact HTx.
    + (** function_on **)
      let p. assume Hp: p :e setprod X Y.
      prove apply_fun (projection_map1 X Y) p :e X.
      claim Happ: apply_fun (projection_map1 X Y) p = p 0.
      { exact (projection1_apply X Y p Hp). }
      rewrite Happ.
      exact (ap0_Sigma X (fun _ : set => Y) p Hp).
  - let V. assume HV: V :e Tx.
    prove preimage_of (setprod X Y) (projection_map1 X Y) V :e product_topology X Tx Y Ty.
    claim HVsub: V c= X.
    { exact (topology_elem_subset X Tx V HTx HV). }
    claim HpreEq: preimage_of (setprod X Y) (projection_map1 X Y) V = rectangle_set V Y.
    { exact (preimage_projection1_rectangle X Y V HVsub). }
    rewrite HpreEq.
    claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
    { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
    claim HYTy: Y :e Ty.
    { exact (topology_has_X Y Ty HTy). }
    claim HRsub: rectangle_set V Y :e product_subbasis X Tx Y Ty.
    { claim HRfam: rectangle_set V Y :e {rectangle_set V V0|V0 :e Ty}.
      { exact (ReplI Ty (fun V0:set => rectangle_set V V0) Y HYTy). }
      exact (famunionI Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) V (rectangle_set V Y) HV HRfam). }
    exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis (rectangle_set V Y) HRsub).
- (** projection_map2 **)
  prove continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y).
  prove topology_on (setprod X Y) (product_topology X Tx Y Ty) /\ topology_on Y Ty /\
    function_on (projection_map2 X Y) (setprod X Y) Y /\
    forall V:set, V :e Ty -> preimage_of (setprod X Y) (projection_map2 X Y) V :e product_topology X Tx Y Ty.
  apply andI.
  - apply andI.
    + apply andI.
      * exact (product_topology_is_topology X Tx Y Ty HTx HTy).
      * exact HTy.
    + (** function_on **)
      let p. assume Hp: p :e setprod X Y.
      prove apply_fun (projection_map2 X Y) p :e Y.
      claim Happ: apply_fun (projection_map2 X Y) p = p 1.
      { exact (projection2_apply X Y p Hp). }
      rewrite Happ.
      exact (ap1_Sigma X (fun _ : set => Y) p Hp).
  - let V. assume HV: V :e Ty.
    prove preimage_of (setprod X Y) (projection_map2 X Y) V :e product_topology X Tx Y Ty.
    claim HVsub: V c= Y.
    { exact (topology_elem_subset Y Ty V HTy HV). }
    claim HpreEq: preimage_of (setprod X Y) (projection_map2 X Y) V = rectangle_set X V.
    { exact (preimage_projection2_rectangle X Y V HVsub). }
    rewrite HpreEq.
    claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
    { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
    claim HXTx: X :e Tx.
    { exact (topology_has_X X Tx HTx). }
    claim HRsub: rectangle_set X V :e product_subbasis X Tx Y Ty.
    { claim HRfam: rectangle_set X V :e {rectangle_set X V0|V0 :e Ty}.
      { exact (ReplI Ty (fun V0:set => rectangle_set X V0) V HV). }
      exact (famunionI Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) X (rectangle_set X V) HXTx HRfam). }
    exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis (rectangle_set X V) HRsub).
Qed.

(** Helper: maps into products, converse direction using projections **)
(** LATEX VERSION: If h : A -> XY is continuous, then each coordinate projection composed with h is continuous. **)
Theorem maps_into_products_converse : forall A Ta X Tx Y Ty h:set,
  topology_on X Tx -> topology_on Y Ty ->
  continuous_map A Ta (setprod X Y) (product_topology X Tx Y Ty) h ->
  continuous_map A Ta X Tx (compose_fun A h (projection_map1 X Y)) /\
  continuous_map A Ta Y Ty (compose_fun A h (projection_map2 X Y)).
let A Ta X Tx Y Ty h.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
assume Hh: continuous_map A Ta (setprod X Y) (product_topology X Tx Y Ty) h.
prove continuous_map A Ta X Tx (compose_fun A h (projection_map1 X Y)) /\
  continuous_map A Ta Y Ty (compose_fun A h (projection_map2 X Y)).
claim Hproj: continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y) /\
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y).
{ exact (projection_maps_continuous X Tx Y Ty HTx HTy). }
apply andI.
- claim Hpr1: continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y).
  { exact (andEL (continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y))
                 (continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y))
                 Hproj). }
  exact (composition_continuous A Ta (setprod X Y) (product_topology X Tx Y Ty) X Tx h (projection_map1 X Y)
         Hh Hpr1).
- claim Hpr2: continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y).
  { exact (andER (continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y))
                 (continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y))
                 Hproj). }
  exact (composition_continuous A Ta (setprod X Y) (product_topology X Tx Y Ty) Y Ty h (projection_map2 X Y)
         Hh Hpr2).
Qed.

(** Helper: maps into products from continuity of coordinates **)
(** LATEX VERSION: If h maps A into XY and the coordinate compositions are continuous, then h is continuous. **)
Theorem maps_into_products_coords_imp : forall A Ta X Tx Y Ty h:set,
  topology_on X Tx -> topology_on Y Ty ->
  function_on h A (setprod X Y) ->
  continuous_map A Ta X Tx (compose_fun A h (projection_map1 X Y)) ->
  continuous_map A Ta Y Ty (compose_fun A h (projection_map2 X Y)) ->
  continuous_map A Ta (setprod X Y) (product_topology X Tx Y Ty) h.
let A Ta X Tx Y Ty h.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
assume Hfunh: function_on h A (setprod X Y).
assume Hc1: continuous_map A Ta X Tx (compose_fun A h (projection_map1 X Y)).
assume Hc2: continuous_map A Ta Y Ty (compose_fun A h (projection_map2 X Y)).
prove continuous_map A Ta (setprod X Y) (product_topology X Tx Y Ty) h.

set h1 := compose_fun A h (projection_map1 X Y).
set h2 := compose_fun A h (projection_map2 X Y).

(** Extract topology on A and preimage properties from Hc1 and Hc2 **)
claim Hc1_left: (topology_on A Ta /\ topology_on X Tx) /\ function_on h1 A X.
{ exact (andEL ((topology_on A Ta /\ topology_on X Tx) /\ function_on h1 A X)
               (forall U:set, U :e Tx -> preimage_of A h1 U :e Ta) Hc1). }
claim HTaX: topology_on A Ta /\ topology_on X Tx.
{ exact (andEL (topology_on A Ta /\ topology_on X Tx) (function_on h1 A X) Hc1_left). }
claim HTa: topology_on A Ta.
{ exact (andEL (topology_on A Ta) (topology_on X Tx) HTaX). }
claim Hpre1: forall U:set, U :e Tx -> preimage_of A h1 U :e Ta.
{ exact (andER ((topology_on A Ta /\ topology_on X Tx) /\ function_on h1 A X)
               (forall U:set, U :e Tx -> preimage_of A h1 U :e Ta) Hc1). }

claim Hc2_left: (topology_on A Ta /\ topology_on Y Ty) /\ function_on h2 A Y.
{ exact (andEL ((topology_on A Ta /\ topology_on Y Ty) /\ function_on h2 A Y)
               (forall V:set, V :e Ty -> preimage_of A h2 V :e Ta) Hc2). }
claim Hpre2: forall V:set, V :e Ty -> preimage_of A h2 V :e Ta.
{ exact (andER ((topology_on A Ta /\ topology_on Y Ty) /\ function_on h2 A Y)
               (forall V:set, V :e Ty -> preimage_of A h2 V :e Ta) Hc2). }

(** Topology on the product **)
claim HTprod: topology_on (setprod X Y) (product_topology X Tx Y Ty).
{ exact (product_topology_is_topology X Tx Y Ty HTx HTy). }

prove ((topology_on A Ta /\ topology_on (setprod X Y) (product_topology X Tx Y Ty)) /\ function_on h A (setprod X Y)) /\
  (forall W:set, W :e product_topology X Tx Y Ty -> preimage_of A h W :e Ta).
apply andI.
- apply andI.
  * apply andI.
    { exact HTa. }
    { exact HTprod. }
  * exact Hfunh.
- let W. assume HW: W :e product_topology X Tx Y Ty.
  prove preimage_of A h W :e Ta.
  claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
  { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
  claim HWopen: open_in (setprod X Y) (product_topology X Tx Y Ty) W.
  { exact (andI (topology_on (setprod X Y) (product_topology X Tx Y Ty))
                (W :e product_topology X Tx Y Ty) HTprod HW). }
  apply (open_sets_as_unions_of_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis W HWopen).
  let Fam. assume HFamPair.
  claim HFamPow: Fam :e Power (product_subbasis X Tx Y Ty).
  { exact (andEL (Fam :e Power (product_subbasis X Tx Y Ty)) (Union Fam = W) HFamPair). }
  claim HUnionEq: Union Fam = W.
  { exact (andER (Fam :e Power (product_subbasis X Tx Y Ty)) (Union Fam = W) HFamPair). }
  claim HFamSub: Fam c= product_subbasis X Tx Y Ty.
  { exact (PowerE (product_subbasis X Tx Y Ty) Fam HFamPow). }
  set PreFam := {preimage_of A h b|b :e Fam}.
  claim HpreEq1: preimage_of A h W = preimage_of A h (Union Fam).
  { rewrite <- HUnionEq.
    reflexivity. }
  claim HpreEq2: preimage_of A h (Union Fam) = Union PreFam.
  { rewrite (preimage_of_Union A h Fam).
    reflexivity. }
  claim HPreFamSub: PreFam c= Ta.
  { let P. assume HP: P :e PreFam.
    apply (ReplE_impred Fam (fun b:set => preimage_of A h b) P HP (P :e Ta)).
    let b. assume HbFam: b :e Fam.
    assume HPeq: P = preimage_of A h b.
    claim HbB: b :e product_subbasis X Tx Y Ty.
    { exact (HFamSub b HbFam). }
    apply (famunionE Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) b HbB).
    let U. assume HUconj: U :e Tx /\ b :e {rectangle_set U V0|V0 :e Ty}.
    claim HUinTx: U :e Tx.
    { exact (andEL (U :e Tx) (b :e {rectangle_set U V0|V0 :e Ty}) HUconj). }
    claim HbRepl: b :e {rectangle_set U V0|V0 :e Ty}.
    { exact (andER (U :e Tx) (b :e {rectangle_set U V0|V0 :e Ty}) HUconj). }
    claim HexV: exists V :e Ty, b = rectangle_set U V.
    { exact (ReplE Ty (fun V0:set => rectangle_set U V0) b HbRepl). }
    apply HexV.
    let V. assume HVconj: V :e Ty /\ b = rectangle_set U V.
    claim HVinTy: V :e Ty.
    { exact (andEL (V :e Ty) (b = rectangle_set U V) HVconj). }
    claim Hbeq: b = rectangle_set U V.
    { exact (andER (V :e Ty) (b = rectangle_set U V) HVconj). }
    claim HUsubX: U c= X.
    { exact (topology_elem_subset X Tx U HTx HUinTx). }
    claim HVsubY: V c= Y.
    { exact (topology_elem_subset Y Ty V HTy HVinTy). }
    claim HpreRect: preimage_of A h (rectangle_set U V) =
      (preimage_of A h1 U) :/\: (preimage_of A h2 V).
    { exact (preimage_of_rectangle_via_projections A X Y h U V Hfunh HUsubX HVsubY). }
    claim HpreU: preimage_of A h1 U :e Ta.
    { exact (Hpre1 U HUinTx). }
    claim HpreV: preimage_of A h2 V :e Ta.
    { exact (Hpre2 V HVinTy). }
    claim Hcap: (preimage_of A h1 U) :/\: (preimage_of A h2 V) :e Ta.
    { exact (topology_binintersect_closed A Ta (preimage_of A h1 U) (preimage_of A h2 V) HTa HpreU HpreV). }
    claim HpreB: preimage_of A h b :e Ta.
    { rewrite Hbeq.
      rewrite HpreRect.
      exact Hcap. }
    rewrite HPeq.
    exact HpreB. }
  claim HPreFamPow: PreFam :e Power Ta.
  { apply PowerI.
    exact HPreFamSub. }
  claim HUnionPre: Union PreFam :e Ta.
  { exact (topology_union_axiom A Ta HTa PreFam HPreFamPow). }
  rewrite HpreEq1.
  rewrite HpreEq2.
  exact HUnionPre.
Qed.

(** Helper: maps into products iff coordinates are continuous **)
(** LATEX VERSION: A map h : A -> XY is continuous iff each projection composed with h is continuous. **)
Theorem maps_into_products_iff_coords : forall A Ta X Tx Y Ty h:set,
  topology_on X Tx -> topology_on Y Ty ->
  function_on h A (setprod X Y) ->
  (continuous_map A Ta (setprod X Y) (product_topology X Tx Y Ty) h <->
   (continuous_map A Ta X Tx (compose_fun A h (projection_map1 X Y)) /\
    continuous_map A Ta Y Ty (compose_fun A h (projection_map2 X Y)))).
let A Ta X Tx Y Ty h.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
assume Hfunh: function_on h A (setprod X Y).
apply iffI.
- assume Hh: continuous_map A Ta (setprod X Y) (product_topology X Tx Y Ty) h.
  exact (maps_into_products_converse A Ta X Tx Y Ty h HTx HTy Hh).
- assume Hcoords: continuous_map A Ta X Tx (compose_fun A h (projection_map1 X Y)) /\
                  continuous_map A Ta Y Ty (compose_fun A h (projection_map2 X Y)).
  claim Hc1: continuous_map A Ta X Tx (compose_fun A h (projection_map1 X Y)).
  { exact (andEL (continuous_map A Ta X Tx (compose_fun A h (projection_map1 X Y)))
                 (continuous_map A Ta Y Ty (compose_fun A h (projection_map2 X Y)))
                 Hcoords). }
  claim Hc2: continuous_map A Ta Y Ty (compose_fun A h (projection_map2 X Y)).
  { exact (andER (continuous_map A Ta X Tx (compose_fun A h (projection_map1 X Y)))
                 (continuous_map A Ta Y Ty (compose_fun A h (projection_map2 X Y)))
                 Hcoords). }
  exact (maps_into_products_coords_imp A Ta X Tx Y Ty h HTx HTy Hfunh Hc1 Hc2).
Qed.

(** Helper: universal property of products - maps into products **)
(** LATEX VERSION: Projections from a product are continuous. **)
Theorem projections_are_continuous : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y) /\
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y).
let X Tx Y Ty.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y) /\
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y).
exact (projection_maps_continuous X Tx Y Ty HTx HTy).
Qed.

(** from 19: product topology is coarsest making projections continuous **) 
(** LATEX VERSION: The product topology is the coarsest topology on XY making the projections continuous. **)
Theorem product_topology_universal : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  exists Tprod:set, topology_on (setprod X Y) Tprod /\
    continuous_map (setprod X Y) Tprod X Tx (projection_map1 X Y) /\
    continuous_map (setprod X Y) Tprod Y Ty (projection_map2 X Y).
let X Tx Y Ty.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove exists Tprod:set, topology_on (setprod X Y) Tprod /\
    continuous_map (setprod X Y) Tprod X Tx (projection_map1 X Y) /\
    continuous_map (setprod X Y) Tprod Y Ty (projection_map2 X Y).
(** Witness the product topology **)
witness (product_topology X Tx Y Ty).
(** Goal is: A /\ B /\ C which is left-associative: (A /\ B) /\ C **)
apply andI.
- (** First part: topology_on (setprod X Y) (product_topology X Tx Y Ty) /\ continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y). **)
  apply andI.
  + (** product_topology is a topology **)
    exact (product_topology_is_topology X Tx Y Ty HTx HTy).
  + (** first projection is continuous **)
    exact (andEL (continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y))
                 (continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y))
                 (projections_are_continuous X Tx Y Ty HTx HTy)).
- (** second projection is continuous **)
  exact (andER (continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y))
               (continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y))
               (projections_are_continuous X Tx Y Ty HTx HTy)).
Qed.

(** Helper: rectangle as intersection of strips **)
Theorem rectangle_set_as_intersection : forall X Y U V:set,
  U c= X -> V c= Y ->
  rectangle_set U V = (rectangle_set U Y) :/\: (rectangle_set X V).
let X Y U V.
assume HU: U c= X.
assume HV: V c= Y.
prove rectangle_set U V = (rectangle_set U Y) :/\: (rectangle_set X V).
prove setprod U V = (setprod U Y) :/\: (setprod X V).
claim Hinter: setprod U Y :/\: setprod X V = setprod (U :/\: X) (Y :/\: V).
{ exact (setprod_intersection U Y X V). }
rewrite Hinter.
claim HUcap: U :/\: X = U.
{ exact (binintersect_Subq_eq_1 U X HU). }
claim HYcap: Y :/\: V = V.
{ rewrite (binintersect_com Y V).
  exact (binintersect_Subq_eq_1 V Y HV). }
rewrite HUcap.
rewrite HYcap.
reflexivity.
Qed.

(** Helper: coarsest property of product topology **)
(** LATEX VERSION: Any topology on XY making the projections continuous contains the product topology. **)
Theorem product_topology_coarsest : forall X Tx Y Ty Tprod:set,
  topology_on X Tx -> topology_on Y Ty ->
  topology_on (setprod X Y) Tprod ->
  continuous_map (setprod X Y) Tprod X Tx (projection_map1 X Y) ->
  continuous_map (setprod X Y) Tprod Y Ty (projection_map2 X Y) ->
  coarser_than (product_topology X Tx Y Ty) Tprod.
let X Tx Y Ty Tprod.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
assume HTprod: topology_on (setprod X Y) Tprod.
assume Hc1: continuous_map (setprod X Y) Tprod X Tx (projection_map1 X Y).
assume Hc2: continuous_map (setprod X Y) Tprod Y Ty (projection_map2 X Y).
prove coarser_than (product_topology X Tx Y Ty) Tprod.
prove product_topology X Tx Y Ty c= Tprod.
set B := product_subbasis X Tx Y Ty.
claim HBasis: basis_on (setprod X Y) B.
{ exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
claim Hc1_pre: forall U:set, U :e Tx -> preimage_of (setprod X Y) (projection_map1 X Y) U :e Tprod.
{ exact (andER ((topology_on (setprod X Y) Tprod /\ topology_on X Tx) /\ function_on (projection_map1 X Y) (setprod X Y) X)
               (forall U:set, U :e Tx -> preimage_of (setprod X Y) (projection_map1 X Y) U :e Tprod)
               Hc1). }
claim Hc2_pre: forall V:set, V :e Ty -> preimage_of (setprod X Y) (projection_map2 X Y) V :e Tprod.
{ exact (andER ((topology_on (setprod X Y) Tprod /\ topology_on Y Ty) /\ function_on (projection_map2 X Y) (setprod X Y) Y)
               (forall V:set, V :e Ty -> preimage_of (setprod X Y) (projection_map2 X Y) V :e Tprod)
               Hc2). }
claim HallB: forall b :e B, b :e Tprod.
{ let b. assume HbB: b :e B.
  apply (famunionE Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) b HbB).
  let U. assume HUconj: U :e Tx /\ b :e {rectangle_set U V0|V0 :e Ty}.
  claim HUinTx: U :e Tx.
  { exact (andEL (U :e Tx) (b :e {rectangle_set U V0|V0 :e Ty}) HUconj). }
  claim HbRepl: b :e {rectangle_set U V0|V0 :e Ty}.
  { exact (andER (U :e Tx) (b :e {rectangle_set U V0|V0 :e Ty}) HUconj). }
  claim HUsubX: U c= X.
  { exact (topology_elem_subset X Tx U HTx HUinTx). }
  claim HexV: exists V :e Ty, b = rectangle_set U V.
  { exact (ReplE Ty (fun V0:set => rectangle_set U V0) b HbRepl). }
  apply HexV.
  let V. assume HVconj: V :e Ty /\ b = rectangle_set U V.
  claim HVinTy: V :e Ty.
  { exact (andEL (V :e Ty) (b = rectangle_set U V) HVconj). }
  claim Hbeq: b = rectangle_set U V.
  { exact (andER (V :e Ty) (b = rectangle_set U V) HVconj). }
  claim HVsubY: V c= Y.
  { exact (topology_elem_subset Y Ty V HTy HVinTy). }
  claim Hpre1eq: preimage_of (setprod X Y) (projection_map1 X Y) U = rectangle_set U Y.
  { exact (preimage_projection1_rectangle X Y U HUsubX). }
  claim Hpre2eq: preimage_of (setprod X Y) (projection_map2 X Y) V = rectangle_set X V.
  { exact (preimage_projection2_rectangle X Y V HVsubY). }
  claim Hstrip1: rectangle_set U Y :e Tprod.
  { rewrite <- Hpre1eq.
    exact (Hc1_pre U HUinTx). }
  claim Hstrip2: rectangle_set X V :e Tprod.
  { rewrite <- Hpre2eq.
    exact (Hc2_pre V HVinTy). }
  claim HrectEq: rectangle_set U V = (rectangle_set U Y) :/\: (rectangle_set X V).
  { exact (rectangle_set_as_intersection X Y U V HUsubX HVsubY). }
  claim Hcap: (rectangle_set U Y) :/\: (rectangle_set X V) :e Tprod.
  { exact (topology_binintersect_closed (setprod X Y) Tprod (rectangle_set U Y) (rectangle_set X V)
           HTprod Hstrip1 Hstrip2). }
  rewrite Hbeq.
  rewrite HrectEq.
  exact Hcap. }
claim Hfiner: finer_than Tprod (generated_topology (setprod X Y) B).
{ exact (generated_topology_finer (setprod X Y) B Tprod HBasis HTprod HallB). }
exact Hfiner.
Qed.

(** from 20 Definition: metric and metric topology **) 
(** LATEX VERSION: Definition of a metric d on X and the induced metric topology generated by open balls. **)
(** FIXED: Triangle inequality uses add_SNo, not :/\:; encoded as ~(Rlt (d(x,y)+d(y,z)) d(x,z)), relying on add_SNo and the intended interpretation of ~Rlt as <=. **)
(** SUSPICIOUS DEFINITION: Triangle inequality encoded by ~Rlt (d(x,y)+d(y,z)) d(x,z) relies on Rlt totality and intended equivalence between ~Rlt and <=. **)
Definition metric_on : set -> set -> prop := fun X d =>
  function_on d (setprod X X) R /\
  (forall x y:set, x :e X -> y :e X ->
     apply_fun d (x,y) = apply_fun d (y,x)) /\
  (forall x:set, x :e X -> apply_fun d (x,x) = 0) /\
  (forall x y:set, x :e X -> y :e X ->
     ~(Rlt (apply_fun d (x,y)) 0)
     /\ (apply_fun d (x,y) = 0 -> x = y)) /\
  (forall x y z:set, x :e X -> y :e X -> z :e X ->
     ~(Rlt (add_SNo (apply_fun d (x,y)) (apply_fun d (y,z)))
           (apply_fun d (x,z)))).

(** Helper: metric_on plus totality of the graph on XX **)
Definition metric_on_total : set -> set -> prop := fun X d =>
  metric_on X d /\ total_function_on d (setprod X X) R.

(** Helper: extract function_on from metric_on **)
Theorem metric_on_function_on : forall X d:set,
  metric_on X d -> function_on d (setprod X X) R.
let X d.
assume Hm: metric_on X d.
apply Hm.
assume Hcore Htri.
apply Hcore.
assume Hcore2 Hposdef.
apply Hcore2.
assume Hab Hrefl.
apply Hab.
assume Hf Hsym.
exact Hf.
Qed.

(** Helper: symmetry of a metric **)
Theorem metric_on_symmetric : forall X d x y:set,
  metric_on X d -> x :e X -> y :e X ->
  apply_fun d (x,y) = apply_fun d (y,x).
let X d x y.
assume Hm: metric_on X d.
assume Hx: x :e X.
assume Hy: y :e X.
claim Hsym: forall x0 y0:set, x0 :e X -> y0 :e X ->
  apply_fun d (x0,y0) = apply_fun d (y0,x0).
{ apply Hm.
  assume Hcore Htri.
  apply Hcore.
  assume Hcore2 Hposdef.
  apply Hcore2.
  assume Hab Hrefl.
  apply Hab.
  assume Hf Hsym.
  exact Hsym. }
exact (Hsym x y Hx Hy).
Qed.

(** Helper: reflexive axiom for a metric **)
Theorem metric_on_diag_zero : forall X d x:set,
  metric_on X d -> x :e X -> apply_fun d (x,x) = 0.
let X d x.
assume Hm: metric_on X d.
assume Hx: x :e X.
claim Hrefl: forall x0:set, x0 :e X -> apply_fun d (x0,x0) = 0.
{ apply Hm.
  assume Hcore Htri.
  apply Hcore.
  assume Hcore2 Hposdef.
  apply Hcore2.
  assume Hab Hrefl.
  exact Hrefl. }
exact (Hrefl x Hx).
Qed.

(** Helper: nonnegativity of a metric **)
Theorem metric_on_nonneg : forall X d x y:set,
  metric_on X d -> x :e X -> y :e X ->
  ~(Rlt (apply_fun d (x,y)) 0).
let X d x y.
assume Hm: metric_on X d.
assume Hx: x :e X.
assume Hy: y :e X.
claim Hpos: forall x0 y0:set, x0 :e X -> y0 :e X ->
  ~(Rlt (apply_fun d (x0,y0)) 0) /\ (apply_fun d (x0,y0) = 0 -> x0 = y0).
{ apply Hm.
  assume Hcore Htri.
  apply Hcore.
  assume Hcore2 Hposdef.
  exact Hposdef. }
exact (andEL (~(Rlt (apply_fun d (x,y)) 0)) (apply_fun d (x,y) = 0 -> x = y) (Hpos x y Hx Hy)).
Qed.

(** Helper: zero distance implies equality **)
Theorem metric_on_zero_eq : forall X d x y:set,
  metric_on X d -> x :e X -> y :e X ->
  apply_fun d (x,y) = 0 -> x = y.
let X d x y.
assume Hm: metric_on X d.
assume Hx: x :e X.
assume Hy: y :e X.
assume H0: apply_fun d (x,y) = 0.
claim Hpos: forall x0 y0:set, x0 :e X -> y0 :e X ->
  ~(Rlt (apply_fun d (x0,y0)) 0) /\ (apply_fun d (x0,y0) = 0 -> x0 = y0).
{ apply Hm.
  assume Hcore Htri.
  apply Hcore.
  assume Hcore2 Hposdef.
  exact Hposdef. }
claim Himp: apply_fun d (x,y) = 0 -> x = y.
{ exact (andER (~(Rlt (apply_fun d (x,y)) 0)) (apply_fun d (x,y) = 0 -> x = y) (Hpos x y Hx Hy)). }
exact (Himp H0).
Qed.

(** Helper: triangle inequality (raw) **)
Theorem metric_on_triangle : forall X d x y z:set,
  metric_on X d -> x :e X -> y :e X -> z :e X ->
  ~(Rlt (add_SNo (apply_fun d (x,y)) (apply_fun d (y,z)))
        (apply_fun d (x,z))).
let X d x y z.
assume Hm: metric_on X d.
assume Hx: x :e X.
assume Hy: y :e X.
assume Hz: z :e X.
apply Hm.
assume Hcore Htri.
exact (Htri x y z Hx Hy Hz).
Qed.

Theorem metric_on_total_imp_metric_on : forall X d:set,
  metric_on_total X d -> metric_on X d.
let X d. assume H.
exact (andEL (metric_on X d) (total_function_on d (setprod X X) R) H).
Qed.

Theorem metric_on_total_total_function : forall X d:set,
  metric_on_total X d -> total_function_on d (setprod X X) R.
let X d. assume H.
exact (andER (metric_on X d) (total_function_on d (setprod X X) R) H).
Qed.

(** helper: triangle inequality in Rle form **)
Theorem metric_triangle_Rle : forall X d x y z:set,
  metric_on X d -> x :e X -> y :e X -> z :e X ->
  Rle (apply_fun d (x,z)) (add_SNo (apply_fun d (x,y)) (apply_fun d (y,z))).
let X d x y z.
assume Hm: metric_on X d.
assume Hx: x :e X.
assume Hy: y :e X.
assume Hz: z :e X.
claim Hfun: function_on d (setprod X X) R.
{ exact (metric_on_function_on X d Hm). }

claim HxyIn: (x,y) :e setprod X X.
{ exact (tuple_2_setprod X X x Hx y Hy). }
claim HyzIn: (y,z) :e setprod X X.
{ exact (tuple_2_setprod X X y Hy z Hz). }
claim HxzIn: (x,z) :e setprod X X.
{ exact (tuple_2_setprod X X x Hx z Hz). }

claim HdxyR: apply_fun d (x,y) :e R.
{ exact (Hfun (x,y) HxyIn). }
claim HdyzR: apply_fun d (y,z) :e R.
{ exact (Hfun (y,z) HyzIn). }
claim HdxzR: apply_fun d (x,z) :e R.
{ exact (Hfun (x,z) HxzIn). }
claim HsumR: add_SNo (apply_fun d (x,y)) (apply_fun d (y,z)) :e R.
{ exact (real_add_SNo (apply_fun d (x,y)) HdxyR (apply_fun d (y,z)) HdyzR). }
exact (RleI (apply_fun d (x,z)) (add_SNo (apply_fun d (x,y)) (apply_fun d (y,z))) HdxzR HsumR
            (metric_on_triangle X d x y z Hm Hx Hy Hz)).
Qed.

(** from 20 Definition: open ball **)
(** LATEX VERSION: Open ball centered at x with radius r in metric d. **)
(** FIXED: Previous version quantified the radius and made the set equal to X; open_ball now takes the radius r as a parameter and uses {y :e X | d(x,y) < r}. **)
Definition open_ball : set -> set -> set -> set -> set := fun X d x r =>
  {y :e X|Rlt (apply_fun d (x,y)) r}.

(** Helper: elimination and introduction rules for open_ball **)
Theorem open_ballE1 : forall X d x r y:set,
  y :e open_ball X d x r -> y :e X.
let X d x r y.
assume Hy: y :e open_ball X d x r.
exact (SepE1 X (fun y0:set => Rlt (apply_fun d (x,y0)) r) y Hy).
Qed.

Theorem open_ballE2 : forall X d x r y:set,
  y :e open_ball X d x r -> Rlt (apply_fun d (x,y)) r.
let X d x r y.
assume Hy: y :e open_ball X d x r.
exact (SepE2 X (fun y0:set => Rlt (apply_fun d (x,y0)) r) y Hy).
Qed.

Theorem open_ballI : forall X d x r y:set,
  y :e X -> Rlt (apply_fun d (x,y)) r -> y :e open_ball X d x r.
let X d x r y.
assume HyX: y :e X.
assume Hlt: Rlt (apply_fun d (x,y)) r.
exact (SepI X (fun y0:set => Rlt (apply_fun d (x,y0)) r) y HyX Hlt).
Qed.

(** Helper: open balls are subsets of X **)
Theorem open_ball_subset_X : forall X d x r:set, open_ball X d x r c= X.
let X d x r.
let y. assume Hy: y :e open_ball X d x r.
exact (open_ballE1 X d x r y Hy).
Qed.

(** Helper: open balls are elements of Power X **)
Theorem open_ball_in_Power : forall X d x r:set, open_ball X d x r :e Power X.
let X d x r.
apply PowerI.
exact (open_ball_subset_X X d x r).
Qed.

(** Helper: the center belongs to any open ball with positive radius **)
Theorem center_in_open_ball : forall X d x r:set,
  metric_on X d -> x :e X -> Rlt 0 r -> x :e open_ball X d x r.
let X d x r.
assume Hm: metric_on X d.
assume Hx: x :e X.
assume Hr: Rlt 0 r.
claim Hdxx0: apply_fun d (x,x) = 0.
{ exact (metric_on_diag_zero X d x Hm Hx). }
claim Hpred: Rlt (apply_fun d (x,x)) r.
{ rewrite Hdxx0. exact Hr. }
exact (SepI X (fun y0:set => Rlt (apply_fun d (x,y0)) r) x Hx Hpred).
Qed.

(** Helper: any open ball with positive radius is nonempty **)
Theorem open_ball_nonempty : forall X d x r:set,
  metric_on X d -> x :e X -> Rlt 0 r -> open_ball X d x r <> Empty.
let X d x r.
assume Hm: metric_on X d.
assume Hx: x :e X.
assume Hr: Rlt 0 r.
assume Hempty: open_ball X d x r = Empty.
claim Hxin: x :e open_ball X d x r.
{ exact (center_in_open_ball X d x r Hm Hx Hr). }
claim HxinEmpty: x :e Empty.
{ rewrite <- Hempty. exact Hxin. }
exact (EmptyE x HxinEmpty).
Qed.

(** Helper: for any positive real d, some eps_N is smaller than d **)
Theorem exists_eps_lt_pos : forall d:set, d :e R -> Rlt 0 d -> exists N :e omega, eps_ N < d.
let d.
assume HdR: d :e R.
assume Hdpos: Rlt 0 d.
claim HdS: SNo d.
{ exact (real_SNo d HdR). }
claim H0ltd: 0 < d.
{ exact (RltE_lt 0 d Hdpos). }
set invd := recip_SNo_pos d.
claim HinvdDef: invd = recip_SNo_pos d.
{ reflexivity. }
claim HinvdR: invd :e R.
{ rewrite HinvdDef.
  exact (real_recip_SNo_pos d HdR H0ltd). }
claim HinvdS: SNo invd.
{ exact (real_SNo invd HinvdR). }
claim Hinvdpos: 0 < invd.
{ exact (recip_SNo_pos_is_pos d HdS H0ltd). }
apply (real_E invd HinvdR (exists N :e omega, eps_ N < d)).
assume HinvS: SNo invd.
assume Hlev.
assume HinS.
assume Hlow.
assume Hup.
assume Huniq.
assume Happrox.
claim HexNlt: exists N :e omega, mul_SNo (eps_ N) invd < 1.
{ exact (SNoS_ordsucc_omega_bdd_eps_pos invd HinS Hinvdpos Hup). }
apply HexNlt.
let N. assume HNpair.
claim HNomega: N :e omega.
{ exact (andEL (N :e omega) (mul_SNo (eps_ N) invd < 1) HNpair). }
claim HmulLt: mul_SNo (eps_ N) invd < 1.
{ exact (andER (N :e omega) (mul_SNo (eps_ N) invd < 1) HNpair). }
witness N.
apply andI.
- exact HNomega.
- claim HepsS: SNo (eps_ N).
  { exact (SNo_eps_ N HNomega). }
  claim HepsLtDiv: eps_ N < div_SNo 1 invd.
  { exact (div_SNo_pos_LtR 1 invd (eps_ N) SNo_1 HinvS HepsS Hinvdpos HmulLt). }
  claim HdivEq: div_SNo 1 invd = d.
  { claim Hposcase: recip_SNo invd = recip_SNo_pos invd.
    { exact (recip_SNo_poscase invd Hinvdpos). }
    claim HrecipInv: recip_SNo_pos invd = d.
    { rewrite HinvdDef.
      exact (recip_SNo_pos_invol d HdS H0ltd). }
    claim HdivDef: div_SNo 1 invd = mul_SNo 1 (recip_SNo invd).
    { reflexivity. }
    rewrite HdivDef.
    rewrite Hposcase.
    rewrite HrecipInv.
    exact (mul_SNo_oneL d HdS). }
  rewrite <- HdivEq.
  exact HepsLtDiv.
Qed.

(** Helper: if a <= b and b < c then a < c **)
Theorem Rle_Rlt_tra : forall a b c:set, Rle a b -> Rlt b c -> Rlt a c.
let a b c.
assume Hab: Rle a b.
assume Hbc: Rlt b c.
claim HaR: a :e R.
{ exact (RleE_left a b Hab). }
claim HbR: b :e R.
{ exact (RleE_right a b Hab). }
claim HcR: c :e R.
{ exact (RltE_right b c Hbc). }
claim HaS: SNo a.
{ exact (real_SNo a HaR). }
claim HbS: SNo b.
{ exact (real_SNo b HbR). }
apply (SNoLt_trichotomy_or_impred a b HaS HbS (Rlt a c)).
- assume Hablt: a < b.
  claim HabRlt: Rlt a b.
  { exact (RltI a b HaR HbR Hablt). }
  exact (Rlt_tra a b c HabRlt Hbc).
- assume Habeq: a = b.
  rewrite Habeq.
  exact Hbc.
- assume Hbalt: b < a.
  claim HbaRlt: Rlt b a.
  { exact (RltI b a HbR HaR Hbalt). }
  claim Hnlt: ~(Rlt b a).
  { exact (RleE_nlt a b Hab). }
  claim Hfalse: False.
  { exact (Hnlt HbaRlt). }
  apply FalseE.
  exact Hfalse.
Qed.

(** Helper: refinement of two open balls around a common point **)
(** LATEX VERSION: If x lies in two open balls, then some smaller ball around x is contained in their intersection. **)
Theorem open_ball_refine_intersection : forall X d c1 c2 x r1 r2:set,
  metric_on X d ->
  c1 :e X -> c2 :e X -> x :e X ->
  r1 :e R -> r2 :e R ->
  Rlt 0 r1 -> Rlt 0 r2 ->
  x :e open_ball X d c1 r1 ->
  x :e open_ball X d c2 r2 ->
  exists r3:set, r3 :e R /\ Rlt 0 r3 /\
    open_ball X d x r3 c= (open_ball X d c1 r1) :/\: (open_ball X d c2 r2).
let X d c1 c2 x r1 r2.
assume Hm: metric_on X d.
assume Hc1: c1 :e X.
assume Hc2: c2 :e X.
assume HxX: x :e X.
assume Hr1R: r1 :e R.
assume Hr2R: r2 :e R.
assume Hr1pos: Rlt 0 r1.
assume Hr2pos: Rlt 0 r2.
assume HxB1: x :e open_ball X d c1 r1.
assume HxB2: x :e open_ball X d c2 r2.

claim Hfun: function_on d (setprod X X) R.
{ exact (metric_on_function_on X d Hm). }

claim Hc1xIn: (c1,x) :e setprod X X.
{ exact (tuple_2_setprod X X c1 Hc1 x HxX). }
claim Hc2xIn: (c2,x) :e setprod X X.
{ exact (tuple_2_setprod X X c2 Hc2 x HxX). }

set dx1 := apply_fun d (c1,x).
set dx2 := apply_fun d (c2,x).
claim Hdx1R: dx1 :e R.
{ exact (Hfun (c1,x) Hc1xIn). }
claim Hdx2R: dx2 :e R.
{ exact (Hfun (c2,x) Hc2xIn). }
claim Hdx1S: SNo dx1.
{ exact (real_SNo dx1 Hdx1R). }
claim Hdx2S: SNo dx2.
{ exact (real_SNo dx2 Hdx2R). }
claim Hr1S: SNo r1.
{ exact (real_SNo r1 Hr1R). }
claim Hr2S: SNo r2.
{ exact (real_SNo r2 Hr2R). }

claim Hdx1lt_r1: dx1 < r1.
{ exact (RltE_lt dx1 r1 (open_ballE2 X d c1 r1 x HxB1)). }
claim Hdx2lt_r2: dx2 < r2.
{ exact (RltE_lt dx2 r2 (open_ballE2 X d c2 r2 x HxB2)). }

set mdx1 := minus_SNo dx1.
set mdx2 := minus_SNo dx2.
claim Hmdx1Def: mdx1 = minus_SNo dx1.
{ reflexivity. }
claim Hmdx2Def: mdx2 = minus_SNo dx2.
{ reflexivity. }
claim Hmdx1R: mdx1 :e R.
{ exact (real_minus_SNo dx1 Hdx1R). }
claim Hmdx2R: mdx2 :e R.
{ exact (real_minus_SNo dx2 Hdx2R). }
claim Hmdx1S: SNo mdx1.
{ exact (real_SNo mdx1 Hmdx1R). }
claim Hmdx2S: SNo mdx2.
{ exact (real_SNo mdx2 Hmdx2R). }

set delta1 := add_SNo r1 mdx1.
set delta2 := add_SNo r2 mdx2.
claim Hdelta1Def: delta1 = add_SNo r1 mdx1.
{ reflexivity. }
claim Hdelta2Def: delta2 = add_SNo r2 mdx2.
{ reflexivity. }
claim Hdelta1R: delta1 :e R.
{ exact (real_add_SNo r1 Hr1R mdx1 Hmdx1R). }
claim Hdelta2R: delta2 :e R.
{ exact (real_add_SNo r2 Hr2R mdx2 Hmdx2R). }
claim Hdelta1S: SNo delta1.
{ exact (real_SNo delta1 Hdelta1R). }
claim Hdelta2S: SNo delta2.
{ exact (real_SNo delta2 Hdelta2R). }

claim H0lt_delta1: 0 < delta1.
{ rewrite Hdelta1Def.
  rewrite Hmdx1Def.
  claim H0plus: add_SNo 0 dx1 < r1.
  { rewrite (add_SNo_0L dx1 Hdx1S).
    exact Hdx1lt_r1. }
  exact (add_SNo_minus_Lt2b r1 dx1 0 Hr1S Hdx1S SNo_0 H0plus). }
claim H0lt_delta2: 0 < delta2.
{ rewrite Hdelta2Def.
  rewrite Hmdx2Def.
  claim H0plus: add_SNo 0 dx2 < r2.
  { rewrite (add_SNo_0L dx2 Hdx2S).
    exact Hdx2lt_r2. }
  exact (add_SNo_minus_Lt2b r2 dx2 0 Hr2S Hdx2S SNo_0 H0plus). }

claim Hdelta1pos: Rlt 0 delta1.
{ exact (RltI 0 delta1 real_0 Hdelta1R H0lt_delta1). }
claim Hdelta2pos: Rlt 0 delta2.
{ exact (RltI 0 delta2 real_0 Hdelta2R H0lt_delta2). }

apply (SNoLt_trichotomy_or_impred delta1 delta2 Hdelta1S Hdelta2S
  (exists r3:set, r3 :e R /\ Rlt 0 r3 /\
    open_ball X d x r3 c= (open_ball X d c1 r1) :/\: (open_ball X d c2 r2))).
- assume Hdelta1lt: delta1 < delta2.
  claim HexN: exists N :e omega, eps_ N < delta1.
  { exact (exists_eps_lt_pos delta1 Hdelta1R Hdelta1pos). }
  apply HexN.
  let N. assume HNpair.
  claim HNomega: N :e omega.
  { exact (andEL (N :e omega) (eps_ N < delta1) HNpair). }
  claim HepsLt1: eps_ N < delta1.
  { exact (andER (N :e omega) (eps_ N < delta1) HNpair). }
  set r3 := eps_ N.
  claim Hr3S: SNo r3.
  { exact (SNo_eps_ N HNomega). }
  claim Hr3InS: r3 :e SNoS_ omega.
  { exact (SNo_eps_SNoS_omega N HNomega). }
  claim Hr3R: r3 :e R.
  { exact (SNoS_omega_real r3 Hr3InS). }
  claim H0lt_r3: 0 < r3.
  { exact (SNo_eps_pos N HNomega). }
  claim Hr3pos: Rlt 0 r3.
  { exact (RltI 0 r3 real_0 Hr3R H0lt_r3). }
  claim Hr3lt1: r3 < delta1.
  { exact HepsLt1. }
  claim Hr3lt2: r3 < delta2.
  { exact (SNoLt_tra r3 delta1 delta2 Hr3S Hdelta1S Hdelta2S Hr3lt1 Hdelta1lt). }
  witness r3.
  apply andI.
  - apply andI.
    + exact Hr3R.
    + exact Hr3pos.
  - let y. assume Hy: y :e open_ball X d x r3.
    claim HyX: y :e X.
    { exact (open_ballE1 X d x r3 y Hy). }
    claim HxyIn: (x,y) :e setprod X X.
    { exact (tuple_2_setprod X X x HxX y HyX). }
    claim Hc1yIn: (c1,y) :e setprod X X.
    { exact (tuple_2_setprod X X c1 Hc1 y HyX). }
    claim Hc2yIn: (c2,y) :e setprod X X.
    { exact (tuple_2_setprod X X c2 Hc2 y HyX). }
    set dxy := apply_fun d (x,y).
    set dc1y := apply_fun d (c1,y).
    set dc2y := apply_fun d (c2,y).
    claim HdxyR: dxy :e R.
    { exact (Hfun (x,y) HxyIn). }
    claim Hdc1yR: dc1y :e R.
    { exact (Hfun (c1,y) Hc1yIn). }
    claim Hdc2yR: dc2y :e R.
    { exact (Hfun (c2,y) Hc2yIn). }
    claim HdxyS: SNo dxy.
    { exact (real_SNo dxy HdxyR). }
    claim Hdc1yS: SNo dc1y.
    { exact (real_SNo dc1y Hdc1yR). }
    claim Hdc2yS: SNo dc2y.
    { exact (real_SNo dc2y Hdc2yR). }
    claim HdxyLtR3: dxy < r3.
    { exact (RltE_lt dxy r3 (open_ballE2 X d x r3 y Hy)). }
    claim Hsum1R: add_SNo dx1 dxy :e R.
    { exact (real_add_SNo dx1 Hdx1R dxy HdxyR). }
    claim Hsum2R: add_SNo dx2 dxy :e R.
    { exact (real_add_SNo dx2 Hdx2R dxy HdxyR). }
    claim Hsum1S: SNo (add_SNo dx1 dxy).
    { exact (real_SNo (add_SNo dx1 dxy) Hsum1R). }
    claim Hsum2S: SNo (add_SNo dx2 dxy).
    { exact (real_SNo (add_SNo dx2 dxy) Hsum2R). }
    claim Hdx1r3R: add_SNo dx1 r3 :e R.
    { exact (real_add_SNo dx1 Hdx1R r3 Hr3R). }
    claim Hdx2r3R: add_SNo dx2 r3 :e R.
    { exact (real_add_SNo dx2 Hdx2R r3 Hr3R). }
    claim Hdx1r3S: SNo (add_SNo dx1 r3).
    { exact (real_SNo (add_SNo dx1 r3) Hdx1r3R). }
    claim Hdx2r3S: SNo (add_SNo dx2 r3).
    { exact (real_SNo (add_SNo dx2 r3) Hdx2r3R). }
    claim Hdx1delta1R: add_SNo dx1 delta1 :e R.
    { exact (real_add_SNo dx1 Hdx1R delta1 Hdelta1R). }
    claim Hdx2delta2R: add_SNo dx2 delta2 :e R.
    { exact (real_add_SNo dx2 Hdx2R delta2 Hdelta2R). }
    claim Hdx1delta1S: SNo (add_SNo dx1 delta1).
    { exact (real_SNo (add_SNo dx1 delta1) Hdx1delta1R). }
    claim Hdx2delta2S: SNo (add_SNo dx2 delta2).
    { exact (real_SNo (add_SNo dx2 delta2) Hdx2delta2R). }
    claim Hdx1r3lt: add_SNo dx1 r3 < r1.
    { claim Hdx1r3lt': add_SNo dx1 r3 < add_SNo dx1 delta1.
      { exact (add_SNo_Lt2 dx1 r3 delta1 Hdx1S Hr3S Hdelta1S Hr3lt1). }
      claim Heq: add_SNo dx1 delta1 = r1.
      { claim Hcom: add_SNo dx1 delta1 = add_SNo delta1 dx1.
        { exact (add_SNo_com dx1 delta1 Hdx1S Hdelta1S). }
        rewrite Hcom.
        rewrite (add_SNo_minus_R2' r1 dx1 Hr1S Hdx1S).
        reflexivity. }
      rewrite <- Heq.
      exact Hdx1r3lt'. }
    claim Hdx2r3lt: add_SNo dx2 r3 < r2.
    { claim Hdx2r3lt': add_SNo dx2 r3 < add_SNo dx2 delta2.
      { exact (add_SNo_Lt2 dx2 r3 delta2 Hdx2S Hr3S Hdelta2S Hr3lt2). }
      claim Heq: add_SNo dx2 delta2 = r2.
      { claim Hcom: add_SNo dx2 delta2 = add_SNo delta2 dx2.
        { exact (add_SNo_com dx2 delta2 Hdx2S Hdelta2S). }
        rewrite Hcom.
        rewrite (add_SNo_minus_R2' r2 dx2 Hr2S Hdx2S).
        reflexivity. }
      rewrite <- Heq.
      exact Hdx2r3lt'. }
    claim Hsum1lt: add_SNo dx1 dxy < r1.
    { claim Hlt1: add_SNo dx1 dxy < add_SNo dx1 r3.
      { exact (add_SNo_Lt2 dx1 dxy r3 Hdx1S HdxyS Hr3S HdxyLtR3). }
      exact (SNoLt_tra (add_SNo dx1 dxy) (add_SNo dx1 r3) r1
             Hsum1S Hdx1r3S Hr1S Hlt1 Hdx1r3lt). }
    claim Hsum2lt: add_SNo dx2 dxy < r2.
    { claim Hlt1: add_SNo dx2 dxy < add_SNo dx2 r3.
      { exact (add_SNo_Lt2 dx2 dxy r3 Hdx2S HdxyS Hr3S HdxyLtR3). }
      exact (SNoLt_tra (add_SNo dx2 dxy) (add_SNo dx2 r3) r2
             Hsum2S Hdx2r3S Hr2S Hlt1 Hdx2r3lt). }
    claim Htri1: Rle dc1y (add_SNo dx1 dxy).
    { exact (metric_triangle_Rle X d c1 x y Hm Hc1 HxX HyX). }
    claim Htri2: Rle dc2y (add_SNo dx2 dxy).
    { exact (metric_triangle_Rle X d c2 x y Hm Hc2 HxX HyX). }
    claim Hsum1Rlt: Rlt (add_SNo dx1 dxy) r1.
    { exact (RltI (add_SNo dx1 dxy) r1 Hsum1R Hr1R Hsum1lt). }
    claim Hsum2Rlt: Rlt (add_SNo dx2 dxy) r2.
    { exact (RltI (add_SNo dx2 dxy) r2 Hsum2R Hr2R Hsum2lt). }
    claim Hdc1yRlt: Rlt dc1y r1.
    { exact (Rle_Rlt_tra dc1y (add_SNo dx1 dxy) r1 Htri1 Hsum1Rlt). }
    claim Hdc2yRlt: Rlt dc2y r2.
    { exact (Rle_Rlt_tra dc2y (add_SNo dx2 dxy) r2 Htri2 Hsum2Rlt). }
    claim HyB1: y :e open_ball X d c1 r1.
    { exact (open_ballI X d c1 r1 y HyX Hdc1yRlt). }
    claim HyB2: y :e open_ball X d c2 r2.
    { exact (open_ballI X d c2 r2 y HyX Hdc2yRlt). }
    apply binintersectI.
    + exact HyB1.
    + exact HyB2.
- assume Hdeltaeq: delta1 = delta2.
  claim HexN: exists N :e omega, eps_ N < delta2.
  { exact (exists_eps_lt_pos delta2 Hdelta2R Hdelta2pos). }
  apply HexN.
  let N. assume HNpair.
  claim HNomega: N :e omega.
  { exact (andEL (N :e omega) (eps_ N < delta2) HNpair). }
  claim HepsLt2: eps_ N < delta2.
  { exact (andER (N :e omega) (eps_ N < delta2) HNpair). }
  set r3 := eps_ N.
  claim Hr3S: SNo r3.
  { exact (SNo_eps_ N HNomega). }
  claim Hr3InS: r3 :e SNoS_ omega.
  { exact (SNo_eps_SNoS_omega N HNomega). }
  claim Hr3R: r3 :e R.
  { exact (SNoS_omega_real r3 Hr3InS). }
  claim H0lt_r3: 0 < r3.
  { exact (SNo_eps_pos N HNomega). }
  claim Hr3pos: Rlt 0 r3.
  { exact (RltI 0 r3 real_0 Hr3R H0lt_r3). }
  claim Hr3lt2: r3 < delta2.
  { exact HepsLt2. }
  claim Hr3lt1: r3 < delta1.
  { rewrite Hdeltaeq.
    exact Hr3lt2. }
  witness r3.
  apply andI.
  - apply andI.
    + exact Hr3R.
    + exact Hr3pos.
  - let y. assume Hy: y :e open_ball X d x r3.
    claim HyX: y :e X.
    { exact (open_ballE1 X d x r3 y Hy). }
    claim HxyIn: (x,y) :e setprod X X.
    { exact (tuple_2_setprod X X x HxX y HyX). }
    claim Hc1yIn: (c1,y) :e setprod X X.
    { exact (tuple_2_setprod X X c1 Hc1 y HyX). }
    claim Hc2yIn: (c2,y) :e setprod X X.
    { exact (tuple_2_setprod X X c2 Hc2 y HyX). }
    set dxy := apply_fun d (x,y).
    set dc1y := apply_fun d (c1,y).
    set dc2y := apply_fun d (c2,y).
    claim HdxyR: dxy :e R.
    { exact (Hfun (x,y) HxyIn). }
    claim Hdc1yR: dc1y :e R.
    { exact (Hfun (c1,y) Hc1yIn). }
    claim Hdc2yR: dc2y :e R.
    { exact (Hfun (c2,y) Hc2yIn). }
    claim HdxyS: SNo dxy.
    { exact (real_SNo dxy HdxyR). }
    claim Hdc1yS: SNo dc1y.
    { exact (real_SNo dc1y Hdc1yR). }
    claim Hdc2yS: SNo dc2y.
    { exact (real_SNo dc2y Hdc2yR). }
    claim HdxyLtR3: dxy < r3.
    { exact (RltE_lt dxy r3 (open_ballE2 X d x r3 y Hy)). }
    claim Hsum1R: add_SNo dx1 dxy :e R.
    { exact (real_add_SNo dx1 Hdx1R dxy HdxyR). }
    claim Hsum2R: add_SNo dx2 dxy :e R.
    { exact (real_add_SNo dx2 Hdx2R dxy HdxyR). }
    claim Hsum1S: SNo (add_SNo dx1 dxy).
    { exact (real_SNo (add_SNo dx1 dxy) Hsum1R). }
    claim Hsum2S: SNo (add_SNo dx2 dxy).
    { exact (real_SNo (add_SNo dx2 dxy) Hsum2R). }
    claim Hdx1r3R: add_SNo dx1 r3 :e R.
    { exact (real_add_SNo dx1 Hdx1R r3 Hr3R). }
    claim Hdx2r3R: add_SNo dx2 r3 :e R.
    { exact (real_add_SNo dx2 Hdx2R r3 Hr3R). }
    claim Hdx1r3S: SNo (add_SNo dx1 r3).
    { exact (real_SNo (add_SNo dx1 r3) Hdx1r3R). }
    claim Hdx2r3S: SNo (add_SNo dx2 r3).
    { exact (real_SNo (add_SNo dx2 r3) Hdx2r3R). }
    claim Hdx1r3lt: add_SNo dx1 r3 < r1.
    { claim Hdx1r3lt': add_SNo dx1 r3 < add_SNo dx1 delta1.
      { exact (add_SNo_Lt2 dx1 r3 delta1 Hdx1S Hr3S Hdelta1S Hr3lt1). }
      claim Heq: add_SNo dx1 delta1 = r1.
      { claim Hcom: add_SNo dx1 delta1 = add_SNo delta1 dx1.
        { exact (add_SNo_com dx1 delta1 Hdx1S Hdelta1S). }
        rewrite Hcom.
        rewrite (add_SNo_minus_R2' r1 dx1 Hr1S Hdx1S).
        reflexivity. }
      rewrite <- Heq.
      exact Hdx1r3lt'. }
    claim Hdx2r3lt: add_SNo dx2 r3 < r2.
    { claim Hdx2r3lt': add_SNo dx2 r3 < add_SNo dx2 delta2.
      { exact (add_SNo_Lt2 dx2 r3 delta2 Hdx2S Hr3S Hdelta2S Hr3lt2). }
      claim Heq: add_SNo dx2 delta2 = r2.
      { claim Hcom: add_SNo dx2 delta2 = add_SNo delta2 dx2.
        { exact (add_SNo_com dx2 delta2 Hdx2S Hdelta2S). }
        rewrite Hcom.
        rewrite (add_SNo_minus_R2' r2 dx2 Hr2S Hdx2S).
        reflexivity. }
      rewrite <- Heq.
      exact Hdx2r3lt'. }
    claim Hsum1lt: add_SNo dx1 dxy < r1.
    { claim Hlt1: add_SNo dx1 dxy < add_SNo dx1 r3.
      { exact (add_SNo_Lt2 dx1 dxy r3 Hdx1S HdxyS Hr3S HdxyLtR3). }
      exact (SNoLt_tra (add_SNo dx1 dxy) (add_SNo dx1 r3) r1
             Hsum1S Hdx1r3S Hr1S Hlt1 Hdx1r3lt). }
    claim Hsum2lt: add_SNo dx2 dxy < r2.
    { claim Hlt1: add_SNo dx2 dxy < add_SNo dx2 r3.
      { exact (add_SNo_Lt2 dx2 dxy r3 Hdx2S HdxyS Hr3S HdxyLtR3). }
      exact (SNoLt_tra (add_SNo dx2 dxy) (add_SNo dx2 r3) r2
             Hsum2S Hdx2r3S Hr2S Hlt1 Hdx2r3lt). }
    claim Htri1: Rle dc1y (add_SNo dx1 dxy).
    { exact (metric_triangle_Rle X d c1 x y Hm Hc1 HxX HyX). }
    claim Htri2: Rle dc2y (add_SNo dx2 dxy).
    { exact (metric_triangle_Rle X d c2 x y Hm Hc2 HxX HyX). }
    claim Hsum1Rlt: Rlt (add_SNo dx1 dxy) r1.
    { exact (RltI (add_SNo dx1 dxy) r1 Hsum1R Hr1R Hsum1lt). }
    claim Hsum2Rlt: Rlt (add_SNo dx2 dxy) r2.
    { exact (RltI (add_SNo dx2 dxy) r2 Hsum2R Hr2R Hsum2lt). }
    claim Hdc1yRlt: Rlt dc1y r1.
    { exact (Rle_Rlt_tra dc1y (add_SNo dx1 dxy) r1 Htri1 Hsum1Rlt). }
    claim Hdc2yRlt: Rlt dc2y r2.
    { exact (Rle_Rlt_tra dc2y (add_SNo dx2 dxy) r2 Htri2 Hsum2Rlt). }
    claim HyB1: y :e open_ball X d c1 r1.
    { exact (open_ballI X d c1 r1 y HyX Hdc1yRlt). }
    claim HyB2: y :e open_ball X d c2 r2.
    { exact (open_ballI X d c2 r2 y HyX Hdc2yRlt). }
    apply binintersectI.
    + exact HyB1.
    + exact HyB2.
- assume Hdelta2lt: delta2 < delta1.
  claim HexN: exists N :e omega, eps_ N < delta2.
  { exact (exists_eps_lt_pos delta2 Hdelta2R Hdelta2pos). }
  apply HexN.
  let N. assume HNpair.
  claim HNomega: N :e omega.
  { exact (andEL (N :e omega) (eps_ N < delta2) HNpair). }
  claim HepsLt2: eps_ N < delta2.
  { exact (andER (N :e omega) (eps_ N < delta2) HNpair). }
  set r3 := eps_ N.
  claim Hr3S: SNo r3.
  { exact (SNo_eps_ N HNomega). }
  claim Hr3InS: r3 :e SNoS_ omega.
  { exact (SNo_eps_SNoS_omega N HNomega). }
  claim Hr3R: r3 :e R.
  { exact (SNoS_omega_real r3 Hr3InS). }
  claim H0lt_r3: 0 < r3.
  { exact (SNo_eps_pos N HNomega). }
  claim Hr3pos: Rlt 0 r3.
  { exact (RltI 0 r3 real_0 Hr3R H0lt_r3). }
  claim Hr3lt2: r3 < delta2.
  { exact HepsLt2. }
  claim Hr3lt1: r3 < delta1.
  { exact (SNoLt_tra r3 delta2 delta1 Hr3S Hdelta2S Hdelta1S Hr3lt2 Hdelta2lt). }
  witness r3.
  apply andI.
  - apply andI.
    + exact Hr3R.
    + exact Hr3pos.
  - let y. assume Hy: y :e open_ball X d x r3.
    claim HyX: y :e X.
    { exact (open_ballE1 X d x r3 y Hy). }
    claim HxyIn: (x,y) :e setprod X X.
    { exact (tuple_2_setprod X X x HxX y HyX). }
    claim Hc1yIn: (c1,y) :e setprod X X.
    { exact (tuple_2_setprod X X c1 Hc1 y HyX). }
    claim Hc2yIn: (c2,y) :e setprod X X.
    { exact (tuple_2_setprod X X c2 Hc2 y HyX). }
    set dxy := apply_fun d (x,y).
    set dc1y := apply_fun d (c1,y).
    set dc2y := apply_fun d (c2,y).
    claim HdxyR: dxy :e R.
    { exact (Hfun (x,y) HxyIn). }
    claim Hdc1yR: dc1y :e R.
    { exact (Hfun (c1,y) Hc1yIn). }
    claim Hdc2yR: dc2y :e R.
    { exact (Hfun (c2,y) Hc2yIn). }
    claim HdxyS: SNo dxy.
    { exact (real_SNo dxy HdxyR). }
    claim Hdc1yS: SNo dc1y.
    { exact (real_SNo dc1y Hdc1yR). }
    claim Hdc2yS: SNo dc2y.
    { exact (real_SNo dc2y Hdc2yR). }
    claim HdxyLtR3: dxy < r3.
    { exact (RltE_lt dxy r3 (open_ballE2 X d x r3 y Hy)). }
    claim Hsum1R: add_SNo dx1 dxy :e R.
    { exact (real_add_SNo dx1 Hdx1R dxy HdxyR). }
    claim Hsum2R: add_SNo dx2 dxy :e R.
    { exact (real_add_SNo dx2 Hdx2R dxy HdxyR). }
    claim Hsum1S: SNo (add_SNo dx1 dxy).
    { exact (real_SNo (add_SNo dx1 dxy) Hsum1R). }
    claim Hsum2S: SNo (add_SNo dx2 dxy).
    { exact (real_SNo (add_SNo dx2 dxy) Hsum2R). }
    claim Hdx1r3R: add_SNo dx1 r3 :e R.
    { exact (real_add_SNo dx1 Hdx1R r3 Hr3R). }
    claim Hdx2r3R: add_SNo dx2 r3 :e R.
    { exact (real_add_SNo dx2 Hdx2R r3 Hr3R). }
    claim Hdx1r3S: SNo (add_SNo dx1 r3).
    { exact (real_SNo (add_SNo dx1 r3) Hdx1r3R). }
    claim Hdx2r3S: SNo (add_SNo dx2 r3).
    { exact (real_SNo (add_SNo dx2 r3) Hdx2r3R). }
    claim Hdx1r3lt: add_SNo dx1 r3 < r1.
    { claim Hdx1r3lt': add_SNo dx1 r3 < add_SNo dx1 delta1.
      { exact (add_SNo_Lt2 dx1 r3 delta1 Hdx1S Hr3S Hdelta1S Hr3lt1). }
      claim Heq: add_SNo dx1 delta1 = r1.
      { claim Hcom: add_SNo dx1 delta1 = add_SNo delta1 dx1.
        { exact (add_SNo_com dx1 delta1 Hdx1S Hdelta1S). }
        rewrite Hcom.
        rewrite (add_SNo_minus_R2' r1 dx1 Hr1S Hdx1S).
        reflexivity. }
      rewrite <- Heq.
      exact Hdx1r3lt'. }
    claim Hdx2r3lt: add_SNo dx2 r3 < r2.
    { claim Hdx2r3lt': add_SNo dx2 r3 < add_SNo dx2 delta2.
      { exact (add_SNo_Lt2 dx2 r3 delta2 Hdx2S Hr3S Hdelta2S Hr3lt2). }
      claim Heq: add_SNo dx2 delta2 = r2.
      { claim Hcom: add_SNo dx2 delta2 = add_SNo delta2 dx2.
        { exact (add_SNo_com dx2 delta2 Hdx2S Hdelta2S). }
        rewrite Hcom.
        rewrite (add_SNo_minus_R2' r2 dx2 Hr2S Hdx2S).
        reflexivity. }
      rewrite <- Heq.
      exact Hdx2r3lt'. }
    claim Hsum1lt: add_SNo dx1 dxy < r1.
    { claim Hlt1: add_SNo dx1 dxy < add_SNo dx1 r3.
      { exact (add_SNo_Lt2 dx1 dxy r3 Hdx1S HdxyS Hr3S HdxyLtR3). }
      exact (SNoLt_tra (add_SNo dx1 dxy) (add_SNo dx1 r3) r1
             Hsum1S Hdx1r3S Hr1S Hlt1 Hdx1r3lt). }
    claim Hsum2lt: add_SNo dx2 dxy < r2.
    { claim Hlt1: add_SNo dx2 dxy < add_SNo dx2 r3.
      { exact (add_SNo_Lt2 dx2 dxy r3 Hdx2S HdxyS Hr3S HdxyLtR3). }
      exact (SNoLt_tra (add_SNo dx2 dxy) (add_SNo dx2 r3) r2
             Hsum2S Hdx2r3S Hr2S Hlt1 Hdx2r3lt). }
    claim Htri1: Rle dc1y (add_SNo dx1 dxy).
    { exact (metric_triangle_Rle X d c1 x y Hm Hc1 HxX HyX). }
    claim Htri2: Rle dc2y (add_SNo dx2 dxy).
    { exact (metric_triangle_Rle X d c2 x y Hm Hc2 HxX HyX). }
    claim Hsum1Rlt: Rlt (add_SNo dx1 dxy) r1.
    { exact (RltI (add_SNo dx1 dxy) r1 Hsum1R Hr1R Hsum1lt). }
    claim Hsum2Rlt: Rlt (add_SNo dx2 dxy) r2.
    { exact (RltI (add_SNo dx2 dxy) r2 Hsum2R Hr2R Hsum2lt). }
    claim Hdc1yRlt: Rlt dc1y r1.
    { exact (Rle_Rlt_tra dc1y (add_SNo dx1 dxy) r1 Htri1 Hsum1Rlt). }
    claim Hdc2yRlt: Rlt dc2y r2.
    { exact (Rle_Rlt_tra dc2y (add_SNo dx2 dxy) r2 Htri2 Hsum2Rlt). }
    claim HyB1: y :e open_ball X d c1 r1.
    { exact (open_ballI X d c1 r1 y HyX Hdc1yRlt). }
    claim HyB2: y :e open_ball X d c2 r2.
    { exact (open_ballI X d c2 r2 y HyX Hdc2yRlt). }
    apply binintersectI.
    + exact HyB1.
    + exact HyB2.
Qed.

(** Helper: if x lies in an open ball, then some ball around x lies inside it **)
(** LATEX VERSION: If x in B_r(c), then exists s>0 with B_s(x) subset B_r(c). **)
Theorem open_ball_refine_center : forall X d c x r:set,
  metric_on X d ->
  c :e X -> x :e X ->
  r :e R -> Rlt 0 r ->
  x :e open_ball X d c r ->
  exists s:set, s :e R /\ Rlt 0 s /\ open_ball X d x s c= open_ball X d c r.
let X d c x r.
assume Hm: metric_on X d.
assume Hc: c :e X.
assume HxX: x :e X.
assume HrR: r :e R.
assume Hrpos: Rlt 0 r.
assume Hxin: x :e open_ball X d c r.
claim Hcenter: x :e open_ball X d x r.
{ exact (center_in_open_ball X d x r Hm HxX Hrpos). }
claim Hex: exists s:set, s :e R /\ Rlt 0 s /\
  open_ball X d x s c= (open_ball X d c r) :/\: (open_ball X d x r).
{ exact (open_ball_refine_intersection X d c x x r r Hm Hc HxX HxX HrR HrR Hrpos Hrpos Hxin Hcenter). }
apply Hex.
let s. assume Hs.
claim Hs1: s :e R /\ Rlt 0 s.
{ exact (andEL (s :e R /\ Rlt 0 s)
               (open_ball X d x s c= (open_ball X d c r) :/\: (open_ball X d x r))
               Hs). }
claim HsR: s :e R.
{ exact (andEL (s :e R) (Rlt 0 s) Hs1). }
claim Hspos: Rlt 0 s.
{ exact (andER (s :e R) (Rlt 0 s) Hs1). }
claim Hsubcap: open_ball X d x s c= (open_ball X d c r) :/\: (open_ball X d x r).
{ exact (andER (s :e R /\ Rlt 0 s)
               (open_ball X d x s c= (open_ball X d c r) :/\: (open_ball X d x r))
               Hs). }
claim Hsub: open_ball X d x s c= open_ball X d c r.
{ exact (Subq_tra (open_ball X d x s) ((open_ball X d c r) :/\: (open_ball X d x r)) (open_ball X d c r)
         Hsubcap (binintersect_Subq_1 (open_ball X d c r) (open_ball X d x r))). }
witness s.
apply andI.
- apply andI.
  + exact HsR.
  + exact Hspos.
- exact Hsub.
Qed.

Definition metric_topology : set -> set -> set := fun X d =>
  generated_topology X (famunion X (fun x => {open_ball X d x r|r :e R, Rlt 0 r})).

(** from 20: open balls form a basis **)
(** LATEX VERSION: In a metric space, open balls form a basis for the metric topology. **)
Theorem open_balls_form_basis : forall X d:set,
  metric_on X d -> basis_on X (famunion X (fun x => {open_ball X d x r|r :e R, Rlt 0 r})).
let X d.
assume Hd: metric_on X d.
prove basis_on X (famunion X (fun x => {open_ball X d x r|r :e R, Rlt 0 r})).
set B := famunion X (fun x0:set => {open_ball X d x0 r|r :e R, Rlt 0 r}).
prove (B c= Power X /\ (forall x :e X, exists b :e B, x :e b)) /\
  (forall b1 :e B, forall b2 :e B, forall x:set,
     x :e b1 -> x :e b2 ->
     exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2).
apply andI.
- (** B c= Power X and cover property **)
  apply andI.
  + (** B c= Power X **)
    let b. assume Hb: b :e B.
    prove b :e Power X.
    apply (famunionE_impred X (fun x0:set => {open_ball X d x0 r|r :e R, Rlt 0 r}) b Hb (b :e Power X)).
    let x0. assume Hx0: x0 :e X.
    assume HbIn: b :e {open_ball X d x0 r|r :e R, Rlt 0 r}.
    apply (ReplSepE_impred R (fun r0:set => Rlt 0 r0) (fun r0:set => open_ball X d x0 r0) b HbIn (b :e Power X)).
    let r0. assume Hr0R: r0 :e R.
    assume Hr0pos: Rlt 0 r0.
    assume Hbeq: b = open_ball X d x0 r0.
    rewrite Hbeq.
    exact (open_ball_in_Power X d x0 r0).
	  + (** cover property **)
	    let x. assume Hx: x :e X.
	    prove exists b :e B, x :e b.
	    witness (open_ball X d x 1).
	    apply andI.
	    - (** b :e B **)
	      claim HballIn: open_ball X d x 1 :e {open_ball X d x r|r :e R, Rlt 0 r}.
	      { exact (ReplSepI R (fun r0:set => Rlt 0 r0) (fun r0:set => open_ball X d x r0) 1 real_1 Rlt_0_1). }
	      exact (famunionI X (fun x0:set => {open_ball X d x0 r|r :e R, Rlt 0 r}) x (open_ball X d x 1) Hx HballIn).
	    - (** x :e b **)
	      exact (center_in_open_ball X d x 1 Hd Hx Rlt_0_1).
- (** refinement property for intersections around a point **)
  let b1. assume Hb1: b1 :e B.
  let b2. assume Hb2: b2 :e B.
  let x. assume Hxb1: x :e b1.
  assume Hxb2: x :e b2.
  prove exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2.
  (** destruct b1 and b2 as open balls; the remaining metric refinement is admitted **)
  apply (famunionE_impred X (fun x0:set => {open_ball X d x0 r|r :e R, Rlt 0 r}) b1 Hb1
         (exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2)).
  let c1. assume Hc1: c1 :e X.
  assume Hb1In: b1 :e {open_ball X d c1 r|r :e R, Rlt 0 r}.
  apply (ReplSepE_impred R (fun r0:set => Rlt 0 r0) (fun r0:set => open_ball X d c1 r0) b1 Hb1In
         (exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2)).
  let r1. assume Hr1R: r1 :e R.
  assume Hr1pos: Rlt 0 r1.
  assume Hb1eq: b1 = open_ball X d c1 r1.
  apply (famunionE_impred X (fun x0:set => {open_ball X d x0 r|r :e R, Rlt 0 r}) b2 Hb2
         (exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2)).
  let c2. assume Hc2: c2 :e X.
  assume Hb2In: b2 :e {open_ball X d c2 r|r :e R, Rlt 0 r}.
  apply (ReplSepE_impred R (fun r0:set => Rlt 0 r0) (fun r0:set => open_ball X d c2 r0) b2 Hb2In
         (exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2)).
  let r2. assume Hr2R: r2 :e R.
  assume Hr2pos: Rlt 0 r2.
  assume Hb2eq: b2 = open_ball X d c2 r2.
  claim Hxball1: x :e open_ball X d c1 r1.
  { rewrite <- Hb1eq. exact Hxb1. }
  claim Hxball2: x :e open_ball X d c2 r2.
  { rewrite <- Hb2eq. exact Hxb2. }
  claim HxX: x :e X.
  { exact (SepE1 X (fun y0:set => Rlt (apply_fun d (c1,y0)) r1) x Hxball1). }
  claim Hexr3: exists r3:set, r3 :e R /\ Rlt 0 r3 /\
    open_ball X d x r3 c= (open_ball X d c1 r1) :/\: (open_ball X d c2 r2).
  { exact (open_ball_refine_intersection X d c1 c2 x r1 r2 Hd Hc1 Hc2 HxX
            Hr1R Hr2R Hr1pos Hr2pos Hxball1 Hxball2). }
  apply Hexr3.
  let r3. assume Hr3: r3 :e R /\ Rlt 0 r3 /\ open_ball X d x r3 c= (open_ball X d c1 r1) :/\: (open_ball X d c2 r2).
  claim Hr3left: r3 :e R /\ Rlt 0 r3.
  { exact (andEL (r3 :e R /\ Rlt 0 r3)
                 (open_ball X d x r3 c= (open_ball X d c1 r1) :/\: (open_ball X d c2 r2))
                 Hr3). }
  claim Hr3R: r3 :e R.
  { exact (andEL (r3 :e R) (Rlt 0 r3) Hr3left). }
  claim Hr3pos: Rlt 0 r3.
  { exact (andER (r3 :e R) (Rlt 0 r3) Hr3left). }
  claim Hr3sub: open_ball X d x r3 c= (open_ball X d c1 r1) :/\: (open_ball X d c2 r2).
  { exact (andER (r3 :e R /\ Rlt 0 r3)
                 (open_ball X d x r3 c= (open_ball X d c1 r1) :/\: (open_ball X d c2 r2))
                 Hr3). }
  witness (open_ball X d x r3).
  prove open_ball X d x r3 :e B /\ (x :e open_ball X d x r3 /\ open_ball X d x r3 c= b1 :/\: b2).
  apply andI.
  - (** open_ball X d x r3 :e B **)
    claim HballIn: open_ball X d x r3 :e {open_ball X d x r|r :e R, Rlt 0 r}.
    { exact (ReplSepI R (fun r0:set => Rlt 0 r0) (fun r0:set => open_ball X d x r0) r3 Hr3R Hr3pos). }
    exact (famunionI X (fun x0:set => {open_ball X d x0 r|r :e R, Rlt 0 r}) x (open_ball X d x r3)
           HxX HballIn).
  - apply andI.
    + (** x :e open_ball X d x r3 **)
      exact (center_in_open_ball X d x r3 Hd HxX Hr3pos).
    + (** subset **)
      rewrite Hb1eq.
      rewrite Hb2eq.
      exact Hr3sub.
Qed.

Theorem metric_topology_is_topology : forall X d:set,
  metric_on X d -> topology_on X (metric_topology X d).
let X d.
assume Hd: metric_on X d.
prove topology_on X (metric_topology X d).
exact (lemma_topology_from_basis X
         (famunion X (fun x => {open_ball X d x r|r :e R, Rlt 0 r}))
         (open_balls_form_basis X d Hd)).
Qed.

(** from 20: metric-induced topology equals generated topology of balls **)
(** LATEX VERSION: The topology induced by a metric is the topology generated by the family of open balls. **)
Theorem metric_topology_generated_by_balls : forall X d:set,
  metric_on X d ->
  generated_topology X (famunion X (fun x => {open_ball X d x r|r :e R, Rlt 0 r})) = metric_topology X d.
let X d.
assume Hd: metric_on X d.
prove generated_topology X (famunion X (fun x => {open_ball X d x r|r :e R, Rlt 0 r})) = metric_topology X d.
(** By definition, metric_topology X d = generated_topology X (famunion X (fun x => {open_ball X d x r|r :e R, Rlt 0 r})) **)
reflexivity.
Qed.

(** Helper: open balls are open in the metric topology **)
Theorem open_ball_open_in_metric_topology : forall X d x r:set,
  metric_on X d -> x :e X -> Rlt 0 r ->
  open_in X (metric_topology X d) (open_ball X d x r).
let X d x r.
assume Hm: metric_on X d.
assume Hx: x :e X.
assume Hr: Rlt 0 r.
set B := famunion X (fun x0 => {open_ball X d x0 rr|rr :e R, Rlt 0 rr}).
claim HBasis: basis_on X B.
{ exact (open_balls_form_basis X d Hm). }
claim Hball_in_rfam: open_ball X d x r :e {open_ball X d x rr|rr :e R, Rlt 0 rr}.
{ claim HrR: r :e R.
  { exact (RltE_right 0 r Hr). }
  exact (ReplSepI R (fun rr:set => Rlt 0 rr) (fun rr:set => open_ball X d x rr) r HrR Hr). }
claim Hball_in_B: open_ball X d x r :e B.
{ exact (famunionI X (fun x0 => {open_ball X d x0 rr|rr :e R, Rlt 0 rr}) x (open_ball X d x r) Hx Hball_in_rfam). }
claim HT: topology_on X (metric_topology X d).
{ exact (metric_topology_is_topology X d Hm). }
prove topology_on X (metric_topology X d) /\ open_ball X d x r :e metric_topology X d.
apply andI.
- exact HT.
- prove open_ball X d x r :e metric_topology X d.
  prove open_ball X d x r :e generated_topology X B.
  exact (generated_topology_contains_basis X B HBasis (open_ball X d x r) Hball_in_B).
Qed.

(** Helper: open balls are elements of the metric topology **)
Theorem open_ball_in_metric_topology : forall X d x r:set,
  metric_on X d -> x :e X -> Rlt 0 r ->
  open_ball X d x r :e metric_topology X d.
let X d x r.
assume Hm: metric_on X d.
assume Hx: x :e X.
assume Hr: Rlt 0 r.
exact (open_in_elem X (metric_topology X d) (open_ball X d x r)
        (open_ball_open_in_metric_topology X d x r Hm Hx Hr)).
Qed.

(** from 21: epsilon-delta continuity in metric spaces **) 
(** LATEX VERSION: A map between metric spaces is continuous exactly when it satisfies the epsilon-delta condition. **)
Theorem metric_epsilon_delta_continuity : forall X dX Y dY f:set,
  metric_on X dX -> metric_on Y dY -> function_on f X Y ->
  (continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f <->
  (forall x0:set, x0 :e X ->
     forall eps:set, eps :e R /\ Rlt 0 eps ->
       exists delta:set, delta :e R /\ Rlt 0 delta /\
         (forall x:set, x :e X ->
            Rlt (apply_fun dX (x,x0)) delta ->
            Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps))).
let X dX Y dY f.
assume HdX: metric_on X dX.
assume HdY: metric_on Y dY.
assume Hf: function_on f X Y.
prove continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f <->
     (forall x0:set, x0 :e X ->
       forall eps:set, eps :e R /\ Rlt 0 eps ->
(** FIXED: Removed extra parentheses around pair argument to dY metric, now apply_fun dY (apply_fun f x, apply_fun f x0), consistent with dX usage. **)
		       exists delta:set, delta :e R /\ Rlt 0 delta /\
				         (forall x:set, x :e X ->
				            Rlt (apply_fun dX (x,x0)) delta ->
				            Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps)).
apply iffI.
- assume Hcont: continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f.
  let x0. assume Hx0: x0 :e X.
  let eps. assume Heps: eps :e R /\ Rlt 0 eps.
  (** Goal: produce delta from openness of preimage of the eps-ball around f(x0). **)
  claim HepsR: eps :e R.
  { exact (andEL (eps :e R) (Rlt 0 eps) Heps). }
  claim Hepspos: Rlt 0 eps.
  { exact (andER (eps :e R) (Rlt 0 eps) Heps). }
  claim Hfx0Y: apply_fun f x0 :e Y.
  { exact (Hf x0 Hx0). }
  set V := open_ball Y dY (apply_fun f x0) eps.
  claim HVtop: V :e metric_topology Y dY.
  { exact (open_ball_in_metric_topology Y dY (apply_fun f x0) eps HdY Hfx0Y Hepspos). }
  set U := preimage_of X f V.
  claim HUtop: U :e metric_topology X dX.
  { exact (continuous_map_preimage X (metric_topology X dX) Y (metric_topology Y dY) f Hcont V HVtop). }
  set Bx := famunion X (fun x0:set => {open_ball X dX x0 r|r :e R, Rlt 0 r}).
  claim HUgen: U :e generated_topology X Bx.
  { exact HUtop. }
  claim Hx0ball: apply_fun f x0 :e V.
  { exact (center_in_open_ball Y dY (apply_fun f x0) eps HdY Hfx0Y Hepspos). }
  claim Hx0U: x0 :e U.
  { exact (SepI X (fun x:set => apply_fun f x :e V) x0 Hx0 Hx0ball). }
  claim HUlocal: forall z :e U, exists b :e Bx, z :e b /\ b c= U.
  { exact (SepE2 (Power X)
                 (fun U0 : set => forall x0 :e U0, exists b :e Bx, x0 :e b /\ b c= U0)
                 U HUgen). }
  apply (HUlocal x0 Hx0U).
  let b. assume Hbpair.
  claim HbBx: b :e Bx.
  { exact (andEL (b :e Bx) (x0 :e b /\ b c= U) Hbpair). }
  claim Hbprop: x0 :e b /\ b c= U.
  { exact (andER (b :e Bx) (x0 :e b /\ b c= U) Hbpair). }
  claim Hx0b: x0 :e b.
  { exact (andEL (x0 :e b) (b c= U) Hbprop). }
  claim HbsubU: b c= U.
  { exact (andER (x0 :e b) (b c= U) Hbprop). }
  (** destruct b as an open ball, then refine to a ball centered at x0 **)
  apply (famunionE_impred X (fun x0:set => {open_ball X dX x0 r|r :e R, Rlt 0 r}) b HbBx
         (exists delta:set, delta :e R /\ Rlt 0 delta /\
           (forall x:set, x :e X ->
              Rlt (apply_fun dX (x,x0)) delta ->
              Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps))).
  let c. assume HcX: c :e X.
  assume HbIn: b :e {open_ball X dX c r|r :e R, Rlt 0 r}.
  apply (ReplSepE_impred R (fun r0:set => Rlt 0 r0) (fun r0:set => open_ball X dX c r0) b HbIn
         (exists delta:set, delta :e R /\ Rlt 0 delta /\
           (forall x:set, x :e X ->
              Rlt (apply_fun dX (x,x0)) delta ->
              Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps))).
  let r. assume HrR: r :e R.
  assume Hrpos: Rlt 0 r.
  assume Hbeq: b = open_ball X dX c r.
  claim Hx0inBall: x0 :e open_ball X dX c r.
  { rewrite <- Hbeq. exact Hx0b. }
  claim Hexdelta: exists delta:set, delta :e R /\ Rlt 0 delta /\ open_ball X dX x0 delta c= open_ball X dX c r.
  { exact (open_ball_refine_center X dX c x0 r HdX HcX Hx0 HrR Hrpos Hx0inBall). }
  apply Hexdelta.
  let delta. assume Hdelta.
  claim Hdelta12: delta :e R /\ Rlt 0 delta.
  { exact (andEL (delta :e R /\ Rlt 0 delta)
                 (open_ball X dX x0 delta c= open_ball X dX c r)
                 Hdelta). }
  claim HdeltaR: delta :e R.
  { exact (andEL (delta :e R) (Rlt 0 delta) Hdelta12). }
  claim Hdeltapos: Rlt 0 delta.
  { exact (andER (delta :e R) (Rlt 0 delta) Hdelta12). }
  claim Hballsub: open_ball X dX x0 delta c= open_ball X dX c r.
  { exact (andER (delta :e R /\ Rlt 0 delta)
                 (open_ball X dX x0 delta c= open_ball X dX c r)
                 Hdelta). }
  claim HballsubU: open_ball X dX x0 delta c= U.
  { claim Hsubb: open_ball X dX x0 delta c= b.
    { rewrite Hbeq.
      exact Hballsub. }
    exact (Subq_tra (open_ball X dX x0 delta) b U Hsubb HbsubU). }
  witness delta.
  apply andI.
  - apply andI.
    + exact HdeltaR.
    + exact Hdeltapos.
  - let x. assume HxX: x :e X.
    assume Hdx: Rlt (apply_fun dX (x,x0)) delta.
    claim Hsym: apply_fun dX (x0,x) = apply_fun dX (x,x0).
    { exact (metric_on_symmetric X dX x0 x HdX Hx0 HxX). }
    claim Hdx': Rlt (apply_fun dX (x0,x)) delta.
    { rewrite Hsym. exact Hdx. }
    claim HxinBall: x :e open_ball X dX x0 delta.
    { exact (open_ballI X dX x0 delta x HxX Hdx'). }
    claim HxinU: x :e U.
    { exact (HballsubU x HxinBall). }
    claim HfxV: apply_fun f x :e V.
    { exact (SepE2 X (fun x0:set => apply_fun f x0 :e V) x HxinU). }
    claim HfxY: apply_fun f x :e Y.
    { exact (Hf x HxX). }
    claim HsymY: apply_fun dY (apply_fun f x, apply_fun f x0) = apply_fun dY (apply_fun f x0, apply_fun f x).
    { exact (metric_on_symmetric Y dY (apply_fun f x) (apply_fun f x0) HdY HfxY Hfx0Y). }
    rewrite HsymY.
    exact (open_ballE2 Y dY (apply_fun f x0) eps (apply_fun f x) HfxV).
- assume Hed: forall x0:set, x0 :e X ->
    forall eps:set, eps :e R /\ Rlt 0 eps ->
      exists delta:set, delta :e R /\ Rlt 0 delta /\
        (forall x:set, x :e X ->
          Rlt (apply_fun dX (x,x0)) delta ->
          Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps).
  (** Goal: show continuity by checking preimages of open balls. **)
  set Bx := famunion X (fun x0:set => {open_ball X dX x0 r|r :e R, Rlt 0 r}).
  set By := famunion Y (fun y0:set => {open_ball Y dY y0 r|r :e R, Rlt 0 r}).
  claim HTx: topology_on X (metric_topology X dX).
  { exact (metric_topology_is_topology X dX HdX). }
  claim HTy: topology_on Y (metric_topology Y dY).
  { exact (metric_topology_is_topology Y dY HdY). }
  prove continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f.
  prove ((topology_on X (metric_topology X dX) /\ topology_on Y (metric_topology Y dY)) /\
         function_on f X Y) /\
        (forall V:set, V :e metric_topology Y dY -> preimage_of X f V :e metric_topology X dX).
  apply andI.
  - apply andI.
    + apply andI.
      * exact HTx.
      * exact HTy.
    + exact Hf.
  - let V. assume HV: V :e metric_topology Y dY.
    prove preimage_of X f V :e metric_topology X dX.
    set U := preimage_of X f V.
    prove U :e generated_topology X Bx.
    (** unpack V as element of generated_topology Y By **)
    claim HVgen: V :e generated_topology Y By.
    { exact HV. }
    claim HVinPow: V :e Power Y.
    { exact (SepE1 (Power Y)
                   (fun V0 : set => forall y0 :e V0, exists b :e By, y0 :e b /\ b c= V0)
                   V HVgen). }
    claim HVsubY: V c= Y.
    { exact (PowerE Y V HVinPow). }
    claim HVlocal: forall y0 :e V, exists b :e By, y0 :e b /\ b c= V.
    { exact (SepE2 (Power Y)
                   (fun V0 : set => forall y0 :e V0, exists b :e By, y0 :e b /\ b c= V0)
                   V HVgen). }
    (** show U belongs to Power X **)
    claim HUsubX: U c= X.
    { let x0. assume Hx0U: x0 :e U.
      exact (SepE1 X (fun x:set => apply_fun f x :e V) x0 Hx0U). }
    claim HUinPow: U :e Power X.
    { exact (PowerI X U HUsubX). }
    (** show the defining local-basis predicate for U **)
    claim HUprop: forall x0 :e U, exists b :e Bx, x0 :e b /\ b c= U.
    { let x0. assume Hx0U: x0 :e U.
      claim Hx0X: x0 :e X.
      { exact (SepE1 X (fun x:set => apply_fun f x :e V) x0 Hx0U). }
      claim Hfx0V: apply_fun f x0 :e V.
      { exact (SepE2 X (fun x:set => apply_fun f x :e V) x0 Hx0U). }
      claim Hfx0Y: apply_fun f x0 :e Y.
      { exact (HVsubY (apply_fun f x0) Hfx0V). }
      apply (HVlocal (apply_fun f x0) Hfx0V).
      let bY. assume HbYpair.
      claim HbYBy: bY :e By.
      { exact (andEL (bY :e By) (apply_fun f x0 :e bY /\ bY c= V) HbYpair). }
      claim HbYprop: apply_fun f x0 :e bY /\ bY c= V.
      { exact (andER (bY :e By) (apply_fun f x0 :e bY /\ bY c= V) HbYpair). }
      claim Hfx0bY: apply_fun f x0 :e bY.
      { exact (andEL (apply_fun f x0 :e bY) (bY c= V) HbYprop). }
      claim HbYsubV: bY c= V.
      { exact (andER (apply_fun f x0 :e bY) (bY c= V) HbYprop). }
      (** destruct bY as an open ball around some center **)
      apply (famunionE_impred Y (fun y0:set => {open_ball Y dY y0 r|r :e R, Rlt 0 r}) bY HbYBy
             (exists b :e Bx, x0 :e b /\ b c= U)).
      let c. assume HcY: c :e Y.
      assume HbYIn: bY :e {open_ball Y dY c r|r :e R, Rlt 0 r}.
      apply (ReplSepE_impred R (fun r0:set => Rlt 0 r0) (fun r0:set => open_ball Y dY c r0) bY HbYIn
             (exists b :e Bx, x0 :e b /\ b c= U)).
      let r. assume HrR: r :e R.
      assume Hrpos: Rlt 0 r.
      assume HbYeq: bY = open_ball Y dY c r.
      claim Hfx0inBall: apply_fun f x0 :e open_ball Y dY c r.
      { rewrite <- HbYeq. exact Hfx0bY. }
      claim Hexeps0: exists eps0:set, eps0 :e R /\ Rlt 0 eps0 /\ open_ball Y dY (apply_fun f x0) eps0 c= open_ball Y dY c r.
      { exact (open_ball_refine_center Y dY c (apply_fun f x0) r HdY HcY Hfx0Y HrR Hrpos Hfx0inBall). }
      apply Hexeps0.
      let eps0. assume Heps0.
      claim Heps0_12: eps0 :e R /\ Rlt 0 eps0.
      { exact (andEL (eps0 :e R /\ Rlt 0 eps0)
                     (open_ball Y dY (apply_fun f x0) eps0 c= open_ball Y dY c r)
                     Heps0). }
      claim Heps0R: eps0 :e R.
      { exact (andEL (eps0 :e R) (Rlt 0 eps0) Heps0_12). }
      claim Heps0pos: Rlt 0 eps0.
      { exact (andER (eps0 :e R) (Rlt 0 eps0) Heps0_12). }
      claim HballYsub: open_ball Y dY (apply_fun f x0) eps0 c= open_ball Y dY c r.
      { exact (andER (eps0 :e R /\ Rlt 0 eps0)
                     (open_ball Y dY (apply_fun f x0) eps0 c= open_ball Y dY c r)
                     Heps0). }
      claim HballYsubV: open_ball Y dY (apply_fun f x0) eps0 c= V.
      { claim HsubbY: open_ball Y dY (apply_fun f x0) eps0 c= bY.
        { rewrite HbYeq.
          exact HballYsub. }
        exact (Subq_tra (open_ball Y dY (apply_fun f x0) eps0) bY V HsubbY HbYsubV). }
      (** apply epsilon-delta hypothesis at x0 with eps0 **)
      apply (Hed x0 Hx0X eps0 (andI (eps0 :e R) (Rlt 0 eps0) Heps0R Heps0pos)).
      let delta. assume Hdelta.
      claim Hdelta12: delta :e R /\ Rlt 0 delta.
      { exact (andEL (delta :e R /\ Rlt 0 delta)
                     (forall x:set, x :e X ->
                       Rlt (apply_fun dX (x,x0)) delta ->
                       Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps0)
                     Hdelta). }
      claim HdeltaR: delta :e R.
      { exact (andEL (delta :e R) (Rlt 0 delta) Hdelta12). }
      claim Hdeltapos: Rlt 0 delta.
      { exact (andER (delta :e R) (Rlt 0 delta) Hdelta12). }
      claim HdeltaImp: forall x:set, x :e X ->
        Rlt (apply_fun dX (x,x0)) delta ->
        Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps0.
      { exact (andER (delta :e R /\ Rlt 0 delta)
                     (forall x:set, x :e X ->
                       Rlt (apply_fun dX (x,x0)) delta ->
                       Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps0)
                     Hdelta). }
      (** choose b = open_ball centered at x0 with radius delta **)
      witness (open_ball X dX x0 delta).
      apply andI.
      - (** membership in Bx **)
        claim HballIn: open_ball X dX x0 delta :e {open_ball X dX x0 r|r :e R, Rlt 0 r}.
        { exact (ReplSepI R (fun r0:set => Rlt 0 r0) (fun r0:set => open_ball X dX x0 r0) delta HdeltaR Hdeltapos). }
        exact (famunionI X (fun x1:set => {open_ball X dX x1 r|r :e R, Rlt 0 r}) x0 (open_ball X dX x0 delta) Hx0X HballIn).
      - apply andI.
        + (** x0 in its delta-ball **)
          exact (center_in_open_ball X dX x0 delta HdX Hx0X Hdeltapos).
        + (** delta-ball subset U **)
          let x. assume Hxin: x :e open_ball X dX x0 delta.
          claim HxX: x :e X.
          { exact (open_ballE1 X dX x0 delta x Hxin). }
          claim HsymX: apply_fun dX (x,x0) = apply_fun dX (x0,x).
          { exact (metric_on_symmetric X dX x x0 HdX HxX Hx0X). }
          claim Hdx0x: Rlt (apply_fun dX (x0,x)) delta.
          { exact (open_ballE2 X dX x0 delta x Hxin). }
          claim Hdx: Rlt (apply_fun dX (x,x0)) delta.
          { rewrite HsymX. exact Hdx0x. }
          claim HfyY: apply_fun f x :e Y.
          { exact (Hf x HxX). }
          claim Hdy: Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps0.
          { exact (HdeltaImp x HxX Hdx). }
          claim HsymY: apply_fun dY (apply_fun f x0, apply_fun f x) = apply_fun dY (apply_fun f x, apply_fun f x0).
          { exact (metric_on_symmetric Y dY (apply_fun f x0) (apply_fun f x) HdY Hfx0Y HfyY). }
          claim Hdy': Rlt (apply_fun dY (apply_fun f x0, apply_fun f x)) eps0.
          { rewrite HsymY. exact Hdy. }
          claim HfxBall: apply_fun f x :e open_ball Y dY (apply_fun f x0) eps0.
          { exact (open_ballI Y dY (apply_fun f x0) eps0 (apply_fun f x) HfyY Hdy'). }
          claim HfxV: apply_fun f x :e V.
          { exact (HballYsubV (apply_fun f x) HfxBall). }
          exact (SepI X (fun x1:set => apply_fun f x1 :e V) x HxX HfxV).
    }
    exact (SepI (Power X)
                (fun U0:set => forall x0 :e U0, exists b :e Bx, x0 :e b /\ b c= U0)
                U HUinPow HUprop).
Qed.

(** sequences as functions from omega **) 
Definition sequence_in : set -> set -> prop := fun seq A => function_on seq omega A.
Definition sequence_on : set -> set -> prop := fun seq A => function_on seq omega A.
Definition converges_to : set -> set -> set -> set -> prop :=
  fun X Tx seq x =>
    topology_on X Tx /\ sequence_on seq X /\ x :e X /\
    forall U:set, U :e Tx -> x :e U ->
      exists N:set, N :e omega /\
        forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U.

(** Helper: extract topology_on from converges_to **)
Theorem converges_to_topology : forall X Tx seq x:set,
  converges_to X Tx seq x -> topology_on X Tx.
let X Tx seq x.
assume H: converges_to X Tx seq x.
claim H123: (topology_on X Tx /\ sequence_on seq X) /\ x :e X.
{ exact (andEL ((topology_on X Tx /\ sequence_on seq X) /\ x :e X)
               (forall U:set, U :e Tx -> x :e U ->
                 exists N:set, N :e omega /\
                   forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U)
               H). }
claim H12: topology_on X Tx /\ sequence_on seq X.
{ exact (andEL (topology_on X Tx /\ sequence_on seq X) (x :e X) H123). }
exact (andEL (topology_on X Tx) (sequence_on seq X) H12).
Qed.

(** Helper: extract sequence_on from converges_to **)
Theorem converges_to_sequence_on : forall X Tx seq x:set,
  converges_to X Tx seq x -> sequence_on seq X.
let X Tx seq x.
assume H: converges_to X Tx seq x.
claim H123: (topology_on X Tx /\ sequence_on seq X) /\ x :e X.
{ exact (andEL ((topology_on X Tx /\ sequence_on seq X) /\ x :e X)
               (forall U:set, U :e Tx -> x :e U ->
                 exists N:set, N :e omega /\
                   forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U)
               H). }
claim H12: topology_on X Tx /\ sequence_on seq X.
{ exact (andEL (topology_on X Tx /\ sequence_on seq X) (x :e X) H123). }
exact (andER (topology_on X Tx) (sequence_on seq X) H12).
Qed.

(** Helper: extract x in X from converges_to **)
Theorem converges_to_point_in_X : forall X Tx seq x:set,
  converges_to X Tx seq x -> x :e X.
let X Tx seq x.
assume H: converges_to X Tx seq x.
claim H123: (topology_on X Tx /\ sequence_on seq X) /\ x :e X.
{ exact (andEL ((topology_on X Tx /\ sequence_on seq X) /\ x :e X)
               (forall U:set, U :e Tx -> x :e U ->
                 exists N:set, N :e omega /\
                   forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U)
               H). }
exact (andER (topology_on X Tx /\ sequence_on seq X) (x :e X) H123).
Qed.

(** Helper: extract neighborhood condition from converges_to **)
Theorem converges_to_neighborhoods : forall X Tx seq x:set,
  converges_to X Tx seq x ->
  forall U:set, U :e Tx -> x :e U ->
    exists N:set, N :e omega /\
      forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U.
let X Tx seq x.
assume H: converges_to X Tx seq x.
exact (andER ((topology_on X Tx /\ sequence_on seq X) /\ x :e X)
             (forall U:set, U :e Tx -> x :e U ->
               exists N:set, N :e omega /\
                 forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U)
             H).
Qed.
(** map a sequence seq by a function f, giving the composed sequence n  f(seq(n)) **)
Definition map_sequence : set -> set -> set := fun f seq => compose_fun omega seq f.

(** image of a set U under a function f **)
Definition image_of : set -> set -> set := fun f U => Repl U (fun x => apply_fun f x).
Definition function_sequence_value : set -> set -> set -> set :=
  fun f_seq n x => apply_fun (apply_fun f_seq n) x.

(** Helper: image is monotone under inclusion **)
(** LATEX VERSION: If U subset V then f(U) subset f(V). **)
Theorem image_of_mono : forall f U V:set,
  U c= V ->
  image_of f U c= image_of f V.
let f U V.
assume HUV: U c= V.
let y. assume Hy: y :e image_of f U.
prove y :e image_of f V.
apply (ReplE_impred U (fun x:set => apply_fun f x) y Hy).
let x. assume HxU: x :e U.
assume Hyx: y = apply_fun f x.
claim HxV: x :e V.
{ exact (HUV x HxU). }
rewrite Hyx.
exact (ReplI V (fun x0:set => apply_fun f x0) x HxV).
Qed.

(** Helper: image under a function_on map stays in the codomain **)
(** LATEX VERSION: If f maps X to Y and U subset X then f(U) subset Y. **)
Theorem image_of_sub_codomain : forall f X Y U:set,
  function_on f X Y ->
  U c= X ->
  image_of f U c= Y.
let f X Y U.
assume Hfun: function_on f X Y.
assume HUX: U c= X.
let y. assume Hy: y :e image_of f U.
prove y :e Y.
apply (ReplE_impred U (fun x:set => apply_fun f x) y Hy).
let x. assume HxU: x :e U.
assume Hyx: y = apply_fun f x.
claim HxX: x :e X.
{ exact (HUX x HxU). }
claim HfxY: apply_fun f x :e Y.
{ exact (Hfun x HxX). }
rewrite Hyx.
exact HfxY.
Qed.

(** Helper: image of Empty **)
(** LATEX VERSION: f(Empty) = Empty. **)
Theorem image_of_Empty : forall f:set,
  image_of f Empty = Empty.
let f.
apply set_ext.
- let y. assume Hy: y :e image_of f Empty.
  apply (ReplE_impred Empty (fun x:set => apply_fun f x) y Hy).
  let x. assume HxE: x :e Empty.
  assume Hyx: y = apply_fun f x.
  apply FalseE.
  exact ((EmptyE x) HxE).
- let y. assume Hy: y :e Empty.
  apply FalseE.
  exact ((EmptyE y) Hy).
Qed.

(** Helper: image of binary union **)
(** LATEX VERSION: f(U union V) = f(U) union f(V). **)
Theorem image_of_binunion : forall f U V:set,
  image_of f (U :\/: V) = (image_of f U) :\/: (image_of f V).
let f U V.
apply set_ext.
- let y. assume Hy: y :e image_of f (U :\/: V).
  prove y :e (image_of f U) :\/: (image_of f V).
  apply (ReplE_impred (U :\/: V) (fun x:set => apply_fun f x) y Hy).
  let x. assume HxUV: x :e U :\/: V.
  assume Hyx: y = apply_fun f x.
  apply (binunionE U V x HxUV).
  * assume HxU: x :e U.
    rewrite Hyx.
    apply binunionI1.
    exact (ReplI U (fun x0:set => apply_fun f x0) x HxU).
  * assume HxV: x :e V.
    rewrite Hyx.
    apply binunionI2.
    exact (ReplI V (fun x0:set => apply_fun f x0) x HxV).
- let y. assume Hy: y :e (image_of f U) :\/: (image_of f V).
  prove y :e image_of f (U :\/: V).
  apply (binunionE (image_of f U) (image_of f V) y Hy).
	  * assume HyU: y :e image_of f U.
	    apply (ReplE_impred U (fun x:set => apply_fun f x) y HyU).
	    let x. assume HxU: x :e U.
	    assume Hyx: y = apply_fun f x.
	    rewrite Hyx.
	    exact (ReplI (U :\/: V) (fun x0:set => apply_fun f x0) x (binunionI1 U V x HxU)).
	  * assume HyV: y :e image_of f V.
	    apply (ReplE_impred V (fun x:set => apply_fun f x) y HyV).
	    let x. assume HxV: x :e V.
	    assume Hyx: y = apply_fun f x.
	    rewrite Hyx.
	    exact (ReplI (U :\/: V) (fun x0:set => apply_fun f x0) x (binunionI2 U V x HxV)).
Qed.

(** Helper: image of union of a family **)
(** LATEX VERSION: f(Union Fam) equals Union of images f(U) for U in Fam. **)
Theorem image_of_Union : forall f Fam:set,
  image_of f (Union Fam) = Union {image_of f U|U :e Fam}.
let f Fam.
apply set_ext.
- let y. assume Hy: y :e image_of f (Union Fam).
  prove y :e Union {image_of f U|U :e Fam}.
  apply (ReplE_impred (Union Fam) (fun x:set => apply_fun f x) y Hy).
  let x. assume HxU: x :e Union Fam.
  assume Hyx: y = apply_fun f x.
  apply (UnionE_impred Fam x HxU).
  let U. assume HxUin: x :e U.
  assume HUFam: U :e Fam.
  claim HyImU: y :e image_of f U.
  { rewrite Hyx.
    exact (ReplI U (fun x0:set => apply_fun f x0) x HxUin). }
  exact (UnionI {image_of f U0|U0 :e Fam} y (image_of f U) HyImU
                (ReplI Fam (fun U0:set => image_of f U0) U HUFam)).
- let y. assume Hy: y :e Union {image_of f U|U :e Fam}.
  prove y :e image_of f (Union Fam).
  apply (UnionE_impred {image_of f U|U :e Fam} y Hy).
  let W. assume HyW: y :e W.
  assume HW: W :e {image_of f U|U :e Fam}.
  apply (ReplE_impred Fam (fun U0:set => image_of f U0) W HW).
  let U. assume HUFam: U :e Fam.
  assume HWU: W = image_of f U.
  claim HyImU: y :e image_of f U.
  { rewrite <- HWU.
    exact HyW. }
  apply (ReplE_impred U (fun x:set => apply_fun f x) y HyImU).
  let x. assume HxU: x :e U.
  assume Hyx: y = apply_fun f x.
  rewrite Hyx.
  exact (ReplI (Union Fam) (fun x0:set => apply_fun f x0) x (UnionI Fam x U HxU HUFam)).
Qed.

(** Helper: image of a set under composition **)
(** LATEX VERSION: If U subset X then (g o f)(U) equals g(f(U)). **)
Theorem image_of_compose_fun : forall X f g U:set,
  U c= X ->
  image_of (compose_fun X f g) U = image_of g (image_of f U).
let X f g U.
assume HUX: U c= X.
apply set_ext.
- let y. assume Hy: y :e image_of (compose_fun X f g) U.
  prove y :e image_of g (image_of f U).
  apply (ReplE_impred U (fun x:set => apply_fun (compose_fun X f g) x) y Hy).
  let x. assume HxU: x :e U.
  assume Hyx: y = apply_fun (compose_fun X f g) x.
  claim HxX: x :e X.
  { exact (HUX x HxU). }
  claim Hcomp: apply_fun (compose_fun X f g) x = apply_fun g (apply_fun f x).
  { exact (compose_fun_apply X f g x HxX). }
  claim Hycomp: y = apply_fun g (apply_fun f x).
  { rewrite Hyx.
    rewrite Hcomp.
    reflexivity. }
  claim HfxIm: apply_fun f x :e image_of f U.
  { exact (ReplI U (fun x0:set => apply_fun f x0) x HxU). }
  rewrite Hycomp.
  exact (ReplI (image_of f U) (fun u:set => apply_fun g u) (apply_fun f x) HfxIm).
- let y. assume Hy: y :e image_of g (image_of f U).
  prove y :e image_of (compose_fun X f g) U.
  apply (ReplE_impred (image_of f U) (fun u:set => apply_fun g u) y Hy).
  let u. assume Hu: u :e image_of f U.
  assume Hyu: y = apply_fun g u.
  apply (ReplE_impred U (fun x:set => apply_fun f x) u Hu).
  let x. assume HxU: x :e U.
  assume Hux: u = apply_fun f x.
  claim HxX: x :e X.
  { exact (HUX x HxU). }
  claim Hcomp: apply_fun (compose_fun X f g) x = apply_fun g (apply_fun f x).
  { exact (compose_fun_apply X f g x HxX). }
  claim Hycomp: y = apply_fun (compose_fun X f g) x.
  { rewrite Hyu.
    rewrite Hux.
    rewrite <- Hcomp.
    reflexivity. }
  rewrite Hycomp.
  exact (ReplI U (fun x0:set => apply_fun (compose_fun X f g) x0) x HxU).
Qed.

(** FIXED: Removed extra parentheses around pair argument to d metric. **)
Definition sequence_converges_metric : set -> set -> set -> set -> prop :=
  fun X d seq x =>
    metric_on X d /\ sequence_on seq X /\ x :e X /\
    forall eps:set, eps :e R /\ Rlt 0 eps ->
      exists N:set, N :e omega /\
        forall n:set, n :e omega -> N c= n ->
          Rlt (apply_fun d (apply_fun seq n, x)) eps.

(** Helper: extract metric_on from sequence_converges_metric **)
Theorem sequence_converges_metric_metric_on : forall X d seq x:set,
  sequence_converges_metric X d seq x -> metric_on X d.
let X d seq x.
assume H: sequence_converges_metric X d seq x.
claim H123: (metric_on X d /\ sequence_on seq X) /\ x :e X.
{ exact (andEL ((metric_on X d /\ sequence_on seq X) /\ x :e X)
               (forall eps:set, eps :e R /\ Rlt 0 eps ->
                 exists N:set, N :e omega /\
                   forall n:set, n :e omega -> N c= n ->
                     Rlt (apply_fun d (apply_fun seq n, x)) eps)
               H). }
claim H12: metric_on X d /\ sequence_on seq X.
{ exact (andEL (metric_on X d /\ sequence_on seq X) (x :e X) H123). }
exact (andEL (metric_on X d) (sequence_on seq X) H12).
Qed.

(** Helper: extract sequence_on from sequence_converges_metric **)
Theorem sequence_converges_metric_sequence_on : forall X d seq x:set,
  sequence_converges_metric X d seq x -> sequence_on seq X.
let X d seq x.
assume H: sequence_converges_metric X d seq x.
claim H123: (metric_on X d /\ sequence_on seq X) /\ x :e X.
{ exact (andEL ((metric_on X d /\ sequence_on seq X) /\ x :e X)
               (forall eps:set, eps :e R /\ Rlt 0 eps ->
                 exists N:set, N :e omega /\
                   forall n:set, n :e omega -> N c= n ->
                     Rlt (apply_fun d (apply_fun seq n, x)) eps)
               H). }
claim H12: metric_on X d /\ sequence_on seq X.
{ exact (andEL (metric_on X d /\ sequence_on seq X) (x :e X) H123). }
exact (andER (metric_on X d) (sequence_on seq X) H12).
Qed.

(** Helper: extract x in X from sequence_converges_metric **)
Theorem sequence_converges_metric_point_in_X : forall X d seq x:set,
  sequence_converges_metric X d seq x -> x :e X.
let X d seq x.
assume H: sequence_converges_metric X d seq x.
claim H123: (metric_on X d /\ sequence_on seq X) /\ x :e X.
{ exact (andEL ((metric_on X d /\ sequence_on seq X) /\ x :e X)
               (forall eps:set, eps :e R /\ Rlt 0 eps ->
                 exists N:set, N :e omega /\
                   forall n:set, n :e omega -> N c= n ->
                     Rlt (apply_fun d (apply_fun seq n, x)) eps)
               H). }
exact (andER (metric_on X d /\ sequence_on seq X) (x :e X) H123).
Qed.

(** Helper: extract the eps condition from sequence_converges_metric **)
Theorem sequence_converges_metric_eps : forall X d seq x:set,
  sequence_converges_metric X d seq x ->
  forall eps:set, eps :e R /\ Rlt 0 eps ->
    exists N:set, N :e omega /\
      forall n:set, n :e omega -> N c= n ->
        Rlt (apply_fun d (apply_fun seq n, x)) eps.
let X d seq x.
assume H: sequence_converges_metric X d seq x.
exact (andER ((metric_on X d /\ sequence_on seq X) /\ x :e X)
             (forall eps:set, eps :e R /\ Rlt 0 eps ->
               exists N:set, N :e omega /\
                 forall n:set, n :e omega -> N c= n ->
                   Rlt (apply_fun d (apply_fun seq n, x)) eps)
             H).
Qed.

(** from 21: uniqueness of limits in metric spaces **) 
(** LATEX VERSION: In a metric space, a convergent sequence has at most one limit. **)
(** helper: function evaluation as graph lookup **) 
Theorem metric_limits_unique : forall X d seq x y:set,
  metric_on X d ->
  sequence_on seq X ->
  sequence_converges_metric X d seq x ->
  sequence_converges_metric X d seq y ->
  x = y.
let X d seq x y.
assume Hd: metric_on X d.
assume Hseq: sequence_on seq X.
assume Hx: sequence_converges_metric X d seq x.
assume Hy: sequence_converges_metric X d seq y.
prove x = y.
apply xm (x = y).
- exact (fun H => H).
- assume Hneq: ~(x = y).
  prove False.
  claim HxX: x :e X.
  { exact (sequence_converges_metric_point_in_X X d seq x Hx). }
  claim HyX: y :e X.
  { exact (sequence_converges_metric_point_in_X X d seq y Hy). }
  claim Hfun: function_on d (setprod X X) R.
  { exact (metric_on_function_on X d Hd). }
  claim HxyIn: (x,y) :e setprod X X.
  { exact (tuple_2_setprod X X x HxX y HyX). }
  claim HdxyR: apply_fun d (x,y) :e R.
  { exact (Hfun (x,y) HxyIn). }
  claim HdxyS: SNo (apply_fun d (x,y)).
  { exact (real_SNo (apply_fun d (x,y)) HdxyR). }
  claim HdxyNe0: ~(apply_fun d (x,y) = 0).
  { assume H0: apply_fun d (x,y) = 0.
    apply Hneq.
    exact (metric_on_zero_eq X d x y Hd HxX HyX H0). }
  claim HdxyPos: Rlt 0 (apply_fun d (x,y)).
  { apply (SNoLt_trichotomy_or_impred 0 (apply_fun d (x,y)) SNo_0 HdxyS
           (Rlt 0 (apply_fun d (x,y)))).
    - assume H0lt: 0 < apply_fun d (x,y).
      exact (RltI 0 (apply_fun d (x,y)) real_0 HdxyR H0lt).
    - assume Heq: 0 = apply_fun d (x,y).
      prove False.
      claim H0eq: apply_fun d (x,y) = 0.
      { rewrite <- Heq. reflexivity. }
      exact (HdxyNe0 H0eq).
    - assume Hlt0: apply_fun d (x,y) < 0.
      prove False.
      claim HltR: Rlt (apply_fun d (x,y)) 0.
      { exact (RltI (apply_fun d (x,y)) 0 HdxyR real_0 Hlt0). }
      exact ((metric_on_nonneg X d x y Hd HxX HyX) HltR). }
  claim HexN: exists N :e omega, eps_ N < apply_fun d (x,y).
  { exact (exists_eps_lt_pos (apply_fun d (x,y)) HdxyR HdxyPos). }
  apply HexN.
  let N. assume HNpair.
  claim HNomega: N :e omega.
  { exact (andEL (N :e omega) (eps_ N < apply_fun d (x,y)) HNpair). }
  claim HepsNlt: eps_ N < apply_fun d (x,y).
  { exact (andER (N :e omega) (eps_ N < apply_fun d (x,y)) HNpair). }
  claim HNnat: nat_p N.
  { exact (omega_nat_p N HNomega). }
  claim HsuccOmega: ordsucc N :e omega.
  { exact (omega_ordsucc N HNomega). }
  claim HepsR: eps_ (ordsucc N) :e R.
  { exact (SNoS_omega_real (eps_ (ordsucc N))
           (SNo_eps_SNoS_omega (ordsucc N) HsuccOmega)). }
  claim HepsS: SNo (eps_ (ordsucc N)).
  { exact (SNo_eps_ (ordsucc N) HsuccOmega). }
  claim H0lt_eps: 0 < eps_ (ordsucc N).
  { exact (SNo_eps_pos (ordsucc N) HsuccOmega). }
  claim HepsPos: Rlt 0 (eps_ (ordsucc N)).
  { exact (RltI 0 (eps_ (ordsucc N)) real_0 HepsR H0lt_eps). }
  claim HexNx: exists Nx:set, Nx :e omega /\
    forall n:set, n :e omega -> Nx c= n ->
      Rlt (apply_fun d (apply_fun seq n, x)) (eps_ (ordsucc N)).
  { exact (sequence_converges_metric_eps X d seq x Hx (eps_ (ordsucc N))
           (andI (eps_ (ordsucc N) :e R) (Rlt 0 (eps_ (ordsucc N))) HepsR HepsPos)). }
  claim HexNy: exists Ny:set, Ny :e omega /\
    forall n:set, n :e omega -> Ny c= n ->
      Rlt (apply_fun d (apply_fun seq n, y)) (eps_ (ordsucc N)).
  { exact (sequence_converges_metric_eps X d seq y Hy (eps_ (ordsucc N))
           (andI (eps_ (ordsucc N) :e R) (Rlt 0 (eps_ (ordsucc N))) HepsR HepsPos)). }
  apply HexNx.
  let Nx. assume HNxpair.
  apply HexNy.
  let Ny. assume HNypair.
  claim HNxomega: Nx :e omega.
  { exact (andEL (Nx :e omega)
                 (forall n:set, n :e omega -> Nx c= n ->
                   Rlt (apply_fun d (apply_fun seq n, x)) (eps_ (ordsucc N)))
                 HNxpair). }
  claim HNxprop: forall n:set, n :e omega -> Nx c= n ->
    Rlt (apply_fun d (apply_fun seq n, x)) (eps_ (ordsucc N)).
  { exact (andER (Nx :e omega)
                 (forall n:set, n :e omega -> Nx c= n ->
                   Rlt (apply_fun d (apply_fun seq n, x)) (eps_ (ordsucc N)))
                 HNxpair). }
  claim HNyomega: Ny :e omega.
  { exact (andEL (Ny :e omega)
                 (forall n:set, n :e omega -> Ny c= n ->
                   Rlt (apply_fun d (apply_fun seq n, y)) (eps_ (ordsucc N)))
                 HNypair). }
  claim HNyprop: forall n:set, n :e omega -> Ny c= n ->
    Rlt (apply_fun d (apply_fun seq n, y)) (eps_ (ordsucc N)).
  { exact (andER (Ny :e omega)
                 (forall n:set, n :e omega -> Ny c= n ->
                   Rlt (apply_fun d (apply_fun seq n, y)) (eps_ (ordsucc N)))
                 HNypair). }
  set n0 := Nx :\/: Ny.
  claim Hn0omega: n0 :e omega.
  { exact (omega_binunion Nx Ny HNxomega HNyomega). }
  claim HNxsub: Nx c= n0.
  { exact (binunion_Subq_1 Nx Ny). }
  claim HNysub: Ny c= n0.
  { exact (binunion_Subq_2 Nx Ny). }
  claim Hdx0: Rlt (apply_fun d (apply_fun seq n0, x)) (eps_ (ordsucc N)).
  { exact (HNxprop n0 Hn0omega HNxsub). }
  claim Hdy0: Rlt (apply_fun d (apply_fun seq n0, y)) (eps_ (ordsucc N)).
  { exact (HNyprop n0 Hn0omega HNysub). }
  claim Hseqfun: function_on seq omega X.
  { exact Hseq. }
  claim Hseqn0X: apply_fun seq n0 :e X.
  { exact (Hseqfun n0 Hn0omega). }
  claim HsymX: apply_fun d (x, apply_fun seq n0) = apply_fun d (apply_fun seq n0, x).
  { exact (metric_on_symmetric X d x (apply_fun seq n0) Hd HxX Hseqn0X). }
  claim Hdx: Rlt (apply_fun d (x, apply_fun seq n0)) (eps_ (ordsucc N)).
  { rewrite HsymX. exact Hdx0. }
  set a := apply_fun d (x, apply_fun seq n0).
  set b := apply_fun d (apply_fun seq n0, y).
  claim Hxn0In: (x, apply_fun seq n0) :e setprod X X.
  { exact (tuple_2_setprod X X x HxX (apply_fun seq n0) Hseqn0X). }
  claim Hn0yIn: (apply_fun seq n0, y) :e setprod X X.
  { exact (tuple_2_setprod X X (apply_fun seq n0) Hseqn0X y HyX). }
  claim HaR: a :e R.
  { exact (Hfun (x, apply_fun seq n0) Hxn0In). }
  claim HbR: b :e R.
  { exact (Hfun (apply_fun seq n0, y) Hn0yIn). }
  claim HaS: SNo a.
  { exact (real_SNo a HaR). }
  claim HbS: SNo b.
  { exact (real_SNo b HbR). }
  claim Haxlt: a < eps_ (ordsucc N).
  { exact (RltE_lt a (eps_ (ordsucc N)) Hdx). }
  claim Hbylt: b < eps_ (ordsucc N).
  { exact (RltE_lt b (eps_ (ordsucc N)) Hdy0). }
  claim Hstep1: add_SNo a b < add_SNo a (eps_ (ordsucc N)).
  { exact (add_SNo_Lt2 a b (eps_ (ordsucc N)) HaS HbS HepsS Hbylt). }
  claim Hstep2raw: add_SNo (eps_ (ordsucc N)) a < add_SNo (eps_ (ordsucc N)) (eps_ (ordsucc N)).
  { exact (add_SNo_Lt2 (eps_ (ordsucc N)) a (eps_ (ordsucc N)) HepsS HaS HepsS Haxlt). }
  claim Hcom: add_SNo (eps_ (ordsucc N)) a = add_SNo a (eps_ (ordsucc N)).
  { exact (add_SNo_com (eps_ (ordsucc N)) a HepsS HaS). }
  claim Hstep2: add_SNo a (eps_ (ordsucc N)) < add_SNo (eps_ (ordsucc N)) (eps_ (ordsucc N)).
  { rewrite <- Hcom at 1.
    exact Hstep2raw. }
  claim Hsumlt_eps2: add_SNo a b < add_SNo (eps_ (ordsucc N)) (eps_ (ordsucc N)).
  { exact (SNoLt_tra (add_SNo a b) (add_SNo a (eps_ (ordsucc N)))
           (add_SNo (eps_ (ordsucc N)) (eps_ (ordsucc N)))
           (SNo_add_SNo a b HaS HbS)
           (SNo_add_SNo a (eps_ (ordsucc N)) HaS HepsS)
           (SNo_add_SNo (eps_ (ordsucc N)) (eps_ (ordsucc N)) HepsS HepsS)
           Hstep1 Hstep2). }
  claim HepsHalf: add_SNo (eps_ (ordsucc N)) (eps_ (ordsucc N)) = eps_ N.
  { exact (eps_ordsucc_half_add N HNnat). }
  claim HsumS: SNo (add_SNo a b).
  { exact (SNo_add_SNo a b HaS HbS). }
  claim HepsNR: eps_ N :e R.
  { exact (SNoS_omega_real (eps_ N) (SNo_eps_SNoS_omega N HNomega)). }
  claim HepsNS: SNo (eps_ N).
  { exact (real_SNo (eps_ N) HepsNR). }
  claim Hsumlt_epsN: add_SNo a b < eps_ N.
  { rewrite <- HepsHalf.
    exact Hsumlt_eps2. }
  claim Hsumlt_dxy: add_SNo a b < apply_fun d (x,y).
  { exact (SNoLt_tra (add_SNo a b) (eps_ N) (apply_fun d (x,y))
           HsumS HepsNS HdxyS Hsumlt_epsN HepsNlt). }
  claim HsumR: add_SNo a b :e R.
  { exact (real_add_SNo a HaR b HbR). }
  claim HsumltR: Rlt (add_SNo a b) (apply_fun d (x,y)).
  { exact (RltI (add_SNo a b) (apply_fun d (x,y)) HsumR HdxyR Hsumlt_dxy). }
  claim Htri: ~(Rlt (add_SNo a b) (apply_fun d (x,y))).
  { exact (metric_on_triangle X d x (apply_fun seq n0) y Hd HxX Hseqn0X HyX). }
  exact (Htri HsumltR).
Qed.

(** uniform convergence of function sequences between metric spaces **) 
Definition uniform_convergence_functions :
  set -> set -> set -> set -> set -> set -> prop :=
  fun X dX Y dY f_seq f =>
    metric_on X dX /\ metric_on Y dY /\
    function_on f_seq omega (function_space X Y) /\ function_on f X Y /\
    (forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y) /\
(** FIXED: Removed extra parentheses around pair argument to dY metric. **)
    forall eps:set, eps :e R /\ Rlt 0 eps ->
      exists N:set, N :e omega /\
        forall n:set, n :e omega -> N c= n ->
          forall x:set, x :e X ->
            Rlt (apply_fun dY (apply_fun (apply_fun f_seq n) x, apply_fun f x)) eps.

(** Helper: extract metric_on X dX from uniform_convergence_functions **)
Theorem uniform_convergence_functions_metric_on_X : forall X dX Y dY f_seq f:set,
  uniform_convergence_functions X dX Y dY f_seq f -> metric_on X dX.
let X dX Y dY f_seq f.
assume H: uniform_convergence_functions X dX Y dY f_seq f.
claim HABCDE: ((((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y)) /\
                function_on f X Y) /\
               (forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y)).
{ exact (andEL ((((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y)) /\
                  function_on f X Y) /\
                 (forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y))
               (forall eps:set, eps :e R /\ Rlt 0 eps ->
                 exists N:set, N :e omega /\
                   forall n:set, n :e omega -> N c= n ->
                     forall x:set, x :e X ->
                       Rlt (apply_fun dY (apply_fun (apply_fun f_seq n) x, apply_fun f x)) eps)
               H). }
claim HABCD: (((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y)) /\
              function_on f X Y).
{ exact (andEL (((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y)) /\
                function_on f X Y)
               (forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y)
               HABCDE). }
claim HAB: metric_on X dX /\ metric_on Y dY.
{ exact (andEL (metric_on X dX /\ metric_on Y dY)
               (function_on f_seq omega (function_space X Y))
               (andEL (metric_on X dX /\ metric_on Y dY /\ function_on f_seq omega (function_space X Y))
                      (function_on f X Y)
                      HABCD)). }
exact (andEL (metric_on X dX) (metric_on Y dY) HAB).
Qed.

(** Helper: extract metric_on Y dY from uniform_convergence_functions **)
Theorem uniform_convergence_functions_metric_on_Y : forall X dX Y dY f_seq f:set,
  uniform_convergence_functions X dX Y dY f_seq f -> metric_on Y dY.
let X dX Y dY f_seq f.
assume H: uniform_convergence_functions X dX Y dY f_seq f.
claim HABCDE: ((((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y)) /\
                function_on f X Y) /\
               (forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y)).
{ exact (andEL ((((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y)) /\
                  function_on f X Y) /\
                 (forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y))
               (forall eps:set, eps :e R /\ Rlt 0 eps ->
                 exists N:set, N :e omega /\
                   forall n:set, n :e omega -> N c= n ->
                     forall x:set, x :e X ->
                       Rlt (apply_fun dY (apply_fun (apply_fun f_seq n) x, apply_fun f x)) eps)
               H). }
claim HABCD: (((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y)) /\
              function_on f X Y).
{ exact (andEL (((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y)) /\
                function_on f X Y)
               (forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y)
               HABCDE). }
claim HAB: metric_on X dX /\ metric_on Y dY.
{ exact (andEL (metric_on X dX /\ metric_on Y dY)
               (function_on f_seq omega (function_space X Y))
               (andEL (metric_on X dX /\ metric_on Y dY /\ function_on f_seq omega (function_space X Y))
                      (function_on f X Y)
                      HABCD)). }
exact (andER (metric_on X dX) (metric_on Y dY) HAB).
Qed.

(** Helper: extract function_on f_seq omega (function_space X Y) from uniform_convergence_functions **)
Theorem uniform_convergence_functions_fseq : forall X dX Y dY f_seq f:set,
  uniform_convergence_functions X dX Y dY f_seq f ->
  function_on f_seq omega (function_space X Y).
let X dX Y dY f_seq f.
assume H: uniform_convergence_functions X dX Y dY f_seq f.
claim HABCDE: ((((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y)) /\
                function_on f X Y) /\
               (forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y)).
{ exact (andEL ((((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y)) /\
                  function_on f X Y) /\
                 (forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y))
               (forall eps:set, eps :e R /\ Rlt 0 eps ->
                 exists N:set, N :e omega /\
                   forall n:set, n :e omega -> N c= n ->
                     forall x:set, x :e X ->
                       Rlt (apply_fun dY (apply_fun (apply_fun f_seq n) x, apply_fun f x)) eps)
               H). }
claim HABCD: (((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y)) /\
              function_on f X Y).
{ exact (andEL (((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y)) /\
                function_on f X Y)
               (forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y)
               HABCDE). }
exact (andER (metric_on X dX /\ metric_on Y dY)
             (function_on f_seq omega (function_space X Y))
             (andEL (metric_on X dX /\ metric_on Y dY /\ function_on f_seq omega (function_space X Y))
                    (function_on f X Y)
                    HABCD)).
Qed.

(** Helper: extract function_on f X Y from uniform_convergence_functions **)
Theorem uniform_convergence_functions_f : forall X dX Y dY f_seq f:set,
  uniform_convergence_functions X dX Y dY f_seq f -> function_on f X Y.
let X dX Y dY f_seq f.
assume H: uniform_convergence_functions X dX Y dY f_seq f.
claim HABCDE: ((((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y)) /\
                function_on f X Y) /\
               (forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y)).
{ exact (andEL ((((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y)) /\
                  function_on f X Y) /\
                 (forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y))
               (forall eps:set, eps :e R /\ Rlt 0 eps ->
                 exists N:set, N :e omega /\
                   forall n:set, n :e omega -> N c= n ->
                     forall x:set, x :e X ->
                       Rlt (apply_fun dY (apply_fun (apply_fun f_seq n) x, apply_fun f x)) eps)
               H). }
claim HABCD: (((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y)) /\
              function_on f X Y).
{ exact (andEL (((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y)) /\
                function_on f X Y)
               (forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y)
               HABCDE). }
exact (andER ((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y))
             (function_on f X Y)
             HABCD).
Qed.

(** Helper: extract pointwise function_on for f_seq n from uniform_convergence_functions **)
Theorem uniform_convergence_functions_pointwise : forall X dX Y dY f_seq f:set,
  uniform_convergence_functions X dX Y dY f_seq f ->
  forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y.
let X dX Y dY f_seq f.
assume H: uniform_convergence_functions X dX Y dY f_seq f.
claim HABCDE: ((((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y)) /\
                function_on f X Y) /\
               (forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y)).
{ exact (andEL ((((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y)) /\
                  function_on f X Y) /\
                 (forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y))
               (forall eps:set, eps :e R /\ Rlt 0 eps ->
                 exists N:set, N :e omega /\
                   forall n:set, n :e omega -> N c= n ->
                     forall x:set, x :e X ->
                       Rlt (apply_fun dY (apply_fun (apply_fun f_seq n) x, apply_fun f x)) eps)
               H). }
exact (andER (((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y)) /\
              function_on f X Y)
             (forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y)
             HABCDE).
Qed.

(** Helper: extract the eps condition from uniform_convergence_functions **)
Theorem uniform_convergence_functions_eps : forall X dX Y dY f_seq f:set,
  uniform_convergence_functions X dX Y dY f_seq f ->
  forall eps:set, eps :e R /\ Rlt 0 eps ->
    exists N:set, N :e omega /\
      forall n:set, n :e omega -> N c= n ->
        forall x:set, x :e X ->
          Rlt (apply_fun dY (apply_fun (apply_fun f_seq n) x, apply_fun f x)) eps.
let X dX Y dY f_seq f.
assume H: uniform_convergence_functions X dX Y dY f_seq f.
exact (andER ((((metric_on X dX /\ metric_on Y dY) /\ function_on f_seq omega (function_space X Y)) /\
               function_on f X Y) /\
              (forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y))
             (forall eps:set, eps :e R /\ Rlt 0 eps ->
               exists N:set, N :e omega /\
                 forall n:set, n :e omega -> N c= n ->
                   forall x:set, x :e X ->
                     Rlt (apply_fun dY (apply_fun (apply_fun f_seq n) x, apply_fun f x)) eps)
             H).
Qed.

(** helper: transitivity of Rle **) 
Theorem Rle_tra : forall a b c:set, Rle a b -> Rle b c -> Rle a c.
let a b c.
assume Hab: Rle a b.
assume Hbc: Rle b c.
apply (RleI a c (RleE_left a b Hab) (RleE_right b c Hbc)).
assume Hca: Rlt c a.
claim HaR: a :e R.
{ exact (RleE_left a b Hab). }
claim HbR: b :e R.
{ exact (RleE_right a b Hab). }
claim HcR: c :e R.
{ exact (RltE_left c a Hca). }
claim HaS: SNo a.
{ exact (real_SNo a HaR). }
claim HbS: SNo b.
{ exact (real_SNo b HbR). }
claim HcS: SNo c.
{ exact (real_SNo c HcR). }
claim Hncb: ~(Rlt c b).
{ exact (RleE_nlt b c Hbc). }
apply (SNoLt_trichotomy_or_impred c b HcS HbS False).
- assume Hcltb: c < b.
  prove False.
  claim Hcb: Rlt c b.
  { exact (RltI c b HcR HbR Hcltb). }
  exact (Hncb Hcb).
- assume Hceq: c = b.
  prove False.
  claim Hba: Rlt b a.
  { rewrite <- Hceq. exact Hca. }
  exact ((RleE_nlt a b Hab) Hba).
- assume Hbltc: b < c.
  prove False.
  claim HcaS: c < a.
  { exact (RltE_lt c a Hca). }
  claim Hbalt: b < a.
  { exact (SNoLt_tra b c a HbS HcS HaS Hbltc HcaS). }
  claim Hba: Rlt b a.
  { exact (RltI b a HbR HaR Hbalt). }
  exact ((RleE_nlt a b Hab) Hba).
Qed.

(** helper: monotonicity of add_SNo in Rle form (right argument) **) 
Theorem Rle_add_SNo_2 : forall x y z:set,
  x :e R -> y :e R -> z :e R ->
  Rle y z -> Rle (add_SNo x y) (add_SNo x z).
let x y z.
assume HxR: x :e R.
assume HyR: y :e R.
assume HzR: z :e R.
assume Hyz: Rle y z.
claim HxS: SNo x.
{ exact (real_SNo x HxR). }
claim HyS: SNo y.
{ exact (real_SNo y HyR). }
claim HzS: SNo z.
{ exact (real_SNo z HzR). }
claim HxyR: add_SNo x y :e R.
{ exact (real_add_SNo x HxR y HyR). }
claim HxzR: add_SNo x z :e R.
{ exact (real_add_SNo x HxR z HzR). }
apply (RleI (add_SNo x y) (add_SNo x z) HxyR HxzR).
assume Hlt: Rlt (add_SNo x z) (add_SNo x y).
claim HltS: add_SNo x z < add_SNo x y.
{ exact (RltE_lt (add_SNo x z) (add_SNo x y) Hlt). }
claim Hzly: z < y.
{ exact (add_SNo_Lt2_cancel x z y HxS HzS HyS HltS). }
claim Hzy: Rlt z y.
{ exact (RltI z y HzR HyR Hzly). }
exact ((RleE_nlt y z Hyz) Hzy).
Qed.

(** from 21: uniform limit theorem placeholder **) 
(** LATEX VERSION: Uniform limit of continuous functions between metric spaces is continuous. **)
Theorem uniform_limit_of_continuous_is_continuous :
  forall X dX Y dY f_seq f:set,
    metric_on X dX -> metric_on Y dY ->
    function_on f_seq omega (function_space X Y) ->
    (forall n:set, n :e omega -> continuous_map X (metric_topology X dX) Y (metric_topology Y dY) (apply_fun f_seq n)) ->
    uniform_convergence_functions X dX Y dY f_seq f ->
    continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f.
let X dX Y dY f_seq f.
assume HdX: metric_on X dX.
assume HdY: metric_on Y dY.
assume Hfseq: function_on f_seq omega (function_space X Y).
assume Hcont: forall n:set, n :e omega -> continuous_map X (metric_topology X dX) Y (metric_topology Y dY) (apply_fun f_seq n).
assume Hunif: uniform_convergence_functions X dX Y dY f_seq f.
prove continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f.
claim Hf: function_on f X Y.
{ exact (uniform_convergence_functions_f X dX Y dY f_seq f Hunif). }
claim Hed: forall x0:set, x0 :e X ->
  forall eps:set, eps :e R /\ Rlt 0 eps ->
    exists delta:set, delta :e R /\ Rlt 0 delta /\
      (forall x:set, x :e X ->
        Rlt (apply_fun dX (x,x0)) delta ->
        Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps).
{ let x0. assume Hx0X: x0 :e X.
  let eps. assume Heps: eps :e R /\ Rlt 0 eps.
  claim HepsR: eps :e R.
  { exact (andEL (eps :e R) (Rlt 0 eps) Heps). }
  claim Hepspos: Rlt 0 eps.
  { exact (andER (eps :e R) (Rlt 0 eps) Heps). }
  (** choose N0 with eps_ N0 < eps and set eta := eps_ (ordsucc (ordsucc N0)) **)
  claim HexN0: exists N0 :e omega, eps_ N0 < eps.
  { exact (exists_eps_lt_pos eps HepsR Hepspos). }
  apply HexN0.
  let N0. assume HN0pair.
  claim HN0omega: N0 :e omega.
  { exact (andEL (N0 :e omega) (eps_ N0 < eps) HN0pair). }
  claim HepsN0lt: eps_ N0 < eps.
  { exact (andER (N0 :e omega) (eps_ N0 < eps) HN0pair). }
  claim HN0nat: nat_p N0.
  { exact (omega_nat_p N0 HN0omega). }
  claim Hsucc0: ordsucc N0 :e omega.
  { exact (omega_ordsucc N0 HN0omega). }
  claim Hsucc1: ordsucc (ordsucc N0) :e omega.
  { exact (omega_ordsucc (ordsucc N0) Hsucc0). }
  set eta := eps_ (ordsucc (ordsucc N0)).
  claim HetaR: eta :e R.
  { exact (SNoS_omega_real eta (SNo_eps_SNoS_omega (ordsucc (ordsucc N0)) Hsucc1)). }
  claim HetaS: SNo eta.
  { exact (SNo_eps_ (ordsucc (ordsucc N0)) Hsucc1). }
  claim H0lt_eta: 0 < eta.
  { exact (SNo_eps_pos (ordsucc (ordsucc N0)) Hsucc1). }
  claim HetaPos: Rlt 0 eta.
  { exact (RltI 0 eta real_0 HetaR H0lt_eta). }
  (** uniform convergence bound with eps = eta **)
  claim HexNu: exists Nu:set, Nu :e omega /\
    forall n:set, n :e omega -> Nu c= n ->
      forall x:set, x :e X ->
        Rlt (apply_fun dY (apply_fun (apply_fun f_seq n) x, apply_fun f x)) eta.
  { exact (uniform_convergence_functions_eps X dX Y dY f_seq f Hunif eta (andI (eta :e R) (Rlt 0 eta) HetaR HetaPos)). }
  apply HexNu.
  let Nu. assume HNupair.
  claim HNuomega: Nu :e omega.
  { exact (andEL (Nu :e omega)
                 (forall n:set, n :e omega -> Nu c= n ->
                   forall x:set, x :e X ->
                     Rlt (apply_fun dY (apply_fun (apply_fun f_seq n) x, apply_fun f x)) eta)
                 HNupair). }
  claim HNuprop: forall n:set, n :e omega -> Nu c= n ->
    forall x:set, x :e X ->
      Rlt (apply_fun dY (apply_fun (apply_fun f_seq n) x, apply_fun f x)) eta.
  { exact (andER (Nu :e omega)
                 (forall n:set, n :e omega -> Nu c= n ->
                   forall x:set, x :e X ->
                     Rlt (apply_fun dY (apply_fun (apply_fun f_seq n) x, apply_fun f x)) eta)
                 HNupair). }
  (** choose fn := f_seq(Nu), use its continuity at x0 with eps = eta **)
  set fn := apply_fun f_seq Nu.
  claim Hfncont: continuous_map X (metric_topology X dX) Y (metric_topology Y dY) fn.
  { exact (Hcont Nu HNuomega). }
  claim Hfn: function_on fn X Y.
  { exact (continuous_map_function_on X (metric_topology X dX) Y (metric_topology Y dY) fn Hfncont). }
  claim Hedfn: forall x1:set, x1 :e X ->
     forall eps1:set, eps1 :e R /\ Rlt 0 eps1 ->
       exists delta1:set, delta1 :e R /\ Rlt 0 delta1 /\
         (forall x2:set, x2 :e X ->
            Rlt (apply_fun dX (x2,x1)) delta1 ->
            Rlt (apply_fun dY (apply_fun fn x2, apply_fun fn x1)) eps1).
  { exact (iffEL
            (continuous_map X (metric_topology X dX) Y (metric_topology Y dY) fn)
            (forall x1:set, x1 :e X ->
              forall eps1:set, eps1 :e R /\ Rlt 0 eps1 ->
                exists delta1:set, delta1 :e R /\ Rlt 0 delta1 /\
                  (forall x2:set, x2 :e X ->
                    Rlt (apply_fun dX (x2,x1)) delta1 ->
                    Rlt (apply_fun dY (apply_fun fn x2, apply_fun fn x1)) eps1))
            (metric_epsilon_delta_continuity X dX Y dY fn HdX HdY Hfn)
            Hfncont). }
  apply (Hedfn x0 Hx0X eta (andI (eta :e R) (Rlt 0 eta) HetaR HetaPos)).
  let delta. assume Hdelta.
  claim Hdelta12: delta :e R /\ Rlt 0 delta.
  { exact (andEL (delta :e R /\ Rlt 0 delta)
                 (forall x2:set, x2 :e X ->
                   Rlt (apply_fun dX (x2,x0)) delta ->
                   Rlt (apply_fun dY (apply_fun fn x2, apply_fun fn x0)) eta)
                 Hdelta). }
  claim HdeltaImp: forall x2:set, x2 :e X ->
    Rlt (apply_fun dX (x2,x0)) delta ->
    Rlt (apply_fun dY (apply_fun fn x2, apply_fun fn x0)) eta.
  { exact (andER (delta :e R /\ Rlt 0 delta)
                 (forall x2:set, x2 :e X ->
                   Rlt (apply_fun dX (x2,x0)) delta ->
                   Rlt (apply_fun dY (apply_fun fn x2, apply_fun fn x0)) eta)
                 Hdelta). }
  witness delta.
  apply andI.
  - exact Hdelta12.
  - let x. assume HxX: x :e X.
    assume Hdx: Rlt (apply_fun dX (x,x0)) delta.
    (** shorthand points in Y **)
    claim HfxY: apply_fun f x :e Y.
    { exact (Hf x HxX). }
    claim Hfx0Y: apply_fun f x0 :e Y.
    { exact (Hf x0 Hx0X). }
    claim HfnxY: apply_fun fn x :e Y.
    { exact (Hfn x HxX). }
    claim Hfnx0Y: apply_fun fn x0 :e Y.
    { exact (Hfn x0 Hx0X). }
    (** bounds from uniform convergence at n=Nu **)
    claim HNuSub: Nu c= Nu.
    { let u. assume Hu: u :e Nu.
      exact Hu. }
    claim Huc1: Rlt (apply_fun dY (apply_fun fn x, apply_fun f x)) eta.
    { exact (HNuprop Nu HNuomega HNuSub x HxX). }
    claim Huc2: Rlt (apply_fun dY (apply_fun fn x0, apply_fun f x0)) eta.
    { exact (HNuprop Nu HNuomega HNuSub x0 Hx0X). }
    (** rewrite these bounds using symmetry to align directions **)
    claim Hsym1: apply_fun dY (apply_fun f x, apply_fun fn x) =
      apply_fun dY (apply_fun fn x, apply_fun f x).
    { exact (metric_on_symmetric Y dY (apply_fun f x) (apply_fun fn x) HdY HfxY HfnxY). }
    claim Hsym2: apply_fun dY (apply_fun fn x0, apply_fun f x0) =
      apply_fun dY (apply_fun f x0, apply_fun fn x0).
    { exact (metric_on_symmetric Y dY (apply_fun fn x0) (apply_fun f x0) HdY Hfnx0Y Hfx0Y). }
    claim Hp: Rlt (apply_fun dY (apply_fun f x, apply_fun fn x)) eta.
    { rewrite Hsym1. exact Huc1. }
    claim Hr: Rlt (apply_fun dY (apply_fun fn x0, apply_fun f x0)) eta.
    { exact Huc2. }
    claim Hq: Rlt (apply_fun dY (apply_fun fn x, apply_fun fn x0)) eta.
    { exact (HdeltaImp x HxX Hdx). }
    (** triangle inequality: d(fx,fx0) <= p + (q + r) **)
    set p := apply_fun dY (apply_fun f x, apply_fun fn x).
    set q := apply_fun dY (apply_fun fn x, apply_fun fn x0).
    set r := apply_fun dY (apply_fun fn x0, apply_fun f x0).
    claim HpR: p :e R.
    { exact ((metric_on_function_on Y dY HdY) (apply_fun f x, apply_fun fn x)
             (tuple_2_setprod Y Y (apply_fun f x) HfxY (apply_fun fn x) HfnxY)). }
    claim HqR: q :e R.
    { exact ((metric_on_function_on Y dY HdY) (apply_fun fn x, apply_fun fn x0)
             (tuple_2_setprod Y Y (apply_fun fn x) HfnxY (apply_fun fn x0) Hfnx0Y)). }
    claim HrR: r :e R.
    { exact ((metric_on_function_on Y dY HdY) (apply_fun fn x0, apply_fun f x0)
             (tuple_2_setprod Y Y (apply_fun fn x0) Hfnx0Y (apply_fun f x0) Hfx0Y)). }
    claim Hpdlt: p < eta.
    { exact (RltE_lt p eta Hp). }
    claim Hqdlt: q < eta.
    { exact (RltE_lt q eta Hq). }
    claim Hrdlt: r < eta.
    { exact (RltE_lt r eta Hr). }
    claim HpS: SNo p.
    { exact (real_SNo p HpR). }
    claim HqS: SNo q.
    { exact (real_SNo q HqR). }
    claim HrS: SNo r.
    { exact (real_SNo r HrR). }
    claim Hsumqr_lt: add_SNo q r < add_SNo eta eta.
    { claim Ht1: add_SNo q r < add_SNo q eta.
      { exact (add_SNo_Lt2 q r eta HqS HrS HetaS Hrdlt). }
      claim Ht2: add_SNo q eta < add_SNo eta eta.
      { exact (add_SNo_Lt1 q eta eta HqS HetaS HetaS Hqdlt). }
      exact (SNoLt_tra (add_SNo q r) (add_SNo q eta) (add_SNo eta eta)
              (SNo_add_SNo q r HqS HrS)
              (SNo_add_SNo q eta HqS HetaS)
              (SNo_add_SNo eta eta HetaS HetaS)
              Ht1 Ht2). }
    claim Hsum_pqr_lt: add_SNo p (add_SNo q r) < add_SNo eta (add_SNo eta eta).
    { claim Ht1: add_SNo p (add_SNo q r) < add_SNo p (add_SNo eta eta).
      { exact (add_SNo_Lt2 p (add_SNo q r) (add_SNo eta eta)
               HpS (SNo_add_SNo q r HqS HrS) (SNo_add_SNo eta eta HetaS HetaS) Hsumqr_lt). }
      claim Ht2: add_SNo p (add_SNo eta eta) < add_SNo eta (add_SNo eta eta).
      { exact (add_SNo_Lt1 p (add_SNo eta eta) eta
               HpS (SNo_add_SNo eta eta HetaS HetaS) HetaS Hpdlt). }
      exact (SNoLt_tra (add_SNo p (add_SNo q r))
              (add_SNo p (add_SNo eta eta))
              (add_SNo eta (add_SNo eta eta))
              (SNo_add_SNo p (add_SNo q r) HpS (SNo_add_SNo q r HqS HrS))
              (SNo_add_SNo p (add_SNo eta eta) HpS (SNo_add_SNo eta eta HetaS HetaS))
              (SNo_add_SNo eta (add_SNo eta eta) HetaS (SNo_add_SNo eta eta HetaS HetaS))
              Ht1 Ht2). }
    (** show add_SNo eta (add_SNo eta eta) < eps via 4 eta = eps_N0 < eps **)
    claim Heta2eq: add_SNo eta eta = eps_ (ordsucc N0).
    { exact (eps_ordsucc_half_add (ordsucc N0) (omega_nat_p (ordsucc N0) Hsucc0)). }
    claim Heta4eq: add_SNo (add_SNo eta eta) (add_SNo eta eta) = eps_ N0.
    { rewrite Heta2eq.
      exact (eps_ordsucc_half_add N0 HN0nat). }
    claim Heta3lt_eta4: add_SNo (add_SNo eta eta) eta < add_SNo (add_SNo eta eta) (add_SNo eta eta).
    { claim Heta_lt_2eta: eta < add_SNo eta eta.
      { claim H0lt: 0 < eta.
        { exact H0lt_eta. }
        claim H0ltR: Rlt 0 eta.
        { exact HetaPos. }
        claim H0ltS: 0 < eta.
        { exact H0lt. }
        claim H0lt2: add_SNo 0 eta < add_SNo eta eta.
        { exact (add_SNo_Lt1 0 eta eta SNo_0 HetaS HetaS H0ltS). }
        rewrite <- (add_SNo_0L eta HetaS) at 1.
        exact H0lt2. }
      exact (add_SNo_Lt2 (add_SNo eta eta) eta (add_SNo eta eta)
             (SNo_add_SNo eta eta HetaS HetaS) HetaS (SNo_add_SNo eta eta HetaS HetaS) Heta_lt_2eta). }
    claim Heta3lt_epsN0: add_SNo (add_SNo eta eta) eta < eps_ N0.
    { rewrite <- Heta4eq.
      exact Heta3lt_eta4. }
    claim HepsN0R: eps_ N0 :e R.
    { exact (SNoS_omega_real (eps_ N0) (SNo_eps_SNoS_omega N0 HN0omega)). }
    claim HepsN0S: SNo (eps_ N0).
    { exact (real_SNo (eps_ N0) HepsN0R). }
    claim Heta3S: SNo (add_SNo (add_SNo eta eta) eta).
    { exact (SNo_add_SNo (add_SNo eta eta) eta (SNo_add_SNo eta eta HetaS HetaS) HetaS). }
    claim Heta3lt_eps: add_SNo (add_SNo eta eta) eta < eps.
    { exact (SNoLt_tra (add_SNo (add_SNo eta eta) eta) (eps_ N0) eps
             Heta3S HepsN0S (real_SNo eps HepsR) Heta3lt_epsN0 HepsN0lt). }
    claim Hsumlt_eps: add_SNo p (add_SNo q r) < eps.
    { claim Hmid: add_SNo eta (add_SNo eta eta) < eps.
      { rewrite (add_SNo_assoc eta eta eta HetaS HetaS HetaS).
        exact Heta3lt_eps. }
      exact (SNoLt_tra (add_SNo p (add_SNo q r))
              (add_SNo eta (add_SNo eta eta))
              eps
              (SNo_add_SNo p (add_SNo q r) HpS (SNo_add_SNo q r HqS HrS))
              (SNo_add_SNo eta (add_SNo eta eta) HetaS (SNo_add_SNo eta eta HetaS HetaS))
              (real_SNo eps HepsR)
              Hsum_pqr_lt Hmid). }
    claim HsumR: add_SNo p (add_SNo q r) :e R.
    { exact (real_add_SNo p HpR (add_SNo q r) (real_add_SNo q HqR r HrR)). }
    claim HsumRlt: Rlt (add_SNo p (add_SNo q r)) eps.
    { exact (RltI (add_SNo p (add_SNo q r)) eps HsumR HepsR Hsumlt_eps). }
    (** Rle bound for the metric distance **)
    claim Htri1: Rle (apply_fun dY (apply_fun f x, apply_fun f x0))
                 (add_SNo p (apply_fun dY (apply_fun fn x, apply_fun f x0))).
    { exact (metric_triangle_Rle Y dY (apply_fun f x) (apply_fun fn x) (apply_fun f x0)
             HdY HfxY HfnxY Hfx0Y). }
    claim Htri2: Rle (apply_fun dY (apply_fun fn x, apply_fun f x0))
                 (add_SNo q r).
    { exact (metric_triangle_Rle Y dY (apply_fun fn x) (apply_fun fn x0) (apply_fun f x0)
             HdY HfnxY Hfnx0Y Hfx0Y). }
    claim Hadd: Rle (add_SNo p (apply_fun dY (apply_fun fn x, apply_fun f x0)))
                  (add_SNo p (add_SNo q r)).
    { exact (Rle_add_SNo_2 p
             (apply_fun dY (apply_fun fn x, apply_fun f x0))
             (add_SNo q r)
             HpR
             ((metric_on_function_on Y dY HdY) (apply_fun fn x, apply_fun f x0)
              (tuple_2_setprod Y Y (apply_fun fn x) HfnxY (apply_fun f x0) Hfx0Y))
             (real_add_SNo q HqR r HrR)
             Htri2). }
    claim Htri3: Rle (apply_fun dY (apply_fun f x, apply_fun f x0))
                 (add_SNo p (add_SNo q r)).
    { exact (Rle_tra (apply_fun dY (apply_fun f x, apply_fun f x0))
             (add_SNo p (apply_fun dY (apply_fun fn x, apply_fun f x0)))
             (add_SNo p (add_SNo q r))
             Htri1 Hadd). }
    exact (Rle_Rlt_tra
            (apply_fun dY (apply_fun f x, apply_fun f x0))
            (add_SNo p (add_SNo q r))
            eps
            Htri3 HsumRlt).
}
exact (iffER
        (continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f)
        (forall x0:set, x0 :e X ->
          forall eps:set, eps :e R /\ Rlt 0 eps ->
            exists delta:set, delta :e R /\ Rlt 0 delta /\
              (forall x:set, x :e X ->
                Rlt (apply_fun dX (x,x0)) delta ->
                Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps))
        (metric_epsilon_delta_continuity X dX Y dY f HdX HdY Hf)
        Hed).
Qed.

(** from 21: convergence of sequences in metric spaces **) 
(** LATEX VERSION: Immediate restatement of convergence (placeholder). **)
Theorem sequence_convergence_metric : forall X d seq x:set,
  sequence_converges_metric X d seq x -> sequence_converges_metric X d seq x.
let X d seq x.
assume H: sequence_converges_metric X d seq x.
prove sequence_converges_metric X d seq x.
exact H.
Qed.

(** from 21: continuity via sequences in metric spaces **)
(** LATEX VERSION: Continuity between metric spaces is equivalent to preserving limits of convergent sequences. **)
(** FIXED: Composed sequence fseq is a function graph {(n, apply_fun f (apply_fun seq n))|n :e omega}, not a Cartesian-product set. **)
Theorem continuity_via_sequences_metric : forall X dX Y dY f:set,
  metric_on X dX -> metric_on Y dY -> function_on f X Y ->
  (continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f <->
    forall seq x:set,
      sequence_converges_metric X dX seq x ->
      sequence_converges_metric Y dY
        ({(n, apply_fun f (apply_fun seq n))|n :e omega})
        (apply_fun f x)).
let X dX Y dY f.
assume HdX: metric_on X dX.
assume HdY: metric_on Y dY.
assume Hf: function_on f X Y.
prove continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f <->
    forall seq x:set,
      sequence_converges_metric X dX seq x ->
      sequence_converges_metric Y dY
        ({(n, apply_fun f (apply_fun seq n))|n :e omega})
        (apply_fun f x).
apply iffI.
- assume Hcont: continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f.
  let seq x.
  assume Hseq: sequence_converges_metric X dX seq x.
  prove sequence_converges_metric Y dY ({(n, apply_fun f (apply_fun seq n))|n :e omega}) (apply_fun f x).
  set seqY := {(n, apply_fun f (apply_fun seq n))|n :e omega}.
  claim Hseqon: sequence_on seq X.
  { exact (sequence_converges_metric_sequence_on X dX seq x Hseq). }
  claim HxX: x :e X.
  { exact (sequence_converges_metric_point_in_X X dX seq x Hseq). }
  claim HfxY: apply_fun f x :e Y.
  { exact (Hf x HxX). }
  claim HseqYfun: function_on seqY omega Y.
  { let n. assume Hnomega: n :e omega.
    claim Hseqfun: function_on seq omega X.
    { exact Hseqon. }
    claim HseqnX: apply_fun seq n :e X.
    { exact (Hseqfun n Hnomega). }
    claim HfseqnY: apply_fun f (apply_fun seq n) :e Y.
    { exact (Hf (apply_fun seq n) HseqnX). }
    claim Hfunc: functional_graph seqY.
    { exact (functional_graph_graph omega (fun n0:set => apply_fun f (apply_fun seq n0))). }
    claim HpairIn: (n, apply_fun f (apply_fun seq n)) :e seqY.
    { exact (ReplI omega (fun n0:set => (n0, apply_fun f (apply_fun seq n0))) n Hnomega). }
    claim Happ: apply_fun seqY n = apply_fun f (apply_fun seq n).
    { exact (functional_graph_apply_fun_eq seqY n (apply_fun f (apply_fun seq n)) Hfunc HpairIn). }
    rewrite Happ.
    exact HfseqnY. }
  claim HseqYon: sequence_on seqY Y.
  { exact HseqYfun. }
  prove sequence_converges_metric Y dY seqY (apply_fun f x).
  prove (metric_on Y dY /\ sequence_on seqY Y) /\ (apply_fun f x :e Y) /\
    forall eps:set, eps :e R /\ Rlt 0 eps ->
      exists N:set, N :e omega /\
        forall n:set, n :e omega -> N c= n ->
          Rlt (apply_fun dY (apply_fun seqY n, apply_fun f x)) eps.
  apply andI.
  - apply andI.
    + apply andI.
      * exact HdY.
      * exact HseqYon.
    + exact HfxY.
  - let eps. assume Heps: eps :e R /\ Rlt 0 eps.
    claim Hedcont: forall x0:set, x0 :e X ->
      forall eps0:set, eps0 :e R /\ Rlt 0 eps0 ->
        exists delta:set, delta :e R /\ Rlt 0 delta /\
          (forall x1:set, x1 :e X ->
            Rlt (apply_fun dX (x1,x0)) delta ->
            Rlt (apply_fun dY (apply_fun f x1, apply_fun f x0)) eps0).
    { exact (iffEL
              (continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f)
              (forall x0:set, x0 :e X ->
                forall eps0:set, eps0 :e R /\ Rlt 0 eps0 ->
                  exists delta:set, delta :e R /\ Rlt 0 delta /\
                    (forall x1:set, x1 :e X ->
                      Rlt (apply_fun dX (x1,x0)) delta ->
                      Rlt (apply_fun dY (apply_fun f x1, apply_fun f x0)) eps0))
              (metric_epsilon_delta_continuity X dX Y dY f HdX HdY Hf)
              Hcont). }
    apply (Hedcont x HxX eps Heps).
    let delta. assume Hdelta.
    claim Hdelta12: delta :e R /\ Rlt 0 delta.
    { exact (andEL (delta :e R /\ Rlt 0 delta)
                   (forall x1:set, x1 :e X ->
                     Rlt (apply_fun dX (x1,x)) delta ->
                     Rlt (apply_fun dY (apply_fun f x1, apply_fun f x)) eps)
                   Hdelta). }
    claim HdeltaImp: forall x1:set, x1 :e X ->
      Rlt (apply_fun dX (x1,x)) delta ->
      Rlt (apply_fun dY (apply_fun f x1, apply_fun f x)) eps.
    { exact (andER (delta :e R /\ Rlt 0 delta)
                   (forall x1:set, x1 :e X ->
                     Rlt (apply_fun dX (x1,x)) delta ->
                     Rlt (apply_fun dY (apply_fun f x1, apply_fun f x)) eps)
                   Hdelta). }
    apply (sequence_converges_metric_eps X dX seq x Hseq delta Hdelta12).
    let N. assume HNpair.
    witness N.
    apply andI.
    - exact (andEL (N :e omega)
                   (forall n:set, n :e omega -> N c= n -> Rlt (apply_fun dX (apply_fun seq n, x)) delta)
                   HNpair).
    - let n. assume Hnomega: n :e omega.
      assume HNsubn: N c= n.
      claim HNprop: forall n0:set, n0 :e omega -> N c= n0 -> Rlt (apply_fun dX (apply_fun seq n0, x)) delta.
      { exact (andER (N :e omega)
                     (forall n0:set, n0 :e omega -> N c= n0 -> Rlt (apply_fun dX (apply_fun seq n0, x)) delta)
                     HNpair). }
      claim Hdx: Rlt (apply_fun dX (apply_fun seq n, x)) delta.
      { exact (HNprop n Hnomega HNsubn). }
      claim Hseqfun: function_on seq omega X.
      { exact Hseqon. }
      claim HseqnX: apply_fun seq n :e X.
      { exact (Hseqfun n Hnomega). }
      claim Hdy: Rlt (apply_fun dY (apply_fun f (apply_fun seq n), apply_fun f x)) eps.
      { exact (HdeltaImp (apply_fun seq n) HseqnX Hdx). }
      claim Hfunc: functional_graph seqY.
      { exact (functional_graph_graph omega (fun n0:set => apply_fun f (apply_fun seq n0))). }
      claim HpairIn: (n, apply_fun f (apply_fun seq n)) :e seqY.
      { exact (ReplI omega (fun n0:set => (n0, apply_fun f (apply_fun seq n0))) n Hnomega). }
      claim Happ: apply_fun seqY n = apply_fun f (apply_fun seq n).
      { exact (functional_graph_apply_fun_eq seqY n (apply_fun f (apply_fun seq n)) Hfunc HpairIn). }
      rewrite Happ.
      exact Hdy.
- assume Hseqcont: forall seq x:set,
    sequence_converges_metric X dX seq x ->
    sequence_converges_metric Y dY ({(n, apply_fun f (apply_fun seq n))|n :e omega}) (apply_fun f x).
  prove continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f.
  claim Hed: forall x0:set, x0 :e X ->
    forall eps:set, eps :e R /\ Rlt 0 eps ->
      exists delta:set, delta :e R /\ Rlt 0 delta /\
        (forall x:set, x :e X ->
          Rlt (apply_fun dX (x,x0)) delta ->
          Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps).
  { let x0. assume Hx0X: x0 :e X.
    let eps. assume Heps: eps :e R /\ Rlt 0 eps.
    apply dneg.
    assume Hno: ~(exists delta:set, delta :e R /\ Rlt 0 delta /\
      (forall x:set, x :e X ->
        Rlt (apply_fun dX (x,x0)) delta ->
        Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps)).
    prove False.
    claim HepsR: eps :e R.
    { exact (andEL (eps :e R) (Rlt 0 eps) Heps). }
    claim Hepspos: Rlt 0 eps.
    { exact (andER (eps :e R) (Rlt 0 eps) Heps). }
    claim Hbad: forall delta:set, delta :e R /\ Rlt 0 delta ->
      exists x:set, x :e X /\ Rlt (apply_fun dX (x,x0)) delta /\
        ~(Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps).
    { let delta. assume Hdelta: delta :e R /\ Rlt 0 delta.
      apply dneg.
      assume Hnobad: ~(exists x:set, x :e X /\ Rlt (apply_fun dX (x,x0)) delta /\
        ~(Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps)).
      prove False.
      apply Hno.
      witness delta.
      apply andI.
      - exact Hdelta.
      - let x. assume HxX: x :e X.
        assume Hdx: Rlt (apply_fun dX (x,x0)) delta.
        apply dneg.
        assume HnRlt: ~(Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps).
        prove False.
        apply Hnobad.
        witness x.
        apply andI.
        - apply andI.
          + exact HxX.
          + exact Hdx.
        - exact HnRlt. }
    set g := fun n:set =>
      Eps_i (fun x:set =>
        x :e X /\
        Rlt (apply_fun dX (x,x0)) (eps_ n) /\
        ~(Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps)).
    set seq := {(n, g n)|n :e omega}.
    claim Hseqfun: function_on seq omega X.
    { claim HgAll: forall n:set, n :e omega -> g n :e X.
      { let n. assume Hnomega: n :e omega.
        claim Hgnreal: eps_ n :e R.
        { exact (SNoS_omega_real (eps_ n) (SNo_eps_SNoS_omega n Hnomega)). }
        claim HgnposS: 0 < eps_ n.
        { exact (SNo_eps_pos n Hnomega). }
        claim Hgnpos: Rlt 0 (eps_ n).
        { exact (RltI 0 (eps_ n) real_0 Hgnreal HgnposS). }
        claim Hexbad: exists x:set, x :e X /\ Rlt (apply_fun dX (x,x0)) (eps_ n) /\
          ~(Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps).
        { exact (Hbad (eps_ n) (andI (eps_ n :e R) (Rlt 0 (eps_ n)) Hgnreal Hgnpos)). }
        claim Hgprop: g n :e X /\ Rlt (apply_fun dX (g n,x0)) (eps_ n) /\
          ~(Rlt (apply_fun dY (apply_fun f (g n), apply_fun f x0)) eps).
        { exact (Eps_i_ex
                  (fun x:set => x :e X /\ Rlt (apply_fun dX (x,x0)) (eps_ n) /\
                    ~(Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps))
                  Hexbad). }
        claim Hg12: g n :e X /\ Rlt (apply_fun dX (g n,x0)) (eps_ n).
        { exact (andEL
                  (g n :e X /\ Rlt (apply_fun dX (g n,x0)) (eps_ n))
                  (~(Rlt (apply_fun dY (apply_fun f (g n), apply_fun f x0)) eps))
                  Hgprop). }
        exact (andEL (g n :e X) (Rlt (apply_fun dX (g n,x0)) (eps_ n)) Hg12). }
      claim Hrng: graph_range_subset seq X.
      { exact (graph_range_subset_graph omega X (fun n0:set => g n0) HgAll). }
      let n. assume Hnomega: n :e omega.
      claim HpairIn: (n, g n) :e seq.
      { exact (ReplI omega (fun n0:set => (n0, g n0)) n Hnomega). }
      claim HpairApp: (n, apply_fun seq n) :e seq.
      { exact (Eps_i_ax (fun y0:set => (n,y0) :e seq) (g n) HpairIn). }
      exact (Hrng n (apply_fun seq n) HpairApp). }
	    claim Hseqconv: sequence_converges_metric X dX seq x0.
	    { prove (metric_on X dX /\ sequence_on seq X) /\ x0 :e X /\
	        forall eps0:set, eps0 :e R /\ Rlt 0 eps0 ->
	          exists N:set, N :e omega /\
	            forall n:set, n :e omega -> N c= n ->
	              Rlt (apply_fun dX (apply_fun seq n, x0)) eps0.
	      apply andI.
	      - apply andI.
	        + apply andI.
	          * exact HdX.
	          * exact Hseqfun.
	        + exact Hx0X.
	      - let eps0. assume Heps0: eps0 :e R /\ Rlt 0 eps0.
	        claim Heps0R: eps0 :e R.
	        { exact (andEL (eps0 :e R) (Rlt 0 eps0) Heps0). }
	        claim Heps0pos: Rlt 0 eps0.
	        { exact (andER (eps0 :e R) (Rlt 0 eps0) Heps0). }
	        claim HexN: exists N :e omega, eps_ N < eps0.
	        { exact (exists_eps_lt_pos eps0 Heps0R Heps0pos). }
	        apply HexN.
	        let N. assume HNpair.
	        claim HNomega: N :e omega.
	        { exact (andEL (N :e omega) (eps_ N < eps0) HNpair). }
	        claim HepsNlt: eps_ N < eps0.
	        { exact (andER (N :e omega) (eps_ N < eps0) HNpair). }
	        claim HepsNR: eps_ N :e R.
	        { exact (SNoS_omega_real (eps_ N) (SNo_eps_SNoS_omega N HNomega)). }
	        claim HepsNltR: Rlt (eps_ N) eps0.
	        { exact (RltI (eps_ N) eps0 HepsNR Heps0R HepsNlt). }
	        witness N.
	        apply andI.
	        + exact HNomega.
	        + let n. assume Hnomega: n :e omega.
	          assume HNsubn: N c= n.
	          claim HepsnR: eps_ n :e R.
	          { exact (SNoS_omega_real (eps_ n) (SNo_eps_SNoS_omega n Hnomega)). }
	          claim HordN: ordinal N.
	          { exact (nat_p_ordinal N (omega_nat_p N HNomega)). }
	          claim Hordn: ordinal n.
	          { exact (nat_p_ordinal n (omega_nat_p n Hnomega)). }
	          claim Hnot_nInN: ~(n :e N).
	          { assume HninN: n :e N.
	            claim Hnn: n :e n.
	            { exact (HNsubn n HninN). }
	            exact ((In_irref n) Hnn). }
	          claim Hfunc: functional_graph seq.
	          { exact (functional_graph_graph omega (fun n0:set => g n0)). }
	          claim HpairIn: (n, g n) :e seq.
	          { exact (ReplI omega (fun n0:set => (n0, g n0)) n Hnomega). }
	          claim Happ: apply_fun seq n = g n.
	          { exact (functional_graph_apply_fun_eq seq n (g n) Hfunc HpairIn). }
	          claim HgnposS: 0 < eps_ n.
	          { exact (SNo_eps_pos n Hnomega). }
	          claim Hgnpos: Rlt 0 (eps_ n).
	          { exact (RltI 0 (eps_ n) real_0 HepsnR HgnposS). }
	          claim Hexbad: exists x:set, x :e X /\ Rlt (apply_fun dX (x,x0)) (eps_ n) /\
	            ~(Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps).
	          { exact (Hbad (eps_ n) (andI (eps_ n :e R) (Rlt 0 (eps_ n)) HepsnR Hgnpos)). }
	          claim Hgprop: g n :e X /\ Rlt (apply_fun dX (g n,x0)) (eps_ n) /\
	            ~(Rlt (apply_fun dY (apply_fun f (g n), apply_fun f x0)) eps).
	          { exact (Eps_i_ex
	                    (fun x:set => x :e X /\ Rlt (apply_fun dX (x,x0)) (eps_ n) /\
	                      ~(Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps))
	                    Hexbad). }
	          claim Hg12: g n :e X /\ Rlt (apply_fun dX (g n,x0)) (eps_ n).
	          { exact (andEL
	                    (g n :e X /\ Rlt (apply_fun dX (g n,x0)) (eps_ n))
	                    (~(Rlt (apply_fun dY (apply_fun f (g n), apply_fun f x0)) eps))
	                    Hgprop). }
	          claim Hdxlt_epsn: Rlt (apply_fun dX (g n, x0)) (eps_ n).
	          { exact (andER (g n :e X) (Rlt (apply_fun dX (g n,x0)) (eps_ n)) Hg12). }
	          claim Hdxlt_epsn2: Rlt (apply_fun dX (apply_fun seq n, x0)) (eps_ n).
	          { rewrite Happ. exact Hdxlt_epsn. }
          claim Hepsnlt_eps0: Rlt (eps_ n) eps0.
          { apply (ordinal_trichotomy_or_impred N n HordN Hordn (Rlt (eps_ n) eps0)).
            - assume HNin: N :e n.
              claim Hepsnlt_epsN: eps_ n < eps_ N.
              { exact (SNo_eps_decr n Hnomega N HNin). }
              claim Hepsnlt_epsNR: Rlt (eps_ n) (eps_ N).
              { exact (RltI (eps_ n) (eps_ N) HepsnR HepsNR Hepsnlt_epsN). }
              exact (Rlt_tra (eps_ n) (eps_ N) eps0 Hepsnlt_epsNR HepsNltR).
            - assume Heq: N = n.
              rewrite <- Heq.
              exact HepsNltR.
            - assume HninN: n :e N.
              apply FalseE.
              prove False.
              exact (Hnot_nInN HninN). }
	          exact (Rlt_tra (apply_fun dX (apply_fun seq n, x0)) (eps_ n) eps0 Hdxlt_epsn2 Hepsnlt_eps0). }
    set seqY := {(n, apply_fun f (apply_fun seq n))|n :e omega}.
    claim Himgconv: sequence_converges_metric Y dY seqY (apply_fun f x0).
    { exact (Hseqcont seq x0 Hseqconv). }
    claim HexNimg: exists N:set, N :e omega /\
      forall n:set, n :e omega -> N c= n ->
        Rlt (apply_fun dY (apply_fun seqY n, apply_fun f x0)) eps.
    { exact (sequence_converges_metric_eps Y dY seqY (apply_fun f x0) Himgconv eps Heps). }
    apply HexNimg.
    let N. assume HNpair.
    claim HNomega: N :e omega.
    { exact (andEL (N :e omega)
                   (forall n:set, n :e omega -> N c= n ->
                     Rlt (apply_fun dY (apply_fun seqY n, apply_fun f x0)) eps)
                   HNpair). }
    claim HNprop: forall n:set, n :e omega -> N c= n ->
      Rlt (apply_fun dY (apply_fun seqY n, apply_fun f x0)) eps.
    { exact (andER (N :e omega)
                   (forall n:set, n :e omega -> N c= n ->
                     Rlt (apply_fun dY (apply_fun seqY n, apply_fun f x0)) eps)
                   HNpair). }
    claim HNsubN: N c= N.
    { exact (Subq_ref N). }
    claim Hdylt: Rlt (apply_fun dY (apply_fun seqY N, apply_fun f x0)) eps.
    { exact (HNprop N HNomega HNsubN). }
    claim HfuncY: functional_graph seqY.
    { exact (functional_graph_graph omega (fun n0:set => apply_fun f (apply_fun seq n0))). }
    claim HpairY: (N, apply_fun f (apply_fun seq N)) :e seqY.
    { exact (ReplI omega (fun n0:set => (n0, apply_fun f (apply_fun seq n0))) N HNomega). }
    claim HappY: apply_fun seqY N = apply_fun f (apply_fun seq N).
    { exact (functional_graph_apply_fun_eq seqY N (apply_fun f (apply_fun seq N)) HfuncY HpairY). }
    claim HfuncX: functional_graph seq.
    { exact (functional_graph_graph omega (fun n0:set => g n0)). }
    claim HpairX: (N, g N) :e seq.
    { exact (ReplI omega (fun n0:set => (n0, g n0)) N HNomega). }
    claim HappX: apply_fun seq N = g N.
    { exact (functional_graph_apply_fun_eq seq N (g N) HfuncX HpairX). }
    claim Hgnreal: eps_ N :e R.
    { exact (SNoS_omega_real (eps_ N) (SNo_eps_SNoS_omega N HNomega)). }
    claim HgnposS: 0 < eps_ N.
    { exact (SNo_eps_pos N HNomega). }
    claim Hgnpos: Rlt 0 (eps_ N).
    { exact (RltI 0 (eps_ N) real_0 Hgnreal HgnposS). }
    claim Hexbad: exists x:set, x :e X /\ Rlt (apply_fun dX (x,x0)) (eps_ N) /\
      ~(Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps).
    { exact (Hbad (eps_ N) (andI (eps_ N :e R) (Rlt 0 (eps_ N)) Hgnreal Hgnpos)). }
    claim Hgprop: g N :e X /\ Rlt (apply_fun dX (g N,x0)) (eps_ N) /\
      ~(Rlt (apply_fun dY (apply_fun f (g N), apply_fun f x0)) eps).
    { exact (Eps_i_ex
              (fun x:set => x :e X /\ Rlt (apply_fun dX (x,x0)) (eps_ N) /\
                ~(Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps))
              Hexbad). }
    claim Hnot: ~(Rlt (apply_fun dY (apply_fun f (g N), apply_fun f x0)) eps).
    { exact (andER
              (g N :e X /\ Rlt (apply_fun dX (g N,x0)) (eps_ N))
              (~(Rlt (apply_fun dY (apply_fun f (g N), apply_fun f x0)) eps))
              Hgprop). }
    claim Hdylt2: Rlt (apply_fun dY (apply_fun f (g N), apply_fun f x0)) eps.
    { claim HeqY: apply_fun seqY N = apply_fun f (g N).
      { rewrite HappY.
        rewrite HappX.
        reflexivity. }
      rewrite <- HeqY at 1.
      exact Hdylt. }
    exact (Hnot Hdylt2). }
  exact (iffER
          (continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f)
          (forall x0:set, x0 :e X ->
            forall eps:set, eps :e R /\ Rlt 0 eps ->
              exists delta:set, delta :e R /\ Rlt 0 delta /\
                (forall x:set, x :e X ->
                  Rlt (apply_fun dX (x,x0)) delta ->
                  Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps))
          (metric_epsilon_delta_continuity X dX Y dY f HdX HdY Hf)
          Hed).
Qed.

(** from 22 Definition: quotient map and quotient topology **) 
(** LATEX VERSION: Quotient topology on Y makes a surjective map f:XY continuous iff preimages of opens in Y are open in X. **)
Definition quotient_topology : set -> set -> set -> set -> set :=
  fun X Tx Y f => {V :e Power Y|{x :e X|apply_fun f x :e V} :e Tx}.

Definition quotient_map : set -> set -> set -> set -> prop := fun X Tx Y f =>
  topology_on X Tx /\
  function_on f X Y /\
  (forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun f x = y).

Theorem quotient_topology_is_topology : forall X Tx Y f:set,
  topology_on X Tx -> quotient_map X Tx Y f ->
  topology_on Y (quotient_topology X Tx Y f).
let X Tx Y f.
assume HTx: topology_on X Tx.
assume Hf: quotient_map X Tx Y f.
prove topology_on Y (quotient_topology X Tx Y f).
set Q := quotient_topology X Tx Y f.
set pre := fun V:set => preimage_of X f V.
prove Q c= Power Y
  /\ Empty :e Q
  /\ Y :e Q
  /\ (forall UFam :e Power Q, Union UFam :e Q)
  /\ (forall U :e Q, forall V :e Q, U :/\: V :e Q).
apply andI.
- apply andI.
  - apply andI.
    - apply andI.
      - (** Q subset Power Y **)
        let V. assume HV: V :e Q.
        exact (SepE1 (Power Y) (fun V0:set => pre V0 :e Tx) V HV).
      - (** Empty in Q **)
        prove Empty :e Q.
        claim HpreE: pre Empty :e Tx.
        { set Epre := pre Empty.
          claim HEsub: Epre c= Empty.
          { let x. assume Hx: x :e Epre.
            prove x :e Empty.
            claim Hxprop: apply_fun f x :e Empty.
            { exact (SepE2 X (fun x0 => apply_fun f x0 :e Empty) x Hx). }
            exact (EmptyE (apply_fun f x) Hxprop (x :e Empty)). }
          claim HEeq: Epre = Empty.
          { exact (Empty_Subq_eq Epre HEsub). }
          rewrite HEeq.
          exact (topology_has_empty X Tx HTx). }
        claim Hpow: Empty :e Power Y.
        { exact (Empty_In_Power Y). }
        exact (SepI (Power Y) (fun V0:set => pre V0 :e Tx) Empty Hpow HpreE).
    - (** Y in Q **)
      prove Y :e Q.
      claim Hf_on: function_on f X Y.
      { exact (andER (topology_on X Tx) (function_on f X Y)
          (andEL (topology_on X Tx /\ function_on f X Y)
            (forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun f x = y) Hf)). }
      claim HpreY: pre Y :e Tx.
      { set Ypre := pre Y.
        claim HYsub: Ypre c= X.
        { let x. assume Hx: x :e Ypre.
          exact (SepE1 X (fun x0 => apply_fun f x0 :e Y) x Hx). }
        claim HXsub: X c= Ypre.
        { let x. assume Hx: x :e X.
          prove x :e Ypre.
	          claim HfxY: apply_fun f x :e Y.
	          { exact (Hf_on x Hx). }
	          exact (SepI X (fun x0 => apply_fun f x0 :e Y) x Hx HfxY). }
        claim HYeq: Ypre = X.
        { apply set_ext.
          - exact HYsub.
          - exact HXsub. }
        rewrite HYeq.
        exact (topology_has_X X Tx HTx). }
      claim Hpow: Y :e Power Y.
      { apply PowerI.
        exact (fun x Hx => Hx). }
      exact (SepI (Power Y) (fun V0:set => pre V0 :e Tx) Y Hpow HpreY).
  - (** Union closure **)
    let UFam. assume HUFam: UFam :e Power Q.
    prove Union UFam :e Q.
    claim HUFamSub: UFam c= Q.
    { exact (PowerE Q UFam HUFam). }
    (** show Union UFam in Power Y **)
    claim HUnionPow: Union UFam :e Power Y.
    { apply PowerI.
      let y. assume Hy: y :e Union UFam.
      prove y :e Y.
      apply (UnionE_impred UFam y Hy).
      let V. assume HyV. assume HVUF.
      claim HVQ: V :e Q.
      { exact (HUFamSub V HVUF). }
      claim HVPow: V :e Power Y.
      { exact (SepE1 (Power Y) (fun V0:set => pre V0 :e Tx) V HVQ). }
      exact (PowerE Y V HVPow y HyV). }
    (** show preimage of Union UFam is open in Tx **)
    claim HpreU: pre (Union UFam) :e Tx.
    { set PUFam := {pre V|V :e UFam}.
      claim HPUFamPow: PUFam :e Power Tx.
      { apply PowerI.
        let W. assume HW: W :e PUFam.
        prove W :e Tx.
        apply (ReplE UFam (fun V:set => pre V) W HW).
        let V. assume HVconj.
        claim HVUF: V :e UFam.
        { exact (andEL (V :e UFam) (W = pre V) HVconj). }
        claim HWeq: W = pre V.
        { exact (andER (V :e UFam) (W = pre V) HVconj). }
        claim HVQ: V :e Q.
        { exact (HUFamSub V HVUF). }
        claim HpreV: pre V :e Tx.
        { exact (SepE2 (Power Y) (fun V0:set => pre V0 :e Tx) V HVQ). }
        rewrite HWeq.
        exact HpreV. }
      (** pre(Union UFam) = Union PUFam **)
      claim Heq: pre (Union UFam) = Union PUFam.
      { apply set_ext.
        - let x. assume Hx: x :e pre (Union UFam).
          prove x :e Union PUFam.
          claim HxX: x :e X.
          { exact (SepE1 X (fun x0 => apply_fun f x0 :e Union UFam) x Hx). }
	          claim HxU: apply_fun f x :e Union UFam.
	          { exact (SepE2 X (fun x0 => apply_fun f x0 :e Union UFam) x Hx). }
	          apply (UnionE_impred UFam (apply_fun f x) HxU).
	          let V. assume HfxV. assume HVUF.
	          claim HxpreV: x :e pre V.
	          { exact (SepI X (fun x0 => apply_fun f x0 :e V) x HxX HfxV). }
	          claim HpreVin: pre V :e PUFam.
	          { exact (ReplI UFam (fun V0:set => pre V0) V HVUF). }
	          exact (UnionI PUFam x (pre V) HxpreV HpreVin).
	        - let x. assume Hx: x :e Union PUFam.
	          prove x :e pre (Union UFam).
	          apply (UnionE_impred PUFam x Hx).
	          let W. assume HxW. assume HWPU.
	          apply (ReplE UFam (fun V:set => pre V) W HWPU).
	          let V. assume HVconj.
	          claim HVUF: V :e UFam.
	          { exact (andEL (V :e UFam) (W = pre V) HVconj). }
          claim HWeq: W = pre V.
          { exact (andER (V :e UFam) (W = pre V) HVconj). }
          claim HxpreV: x :e pre V.
          { rewrite <- HWeq.
            exact HxW. }
          claim HfxV: apply_fun f x :e V.
          { exact (SepE2 X (fun x0 => apply_fun f x0 :e V) x HxpreV). }
	          claim HfxU: apply_fun f x :e Union UFam.
	          { exact (UnionI UFam (apply_fun f x) V HfxV HVUF). }
          claim HxX: x :e X.
          { exact (SepE1 X (fun x0 => apply_fun f x0 :e V) x HxpreV). }
          exact (SepI X (fun x0 => apply_fun f x0 :e Union UFam) x HxX HfxU). }
      rewrite Heq.
      exact (topology_union_axiom X Tx HTx PUFam HPUFamPow). }
    exact (SepI (Power Y) (fun V0:set => pre V0 :e Tx) (Union UFam) HUnionPow HpreU).
- (** binary intersection closure **)
  let U. assume HU: U :e Q.
  let V. assume HV: V :e Q.
  prove U :/\: V :e Q.
  claim HUPow: U :e Power Y.
  { exact (SepE1 (Power Y) (fun V0:set => pre V0 :e Tx) U HU). }
  claim HVPow: V :e Power Y.
  { exact (SepE1 (Power Y) (fun V0:set => pre V0 :e Tx) V HV). }
  claim HpreU: pre U :e Tx.
  { exact (SepE2 (Power Y) (fun V0:set => pre V0 :e Tx) U HU). }
  claim HpreV: pre V :e Tx.
  { exact (SepE2 (Power Y) (fun V0:set => pre V0 :e Tx) V HV). }
  claim HUVPow: U :/\: V :e Power Y.
  { apply PowerI.
    let y. assume Hy: y :e U :/\: V.
    prove y :e Y.
    claim HyU: y :e U.
    { exact (binintersectE1 U V y Hy). }
    exact (PowerE Y U HUPow y HyU). }
  (** pre(UV) = pre(U)  pre(V) **)
  claim Heq: pre (U :/\: V) = pre U :/\: pre V.
  { apply set_ext.
    - let x. assume Hx: x :e pre (U :/\: V).
      prove x :e pre U :/\: pre V.
      claim HxX: x :e X.
      { exact (SepE1 X (fun x0 => apply_fun f x0 :e U :/\: V) x Hx). }
      claim Hfx: apply_fun f x :e U :/\: V.
      { exact (SepE2 X (fun x0 => apply_fun f x0 :e U :/\: V) x Hx). }
      claim HfxU: apply_fun f x :e U.
      { exact (binintersectE1 U V (apply_fun f x) Hfx). }
      claim HfxV: apply_fun f x :e V.
      { exact (binintersectE2 U V (apply_fun f x) Hfx). }
      exact (binintersectI (pre U) (pre V) x
              (SepI X (fun x0 => apply_fun f x0 :e U) x HxX HfxU)
              (SepI X (fun x0 => apply_fun f x0 :e V) x HxX HfxV)).
    - let x. assume Hx: x :e pre U :/\: pre V.
      prove x :e pre (U :/\: V).
      claim HxpreU: x :e pre U.
      { exact (binintersectE1 (pre U) (pre V) x Hx). }
      claim HxpreV: x :e pre V.
      { exact (binintersectE2 (pre U) (pre V) x Hx). }
      claim HxX: x :e X.
      { exact (SepE1 X (fun x0 => apply_fun f x0 :e U) x HxpreU). }
      claim HfxU: apply_fun f x :e U.
      { exact (SepE2 X (fun x0 => apply_fun f x0 :e U) x HxpreU). }
      claim HfxV: apply_fun f x :e V.
      { exact (SepE2 X (fun x0 => apply_fun f x0 :e V) x HxpreV). }
      claim HfxUV: apply_fun f x :e U :/\: V.
      { exact (binintersectI U V (apply_fun f x) HfxU HfxV). }
      exact (SepI X (fun x0 => apply_fun f x0 :e U :/\: V) x HxX HfxUV). }
  claim HpreUV: pre (U :/\: V) :e Tx.
  { rewrite Heq.
    exact (topology_binintersect_closed X Tx (pre U) (pre V) HTx HpreU HpreV). }
  exact (SepI (Power Y) (fun V0:set => pre V0 :e Tx) (U :/\: V) HUVPow HpreUV).
Qed.

(** from 22: universal property of quotient maps **) 
(** LATEX VERSION: Universal property: a quotient map f is continuous into any topology Ty on Y coarser than the quotient topology. **)
Theorem quotient_universal_property : forall X Tx Y Ty f:set,
  quotient_map X Tx Y f -> topology_on Y Ty -> Ty c= quotient_topology X Tx Y f ->
  continuous_map X Tx Y Ty f.
let X Tx Y Ty f.
assume Hf: quotient_map X Tx Y f.
assume HTy: topology_on Y Ty.
assume Hsub: Ty c= quotient_topology X Tx Y f.
prove continuous_map X Tx Y Ty f.
prove topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y /\ forall V:set, V :e Ty -> preimage_of X f V :e Tx.
claim Htopfun : topology_on X Tx /\ function_on f X Y.
{ exact (andEL (topology_on X Tx /\ function_on f X Y)
        (forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun f x = y) Hf). }
claim HTx : topology_on X Tx.
{ exact (andEL (topology_on X Tx) (function_on f X Y) Htopfun). }
claim Hf_on : function_on f X Y.
{ exact (andER (topology_on X Tx) (function_on f X Y) Htopfun). }
apply andI.
- apply andI.
  - apply andI.
    + exact HTx.
    + exact HTy.
  - exact Hf_on.
- let V. assume HV: V :e Ty.
  prove preimage_of X f V :e Tx.
  claim HVQ: V :e quotient_topology X Tx Y f.
  { exact (Hsub V HV). }
  exact (SepE2 (Power Y) (fun V0:set => preimage_of X f V0 :e Tx) V HVQ).
Qed.

(** from 23 Definition: separation of a space **) 
(** LATEX VERSION: A separation of X is a pair of disjoint nonempty open sets whose union is X. **)
Definition separation_of : set -> set -> set -> prop := fun X U V =>
  U :e Power X /\ V :e Power X /\ U :/\: V = Empty /\ U <> Empty /\ V <> Empty /\ U :\/: V = X.

(** Helper: a proper nonempty subset yields a separation by its complement **)
Theorem separation_of_complement : forall X U:set,
  U c= X -> U <> Empty -> U <> X ->
  separation_of X U (X :\: U).
let X U.
assume HUsub: U c= X.
assume HUne: U <> Empty.
assume HUnX: U <> X.
prove separation_of X U (X :\: U).
claim HUpow: U :e Power X.
{ exact (PowerI X U HUsub). }
claim HcompSubX: X :\: U c= X.
{ exact (setminus_Subq X U). }
claim HcompPower: (X :\: U) :e Power X.
{ exact (PowerI X (X :\: U) HcompSubX). }
claim Hdisjoint: U :/\: (X :\: U) = Empty.
{ apply Empty_eq.
  let x. assume Hx: x :e U :/\: (X :\: U).
  apply (binintersectE U (X :\: U) x Hx).
  assume HxU: x :e U.
  assume HxComp: x :e X :\: U.
  apply (setminusE X U x HxComp).
  assume _. assume HxNotU: x /:e U.
  exact (HxNotU HxU). }
claim HcompNe: (X :\: U) <> Empty.
{ assume Heq: X :\: U = Empty.
  claim HUeqX: U = X.
  { apply set_ext.
    - exact HUsub.
    - let x. assume HxX: x :e X.
      apply (xm (x :e U)).
      + assume HxU. exact HxU.
      + assume HxNotU.
        claim Hxcomp: x :e X :\: U.
        { exact (setminusI X U x HxX HxNotU). }
        claim HxEmpty: x :e Empty.
        { rewrite <- Heq. exact Hxcomp. }
        prove x :e U.
        exact (FalseE (EmptyE x HxEmpty) (x :e U)). }
  exact (HUnX HUeqX). }
claim Hunion: U :\/: (X :\: U) = X.
{ apply set_ext.
  - let x. assume Hx: x :e U :\/: (X :\: U).
    apply (binunionE U (X :\: U) x Hx).
    + assume HxU. exact (HUsub x HxU).
    + assume HxComp. exact (setminusE1 X U x HxComp).
  - let x. assume HxX: x :e X.
    apply (xm (x :e U)).
    + assume HxU. exact (binunionI1 U (X :\: U) x HxU).
    + assume HxNotU. exact (binunionI2 U (X :\: U) x (setminusI X U x HxX HxNotU)). }
prove U :e Power X /\ (X :\: U) :e Power X /\ U :/\: (X :\: U) = Empty /\ U <> Empty /\ (X :\: U) <> Empty /\ U :\/: (X :\: U) = X.
(** `separation_of` is left-associative; build the conjunction tree explicitly. **)
apply andI.
- apply andI.
  + apply andI.
    * apply andI.
      { apply andI.
        - exact HUpow.
        - exact HcompPower. }
      { exact Hdisjoint. }
    * exact HUne.
  + exact HcompNe.
- exact Hunion.
Qed.

(** from 23 Definition: connected space **) 
(** LATEX VERSION: X with topology Tx is connected if it admits no separation. **)
Definition connected_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).

(** Helper: extract topology_on from connected_space **)
Theorem connected_space_topology : forall X Tx:set,
  connected_space X Tx -> topology_on X Tx.
let X Tx.
assume H: connected_space X Tx.
exact (andEL (topology_on X Tx)
             (~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V))
             H).
Qed.

(** Helper: extract no-separation property from connected_space **)
Theorem connected_space_no_separation : forall X Tx:set,
  connected_space X Tx -> ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).
let X Tx.
assume H: connected_space X Tx.
exact (andER (topology_on X Tx)
             (~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V))
             H).
Qed.

(** Helper: homeomorphisms preserve connectedness **)
Theorem homeomorphism_preserves_connected : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f ->
  connected_space X Tx ->
  connected_space Y Ty.
let X Tx Y Ty f.
assume Hhom: homeomorphism X Tx Y Ty f.
assume HX: connected_space X Tx.
prove connected_space Y Ty.
prove topology_on Y Ty /\ ~(exists U V:set, U :e Ty /\ V :e Ty /\ separation_of Y U V).
apply andI.
- exact (homeomorphism_topology_right X Tx Y Ty f Hhom).
  - assume HsepY: exists U V:set, U :e Ty /\ V :e Ty /\ separation_of Y U V.
    prove False.
    claim HnoSepX: ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).
  { exact (connected_space_no_separation X Tx HX). }
  claim Hcontf: continuous_map X Tx Y Ty f.
  { exact (andEL (continuous_map X Tx Y Ty f)
                 (exists g:set, continuous_map Y Ty X Tx g /\
                   (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
                   (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y))
                 Hhom). }
  claim Habc: (topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y.
  { exact (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
                 (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
                 Hcontf). }
  claim Hfunf: function_on f X Y.
  { exact (andER (topology_on X Tx /\ topology_on Y Ty)
                 (function_on f X Y)
                 Habc). }
  claim Hpreimg: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
  { exact (andER ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
                 (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
                 Hcontf). }
  claim Hexg:
    exists g:set, continuous_map Y Ty X Tx g /\
      (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
      (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y).
  { exact (andER (continuous_map X Tx Y Ty f)
                 (exists g:set, continuous_map Y Ty X Tx g /\
                   (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
                   (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y))
                 Hhom). }
  apply Hexg.
  let g. assume Hgprop.
  claim Hfg: forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y.
  { exact (andER (continuous_map Y Ty X Tx g /\
                   (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x))
                 (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y)
                 Hgprop). }
  claim Habg:
    continuous_map Y Ty X Tx g /\
      (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x).
  { exact (andEL (continuous_map Y Ty X Tx g /\
                   (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x))
                 (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y)
                 Hgprop). }
  claim Hcontg: continuous_map Y Ty X Tx g.
  { exact (andEL (continuous_map Y Ty X Tx g)
                 (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x)
                 Habg). }
  claim Habcg: (topology_on Y Ty /\ topology_on X Tx) /\ function_on g Y X.
  { exact (andEL ((topology_on Y Ty /\ topology_on X Tx) /\ function_on g Y X)
                 (forall V:set, V :e Tx -> preimage_of Y g V :e Ty)
                 Hcontg). }
  claim Hfung: function_on g Y X.
  { exact (andER (topology_on Y Ty /\ topology_on X Tx)
                 (function_on g Y X)
                 Habcg). }
  apply HsepY.
  let U. assume HexV: exists V:set, U :e Ty /\ V :e Ty /\ separation_of Y U V.
  apply HexV.
  let V. assume HUV: U :e Ty /\ V :e Ty /\ separation_of Y U V.
  set U0 := preimage_of X f U.
  set V0 := preimage_of X f V.
  claim HUVop: U :e Ty /\ V :e Ty.
  { exact (andEL (U :e Ty /\ V :e Ty) (separation_of Y U V) HUV). }
  claim HU_Ty: U :e Ty.
  { exact (andEL (U :e Ty) (V :e Ty) HUVop). }
  claim HV_Ty: V :e Ty.
  { exact (andER (U :e Ty) (V :e Ty) HUVop). }
  claim HsepYUV: separation_of Y U V.
  { exact (andER (U :e Ty /\ V :e Ty) (separation_of Y U V) HUV). }
  claim HU0Tx: U0 :e Tx.
  { exact (Hpreimg U HU_Ty). }
  claim HV0Tx: V0 :e Tx.
  { exact (Hpreimg V HV_Ty). }
  claim HsepXUV: separation_of X U0 V0.
  { prove U0 :e Power X /\ V0 :e Power X /\ U0 :/\: V0 = Empty /\ U0 <> Empty /\ V0 <> Empty /\ U0 :\/: V0 = X.
    claim HsepY0:
      (((U :e Power Y /\ V :e Power Y) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty.
    { exact (andEL ((((U :e Power Y /\ V :e Power Y) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                   (U :\/: V = Y)
                   HsepYUV). }
    claim HcoverY: U :\/: V = Y.
    { exact (andER ((((U :e Power Y /\ V :e Power Y) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                   (U :\/: V = Y)
                   HsepYUV). }
    claim HsepY1: ((U :e Power Y /\ V :e Power Y) /\ U :/\: V = Empty) /\ U <> Empty.
    { exact (andEL (((U :e Power Y /\ V :e Power Y) /\ U :/\: V = Empty) /\ U <> Empty)
                   (V <> Empty)
                   HsepY0). }
    claim HVne: V <> Empty.
    { exact (andER (((U :e Power Y /\ V :e Power Y) /\ U :/\: V = Empty) /\ U <> Empty)
                   (V <> Empty)
                   HsepY0). }
    claim HsepY2: (U :e Power Y /\ V :e Power Y) /\ U :/\: V = Empty.
    { exact (andEL ((U :e Power Y /\ V :e Power Y) /\ U :/\: V = Empty)
                   (U <> Empty)
                   HsepY1). }
    claim HUne: U <> Empty.
    { exact (andER ((U :e Power Y /\ V :e Power Y) /\ U :/\: V = Empty)
                   (U <> Empty)
                   HsepY1). }
    claim HUVpow: U :e Power Y /\ V :e Power Y.
    { exact (andEL (U :e Power Y /\ V :e Power Y)
                   (U :/\: V = Empty)
                   HsepY2). }
    claim HdisjY: U :/\: V = Empty.
    { exact (andER (U :e Power Y /\ V :e Power Y)
                   (U :/\: V = Empty)
                   HsepY2). }
    claim HUpow: U :e Power Y.
    { exact (andEL (U :e Power Y) (V :e Power Y) HUVpow). }
    claim HVpow: V :e Power Y.
    { exact (andER (U :e Power Y) (V :e Power Y) HUVpow). }
    claim HU0subX: U0 c= X.
    { let x. assume Hx: x :e U0.
      exact (SepE1 X (fun x0:set => apply_fun f x0 :e U) x Hx). }
    claim HV0subX: V0 c= X.
    { let x. assume Hx: x :e V0.
      exact (SepE1 X (fun x0:set => apply_fun f x0 :e V) x Hx). }
    claim HU0Pow: U0 :e Power X.
    { exact (PowerI X U0 HU0subX). }
    claim HV0Pow: V0 :e Power X.
    { exact (PowerI X V0 HV0subX). }
    claim Hdisj: U0 :/\: V0 = Empty.
    { rewrite <- (preimage_of_binintersect X f U V).
      rewrite HdisjY.
      exact (preimage_of_Empty X f). }
    claim HU0ne: U0 <> Empty.
    { apply (nonempty_has_element U HUne).
      let y. assume HyU: y :e U.
      claim HUsubY: U c= Y.
      { exact (PowerE Y U HUpow). }
      claim HyY: y :e Y.
      { exact (HUsubY y HyU). }
      claim HgyX: apply_fun g y :e X.
      { exact (Hfung y HyY). }
      claim HfgyU: apply_fun f (apply_fun g y) :e U.
      { rewrite (Hfg y HyY).
        exact HyU. }
      claim HgyPreU: apply_fun g y :e U0.
      { exact (SepI X (fun x0:set => apply_fun f x0 :e U) (apply_fun g y) HgyX HfgyU). }
      exact (elem_implies_nonempty U0 (apply_fun g y) HgyPreU). }
    claim HV0ne: V0 <> Empty.
    { apply (nonempty_has_element V HVne).
      let y. assume HyV: y :e V.
      claim HVsubY: V c= Y.
      { exact (PowerE Y V HVpow). }
      claim HyY: y :e Y.
      { exact (HVsubY y HyV). }
      claim HgyX: apply_fun g y :e X.
      { exact (Hfung y HyY). }
      claim HfgyV: apply_fun f (apply_fun g y) :e V.
      { rewrite (Hfg y HyY).
        exact HyV. }
      claim HgyPreV: apply_fun g y :e V0.
      { exact (SepI X (fun x0:set => apply_fun f x0 :e V) (apply_fun g y) HgyX HfgyV). }
      exact (elem_implies_nonempty V0 (apply_fun g y) HgyPreV). }
    claim Hunion: U0 :\/: V0 = X.
    { rewrite <- (preimage_of_binunion X f U V).
      rewrite HcoverY.
      exact (preimage_of_whole X Y f Hfunf). }
    prove (((((U0 :e Power X /\ V0 :e Power X) /\ U0 :/\: V0 = Empty) /\ U0 <> Empty) /\ V0 <> Empty) /\ U0 :\/: V0 = X).
    apply andI.
    * apply andI.
      { apply andI.
        - apply andI.
          + apply andI.
            { exact HU0Pow. }
            { exact HV0Pow. }
          + exact Hdisj.
        - exact HU0ne. }
      { exact HV0ne. }
    * exact Hunion. }
  apply HnoSepX.
  witness U0.
  witness V0.
  prove U0 :e Tx /\ V0 :e Tx /\ separation_of X U0 V0.
  apply andI.
  - apply andI.
    + exact HU0Tx.
    + exact HV0Tx.
  - exact HsepXUV.
Qed.

(** Helper theorems for connected_iff_no_nontrivial_clopen **)
Theorem clopen_gives_separation : forall X Tx A:set,
  topology_on X Tx -> A <> Empty -> A <> X ->
  open_in X Tx A -> closed_in X Tx A ->
  exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V.
let X Tx A.
assume HTx: topology_on X Tx.
assume HAne: A <> Empty.
assume HAneX: A <> X.
assume HAopen: open_in X Tx A.
assume HAclosed: closed_in X Tx A.
claim HATx: A :e Tx.
{ exact (andER (topology_on X Tx) (A :e Tx) HAopen). }
claim HcompOpen: open_in X Tx (X :\: A).
{ exact (open_of_closed_complement X Tx A HAclosed). }
claim HcompTx: X :\: A :e Tx.
{ exact (andER (topology_on X Tx) ((X :\: A) :e Tx) HcompOpen). }
witness A.
witness (X :\: A).
apply andI.
- apply andI.
  + exact HATx.
  + exact HcompTx.
- prove separation_of X A (X :\: A).
    prove A :e Power X /\ (X :\: A) :e Power X /\ A :/\: (X :\: A) = Empty /\ A <> Empty /\ (X :\: A) <> Empty /\ A :\/: (X :\: A) = X.
    claim HAsubX: A c= X.
    { exact (open_in_subset X Tx A HAopen). }
    claim HApower: A :e Power X.
    { exact (PowerI X A HAsubX). }
    claim HcompSubX: X :\: A c= X.
    { exact (setminus_Subq X A). }
    claim HcompPower: (X :\: A) :e Power X.
    { exact (PowerI X (X :\: A) HcompSubX). }
    claim Hdisjoint: A :/\: (X :\: A) = Empty.
    { apply Empty_eq.
      let x. assume Hx: x :e A :/\: (X :\: A).
      apply (binintersectE A (X :\: A) x Hx).
      assume HxA: x :e A.
      assume HxComp: x :e X :\: A.
      apply (setminusE X A x HxComp).
      assume _. assume HxNotA: x /:e A.
      exact (HxNotA HxA). }
    claim HcompNe: (X :\: A) <> Empty.
    { assume Heq: X :\: A = Empty.
      claim HAeqX: A = X.
      { apply set_ext.
        - exact HAsubX.
        - let x. assume HxX: x :e X.
          apply (xm (x :e A)).
          + assume HxA. exact HxA.
          + assume HxNotA.
            claim Hxcomp: x :e X :\: A.
            { exact (setminusI X A x HxX HxNotA). }
            claim HxEmpty: x :e Empty.
            { rewrite <- Heq. exact Hxcomp. }
            prove x :e A.
            exact (FalseE (EmptyE x HxEmpty) (x :e A)). }
      exact (HAneX HAeqX). }
    claim Hunion: A :\/: (X :\: A) = X.
    { apply set_ext.
      - let x. assume Hx: x :e A :\/: (X :\: A).
        apply (binunionE A (X :\: A) x Hx).
        + assume HxA. exact (HAsubX x HxA).
        + assume HxComp. exact (setminusE1 X A x HxComp).
      - let x. assume HxX: x :e X.
        apply (xm (x :e A)).
        + assume HxA. exact (binunionI1 A (X :\: A) x HxA).
        + assume HxNotA. exact (binunionI2 A (X :\: A) x (setminusI X A x HxX HxNotA)). }
    prove (((((A :e Power X /\ (X :\: A) :e Power X) /\ A :/\: (X :\: A) = Empty) /\ A <> Empty) /\ (X :\: A) <> Empty) /\ A :\/: (X :\: A) = X).
    apply andI.
    * apply andI.
      { apply andI.
        - apply andI.
          + apply andI.
            { exact HApower. }
            { exact HcompPower. }
          + exact Hdisjoint.
        - exact HAne. }
      { exact HcompNe. }
    * exact Hunion.
Qed.

Theorem separation_gives_clopen : forall X Tx U V:set,
  topology_on X Tx ->
  U :e Tx -> V :e Tx -> separation_of X U V ->
  exists A:set, A <> Empty /\ A <> X /\ open_in X Tx A /\ closed_in X Tx A.
let X Tx U V.
assume HTx: topology_on X Tx.
assume HU: U :e Tx.
assume HV: V :e Tx.
assume Hsep: separation_of X U V.
witness U.
prove U <> Empty /\ U <> X /\ open_in X Tx U /\ closed_in X Tx U.
claim H1: (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty.
{ exact (andEL ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
               (U :\/: V = X) Hsep). }
claim H2: ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty.
{ exact (andEL (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty)
               (V <> Empty) H1). }
claim HUne: U <> Empty.
{ exact (andER (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty)) (U <> Empty) H2). }
claim Hunion: U :\/: V = X.
{ exact (andER ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
               (U :\/: V = X) Hsep). }
claim HUneX: U <> X.
{ assume Heq: U = X.
  claim HVempty: V = Empty.
  { apply Empty_eq.
    let x. assume Hx: x :e V.
    claim HxX: x :e X.
    { rewrite <- Hunion. exact (binunionI2 U V x Hx). }
    claim HxU: x :e U.
    { rewrite Heq. exact HxX. }
    claim Hxdisj: x :e U :/\: V.
    { exact (binintersectI U V x HxU Hx). }
    claim Hdisj: U :/\: V = Empty.
    { exact (andER (U :e Power X /\ V :e Power X) (U :/\: V = Empty)
                   (andEL ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty)
                          (U <> Empty) H2)). }
    claim Hfalse: x :e Empty.
    { rewrite <- Hdisj. exact Hxdisj. }
    exact (EmptyE x Hfalse). }
  claim HVne: V <> Empty.
  { exact (andER ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty)) (V <> Empty) H1). }
  exact (HVne HVempty). }
claim HUopen: open_in X Tx U.
{ exact (andI (topology_on X Tx) (U :e Tx) HTx HU). }
claim Hdisj: U :/\: V = Empty.
{ exact (andER (U :e Power X /\ V :e Power X) (U :/\: V = Empty)
               (andEL ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty)
                      (U <> Empty) H2)). }
claim HUpower: U :e Power X.
{ exact (andEL (U :e Power X) (V :e Power X)
               (andEL (U :e Power X /\ V :e Power X) (U :/\: V = Empty)
                      (andEL ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) (U <> Empty) H2))). }
claim HUsubX: U c= X.
{ exact (PowerE X U HUpower). }
claim Heq_comp: U = X :\: V.
{ apply set_ext.
  - let x. assume Hx: x :e U.
    prove x :e X :\: V.
    claim HxX: x :e X.
    { exact (HUsubX x Hx). }
    claim HxnotV: x /:e V.
    { assume HxV: x :e V.
      claim Hxdisj: x :e U :/\: V.
      { exact (binintersectI U V x Hx HxV). }
      claim Hfalse: x :e Empty.
      { rewrite <- Hdisj. exact Hxdisj. }
      exact (EmptyE x Hfalse). }
    exact (setminusI X V x HxX HxnotV).
  - let x. assume Hx: x :e X :\: V.
    prove x :e U.
    claim HxX: x :e X.
    { exact (setminusE1 X V x Hx). }
    claim HxnotV: x /:e V.
    { exact (setminusE2 X V x Hx). }
    claim HxUnion: x :e U :\/: V.
    { rewrite Hunion. exact HxX. }
    apply (binunionE U V x HxUnion).
    + assume HxU. exact HxU.
    + assume HxV. exact (FalseE (HxnotV HxV) (x :e U)). }
claim HUclosed: closed_in X Tx U.
{ prove topology_on X Tx /\ (U c= X /\ exists W :e Tx, U = X :\: W).
  apply andI.
  - exact HTx.
  - apply andI.
    + exact HUsubX.
    + witness V.
      apply andI.
      * exact HV.
      * exact Heq_comp. }
apply andI.
- apply andI.
  + apply andI.
    * exact HUne.
    * exact HUneX.
  + exact HUopen.
- exact HUclosed.
Qed.

(** from 23: no nontrivial clopen sets characterization **)
(** LATEX VERSION: A space is connected iff it has no nontrivial clopen subsets. **)
Theorem connected_iff_no_nontrivial_clopen : forall X Tx:set,
  topology_on X Tx ->
  (connected_space X Tx <->
  ~(exists A:set, A <> Empty /\ A <> X /\ open_in X Tx A /\ closed_in X Tx A)).
let X Tx.
assume HTx: topology_on X Tx.
prove connected_space X Tx <-> ~(exists A:set, A <> Empty /\ A <> X /\ open_in X Tx A /\ closed_in X Tx A).
apply iffI.
- (** Forward: connected implies no nontrivial clopen **)
  assume Hconn: connected_space X Tx.
  prove ~(exists A:set, A <> Empty /\ A <> X /\ open_in X Tx A /\ closed_in X Tx A).
  assume Hclopen: exists A:set, A <> Empty /\ A <> X /\ open_in X Tx A /\ closed_in X Tx A.
  (** Extract no-separation from connectedness **)
  claim Hnosep: ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).
  { exact (andER (topology_on X Tx)
                 (~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V))
                 Hconn). }
  (** Clopen exists, so by axiom we get separation **)
  apply Hclopen.
  let A. assume HA.
  (** Left-associative: (((A <> Empty /\ A <> X) /\ open_in X Tx A) /\ closed_in X Tx A) **)
  claim HAne: A <> Empty.
  { exact (andEL (A <> Empty) (A <> X)
                 (andEL (A <> Empty /\ A <> X) (open_in X Tx A)
                        (andEL ((A <> Empty /\ A <> X) /\ open_in X Tx A) (closed_in X Tx A) HA))). }
  claim HAnX: A <> X.
  { exact (andER (A <> Empty) (A <> X)
                 (andEL (A <> Empty /\ A <> X) (open_in X Tx A)
                        (andEL ((A <> Empty /\ A <> X) /\ open_in X Tx A) (closed_in X Tx A) HA))). }
  claim HAopen: open_in X Tx A.
  { exact (andER (A <> Empty /\ A <> X) (open_in X Tx A)
                 (andEL ((A <> Empty /\ A <> X) /\ open_in X Tx A) (closed_in X Tx A) HA)). }
  claim HAclosed: closed_in X Tx A.
  { exact (andER ((A <> Empty /\ A <> X) /\ open_in X Tx A) (closed_in X Tx A) HA). }
  (** Apply axiom to get separation **)
  claim Hsepexists: exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V.
  { exact (clopen_gives_separation X Tx A HTx HAne HAnX HAopen HAclosed). }
  (** Contradiction **)
  apply Hnosep.
  exact Hsepexists.
- (** Backward: no nontrivial clopen implies connected **)
  assume Hno_clopen: ~(exists A:set, A <> Empty /\ A <> X /\ open_in X Tx A /\ closed_in X Tx A).
  prove connected_space X Tx.
  prove topology_on X Tx /\ ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).
  apply andI.
  + exact HTx.
  + prove ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).
    assume Hsep: exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V.
    apply Hsep.
    let U. assume HsepV: exists V:set, U :e Tx /\ V :e Tx /\ separation_of X U V.
    apply HsepV.
    let V. assume HUV.
    (** Left-associative: ((U :e Tx /\ V :e Tx) /\ separation_of X U V) **)
    claim HU: U :e Tx.
    { exact (andEL (U :e Tx) (V :e Tx)
                   (andEL (U :e Tx /\ V :e Tx) (separation_of X U V) HUV)). }
    claim HV: V :e Tx.
    { exact (andER (U :e Tx) (V :e Tx)
                   (andEL (U :e Tx /\ V :e Tx) (separation_of X U V) HUV)). }
    claim Hsepof: separation_of X U V.
    { exact (andER (U :e Tx /\ V :e Tx) (separation_of X U V) HUV). }
    (** Apply axiom to get clopen from separation **)
    claim Hclopenexists: exists A:set, A <> Empty /\ A <> X /\ open_in X Tx A /\ closed_in X Tx A.
    { exact (separation_gives_clopen X Tx U V HTx HU HV Hsepof). }
    (** Contradiction **)
    apply Hno_clopen.
    exact Hclopenexists.
Qed.

(** from 23 Lemma 23.1: separations in subspaces via limit points **)
(** LATEX VERSION: If Y is a subspace of X, a separation of Y is a pair of disjoint nonempty sets A,B whose union is Y, neither containing a limit point of the other. **)
Theorem separation_subspace_limit_points : forall X Tx Y A B:set,
  topology_on X Tx -> Y c= X ->
  (((A :e subspace_topology X Tx Y /\ B :e subspace_topology X Tx Y) /\ separation_of Y A B)
  <->
  (separation_of Y A B
    /\ ~(exists b:set, b :e B /\ limit_point_of X Tx A b)
    /\ ~(exists a:set, a :e A /\ limit_point_of X Tx B a))).
let X Tx Y A B.
assume HTx: topology_on X Tx.
assume HY: Y c= X.
prove (((A :e subspace_topology X Tx Y /\ B :e subspace_topology X Tx Y) /\ separation_of Y A B)
  <->
  (separation_of Y A B
    /\ ~(exists b:set, b :e B /\ limit_point_of X Tx A b)
    /\ ~(exists a:set, a :e A /\ limit_point_of X Tx B a))).
apply iffI.
- (** -> direction: openness in subspace implies no cross-limit-points **)
  assume Hleft.
  claim HABsub: A :e subspace_topology X Tx Y /\ B :e subspace_topology X Tx Y.
  { exact (andEL (A :e subspace_topology X Tx Y /\ B :e subspace_topology X Tx Y) (separation_of Y A B) Hleft). }
  claim HAinTy: A :e subspace_topology X Tx Y.
  { exact (andEL (A :e subspace_topology X Tx Y) (B :e subspace_topology X Tx Y) HABsub). }
  claim HBinTy: B :e subspace_topology X Tx Y.
  { exact (andER (A :e subspace_topology X Tx Y) (B :e subspace_topology X Tx Y) HABsub). }
  claim Hsep: separation_of Y A B.
  { exact (andER (A :e subspace_topology X Tx Y /\ B :e subspace_topology X Tx Y) (separation_of Y A B) Hleft). }
  prove separation_of Y A B
    /\ ~(exists b:set, b :e B /\ limit_point_of X Tx A b)
    /\ ~(exists a:set, a :e A /\ limit_point_of X Tx B a).
  apply andI.
  + apply andI.
    - exact Hsep.
    - (** no b in B is a limit point of A **)
      prove ~(exists b:set, b :e B /\ limit_point_of X Tx A b).
      assume Hex: exists b:set, b :e B /\ limit_point_of X Tx A b.
      prove False.
      apply Hex.
      let b. assume Hbconj.
      claim HbB: b :e B.
      { exact (andEL (b :e B) (limit_point_of X Tx A b) Hbconj). }
      claim HLP: limit_point_of X Tx A b.
      { exact (andER (b :e B) (limit_point_of X Tx A b) Hbconj). }
      (** Extract B = V  Y for some V open in X **)
      claim HexV: exists V :e Tx, B = V :/\: Y.
      { exact (SepE2 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) B HBinTy). }
      apply HexV.
      let V. assume HVpair.
      claim HVTx: V :e Tx.
      { exact (andEL (V :e Tx) (B = V :/\: Y) HVpair). }
      claim HBeq: B = V :/\: Y.
      { exact (andER (V :e Tx) (B = V :/\: Y) HVpair). }
      (** Use separation_of to get A,B  Y and AB= **)
      claim Hpart1: ((((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty) /\ B <> Empty).
      { exact (andEL ((((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty) /\ B <> Empty)
                     (A :\/: B = Y) Hsep). }
      claim HAux: (((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty).
      { exact (andEL (((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty)
                     (B <> Empty) Hpart1). }
      claim Hpowdisj: (A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty.
      { exact (andEL ((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) (A <> Empty) HAux). }
      claim Hpow: A :e Power Y /\ B :e Power Y.
      { exact (andEL (A :e Power Y /\ B :e Power Y) (A :/\: B = Empty) Hpowdisj). }
      claim Hdisj: A :/\: B = Empty.
      { exact (andER (A :e Power Y /\ B :e Power Y) (A :/\: B = Empty) Hpowdisj). }
      claim HApowY: A :e Power Y.
      { exact (andEL (A :e Power Y) (B :e Power Y) Hpow). }
      claim HBpowY: B :e Power Y.
      { exact (andER (A :e Power Y) (B :e Power Y) Hpow). }
      claim HAsubY: A c= Y.
      { exact (PowerE Y A HApowY). }
      claim HBsubY: B c= Y.
      { exact (PowerE Y B HBpowY). }
      (** b  V **)
      claim HbVY: b :e V :/\: Y.
      { rewrite <- HBeq. exact HbB. }
      claim HbV: b :e V.
      { exact (binintersectE1 V Y b HbVY). }
      (** Apply limit point condition to neighborhood V **)
      claim HLPp: topology_on X Tx /\ b :e X.
      { exact (andEL (topology_on X Tx /\ b :e X) (forall U:set, U :e Tx -> b :e U -> exists y:set, y :e A /\ y <> b /\ y :e U) HLP). }
      claim HLPcond: forall U:set, U :e Tx -> b :e U -> exists y:set, y :e A /\ y <> b /\ y :e U.
      { exact (andER (topology_on X Tx /\ b :e X) (forall U:set, U :e Tx -> b :e U -> exists y:set, y :e A /\ y <> b /\ y :e U) HLP). }
      claim Hexy: exists y:set, y :e A /\ y <> b /\ y :e V.
      { exact (HLPcond V HVTx HbV). }
      apply Hexy.
      let y. assume Hyconj.
      claim HyAB: y :e A /\ y <> b.
      { exact (andEL (y :e A /\ y <> b) (y :e V) Hyconj). }
      claim HyA: y :e A.
      { exact (andEL (y :e A) (y <> b) HyAB). }
      claim HyV: y :e V.
      { exact (andER (y :e A /\ y <> b) (y :e V) Hyconj). }
      claim HyY: y :e Y.
      { exact (HAsubY y HyA). }
      claim HyB: y :e B.
      { rewrite HBeq. exact (binintersectI V Y y HyV HyY). }
      claim HyAB2: y :e A :/\: B.
      { exact (binintersectI A B y HyA HyB). }
      claim HyE: y :e Empty.
      { rewrite <- Hdisj. exact HyAB2. }
      exact (EmptyE y HyE).
  + (** no a in A is a limit point of B (symmetric) **)
    prove ~(exists a:set, a :e A /\ limit_point_of X Tx B a).
    assume Hex: exists a:set, a :e A /\ limit_point_of X Tx B a.
    prove False.
    apply Hex.
    let a. assume Haconj.
    claim HaA: a :e A.
    { exact (andEL (a :e A) (limit_point_of X Tx B a) Haconj). }
    claim HLP: limit_point_of X Tx B a.
    { exact (andER (a :e A) (limit_point_of X Tx B a) Haconj). }
      (** Extract A = U  Y for some U open in X **)
      claim HexU: exists U :e Tx, A = U :/\: Y.
      { exact (SepE2 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) A HAinTy). }
      apply HexU.
      let U. assume HUpair.
      claim HUTx: U :e Tx.
      { exact (andEL (U :e Tx) (A = U :/\: Y) HUpair). }
      claim HAeq: A = U :/\: Y.
      { exact (andER (U :e Tx) (A = U :/\: Y) HUpair). }
      (** Use separation_of to get A,B  Y and AB= **)
      claim Hpart1: ((((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty) /\ B <> Empty).
      { exact (andEL ((((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty) /\ B <> Empty)
                     (A :\/: B = Y) Hsep). }
      claim HAux: (((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty).
      { exact (andEL (((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty)
                     (B <> Empty) Hpart1). }
      claim Hpowdisj: (A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty.
      { exact (andEL ((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) (A <> Empty) HAux). }
      claim Hpow: A :e Power Y /\ B :e Power Y.
      { exact (andEL (A :e Power Y /\ B :e Power Y) (A :/\: B = Empty) Hpowdisj). }
      claim Hdisj: A :/\: B = Empty.
      { exact (andER (A :e Power Y /\ B :e Power Y) (A :/\: B = Empty) Hpowdisj). }
      claim HApowY: A :e Power Y.
      { exact (andEL (A :e Power Y) (B :e Power Y) Hpow). }
      claim HBpowY: B :e Power Y.
      { exact (andER (A :e Power Y) (B :e Power Y) Hpow). }
      claim HAsubY: A c= Y.
      { exact (PowerE Y A HApowY). }
      claim HBsubY: B c= Y.
      { exact (PowerE Y B HBpowY). }
      (** a  U **)
      claim HaUY: a :e U :/\: Y.
      { rewrite <- HAeq. exact HaA. }
      claim HaU: a :e U.
      { exact (binintersectE1 U Y a HaUY). }
      (** Apply limit point condition to neighborhood U **)
      claim HLPcond: forall V0:set, V0 :e Tx -> a :e V0 -> exists y:set, y :e B /\ y <> a /\ y :e V0.
      { exact (andER (topology_on X Tx /\ a :e X) (forall V0:set, V0 :e Tx -> a :e V0 -> exists y:set, y :e B /\ y <> a /\ y :e V0) HLP). }
      claim Hexy: exists y:set, y :e B /\ y <> a /\ y :e U.
      { exact (HLPcond U HUTx HaU). }
      apply Hexy.
      let y. assume Hyconj.
      claim HyBA: y :e B /\ y <> a.
      { exact (andEL (y :e B /\ y <> a) (y :e U) Hyconj). }
      claim HyB: y :e B.
      { exact (andEL (y :e B) (y <> a) HyBA). }
      claim HyU: y :e U.
      { exact (andER (y :e B /\ y <> a) (y :e U) Hyconj). }
      claim HyY: y :e Y.
      { exact (HBsubY y HyB). }
      claim HyA2: y :e A.
      { rewrite HAeq. exact (binintersectI U Y y HyU HyY). }
      claim HyAB2: y :e A :/\: B.
      { exact (binintersectI A B y HyA2 HyB). }
      claim HyE: y :e Empty.
      { rewrite <- Hdisj. exact HyAB2. }
      exact (EmptyE y HyE).
- (** <- direction: no cross-limit-points implies openness in subspace **)
  assume Hright.
  claim Htmp: separation_of Y A B /\ ~(exists b:set, b :e B /\ limit_point_of X Tx A b).
  { exact (andEL (separation_of Y A B /\ ~(exists b:set, b :e B /\ limit_point_of X Tx A b))
                 (~(exists a:set, a :e A /\ limit_point_of X Tx B a)) Hright). }
  claim Hsep: separation_of Y A B.
  { exact (andEL (separation_of Y A B) (~(exists b:set, b :e B /\ limit_point_of X Tx A b)) Htmp). }
  claim HnoB: ~(exists b:set, b :e B /\ limit_point_of X Tx A b).
  { exact (andER (separation_of Y A B) (~(exists b:set, b :e B /\ limit_point_of X Tx A b)) Htmp). }
  claim HnoA: ~(exists a:set, a :e A /\ limit_point_of X Tx B a).
  { exact (andER (separation_of Y A B /\ ~(exists b:set, b :e B /\ limit_point_of X Tx A b))
                 (~(exists a:set, a :e A /\ limit_point_of X Tx B a)) Hright). }
  (** Extract basic separation facts **)
  claim Hpart1: ((((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty) /\ B <> Empty).
  { exact (andEL ((((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty) /\ B <> Empty)
                 (A :\/: B = Y) Hsep). }
  claim Hunion: A :\/: B = Y.
  { exact (andER ((((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty) /\ B <> Empty)
                 (A :\/: B = Y) Hsep). }
  claim HAux: (((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty).
  { exact (andEL (((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty)
                 (B <> Empty) Hpart1). }
  claim Hpowdisj: (A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty.
  { exact (andEL ((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) (A <> Empty) HAux). }
  claim Hpow: A :e Power Y /\ B :e Power Y.
  { exact (andEL (A :e Power Y /\ B :e Power Y) (A :/\: B = Empty) Hpowdisj). }
  claim Hdisj: A :/\: B = Empty.
  { exact (andER (A :e Power Y /\ B :e Power Y) (A :/\: B = Empty) Hpowdisj). }
  claim HApowY: A :e Power Y.
  { exact (andEL (A :e Power Y) (B :e Power Y) Hpow). }
  claim HBpowY: B :e Power Y.
  { exact (andER (A :e Power Y) (B :e Power Y) Hpow). }
  claim HAsubY: A c= Y.
  { exact (PowerE Y A HApowY). }
  claim HBsubY: B c= Y.
  { exact (PowerE Y B HBpowY). }
  (** Topology on Y **)
  claim HtopY: topology_on Y (subspace_topology X Tx Y).
  { exact (subspace_topology_is_topology X Tx Y HTx HY). }
  (** Prove A and B are open in the subspace by local openness (ex13_1). **)
  claim HAopen_in: open_in Y (subspace_topology X Tx Y) A.
  { apply (ex13_1_local_open_subset Y (subspace_topology X Tx Y) A HtopY).
    let x. assume HxA: x :e A.
    prove exists U :e subspace_topology X Tx Y, x :e U /\ U c= A.
    (** x is not a limit point of B (otherwise contradict HnoA) **)
    claim HnotLP: ~(limit_point_of X Tx B x).
    { assume HLP.
      apply HnoA.
      witness x.
      apply andI.
      - exact HxA.
      - exact HLP. }
    claim HxY: x :e Y.
    { exact (HAsubY x HxA). }
    claim HxX: x :e X.
    { exact (HY x HxY). }
    (** Not being a limit point yields an open neighborhood W with no B-point in it. **)
    claim HnotForall: ~(forall W:set, W :e Tx -> x :e W -> exists y:set, y :e B /\ y <> x /\ y :e W).
    { assume Hforall.
      apply HnotLP.
      prove topology_on X Tx /\ x :e X /\ forall U:set, U :e Tx -> x :e U -> exists y:set, y :e B /\ y <> x /\ y :e U.
      apply andI.
      - apply andI.
        + exact HTx.
        + exact HxX.
      - exact Hforall. }
    claim HexW: exists W:set, ~(W :e Tx -> x :e W -> exists y:set, y :e B /\ y <> x /\ y :e W).
    { exact (not_all_ex_demorgan_i (fun W:set => W :e Tx -> x :e W -> exists y:set, y :e B /\ y <> x /\ y :e W) HnotForall). }
    apply HexW.
    let W. assume HnImp.
    (** Derive W  Tx **)
    claim HWTx: W :e Tx.
    { apply (xm (W :e Tx)).
      - assume HW. exact HW.
      - assume HnotW.
        apply FalseE.
        apply HnImp.
        assume HW0: W :e Tx.
        assume HxW0: x :e W.
        apply FalseE.
        exact (HnotW HW0). }
    (** Derive x  W **)
    claim HxW: x :e W.
    { apply (xm (x :e W)).
      - assume Hx. exact Hx.
      - assume Hnotx.
        apply FalseE.
        apply HnImp.
        assume HW0: W :e Tx.
        assume HxW0: x :e W.
        apply FalseE.
        exact (Hnotx HxW0). }
    (** Hence no y  B with y  x in W. **)
    claim HnoY: ~(exists y:set, y :e B /\ y <> x /\ y :e W).
    { assume Hexy.
      apply HnImp.
      assume HW0: W :e Tx.
      assume HxW0: x :e W.
      exact Hexy. }
    (** Neighborhood in subspace: U = W  Y **)
    set U := W :/\: Y.
    witness U.
    (** Bounded-exists goal is UTy  (xU  UA) **)
    apply andI.
    - (** U  subspace topology with witness W **)
      prove U :e subspace_topology X Tx Y.
      claim HUpowY: U :e Power Y.
      { apply PowerI.
        let t. assume Ht: t :e U.
        exact (binintersectE2 W Y t Ht). }
      claim HexWU: exists V :e Tx, U = V :/\: Y.
      { witness W.
        apply andI.
        - exact HWTx.
        - reflexivity. }
      exact (SepI (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HUpowY HexWU).
    - (** x  U  U  A **)
      apply andI.
      + exact (binintersectI W Y x HxW HxY).
      + (** U  A since U  Y and disjoint from B, and A  B = Y **)
        prove U c= A.
        let t. assume Ht: t :e U.
        prove t :e A.
        claim HtY: t :e Y.
        { exact (binintersectE2 W Y t Ht). }
        (** show t  B using HnoY **)
        claim HtnotB: t /:e B.
        { assume HtB: t :e B.
          apply HnoY.
          witness t.
          prove (t :e B /\ t <> x) /\ t :e W.
          apply andI.
          - apply andI.
            + exact HtB.
            + (** t <> x since x  A and A  B =  **)
              assume Heq: t = x.
              claim HxB: x :e B.
              { rewrite <- Heq. exact HtB. }
              claim HxAB: x :e A :/\: B.
              { exact (binintersectI A B x HxA HxB). }
              claim HxE: x :e Empty.
              { rewrite <- Hdisj. exact HxAB. }
              exact (EmptyE x HxE).
          - (** t  W **)
            exact (binintersectE1 W Y t Ht). }
        (** From t  Y, get t  A  B, then eliminate the B case. **)
        claim HtAB: t :e A :\/: B.
        { rewrite Hunion. exact HtY. }
        apply (binunionE A B t HtAB).
        * assume HtA. exact HtA.
        * assume HtB.
          apply FalseE.
          exact (HtnotB HtB). }
  claim HATy: A :e subspace_topology X Tx Y.
  { exact (andER (topology_on Y (subspace_topology X Tx Y)) (A :e subspace_topology X Tx Y) HAopen_in). }
  claim HBopen_in: open_in Y (subspace_topology X Tx Y) B.
  { apply (ex13_1_local_open_subset Y (subspace_topology X Tx Y) B HtopY).
    let x. assume HxB: x :e B.
    prove exists U :e subspace_topology X Tx Y, x :e U /\ U c= B.
    claim HnotLP: ~(limit_point_of X Tx A x).
    { assume HLP.
      apply HnoB.
      witness x.
      apply andI.
      - exact HxB.
      - exact HLP. }
    claim HxY: x :e Y.
    { exact (HBsubY x HxB). }
    claim HxX: x :e X.
    { exact (HY x HxY). }
    claim HnotForall: ~(forall W:set, W :e Tx -> x :e W -> exists y:set, y :e A /\ y <> x /\ y :e W).
    { assume Hforall.
      apply HnotLP.
      prove topology_on X Tx /\ x :e X /\ forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
      apply andI.
      - apply andI.
        + exact HTx.
        + exact HxX.
      - exact Hforall. }
    claim HexW: exists W:set, ~(W :e Tx -> x :e W -> exists y:set, y :e A /\ y <> x /\ y :e W).
    { exact (not_all_ex_demorgan_i (fun W:set => W :e Tx -> x :e W -> exists y:set, y :e A /\ y <> x /\ y :e W) HnotForall). }
    apply HexW.
    let W. assume HnImp.
    claim HWTx: W :e Tx.
    { apply (xm (W :e Tx)).
      - assume HW. exact HW.
      - assume HnotW.
        apply FalseE.
        apply HnImp.
        assume HW0: W :e Tx.
        assume HxW0: x :e W.
        apply FalseE.
        exact (HnotW HW0). }
    claim HxW: x :e W.
    { apply (xm (x :e W)).
      - assume Hx. exact Hx.
      - assume Hnotx.
        apply FalseE.
        apply HnImp.
        assume HW0: W :e Tx.
        assume HxW0: x :e W.
        apply FalseE.
        exact (Hnotx HxW0). }
    claim HnoY: ~(exists y:set, y :e A /\ y <> x /\ y :e W).
    { assume Hexy.
      apply HnImp.
      assume HW0: W :e Tx.
      assume HxW0: x :e W.
      exact Hexy. }
    set U := W :/\: Y.
    witness U.
    (** Bounded-exists goal is UTy  (xU  UB) **)
    apply andI.
    - (** U  subspace topology **)
      prove U :e subspace_topology X Tx Y.
      claim HUpowY: U :e Power Y.
      { apply PowerI.
        let t. assume Ht: t :e U.
        exact (binintersectE2 W Y t Ht). }
      claim HexWU: exists V :e Tx, U = V :/\: Y.
      { witness W.
        apply andI.
        - exact HWTx.
        - reflexivity. }
      exact (SepI (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HUpowY HexWU).
    - (** x  U  U  B **)
      apply andI.
      + exact (binintersectI W Y x HxW HxY).
      + prove U c= B.
        let t. assume Ht: t :e U.
        prove t :e B.
        claim HtY: t :e Y.
        { exact (binintersectE2 W Y t Ht). }
        claim HtnotA: t /:e A.
        { assume HtA: t :e A.
          apply HnoY.
          witness t.
          prove (t :e A /\ t <> x) /\ t :e W.
          apply andI.
          - apply andI.
            + exact HtA.
            + assume Heq: t = x.
              claim HxA: x :e A.
              { rewrite <- Heq. exact HtA. }
              claim HxAB: x :e A :/\: B.
              { exact (binintersectI A B x HxA HxB). }
              claim HxE: x :e Empty.
              { rewrite <- Hdisj. exact HxAB. }
              exact (EmptyE x HxE).
          - exact (binintersectE1 W Y t Ht). }
        claim HtAB: t :e A :\/: B.
        { rewrite Hunion. exact HtY. }
        apply (binunionE A B t HtAB).
        * assume HtA.
          apply FalseE.
          exact (HtnotA HtA).
        * assume HtB. exact HtB. }
  claim HBTy: B :e subspace_topology X Tx Y.
  { exact (andER (topology_on Y (subspace_topology X Tx Y)) (B :e subspace_topology X Tx Y) HBopen_in). }
  prove (A :e subspace_topology X Tx Y /\ B :e subspace_topology X Tx Y) /\ separation_of Y A B.
  apply andI.
  + apply andI.
    * exact HATy.
    * exact HBTy.
  + exact Hsep.
Qed.

(** from 23 Lemma 23.2: connected subspace lies in one side of a separation **)
(** LATEX VERSION: If C and D form a separation of X and Y is a connected subspace of X, then Y lies entirely within either C or D. **)
Theorem connected_subset_in_separation_side : forall X Tx C D Y:set,
  topology_on X Tx -> Y c= X ->
  connected_space Y (subspace_topology X Tx Y) ->
  C :e Tx -> D :e Tx -> separation_of X C D ->
  Y c= C \/ Y c= D.
let X Tx C D Y.
assume HTx: topology_on X Tx.
assume HYX: Y c= X.
assume HY: connected_space Y (subspace_topology X Tx Y).
assume HC: C :e Tx.
assume HD: D :e Tx.
assume Hsep: separation_of X C D.
prove Y c= C \/ Y c= D.
(** Proof by contradiction: if Y meets both C and D, then (CY) and (DY) separate Y. **)
apply (xm (Y c= C)).
- assume HYC: Y c= C.
  apply orIL.
  exact HYC.
- assume HnotYcC: ~(Y c= C).
  apply (xm (Y c= D)).
  + assume HYD: Y c= D.
    apply orIR.
    exact HYD.
  + assume HnotYcD: ~(Y c= D).
    (** Get yD in YD from not(YC) and CD=X **)
    claim HexYnotC: exists y:set, y :e Y /\ y /:e C.
    { claim Hex: exists y:set, ~(y :e Y -> y :e C).
      { exact (not_all_ex_demorgan_i (fun y:set => y :e Y -> y :e C) HnotYcC). }
      apply Hex.
      let y. assume Hnotimp.
      (** From ~(P -> Q), derive P and ~Q by contradiction. **)
      claim HyY: y :e Y.
      { apply (xm (y :e Y)).
        - assume HyY. exact HyY.
        - assume HyNotY.
          apply FalseE.
          apply Hnotimp.
          assume HyY: y :e Y.
          apply FalseE.
          exact (HyNotY HyY). }
      claim HyNotC: y /:e C.
      { assume HyC: y :e C.
        apply Hnotimp.
        assume _: y :e Y.
        exact HyC. }
      witness y.
      apply andI.
      - exact HyY.
      - exact HyNotC. }
    apply HexYnotC.
    let yD. assume HyDpair.
    claim HyDY: yD :e Y.
    { exact (andEL (yD :e Y) (yD /:e C) HyDpair). }
    claim HyDnotC: yD /:e C.
    { exact (andER (yD :e Y) (yD /:e C) HyDpair). }
    (** Extract union CD=X and C,D subset X from separation_of **)
    claim Hsep_left: ((((C :e Power X /\ D :e Power X) /\ C :/\: D = Empty) /\ C <> Empty) /\ D <> Empty).
    { exact (andEL ((((C :e Power X /\ D :e Power X) /\ C :/\: D = Empty) /\ C <> Empty) /\ D <> Empty)
                   (C :\/: D = X) Hsep). }
    claim Hsep_pow_disj: (C :e Power X /\ D :e Power X) /\ C :/\: D = Empty.
    { exact (andEL ((C :e Power X /\ D :e Power X) /\ C :/\: D = Empty)
                   (C <> Empty)
                   (andEL (((C :e Power X /\ D :e Power X) /\ C :/\: D = Empty) /\ C <> Empty)
                          (D <> Empty) Hsep_left)). }
    claim HCpow: C :e Power X.
    { exact (andEL (C :e Power X) (D :e Power X)
                   (andEL (C :e Power X /\ D :e Power X) (C :/\: D = Empty) Hsep_pow_disj)). }
    claim HDpow: D :e Power X.
    { exact (andER (C :e Power X) (D :e Power X)
                   (andEL (C :e Power X /\ D :e Power X) (C :/\: D = Empty) Hsep_pow_disj)). }
    claim HCsubX: C c= X.
    { exact (PowerE X C HCpow). }
    claim HDsubX: D c= X.
    { exact (PowerE X D HDpow). }
    claim HunionCD: C :\/: D = X.
    { exact (andER ((((C :e Power X /\ D :e Power X) /\ C :/\: D = Empty) /\ C <> Empty) /\ D <> Empty)
                   (C :\/: D = X) Hsep). }
    claim HyDX: yD :e X.
    { exact (HYX yD HyDY). }
    claim HyDinCD: yD :e C :\/: D.
    { rewrite HunionCD. exact HyDX. }
    claim HyDinD: yD :e D.
    { apply (binunionE C D yD HyDinCD).
      - assume HyDC: yD :e C.
        apply FalseE.
        exact (HyDnotC HyDC).
      - assume HyDD: yD :e D.
        exact HyDD. }

    (** Get yC in YC from not(YD) and CD=X **)
    claim HexYnotD: exists y:set, y :e Y /\ y /:e D.
    { claim Hex: exists y:set, ~(y :e Y -> y :e D).
      { exact (not_all_ex_demorgan_i (fun y:set => y :e Y -> y :e D) HnotYcD). }
      apply Hex.
      let y. assume Hnotimp.
      claim HyY: y :e Y.
      { apply (xm (y :e Y)).
        - assume HyY. exact HyY.
        - assume HyNotY.
          apply FalseE.
          apply Hnotimp.
          assume HyY: y :e Y.
          apply FalseE.
          exact (HyNotY HyY). }
      claim HyNotD: y /:e D.
      { assume HyD: y :e D.
        apply Hnotimp.
        assume _: y :e Y.
        exact HyD. }
      witness y.
      apply andI.
      - exact HyY.
      - exact HyNotD. }
    apply HexYnotD.
    let yC. assume HyCpair.
    claim HyCY: yC :e Y.
    { exact (andEL (yC :e Y) (yC /:e D) HyCpair). }
    claim HyCnotD: yC /:e D.
    { exact (andER (yC :e Y) (yC /:e D) HyCpair). }
    claim HyCX: yC :e X.
    { exact (HYX yC HyCY). }
    claim HyCinCD: yC :e C :\/: D.
    { rewrite HunionCD. exact HyCX. }
    claim HyCinC: yC :e C.
    { apply (binunionE C D yC HyCinCD).
      - assume HyCC: yC :e C.
        exact HyCC.
      - assume HyCD: yC :e D.
        apply FalseE.
        exact (HyCnotD HyCD). }

    (** Define A = CY and B = DY; show they are open in the subspace topology and form a separation of Y **)
    set A := C :/\: Y.
    set B := D :/\: Y.
    claim HAYsub: A c= Y.
    { exact (binintersect_Subq_2 C Y). }
    claim HBYsub: B c= Y.
    { exact (binintersect_Subq_2 D Y). }
    claim HAopenY: open_in Y (subspace_topology X Tx Y) A.
    { apply (iffER (open_in Y (subspace_topology X Tx Y) A)
                   (exists V :e Tx, A = V :/\: Y)
                   (open_in_subspace_iff X Tx Y A HTx HYX HAYsub)).
      witness C.
      apply andI.
      - exact HC.
      - prove A = C :/\: Y.
        reflexivity. }
    claim HBopenY: open_in Y (subspace_topology X Tx Y) B.
    { apply (iffER (open_in Y (subspace_topology X Tx Y) B)
                   (exists V :e Tx, B = V :/\: Y)
                   (open_in_subspace_iff X Tx Y B HTx HYX HBYsub)).
      witness D.
      apply andI.
      - exact HD.
      - prove B = D :/\: Y.
        reflexivity. }
    claim HAinSub: A :e subspace_topology X Tx Y.
    { exact (andER (topology_on Y (subspace_topology X Tx Y)) (A :e subspace_topology X Tx Y) HAopenY). }
    claim HBinSub: B :e subspace_topology X Tx Y.
    { exact (andER (topology_on Y (subspace_topology X Tx Y)) (B :e subspace_topology X Tx Y) HBopenY). }
    (** separation_of Y A B **)
    claim HsepAB: separation_of Y A B.
    { prove A :e Power Y /\ B :e Power Y /\ A :/\: B = Empty /\ A <> Empty /\ B <> Empty /\ A :\/: B = Y.
      apply andI.
      - prove ((((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty) /\ B <> Empty).
        apply andI.
        + prove (((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty).
          apply andI.
          - prove (A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty.
            apply andI.
            + prove A :e Power Y /\ B :e Power Y.
              apply andI.
              - exact (PowerI Y A HAYsub).
              - exact (PowerI Y B HBYsub).
            + prove A :/\: B = Empty.
              apply Empty_eq.
              let t. assume Ht: t :e A :/\: B.
              apply (binintersectE A B t Ht).
              assume HtA: t :e A.
              assume HtB: t :e B.
              (** t in C and D, so t in CD, contradiction **)
              claim HtC: t :e C.
              { exact (binintersectE1 C Y t HtA). }
              claim HtD: t :e D.
              { exact (binintersectE1 D Y t HtB). }
              claim HtCD: t :e C :/\: D.
              { exact (binintersectI C D t HtC HtD). }
              claim HCDdisj: C :/\: D = Empty.
              { exact (andER (C :e Power X /\ D :e Power X) (C :/\: D = Empty) Hsep_pow_disj). }
              claim Hfalse: t :e Empty.
              { rewrite <- HCDdisj. exact HtCD. }
              exact (EmptyE t Hfalse).
          - (** A <> Empty using yC **)
            assume Heq: A = Empty.
            claim HyCA: yC :e A.
            { exact (binintersectI C Y yC HyCinC HyCY). }
            claim HyCEmpty: yC :e Empty.
            { rewrite <- Heq. exact HyCA. }
            exact (EmptyE yC HyCEmpty).
        + (** B <> Empty using yD **)
          assume Heq: B = Empty.
          claim HyDB: yD :e B.
          { exact (binintersectI D Y yD HyDinD HyDY). }
          claim HyDEmpty: yD :e Empty.
          { rewrite <- Heq. exact HyDB. }
          exact (EmptyE yD HyDEmpty).
      - prove A :\/: B = Y.
        apply set_ext.
        + let t. assume Ht: t :e A :\/: B.
          prove t :e Y.
          apply (binunionE A B t Ht).
          - assume HtA: t :e A.
            exact (binintersectE2 C Y t HtA).
          - assume HtB: t :e B.
            exact (binintersectE2 D Y t HtB).
        + let t. assume HtY: t :e Y.
          prove t :e A :\/: B.
          claim HtX: t :e X.
          { exact (HYX t HtY). }
          claim HtCD: t :e C :\/: D.
          { rewrite HunionCD. exact HtX. }
          apply (binunionE C D t HtCD).
          - assume HtC: t :e C.
            apply binunionI1.
            exact (binintersectI C Y t HtC HtY).
          - assume HtD: t :e D.
            apply binunionI2.
            exact (binintersectI D Y t HtD HtY). }
    (** Contradiction with connectedness of Y **)
    claim HnosepY: ~(exists U V:set,
      U :e subspace_topology X Tx Y /\ V :e subspace_topology X Tx Y /\ separation_of Y U V).
    { exact (andER (topology_on Y (subspace_topology X Tx Y))
                   (~(exists U V:set, U :e subspace_topology X Tx Y /\ V :e subspace_topology X Tx Y /\ separation_of Y U V))
                   HY). }
    apply FalseE.
    apply HnosepY.
    witness A.
    witness B.
    prove A :e subspace_topology X Tx Y /\ B :e subspace_topology X Tx Y /\ separation_of Y A B.
    apply andI.
    - apply andI.
      + exact HAinSub.
      + exact HBinSub.
    - exact HsepAB.
Qed.

(** from 23 Theorem 23.3: union of connected sets with common point is connected **)
(** LATEX VERSION: If each A is connected and the A have a point in common, then their union is connected. **)
Theorem union_connected_common_point : forall X Tx F:set,
  topology_on X Tx ->
  (forall C:set, C :e F -> C c= X) ->
  (forall C:set, C :e F -> connected_space C (subspace_topology X Tx C)) ->
  (exists x:set, forall C:set, C :e F -> x :e C) ->
  connected_space (Union F) (subspace_topology X Tx (Union F)).
let X Tx F.
assume HTx: topology_on X Tx.
assume HFsub: forall C:set, C :e F -> C c= X.
assume HF: forall C:set, C :e F -> connected_space C (subspace_topology X Tx C).
assume Hcommon: exists x:set, forall C:set, C :e F -> x :e C.
prove connected_space (Union F) (subspace_topology X Tx (Union F)).
prove topology_on (Union F) (subspace_topology X Tx (Union F)) /\
  ~(exists U V:set, U :e subspace_topology X Tx (Union F) /\ V :e subspace_topology X Tx (Union F) /\ separation_of (Union F) U V).
(** Precompute Union(F)  X so we can use subspace topology lemmas. **)
claim HFpow: F c= Power X.
{ let C. assume HC: C :e F.
  prove C :e Power X.
  exact (PowerI X C (HFsub C HC)). }
claim HUnionSubX: Union F c= X.
{ exact (Union_Power X F HFpow). }
claim HtopUnion: topology_on (Union F) (subspace_topology X Tx (Union F)).
{ exact (subspace_topology_is_topology X Tx (Union F) HTx HUnionSubX). }
apply andI.
- exact HtopUnion.
- prove ~(exists U V:set, U :e subspace_topology X Tx (Union F) /\ V :e subspace_topology X Tx (Union F) /\ separation_of (Union F) U V).
  assume HsepExists: exists U V:set, U :e subspace_topology X Tx (Union F) /\ V :e subspace_topology X Tx (Union F) /\ separation_of (Union F) U V.
  prove False.
  (** Choose the common point x0. **)
  apply Hcommon.
  let x0. assume Hx0All: forall C:set, C :e F -> x0 :e C.
  (** Unpack the supposed separation. **)
  apply HsepExists.
  let U. assume HexV: exists V:set, U :e subspace_topology X Tx (Union F) /\ V :e subspace_topology X Tx (Union F) /\ separation_of (Union F) U V.
  apply HexV.
  let V. assume HUVsep.
  claim HUVopen: U :e subspace_topology X Tx (Union F) /\ V :e subspace_topology X Tx (Union F).
  { exact (andEL (U :e subspace_topology X Tx (Union F) /\ V :e subspace_topology X Tx (Union F))
                 (separation_of (Union F) U V) HUVsep). }
  claim HUopen: U :e subspace_topology X Tx (Union F).
  { exact (andEL (U :e subspace_topology X Tx (Union F)) (V :e subspace_topology X Tx (Union F)) HUVopen). }
  claim HVopen: V :e subspace_topology X Tx (Union F).
  { exact (andER (U :e subspace_topology X Tx (Union F)) (V :e subspace_topology X Tx (Union F)) HUVopen). }
  claim Hsep: separation_of (Union F) U V.
  { exact (andER (U :e subspace_topology X Tx (Union F) /\ V :e subspace_topology X Tx (Union F))
                 (separation_of (Union F) U V) HUVsep). }
  (** Extract useful facts from separation_of. **)
  claim Hpart1: ((((U :e Power (Union F) /\ V :e Power (Union F)) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty).
  { exact (andEL ((((U :e Power (Union F) /\ V :e Power (Union F)) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                 (U :\/: V = Union F) Hsep). }
  claim Hunion: U :\/: V = Union F.
  { exact (andER ((((U :e Power (Union F) /\ V :e Power (Union F)) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                 (U :\/: V = Union F) Hsep). }
  claim HAux: (((U :e Power (Union F) /\ V :e Power (Union F)) /\ U :/\: V = Empty) /\ U <> Empty).
  { exact (andEL (((U :e Power (Union F) /\ V :e Power (Union F)) /\ U :/\: V = Empty) /\ U <> Empty)
                 (V <> Empty) Hpart1). }
  claim HVne: V <> Empty.
  { exact (andER (((U :e Power (Union F) /\ V :e Power (Union F)) /\ U :/\: V = Empty) /\ U <> Empty)
                 (V <> Empty) Hpart1). }
  claim Hpowdisj: (U :e Power (Union F) /\ V :e Power (Union F)) /\ U :/\: V = Empty.
  { exact (andEL ((U :e Power (Union F) /\ V :e Power (Union F)) /\ U :/\: V = Empty)
                 (U <> Empty) HAux). }
  claim HUne: U <> Empty.
  { exact (andER ((U :e Power (Union F) /\ V :e Power (Union F)) /\ U :/\: V = Empty)
                 (U <> Empty) HAux). }
  claim Hpow: U :e Power (Union F) /\ V :e Power (Union F).
  { exact (andEL (U :e Power (Union F) /\ V :e Power (Union F)) (U :/\: V = Empty) Hpowdisj). }
  claim Hdisj: U :/\: V = Empty.
  { exact (andER (U :e Power (Union F) /\ V :e Power (Union F)) (U :/\: V = Empty) Hpowdisj). }
  claim HUpow: U :e Power (Union F).
  { exact (andEL (U :e Power (Union F)) (V :e Power (Union F)) Hpow). }
  claim HVpow: V :e Power (Union F).
  { exact (andER (U :e Power (Union F)) (V :e Power (Union F)) Hpow). }
  claim HUsub: U c= Union F.
  { exact (PowerE (Union F) U HUpow). }
  claim HVsub: V c= Union F.
  { exact (PowerE (Union F) V HVpow). }
  (** Get some point v0 in V, hence in Union(F), hence in some member C0 of F. **)
  claim Hexv0: exists v0:set, v0 :e V.
  { exact (nonempty_has_element V HVne). }
  apply Hexv0.
  let v0. assume Hv0V: v0 :e V.
  claim Hv0Union: v0 :e Union F.
  { exact (HVsub v0 Hv0V). }
  apply (UnionE_impred F v0 Hv0Union).
  let C0. assume Hv0C0: v0 :e C0. assume HC0F: C0 :e F.
  claim Hx0C0: x0 :e C0.
  { exact (Hx0All C0 HC0F). }
  claim Hx0Union: x0 :e Union F.
  { exact (UnionI F x0 C0 Hx0C0 HC0F). }
  (** Now x0 is in U or V, by U  V = Union(F). **)
  claim Hx0UV: x0 :e U :\/: V.
  { rewrite Hunion. exact Hx0Union. }
  apply (binunionE U V x0 Hx0UV).
  - (** Case: x0  U **)
    assume Hx0U: x0 :e U.
    (** Show Union(F)  U by showing each C  F is contained in U. **)
    claim HUnionSubU: Union F c= U.
    { let y. assume HyUnion: y :e Union F.
      prove y :e U.
      apply (UnionE_impred F y HyUnion (y :e U)).
      let C. assume HyC: y :e C. assume HC: C :e F.
      (** C  Union(F) **)
      claim HCsubUnion: C c= Union F.
      { let z. assume Hz: z :e C.
        exact (UnionI F z C Hz HC). }
      (** Connectedness of C as a subspace of Union(F) **)
      claim HeqTop: subspace_topology (Union F) (subspace_topology X Tx (Union F)) C =
                    subspace_topology X Tx C.
      { exact (ex16_1_subspace_transitive X Tx (Union F) C HTx HUnionSubX HCsubUnion). }
      claim HCconn: connected_space C (subspace_topology (Union F) (subspace_topology X Tx (Union F)) C).
      { rewrite HeqTop. exact (HF C HC). }
      claim HCside: C c= U \/ C c= V.
      { exact (connected_subset_in_separation_side (Union F) (subspace_topology X Tx (Union F)) U V C
                HtopUnion HCsubUnion HCconn HUopen HVopen Hsep). }
      apply HCside.
      + assume HCsubU: C c= U.
        exact (HCsubU y HyC).
      + assume HCsubV: C c= V.
        (** Contradiction with disjointness, since x0  C and x0  U. **)
        claim Hx0C: x0 :e C.
        { exact (Hx0All C HC). }
        claim Hx0V: x0 :e V.
        { exact (HCsubV x0 Hx0C). }
        claim Hx0UV2: x0 :e U :/\: V.
        { exact (binintersectI U V x0 Hx0U Hx0V). }
        claim Hx0E: x0 :e Empty.
        { rewrite <- Hdisj. exact Hx0UV2. }
        apply FalseE.
        exact (EmptyE x0 Hx0E). }
    (** If Union(F)  U, then V  U; but UV=, so V=, contradicting V. **)
    claim HVsubU: V c= U.
    { let y. assume HyV: y :e V.
      exact (HUnionSubU y (HVsub y HyV)). }
    claim HVsubEmpty: V c= Empty.
    { let y. assume HyV: y :e V.
      prove y :e Empty.
      claim HyU: y :e U.
      { exact (HVsubU y HyV). }
      claim HyUV: y :e U :/\: V.
      { exact (binintersectI U V y HyU HyV). }
      rewrite <- Hdisj.
      exact HyUV. }
    claim HVEmpty: V = Empty.
    { exact (Empty_Subq_eq V HVsubEmpty). }
    exact (HVne HVEmpty).
  - (** Case: x0  V (symmetric) **)
    assume Hx0V: x0 :e V.
    claim HUnionSubV: Union F c= V.
    { let y. assume HyUnion: y :e Union F.
      prove y :e V.
      apply (UnionE_impred F y HyUnion (y :e V)).
      let C. assume HyC: y :e C. assume HC: C :e F.
      claim HCsubUnion: C c= Union F.
      { let z. assume Hz: z :e C.
        exact (UnionI F z C Hz HC). }
      claim HeqTop: subspace_topology (Union F) (subspace_topology X Tx (Union F)) C =
                    subspace_topology X Tx C.
      { exact (ex16_1_subspace_transitive X Tx (Union F) C HTx HUnionSubX HCsubUnion). }
      claim HCconn: connected_space C (subspace_topology (Union F) (subspace_topology X Tx (Union F)) C).
      { rewrite HeqTop. exact (HF C HC). }
      claim HCside: C c= U \/ C c= V.
      { exact (connected_subset_in_separation_side (Union F) (subspace_topology X Tx (Union F)) U V C
                HtopUnion HCsubUnion HCconn HUopen HVopen Hsep). }
      apply HCside.
      + assume HCsubU: C c= U.
        claim Hx0C: x0 :e C.
        { exact (Hx0All C HC). }
        claim Hx0U: x0 :e U.
        { exact (HCsubU x0 Hx0C). }
        claim Hx0UV2: x0 :e U :/\: V.
        { exact (binintersectI U V x0 Hx0U Hx0V). }
        claim Hx0E: x0 :e Empty.
        { rewrite <- Hdisj. exact Hx0UV2. }
        apply FalseE.
        exact (EmptyE x0 Hx0E).
      + assume HCsubV: C c= V.
        exact (HCsubV y HyC). }
    claim HUne: U <> Empty.
    { exact HUne. }
    claim HUsubV: U c= V.
    { let y. assume HyU: y :e U.
      (** U  Union(F) by HUsub, and Union(F)  V by HUnionSubV **)
      exact (HUnionSubV y (HUsub y HyU)). }
    claim HUsubEmpty: U c= Empty.
    { let y. assume HyU: y :e U.
      prove y :e Empty.
      claim HyV: y :e V.
      { exact (HUsubV y HyU). }
      claim HyUV: y :e U :/\: V.
      { exact (binintersectI U V y HyU HyV). }
      rewrite <- Hdisj.
      exact HyUV. }
    claim HUEmpty: U = Empty.
    { exact (Empty_Subq_eq U HUsubEmpty). }
    exact (HUne HUEmpty).
Qed.

(** from 23 Theorem 23.4: adjoining limit points preserves connectedness **)
(** LATEX VERSION: If A is connected and A  B  cl(A), then B is connected. **)
Theorem connected_with_limit_points : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  connected_space A (subspace_topology X Tx A) ->
  A c= B -> B c= closure_of X Tx A ->
  connected_space B (subspace_topology X Tx B).
let X Tx A B.
assume HTx: topology_on X Tx.
assume HAX: A c= X.
assume HBX: B c= X.
assume HA: connected_space A (subspace_topology X Tx A).
assume HAB: A c= B.
assume HBcl: B c= closure_of X Tx A.
prove connected_space B (subspace_topology X Tx B).
prove topology_on B (subspace_topology X Tx B) /\
  ~(exists U V:set, U :e subspace_topology X Tx B /\ V :e subspace_topology X Tx B /\ separation_of B U V).
claim HtopB: topology_on B (subspace_topology X Tx B).
{ exact (subspace_topology_is_topology X Tx B HTx HBX). }
apply andI.
- exact HtopB.
- prove ~(exists U V:set, U :e subspace_topology X Tx B /\ V :e subspace_topology X Tx B /\ separation_of B U V).
  assume HsepExists: exists U V:set, U :e subspace_topology X Tx B /\ V :e subspace_topology X Tx B /\ separation_of B U V.
  prove False.
  apply HsepExists.
  let U. assume HexV: exists V:set, U :e subspace_topology X Tx B /\ V :e subspace_topology X Tx B /\ separation_of B U V.
  apply HexV.
  let V. assume HUVsep.
  claim HUVopen: U :e subspace_topology X Tx B /\ V :e subspace_topology X Tx B.
  { exact (andEL (U :e subspace_topology X Tx B /\ V :e subspace_topology X Tx B) (separation_of B U V) HUVsep). }
  claim HUopen: U :e subspace_topology X Tx B.
  { exact (andEL (U :e subspace_topology X Tx B) (V :e subspace_topology X Tx B) HUVopen). }
  claim HVopen: V :e subspace_topology X Tx B.
  { exact (andER (U :e subspace_topology X Tx B) (V :e subspace_topology X Tx B) HUVopen). }
  claim Hsep: separation_of B U V.
  { exact (andER (U :e subspace_topology X Tx B /\ V :e subspace_topology X Tx B) (separation_of B U V) HUVsep). }
  (** Parts of the separation **)
  claim Hpart1: ((((U :e Power B /\ V :e Power B) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty).
  { exact (andEL ((((U :e Power B /\ V :e Power B) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                 (U :\/: V = B) Hsep). }
  claim HAux: (((U :e Power B /\ V :e Power B) /\ U :/\: V = Empty) /\ U <> Empty).
  { exact (andEL (((U :e Power B /\ V :e Power B) /\ U :/\: V = Empty) /\ U <> Empty)
                 (V <> Empty) Hpart1). }
  claim HVne: V <> Empty.
  { exact (andER (((U :e Power B /\ V :e Power B) /\ U :/\: V = Empty) /\ U <> Empty)
                 (V <> Empty) Hpart1). }
  claim HUne: U <> Empty.
  { exact (andER ((U :e Power B /\ V :e Power B) /\ U :/\: V = Empty) (U <> Empty) HAux). }
  claim Hpowdisj: (U :e Power B /\ V :e Power B) /\ U :/\: V = Empty.
  { exact (andEL ((U :e Power B /\ V :e Power B) /\ U :/\: V = Empty) (U <> Empty) HAux). }
  claim Hpow: U :e Power B /\ V :e Power B.
  { exact (andEL (U :e Power B /\ V :e Power B) (U :/\: V = Empty) Hpowdisj). }
  claim Hdisj: U :/\: V = Empty.
  { exact (andER (U :e Power B /\ V :e Power B) (U :/\: V = Empty) Hpowdisj). }
  claim HUpow: U :e Power B.
  { exact (andEL (U :e Power B) (V :e Power B) Hpow). }
  claim HVpow: V :e Power B.
  { exact (andER (U :e Power B) (V :e Power B) Hpow). }
  claim HUsubB: U c= B.
  { exact (PowerE B U HUpow). }
  claim HVsubB: V c= B.
  { exact (PowerE B V HVpow). }
  (** Connectedness of A as a subspace of B (rewrite via subspace transitivity). **)
  claim HeqTopA: subspace_topology B (subspace_topology X Tx B) A = subspace_topology X Tx A.
  { exact (ex16_1_subspace_transitive X Tx B A HTx HBX HAB). }
  claim HAconnB: connected_space A (subspace_topology B (subspace_topology X Tx B) A).
  { rewrite HeqTopA. exact HA. }
  (** Apply Lemma 23.2 inside the space B. **)
  claim HA_side: A c= U \/ A c= V.
  { exact (connected_subset_in_separation_side B (subspace_topology X Tx B) U V A
            HtopB HAB HAconnB HUopen HVopen Hsep). }
  apply HA_side.
  - (** Case A  U: then V must be empty using B  cl(A). **)
    assume HAU: A c= U.
    (** Pick v  V. **)
    claim Hexv: exists v:set, v :e V.
    { exact (nonempty_has_element V HVne). }
    apply Hexv.
    let v. assume HvV: v :e V.
    claim HvB: v :e B.
    { exact (HVsubB v HvV). }
    claim Hvcl: v :e closure_of X Tx A.
    { exact (HBcl v HvB). }
    (** V open in the subspace, so V = W  B for some W open in X. **)
    claim HexW: exists W :e Tx, V = W :/\: B.
    { exact (SepE2 (Power B) (fun V0:set => exists W :e Tx, V0 = W :/\: B) V HVopen). }
    apply HexW.
    let W. assume HWpair.
    claim HWopen: W :e Tx.
    { exact (andEL (W :e Tx) (V = W :/\: B) HWpair). }
    claim HVeql: V = W :/\: B.
    { exact (andER (W :e Tx) (V = W :/\: B) HWpair). }
    claim HvWB: v :e W :/\: B.
    { rewrite <- HVeql. exact HvV. }
    claim HvW: v :e W.
    { exact (binintersectE1 W B v HvWB). }
    (** Use closure definition: W  A   **)
    claim Hclcond: forall U0:set, U0 :e Tx -> v :e U0 -> U0 :/\: A <> Empty.
    { exact (SepE2 X (fun x0 => forall U0:set, U0 :e Tx -> x0 :e U0 -> U0 :/\: A <> Empty) v Hvcl). }
    claim HWAnE: W :/\: A <> Empty.
    { exact (Hclcond W HWopen HvW). }
    (** Choose a  W  A. **)
    apply (nonempty_has_element (W :/\: A) HWAnE).
    let a. assume HaWA: a :e W :/\: A.
    claim HaW: a :e W.
    { exact (binintersectE1 W A a HaWA). }
    claim HaA: a :e A.
    { exact (binintersectE2 W A a HaWA). }
    claim HaB: a :e B.
    { exact (HAB a HaA). }
    claim HaWB: a :e W :/\: B.
    { exact (binintersectI W B a HaW HaB). }
    claim HaV: a :e V.
    { rewrite HVeql. exact HaWB. }
    claim HaU: a :e U.
    { exact (HAU a HaA). }
    claim HaUV: a :e U :/\: V.
    { exact (binintersectI U V a HaU HaV). }
    claim HaE: a :e Empty.
    { rewrite <- Hdisj. exact HaUV. }
    exact (EmptyE a HaE).
  - (** Case A  V: symmetric, U must be empty. **)
    assume HAV: A c= V.
    claim Hexu: exists u:set, u :e U.
    { exact (nonempty_has_element U HUne). }
    apply Hexu.
    let u. assume HuU: u :e U.
    claim HuB: u :e B.
    { exact (HUsubB u HuU). }
    claim Hucl: u :e closure_of X Tx A.
    { exact (HBcl u HuB). }
    claim HexW: exists W :e Tx, U = W :/\: B.
    { exact (SepE2 (Power B) (fun U0:set => exists W :e Tx, U0 = W :/\: B) U HUopen). }
    apply HexW.
    let W. assume HWpair.
    claim HWopen: W :e Tx.
    { exact (andEL (W :e Tx) (U = W :/\: B) HWpair). }
    claim HUeql: U = W :/\: B.
    { exact (andER (W :e Tx) (U = W :/\: B) HWpair). }
    claim HuWB: u :e W :/\: B.
    { rewrite <- HUeql. exact HuU. }
    claim HuW: u :e W.
    { exact (binintersectE1 W B u HuWB). }
    claim Hclcond: forall U0:set, U0 :e Tx -> u :e U0 -> U0 :/\: A <> Empty.
    { exact (SepE2 X (fun x0 => forall U0:set, U0 :e Tx -> x0 :e U0 -> U0 :/\: A <> Empty) u Hucl). }
    claim HWAnE: W :/\: A <> Empty.
    { exact (Hclcond W HWopen HuW). }
    apply (nonempty_has_element (W :/\: A) HWAnE).
    let a. assume HaWA: a :e W :/\: A.
    claim HaW: a :e W.
    { exact (binintersectE1 W A a HaWA). }
    claim HaA: a :e A.
    { exact (binintersectE2 W A a HaWA). }
    claim HaB: a :e B.
    { exact (HAB a HaA). }
    claim HaWB: a :e W :/\: B.
    { exact (binintersectI W B a HaW HaB). }
    claim HaU: a :e U.
    { rewrite HUeql. exact HaWB. }
    claim HaV: a :e V.
    { exact (HAV a HaA). }
    claim HaUV: a :e U :/\: V.
    { exact (binintersectI U V a HaU HaV). }
    claim HaE: a :e Empty.
    { rewrite <- Hdisj. exact HaUV. }
    exact (EmptyE a HaE).
Qed.

(** from 23 Theorem 23.5: image of a connected space is connected **)
(** LATEX VERSION: If f:XY is continuous and X is connected, then f(X) is connected (as a subspace of Y). **)
Theorem continuous_image_connected : forall X Tx Y Ty f:set,
  connected_space X Tx ->
  continuous_map X Tx Y Ty f ->
  connected_space (image_of f X) (subspace_topology Y Ty (image_of f X)).
let X Tx Y Ty f.
assume HX: connected_space X Tx.
assume Hf: continuous_map X Tx Y Ty f.
prove connected_space (image_of f X) (subspace_topology Y Ty (image_of f X)).
set Im := image_of f X.
set Tim := subspace_topology Y Ty Im.
claim HtopX: topology_on X Tx.
{ exact (connected_space_topology X Tx HX). }
claim HnoSepX: ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).
{ exact (connected_space_no_separation X Tx HX). }
claim HTy: topology_on Y Ty.
{ exact (continuous_map_topology_cod X Tx Y Ty f Hf). }
claim Hfun: function_on f X Y.
{ exact (continuous_map_function_on X Tx Y Ty f Hf). }
claim HImsubY: Im c= Y.
{ exact (image_of_sub_codomain f X Y X Hfun (Subq_ref X)). }
claim HtopIm: topology_on Im Tim.
{ exact (subspace_topology_is_topology Y Ty Im HTy HImsubY). }
prove topology_on Im Tim /\ ~(exists U V:set, U :e Tim /\ V :e Tim /\ separation_of Im U V).
apply andI.
- exact HtopIm.
- assume HsepIm: exists U V:set, U :e Tim /\ V :e Tim /\ separation_of Im U V.
  prove False.
  apply HsepIm.
  let U. assume HexV: exists V:set, U :e Tim /\ V :e Tim /\ separation_of Im U V.
  apply HexV.
  let V. assume HUV: U :e Tim /\ V :e Tim /\ separation_of Im U V.
  claim HUV0: U :e Tim /\ V :e Tim.
  { exact (andEL (U :e Tim /\ V :e Tim) (separation_of Im U V) HUV). }
  claim HUin: U :e Tim.
  { exact (andEL (U :e Tim) (V :e Tim) HUV0). }
  claim HVin: V :e Tim.
  { exact (andER (U :e Tim) (V :e Tim) HUV0). }
  claim HsepUV: separation_of Im U V.
  { exact (andER (U :e Tim /\ V :e Tim) (separation_of Im U V) HUV). }
  claim HUrep: exists U0 :e Ty, U = U0 :/\: Im.
  { exact (SepE2 (Power Im) (fun W:set => exists U0 :e Ty, W = U0 :/\: Im) U HUin). }
  claim HVrep: exists V0 :e Ty, V = V0 :/\: Im.
  { exact (SepE2 (Power Im) (fun W:set => exists V0 :e Ty, W = V0 :/\: Im) V HVin). }
  apply HUrep.
  let U0. assume HU0pair.
  claim HU0: U0 :e Ty.
  { exact (andEL (U0 :e Ty) (U = U0 :/\: Im) HU0pair). }
  claim HUeq: U = U0 :/\: Im.
  { exact (andER (U0 :e Ty) (U = U0 :/\: Im) HU0pair). }
  apply HVrep.
  let V0. assume HV0pair.
  claim HV0: V0 :e Ty.
  { exact (andEL (V0 :e Ty) (V = V0 :/\: Im) HV0pair). }
  claim HVeql: V = V0 :/\: Im.
  { exact (andER (V0 :e Ty) (V = V0 :/\: Im) HV0pair). }
  set preU := preimage_of X f U0.
  set preV := preimage_of X f V0.
  claim HpreU: preU :e Tx.
  { exact (continuous_map_preimage X Tx Y Ty f Hf U0 HU0). }
  claim HpreV: preV :e Tx.
  { exact (continuous_map_preimage X Tx Y Ty f Hf V0 HV0). }
  claim HsepX: separation_of X preU preV.
  { (** extract separation data on Im **)
    claim HsepL1: ((((U :e Power Im /\ V :e Power Im) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty).
    { exact (andEL ((((U :e Power Im /\ V :e Power Im) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                   (U :\/: V = Im) HsepUV). }
    claim Hunion: U :\/: V = Im.
    { exact (andER ((((U :e Power Im /\ V :e Power Im) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                   (U :\/: V = Im) HsepUV). }
    claim HsepL2: (((U :e Power Im /\ V :e Power Im) /\ U :/\: V = Empty) /\ U <> Empty).
    { exact (andEL (((U :e Power Im /\ V :e Power Im) /\ U :/\: V = Empty) /\ U <> Empty)
                   (V <> Empty) HsepL1). }
    claim HVne: V <> Empty.
    { exact (andER (((U :e Power Im /\ V :e Power Im) /\ U :/\: V = Empty) /\ U <> Empty)
                   (V <> Empty) HsepL1). }
    claim HsepL3: (U :e Power Im /\ V :e Power Im) /\ U :/\: V = Empty.
    { exact (andEL ((U :e Power Im /\ V :e Power Im) /\ U :/\: V = Empty)
                   (U <> Empty) HsepL2). }
    claim HUne: U <> Empty.
    { exact (andER ((U :e Power Im /\ V :e Power Im) /\ U :/\: V = Empty)
                   (U <> Empty) HsepL2). }
    claim Hpow: U :e Power Im /\ V :e Power Im.
    { exact (andEL (U :e Power Im /\ V :e Power Im) (U :/\: V = Empty) HsepL3). }
    claim Hdisj: U :/\: V = Empty.
    { exact (andER (U :e Power Im /\ V :e Power Im) (U :/\: V = Empty) HsepL3). }
    claim HU0pow: U :e Power Im.
    { exact (andEL (U :e Power Im) (V :e Power Im) Hpow). }
    claim HV0pow: V :e Power Im.
    { exact (andER (U :e Power Im) (V :e Power Im) Hpow). }
    (** show preU and preV form a separation of X **)
    claim HpreUsubX: preU c= X.
    { let x. assume Hx: x :e preU.
      exact (SepE1 X (fun x0:set => apply_fun f x0 :e U0) x Hx). }
    claim HpreVsubX: preV c= X.
    { let x. assume Hx: x :e preV.
      exact (SepE1 X (fun x0:set => apply_fun f x0 :e V0) x Hx). }
    claim HpreUPow: preU :e Power X.
    { exact (PowerI X preU HpreUsubX). }
    claim HpreVPow: preV :e Power X.
    { exact (PowerI X preV HpreVsubX). }
    claim HdisjPre: preU :/\: preV = Empty.
    { apply Empty_eq.
      let x. assume Hx: x :e preU :/\: preV.
      apply (binintersectE preU preV x Hx).
      assume HxU: x :e preU.
      assume HxV: x :e preV.
      claim HxX: x :e X.
      { exact (SepE1 X (fun x0:set => apply_fun f x0 :e U0) x HxU). }
      claim HfxU0: apply_fun f x :e U0.
      { exact (SepE2 X (fun x0:set => apply_fun f x0 :e U0) x HxU). }
      claim HfxV0: apply_fun f x :e V0.
      { exact (SepE2 X (fun x0:set => apply_fun f x0 :e V0) x HxV). }
      claim HfxIm: apply_fun f x :e Im.
      { exact (ReplI X (fun x0:set => apply_fun f x0) x HxX). }
      claim HfxU: apply_fun f x :e U.
      { rewrite HUeq.
        exact (binintersectI U0 Im (apply_fun f x) HfxU0 HfxIm). }
      claim HfxV: apply_fun f x :e V.
      { rewrite HVeql.
        exact (binintersectI V0 Im (apply_fun f x) HfxV0 HfxIm). }
      claim HfxUV: apply_fun f x :e U :/\: V.
      { exact (binintersectI U V (apply_fun f x) HfxU HfxV). }
      claim HfxE: apply_fun f x :e Empty.
      { rewrite <- Hdisj. exact HfxUV. }
      exact (EmptyE (apply_fun f x) HfxE). }
    claim HpreUne: preU <> Empty.
    { apply (nonempty_has_element U HUne).
      let y. assume HyU: y :e U.
      claim HUsubIm: U c= Im.
      { exact (PowerE Im U HU0pow). }
      claim HyIm: y :e Im.
      { exact (HUsubIm y HyU). }
      apply (ReplE_impred X (fun x0:set => apply_fun f x0) y HyIm).
      let x. assume HxX: x :e X.
      assume Hyx: y = apply_fun f x.
      claim HyU0Im: y :e U0 :/\: Im.
      { rewrite <- HUeq. exact HyU. }
      claim HyU0: y :e U0.
      { exact (binintersectE1 U0 Im y HyU0Im). }
      claim HfxU0: apply_fun f x :e U0.
      { rewrite <- Hyx. exact HyU0. }
      claim HxPreU: x :e preU.
      { exact (SepI X (fun x0:set => apply_fun f x0 :e U0) x HxX HfxU0). }
      exact (elem_implies_nonempty preU x HxPreU). }
    claim HpreVne: preV <> Empty.
    { apply (nonempty_has_element V HVne).
      let y. assume HyV: y :e V.
      claim HVsubIm: V c= Im.
      { exact (PowerE Im V HV0pow). }
      claim HyIm: y :e Im.
      { exact (HVsubIm y HyV). }
      apply (ReplE_impred X (fun x0:set => apply_fun f x0) y HyIm).
      let x. assume HxX: x :e X.
      assume Hyx: y = apply_fun f x.
      claim HyV0Im: y :e V0 :/\: Im.
      { rewrite <- HVeql. exact HyV. }
      claim HyV0: y :e V0.
      { exact (binintersectE1 V0 Im y HyV0Im). }
      claim HfxV0: apply_fun f x :e V0.
      { rewrite <- Hyx. exact HyV0. }
      claim HxPreV: x :e preV.
      { exact (SepI X (fun x0:set => apply_fun f x0 :e V0) x HxX HfxV0). }
      exact (elem_implies_nonempty preV x HxPreV). }
    claim HunionPre: preU :\/: preV = X.
    { apply set_ext.
      - let x. assume Hx: x :e preU :\/: preV.
        apply (binunionE preU preV x Hx).
        + assume HxU: x :e preU.
          exact (SepE1 X (fun x0:set => apply_fun f x0 :e U0) x HxU).
        + assume HxV: x :e preV.
          exact (SepE1 X (fun x0:set => apply_fun f x0 :e V0) x HxV).
      - let x. assume HxX: x :e X.
        prove x :e preU :\/: preV.
        claim HfxIm: apply_fun f x :e Im.
        { exact (ReplI X (fun x0:set => apply_fun f x0) x HxX). }
        claim HfxUV: apply_fun f x :e U :\/: V.
        { rewrite Hunion. exact HfxIm. }
        apply (binunionE U V (apply_fun f x) HfxUV).
        + assume HfxU: apply_fun f x :e U.
          claim HfxU0Im: apply_fun f x :e U0 :/\: Im.
          { rewrite <- HUeq. exact HfxU. }
          claim HfxU0: apply_fun f x :e U0.
          { exact (binintersectE1 U0 Im (apply_fun f x) HfxU0Im). }
          exact (binunionI1 preU preV x (SepI X (fun x0:set => apply_fun f x0 :e U0) x HxX HfxU0)).
        + assume HfxV: apply_fun f x :e V.
          claim HfxV0Im: apply_fun f x :e V0 :/\: Im.
          { rewrite <- HVeql. exact HfxV. }
          claim HfxV0: apply_fun f x :e V0.
          { exact (binintersectE1 V0 Im (apply_fun f x) HfxV0Im). }
          exact (binunionI2 preU preV x (SepI X (fun x0:set => apply_fun f x0 :e V0) x HxX HfxV0)). }
    prove (((((preU :e Power X /\ preV :e Power X) /\ preU :/\: preV = Empty) /\ preU <> Empty) /\ preV <> Empty) /\ preU :\/: preV = X).
    apply andI.
    * apply andI.
      { apply andI.
        - apply andI.
          + apply andI.
            { exact HpreUPow. }
            { exact HpreVPow. }
          + exact HdisjPre.
        - exact HpreUne. }
      { exact HpreVne. }
    * exact HunionPre. }
  apply HnoSepX.
  witness preU. witness preV.
  prove preU :e Tx /\ preV :e Tx /\ separation_of X preU preV.
  apply andI.
  - apply andI.
    + exact HpreU.
    + exact HpreV.
  - exact HsepX.
Qed.

(** from 24 Corollary 24.2: the real line is connected **)
(** LATEX VERSION: Corollary 24.2: The real line R is connected (and so are intervals and rays in R). **)
(** LATEX VERSION: The real line with the standard topology is connected. **)
Theorem interval_connected : connected_space R R_standard_topology.
prove topology_on R R_standard_topology /\
  ~(exists U V:set, U :e R_standard_topology /\ V :e R_standard_topology /\ separation_of R U V).
apply andI.
- exact R_standard_topology_is_topology.
- assume Hsep: exists U V:set, U :e R_standard_topology /\ V :e R_standard_topology /\ separation_of R U V.
  (** standard proof uses order properties of R to contradict existence of a separation **)
  admit.
Qed.

(** from 24 Theorem 24.3: intermediate value theorem (order topology) **)
(** LATEX VERSION: If f:XY is continuous, X is connected, and r lies between f(a) and f(b), then cX with f(c)=r. **)
Definition between_in_order : set -> set -> set -> set -> prop := fun Y u r v =>
  (order_rel Y u r /\ order_rel Y r v)
  \/ (order_rel Y v r /\ order_rel Y r u)
  \/ r = u
  \/ r = v.

(** Helper: introduction rule for between_in_order using u <= r <= v **)
Theorem between_in_orderI_left : forall Y u r v:set,
  order_rel Y u r ->
  order_rel Y r v ->
  between_in_order Y u r v.
let Y u r v.
assume Hur: order_rel Y u r.
assume Hrv: order_rel Y r v.
prove between_in_order Y u r v.
prove (order_rel Y u r /\ order_rel Y r v)
  \/ (order_rel Y v r /\ order_rel Y r u)
  \/ r = u
  \/ r = v.
apply orIL.
apply orIL.
apply orIL.
exact (andI (order_rel Y u r) (order_rel Y r v) Hur Hrv).
Qed.

(** Helper: introduction rule for between_in_order using v <= r <= u **)
Theorem between_in_orderI_right : forall Y u r v:set,
  order_rel Y v r ->
  order_rel Y r u ->
  between_in_order Y u r v.
let Y u r v.
assume Hvr: order_rel Y v r.
assume Hru: order_rel Y r u.
prove between_in_order Y u r v.
prove (order_rel Y u r /\ order_rel Y r v)
  \/ (order_rel Y v r /\ order_rel Y r u)
  \/ r = u
  \/ r = v.
apply orIL.
apply orIL.
apply orIR.
exact (andI (order_rel Y v r) (order_rel Y r u) Hvr Hru).
Qed.

(** Helper: introduction rule for between_in_order when r = u **)
Theorem between_in_orderI_eq_left : forall Y u v:set,
  between_in_order Y u u v.
let Y u v.
prove between_in_order Y u u v.
prove (order_rel Y u u /\ order_rel Y u v)
  \/ (order_rel Y v u /\ order_rel Y u u)
  \/ u = u
  \/ u = v.
apply orIL.
apply orIR.
reflexivity.
Qed.

(** Helper: introduction rule for between_in_order when r = v **)
Theorem between_in_orderI_eq_right : forall Y u v:set,
  between_in_order Y u v v.
let Y u v.
prove between_in_order Y u v v.
prove (order_rel Y u v /\ order_rel Y v v)
  \/ (order_rel Y v v /\ order_rel Y v u)
  \/ v = u
  \/ v = v.
apply orIR.
reflexivity.
Qed.

(** from 24 Theorem 24.3: intermediate value theorem (order topology) **)
(** LATEX VERSION: If f is continuous and X is connected, every value between f(a) and f(b) is attained. **)
(** LATEX VERSION: Intermediate value theorem, stated as a derived theorem wrapper. **)
Theorem intermediate_value_theorem : forall X Tx Y f a b r:set,
  connected_space X Tx ->
  continuous_map X Tx Y (order_topology Y) f ->
  a :e X -> b :e X -> r :e Y ->
  between_in_order Y (apply_fun f a) r (apply_fun f b) ->
  exists c:set, c :e X /\ apply_fun f c = r.
let X Tx Y f a b r.
assume Hconn: connected_space X Tx.
assume Hcont: continuous_map X Tx Y (order_topology Y) f.
assume Ha: a :e X.
assume Hb: b :e X.
assume Hr: r :e Y.
assume Hbetw: between_in_order Y (apply_fun f a) r (apply_fun f b).
prove exists c:set, c :e X /\ apply_fun f c = r.
set Im := image_of f X.
set Tim := subspace_topology Y (order_topology Y) Im.
claim HImconn: connected_space Im Tim.
{ exact (continuous_image_connected X Tx Y (order_topology Y) f Hconn Hcont). }
(** If r equals one of the endpoint values then we can witness immediately; the strict-between case is left admitted **)
apply (Hbetw (exists c:set, c :e X /\ apply_fun f c = r)).
- assume Hcases1:
    ((order_rel Y (apply_fun f a) r /\ order_rel Y r (apply_fun f b))
      \/ (order_rel Y (apply_fun f b) r /\ order_rel Y r (apply_fun f a)))
    \/ r = apply_fun f a.
  apply (Hcases1 (exists c:set, c :e X /\ apply_fun f c = r)).
  + assume Hstrict:
      (order_rel Y (apply_fun f a) r /\ order_rel Y r (apply_fun f b))
      \/ (order_rel Y (apply_fun f b) r /\ order_rel Y r (apply_fun f a)).
    admit.
  + assume HrEqFa: r = apply_fun f a.
    witness a.
    apply andI.
    * exact Ha.
    * rewrite <- HrEqFa.
      reflexivity.
- assume HrEqFb: r = apply_fun f b.
  witness b.
  apply andI.
  * exact Hb.
  * rewrite <- HrEqFb.
    reflexivity.
Qed.

(** from 24: connected subspaces of  are intervals **) 
(** LATEX VERSION: A connected subset of the real line contains every point between any two of its points. **)
Theorem connected_subsets_real_are_intervals : forall A:set,
  A c= R ->
  connected_space A (subspace_topology R R_standard_topology A) ->
  forall x y z:set, x :e A -> y :e A -> z :e R ->
    (Rlt x z /\ Rlt z y \/ Rlt y z /\ Rlt z x) -> z :e A.
let A.
assume HA: A c= R.
assume Hconn: connected_space A (subspace_topology R R_standard_topology A).
let x y z.
assume Hx: x :e A.
assume Hy: y :e A.
assume Hz: z :e R.
assume Hbetw: Rlt x z /\ Rlt z y \/ Rlt y z /\ Rlt z x.
prove z :e A.
apply (xm (z :e A)).
- assume HzA: z :e A.
  exact HzA.
- assume HznotA: z /:e A.
  (** If z  A, define U = A(-,z) and V = A(z,), show they separate A. **)
  set U := {t :e A|Rlt t z}.
  set V := {t :e A|Rlt z t}.
  (** Extract no separations from connectedness of A. **)
  claim Hnosep: ~(exists U0 V0:set,
      U0 :e subspace_topology R R_standard_topology A /\
      V0 :e subspace_topology R R_standard_topology A /\
      separation_of A U0 V0).
  { exact (connected_space_no_separation A (subspace_topology R R_standard_topology A) Hconn). }
  (** Show U and V are in the subspace topology on A. **)
  claim HUinTy: U :e subspace_topology R R_standard_topology A.
  { (** witness the open left ray in R **)
    set L := {t :e R|Rlt t z}.
    claim HLopen: L :e R_standard_topology.
    { exact (open_left_ray_in_R_standard_topology z Hz). }
    claim HUeq: U = L :/\: A.
    { apply set_ext.
      - let t. assume Ht: t :e U.
        prove t :e L :/\: A.
        claim HtA: t :e A.
        { exact (SepE1 A (fun t0:set => Rlt t0 z) t Ht). }
        claim HtR: t :e R.
        { exact (HA t HtA). }
        claim Htlt: Rlt t z.
        { exact (SepE2 A (fun t0:set => Rlt t0 z) t Ht). }
        claim HtL: t :e L.
        { exact (SepI R (fun t0:set => Rlt t0 z) t HtR Htlt). }
        exact (binintersectI L A t HtL HtA).
      - let t. assume Ht: t :e L :/\: A.
        prove t :e U.
        claim HtL: t :e L.
        { exact (binintersectE1 L A t Ht). }
        claim HtA: t :e A.
        { exact (binintersectE2 L A t Ht). }
        claim Htlt: Rlt t z.
        { exact (SepE2 R (fun t0:set => Rlt t0 z) t HtL). }
        exact (SepI A (fun t0:set => Rlt t0 z) t HtA Htlt). }
    (** Now package membership in the subspace topology. **)
    claim HUpow: U :e Power A.
    { apply PowerI.
      let t. assume Ht: t :e U.
      exact (SepE1 A (fun t0:set => Rlt t0 z) t Ht). }
    claim Hex: exists W :e R_standard_topology, U = W :/\: A.
    { witness L.
      apply andI.
      - exact HLopen.
      - exact HUeq. }
    exact (SepI (Power A) (fun U0:set => exists W :e R_standard_topology, U0 = W :/\: A) U HUpow Hex). }
  claim HVinTy: V :e subspace_topology R R_standard_topology A.
  { set Rray := {t :e R|Rlt z t}.
    claim HRopen: Rray :e R_standard_topology.
    { exact (open_ray_in_R_standard_topology z Hz). }
    claim HVeql: V = Rray :/\: A.
    { apply set_ext.
      - let t. assume Ht: t :e V.
        prove t :e Rray :/\: A.
        claim HtA: t :e A.
        { exact (SepE1 A (fun t0:set => Rlt z t0) t Ht). }
        claim HtR: t :e R.
        { exact (HA t HtA). }
        claim Htlt: Rlt z t.
        { exact (SepE2 A (fun t0:set => Rlt z t0) t Ht). }
        claim HtRray: t :e Rray.
        { exact (SepI R (fun t0:set => Rlt z t0) t HtR Htlt). }
        exact (binintersectI Rray A t HtRray HtA).
      - let t. assume Ht: t :e Rray :/\: A.
        prove t :e V.
        claim HtRray: t :e Rray.
        { exact (binintersectE1 Rray A t Ht). }
        claim HtA: t :e A.
        { exact (binintersectE2 Rray A t Ht). }
        claim Htlt: Rlt z t.
        { exact (SepE2 R (fun t0:set => Rlt z t0) t HtRray). }
        exact (SepI A (fun t0:set => Rlt z t0) t HtA Htlt). }
    claim HVpow: V :e Power A.
    { apply PowerI.
      let t. assume Ht: t :e V.
      exact (SepE1 A (fun t0:set => Rlt z t0) t Ht). }
    claim Hex: exists W :e R_standard_topology, V = W :/\: A.
    { witness Rray.
      apply andI.
      - exact HRopen.
      - exact HVeql. }
    exact (SepI (Power A) (fun U0:set => exists W :e R_standard_topology, U0 = W :/\: A) V HVpow Hex). }
  (** Build a separation_of A U V. **)
  claim HsepUV: separation_of A U V.
  { (** U,V  A **)
    claim HUsubA: U c= A.
    { let t. assume Ht: t :e U.
      exact (SepE1 A (fun t0:set => Rlt t0 z) t Ht). }
    claim HVsubA: V c= A.
    { let t. assume Ht: t :e V.
      exact (SepE1 A (fun t0:set => Rlt z t0) t Ht). }
    claim HUpowA: U :e Power A.
    { exact (PowerI A U HUsubA). }
    claim HVpowA: V :e Power A.
    { exact (PowerI A V HVsubA). }
    (** disjointness **)
    claim Hdisj: U :/\: V = Empty.
    { apply Empty_eq.
      let t. assume Ht: t :e U :/\: V.
      apply (binintersectE U V t Ht).
      assume HtU: t :e U.
      assume HtV: t :e V.
      claim HtA: t :e A.
      { exact (SepE1 A (fun t0:set => Rlt t0 z) t HtU). }
      claim HtR: t :e R.
      { exact (HA t HtA). }
      claim Hlt1: Rlt t z.
      { exact (SepE2 A (fun t0:set => Rlt t0 z) t HtU). }
      claim Hlt2: Rlt z t.
      { exact (SepE2 A (fun t0:set => Rlt z t0) t HtV). }
      claim Htt: Rlt t t.
      { exact (Rlt_tra t z t Hlt1 Hlt2). }
      apply FalseE.
      exact ((not_Rlt_refl t HtR) Htt). }
    (** Nonemptiness of U and V using x,y around z **)
    claim HUne: U <> Empty.
    { apply (xm (Rlt x z /\ Rlt z y)).
      - assume Hxzzy: Rlt x z /\ Rlt z y.
        claim Hxz: Rlt x z.
        { exact (andEL (Rlt x z) (Rlt z y) Hxzzy). }
        claim HxU: x :e U.
        { exact (SepI A (fun t0:set => Rlt t0 z) x Hx Hxz). }
        exact (elem_implies_nonempty U x HxU).
      - assume Hnot.
        (** then use the other disjunct from Hbetw **)
        claim Hyz: Rlt y z.
        { apply Hbetw.
          assume Hxzzy: Rlt x z /\ Rlt z y.
          apply FalseE.
          exact (Hnot Hxzzy).
          assume Hyzzx: Rlt y z /\ Rlt z x.
          exact (andEL (Rlt y z) (Rlt z x) Hyzzx). }
        claim HyU: y :e U.
        { exact (SepI A (fun t0:set => Rlt t0 z) y Hy Hyz). }
        exact (elem_implies_nonempty U y HyU). }
    claim HVne: V <> Empty.
    { apply (xm (Rlt x z /\ Rlt z y)).
      - assume Hxzzy: Rlt x z /\ Rlt z y.
        claim Hzy: Rlt z y.
        { exact (andER (Rlt x z) (Rlt z y) Hxzzy). }
        claim HyV: y :e V.
        { exact (SepI A (fun t0:set => Rlt z t0) y Hy Hzy). }
        exact (elem_implies_nonempty V y HyV).
      - assume Hnot.
        claim Hzx: Rlt z x.
        { apply Hbetw.
          assume Hxzzy: Rlt x z /\ Rlt z y.
          apply FalseE.
          exact (Hnot Hxzzy).
          assume Hyzzx: Rlt y z /\ Rlt z x.
          exact (andER (Rlt y z) (Rlt z x) Hyzzx). }
        claim HxV: x :e V.
        { exact (SepI A (fun t0:set => Rlt z t0) x Hx Hzx). }
        exact (elem_implies_nonempty V x HxV). }
    (** Union is all of A since z  A and order is trichotomous. **)
    claim Hunion: U :\/: V = A.
    { apply set_ext.
      - let t. assume Ht: t :e U :\/: V.
        prove t :e A.
        apply (binunionE U V t Ht).
        + assume HtU. exact (SepE1 A (fun t0:set => Rlt t0 z) t HtU).
        + assume HtV. exact (SepE1 A (fun t0:set => Rlt z t0) t HtV).
      - let t. assume HtA: t :e A.
        prove t :e U :\/: V.
        claim HtR: t :e R.
        { exact (HA t HtA). }
        claim HtS: SNo t.
        { exact (real_SNo t HtR). }
        claim HzS: SNo z.
        { exact (real_SNo z Hz). }
        apply (SNoLt_trichotomy_or_impred t z HtS HzS (t :e U :\/: V)).
        + (** t < z -> t in U **)
          assume Hlt: t < z.
          claim Htlt: Rlt t z.
          { exact (RltI t z HtR Hz Hlt). }
          exact (binunionI1 U V t (SepI A (fun t0:set => Rlt t0 z) t HtA Htlt)).
        + (** t = z -> contradiction since z  A **)
          assume Heq: t = z.
          claim HzA: z :e A.
          { rewrite <- Heq. exact HtA. }
          apply FalseE.
          exact (HznotA HzA).
        + (** z < t -> t in V **)
          assume Hlt: z < t.
          claim Hzt: Rlt z t.
          { exact (RltI z t Hz HtR Hlt). }
          exact (binunionI2 U V t (SepI A (fun t0:set => Rlt z t0) t HtA Hzt)). }
    (** Package separation_of A U V **)
    prove (((((U :e Power A /\ V :e Power A) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty) /\ U :\/: V = A).
    apply andI.
    - prove ((((U :e Power A /\ V :e Power A) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty).
      apply andI.
      + prove (((U :e Power A /\ V :e Power A) /\ U :/\: V = Empty) /\ U <> Empty).
        apply andI.
        * prove (U :e Power A /\ V :e Power A) /\ U :/\: V = Empty.
          apply andI.
          { apply andI.
            - exact HUpowA.
            - exact HVpowA. }
          { exact Hdisj. }
        * exact HUne.
      + exact HVne.
    - exact Hunion. }
  (** Contradict connectedness **)
  apply FalseE.
  apply Hnosep.
  witness U.
  witness V.
  (** goal is (UTy  VTy)  separation_of A U V **)
  apply andI.
  - apply andI.
    + exact HUinTy.
    + exact HVinTy.
  - exact HsepUV.
Qed.

(** Helper: image of x mapped to (x,y0) is setprod X {y0} **)
Theorem image_of_id_const_is_slice : forall X y0:set,
  image_of (pair_map X {(x,x)|x :e X} (const_fun X y0)) X = setprod X {y0}.
let X y0.
prove image_of (pair_map X {(x,x)|x :e X} (const_fun X y0)) X = setprod X {y0}.
apply set_ext.
- let p. assume Hp: p :e image_of (pair_map X {(x,x)|x :e X} (const_fun X y0)) X.
  prove p :e setprod X {y0}.
  (** unfold image_of **)
  set f := pair_map X {(x,x)|x :e X} (const_fun X y0).
  claim HpRepl: p :e Repl X (fun a => apply_fun f a).
  { exact Hp. }
  apply (ReplE_impred X (fun a:set => apply_fun f a) p HpRepl).
  let a. assume HaX: a :e X.
  assume Heq: p = apply_fun f a.
  rewrite Heq.
  claim Hfa: apply_fun f a = (apply_fun {(x,x)|x :e X} a, apply_fun (const_fun X y0) a).
  { exact (pair_map_apply X X {y0} {(x,x)|x :e X} (const_fun X y0) a HaX). }
  claim Hid: apply_fun {(x,x)|x :e X} a = a.
  { exact (identity_function_apply X a HaX). }
  claim Hc: apply_fun (const_fun X y0) a = y0.
  { exact (const_fun_apply X y0 a HaX). }
  rewrite Hfa.
  rewrite Hid.
  rewrite Hc.
  exact (tuple_2_setprod X {y0} a HaX y0 (SingI y0)).
- let p. assume Hp: p :e setprod X {y0}.
  prove p :e image_of (pair_map X {(x,x)|x :e X} (const_fun X y0)) X.
  set f := pair_map X {(x,x)|x :e X} (const_fun X y0).
  (** extract coordinates **)
  claim Hp0X: (p 0) :e X.
  { exact (ap0_Sigma X (fun _:set => {y0}) p Hp). }
  claim Hp1Sing: (p 1) :e {y0}.
  { exact (ap1_Sigma X (fun _:set => {y0}) p Hp). }
  claim Hp1eq: (p 1) = y0.
  { exact (singleton_elem (p 1) y0 Hp1Sing). }
  claim Heta: p = (p 0, p 1).
  { exact (setprod_eta X {y0} p Hp). }
  (** show p is in the image by choosing a = p0 **)
  prove p :e Repl X (fun a => apply_fun f a).
  claim Hfp0: apply_fun f (p 0) = (apply_fun {(x,x)|x :e X} (p 0), apply_fun (const_fun X y0) (p 0)).
  { exact (pair_map_apply X X {y0} {(x,x)|x :e X} (const_fun X y0) (p 0) Hp0X). }
  claim Hid0: apply_fun {(x,x)|x :e X} (p 0) = (p 0).
  { exact (identity_function_apply X (p 0) Hp0X). }
  claim Hc0: apply_fun (const_fun X y0) (p 0) = y0.
  { exact (const_fun_apply X y0 (p 0) Hp0X). }
	  claim Hfp0eq: apply_fun f (p 0) = (p 0, p 1).
	  { rewrite Hfp0.
	    rewrite Hid0.
	    rewrite Hc0.
	    rewrite Hp1eq.
	    reflexivity. }
  claim Hp_as_image: p = apply_fun f (p 0).
  { rewrite Heta at 1.
    rewrite Hfp0eq.
    reflexivity. }
  rewrite Hp_as_image.
  exact (ReplI X (fun a:set => apply_fun f a) (p 0) Hp0X).
Qed.

(** Helper: slice X times {y0} is connected when X is connected **)
Theorem slice_X_connected : forall X Tx Y Ty y0:set,
  connected_space X Tx -> topology_on Y Ty -> y0 :e Y ->
  connected_space (setprod X {y0})
    (subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod X {y0})).
let X Tx Y Ty y0.
assume HX: connected_space X Tx.
assume HTy: topology_on Y Ty.
assume Hy0: y0 :e Y.
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
              (~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V))
              HX). }
set idX := {(x,x)|x :e X}.
set c := const_fun X y0.
set f := pair_map X idX c.
claim Hid: continuous_map X Tx X Tx idX.
{ exact (identity_continuous X Tx HTx). }
claim Hc: continuous_map X Tx Y Ty c.
{ exact (const_fun_continuous X Tx Y Ty y0 HTx HTy Hy0). }
claim Hf: continuous_map X Tx (setprod X Y) (product_topology X Tx Y Ty) f.
{ exact (maps_into_products X Tx X Tx Y Ty idX c Hid Hc). }
claim Himg: connected_space (image_of f X)
  (subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (image_of f X)).
{ exact (continuous_image_connected X Tx (setprod X Y) (product_topology X Tx Y Ty) f HX Hf). }
prove connected_space (setprod X {y0})
    (subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod X {y0})).
rewrite <- (image_of_id_const_is_slice X y0).
exact Himg.
Qed.

(** Helper: image of y mapped to (x0,y) is setprod {x0} Y **)
Theorem image_of_const_id_is_slice : forall Y x0:set,
  image_of (pair_map Y (const_fun Y x0) {(y,y)|y :e Y}) Y = setprod {x0} Y.
let Y x0.
set idY := {(y,y)|y :e Y}.
prove image_of (pair_map Y (const_fun Y x0) idY) Y = setprod {x0} Y.
apply set_ext.
- let p. assume Hp: p :e image_of (pair_map Y (const_fun Y x0) idY) Y.
  prove p :e setprod {x0} Y.
  set f := pair_map Y (const_fun Y x0) idY.
  claim HpRepl: p :e Repl Y (fun a => apply_fun f a).
  { exact Hp. }
  apply (ReplE_impred Y (fun a:set => apply_fun f a) p HpRepl).
  let a. assume HaY: a :e Y.
  assume Heq: p = apply_fun f a.
  rewrite Heq.
  claim Hfa: apply_fun f a = (apply_fun (const_fun Y x0) a, apply_fun idY a).
  { exact (pair_map_apply Y {x0} Y (const_fun Y x0) idY a HaY). }
  claim Hc: apply_fun (const_fun Y x0) a = x0.
  { exact (const_fun_apply Y x0 a HaY). }
  claim Hid: apply_fun idY a = a.
  { exact (identity_function_apply Y a HaY). }
  rewrite Hfa.
  rewrite Hc.
  rewrite Hid.
  exact (tuple_2_setprod {x0} Y x0 (SingI x0) a HaY).
- let p. assume Hp: p :e setprod {x0} Y.
  prove p :e image_of (pair_map Y (const_fun Y x0) idY) Y.
  set f := pair_map Y (const_fun Y x0) idY.
  claim Hp0Sing: (p 0) :e {x0}.
  { exact (ap0_Sigma {x0} (fun _:set => Y) p Hp). }
  claim Hp1Y: (p 1) :e Y.
  { exact (ap1_Sigma {x0} (fun _:set => Y) p Hp). }
  claim Hp0eq: (p 0) = x0.
  { exact (singleton_elem (p 0) x0 Hp0Sing). }
  claim Heta: p = (p 0, p 1).
  { exact (setprod_eta {x0} Y p Hp). }
  prove p :e Repl Y (fun a => apply_fun f a).
  claim Hfp1: apply_fun f (p 1) = (apply_fun (const_fun Y x0) (p 1), apply_fun idY (p 1)).
  { exact (pair_map_apply Y {x0} Y (const_fun Y x0) idY (p 1) Hp1Y). }
  claim Hc1: apply_fun (const_fun Y x0) (p 1) = x0.
  { exact (const_fun_apply Y x0 (p 1) Hp1Y). }
  claim Hid1: apply_fun idY (p 1) = (p 1).
  { exact (identity_function_apply Y (p 1) Hp1Y). }
  claim Hfp1eq: apply_fun f (p 1) = (p 0, p 1).
  { rewrite Hfp1.
    rewrite Hc1.
    rewrite Hid1.
    rewrite <- Hp0eq at 1.
    reflexivity. }
  claim Hp_as_image: p = apply_fun f (p 1).
  { rewrite Heta at 1.
    rewrite <- Hfp1eq.
    reflexivity. }
  rewrite Hp_as_image.
  exact (ReplI Y (fun a:set => apply_fun f a) (p 1) Hp1Y).
Qed.

(** Helper: y maps to (x0,y) is a homeomorphism onto the slice {x0} times Y **)
Theorem homeomorphism_const_id_slice : forall X Tx Y Ty x0:set,
  topology_on X Tx -> topology_on Y Ty -> x0 :e X ->
  homeomorphism Y Ty (setprod {x0} Y)
    (subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod {x0} Y))
    (pair_map Y (const_fun Y x0) {(y,y)|y :e Y}).
let X Tx Y Ty x0.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
assume Hx0X: x0 :e X.
set idY := {(y,y)|y :e Y}.
set c := const_fun Y x0.
set f := pair_map Y c idY.
set Slice := setprod {x0} Y.
set Tslice := subspace_topology (setprod X Y) (product_topology X Tx Y Ty) Slice.

claim HTprod: topology_on (setprod X Y) (product_topology X Tx Y Ty).
{ exact (product_topology_is_topology X Tx Y Ty HTx HTy). }

claim Hc: continuous_map Y Ty X Tx c.
{ exact (const_fun_continuous Y Ty X Tx x0 HTy HTx Hx0X). }
claim Hid: continuous_map Y Ty Y Ty idY.
{ exact (identity_continuous Y Ty HTy). }
claim HfProd: continuous_map Y Ty (setprod X Y) (product_topology X Tx Y Ty) f.
{ exact (maps_into_products Y Ty X Tx Y Ty c idY Hc Hid). }

claim HSingSub: {x0} c= X.
{ exact (singleton_subset x0 X Hx0X). }
claim HSlicesub: Slice c= setprod X Y.
{ exact (setprod_Subq {x0} Y X Y HSingSub (Subq_ref Y)). }
claim Himg: forall y:set, y :e Y -> apply_fun f y :e Slice.
{ let y. assume HyY: y :e Y.
  prove apply_fun f y :e Slice.
  claim Happ: apply_fun f y = (apply_fun c y, apply_fun idY y).
  { exact (pair_map_apply Y X Y c idY y HyY). }
  claim Hcapp: apply_fun c y = x0.
  { exact (const_fun_apply Y x0 y HyY). }
  claim Hidapp: apply_fun idY y = y.
  { exact (identity_function_apply Y y HyY). }
  rewrite Happ.
  rewrite Hcapp.
  rewrite Hidapp.
  exact (tuple_2_setprod {x0} Y x0 (SingI x0) y HyY). }
claim Hf: continuous_map Y Ty Slice Tslice f.
{ exact (continuous_map_range_restrict Y Ty (setprod X Y) (product_topology X Tx Y Ty) f Slice
          HfProd HSlicesub Himg). }

claim HprojPair:
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y) /\
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y).
{ exact (projection_maps_continuous X Tx Y Ty HTx HTy). }
claim Hproj2:
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y).
{ exact (andER (continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y))
               (continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y))
               HprojPair). }
claim Hg:
  continuous_map Slice Tslice Y Ty (projection_map2 X Y).
{ exact (continuous_on_subspace (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y) Slice
          HTprod HSlicesub Hproj2). }

prove continuous_map Y Ty Slice Tslice f /\
  exists g:set, continuous_map Slice Tslice Y Ty g /\
    (forall x:set, x :e Y -> apply_fun g (apply_fun f x) = x) /\
    (forall y:set, y :e Slice -> apply_fun f (apply_fun g y) = y).
apply andI.
- exact Hf.
- witness (projection_map2 X Y).
  apply andI.
  + apply andI.
    * exact Hg.
    * (** g after f is identity on Y **)
      let y. assume HyY: y :e Y.
      prove apply_fun (projection_map2 X Y) (apply_fun f y) = y.
      claim Happf: apply_fun f y = (apply_fun c y, apply_fun idY y).
      { exact (pair_map_apply Y X Y c idY y HyY). }
      claim Hcapp: apply_fun c y = x0.
      { exact (const_fun_apply Y x0 y HyY). }
      claim Hidapp: apply_fun idY y = y.
      { exact (identity_function_apply Y y HyY). }
      claim HxyXY: (x0,y) :e setprod X Y.
      { exact (tuple_2_setprod X Y x0 Hx0X y HyY). }
      rewrite Happf.
      rewrite Hcapp.
      rewrite Hidapp.
      claim Happ2: apply_fun (projection_map2 X Y) (x0,y) = (x0,y) 1.
      { exact (projection2_apply X Y (x0,y) HxyXY). }
      rewrite Happ2.
      exact (tuple_2_1_eq x0 y).
  + (** f after g is identity on Slice **)
    let p. assume HpSlice: p :e Slice.
    prove apply_fun f (apply_fun (projection_map2 X Y) p) = p.
    claim HpXY: p :e setprod X Y.
    { exact (HSlicesub p HpSlice). }
    claim Hp1Y: (p 1) :e Y.
    { exact (ap1_Sigma {x0} (fun _:set => Y) p HpSlice). }
    claim Happ2: apply_fun (projection_map2 X Y) p = p 1.
    { exact (projection2_apply X Y p HpXY). }
    rewrite Happ2.
    claim Happf: apply_fun f (p 1) = (apply_fun c (p 1), apply_fun idY (p 1)).
    { exact (pair_map_apply Y X Y c idY (p 1) Hp1Y). }
    claim Hcapp: apply_fun c (p 1) = x0.
    { exact (const_fun_apply Y x0 (p 1) Hp1Y). }
    claim Hidapp: apply_fun idY (p 1) = (p 1).
    { exact (identity_function_apply Y (p 1) Hp1Y). }
    rewrite Happf.
    rewrite Hcapp.
    rewrite Hidapp.
    claim Hp0Sing: (p 0) :e {x0}.
    { exact (ap0_Sigma {x0} (fun _:set => Y) p HpSlice). }
    claim Hp0eq: (p 0) = x0.
    { exact (singleton_elem (p 0) x0 Hp0Sing). }
    claim Heta: p = (p 0, p 1).
    { exact (setprod_eta {x0} Y p HpSlice). }
    claim HtupleEq: (p 0, p 1) = p.
    { rewrite <- Heta.
      reflexivity. }
    rewrite <- Hp0eq at 1.
    exact HtupleEq.
Qed.

(** Helper: slice {x0} times Y is connected when Y is connected **)
Theorem slice_Y_connected : forall X Tx Y Ty x0:set,
  connected_space Y Ty -> topology_on X Tx -> x0 :e X ->
  connected_space (setprod {x0} Y)
    (subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod {x0} Y)).
let X Tx Y Ty x0.
assume HY: connected_space Y Ty.
assume HTx: topology_on X Tx.
assume Hx0: x0 :e X.
claim HTy: topology_on Y Ty.
{ exact (andEL (topology_on Y Ty)
              (~(exists U V:set, U :e Ty /\ V :e Ty /\ separation_of Y U V))
              HY). }
set idY := {(y,y)|y :e Y}.
set c := const_fun Y x0.
set f := pair_map Y c idY.
claim Hc: continuous_map Y Ty X Tx c.
{ exact (const_fun_continuous Y Ty X Tx x0 HTy HTx Hx0). }
claim Hid: continuous_map Y Ty Y Ty idY.
{ exact (identity_continuous Y Ty HTy). }
claim Hf: continuous_map Y Ty (setprod X Y) (product_topology X Tx Y Ty) f.
{ exact (maps_into_products Y Ty X Tx Y Ty c idY Hc Hid). }
claim Himg: connected_space (image_of f Y)
  (subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (image_of f Y)).
{ exact (continuous_image_connected Y Ty (setprod X Y) (product_topology X Tx Y Ty) f HY Hf). }
prove connected_space (setprod {x0} Y)
    (subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod {x0} Y)).
rewrite <- (image_of_const_id_is_slice Y x0).
exact Himg.
Qed.

(** from 23 Theorem 23.6: finite products of connected spaces are connected **) 
(** LATEX VERSION: The product of two connected spaces is connected in the product topology. **)
Theorem finite_product_connected : forall X Tx Y Ty:set,
  connected_space X Tx -> connected_space Y Ty ->
  connected_space (setprod X Y) (product_topology X Tx Y Ty).
let X Tx Y Ty.
assume HX: connected_space X Tx.
assume HY: connected_space Y Ty.
prove connected_space (setprod X Y) (product_topology X Tx Y Ty).
(** Helper: product with empty set is empty (left) **)
claim Hsetprod_empty_left: forall Y0:set, setprod Empty Y0 = Empty.
{ let Y0.
  apply set_ext.
  - let p. assume Hp: p :e setprod Empty Y0.
    prove p :e Empty.
    apply FalseE.
    claim Hp0: (p 0) :e Empty.
    { exact (ap0_Sigma Empty (fun _:set => Y0) p Hp). }
    exact (EmptyE (p 0) Hp0).
  - let p. assume Hp: p :e Empty.
    prove p :e setprod Empty Y0.
    apply FalseE.
    exact (EmptyE p Hp). }
(** Helper: product with empty set is empty (right) **)
claim Hsetprod_empty_right: forall X0:set, setprod X0 Empty = Empty.
{ let X0.
  apply set_ext.
  - let p. assume Hp: p :e setprod X0 Empty.
    prove p :e Empty.
    apply FalseE.
    claim Hp1: (p 1) :e Empty.
    { exact (ap1_Sigma X0 (fun _:set => Empty) p Hp). }
    exact (EmptyE (p 1) Hp1).
  - let p. assume Hp: p :e Empty.
    prove p :e setprod X0 Empty.
    apply FalseE.
    exact (EmptyE p Hp). }

(** Extract the topology parts **)
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
              (~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V))
              HX). }
claim HTy: topology_on Y Ty.
{ exact (andEL (topology_on Y Ty)
              (~(exists U V:set, U :e Ty /\ V :e Ty /\ separation_of Y U V))
              HY). }

(** Case split on emptiness of X and Y **)
apply xm (X = Empty).
- assume HXEmpty: X = Empty.
  rewrite HXEmpty.
  rewrite (Hsetprod_empty_left Y).
  prove topology_on Empty (product_topology Empty Tx Y Ty) /\
    ~(exists U V:set,
      U :e product_topology Empty Tx Y Ty /\
      V :e product_topology Empty Tx Y Ty /\
      separation_of Empty U V).
  apply andI.
  - (** topology_on Empty (...) **)
    claim HTx0: topology_on Empty Tx.
    { rewrite <- HXEmpty. exact HTx. }
    prove topology_on Empty (product_topology Empty Tx Y Ty).
    rewrite <- (Hsetprod_empty_left Y) at 1.
    exact (product_topology_is_topology Empty Tx Y Ty HTx0 HTy).
  - (** no separation of Empty **)
    prove ~(exists U V:set,
      U :e product_topology Empty Tx Y Ty /\
      V :e product_topology Empty Tx Y Ty /\
      separation_of Empty U V).
    assume Hsep: exists U V:set,
      U :e product_topology Empty Tx Y Ty /\
      V :e product_topology Empty Tx Y Ty /\
      separation_of Empty U V.
    apply Hsep.
    let U. assume HexV: exists V:set,
      U :e product_topology Empty Tx Y Ty /\
      V :e product_topology Empty Tx Y Ty /\
      separation_of Empty U V.
    apply HexV.
    let V. assume HUVsep.
    claim HsepUV: separation_of Empty U V.
    { exact (andER (U :e product_topology Empty Tx Y Ty /\ V :e product_topology Empty Tx Y Ty)
                   (separation_of Empty U V) HUVsep). }
    claim Hpart1: ((((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty).
    { exact (andEL ((((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                   (U :\/: V = Empty) HsepUV). }
    claim Hpart2: ((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) /\ U <> Empty.
    { exact (andEL (((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) /\ U <> Empty)
                   (V <> Empty) Hpart1). }
    claim HUne: U <> Empty.
    { exact (andER ((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) (U <> Empty) Hpart2). }
    claim Hpow: (U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty.
    { exact (andEL ((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) (U <> Empty) Hpart2). }
    claim HpowUV: U :e Power Empty /\ V :e Power Empty.
    { exact (andEL (U :e Power Empty /\ V :e Power Empty) (U :/\: V = Empty) Hpow). }
    claim HUsub: U c= Empty.
    { exact (PowerE Empty U (andEL (U :e Power Empty) (V :e Power Empty) HpowUV)). }
    claim HUeq: U = Empty.
    { exact (Empty_Subq_eq U HUsub). }
    exact (HUne HUeq).
- assume HXNonEmpty: X <> Empty.
  apply xm (Y = Empty).
  + assume HYEmpty: Y = Empty.
    rewrite HYEmpty.
    rewrite (Hsetprod_empty_right X).
    prove topology_on Empty (product_topology X Tx Empty Ty) /\
      ~(exists U V:set,
        U :e product_topology X Tx Empty Ty /\
        V :e product_topology X Tx Empty Ty /\
        separation_of Empty U V).
    apply andI.
    - (** topology_on Empty (...) **)
      claim HTy0: topology_on Empty Ty.
      { rewrite <- HYEmpty. exact HTy. }
      prove topology_on Empty (product_topology X Tx Empty Ty).
      rewrite <- (Hsetprod_empty_right X) at 1.
      exact (product_topology_is_topology X Tx Empty Ty HTx HTy0).
    - (** no separation of Empty **)
      prove ~(exists U V:set,
        U :e product_topology X Tx Empty Ty /\
        V :e product_topology X Tx Empty Ty /\
        separation_of Empty U V).
      assume Hsep: exists U V:set,
        U :e product_topology X Tx Empty Ty /\
        V :e product_topology X Tx Empty Ty /\
        separation_of Empty U V.
      apply Hsep.
      let U. assume HexV: exists V:set,
        U :e product_topology X Tx Empty Ty /\
        V :e product_topology X Tx Empty Ty /\
        separation_of Empty U V.
      apply HexV.
      let V. assume HUVsep.
      claim HsepUV: separation_of Empty U V.
      { exact (andER (U :e product_topology X Tx Empty Ty /\ V :e product_topology X Tx Empty Ty)
                     (separation_of Empty U V) HUVsep). }
      claim Hpart1: ((((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty).
      { exact (andEL ((((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                     (U :\/: V = Empty) HsepUV). }
      claim Hpart2: ((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) /\ U <> Empty.
      { exact (andEL (((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) /\ U <> Empty)
                     (V <> Empty) Hpart1). }
      claim HUne: U <> Empty.
      { exact (andER ((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) (U <> Empty) Hpart2). }
      claim Hpow: (U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty.
      { exact (andEL ((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) (U <> Empty) Hpart2). }
      claim HpowUV: U :e Power Empty /\ V :e Power Empty.
      { exact (andEL (U :e Power Empty /\ V :e Power Empty) (U :/\: V = Empty) Hpow). }
      claim HUsub: U c= Empty.
      { exact (PowerE Empty U (andEL (U :e Power Empty) (V :e Power Empty) HpowUV)). }
      claim HUeq: U = Empty.
      { exact (Empty_Subq_eq U HUsub). }
      exact (HUne HUeq).
  + assume HYNonEmpty: Y <> Empty.
    (** Nonempty X and Y: union of connected slices with a common point **)
    apply (nonempty_has_element X HXNonEmpty).
    let x0. assume Hx0X: x0 :e X.
    apply (nonempty_has_element Y HYNonEmpty).
    let y0. assume Hy0Y: y0 :e Y.
    set Top := product_topology X Tx Y Ty.
    set Hhor := setprod X {y0}.
    set F := {setprod {x} Y :\/: Hhor|x :e X}.

    claim HTprod: topology_on (setprod X Y) Top.
    { exact (product_topology_is_topology X Tx Y Ty HTx HTy). }

    (** Each member of F is a subset of XY **)
    claim HFsub: forall C:set, C :e F -> C c= setprod X Y.
    { let C. assume HC: C :e F.
      apply (ReplE_impred X (fun x:set => setprod {x} Y :\/: Hhor) C HC).
      let x. assume HxX: x :e X.
      assume HCeq: C = setprod {x} Y :\/: Hhor.
      rewrite HCeq.
      prove (setprod {x} Y :\/: Hhor) c= setprod X Y.
      let p. assume Hp: p :e setprod {x} Y :\/: Hhor.
      prove p :e setprod X Y.
      apply (binunionE' (setprod {x} Y) Hhor p (p :e setprod X Y)).
      - assume HpA: p :e setprod {x} Y.
        claim Hxsub: {x} c= X.
        { exact (singleton_subset x X HxX). }
        claim HYsub: Y c= Y.
        { exact (Subq_ref Y). }
        exact (setprod_Subq {x} Y X Y Hxsub HYsub p HpA).
      - assume HpB: p :e Hhor.
        claim HXsub: X c= X.
        { exact (Subq_ref X). }
        claim Hy0sub: {y0} c= Y.
        { exact (singleton_subset y0 Y Hy0Y). }
        exact (setprod_Subq X {y0} X Y HXsub Hy0sub p HpB).
      - exact Hp. }

    (** Each member of F is connected **)
    claim HFconn: forall C:set, C :e F ->
      connected_space C (subspace_topology (setprod X Y) Top C).
    { let C. assume HC: C :e F.
      apply (ReplE_impred X (fun x:set => setprod {x} Y :\/: Hhor) C HC).
      let x. assume HxX: x :e X.
      assume HCeq: C = setprod {x} Y :\/: Hhor.
      rewrite HCeq.
      set A := setprod {x} Y.
      set B := Hhor.
      claim HAconn: connected_space A (subspace_topology (setprod X Y) Top A).
      { exact (slice_Y_connected X Tx Y Ty x HY HTx HxX). }
      claim HBconn: connected_space B (subspace_topology (setprod X Y) Top B).
      { exact (slice_X_connected X Tx Y Ty y0 HX HTy Hy0Y). }
      claim HABsub: forall D:set, D :e {A,B} -> D c= setprod X Y.
      { let D. assume HD: D :e {A,B}.
        apply (UPairE D A B HD (D c= setprod X Y)).
        - assume HDa: D = A. rewrite HDa.
          claim Hxsub: {x} c= X.
          { exact (singleton_subset x X HxX). }
          claim HYsub: Y c= Y.
          { exact (Subq_ref Y). }
          exact (setprod_Subq {x} Y X Y Hxsub HYsub).
        - assume HDb: D = B. rewrite HDb.
          claim HXsub: X c= X.
          { exact (Subq_ref X). }
          claim Hy0sub: {y0} c= Y.
          { exact (singleton_subset y0 Y Hy0Y). }
          exact (setprod_Subq X {y0} X Y HXsub Hy0sub). }

      (** Use union_connected_common_point on {A,B} with common point (x,y0) **)
      claim HunionAB: connected_space (Union {A,B})
        (subspace_topology (setprod X Y) Top (Union {A,B})).
      { apply (union_connected_common_point (setprod X Y) Top {A,B} HTprod).
        - exact HABsub.
        - let D. assume HD: D :e {A,B}.
          apply (UPairE D A B HD (connected_space D (subspace_topology (setprod X Y) Top D))).
          + assume HDa: D = A. rewrite HDa. exact HAconn.
          + assume HDb: D = B. rewrite HDb. exact HBconn.
        - witness (x,y0).
          let D. assume HD: D :e {A,B}.
          apply (UPairE D A B HD ((x,y0) :e D)).
          + assume HDa: D = A.
            rewrite HDa.
            exact (tuple_2_setprod {x} Y x (SingI x) y0 Hy0Y).
          + assume HDb: D = B.
            rewrite HDb.
            exact (tuple_2_setprod X {y0} x HxX y0 (SingI y0)). }

      (** Rewrite Union {A,B} into A :\/: B **)
      rewrite (binunion_eq_Union_pair A B).
      exact HunionAB. }

    (** Common point for all members of F: (x0,y0) lies in the horizontal slice **)
    claim Hcommon: exists p:set, forall C:set, C :e F -> p :e C.
    { witness (x0,y0).
      let C. assume HC: C :e F.
      apply (ReplE_impred X (fun x:set => setprod {x} Y :\/: Hhor) C HC).
      let x. assume HxX: x :e X.
      assume HCeq: C = setprod {x} Y :\/: Hhor.
      rewrite HCeq.
      prove (x0,y0) :e setprod {x} Y :\/: Hhor.
      apply binunionI2.
      exact (tuple_2_setprod X {y0} x0 Hx0X y0 (SingI y0)). }

    (** Connectedness of the union Union F **)
    claim HconnUnion: connected_space (Union F)
      (subspace_topology (setprod X Y) Top (Union F)).
    { exact (union_connected_common_point (setprod X Y) Top F HTprod HFsub HFconn Hcommon). }

    (** Union F is all of XY **)
    claim HFpow: F c= Power (setprod X Y).
    { let C. assume HC: C :e F.
      prove C :e Power (setprod X Y).
      exact (PowerI (setprod X Y) C (HFsub C HC)). }
    claim HUnionSub: Union F c= setprod X Y.
    { exact (Union_Power (setprod X Y) F HFpow). }
    claim HSubUnion: setprod X Y c= Union F.
    { let p. assume Hp: p :e setprod X Y.
      claim Hp0X: (p 0) :e X.
      { exact (ap0_Sigma X (fun _:set => Y) p Hp). }
      claim Hp1Y: (p 1) :e Y.
      { exact (ap1_Sigma X (fun _:set => Y) p Hp). }
      set C0 := setprod {p 0} Y :\/: Hhor.
      claim HC0F: C0 :e F.
      { exact (ReplI X (fun x:set => setprod {x} Y :\/: Hhor) (p 0) Hp0X). }
      prove p :e Union F.
      apply (UnionI F p C0).
      - prove p :e C0.
        apply binunionI1.
      claim Heta: p = (p 0, p 1).
      { exact (setprod_eta X Y p Hp). }
      rewrite Heta at 1.
      exact (tuple_2_setprod {p 0} Y (p 0) (SingI (p 0)) (p 1) Hp1Y).
      - exact HC0F. }
    claim HUnionEq: Union F = setprod X Y.
    { apply set_ext.
      - exact HUnionSub.
      - exact HSubUnion. }

    (** Transfer connectedness from the union to XY, then collapse subspace topology **)
    claim HconnAmbientSub: connected_space (setprod X Y)
      (subspace_topology (setprod X Y) Top (setprod X Y)).
    { rewrite <- HUnionEq.
      exact HconnUnion. }
    claim Hsubeq: subspace_topology (setprod X Y) Top (setprod X Y) = Top.
    { exact (subspace_topology_whole (setprod X Y) Top HTprod). }
    rewrite <- Hsubeq.
    exact HconnAmbientSub.
Qed.

(** from 23 Example 6: R^ in the box topology is not connected **) 
(** LATEX VERSION: Partition R^ into bounded and unbounded sequences; each is open in the box topology using (a_i-1,a_i+1). **)
Definition R_omega_space : set :=
  product_space omega (const_space_family omega R R_standard_topology).
Definition R_omega_box_topology : set :=
  box_topology omega (const_space_family omega R R_standard_topology).
Definition R_omega_product_topology : set :=
  product_topology_full omega (const_space_family omega R R_standard_topology).

Definition bounded_sequence_Romega : set -> prop := fun f =>
  exists M:set, M :e R /\ forall n:set, n :e omega -> apply_fun f n :e open_interval (minus_SNo M) M.

Definition bounded_sequences_Romega : set :=
  {f :e R_omega_space | bounded_sequence_Romega f}.

Definition unbounded_sequence_Romega : set -> prop := fun f =>
  forall M:set, M :e R -> exists n:set, n :e omega /\ ~(apply_fun f n :e open_interval (minus_SNo M) M).

Definition unbounded_sequences_Romega : set :=
  {f :e R_omega_space | unbounded_sequence_Romega f}.

(** Helper: coordinates of a point in R_omega_space are real numbers **)
Theorem Romega_coord_in_R : forall f i:set,
  f :e R_omega_space ->
  i :e omega ->
  apply_fun f i :e R.
let f i.
assume Hf: f :e R_omega_space.
assume Hi: i :e omega.
prove apply_fun f i :e R.
set Xi := const_space_family omega R R_standard_topology.
claim Hfprop: function_on f omega (space_family_union omega Xi) /\
              forall j:set, j :e omega -> apply_fun f j :e space_family_set Xi j.
{ exact (SepE2 (Power (setprod omega (space_family_union omega Xi)))
               (fun f0:set => function_on f0 omega (space_family_union omega Xi) /\
                 forall j:set, j :e omega -> apply_fun f0 j :e space_family_set Xi j)
               f
               Hf). }
claim Hcoords: forall j:set, j :e omega -> apply_fun f j :e space_family_set Xi j.
{ exact (andER (function_on f omega (space_family_union omega Xi))
               (forall j:set, j :e omega -> apply_fun f j :e space_family_set Xi j)
               Hfprop). }
claim Hfi: apply_fun f i :e space_family_set Xi i.
{ exact (Hcoords i Hi). }
claim HXi: apply_fun Xi i = (R, R_standard_topology).
{ exact (const_space_family_apply omega R R_standard_topology i Hi). }
claim Hset: space_family_set Xi i = R.
{ claim Hdef: space_family_set Xi i = (apply_fun Xi i) 0.
  { reflexivity. }
  rewrite Hdef.
  rewrite HXi.
  exact (tuple_2_0_eq R R_standard_topology). }
 rewrite <- Hset.
 exact Hfi.
Qed.

(** Helper: bounded and unbounded sequence collections lie in Power R_omega_space **)
Theorem bounded_sequences_Romega_in_Power : bounded_sequences_Romega :e Power R_omega_space.
prove bounded_sequences_Romega :e Power R_omega_space.
apply PowerI.
let f. assume Hf: f :e bounded_sequences_Romega.
prove f :e R_omega_space.
exact (SepE1 R_omega_space (fun f0:set => bounded_sequence_Romega f0) f Hf).
Qed.

Theorem unbounded_sequences_Romega_in_Power : unbounded_sequences_Romega :e Power R_omega_space.
prove unbounded_sequences_Romega :e Power R_omega_space.
apply PowerI.
let f. assume Hf: f :e unbounded_sequences_Romega.
prove f :e R_omega_space.
exact (SepE1 R_omega_space (fun f0:set => unbounded_sequence_Romega f0) f Hf).
Qed.

(** Helper: bounded/unbounded sets are intended to form a separation in the box topology **)
Theorem bounded_sequences_in_Romega_box_topology :
  bounded_sequences_Romega :e R_omega_box_topology.
prove bounded_sequences_Romega :e R_omega_box_topology.
set Xi := const_space_family omega R R_standard_topology.
set X := product_space omega Xi.
set B := box_basis omega Xi.
set TU := topology_family_union omega Xi.
prove bounded_sequences_Romega :e generated_topology X B.
claim Hpow: bounded_sequences_Romega :e Power X.
{ exact bounded_sequences_Romega_in_Power. }
claim Hcond: forall f :e bounded_sequences_Romega, exists b :e B, f :e b /\ b c= bounded_sequences_Romega.
{ let f. assume Hf: f :e bounded_sequences_Romega.
  claim HfX: f :e X.
  { exact (SepE1 R_omega_space (fun f0:set => bounded_sequence_Romega f0) f Hf). }
  claim Hb: bounded_sequence_Romega f.
  { exact (SepE2 R_omega_space (fun f0:set => bounded_sequence_Romega f0) f Hf). }
  apply Hb.
  let M. assume HMconj.
  claim HMR: M :e R.
  { exact (andEL (M :e R) (forall n:set, n :e omega -> apply_fun f n :e open_interval (minus_SNo M) M) HMconj). }
  claim Hbnd: forall n:set, n :e omega -> apply_fun f n :e open_interval (minus_SNo M) M.
  { exact (andER (M :e R) (forall n:set, n :e omega -> apply_fun f n :e open_interval (minus_SNo M) M) HMconj). }

  claim H0omega: 0 :e omega.
  { exact (nat_p_omega 0 nat_0). }
  claim Hf0In: apply_fun f 0 :e open_interval (minus_SNo M) M.
  { exact (Hbnd 0 H0omega). }
  claim Hf0prop: Rlt (minus_SNo M) (apply_fun f 0) /\ Rlt (apply_fun f 0) M.
  { exact (SepE2 R (fun x0:set => Rlt (minus_SNo M) x0 /\ Rlt x0 M) (apply_fun f 0) Hf0In). }
  claim Hm0: Rlt (minus_SNo M) (apply_fun f 0).
  { exact (andEL (Rlt (minus_SNo M) (apply_fun f 0)) (Rlt (apply_fun f 0) M) Hf0prop). }
  claim H0m: Rlt (apply_fun f 0) M.
  { exact (andER (Rlt (minus_SNo M) (apply_fun f 0)) (Rlt (apply_fun f 0) M) Hf0prop). }
  claim HMlt: Rlt (minus_SNo M) M.
  { exact (Rlt_tra (minus_SNo M) (apply_fun f 0) M Hm0 H0m). }
  claim HopenI: open_interval (minus_SNo M) M :e R_standard_topology.
  { exact (open_interval_in_R_standard_topology (minus_SNo M) M HMlt). }

  claim HX0: apply_fun Xi 0 = (R, R_standard_topology).
  { exact (const_space_family_apply omega R R_standard_topology 0 H0omega). }
  claim HT0: space_family_topology Xi 0 = R_standard_topology.
  { claim Hdef: space_family_topology Xi 0 = (apply_fun Xi 0) 1.
    { reflexivity. }
    rewrite Hdef.
    rewrite HX0.
    exact (tuple_2_1_eq R R_standard_topology). }
  claim HTfam: R_standard_topology :e {space_family_topology Xi i|i :e omega}.
  { apply ReplEq omega (fun i:set => space_family_topology Xi i) R_standard_topology.
    assume _ H2. apply H2.
    prove exists i :e omega, R_standard_topology = space_family_topology Xi i.
    witness 0.
    apply andI.
    - exact H0omega.
    - symmetry.
      exact HT0. }
  claim HintervalTU: open_interval (minus_SNo M) M :e TU.
  { exact (UnionI {space_family_topology Xi i|i :e omega}
                 (open_interval (minus_SNo M) M)
                 R_standard_topology
                 HopenI
                 HTfam). }

  set Um := const_fun omega (open_interval (minus_SNo M) M).
  set bM := {g :e X | forall i:set, i :e omega -> apply_fun g i :e apply_fun Um i}.

  witness bM.
  apply andI.
  - (** bM :e box_basis omega Xi **)
    prove bM :e B.
    claim HbMsub: bM c= X.
    { let g. assume Hg: g :e bM.
      prove g :e X.
      exact (SepE1 X (fun g0:set => forall i:set, i :e omega -> apply_fun g0 i :e apply_fun Um i) g Hg). }
    claim HbMpow: bM :e Power X.
    { exact (PowerI X bM HbMsub). }
    claim HUmfun: function_on Um omega TU.
    { claim Htot: total_function_on Um omega TU.
      { exact (const_fun_total_function_on omega TU (open_interval (minus_SNo M) M) HintervalTU). }
      exact (total_function_on_function_on Um omega TU Htot). }
    claim HUmcoords: forall i:set, i :e omega -> apply_fun Um i :e space_family_topology Xi i.
    { let i. assume Hi: i :e omega.
      prove apply_fun Um i :e space_family_topology Xi i.
      claim Happ: apply_fun Um i = open_interval (minus_SNo M) M.
      { exact (const_fun_apply omega (open_interval (minus_SNo M) M) i Hi). }
      rewrite Happ.
      claim HXi: apply_fun Xi i = (R, R_standard_topology).
      { exact (const_space_family_apply omega R R_standard_topology i Hi). }
      claim HTi: space_family_topology Xi i = R_standard_topology.
      { claim Hdef: space_family_topology Xi i = (apply_fun Xi i) 1.
        { reflexivity. }
        rewrite Hdef.
        rewrite HXi.
        exact (tuple_2_1_eq R R_standard_topology). }
      rewrite HTi.
      exact HopenI. }
    claim HexU: exists U:set, function_on U omega TU /\
      (forall i:set, i :e omega -> apply_fun U i :e space_family_topology Xi i) /\
      bM = {f :e X | forall i:set, i :e omega -> apply_fun f i :e apply_fun U i}.
    { witness Um.
      apply andI.
      - apply andI.
        + exact HUmfun.
        + exact HUmcoords.
      - reflexivity. }
    exact (SepI (Power X)
                (fun B0:set => exists U:set, function_on U omega TU /\
                  (forall i:set, i :e omega -> apply_fun U i :e space_family_topology Xi i) /\
                  B0 = {f :e X | forall i:set, i :e omega -> apply_fun f i :e apply_fun U i})
                bM
                HbMpow
                HexU).
  - apply andI.
    + (** f :e bM **)
      prove f :e bM.
      apply (SepI X (fun g0:set => forall i:set, i :e omega -> apply_fun g0 i :e apply_fun Um i) f HfX).
      let i. assume Hi: i :e omega.
      prove apply_fun f i :e apply_fun Um i.
      claim Happ: apply_fun Um i = open_interval (minus_SNo M) M.
      { exact (const_fun_apply omega (open_interval (minus_SNo M) M) i Hi). }
      rewrite Happ.
      exact (Hbnd i Hi).
    + (** bM c= bounded_sequences_Romega **)
      let g. assume Hg: g :e bM.
      prove g :e bounded_sequences_Romega.
      claim HgX: g :e X.
      { exact (SepE1 X (fun g0:set => forall i:set, i :e omega -> apply_fun g0 i :e apply_fun Um i) g Hg). }
      claim Hgprop: forall i:set, i :e omega -> apply_fun g i :e apply_fun Um i.
      { exact (SepE2 X (fun g0:set => forall i:set, i :e omega -> apply_fun g0 i :e apply_fun Um i) g Hg). }
      claim Hbseqg: bounded_sequence_Romega g.
      { claim Hbndg: forall n:set, n :e omega -> apply_fun g n :e open_interval (minus_SNo M) M.
        { let n. assume HnO: n :e omega.
          claim Hgn: apply_fun g n :e apply_fun Um n.
          { exact (Hgprop n HnO). }
          claim Happ: apply_fun Um n = open_interval (minus_SNo M) M.
          { exact (const_fun_apply omega (open_interval (minus_SNo M) M) n HnO). }
          rewrite <- Happ.
          exact Hgn. }
        exact (fun P Hp => Hp M (andI (M :e R)
                                      (forall n:set, n :e omega -> apply_fun g n :e open_interval (minus_SNo M) M)
                                      HMR
                                      Hbndg)). }
      exact (SepI R_omega_space (fun h:set => bounded_sequence_Romega h) g HgX Hbseqg). }
exact (SepI (Power X)
            (fun U0:set => forall x :e U0, exists b :e B, x :e b /\ b c= U0)
            bounded_sequences_Romega
            Hpow
            Hcond).
Qed.

Theorem unbounded_sequences_in_Romega_box_topology :
  unbounded_sequences_Romega :e R_omega_box_topology.
prove unbounded_sequences_Romega :e R_omega_box_topology.
set Xi := const_space_family omega R R_standard_topology.
set X := product_space omega Xi.
set B := box_basis omega Xi.
set TU := topology_family_union omega Xi.
prove unbounded_sequences_Romega :e generated_topology X B.
claim Hpow: unbounded_sequences_Romega :e Power X.
{ exact unbounded_sequences_Romega_in_Power. }
claim Hcond: forall f :e unbounded_sequences_Romega, exists b :e B, f :e b /\ b c= unbounded_sequences_Romega.
{ let f. assume Hf: f :e unbounded_sequences_Romega.
  claim HfX: f :e X.
  { exact (SepE1 R_omega_space (fun f0:set => unbounded_sequence_Romega f0) f Hf). }
  claim Huf: unbounded_sequence_Romega f.
  { exact (SepE2 R_omega_space (fun f0:set => unbounded_sequence_Romega f0) f Hf). }

  claim H0omega: 0 :e omega.
  { exact (nat_p_omega 0 nat_0). }
  claim HX0: apply_fun Xi 0 = (R, R_standard_topology).
  { exact (const_space_family_apply omega R R_standard_topology 0 H0omega). }
  claim HT0: space_family_topology Xi 0 = R_standard_topology.
  { claim Hdef: space_family_topology Xi 0 = (apply_fun Xi 0) 1.
    { reflexivity. }
    rewrite Hdef.
    rewrite HX0.
    exact (tuple_2_1_eq R R_standard_topology). }
  claim HTfam: R_standard_topology :e {space_family_topology Xi i|i :e omega}.
  { apply ReplEq omega (fun i:set => space_family_topology Xi i) R_standard_topology.
    assume _ H2. apply H2.
    prove exists i :e omega, R_standard_topology = space_family_topology Xi i.
    witness 0.
    apply andI.
    - exact H0omega.
    - symmetry.
      exact HT0. }

  claim Hm1R : minus_SNo 1 :e R.
  { exact (real_minus_SNo 1 real_1). }
  claim Hm1S : SNo (minus_SNo 1).
  { exact (real_SNo (minus_SNo 1) Hm1R). }
  claim Hm1lt1 : minus_SNo 1 < 1.
  { exact (SNoLt_tra (minus_SNo 1) 0 1 Hm1S SNo_0 SNo_1 minus_1_lt_0 SNoLt_0_1). }

  set U := {(i, open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                              (add_SNo (apply_fun f i) 1)) | i :e omega}.
  set bU := {g :e X | forall i:set, i :e omega -> apply_fun g i :e apply_fun U i}.

  claim HUapply: forall i:set, i :e omega ->
    apply_fun U i = open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                                 (add_SNo (apply_fun f i) 1).
  { let i. assume Hi: i :e omega.
    prove apply_fun U i = open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                                     (add_SNo (apply_fun f i) 1).
    prove Eps_i (fun z => (i, z) :e U) =
      open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                    (add_SNo (apply_fun f i) 1).
    claim H1: (i, open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                               (add_SNo (apply_fun f i) 1)) :e U.
    { exact (ReplI omega (fun i0:set =>
              (i0, open_interval (add_SNo (apply_fun f i0) (minus_SNo 1))
                                 (add_SNo (apply_fun f i0) 1))) i Hi). }
    claim H2: (i, Eps_i (fun z => (i, z) :e U)) :e U.
    { exact (Eps_i_ax (fun z => (i, z) :e U)
                      (open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                                     (add_SNo (apply_fun f i) 1))
                      H1). }
    apply (ReplE_impred omega (fun i0:set =>
              (i0, open_interval (add_SNo (apply_fun f i0) (minus_SNo 1))
                                 (add_SNo (apply_fun f i0) 1)))
              (i, Eps_i (fun z => (i, z) :e U)) H2).
    let i0.
    assume Hi0: i0 :e omega.
    assume Heq: (i, Eps_i (fun z => (i, z) :e U)) =
                (i0, open_interval (add_SNo (apply_fun f i0) (minus_SNo 1))
                                   (add_SNo (apply_fun f i0) 1)).
    claim Hi_eq: i = i0.
    { rewrite <- (tuple_2_0_eq i (Eps_i (fun z => (i, z) :e U))).
      rewrite <- (tuple_2_0_eq i0 (open_interval (add_SNo (apply_fun f i0) (minus_SNo 1))
                                                 (add_SNo (apply_fun f i0) 1))).
      rewrite Heq.
      reflexivity. }
    claim Hz_eq: Eps_i (fun z => (i, z) :e U) =
                 open_interval (add_SNo (apply_fun f i0) (minus_SNo 1))
                               (add_SNo (apply_fun f i0) 1).
    { rewrite <- (tuple_2_1_eq i (Eps_i (fun z => (i, z) :e U))).
      rewrite <- (tuple_2_1_eq i0 (open_interval (add_SNo (apply_fun f i0) (minus_SNo 1))
                                                 (add_SNo (apply_fun f i0) 1))).
      rewrite Heq.
      reflexivity. }
    rewrite Hz_eq.
    rewrite <- Hi_eq.
    reflexivity. }

  witness bU.
  apply andI.
  - (** bU :e box_basis omega Xi **)
    prove bU :e B.
    claim HbUsub: bU c= X.
    { let g. assume Hg: g :e bU.
      prove g :e X.
      exact (SepE1 X (fun g0:set => forall i:set, i :e omega -> apply_fun g0 i :e apply_fun U i) g Hg). }
    claim HbUpow: bU :e Power X.
    { exact (PowerI X bU HbUsub). }
    claim HUfun: function_on U omega TU.
    { let i. assume Hi: i :e omega.
      prove apply_fun U i :e TU.
      claim HfRi: apply_fun f i :e R.
      { exact (Romega_coord_in_R f i HfX Hi). }
      claim HfSi: SNo (apply_fun f i).
      { exact (real_SNo (apply_fun f i) HfRi). }
      claim HaR: add_SNo (apply_fun f i) (minus_SNo 1) :e R.
      { exact (real_add_SNo (apply_fun f i) HfRi (minus_SNo 1) Hm1R). }
      claim HbR: add_SNo (apply_fun f i) 1 :e R.
      { exact (real_add_SNo (apply_fun f i) HfRi 1 real_1). }
      claim HaS: SNo (add_SNo (apply_fun f i) (minus_SNo 1)).
      { exact (real_SNo (add_SNo (apply_fun f i) (minus_SNo 1)) HaR). }
      claim HbS: SNo (add_SNo (apply_fun f i) 1).
      { exact (real_SNo (add_SNo (apply_fun f i) 1) HbR). }
      claim Hlt: add_SNo (apply_fun f i) (minus_SNo 1) < add_SNo (apply_fun f i) 1.
      { exact (add_SNo_Lt2 (apply_fun f i) (minus_SNo 1) 1 HfSi Hm1S SNo_1 Hm1lt1). }
      claim HRlt: Rlt (add_SNo (apply_fun f i) (minus_SNo 1)) (add_SNo (apply_fun f i) 1).
      { exact (RltI (add_SNo (apply_fun f i) (minus_SNo 1))
                    (add_SNo (apply_fun f i) 1)
                    HaR
                    HbR
                    Hlt). }
      claim HopenI: open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                                  (add_SNo (apply_fun f i) 1) :e R_standard_topology.
      { exact (open_interval_in_R_standard_topology
                (add_SNo (apply_fun f i) (minus_SNo 1))
                (add_SNo (apply_fun f i) 1)
                HRlt). }
      claim HappUi: apply_fun U i =
        open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                      (add_SNo (apply_fun f i) 1).
      { exact (HUapply i Hi). }
      rewrite HappUi.
      exact (UnionI {space_family_topology Xi j|j :e omega}
                    (open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                                   (add_SNo (apply_fun f i) 1))
                    R_standard_topology
                    HopenI
                    HTfam). }
    claim HUcoords: forall i:set, i :e omega -> apply_fun U i :e space_family_topology Xi i.
    { let i. assume Hi: i :e omega.
      prove apply_fun U i :e space_family_topology Xi i.
      claim HXi: apply_fun Xi i = (R, R_standard_topology).
      { exact (const_space_family_apply omega R R_standard_topology i Hi). }
      claim HTi: space_family_topology Xi i = R_standard_topology.
      { claim Hdef: space_family_topology Xi i = (apply_fun Xi i) 1.
        { reflexivity. }
        rewrite Hdef.
        rewrite HXi.
        exact (tuple_2_1_eq R R_standard_topology). }
      rewrite HTi.
      claim HfRi: apply_fun f i :e R.
      { exact (Romega_coord_in_R f i HfX Hi). }
      claim HfSi: SNo (apply_fun f i).
      { exact (real_SNo (apply_fun f i) HfRi). }
      claim HaR: add_SNo (apply_fun f i) (minus_SNo 1) :e R.
      { exact (real_add_SNo (apply_fun f i) HfRi (minus_SNo 1) Hm1R). }
      claim HbR: add_SNo (apply_fun f i) 1 :e R.
      { exact (real_add_SNo (apply_fun f i) HfRi 1 real_1). }
      claim Hlt: add_SNo (apply_fun f i) (minus_SNo 1) < add_SNo (apply_fun f i) 1.
      { exact (add_SNo_Lt2 (apply_fun f i) (minus_SNo 1) 1 HfSi Hm1S SNo_1 Hm1lt1). }
      claim HRlt: Rlt (add_SNo (apply_fun f i) (minus_SNo 1)) (add_SNo (apply_fun f i) 1).
      { exact (RltI (add_SNo (apply_fun f i) (minus_SNo 1))
                    (add_SNo (apply_fun f i) 1)
                    HaR
                    HbR
                    Hlt). }
      claim HopenI: open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                                  (add_SNo (apply_fun f i) 1) :e R_standard_topology.
      { exact (open_interval_in_R_standard_topology
                (add_SNo (apply_fun f i) (minus_SNo 1))
                (add_SNo (apply_fun f i) 1)
                HRlt). }
      claim HappUi: apply_fun U i =
        open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                      (add_SNo (apply_fun f i) 1).
      { exact (HUapply i Hi). }
      rewrite HappUi.
      exact HopenI. }
    claim HexU: exists U0:set, function_on U0 omega TU /\
      (forall i:set, i :e omega -> apply_fun U0 i :e space_family_topology Xi i) /\
      bU = {f0 :e X | forall i:set, i :e omega -> apply_fun f0 i :e apply_fun U0 i}.
    { witness U.
      apply andI.
      - apply andI.
        + exact HUfun.
        + exact HUcoords.
      - reflexivity. }
    exact (SepI (Power X)
                (fun B0:set => exists U0:set, function_on U0 omega TU /\
                  (forall i:set, i :e omega -> apply_fun U0 i :e space_family_topology Xi i) /\
                  B0 = {f0 :e X | forall i:set, i :e omega -> apply_fun f0 i :e apply_fun U0 i})
                bU
                HbUpow
                HexU).
  - apply andI.
    + (** f :e bU **)
      prove f :e bU.
      apply (SepI X (fun g0:set => forall i:set, i :e omega -> apply_fun g0 i :e apply_fun U i) f HfX).
      let i. assume Hi: i :e omega.
      prove apply_fun f i :e apply_fun U i.
      claim HfRi: apply_fun f i :e R.
      { exact (Romega_coord_in_R f i HfX Hi). }
      claim HfSi: SNo (apply_fun f i).
      { exact (real_SNo (apply_fun f i) HfRi). }
      claim HaR: add_SNo (apply_fun f i) (minus_SNo 1) :e R.
      { exact (real_add_SNo (apply_fun f i) HfRi (minus_SNo 1) Hm1R). }
      claim HbR: add_SNo (apply_fun f i) 1 :e R.
      { exact (real_add_SNo (apply_fun f i) HfRi 1 real_1). }
      claim Hx0eq : add_SNo (apply_fun f i) 0 = apply_fun f i.
      { exact (add_SNo_0R (apply_fun f i) HfSi). }
      claim Haxlt0 : add_SNo (apply_fun f i) (minus_SNo 1) < add_SNo (apply_fun f i) 0.
      { exact (add_SNo_Lt2 (apply_fun f i) (minus_SNo 1) 0 HfSi Hm1S SNo_0 minus_1_lt_0). }
      claim Haxlt : add_SNo (apply_fun f i) (minus_SNo 1) < apply_fun f i.
      { rewrite <- Hx0eq at 2. exact Haxlt0. }
      claim Hxltb0 : add_SNo (apply_fun f i) 0 < add_SNo (apply_fun f i) 1.
      { exact (add_SNo_Lt2 (apply_fun f i) 0 1 HfSi SNo_0 SNo_1 SNoLt_0_1). }
      claim Hxltb : apply_fun f i < add_SNo (apply_fun f i) 1.
      { rewrite <- Hx0eq at 1. exact Hxltb0. }
      claim HaRltx : Rlt (add_SNo (apply_fun f i) (minus_SNo 1)) (apply_fun f i).
      { exact (RltI (add_SNo (apply_fun f i) (minus_SNo 1)) (apply_fun f i) HaR HfRi Haxlt). }
      claim HxRltb : Rlt (apply_fun f i) (add_SNo (apply_fun f i) 1).
      { exact (RltI (apply_fun f i) (add_SNo (apply_fun f i) 1) HfRi HbR Hxltb). }
      claim HxIn: apply_fun f i :e open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                                           (add_SNo (apply_fun f i) 1).
      { exact (SepI R (fun z : set => Rlt (add_SNo (apply_fun f i) (minus_SNo 1)) z /\ Rlt z (add_SNo (apply_fun f i) 1))
                    (apply_fun f i) HfRi (andI (Rlt (add_SNo (apply_fun f i) (minus_SNo 1)) (apply_fun f i))
                                               (Rlt (apply_fun f i) (add_SNo (apply_fun f i) 1))
                                               HaRltx
                                               HxRltb)). }
      claim HappUi: apply_fun U i =
        open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                      (add_SNo (apply_fun f i) 1).
      { exact (HUapply i Hi). }
      rewrite HappUi.
      exact HxIn.
    + (** bU c= unbounded_sequences_Romega **)
      let g. assume Hg: g :e bU.
      prove g :e unbounded_sequences_Romega.
      claim HgX: g :e X.
      { exact (SepE1 X (fun g0:set => forall i:set, i :e omega -> apply_fun g0 i :e apply_fun U i) g Hg). }
      claim Hgprop: forall i:set, i :e omega -> apply_fun g i :e apply_fun U i.
      { exact (SepE2 X (fun g0:set => forall i:set, i :e omega -> apply_fun g0 i :e apply_fun U i) g Hg). }
      apply (SepI R_omega_space (fun h:set => unbounded_sequence_Romega h) g HgX).
      prove unbounded_sequence_Romega g.
      let M. assume HM: M :e R.
      set K := add_SNo M 1.
      claim HKR: K :e R.
      { exact (real_add_SNo M HM 1 real_1). }
      claim Hexn: exists n:set, n :e omega /\ ~(apply_fun f n :e open_interval (minus_SNo K) K).
      { exact (Huf K HKR). }
      apply Hexn.
      let n. assume Hnconj.
      claim HnO: n :e omega.
      { exact (andEL (n :e omega) (~(apply_fun f n :e open_interval (minus_SNo K) K)) Hnconj). }
      claim Hfnot: ~(apply_fun f n :e open_interval (minus_SNo K) K).
      { exact (andER (n :e omega) (~(apply_fun f n :e open_interval (minus_SNo K) K)) Hnconj). }
      witness n.
      apply andI.
      - exact HnO.
      - prove ~(apply_fun g n :e open_interval (minus_SNo M) M).
        assume HgnIn: apply_fun g n :e open_interval (minus_SNo M) M.
        prove False.
        apply Hfnot.
        (** show apply_fun f n is in open_interval (minus_SNo K) K from HgnIn and box membership **)
        claim HfnR: apply_fun f n :e R.
        { exact (Romega_coord_in_R f n HfX HnO). }
        claim HgnR: apply_fun g n :e R.
        { exact (Romega_coord_in_R g n HgX HnO). }
        claim HfnS: SNo (apply_fun f n).
        { exact (real_SNo (apply_fun f n) HfnR). }
        claim HgnS: SNo (apply_fun g n).
        { exact (real_SNo (apply_fun g n) HgnR). }
        claim HM_S: SNo M.
        { exact (real_SNo M HM). }
        claim HK_S: SNo K.
        { exact (real_SNo K HKR). }

        claim HgnBox: apply_fun g n :e open_interval (add_SNo (apply_fun f n) (minus_SNo 1))
                                               (add_SNo (apply_fun f n) 1).
        { claim HgnU: apply_fun g n :e apply_fun U n.
          { exact (Hgprop n HnO). }
          claim HappUn: apply_fun U n =
            open_interval (add_SNo (apply_fun f n) (minus_SNo 1))
                          (add_SNo (apply_fun f n) 1).
          { exact (HUapply n HnO). }
          rewrite <- HappUn.
          exact HgnU. }

        claim HgnInProp: Rlt (minus_SNo M) (apply_fun g n) /\ Rlt (apply_fun g n) M.
        { exact (SepE2 R (fun z:set => Rlt (minus_SNo M) z /\ Rlt z M) (apply_fun g n) HgnIn). }
        claim Hgn_gt_mM: Rlt (minus_SNo M) (apply_fun g n).
        { exact (andEL (Rlt (minus_SNo M) (apply_fun g n)) (Rlt (apply_fun g n) M) HgnInProp). }
        claim Hgn_lt_M: Rlt (apply_fun g n) M.
        { exact (andER (Rlt (minus_SNo M) (apply_fun g n)) (Rlt (apply_fun g n) M) HgnInProp). }

        claim HgnBoxProp: Rlt (add_SNo (apply_fun f n) (minus_SNo 1)) (apply_fun g n)
                          /\ Rlt (apply_fun g n) (add_SNo (apply_fun f n) 1).
        { exact (SepE2 R (fun z:set => Rlt (add_SNo (apply_fun f n) (minus_SNo 1)) z /\ Rlt z (add_SNo (apply_fun f n) 1))
                     (apply_fun g n) HgnBox). }
        claim HxL_lt_y: Rlt (add_SNo (apply_fun f n) (minus_SNo 1)) (apply_fun g n).
        { exact (andEL (Rlt (add_SNo (apply_fun f n) (minus_SNo 1)) (apply_fun g n))
                       (Rlt (apply_fun g n) (add_SNo (apply_fun f n) 1))
                       HgnBoxProp). }
        claim Hy_lt_xR: Rlt (apply_fun g n) (add_SNo (apply_fun f n) 1).
        { exact (andER (Rlt (add_SNo (apply_fun f n) (minus_SNo 1)) (apply_fun g n))
                       (Rlt (apply_fun g n) (add_SNo (apply_fun f n) 1))
                       HgnBoxProp). }

        (** derive apply_fun f n < apply_fun g n + 1 **)
        claim HxL_lt_y_lt: add_SNo (apply_fun f n) (minus_SNo 1) < apply_fun g n.
        { exact (RltE_lt (add_SNo (apply_fun f n) (minus_SNo 1)) (apply_fun g n) HxL_lt_y). }
        claim HxL1_lt_y1: add_SNo (add_SNo (apply_fun f n) (minus_SNo 1)) 1 < add_SNo (apply_fun g n) 1.
        { exact (add_SNo_Lt1 (add_SNo (apply_fun f n) (minus_SNo 1)) 1 (apply_fun g n)
                             (SNo_add_SNo (apply_fun f n) (minus_SNo 1) HfnS Hm1S)
                             SNo_1
                             HgnS
                             HxL_lt_y_lt). }
        claim Hx_to_xL1: add_SNo (add_SNo (apply_fun f n) (minus_SNo 1)) 1 = apply_fun f n.
        { exact (add_SNo_minus_R2' (apply_fun f n) 1 HfnS SNo_1). }
        claim Hx_lt_y1_lt: apply_fun f n < add_SNo (apply_fun g n) 1.
        { rewrite <- Hx_to_xL1 at 1. exact HxL1_lt_y1. }
        claim Hy1R: add_SNo (apply_fun g n) 1 :e R.
        { exact (real_add_SNo (apply_fun g n) HgnR 1 real_1). }
        claim Hx_lt_y1: Rlt (apply_fun f n) (add_SNo (apply_fun g n) 1).
        { exact (RltI (apply_fun f n) (add_SNo (apply_fun g n) 1) HfnR Hy1R Hx_lt_y1_lt). }

        (** derive add_SNo (apply_fun g n) 1 < K **)
        claim Hy_lt_M_lt: apply_fun g n < M.
        { exact (RltE_lt (apply_fun g n) M Hgn_lt_M). }
        claim Hy1_lt_M1: add_SNo (apply_fun g n) 1 < add_SNo M 1.
        { exact (add_SNo_Lt1 (apply_fun g n) 1 M HgnS SNo_1 HM_S Hy_lt_M_lt). }
        claim Hy1_Rlt_K: Rlt (add_SNo (apply_fun g n) 1) K.
        { exact (RltI (add_SNo (apply_fun g n) 1) K Hy1R HKR Hy1_lt_M1). }

        (** combine for upper bound: apply_fun f n < K **)
        claim Hx_lt_K: Rlt (apply_fun f n) K.
        { exact (Rlt_tra (apply_fun f n) (add_SNo (apply_fun g n) 1) K Hx_lt_y1 Hy1_Rlt_K). }

        (** derive minus_SNo K < apply_fun f n **)
        claim Hy_gt_mM_lt: minus_SNo M < apply_fun g n.
        { exact (RltE_lt (minus_SNo M) (apply_fun g n) Hgn_gt_mM). }
        claim Hy_m1_lt_x: add_SNo (apply_fun g n) (minus_SNo 1) < apply_fun f n.
        { claim Hy_lt_xR_lt: apply_fun g n < add_SNo (apply_fun f n) 1.
          { exact (RltE_lt (apply_fun g n) (add_SNo (apply_fun f n) 1) Hy_lt_xR). }
          claim Hy_m1_lt_x0: add_SNo (apply_fun g n) (minus_SNo 1) < add_SNo (add_SNo (apply_fun f n) 1) (minus_SNo 1).
          { exact (add_SNo_Lt1 (apply_fun g n) (minus_SNo 1) (add_SNo (apply_fun f n) 1)
                               HgnS
                               Hm1S
                               (SNo_add_SNo (apply_fun f n) 1 HfnS SNo_1)
                               Hy_lt_xR_lt). }
          claim Hx1m1_eq: add_SNo (add_SNo (apply_fun f n) 1) (minus_SNo 1) = apply_fun f n.
          { exact (add_SNo_minus_R2 (apply_fun f n) 1 HfnS SNo_1). }
          rewrite <- Hx1m1_eq.
          exact Hy_m1_lt_x0. }

        claim HmM_m1_lt_y_m1: add_SNo (minus_SNo M) (minus_SNo 1) < add_SNo (apply_fun g n) (minus_SNo 1).
        { exact (add_SNo_Lt1 (minus_SNo M) (minus_SNo 1) (apply_fun g n)
                             (real_SNo (minus_SNo M) (real_minus_SNo M HM))
                             Hm1S
                             HgnS
                             Hy_gt_mM_lt). }

        claim HmM_m1_R: add_SNo (minus_SNo M) (minus_SNo 1) :e R.
        { exact (real_add_SNo (minus_SNo M) (real_minus_SNo M HM) (minus_SNo 1) Hm1R). }
        claim HKneg: minus_SNo K = add_SNo (minus_SNo M) (minus_SNo 1).
        { claim Hdist: minus_SNo (add_SNo M 1) = add_SNo (minus_SNo M) (minus_SNo 1).
          { exact (minus_add_SNo_distr M 1 (real_SNo M HM) SNo_1). }
          exact Hdist. }

        claim HmK_lt_x: Rlt (minus_SNo K) (apply_fun f n).
        { rewrite HKneg.
          claim Htmp: Rlt (add_SNo (minus_SNo M) (minus_SNo 1)) (apply_fun f n).
          { claim Hmid: Rlt (add_SNo (minus_SNo M) (minus_SNo 1)) (add_SNo (apply_fun g n) (minus_SNo 1)).
            { exact (RltI (add_SNo (minus_SNo M) (minus_SNo 1))
                          (add_SNo (apply_fun g n) (minus_SNo 1))
                          HmM_m1_R
                          (real_add_SNo (apply_fun g n) HgnR (minus_SNo 1) Hm1R)
                          HmM_m1_lt_y_m1). }
            claim Hmid2: Rlt (add_SNo (apply_fun g n) (minus_SNo 1)) (apply_fun f n).
            { exact (RltI (add_SNo (apply_fun g n) (minus_SNo 1)) (apply_fun f n)
                          (real_add_SNo (apply_fun g n) HgnR (minus_SNo 1) Hm1R)
                          HfnR
                          Hy_m1_lt_x). }
            exact (Rlt_tra (add_SNo (minus_SNo M) (minus_SNo 1))
                           (add_SNo (apply_fun g n) (minus_SNo 1))
                           (apply_fun f n)
                           Hmid
                           Hmid2). }
          exact Htmp. }

        (** package membership in open_interval (minus_SNo K) K **)
        exact (SepI R (fun z:set => Rlt (minus_SNo K) z /\ Rlt z K)
                     (apply_fun f n)
                     HfnR
                     (andI (Rlt (minus_SNo K) (apply_fun f n))
                           (Rlt (apply_fun f n) K)
                           HmK_lt_x
                           Hx_lt_K)).
  }
exact (SepI (Power X)
            (fun U0:set => forall x :e U0, exists b :e B, x :e b /\ b c= U0)
            unbounded_sequences_Romega
            Hpow
            Hcond).
Qed.

Theorem bounded_unbounded_disjoint_Romega :
  bounded_sequences_Romega :/\: unbounded_sequences_Romega = Empty.
prove bounded_sequences_Romega :/\: unbounded_sequences_Romega = Empty.
apply set_ext.
- let f. assume Hf: f :e bounded_sequences_Romega :/\: unbounded_sequences_Romega.
  prove f :e Empty.
  claim Hb: f :e bounded_sequences_Romega.
  { exact (binintersectE1 bounded_sequences_Romega unbounded_sequences_Romega f Hf). }
  claim Hu: f :e unbounded_sequences_Romega.
  { exact (binintersectE2 bounded_sequences_Romega unbounded_sequences_Romega f Hf). }
  claim Hbprop: bounded_sequence_Romega f.
  { exact (SepE2 R_omega_space (fun f0:set => bounded_sequence_Romega f0) f Hb). }
  claim Huprop: unbounded_sequence_Romega f.
  { exact (SepE2 R_omega_space (fun f0:set => unbounded_sequence_Romega f0) f Hu). }
  apply Hbprop.
  let M. assume HMconj.
  claim HMR: M :e R.
  { exact (andEL (M :e R) (forall n:set, n :e omega -> apply_fun f n :e open_interval (minus_SNo M) M) HMconj). }
  claim Hbnd: forall n:set, n :e omega -> apply_fun f n :e open_interval (minus_SNo M) M.
  { exact (andER (M :e R) (forall n:set, n :e omega -> apply_fun f n :e open_interval (minus_SNo M) M) HMconj). }
  claim Hexn: exists n :e omega, ~(apply_fun f n :e open_interval (minus_SNo M) M).
  { exact (Huprop M HMR). }
  apply Hexn.
  let n. assume Hnconj.
  claim HnO: n :e omega.
  { exact (andEL (n :e omega) (~(apply_fun f n :e open_interval (minus_SNo M) M)) Hnconj). }
  claim Hnnot: ~(apply_fun f n :e open_interval (minus_SNo M) M).
  { exact (andER (n :e omega) (~(apply_fun f n :e open_interval (minus_SNo M) M)) Hnconj). }
  claim Hfalse: False.
  { exact (Hnnot (Hbnd n HnO)). }
  exact (FalseE Hfalse (f :e Empty)).
- exact (Subq_Empty (bounded_sequences_Romega :/\: unbounded_sequences_Romega)).
Qed.

Theorem bounded_union_unbounded_Romega :
  bounded_sequences_Romega :\/: unbounded_sequences_Romega = R_omega_space.
prove bounded_sequences_Romega :\/: unbounded_sequences_Romega = R_omega_space.
apply set_ext.
- let f. assume Hf: f :e bounded_sequences_Romega :\/: unbounded_sequences_Romega.
  prove f :e R_omega_space.
  apply (binunionE bounded_sequences_Romega unbounded_sequences_Romega f Hf).
  - assume Hb: f :e bounded_sequences_Romega.
    exact (SepE1 R_omega_space (fun f0:set => bounded_sequence_Romega f0) f Hb).
  - assume Hu: f :e unbounded_sequences_Romega.
    exact (SepE1 R_omega_space (fun f0:set => unbounded_sequence_Romega f0) f Hu).
- let f. assume Hf: f :e R_omega_space.
  prove f :e bounded_sequences_Romega :\/: unbounded_sequences_Romega.
  apply (xm (bounded_sequence_Romega f) (f :e bounded_sequences_Romega :\/: unbounded_sequences_Romega)).
  - assume Hbseq: bounded_sequence_Romega f.
    prove f :e bounded_sequences_Romega :\/: unbounded_sequences_Romega.
    apply binunionI1.
    exact (SepI R_omega_space (fun f0:set => bounded_sequence_Romega f0) f Hf Hbseq).
  - assume HnotBound: ~(bounded_sequence_Romega f).
    prove f :e bounded_sequences_Romega :\/: unbounded_sequences_Romega.
    apply binunionI2.
    prove f :e unbounded_sequences_Romega.
    apply (SepI R_omega_space (fun f0:set => unbounded_sequence_Romega f0) f Hf).
    prove unbounded_sequence_Romega f.
    let M. assume HM: M :e R.
    apply (xm (exists n:set, n :e omega /\ ~(apply_fun f n :e open_interval (minus_SNo M) M))).
    - assume Hex. exact Hex.
    - assume Hnone: ~(exists n:set, n :e omega /\ ~(apply_fun f n :e open_interval (minus_SNo M) M)).
      prove exists n:set, n :e omega /\ ~(apply_fun f n :e open_interval (minus_SNo M) M).
      apply FalseE.
      prove False.
      apply HnotBound.
      prove bounded_sequence_Romega f.
      claim HbndM: forall n:set, n :e omega -> apply_fun f n :e open_interval (minus_SNo M) M.
      { let n. assume HnO: n :e omega.
        prove apply_fun f n :e open_interval (minus_SNo M) M.
        apply dneg.
        assume Hnnot: ~(apply_fun f n :e open_interval (minus_SNo M) M).
        prove False.
        apply Hnone.
        witness n.
        apply andI.
        - exact HnO.
        - exact Hnnot. }
      exact (fun P Hp => Hp M (andI (M :e R)
                                    (forall n:set, n :e omega -> apply_fun f n :e open_interval (minus_SNo M) M)
                                    HM
                                    HbndM)).
Qed.

(** Helper: both halves of the separation are nonempty **)
Theorem bounded_sequences_Romega_nonempty : bounded_sequences_Romega <> Empty.
prove bounded_sequences_Romega <> Empty.
assume Heq: bounded_sequences_Romega = Empty.
prove False.
set Xi := const_space_family omega R R_standard_topology.
set U := space_family_union omega Xi.
set f0 := const_fun omega 0.
claim H0omega: 0 :e omega.
{ exact (nat_p_omega 0 nat_0). }
claim HR0: 0 :e R.
{ exact real_0. }
claim HX0: apply_fun Xi 0 = (R, R_standard_topology).
{ exact (const_space_family_apply omega R R_standard_topology 0 H0omega). }
claim Hset0: space_family_set Xi 0 = R.
{ claim Hdef: space_family_set Xi 0 = (apply_fun Xi 0) 0.
  { reflexivity. }
  rewrite Hdef.
  rewrite HX0.
  exact (tuple_2_0_eq R R_standard_topology). }
claim HRfam: R :e {space_family_set Xi i|i :e omega}.
{ apply ReplEq omega (fun i:set => space_family_set Xi i) R.
  assume _ H2. apply H2.
  prove exists i :e omega, R = space_family_set Xi i.
  witness 0.
  apply andI.
  - exact H0omega.
  - prove R = space_family_set Xi 0.
    symmetry.
    exact Hset0. }
claim H0U: 0 :e U.
{ exact (UnionI {space_family_set Xi i|i :e omega} 0 R HR0 HRfam). }

(** show f0 :e R_omega_space **)
claim Hf0: f0 :e R_omega_space.
{ prove f0 :e product_space omega Xi.
  prove f0 :e {f :e Power (setprod omega (space_family_union omega Xi))|
     function_on f omega (space_family_union omega Xi) /\
     forall i:set, i :e omega -> apply_fun f i :e space_family_set Xi i}.
  set U0 := space_family_union omega Xi.
  claim Hsub: f0 c= setprod omega U0.
  { let p. assume Hp: p :e f0.
    prove p :e setprod omega U0.
    apply (ReplE_impred omega (fun a:set => (a,0)) p Hp (p :e setprod omega U0)).
    let a. assume HaO: a :e omega. assume Hpeq: p = (a,0).
    rewrite Hpeq.
    exact (tuple_2_setprod omega U0 a HaO 0 H0U). }
  claim Hpow: f0 :e Power (setprod omega U0).
  { exact (PowerI (setprod omega U0) f0 Hsub). }
  claim Hfun: function_on f0 omega U0.
  { let i. assume Hi: i :e omega.
    prove apply_fun f0 i :e U0.
    claim Happ: apply_fun f0 i = 0.
    { exact (const_fun_apply omega 0 i Hi). }
    rewrite Happ.
    exact H0U. }
  claim Hcoords: forall i:set, i :e omega -> apply_fun f0 i :e space_family_set Xi i.
  { let i. assume Hi: i :e omega.
    prove apply_fun f0 i :e space_family_set Xi i.
    claim Happ: apply_fun f0 i = 0.
    { exact (const_fun_apply omega 0 i Hi). }
    rewrite Happ.
    claim HX: apply_fun Xi i = (R, R_standard_topology).
    { exact (const_space_family_apply omega R R_standard_topology i Hi). }
    claim Hset: space_family_set Xi i = R.
    { claim Hdef: space_family_set Xi i = (apply_fun Xi i) 0.
      { reflexivity. }
      rewrite Hdef.
      rewrite HX.
      exact (tuple_2_0_eq R R_standard_topology). }
    rewrite Hset.
    exact real_0. }
  claim Hprop: function_on f0 omega U0 /\ forall i:set, i :e omega -> apply_fun f0 i :e space_family_set Xi i.
  { apply andI.
    - exact Hfun.
    - exact Hcoords. }
  exact (SepI (Power (setprod omega U0))
              (fun f:set => function_on f omega U0 /\ forall i:set, i :e omega -> apply_fun f i :e space_family_set Xi i)
              f0
              Hpow
              Hprop). }

(** show bounded_sequence_Romega f0 by the bound 1 **)
claim Hbseq: bounded_sequence_Romega f0.
{ claim Hbnd1: forall n:set, n :e omega -> apply_fun f0 n :e open_interval (minus_SNo 1) 1.
  { let n. assume HnO: n :e omega.
    prove apply_fun f0 n :e open_interval (minus_SNo 1) 1.
    claim Happ: apply_fun f0 n = 0.
    { exact (const_fun_apply omega 0 n HnO). }
    rewrite Happ.
    claim Hm1R: minus_SNo 1 :e R.
    { exact (real_minus_SNo 1 real_1). }
    claim Hm1lt0: Rlt (minus_SNo 1) 0.
    { exact (RltI (minus_SNo 1) 0 Hm1R real_0 minus_1_lt_0). }
    claim H0lt1: Rlt 0 1.
    { exact Rlt_0_1. }
    claim Hconj: Rlt (minus_SNo 1) 0 /\ Rlt 0 1.
    { apply andI.
      - exact Hm1lt0.
      - exact H0lt1. }
    exact (SepI R (fun x0:set => Rlt (minus_SNo 1) x0 /\ Rlt x0 1) 0 real_0 Hconj). }
  exact (fun P Hp => Hp 1 (andI (1 :e R)
                                (forall n:set, n :e omega -> apply_fun f0 n :e open_interval (minus_SNo 1) 1)
                                real_1
                                Hbnd1)). }

claim Hf0B: f0 :e bounded_sequences_Romega.
{ exact (SepI R_omega_space (fun f:set => bounded_sequence_Romega f) f0 Hf0 Hbseq). }
claim Hf0E: f0 :e Empty.
{ rewrite <- Heq at 2.
  exact Hf0B. }
exact (EmptyE f0 Hf0E).
Qed.

Theorem unbounded_sequences_Romega_nonempty : unbounded_sequences_Romega <> Empty.
prove unbounded_sequences_Romega <> Empty.
assume Heq: unbounded_sequences_Romega = Empty.
prove False.
set Xi := const_space_family omega R R_standard_topology.
set U := space_family_union omega Xi.
set fid := {(i,i)|i :e omega}.

(** show fid :e R_omega_space **)
claim Hfid: fid :e R_omega_space.
{ prove fid :e product_space omega Xi.
  prove fid :e {f :e Power (setprod omega (space_family_union omega Xi))|
     function_on f omega (space_family_union omega Xi) /\
     forall i:set, i :e omega -> apply_fun f i :e space_family_set Xi i}.
  claim H0omega: 0 :e omega.
  { exact (nat_p_omega 0 nat_0). }
  claim HX0: apply_fun Xi 0 = (R, R_standard_topology).
  { exact (const_space_family_apply omega R R_standard_topology 0 H0omega). }
  claim Hset0: space_family_set Xi 0 = R.
  { claim Hdef: space_family_set Xi 0 = (apply_fun Xi 0) 0.
    { reflexivity. }
    rewrite Hdef.
    rewrite HX0.
    exact (tuple_2_0_eq R R_standard_topology). }
  claim HRfam: R :e {space_family_set Xi i|i :e omega}.
  { apply ReplEq omega (fun i:set => space_family_set Xi i) R.
    assume _ H2. apply H2.
    prove exists i :e omega, R = space_family_set Xi i.
    witness 0.
    apply andI.
    - exact H0omega.
    - symmetry.
      exact Hset0. }
	  claim HomegaU: forall i:set, i :e omega -> i :e U.
	  { let i. assume Hi: i :e omega.
	    prove i :e U.
	    claim HiR: i :e R.
	    { claim HiSNoS: i :e SNoS_ omega.
	      { exact (omega_SNoS_omega i Hi). }
	      exact (SNoS_omega_real i HiSNoS). }
	    exact (UnionI {space_family_set Xi i0|i0 :e omega} i R HiR HRfam). }

  claim Hsub: fid c= setprod omega U.
  { let p. assume Hp: p :e fid.
    prove p :e setprod omega U.
    apply (ReplE_impred omega (fun i:set => (i,i)) p Hp (p :e setprod omega U)).
    let i. assume Hi: i :e omega. assume Hpeq: p = (i,i).
    rewrite Hpeq.
    exact (tuple_2_setprod omega U i Hi i (HomegaU i Hi)). }
  claim Hpow: fid :e Power (setprod omega U).
  { exact (PowerI (setprod omega U) fid Hsub). }

  claim Hfun: function_on fid omega U.
  { let i. assume Hi: i :e omega.
    prove apply_fun fid i :e U.
    claim Happ: apply_fun fid i = i.
    { exact (identity_function_apply omega i Hi). }
    rewrite Happ.
    exact (HomegaU i Hi). }
  claim Hcoords: forall i:set, i :e omega -> apply_fun fid i :e space_family_set Xi i.
  { let i. assume Hi: i :e omega.
    prove apply_fun fid i :e space_family_set Xi i.
    claim Happ: apply_fun fid i = i.
    { exact (identity_function_apply omega i Hi). }
    rewrite Happ.
    claim Hset: space_family_set Xi i = R.
    { claim HXi: apply_fun Xi i = (R, R_standard_topology).
      { exact (const_space_family_apply omega R R_standard_topology i Hi). }
      claim Hdef: space_family_set Xi i = (apply_fun Xi i) 0.
      { reflexivity. }
      rewrite Hdef.
      rewrite HXi.
      exact (tuple_2_0_eq R R_standard_topology). }
	    rewrite Hset.
	    claim HiSNoS: i :e SNoS_ omega.
	    { exact (omega_SNoS_omega i Hi). }
	    exact (SNoS_omega_real i HiSNoS). }

  claim Hprop: function_on fid omega U /\ forall i:set, i :e omega -> apply_fun fid i :e space_family_set Xi i.
  { apply andI.
    - exact Hfun.
    - exact Hcoords. }
  exact (SepI (Power (setprod omega U))
              (fun f:set => function_on f omega U /\ forall i:set, i :e omega -> apply_fun f i :e space_family_set Xi i)
              fid
              Hpow
              Hprop). }

(** show unbounded_sequence_Romega fid **)
claim Huseq: unbounded_sequence_Romega fid.
{ let M. assume HM: M :e R.
  claim HMS: SNo M.
  { exact (real_SNo M HM). }
  claim Hor: M < 0 \/ 0 <= M.
  { exact (SNoLtLe_or M 0 HMS SNo_0). }
  claim Hcase1: M < 0 ->
    exists n:set, n :e omega /\ ~(apply_fun fid n :e open_interval (minus_SNo M) M).
  { assume HMlt0: M < 0.
    witness 0.
    apply andI.
    - exact (nat_p_omega 0 nat_0).
    - prove ~(apply_fun fid 0 :e open_interval (minus_SNo M) M).
      assume Hin: apply_fun fid 0 :e open_interval (minus_SNo M) M.
      claim Happ: apply_fun fid 0 = 0.
      { exact (identity_function_apply omega 0 (nat_p_omega 0 nat_0)). }
      claim Hprop: Rlt (minus_SNo M) (apply_fun fid 0) /\ Rlt (apply_fun fid 0) M.
      { exact (SepE2 R (fun x0:set => Rlt (minus_SNo M) x0 /\ Rlt x0 M) (apply_fun fid 0) Hin). }
      claim HRlt0M: Rlt 0 M.
      { rewrite <- Happ.
        exact (andER (Rlt (minus_SNo M) (apply_fun fid 0)) (Rlt (apply_fun fid 0) M) Hprop). }
      claim HRltM0: Rlt M 0.
      { exact (RltI M 0 HM real_0 HMlt0). }
      claim Hnot: ~(Rlt 0 M).
      { exact (not_Rlt_sym M 0 HRltM0). }
      exact (Hnot HRlt0M). }
  claim Hcase2: 0 <= M ->
    exists n:set, n :e omega /\ ~(apply_fun fid n :e open_interval (minus_SNo M) M).
  { assume HMnonneg: 0 <= M.
    claim Hexn0: exists n :e omega, n <= M /\ M < ordsucc n.
    { exact (nonneg_real_nat_interval M HM HMnonneg). }
    apply Hexn0.
    let n0. assume Hn0conj.
    claim Hn0: n0 :e omega.
    { exact (andEL (n0 :e omega) (n0 <= M /\ M < ordsucc n0) Hn0conj). }
    claim Hn0prop: n0 <= M /\ M < ordsucc n0.
    { exact (andER (n0 :e omega) (n0 <= M /\ M < ordsucc n0) Hn0conj). }
    claim HMltS: M < ordsucc n0.
    { exact (andER (n0 <= M) (M < ordsucc n0) Hn0prop). }
    set n := ordsucc n0.
    witness n.
    apply andI.
    - exact (omega_ordsucc n0 Hn0).
    - prove ~(apply_fun fid n :e open_interval (minus_SNo M) M).
      assume Hin: apply_fun fid n :e open_interval (minus_SNo M) M.
      claim Happ: apply_fun fid n = n.
      { exact (identity_function_apply omega n (omega_ordsucc n0 Hn0)). }
      claim HnR: n :e R.
      { claim HnO: n :e omega.
        { exact (omega_ordsucc n0 Hn0). }
        claim HnSNoS: n :e SNoS_ omega.
        { exact (omega_SNoS_omega n HnO). }
        exact (SNoS_omega_real n HnSNoS). }
      claim HRltMn: Rlt M n.
      { exact (RltI M n HM HnR HMltS). }
      claim HnotnM: ~(Rlt n M).
      { exact (not_Rlt_sym M n HRltMn). }
      claim Hprop: Rlt (minus_SNo M) (apply_fun fid n) /\ Rlt (apply_fun fid n) M.
      { exact (SepE2 R (fun x0:set => Rlt (minus_SNo M) x0 /\ Rlt x0 M) (apply_fun fid n) Hin). }
      claim HRltnM: Rlt n M.
      { rewrite <- Happ.
        exact (andER (Rlt (minus_SNo M) (apply_fun fid n)) (Rlt (apply_fun fid n) M) Hprop). }
      exact (HnotnM HRltnM). }
  exact (Hor (exists n:set, n :e omega /\ ~(apply_fun fid n :e open_interval (minus_SNo M) M)) Hcase1 Hcase2).
}

claim HfidU: fid :e unbounded_sequences_Romega.
{ exact (SepI R_omega_space (fun f:set => unbounded_sequence_Romega f) fid Hfid Huseq). }
claim HeqE: Empty = unbounded_sequences_Romega.
{ symmetry. exact Heq. }
claim Hsubst: forall S T:set, S = T -> fid :e T -> fid :e S.
{ let S T.
  assume HeqST: S = T.
  assume HfidT: fid :e T.
  prove fid :e S.
  rewrite HeqST.
  exact HfidT. }
claim HfidE: fid :e Empty.
{ exact (Hsubst Empty unbounded_sequences_Romega HeqE HfidU). }
exact (EmptyE fid HfidE).
Qed.

Theorem R_omega_box_not_connected :
  ~ connected_space (product_space omega (const_space_family omega R R_standard_topology))
    (box_topology omega (const_space_family omega R R_standard_topology)).
prove ~ connected_space (product_space omega (const_space_family omega R R_standard_topology))
  (box_topology omega (const_space_family omega R R_standard_topology)).
assume Hconn: connected_space R_omega_space R_omega_box_topology.
prove False.
claim Hnosep: ~(exists U V:set, U :e R_omega_box_topology /\ V :e R_omega_box_topology /\ separation_of R_omega_space U V).
{ exact (andER (topology_on R_omega_space R_omega_box_topology)
               (~(exists U V:set, U :e R_omega_box_topology /\ V :e R_omega_box_topology /\ separation_of R_omega_space U V))
               Hconn). }
claim Hsep: exists U V:set, U :e R_omega_box_topology /\ V :e R_omega_box_topology /\ separation_of R_omega_space U V.
{ witness bounded_sequences_Romega.
  witness unbounded_sequences_Romega.
  apply andI.
  - apply andI.
    + exact bounded_sequences_in_Romega_box_topology.
    + exact unbounded_sequences_in_Romega_box_topology.
  - prove separation_of R_omega_space bounded_sequences_Romega unbounded_sequences_Romega.
    prove bounded_sequences_Romega :e Power R_omega_space /\
          unbounded_sequences_Romega :e Power R_omega_space /\
          bounded_sequences_Romega :/\: unbounded_sequences_Romega = Empty /\
          bounded_sequences_Romega <> Empty /\
          unbounded_sequences_Romega <> Empty /\
          bounded_sequences_Romega :\/: unbounded_sequences_Romega = R_omega_space.
    (** Conjunction is left-associative: (((((A /\ B) /\ C) /\ D) /\ E) /\ F) **)
    apply andI.
    - (** ((((A /\ B) /\ C) /\ D) /\ E) **)
      apply andI.
      + (** (((A /\ B) /\ C) /\ D) **)
        apply andI.
        * (** ((A /\ B) /\ C) **)
          apply andI.
          - (** (A /\ B) **)
            apply andI.
            + exact bounded_sequences_Romega_in_Power.
            + exact unbounded_sequences_Romega_in_Power.
          - exact bounded_unbounded_disjoint_Romega.
        * exact bounded_sequences_Romega_nonempty.
      + exact unbounded_sequences_Romega_nonempty.
    - exact bounded_union_unbounded_Romega.
}
exact (Hnosep Hsep).
Qed.

(** from 23 Example 7: R^ in the product topology is connected **) 
(** LATEX VERSION: Let R^ be sequences eventually 0; it is connected as union of R^n; its closure is all of R^ in product topology. **)
Definition Romega_tilde : set -> set := fun n =>
  {f :e R_omega_space | forall i:set, i :e omega -> n :e i -> apply_fun f i = 0}.

Definition Romega_infty : set := Union {Romega_tilde n|n :e omega}.

Theorem Romega_tilde_sub_Romega : forall n:set,
  Romega_tilde n c= R_omega_space.
let n.
let f. assume Hf: f :e Romega_tilde n.
prove f :e R_omega_space.
exact (SepE1 R_omega_space (fun f0:set => forall i:set, i :e omega -> n :e i -> apply_fun f0 i = 0) f Hf).
Qed.

Theorem Romega_infty_sub_Romega : Romega_infty c= R_omega_space.
let f. assume Hf: f :e Romega_infty.
prove f :e R_omega_space.
apply (UnionE_impred {Romega_tilde n|n :e omega} f Hf).
let Y. assume HfY: f :e Y. assume HY: Y :e {Romega_tilde n|n :e omega}.
apply (ReplE_impred omega (fun n:set => Romega_tilde n) Y HY (f :e R_omega_space)).
let n. assume Hn: n :e omega. assume HYeq: Y = Romega_tilde n.
claim HfY2: f :e Romega_tilde n.
{ rewrite <- HYeq.
  exact HfY. }
exact (Romega_tilde_sub_Romega n f HfY2).
Qed.

(** from 23 Example 7: the constant zero sequence in R^omega **)
(** LATEX VERSION: The constant zero sequence is an element of R^omega (the countable product of R). **)
Definition Romega_zero : set := const_fun omega 0.

Theorem Romega_zero_in_Romega_space : Romega_zero :e R_omega_space.
prove Romega_zero :e R_omega_space.
set Xi := const_space_family omega R R_standard_topology.
set U0 := space_family_union omega Xi.
claim H0omega: 0 :e omega.
{ exact (nat_p_omega 0 nat_0). }
claim HR0: 0 :e R.
{ exact real_0. }
claim HX0: apply_fun Xi 0 = (R, R_standard_topology).
{ exact (const_space_family_apply omega R R_standard_topology 0 H0omega). }
claim Hset0: space_family_set Xi 0 = R.
{ claim Hdef: space_family_set Xi 0 = (apply_fun Xi 0) 0.
  { reflexivity. }
  rewrite Hdef.
  rewrite HX0.
  exact (tuple_2_0_eq R R_standard_topology). }
claim HRfam: R :e {space_family_set Xi i|i :e omega}.
{ apply ReplEq omega (fun i:set => space_family_set Xi i) R.
  assume _ H2. apply H2.
  prove exists i :e omega, R = space_family_set Xi i.
  witness 0.
  apply andI.
  - exact H0omega.
  - prove R = space_family_set Xi 0.
    symmetry.
    exact Hset0. }
claim H0U0: 0 :e U0.
{ exact (UnionI {space_family_set Xi i|i :e omega} 0 R HR0 HRfam). }

prove Romega_zero :e product_space omega Xi.
prove Romega_zero :e {f :e Power (setprod omega (space_family_union omega Xi))|
   function_on f omega (space_family_union omega Xi) /\
   forall i:set, i :e omega -> apply_fun f i :e space_family_set Xi i}.
claim Hsub: Romega_zero c= setprod omega U0.
{ let p. assume Hp: p :e Romega_zero.
  prove p :e setprod omega U0.
  apply (ReplE_impred omega (fun a:set => (a,0)) p Hp (p :e setprod omega U0)).
  let a. assume HaO: a :e omega. assume Hpeq: p = (a,0).
  rewrite Hpeq.
  exact (tuple_2_setprod omega U0 a HaO 0 H0U0). }
claim Hpow: Romega_zero :e Power (setprod omega U0).
{ exact (PowerI (setprod omega U0) Romega_zero Hsub). }
claim Htot: total_function_on Romega_zero omega U0.
{ exact (const_fun_total_function_on omega U0 0 H0U0). }
claim Hfun: function_on Romega_zero omega U0.
{ exact (total_function_on_function_on Romega_zero omega U0 Htot). }
claim Hcoords: forall i:set, i :e omega -> apply_fun Romega_zero i :e space_family_set Xi i.
{ let i. assume Hi: i :e omega.
  prove apply_fun Romega_zero i :e space_family_set Xi i.
  claim Happ: apply_fun Romega_zero i = 0.
  { exact (const_fun_apply omega 0 i Hi). }
  rewrite Happ.
  claim HX: apply_fun Xi i = (R, R_standard_topology).
  { exact (const_space_family_apply omega R R_standard_topology i Hi). }
  claim Hset: space_family_set Xi i = R.
  { claim Hdef: space_family_set Xi i = (apply_fun Xi i) 0.
    { reflexivity. }
    rewrite Hdef.
    rewrite HX.
    exact (tuple_2_0_eq R R_standard_topology). }
  rewrite Hset.
  exact real_0. }
claim Hprop: function_on Romega_zero omega U0 /\ forall i:set, i :e omega -> apply_fun Romega_zero i :e space_family_set Xi i.
{ apply andI.
  - exact Hfun.
  - exact Hcoords. }
exact (SepI (Power (setprod omega U0))
            (fun f:set => function_on f omega U0 /\ forall i:set, i :e omega -> apply_fun f i :e space_family_set Xi i)
            Romega_zero
            Hpow
            Hprop).
Qed.

Theorem Romega_zero_in_Romega_tilde : forall n:set,
  n :e omega -> Romega_zero :e Romega_tilde n.
let n. assume HnO: n :e omega.
prove Romega_zero :e Romega_tilde n.
claim Hbase: Romega_zero :e R_omega_space.
{ exact Romega_zero_in_Romega_space. }
claim Hprop: forall i:set, i :e omega -> n :e i -> apply_fun Romega_zero i = 0.
{ let i. assume Hi: i :e omega.
  assume Hni: n :e i.
  prove apply_fun Romega_zero i = 0.
  exact (const_fun_apply omega 0 i Hi). }
exact (SepI R_omega_space
           (fun f0:set => forall i:set, i :e omega -> n :e i -> apply_fun f0 i = 0)
           Romega_zero
           Hbase
           Hprop).
Qed.

Theorem Romega_tilde_nonempty : forall n:set,
  n :e omega -> Romega_tilde n <> Empty.
let n. assume HnO: n :e omega.
prove Romega_tilde n <> Empty.
assume HEmpty: Romega_tilde n = Empty.
prove False.
claim H0in: Romega_zero :e Romega_tilde n.
{ exact (Romega_zero_in_Romega_tilde n HnO). }
claim H0E: Romega_zero :e Empty.
{ rewrite <- HEmpty.
  exact H0in. }
exact (EmptyE Romega_zero H0E).
Qed.

(** from 23 Example 7: product topology on R^omega is a topology **)
(** LATEX VERSION: The product topology on R to the omega is a topology on the product space R to the omega. **)
Theorem Romega_product_topology_is_topology : topology_on R_omega_space R_omega_product_topology.
prove topology_on R_omega_space R_omega_product_topology.
set Xi := const_space_family omega R R_standard_topology.
set X := product_space omega Xi.
set S := product_subbasis_full omega Xi.
set Tx := generated_topology_from_subbasis X S.

claim H0omega: 0 :e omega.
{ exact (nat_p_omega 0 nat_0). }

claim HcompTop: forall i:set, i :e omega -> topology_on (space_family_set Xi i) (space_family_topology Xi i).
{ let i. assume Hi: i :e omega.
  prove topology_on (space_family_set Xi i) (space_family_topology Xi i).
  claim HXi: apply_fun Xi i = (R, R_standard_topology).
  { exact (const_space_family_apply omega R R_standard_topology i Hi). }
  claim Hset: space_family_set Xi i = R.
  { claim Hdef: space_family_set Xi i = (apply_fun Xi i) 0.
    { reflexivity. }
    rewrite Hdef.
    rewrite HXi.
    exact (tuple_2_0_eq R R_standard_topology). }
  claim HTi: space_family_topology Xi i = R_standard_topology.
  { claim Hdef: space_family_topology Xi i = (apply_fun Xi i) 1.
    { reflexivity. }
    rewrite Hdef.
    rewrite HXi.
    exact (tuple_2_1_eq R R_standard_topology). }
  rewrite Hset.
  rewrite HTi.
  exact R_standard_topology_is_topology_local. }

claim HSsub: S c= Power X.
{ let s. assume Hs: s :e S.
  prove s :e Power X.
  apply PowerI.
  let f. assume Hf: f :e s.
  prove f :e X.
  set F := (fun i:set => {product_cylinder omega Xi i U|U :e space_family_topology Xi i}).
  claim HsF: s :e (\/_ i :e omega, F i).
  { exact Hs. }
  apply (famunionE_impred omega F s HsF).
  let i. assume Hi: i :e omega. assume HsFi: s :e F i.
  apply (ReplE_impred (space_family_topology Xi i) (fun U0:set => product_cylinder omega Xi i U0) s HsFi (f :e X)).
  let U0. assume HU0: U0 :e space_family_topology Xi i.
  assume Hseq: s = product_cylinder omega Xi i U0.
  claim HfCyl: f :e product_cylinder omega Xi i U0.
  { rewrite <- Hseq.
    exact Hf. }
  exact (SepE1 X
              (fun g0:set => i :e omega /\ U0 :e space_family_topology Xi i /\ apply_fun g0 i :e U0)
              f
              HfCyl). }

claim HUnionS: Union S = X.
{ apply set_ext.
  - let f. assume Hf: f :e Union S.
    prove f :e X.
    apply UnionE_impred S f Hf.
    let s. assume Hfs: f :e s. assume HsS: s :e S.
    claim HsPow: s :e Power X.
    { exact (HSsub s HsS). }
    exact (PowerE X s HsPow f Hfs).
  - let f. assume Hf: f :e X.
    prove f :e Union S.
    set i0 := 0.
    set U0 := space_family_set Xi i0.
    set s0 := product_cylinder omega Xi i0 U0.
    claim Hi0: i0 :e omega.
    { exact H0omega. }
    claim HTi0: topology_on (space_family_set Xi i0) (space_family_topology Xi i0).
    { exact (HcompTop i0 Hi0). }
    claim HU0top: U0 :e space_family_topology Xi i0.
    { exact (topology_has_X (space_family_set Xi i0) (space_family_topology Xi i0) HTi0). }
    claim Hs0S: s0 :e S.
    { set F := (fun i:set => {product_cylinder omega Xi i U|U :e space_family_topology Xi i}).
      claim Hs0Fi0: s0 :e F i0.
      { exact (ReplI (space_family_topology Xi i0)
                     (fun U:set => product_cylinder omega Xi i0 U)
                     U0
                     HU0top). }
      exact (famunionI omega F i0 s0 Hi0 Hs0Fi0). }
    prove f :e Union S.
    apply (UnionI S f s0).
    - prove f :e s0.
      prove f :e {g :e X | i0 :e omega /\ U0 :e space_family_topology Xi i0 /\ apply_fun g i0 :e U0}.
      apply (SepI X
               (fun g0:set => i0 :e omega /\ U0 :e space_family_topology Xi i0 /\ apply_fun g0 i0 :e U0)
               f
               Hf).
      prove i0 :e omega /\ U0 :e space_family_topology Xi i0 /\ apply_fun f i0 :e U0.
      apply andI.
      + prove i0 :e omega /\ U0 :e space_family_topology Xi i0.
        apply andI.
        - exact Hi0.
        - exact HU0top.
      + claim Hfprop: function_on f omega (space_family_union omega Xi) /\
            forall i:set, i :e omega -> apply_fun f i :e space_family_set Xi i.
          { exact (SepE2 (Power (setprod omega (space_family_union omega Xi)))
                         (fun f0:set => function_on f0 omega (space_family_union omega Xi) /\
                           forall i:set, i :e omega -> apply_fun f0 i :e space_family_set Xi i)
                         f
                         Hf). }
          claim Hcoords: forall i:set, i :e omega -> apply_fun f i :e space_family_set Xi i.
          { exact (andER (function_on f omega (space_family_union omega Xi))
                         (forall i:set, i :e omega -> apply_fun f i :e space_family_set Xi i)
                         Hfprop). }
          exact (Hcoords i0 Hi0).
    - exact Hs0S. }

claim HS: subbasis_on X S.
{ prove S c= Power X /\ Union S = X.
  apply andI.
  - exact HSsub.
  - exact HUnionS. }
claim HTx: topology_on X Tx.
{ exact (topology_from_subbasis_is_topology X S HS). }
claim HXe: X = R_omega_space.
{ reflexivity. }
claim HTXe: Tx = R_omega_product_topology.
{ reflexivity. }
rewrite <- HXe.
rewrite <- HTXe.
exact HTx.
Qed.

(** from 23: dense set meets every nonempty open set **)
(** LATEX VERSION: If A is dense in X and U is nonempty open, then U intersect A is nonempty. **)
Theorem dense_in_meets_nonempty_open : forall A X Tx U:set,
  topology_on X Tx ->
  closure_of X Tx A = X ->
  U :e Tx ->
  U <> Empty ->
  U :/\: A <> Empty.
let A X Tx U.
assume HTx: topology_on X Tx.
assume Hdense: closure_of X Tx A = X.
assume HU: U :e Tx.
assume HUne: U <> Empty.
claim Hexx: exists x:set, x :e U.
{ exact (nonempty_has_element U HUne). }
apply Hexx.
let x. assume HxU: x :e U.
claim HTsub: Tx c= Power X.
{ exact (topology_subset_axiom X Tx HTx). }
claim HUpow: U :e Power X.
{ exact (HTsub U HU). }
claim HxX: x :e X.
{ exact (PowerE X U HUpow x HxU). }
claim Hcl: x :e closure_of X Tx A.
{ rewrite Hdense.
  exact HxX. }
claim Hcliff: x :e closure_of X Tx A <-> (forall V :e Tx, x :e V -> V :/\: A <> Empty).
{ exact (closure_characterization X Tx A x HTx HxX). }
claim Hneigh: forall V :e Tx, x :e V -> V :/\: A <> Empty.
{ exact (iffEL (x :e closure_of X Tx A) (forall V :e Tx, x :e V -> V :/\: A <> Empty) Hcliff Hcl). }
exact (Hneigh U HU HxU).
Qed.

(** from 23: dense connected subset implies connected space **)
(** LATEX VERSION: If A is dense in X and A is connected in the subspace topology, then X is connected. **)
Theorem connected_space_if_dense_connected_subset : forall X Tx A:set,
  topology_on X Tx ->
  A c= X ->
  connected_space A (subspace_topology X Tx A) ->
  closure_of X Tx A = X ->
  connected_space X Tx.
let X Tx A.
assume HTx: topology_on X Tx.
assume HAsub: A c= X.
assume HAconn: connected_space A (subspace_topology X Tx A).
assume Hdense: closure_of X Tx A = X.
prove connected_space X Tx.
prove topology_on X Tx /\ ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).
apply andI.
- exact HTx.
- prove ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).
  assume Hsep: exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V.
  apply Hsep.
  let U. assume HexV: exists V:set, U :e Tx /\ V :e Tx /\ separation_of X U V.
  apply HexV.
  let V. assume HUVsep.
  claim HUV12: U :e Tx /\ V :e Tx.
  { exact (andEL (U :e Tx /\ V :e Tx) (separation_of X U V) HUVsep). }
  claim HU: U :e Tx.
  { exact (andEL (U :e Tx) (V :e Tx) HUV12). }
  claim HV: V :e Tx.
  { exact (andER (U :e Tx) (V :e Tx) HUV12). }
  claim HsepUV: separation_of X U V.
  { exact (andER (U :e Tx /\ V :e Tx) (separation_of X U V) HUVsep). }
  claim HsepL: ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty).
  { exact (andEL ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                 (U :\/: V = X)
                 HsepUV). }
  claim HUVdisj: (U :e Power X /\ V :e Power X) /\ U :/\: V = Empty.
  { exact (andEL ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty)
                 (U <> Empty)
                 (andEL (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty)
                        (V <> Empty)
                        HsepL)). }
  claim HUVempty: U :/\: V = Empty.
  { exact (andER (U :e Power X /\ V :e Power X) (U :/\: V = Empty) HUVdisj). }
  claim HU0: U <> Empty.
  { exact (andER ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) (U <> Empty)
                 (andEL (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty)
                        (V <> Empty)
                        HsepL)). }
  claim HV0: V <> Empty.
  { exact (andER (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty)
                 (V <> Empty)
                 HsepL). }
  claim Hside: A c= U \/ A c= V.
  { exact (connected_subset_in_separation_side X Tx U V A HTx HAsub HAconn HU HV HsepUV). }
  apply Hside.
  - assume HAU: A c= U.
    claim HVneA: V :/\: A <> Empty.
    { exact (dense_in_meets_nonempty_open A X Tx V HTx Hdense HV HV0). }
    claim HVAsubEmpty: V :/\: A c= Empty.
    { let x. assume Hx: x :e V :/\: A.
      prove x :e Empty.
      claim HxV: x :e V.
      { exact (binintersectE1 V A x Hx). }
      claim HxA: x :e A.
      { exact (binintersectE2 V A x Hx). }
      claim HxU: x :e U.
      { exact (HAU x HxA). }
      claim HxUV: x :e U :/\: V.
      { exact (binintersectI U V x HxU HxV). }
      claim HxE: x :e Empty.
      { rewrite <- HUVempty.
        exact HxUV. }
      exact HxE. }
    claim HVAEq: V :/\: A = Empty.
    { exact (Empty_Subq_eq (V :/\: A) HVAsubEmpty). }
    apply HVneA.
    exact HVAEq.
  - assume HAV: A c= V.
    claim HUneA: U :/\: A <> Empty.
    { exact (dense_in_meets_nonempty_open A X Tx U HTx Hdense HU HU0). }
    claim HUAsubEmpty: U :/\: A c= Empty.
    { let x. assume Hx: x :e U :/\: A.
      prove x :e Empty.
      claim HxU: x :e U.
      { exact (binintersectE1 U A x Hx). }
      claim HxA: x :e A.
      { exact (binintersectE2 U A x Hx). }
      claim HxV: x :e V.
      { exact (HAV x HxA). }
      claim HxUV: x :e U :/\: V.
      { exact (binintersectI U V x HxU HxV). }
      claim HxE: x :e Empty.
      { rewrite <- HUVempty.
        exact HxUV. }
      exact HxE. }
    claim HUAEq: U :/\: A = Empty.
    { exact (Empty_Subq_eq (U :/\: A) HUAsubEmpty). }
    apply HUneA.
    exact HUAEq.
Qed.

(** Example 7 connectedness theorems are stated later, after singleton and extension map infrastructure. **)

(** Helper: any omega indexed real map gives an element of R_omega_space **)
Theorem graph_omega_in_Romega_space : forall h:set->set,
  (forall i:set, i :e omega -> h i :e R) ->
  graph omega h :e R_omega_space.
let h.
assume HhR: forall i:set, i :e omega -> h i :e R.
prove graph omega h :e R_omega_space.
set Xi := const_space_family omega R R_standard_topology.
set U0 := space_family_union omega Xi.
claim H0omega: 0 :e omega.
{ exact (nat_p_omega 0 nat_0). }
claim HXi0: apply_fun Xi 0 = (R, R_standard_topology).
{ exact (const_space_family_apply omega R R_standard_topology 0 H0omega). }
claim Hset0: space_family_set Xi 0 = R.
{ claim Hdef: space_family_set Xi 0 = (apply_fun Xi 0) 0.
  { reflexivity. }
  rewrite Hdef.
  rewrite HXi0.
  exact (tuple_2_0_eq R R_standard_topology). }
claim HRfam: R :e {space_family_set Xi i|i :e omega}.
{ apply ReplEq omega (fun i:set => space_family_set Xi i) R.
  assume _ H2. apply H2.
  prove exists i :e omega, R = space_family_set Xi i.
  witness 0.
  apply andI.
  - exact H0omega.
  - prove R = space_family_set Xi 0.
    symmetry.
    exact Hset0. }
claim HRinU0: forall r:set, r :e R -> r :e U0.
{ let r. assume Hr: r :e R.
  exact (UnionI {space_family_set Xi i|i :e omega} r R Hr HRfam). }
claim Hsub: graph omega h c= setprod omega U0.
{ let p. assume Hp: p :e graph omega h.
  prove p :e setprod omega U0.
  apply (ReplE_impred omega (fun i:set => (i, h i)) p Hp (p :e setprod omega U0)).
  let i. assume Hi: i :e omega. assume Heq: p = (i, h i).
  rewrite Heq.
  claim HhiR: h i :e R.
  { exact (HhR i Hi). }
  claim HhiU0: h i :e U0.
  { exact (HRinU0 (h i) HhiR). }
  exact (tuple_2_setprod omega U0 i Hi (h i) HhiU0). }
claim Hpow: graph omega h :e Power (setprod omega U0).
{ exact (PowerI (setprod omega U0) (graph omega h) Hsub). }
claim Hfun: function_on (graph omega h) omega U0.
{ let i. assume Hi: i :e omega.
  prove apply_fun (graph omega h) i :e U0.
  claim Happ: apply_fun (graph omega h) i = h i.
  { exact (apply_fun_graph omega h i Hi). }
  rewrite Happ.
  exact (HRinU0 (h i) (HhR i Hi)). }
claim Hcoords: forall i:set, i :e omega -> apply_fun (graph omega h) i :e space_family_set Xi i.
{ let i. assume Hi: i :e omega.
  prove apply_fun (graph omega h) i :e space_family_set Xi i.
  claim Happ: apply_fun (graph omega h) i = h i.
  { exact (apply_fun_graph omega h i Hi). }
  rewrite Happ.
  claim HXi: apply_fun Xi i = (R, R_standard_topology).
  { exact (const_space_family_apply omega R R_standard_topology i Hi). }
  claim Hset: space_family_set Xi i = R.
  { claim Hdef: space_family_set Xi i = (apply_fun Xi i) 0.
    { reflexivity. }
    rewrite Hdef.
    rewrite HXi.
    exact (tuple_2_0_eq R R_standard_topology). }
  rewrite Hset.
  exact (HhR i Hi). }
claim Hprop: function_on (graph omega h) omega U0 /\
  forall i:set, i :e omega -> apply_fun (graph omega h) i :e space_family_set Xi i.
{ apply andI.
  - exact Hfun.
  - exact Hcoords. }
exact (SepI (Power (setprod omega U0))
            (fun f0:set => function_on f0 omega U0 /\
              forall i:set, i :e omega -> apply_fun f0 i :e space_family_set Xi i)
            (graph omega h)
            Hpow
            Hprop).
Qed.

(** Helper: a sequence supported at coordinate 0 **)
Definition Romega_singleton_seq : set -> set := fun r =>
  graph omega (fun i:set => If_i (0 :e i) 0 r).

(** Helper: singleton sequence is in the ambient product space **)
Theorem Romega_singleton_seq_in_Romega_space : forall r:set,
  r :e R -> Romega_singleton_seq r :e R_omega_space.
let r. assume Hr: r :e R.
prove Romega_singleton_seq r :e R_omega_space.
claim Hdef: Romega_singleton_seq r = graph omega (fun i:set => If_i (0 :e i) 0 r).
{ reflexivity. }
rewrite Hdef.
apply (graph_omega_in_Romega_space (fun i:set => If_i (0 :e i) 0 r)).
let i. assume Hi: i :e omega.
prove If_i (0 :e i) 0 r :e R.
apply (xm (0 :e i)).
- assume H0i: 0 :e i.
  rewrite (If_i_1 (0 :e i) 0 r H0i).
  exact real_0.
- assume Hn0i: ~(0 :e i).
  rewrite (If_i_0 (0 :e i) 0 r Hn0i).
  exact Hr.
Qed.

(** Helper: coordinate evaluation of the singleton sequence **)
(** LATEX VERSION: For the singleton sequence r  (r,0,0,...), the i-th coordinate is If(0 in i) then 0 else r. **)
Theorem Romega_singleton_seq_apply : forall r i:set,
  r :e R ->
  i :e omega ->
  apply_fun (Romega_singleton_seq r) i = If_i (0 :e i) 0 r.
let r i.
assume Hr: r :e R.
assume Hi: i :e omega.
prove apply_fun (Romega_singleton_seq r) i = If_i (0 :e i) 0 r.
claim Hdef: Romega_singleton_seq r = graph omega (fun j:set => If_i (0 :e j) 0 r).
{ reflexivity. }
rewrite Hdef.
exact (apply_fun_graph omega (fun j:set => If_i (0 :e j) 0 r) i Hi).
Qed.

(** Helper: singleton sequence is in Romega_tilde 0 **)
Theorem Romega_singleton_seq_in_Romega_tilde0 : forall r:set,
  r :e R -> Romega_singleton_seq r :e Romega_tilde 0.
let r. assume Hr: r :e R.
prove Romega_singleton_seq r :e Romega_tilde 0.
claim HdefT: Romega_tilde 0 =
  {f :e R_omega_space | forall i:set, i :e omega -> 0 :e i -> apply_fun f i = 0}.
{ reflexivity. }
rewrite HdefT.
apply (SepI R_omega_space (fun f0:set => forall i:set, i :e omega -> 0 :e i -> apply_fun f0 i = 0)).
- exact (Romega_singleton_seq_in_Romega_space r Hr).
- let i. assume Hi: i :e omega.
  assume H0i: 0 :e i.
  prove apply_fun (Romega_singleton_seq r) i = 0.
  claim Happ: apply_fun (Romega_singleton_seq r) i = If_i (0 :e i) 0 r.
  { claim Hdef: Romega_singleton_seq r = graph omega (fun j:set => If_i (0 :e j) 0 r).
    { reflexivity. }
    rewrite Hdef.
    exact (apply_fun_graph omega (fun j:set => If_i (0 :e j) 0 r) i Hi). }
  rewrite Happ.
  rewrite (If_i_1 (0 :e i) 0 r H0i).
  reflexivity.
Qed.

(** Helper: map r in R to the singleton sequence **)
Definition Romega_singleton_map : set := graph R Romega_singleton_seq.

(** Helper: apply_fun for Romega_singleton_map **)
Theorem Romega_singleton_map_apply : forall r:set,
  r :e R -> apply_fun Romega_singleton_map r = Romega_singleton_seq r.
let r. assume Hr: r :e R.
prove apply_fun Romega_singleton_map r = Romega_singleton_seq r.
claim Hdef: Romega_singleton_map = graph R Romega_singleton_seq.
{ reflexivity. }
rewrite Hdef.
exact (apply_fun_graph R Romega_singleton_seq r Hr).
Qed.

(** Helper: singleton map is a function into the ambient product space **)
Theorem Romega_singleton_map_function_on :
  function_on Romega_singleton_map R R_omega_space.
prove function_on Romega_singleton_map R R_omega_space.
let r. assume Hr: r :e R.
prove apply_fun Romega_singleton_map r :e R_omega_space.
rewrite (Romega_singleton_map_apply r Hr).
exact (Romega_singleton_seq_in_Romega_space r Hr).
Qed.

(** Helper: singleton map is continuous into the product topology on R_omega_space **)
(** LATEX VERSION: The coordinate-inclusion map r  (r,0,0,...) is continuous in the product topology. **)
Theorem Romega_singleton_map_continuous_prod :
  continuous_map R R_standard_topology R_omega_space R_omega_product_topology Romega_singleton_map.
prove continuous_map R R_standard_topology R_omega_space R_omega_product_topology Romega_singleton_map.
set Xi := const_space_family omega R R_standard_topology.
set S := product_subbasis_full omega Xi.
claim HtopR: topology_on R R_standard_topology.
{ exact R_standard_topology_is_topology. }
claim Hfun: function_on Romega_singleton_map R R_omega_space.
{ exact Romega_singleton_map_function_on. }
claim Hone: omega <> Empty.
{ claim H0o: 0 :e omega.
  { exact (nat_p_omega 0 nat_0). }
  exact (elem_implies_nonempty omega 0 H0o). }
claim Hcomp: forall i:set, i :e omega -> topology_on (space_family_set Xi i) (space_family_topology Xi i).
{ let i. assume Hi: i :e omega.
  claim HXi: apply_fun Xi i = (R, R_standard_topology).
  { exact (const_space_family_apply omega R R_standard_topology i Hi). }
  claim Hset: space_family_set Xi i = R.
  { claim Hdef: space_family_set Xi i = (apply_fun Xi i) 0.
    { reflexivity. }
    rewrite Hdef.
    rewrite HXi.
    exact (tuple_2_0_eq R R_standard_topology). }
  claim Htop: space_family_topology Xi i = R_standard_topology.
  { claim Hdef: space_family_topology Xi i = (apply_fun Xi i) 1.
    { reflexivity. }
    rewrite Hdef.
    rewrite HXi.
    exact (tuple_2_1_eq R R_standard_topology). }
  rewrite Hset.
  rewrite Htop.
  exact R_standard_topology_is_topology. }
claim HS: subbasis_on R_omega_space S.
{ prove S c= Power R_omega_space /\ Union S = R_omega_space.
  apply andI.
  - let s. assume Hs: s :e S.
    prove s :e Power R_omega_space.
    apply PowerI.
    let f. assume Hf: f :e s.
    prove f :e R_omega_space.
    set F := (fun i:set => {product_cylinder omega Xi i U|U :e space_family_topology Xi i}).
    claim HsF: s :e (\/_ i :e omega, F i).
    { exact Hs. }
    apply (famunionE_impred omega F s HsF (f :e R_omega_space)).
    let i. assume Hi: i :e omega.
    assume HsFi: s :e F i.
    apply (ReplE_impred (space_family_topology Xi i) (fun U0:set => product_cylinder omega Xi i U0) s HsFi
                        (f :e R_omega_space)).
    let U.
    assume HU: U :e space_family_topology Xi i.
    assume Hseq: s = product_cylinder omega Xi i U.
    claim HfCyl: f :e product_cylinder omega Xi i U.
    { rewrite <- Hseq.
      exact Hf. }
    claim Hfprod: f :e product_space omega Xi.
    { exact (SepE1 (product_space omega Xi)
                   (fun g:set => i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U)
                   f
                   HfCyl). }
    exact Hfprod.
  - (** Union S = R_omega_space **)
    apply set_ext.
    - let f. assume Hf: f :e Union S.
      prove f :e R_omega_space.
      claim HSsubPow: S c= Power R_omega_space.
      { let s. assume Hs: s :e S.
        prove s :e Power R_omega_space.
        apply PowerI.
        let g. assume Hg: g :e s.
        prove g :e R_omega_space.
        set F := (fun i:set => {product_cylinder omega Xi i U|U :e space_family_topology Xi i}).
        claim HsF: s :e (\/_ i :e omega, F i).
        { exact Hs. }
        apply (famunionE_impred omega F s HsF (g :e R_omega_space)).
        let i. assume Hi: i :e omega.
        assume HsFi: s :e F i.
        apply (ReplE_impred (space_family_topology Xi i) (fun U0:set => product_cylinder omega Xi i U0) s HsFi
                            (g :e R_omega_space)).
        let U.
        assume HU: U :e space_family_topology Xi i.
        assume Hseq: s = product_cylinder omega Xi i U.
        claim HgCyl: g :e product_cylinder omega Xi i U.
        { rewrite <- Hseq.
          exact Hg. }
        exact (SepE1 (product_space omega Xi)
                     (fun h:set => i :e omega /\ U :e space_family_topology Xi i /\ apply_fun h i :e U)
                     g
                     HgCyl). }
      apply (UnionE_impred S f Hf).
      let s. assume Hfs: f :e s. assume Hs: s :e S.
      claim HsPow: s :e Power R_omega_space.
      { exact (HSsubPow s Hs). }
      claim HsSub: s c= R_omega_space.
      { exact (PowerE R_omega_space s HsPow). }
      exact (HsSub f Hfs).
    - let f. assume Hf: f :e R_omega_space.
      prove f :e Union S.
      claim H0o: 0 :e omega.
      { exact (nat_p_omega 0 nat_0). }
      claim HXi0: apply_fun Xi 0 = (R, R_standard_topology).
      { exact (const_space_family_apply omega R R_standard_topology 0 H0o). }
      claim Htop0: space_family_topology Xi 0 = R_standard_topology.
      { claim Hdef: space_family_topology Xi 0 = (apply_fun Xi 0) 1.
        { reflexivity. }
        rewrite Hdef.
        rewrite HXi0.
        exact (tuple_2_1_eq R R_standard_topology). }
      claim HRin: R :e space_family_topology Xi 0.
      { rewrite Htop0.
        exact (topology_has_X R R_standard_topology R_standard_topology_is_topology). }
      set s0 := product_cylinder omega Xi 0 R.
      claim Hs0S: s0 :e S.
      { set F := (fun i:set => {product_cylinder omega Xi i U|U :e space_family_topology Xi i}).
        claim Hs0F0: s0 :e F 0.
        { exact (ReplI (space_family_topology Xi 0) (fun U0:set => product_cylinder omega Xi 0 U0) R HRin). }
        exact (famunionI omega F 0 s0 H0o Hs0F0). }
      claim Hf0R: apply_fun f 0 :e R.
      { exact (Romega_coord_in_R f 0 Hf H0o). }
      claim HXdef: R_omega_space = product_space omega Xi.
      { reflexivity. }
      claim Hfprod: f :e product_space omega Xi.
      { rewrite <- HXdef.
        exact Hf. }
      claim Hfs0: f :e s0.
      { claim Hs0def: s0 = product_cylinder omega Xi 0 R.
        { reflexivity. }
        rewrite Hs0def.
        claim Hcyl_def: product_cylinder omega Xi 0 R =
          {g :e product_space omega Xi | 0 :e omega /\ R :e space_family_topology Xi 0 /\ apply_fun g 0 :e R}.
        { reflexivity. }
        rewrite Hcyl_def.
        apply (SepI (product_space omega Xi)
                    (fun g:set => 0 :e omega /\ R :e space_family_topology Xi 0 /\ apply_fun g 0 :e R)
                    f
                    Hfprod).
        apply andI.
        - apply andI.
          + exact H0o.
          + exact HRin.
        - exact Hf0R. }
      exact (UnionI S f s0 Hfs0 Hs0S).
}
claim Hpre: forall s:set, s :e S -> preimage_of R Romega_singleton_map s :e R_standard_topology.
{ let s. assume Hs: s :e S.
  set F := (fun i:set => {product_cylinder omega Xi i U|U :e space_family_topology Xi i}).
  claim HsF: s :e (\/_ i :e omega, F i).
  { exact Hs. }
  apply (famunionE_impred omega F s HsF (preimage_of R Romega_singleton_map s :e R_standard_topology)).
  let i. assume Hi: i :e omega.
  assume HsFi: s :e F i.
  apply (ReplE_impred (space_family_topology Xi i) (fun U0:set => product_cylinder omega Xi i U0) s HsFi
                      (preimage_of R Romega_singleton_map s :e R_standard_topology)).
  let U. assume HUtop: U :e space_family_topology Xi i.
  assume Hseq: s = product_cylinder omega Xi i U.
  rewrite Hseq.
  claim HXi: apply_fun Xi i = (R, R_standard_topology).
  { exact (const_space_family_apply omega R R_standard_topology i Hi). }
  claim Htopi: space_family_topology Xi i = R_standard_topology.
  { claim Hdef: space_family_topology Xi i = (apply_fun Xi i) 1.
    { reflexivity. }
    rewrite Hdef.
    rewrite HXi.
    exact (tuple_2_1_eq R R_standard_topology). }
  claim HUstd: U :e R_standard_topology.
  { rewrite <- Htopi.
    exact HUtop. }
  claim HUsubR: U c= R.
  { claim HtopSub: R_standard_topology c= Power R.
    { exact (topology_subset_axiom R R_standard_topology R_standard_topology_is_topology). }
    claim HUpow: U :e Power R.
    { exact (HtopSub U HUstd). }
    exact (PowerE R U HUpow). }
  apply (xm (0 :e i)).
  + assume H0i: 0 :e i.
    apply (xm (0 :e U)).
    - assume H0U: 0 :e U.
      claim Heq: preimage_of R Romega_singleton_map (product_cylinder omega Xi i U) = R.
      { apply set_ext.
        - let r. assume Hrpre: r :e preimage_of R Romega_singleton_map (product_cylinder omega Xi i U).
          prove r :e R.
          claim Hrpre2: r :e {x0 :e R | apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U}.
          { claim Hpre_def: preimage_of R Romega_singleton_map (product_cylinder omega Xi i U) =
              {x0 :e R | apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U}.
            { reflexivity. }
            rewrite <- Hpre_def.
            exact Hrpre. }
          exact (SepE1 R (fun x0:set => apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U) r Hrpre2).
        - let r. assume HrR: r :e R.
          prove r :e preimage_of R Romega_singleton_map (product_cylinder omega Xi i U).
          claim Hpre_def: preimage_of R Romega_singleton_map (product_cylinder omega Xi i U) =
            {x0 :e R | apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U}.
          { reflexivity. }
          rewrite Hpre_def.
          apply (SepI R (fun x0:set => apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U) r HrR).
          prove apply_fun Romega_singleton_map r :e product_cylinder omega Xi i U.
          claim Happmap: apply_fun Romega_singleton_map r = Romega_singleton_seq r.
          { exact (Romega_singleton_map_apply r HrR). }
          rewrite Happmap.
          claim HXdef: R_omega_space = product_space omega Xi.
          { reflexivity. }
          claim Hrseq: Romega_singleton_seq r :e product_space omega Xi.
          { rewrite <- HXdef.
            exact (Romega_singleton_seq_in_Romega_space r HrR). }
          claim Hcyl_def: product_cylinder omega Xi i U =
            {g :e product_space omega Xi | i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U}.
          { reflexivity. }
          rewrite Hcyl_def.
          apply (SepI (product_space omega Xi)
                      (fun g:set => i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U)
                      (Romega_singleton_seq r)
                      Hrseq).
          apply andI.
          + apply andI.
            * exact Hi.
            * exact HUtop.
          + claim Happi: apply_fun (Romega_singleton_seq r) i = If_i (0 :e i) 0 r.
            { exact (Romega_singleton_seq_apply r i HrR Hi). }
            rewrite Happi.
            rewrite (If_i_1 (0 :e i) 0 r H0i).
            exact H0U. }
      rewrite Heq.
      exact (topology_has_X R R_standard_topology R_standard_topology_is_topology).
    - assume Hn0U: ~(0 :e U).
      claim Heq: preimage_of R Romega_singleton_map (product_cylinder omega Xi i U) = Empty.
      { apply set_ext.
        - let r. assume Hrpre: r :e preimage_of R Romega_singleton_map (product_cylinder omega Xi i U).
          prove r :e Empty.
          apply FalseE.
          claim Hrpre2: r :e {x0 :e R | apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U}.
          { claim Hpre_def: preimage_of R Romega_singleton_map (product_cylinder omega Xi i U) =
              {x0 :e R | apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U}.
            { reflexivity. }
            rewrite <- Hpre_def.
            exact Hrpre. }
          claim HrR: r :e R.
          { exact (SepE1 R (fun x0:set => apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U) r Hrpre2). }
          claim Hcond: apply_fun Romega_singleton_map r :e product_cylinder omega Xi i U.
          { exact (SepE2 R (fun x0:set => apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U) r Hrpre2). }
          claim Happmap: apply_fun Romega_singleton_map r = Romega_singleton_seq r.
          { exact (Romega_singleton_map_apply r HrR). }
          claim Hcond2: Romega_singleton_seq r :e product_cylinder omega Xi i U.
          { rewrite <- Happmap.
            exact Hcond. }
          claim Hcyl_def: product_cylinder omega Xi i U =
            {g :e product_space omega Xi | i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U}.
          { reflexivity. }
          claim Hcond3: Romega_singleton_seq r :e
            {g :e product_space omega Xi | i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U}.
          { rewrite <- Hcyl_def.
            exact Hcond2. }
          claim Hprop: i :e omega /\ U :e space_family_topology Xi i /\ apply_fun (Romega_singleton_seq r) i :e U.
          { exact (SepE2 (product_space omega Xi)
                         (fun g:set => i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U)
                         (Romega_singleton_seq r)
                         Hcond3). }
          claim Hri: apply_fun (Romega_singleton_seq r) i :e U.
          { exact (andER (i :e omega /\ U :e space_family_topology Xi i)
                         (apply_fun (Romega_singleton_seq r) i :e U)
                         Hprop). }
          claim Happi: apply_fun (Romega_singleton_seq r) i = If_i (0 :e i) 0 r.
          { exact (Romega_singleton_seq_apply r i HrR Hi). }
          claim HriIf: If_i (0 :e i) 0 r :e U.
          { rewrite <- Happi.
            exact Hri. }
          claim Hif1: If_i (0 :e i) 0 r = 0.
          { exact (If_i_1 (0 :e i) 0 r H0i). }
          claim H0U: 0 :e U.
          { rewrite <- Hif1.
            exact HriIf. }
          exact (Hn0U H0U).
        - let r. assume HrE: r :e Empty.
          prove r :e preimage_of R Romega_singleton_map (product_cylinder omega Xi i U).
          apply FalseE.
          exact (EmptyE r HrE). }
      rewrite Heq.
      exact (topology_has_empty R R_standard_topology R_standard_topology_is_topology).
  + assume Hn0i: ~(0 :e i).
    claim Heq: preimage_of R Romega_singleton_map (product_cylinder omega Xi i U) = U.
    { apply set_ext.
      - let r. assume Hrpre: r :e preimage_of R Romega_singleton_map (product_cylinder omega Xi i U).
        prove r :e U.
        claim Hrpre2: r :e {x0 :e R | apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U}.
        { claim Hpre_def: preimage_of R Romega_singleton_map (product_cylinder omega Xi i U) =
            {x0 :e R | apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U}.
          { reflexivity. }
          rewrite <- Hpre_def.
          exact Hrpre. }
        claim HrR: r :e R.
        { exact (SepE1 R (fun x0:set => apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U) r Hrpre2). }
        claim Hcond: apply_fun Romega_singleton_map r :e product_cylinder omega Xi i U.
        { exact (SepE2 R (fun x0:set => apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U) r Hrpre2). }
        claim Happmap: apply_fun Romega_singleton_map r = Romega_singleton_seq r.
        { exact (Romega_singleton_map_apply r HrR). }
        claim Hcond2: Romega_singleton_seq r :e product_cylinder omega Xi i U.
        { rewrite <- Happmap.
          exact Hcond. }
        claim Hcyl_def: product_cylinder omega Xi i U =
          {g :e product_space omega Xi | i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U}.
        { reflexivity. }
        claim Hcond3: Romega_singleton_seq r :e
          {g :e product_space omega Xi | i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U}.
        { rewrite <- Hcyl_def.
          exact Hcond2. }
        claim Hprop: i :e omega /\ U :e space_family_topology Xi i /\ apply_fun (Romega_singleton_seq r) i :e U.
        { exact (SepE2 (product_space omega Xi)
                       (fun g:set => i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U)
                       (Romega_singleton_seq r)
                       Hcond3). }
        claim Hri: apply_fun (Romega_singleton_seq r) i :e U.
        { exact (andER (i :e omega /\ U :e space_family_topology Xi i)
                       (apply_fun (Romega_singleton_seq r) i :e U)
                       Hprop). }
        claim Happi: apply_fun (Romega_singleton_seq r) i = If_i (0 :e i) 0 r.
        { exact (Romega_singleton_seq_apply r i HrR Hi). }
        claim HriIf: If_i (0 :e i) 0 r :e U.
        { rewrite <- Happi.
          exact Hri. }
        claim Hif0: If_i (0 :e i) 0 r = r.
        { exact (If_i_0 (0 :e i) 0 r Hn0i). }
        rewrite <- Hif0.
        exact HriIf.
      - let r. assume HrU: r :e U.
        prove r :e preimage_of R Romega_singleton_map (product_cylinder omega Xi i U).
        claim HrR: r :e R.
        { exact (HUsubR r HrU). }
        claim Hpre_def: preimage_of R Romega_singleton_map (product_cylinder omega Xi i U) =
          {x0 :e R | apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U}.
        { reflexivity. }
        rewrite Hpre_def.
        apply (SepI R (fun x0:set => apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U) r HrR).
        prove apply_fun Romega_singleton_map r :e product_cylinder omega Xi i U.
        claim Happmap: apply_fun Romega_singleton_map r = Romega_singleton_seq r.
        { exact (Romega_singleton_map_apply r HrR). }
        rewrite Happmap.
        claim HXdef: R_omega_space = product_space omega Xi.
        { reflexivity. }
        claim Hrseq: Romega_singleton_seq r :e product_space omega Xi.
        { rewrite <- HXdef.
          exact (Romega_singleton_seq_in_Romega_space r HrR). }
        claim Hcyl_def: product_cylinder omega Xi i U =
          {g :e product_space omega Xi | i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U}.
        { reflexivity. }
        rewrite Hcyl_def.
        apply (SepI (product_space omega Xi)
                    (fun g:set => i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U)
                    (Romega_singleton_seq r)
                    Hrseq).
        apply andI.
        + apply andI.
          * exact Hi.
          * exact HUtop.
        + claim Happi: apply_fun (Romega_singleton_seq r) i = If_i (0 :e i) 0 r.
          { exact (Romega_singleton_seq_apply r i HrR Hi). }
          rewrite Happi.
          rewrite (If_i_0 (0 :e i) 0 r Hn0i).
          exact HrU. }
    rewrite Heq.
    exact HUstd. }
claim HdefTy: R_omega_product_topology = generated_topology_from_subbasis R_omega_space S.
{ reflexivity. }
rewrite HdefTy.
exact (continuous_map_from_subbasis R R_standard_topology R_omega_space S Romega_singleton_map
        HtopR Hfun HS Hpre).
Qed.

(** Helper: image of the singleton map lies in Romega_tilde 0 **)
Theorem image_of_Romega_singleton_map_sub_Romega_tilde0 :
  image_of Romega_singleton_map R c= Romega_tilde 0.
let f. assume Hf: f :e image_of Romega_singleton_map R.
prove f :e Romega_tilde 0.
apply (ReplE_impred R (fun r0:set => apply_fun Romega_singleton_map r0) f Hf (f :e Romega_tilde 0)).
let r. assume Hr: r :e R. assume Hfeq: f = apply_fun Romega_singleton_map r.
rewrite Hfeq.
rewrite (Romega_singleton_map_apply r Hr).
exact (Romega_singleton_seq_in_Romega_tilde0 r Hr).
Qed.

(** Helper: extend an element of Romega_tilde k with one more real coordinate at ordsucc k **)
Definition Romega_extend_seq : set -> set -> set := fun k p =>
  graph omega (fun i:set =>
    If_i (ordsucc k :e i) 0
      (If_i (i = ordsucc k) (p 1) (apply_fun (p 0) i))).

(** Helper: extension lands in Romega_tilde (ordsucc k) **)
Theorem Romega_extend_seq_in_Romega_tilde_succ : forall k p:set,
  k :e omega ->
  p :e setprod (Romega_tilde k) R ->
  Romega_extend_seq k p :e Romega_tilde (ordsucc k).
let k p.
assume HkO: k :e omega.
assume Hp: p :e setprod (Romega_tilde k) R.
prove Romega_extend_seq k p :e Romega_tilde (ordsucc k).
set h := (fun i:set =>
    If_i (ordsucc k :e i) 0
      (If_i (i = ordsucc k) (p 1) (apply_fun (p 0) i))).
claim Hdef: Romega_extend_seq k p = graph omega h.
{ reflexivity. }
rewrite Hdef.
claim HdefT: Romega_tilde (ordsucc k) =
  {f :e R_omega_space | forall i:set, i :e omega -> ordsucc k :e i -> apply_fun f i = 0}.
{ reflexivity. }
rewrite HdefT.
apply (SepI R_omega_space (fun f0:set => forall i:set, i :e omega -> ordsucc k :e i -> apply_fun f0 i = 0)).
- (** graph omega h is in the ambient product space **)
  apply (graph_omega_in_Romega_space h).
  let i. assume Hi: i :e omega.
  prove h i :e R.
  claim Hhi: h i = If_i (ordsucc k :e i) 0 (If_i (i = ordsucc k) (p 1) (apply_fun (p 0) i)).
  { reflexivity. }
  rewrite Hhi.
  apply (xm (ordsucc k :e i)).
  + assume Hki: ordsucc k :e i.
    rewrite (If_i_1 (ordsucc k :e i) 0 (If_i (i = ordsucc k) (p 1) (apply_fun (p 0) i)) Hki).
    exact real_0.
  + assume Hnki: ~(ordsucc k :e i).
    rewrite (If_i_0 (ordsucc k :e i) 0 (If_i (i = ordsucc k) (p 1) (apply_fun (p 0) i)) Hnki).
    apply (xm (i = ordsucc k)).
    * assume Hieq.
      rewrite (If_i_1 (i = ordsucc k) (p 1) (apply_fun (p 0) i) Hieq).
      (** second coordinate of p lies in R **)
      claim Hp1: p 1 :e R.
      { claim Hp1raw: p 1 :e (fun _ : set => R) (p 0).
        { exact (ap1_Sigma (Romega_tilde k) (fun _ : set => R) p Hp). }
        exact Hp1raw. }
      exact Hp1.
    * assume Hineq.
      rewrite (If_i_0 (i = ordsucc k) (p 1) (apply_fun (p 0) i) Hineq).
      (** first coordinate of p lies in Romega_tilde k, hence in R_omega_space **)
      claim Hp0: p 0 :e Romega_tilde k.
      { exact (ap0_Sigma (Romega_tilde k) (fun _ : set => R) p Hp). }
      claim Hp0X: p 0 :e R_omega_space.
      { exact (Romega_tilde_sub_Romega k (p 0) Hp0). }
      exact (Romega_coord_in_R (p 0) i Hp0X Hi).
- (** verify the defining property of Romega_tilde (ordsucc k) **)
  let i. assume Hi: i :e omega.
  assume Hki: ordsucc k :e i.
  prove apply_fun (graph omega h) i = 0.
  claim Happ: apply_fun (graph omega h) i = h i.
  { exact (apply_fun_graph omega h i Hi). }
  rewrite Happ.
  claim Hhi: h i = If_i (ordsucc k :e i) 0 (If_i (i = ordsucc k) (p 1) (apply_fun (p 0) i)).
  { reflexivity. }
  rewrite Hhi.
  rewrite (If_i_1 (ordsucc k :e i) 0 (If_i (i = ordsucc k) (p 1) (apply_fun (p 0) i)) Hki).
  reflexivity.
Qed.

(** Helper: map extending Romega_tilde k by one coordinate **)
Definition Romega_extend_map : set -> set := fun k =>
  graph (setprod (Romega_tilde k) R) (fun p:set => Romega_extend_seq k p).

(** Helper: apply_fun for Romega_extend_map **)
Theorem Romega_extend_map_apply : forall k p:set,
  k :e omega ->
  p :e setprod (Romega_tilde k) R ->
  apply_fun (Romega_extend_map k) p = Romega_extend_seq k p.
let k p.
assume HkO: k :e omega.
assume Hp: p :e setprod (Romega_tilde k) R.
prove apply_fun (Romega_extend_map k) p = Romega_extend_seq k p.
claim Hdef: Romega_extend_map k = graph (setprod (Romega_tilde k) R) (fun q:set => Romega_extend_seq k q).
{ reflexivity. }
rewrite Hdef.
exact (apply_fun_graph (setprod (Romega_tilde k) R) (fun q:set => Romega_extend_seq k q) p Hp).
Qed.

(** Helper: extension map is a function into the ambient product space **)
Theorem Romega_extend_map_function_on : forall k:set,
  k :e omega ->
  function_on (Romega_extend_map k) (setprod (Romega_tilde k) R) R_omega_space.
let k. assume HkO: k :e omega.
prove function_on (Romega_extend_map k) (setprod (Romega_tilde k) R) R_omega_space.
let p. assume Hp: p :e setprod (Romega_tilde k) R.
prove apply_fun (Romega_extend_map k) p :e R_omega_space.
rewrite (Romega_extend_map_apply k p HkO Hp).
claim Htilde: Romega_extend_seq k p :e Romega_tilde (ordsucc k).
{ exact (Romega_extend_seq_in_Romega_tilde_succ k p HkO Hp). }
exact (Romega_tilde_sub_Romega (ordsucc k) (Romega_extend_seq k p) Htilde).
Qed.

(** Helper: image of the extension map lies in Romega_tilde (ordsucc k) **)
Theorem image_of_Romega_extend_map_sub_Romega_tilde_succ : forall k:set,
  k :e omega ->
  image_of (Romega_extend_map k) (setprod (Romega_tilde k) R) c= Romega_tilde (ordsucc k).
let k. assume HkO: k :e omega.
let f. assume Hf: f :e image_of (Romega_extend_map k) (setprod (Romega_tilde k) R).
prove f :e Romega_tilde (ordsucc k).
apply (ReplE_impred (setprod (Romega_tilde k) R) (fun p0:set => apply_fun (Romega_extend_map k) p0) f Hf
       (f :e Romega_tilde (ordsucc k))).
let p. assume Hp: p :e setprod (Romega_tilde k) R.
assume Hfeq: f = apply_fun (Romega_extend_map k) p.
rewrite Hfeq.
rewrite (Romega_extend_map_apply k p HkO Hp).
exact (Romega_extend_seq_in_Romega_tilde_succ k p HkO Hp).
Qed.

(** Helper: extension identifies Romega_tilde (ordsucc k) with a product **)
Theorem Romega_tilde_succ_homeomorphism : forall k:set,
  k :e omega ->
  homeomorphism
    (setprod (Romega_tilde k) R)
    (product_topology (Romega_tilde k) (subspace_topology R_omega_space R_omega_product_topology (Romega_tilde k))
                      R R_standard_topology)
    (Romega_tilde (ordsucc k))
    (subspace_topology R_omega_space R_omega_product_topology (Romega_tilde (ordsucc k)))
    (Romega_extend_map k).
admit.
Qed.

(** Helper: every finite subset of omega is bounded by some n in omega **)
Theorem finite_subset_of_omega_bounded : forall F:set,
  F c= omega -> finite F -> exists n :e omega, forall m :e F, m :e n.
let F.
assume HFsub: F c= omega.
assume HFfin: finite F.
prove exists n :e omega, forall m :e F, m :e n.
claim Hp0: (Empty c= omega -> exists n :e omega, forall m :e Empty, m :e n).
{ assume Hsub0: Empty c= omega.
  prove exists n :e omega, forall m :e Empty, m :e n.
  witness 0.
  apply andI.
  - exact (nat_p_omega 0 nat_0).
  - let m. assume Hm: m :e Empty.
    apply FalseE.
    exact (EmptyE m Hm). }
claim Hpstep: forall A y, finite A -> y /:e A ->
  (A c= omega -> exists n :e omega, forall m :e A, m :e n) ->
  (A :\/: {y} c= omega -> exists n0 :e omega, forall m:set, m :e A :\/: {y} -> m :e n0).
{ let A y.
  assume HAfin: finite A.
  assume HyA: y /:e A.
  assume HpA: (A c= omega -> exists n :e omega, forall m :e A, m :e n).
  assume HsubAy: A :\/: {y} c= omega.
  claim HsubA: A c= omega.
  { exact (Subq_tra A (A :\/: {y}) omega (binunion_Subq_1 A {y}) HsubAy). }
  claim Hexn: exists n :e omega, forall m :e A, m :e n.
  { exact (HpA HsubA). }
  apply Hexn.
  let n.
  assume Hnand.
  claim Hn: n :e omega.
  { exact (andEL (n :e omega) (forall m :e A, m :e n) Hnand). }
  claim Hnprop: forall m :e A, m :e n.
  { exact (andER (n :e omega) (forall m :e A, m :e n) Hnand). }
  prove exists n0 :e omega, forall m:set, m :e A :\/: {y} -> m :e n0.
  claim Hy_in_union: y :e A :\/: {y}.
  { apply binunionI2. exact (SingI y). }
  claim Hy_omega: y :e omega.
  { exact (HsubAy y Hy_in_union). }
  claim Hysucc_omega: ordsucc y :e omega.
  { exact (omega_ordsucc y Hy_omega). }
  claim Hn_union_omega: n :\/: ordsucc y :e omega.
  { exact (omega_binunion n (ordsucc y) Hn Hysucc_omega). }
  set n0 := ordsucc (n :\/: ordsucc y).
  claim Hn0_omega: n0 :e omega.
  { exact (omega_ordsucc (n :\/: ordsucc y) Hn_union_omega). }
  witness n0.
  apply andI.
  - exact Hn0_omega.
  - let m. assume Hm: m :e A :\/: {y}.
    prove m :e n0.
    apply (binunionE A {y} m Hm).
    + assume HmA: m :e A.
      claim Hmn: m :e n.
      { exact (Hnprop m HmA). }
      claim HmnU: m :e n :\/: ordsucc y.
      { exact (binunionI1 n (ordsucc y) m Hmn). }
      exact (ordsuccI1 (n :\/: ordsucc y) m HmnU).
    + assume HmY: m :e {y}.
      claim Hmy: m = y.
      { exact (SingE y m HmY). }
      rewrite Hmy.
      claim Hy_in_succ: y :e ordsucc y.
      { exact (ordsuccI2 y). }
      claim Hy_in_U: y :e n :\/: ordsucc y.
      { exact (binunionI2 n (ordsucc y) y Hy_in_succ). }
      exact (ordsuccI1 (n :\/: ordsucc y) y Hy_in_U). }
claim HpF: (F c= omega -> exists n :e omega, forall m :e F, m :e n).
{ exact (finite_ind (fun A => A c= omega -> exists n :e omega, forall m :e A, m :e n)
                    Hp0 Hpstep F HFfin). }
exact (HpF HFsub).
Qed.

(** Helper: basis neighborhoods in the product topology meet Romega_infty **)
(** LATEX VERSION: Any basic open neighborhood in the product topology contains a point of R^infty by truncating outside finitely many constrained coordinates. **)
Theorem Romega_infty_meets_product_basis : forall b x:set,
  b :e basis_of_subbasis R_omega_space (product_subbasis_full omega (const_space_family omega R R_standard_topology)) ->
  x :e b ->
  b :/\: Romega_infty <> Empty.
let b x.
assume Hb: b :e basis_of_subbasis R_omega_space (product_subbasis_full omega (const_space_family omega R R_standard_topology)).
assume Hxb: x :e b.
prove b :/\: Romega_infty <> Empty.
set X := R_omega_space.
set Xi := const_space_family omega R R_standard_topology.
set S := product_subbasis_full omega Xi.
set B := basis_of_subbasis X S.
claim HbB: b :e B.
{ exact Hb. }
(** Unpack basis_of_subbasis membership. **)
claim Hbfin: b :e finite_intersections_of X S.
{ exact (SepE1 (finite_intersections_of X S) (fun b0:set => b0 <> Empty) b HbB). }
claim Hbne: b <> Empty.
{ exact (SepE2 (finite_intersections_of X S) (fun b0:set => b0 <> Empty) b HbB). }
(** Choose finite subcollection F of S with b = intersection_of_family X F. **)
apply (ReplE_impred (finite_subcollections S) (fun F0:set => intersection_of_family X F0) b Hbfin (b :/\: Romega_infty <> Empty)).
let F.
assume HF: F :e finite_subcollections S.
assume Hbeq: b = intersection_of_family X F.
rewrite Hbeq at 1.
(** Extract basic properties of F. **)
claim HFpow: F :e Power S.
{ exact (SepE1 (Power S) (fun F0:set => finite F0) F HF). }
claim HFsubS: F c= S.
{ exact (PowerE S F HFpow). }
claim HFfin: finite F.
{ exact (SepE2 (Power S) (fun F0:set => finite F0) F HF). }
(** x lies in the intersection, hence in X and in every s in F. **)
claim HxInt: x :e intersection_of_family X F.
{ rewrite <- Hbeq.
  exact Hxb. }
claim HxX: x :e X.
{ exact (SepE1 X (fun x0:set => forall U:set, U :e F -> x0 :e U) x HxInt). }
claim HxAll: forall s:set, s :e F -> x :e s.
{ exact (SepE2 X (fun x0:set => forall U:set, U :e F -> x0 :e U) x HxInt). }

(** Pick for each s :e F a coordinate index in omega witnessing s :e S. **)
set CylFam := fun i:set => {product_cylinder omega Xi i U|U :e space_family_topology Xi i}.
set pick_i := fun s:set => Eps_i (fun i:set => i :e omega /\ s :e CylFam i).

claim Hpick_omega: forall s:set, s :e F -> pick_i s :e omega.
{ let s. assume HsF: s :e F.
  prove pick_i s :e omega.
  claim HsS: s :e S.
  { exact (HFsubS s HsF). }
  claim Hex: exists i:set, i :e omega /\ s :e CylFam i.
  { exact (famunionE omega (fun i:set => CylFam i) s HsS). }
  claim Hpick: pick_i s :e omega /\ s :e CylFam (pick_i s).
  { exact (Eps_i_ex (fun i:set => i :e omega /\ s :e CylFam i) Hex). }
  exact (andEL (pick_i s :e omega) (s :e CylFam (pick_i s)) Hpick). }

claim Hpick_in: forall s:set, s :e F -> s :e CylFam (pick_i s).
{ let s. assume HsF: s :e F.
  prove s :e CylFam (pick_i s).
  claim HsS: s :e S.
  { exact (HFsubS s HsF). }
  claim Hex: exists i:set, i :e omega /\ s :e CylFam i.
  { exact (famunionE omega (fun i:set => CylFam i) s HsS). }
  claim Hpick: pick_i s :e omega /\ s :e CylFam (pick_i s).
  { exact (Eps_i_ex (fun i:set => i :e omega /\ s :e CylFam i) Hex). }
  exact (andER (pick_i s :e omega) (s :e CylFam (pick_i s)) Hpick). }

(** The set of picked indices is finite and contained in omega. **)
set J := {pick_i s|s :e F}.
claim HJfin: finite J.
{ exact (Repl_finite (fun s:set => pick_i s) F HFfin). }
claim HJsub: J c= omega.
{ let j. assume Hj: j :e J.
  prove j :e omega.
  apply (ReplE_impred F (fun s:set => pick_i s) j Hj (j :e omega)).
  let s. assume HsF: s :e F.
  assume Hjeq: j = pick_i s.
  rewrite Hjeq.
  exact (Hpick_omega s HsF). }

(** Choose n bounding all picked indices. **)
claim Hexn: exists n :e omega, forall m :e J, m :e n.
{ exact (finite_subset_of_omega_bounded J HJsub HJfin). }
apply Hexn.
let n.
assume Hnand.
claim HnO: n :e omega.
{ exact (andEL (n :e omega) (forall m :e J, m :e n) Hnand). }
claim Hnprop: forall m :e J, m :e n.
{ exact (andER (n :e omega) (forall m :e J, m :e n) Hnand). }

(** Define a truncation of x: keep x on indices in n, and 0 beyond n. **)
set h := fun i:set => If_i (n :e i) 0 (apply_fun x i).
set f := graph omega h.

claim HhR: forall i:set, i :e omega -> h i :e R.
{ let i. assume Hi: i :e omega.
  prove h i :e R.
  claim Hhdef: h i = If_i (n :e i) 0 (apply_fun x i).
  { reflexivity. }
  apply (xm (n :e i)).
  - assume Hni: n :e i.
    rewrite Hhdef.
    rewrite (If_i_1 (n :e i) 0 (apply_fun x i) Hni).
    exact real_0.
  - assume Hnni: ~(n :e i).
    rewrite Hhdef.
    rewrite (If_i_0 (n :e i) 0 (apply_fun x i) Hnni).
    exact (Romega_coord_in_R x i HxX Hi). }

claim HfX: f :e X.
{ exact (graph_omega_in_Romega_space h HhR). }

(** f is eventually zero from index n onward, hence lies in Romega_infty. **)
claim Hftilde: f :e Romega_tilde n.
{ prove f :e Romega_tilde n.
  prove f :e {f0 :e X | forall i:set, i :e omega -> n :e i -> apply_fun f0 i = 0}.
  apply (SepI X (fun f0:set => forall i:set, i :e omega -> n :e i -> apply_fun f0 i = 0) f HfX).
  let i. assume Hi: i :e omega. assume Hni: n :e i.
  prove apply_fun f i = 0.
  claim Happ: apply_fun f i = h i.
  { exact (apply_fun_graph omega h i Hi). }
  rewrite Happ.
  claim Hhdef: h i = If_i (n :e i) 0 (apply_fun x i).
  { reflexivity. }
  rewrite Hhdef.
  rewrite (If_i_1 (n :e i) 0 (apply_fun x i) Hni).
  reflexivity. }
claim HfA: f :e Romega_infty.
{ prove f :e Romega_infty.
  set Y := Romega_tilde n.
  claim HYn: Y :e {Romega_tilde k|k :e omega}.
  { exact (ReplI omega (fun k:set => Romega_tilde k) n HnO). }
  exact (UnionI {Romega_tilde k|k :e omega} f Y Hftilde HYn). }

(** Show f lies in the intersection_of_family X F, hence in b. **)
claim HfInt: f :e intersection_of_family X F.
{ prove f :e intersection_of_family X F.
  prove f :e {x0 :e X|forall U:set, U :e F -> x0 :e U}.
  apply (SepI X (fun x0:set => forall U:set, U :e F -> x0 :e U) f HfX).
  let s. assume HsF: s :e F.
  prove f :e s.
  (** Expand s as a product_cylinder at coordinate pick_i s. **)
  claim HsCyl: s :e CylFam (pick_i s).
  { exact (Hpick_in s HsF). }
  apply (ReplE_impred (space_family_topology Xi (pick_i s))
          (fun U:set => product_cylinder omega Xi (pick_i s) U)
          s
          HsCyl
          (f :e s)).
  let U.
  assume HU: U :e space_family_topology Xi (pick_i s).
  assume Hseq: s = product_cylinder omega Xi (pick_i s) U.
  rewrite Hseq.
  (** Extract that x satisfies this cylinder, hence x(pick_i s) :e U. **)
  claim Hxs: x :e s.
  { exact (HxAll s HsF). }
  claim HxCyl: x :e product_cylinder omega Xi (pick_i s) U.
  { rewrite <- Hseq.
    exact Hxs. }
  claim Hxcylprop: (pick_i s :e omega /\ U :e space_family_topology Xi (pick_i s)) /\ apply_fun x (pick_i s) :e U.
  { exact (SepE2 (product_space omega Xi)
                 (fun f0:set => (pick_i s :e omega /\ U :e space_family_topology Xi (pick_i s)) /\ apply_fun f0 (pick_i s) :e U)
                 x
                 HxCyl). }
  claim HxUi: apply_fun x (pick_i s) :e U.
  { exact (andER (pick_i s :e omega /\ U :e space_family_topology Xi (pick_i s))
                 (apply_fun x (pick_i s) :e U)
                 Hxcylprop). }
  (** Show apply_fun f (pick_i s) equals apply_fun x (pick_i s). **)
  claim Hidx: pick_i s :e omega.
  { exact (Hpick_omega s HsF). }
  claim HidxJ: pick_i s :e J.
  { exact (ReplI F (fun s0:set => pick_i s0) s HsF). }
  claim Hidxn: pick_i s :e n.
  { exact (Hnprop (pick_i s) HidxJ). }
  claim Hnot_nin: ~(n :e pick_i s).
  { assume Hnin: n :e pick_i s.
    exact (In_no2cycle (pick_i s) n Hidxn Hnin). }
  (** Conclude f is in the cylinder by the defining Sep predicate. **)
  prove f :e product_cylinder omega Xi (pick_i s) U.
  prove f :e {f0 :e product_space omega Xi | pick_i s :e omega /\ U :e space_family_topology Xi (pick_i s) /\ apply_fun f0 (pick_i s) :e U}.
  claim HfProd: f :e product_space omega Xi.
  { exact HfX. }
  claim Hpropf: pick_i s :e omega /\ U :e space_family_topology Xi (pick_i s) /\ apply_fun f (pick_i s) :e U.
  { apply andI.
    - apply andI.
      + exact Hidx.
      + exact HU.
    - prove apply_fun f (pick_i s) :e U.
      claim Happf: apply_fun f (pick_i s) = h (pick_i s).
      { exact (apply_fun_graph omega h (pick_i s) Hidx). }
      rewrite Happf.
      claim Hhdef: h (pick_i s) = If_i (n :e pick_i s) 0 (apply_fun x (pick_i s)).
      { reflexivity. }
      rewrite Hhdef.
      claim Hif: If_i (n :e pick_i s) 0 (apply_fun x (pick_i s)) = apply_fun x (pick_i s).
      { exact (If_i_0 (n :e pick_i s) 0 (apply_fun x (pick_i s)) Hnot_nin). }
      rewrite Hif.
      exact HxUi. }
  exact (SepI (product_space omega Xi)
        (fun f0:set => pick_i s :e omega /\ U :e space_family_topology Xi (pick_i s) /\ apply_fun f0 (pick_i s) :e U)
        f
        HfProd
        Hpropf). }

(** Conclude the intersection b meets Romega_infty by exhibiting f. **)
assume Hempty: (intersection_of_family X F) :/\: Romega_infty = Empty.
prove False.
claim HfB: f :e intersection_of_family X F.
{ exact HfInt. }
claim HfBA: f :e (intersection_of_family X F) :/\: Romega_infty.
{ exact (binintersectI (intersection_of_family X F) Romega_infty f HfB HfA). }
claim HfE: f :e Empty.
{ claim HsubE: (intersection_of_family X F) :/\: Romega_infty c= Empty.
  { rewrite Hempty.
    exact (Subq_ref Empty). }
  exact (HsubE f HfBA). }
exact (EmptyE f HfE).
Qed.

(** Helper: basis neighborhoods in the product topology meet Romega_tilde 0 via singleton sequences **)
(** LATEX VERSION: Any basic open neighborhood of a point with all nonzero coordinates 0 contains a singleton sequence (r,0,0,...). **)
Theorem Romega_tilde0_meets_product_basis : forall b x:set,
  b :e basis_of_subbasis R_omega_space (product_subbasis_full omega (const_space_family omega R R_standard_topology)) ->
  x :e Romega_tilde 0 ->
  x :e b ->
  b :/\: image_of Romega_singleton_map R <> Empty.
let b x.
assume Hb: b :e basis_of_subbasis R_omega_space (product_subbasis_full omega (const_space_family omega R R_standard_topology)).
assume Hx0: x :e Romega_tilde 0.
assume Hxb: x :e b.
prove b :/\: image_of Romega_singleton_map R <> Empty.
set X := R_omega_space.
set Xi := const_space_family omega R R_standard_topology.
set S := product_subbasis_full omega Xi.
set B := basis_of_subbasis X S.
claim HbB: b :e B.
{ exact Hb. }
(** Unpack basis_of_subbasis membership. **)
claim Hbfin: b :e finite_intersections_of X S.
{ exact (SepE1 (finite_intersections_of X S) (fun b0:set => b0 <> Empty) b HbB). }
apply (ReplE_impred (finite_subcollections S) (fun F0:set => intersection_of_family X F0) b Hbfin
        (b :/\: image_of Romega_singleton_map R <> Empty)).
let F.
assume HF: F :e finite_subcollections S.
assume Hbeq: b = intersection_of_family X F.
rewrite Hbeq at 1.
(** Extract basic properties of F. **)
claim HFpow: F :e Power S.
{ exact (SepE1 (Power S) (fun F0:set => finite F0) F HF). }
claim HFsubS: F c= S.
{ exact (PowerE S F HFpow). }
(** x lies in the intersection, hence in X and in every s in F. **)
claim HxInt: x :e intersection_of_family X F.
{ rewrite <- Hbeq.
  exact Hxb. }
claim HxX: x :e X.
{ exact (SepE1 X (fun x0 : set => forall U:set, U :e F -> x0 :e U) x HxInt). }
claim HxAll: forall s:set, s :e F -> x :e s.
{ exact (SepE2 X (fun x0 : set => forall U:set, U :e F -> x0 :e U) x HxInt). }
(** Extract the defining property of x :e Romega_tilde 0. **)
claim Hx0prop: forall i:set, i :e omega -> 0 :e i -> apply_fun x i = 0.
{ exact (SepE2 X (fun f0:set => forall i:set, i :e omega -> 0 :e i -> apply_fun f0 i = 0) x Hx0). }
(** Define r to be the 0th coordinate of x. **)
set r := apply_fun x 0.
claim H0o: 0 :e omega.
{ exact (nat_p_omega 0 nat_0). }
claim HrR: r :e R.
{ exact (Romega_coord_in_R x 0 HxX H0o). }
set f := apply_fun Romega_singleton_map r.
claim HfX: f :e X.
{ rewrite (Romega_singleton_map_apply r HrR).
  exact (Romega_singleton_seq_in_Romega_space r HrR). }
claim HfImg: f :e image_of Romega_singleton_map R.
{ claim Hfeq: f = apply_fun Romega_singleton_map r.
  { reflexivity. }
  rewrite Hfeq.
  exact (ReplI R (fun a:set => apply_fun Romega_singleton_map a) r HrR). }
(** Show f :e intersection_of_family X F by showing f is in every s in F. **)
claim HfInt: f :e intersection_of_family X F.
{ prove f :e intersection_of_family X F.
  prove f :e {x0 :e X|forall U:set, U :e F -> x0 :e U}.
  apply (SepI X (fun x0:set => forall U:set, U :e F -> x0 :e U) f HfX).
  let s. assume HsF: s :e F.
  prove f :e s.
  claim HsS: s :e S.
  { exact (HFsubS s HsF). }
  set CylFam := (fun i:set => {product_cylinder omega Xi i U|U :e space_family_topology Xi i}).
  claim HsCyl: s :e (\/_ i :e omega, CylFam i).
  { exact HsS. }
  apply (famunionE_impred omega CylFam s HsCyl (f :e s)).
  let i. assume Hi: i :e omega.
  assume HsFi: s :e CylFam i.
  apply (ReplE_impred (space_family_topology Xi i) (fun U0:set => product_cylinder omega Xi i U0) s HsFi (f :e s)).
  let U.
  assume HU: U :e space_family_topology Xi i.
  assume Hseq: s = product_cylinder omega Xi i U.
  rewrite Hseq.
  prove f :e product_cylinder omega Xi i U.
  prove f :e {f0 :e product_space omega Xi | i :e omega /\ U :e space_family_topology Xi i /\ apply_fun f0 i :e U}.
  claim HfProd: f :e product_space omega Xi.
  { exact HfX. }
  claim Hpropf: i :e omega /\ U :e space_family_topology Xi i /\ apply_fun f i :e U.
  { apply andI.
    - apply andI.
      + exact Hi.
      + exact HU.
    - prove apply_fun f i :e U.
      (** Use that x is in this cylinder, and x :e Romega_tilde 0, to show the singleton sequence matches x at i. **)
      claim Hxs: x :e s.
      { exact (HxAll s HsF). }
      claim HxCyl: x :e product_cylinder omega Xi i U.
      { rewrite <- Hseq.
        exact Hxs. }
      claim Hxcylprop: (i :e omega /\ U :e space_family_topology Xi i) /\ apply_fun x i :e U.
      { exact (SepE2 (product_space omega Xi)
                     (fun f0:set => (i :e omega /\ U :e space_family_topology Xi i) /\ apply_fun f0 i :e U)
                     x
                     HxCyl). }
      claim HxUi: apply_fun x i :e U.
      { exact (andER (i :e omega /\ U :e space_family_topology Xi i)
                     (apply_fun x i :e U)
                     Hxcylprop). }
      (** Rewrite apply_fun f i using the singleton map. **)
      rewrite (Romega_singleton_map_apply r HrR).
      rewrite (Romega_singleton_seq_apply r i HrR Hi).
      claim Hnat: nat_p i.
      { exact (omega_nat_p i Hi). }
      (** Case split on i = 0 or i = ordsucc k. **)
      apply (nat_inv i Hnat).
      - assume Hieq0: i = 0.
        rewrite Hieq0.
        claim Hnot0in0: ~(0 :e 0).
        { assume H0in0: 0 :e 0.
          prove False.
          exact (EmptyE 0 H0in0). }
        rewrite (If_i_0 (0 :e 0) 0 r Hnot0in0).
        claim HxUi0: apply_fun x 0 :e U.
        { rewrite <- Hieq0.
          exact HxUi. }
        claim Hreq: r = apply_fun x 0.
        { reflexivity. }
        rewrite Hreq.
        exact HxUi0.
      - assume Hexk: exists k:set, nat_p k /\ i = ordsucc k.
        apply Hexk.
        let k. assume Hkconj: nat_p k /\ i = ordsucc k.
        claim HkNat: nat_p k.
        { exact (andEL (nat_p k) (i = ordsucc k) Hkconj). }
        claim Hieq: i = ordsucc k.
        { exact (andER (nat_p k) (i = ordsucc k) Hkconj). }
        claim H0in: 0 :e i.
        { rewrite Hieq.
          exact (nat_0_in_ordsucc k HkNat). }
        rewrite (If_i_1 (0 :e i) 0 r H0in).
        claim Hxcoord0: apply_fun x i = 0.
        { exact (Hx0prop i Hi H0in). }
        rewrite <- Hxcoord0.
        exact HxUi.
  }
  exact (SepI (product_space omega Xi)
              (fun f0:set => i :e omega /\ U :e space_family_topology Xi i /\ apply_fun f0 i :e U)
              f
              HfProd
              Hpropf).
}
(** Conclude the intersection is nonempty by exhibiting f. **)
assume Hempty: (intersection_of_family X F) :/\: image_of Romega_singleton_map R = Empty.
prove False.
claim HfBA: f :e (intersection_of_family X F) :/\: image_of Romega_singleton_map R.
{ exact (binintersectI (intersection_of_family X F) (image_of Romega_singleton_map R) f HfInt HfImg). }
claim HfE: f :e Empty.
{ claim HsubE: (intersection_of_family X F) :/\: image_of Romega_singleton_map R c= Empty.
  { rewrite Hempty.
    exact (Subq_ref Empty). }
  exact (HsubE f HfBA). }
exact (EmptyE f HfE).
Qed.

(** Helper: singleton sequences are dense in Romega_tilde 0 (in the product topology) **)
(** LATEX VERSION: Any basic neighborhood of a point in R^0~ meets the set of singleton sequences. **)
Theorem Romega_tilde0_singletons_dense_in_subspace :
  closure_of (Romega_tilde 0)
    (subspace_topology R_omega_space R_omega_product_topology (Romega_tilde 0))
    (image_of Romega_singleton_map R) =
  Romega_tilde 0.
prove closure_of (Romega_tilde 0)
    (subspace_topology R_omega_space R_omega_product_topology (Romega_tilde 0))
    (image_of Romega_singleton_map R) =
  Romega_tilde 0.
set X := R_omega_space.
set Tx := R_omega_product_topology.
set Y := Romega_tilde 0.
set A := image_of Romega_singleton_map R.
claim HTx: topology_on X Tx.
{ exact Romega_product_topology_is_topology. }
claim HYsub: Y c= X.
{ exact (Romega_tilde_sub_Romega 0). }
claim HAsubY: A c= Y.
{ exact image_of_Romega_singleton_map_sub_Romega_tilde0. }
(** closure in subspace = ambient closure intersect subspace **)
claim HclEq: closure_of Y (subspace_topology X Tx Y) A = (closure_of X Tx A) :/\: Y.
{ exact (closure_in_subspace X Tx Y A HTx HYsub HAsubY). }
rewrite HclEq.
apply set_ext.
- let z. assume Hz: z :e (closure_of X Tx A) :/\: Y.
  exact (binintersectE2 (closure_of X Tx A) Y z Hz).
- let y. assume Hy: y :e Y.
  prove y :e (closure_of X Tx A) :/\: Y.
  apply binintersectI.
  + (** Show y :e closure_of X Tx A by the neighborhood characterization using a product basis element **)
    prove y :e closure_of X Tx A.
    (** Use defining Sep condition for closure_of X Tx A **)
    claim HyCond: forall U:set, U :e Tx -> y :e U -> U :/\: A <> Empty.
    { let U. assume HU: U :e Tx.
      assume HyU: y :e U.
      prove U :/\: A <> Empty.
      set S := product_subbasis_full omega (const_space_family omega R R_standard_topology).
      set B := basis_of_subbasis X S.
      claim HUl: forall z :e U, exists b0 :e B, z :e b0 /\ b0 c= U.
      { exact (SepE2 (Power X)
                    (fun U0:set => forall z :e U0, exists b0 :e B, z :e b0 /\ b0 c= U0)
                    U
                    HU). }
      apply (HUl y HyU).
      let b0. assume Hb0pair.
      claim Hb0B: b0 :e B.
      { exact (andEL (b0 :e B) (y :e b0 /\ b0 c= U) Hb0pair). }
      claim Hyb0sub: y :e b0 /\ b0 c= U.
      { exact (andER (b0 :e B) (y :e b0 /\ b0 c= U) Hb0pair). }
      claim Hyb0: y :e b0.
      { exact (andEL (y :e b0) (b0 c= U) Hyb0sub). }
      claim Hb0subU: b0 c= U.
      { exact (andER (y :e b0) (b0 c= U) Hyb0sub). }
      claim Hb0neA: b0 :/\: A <> Empty.
      { exact (Romega_tilde0_meets_product_basis b0 y Hb0B Hy Hyb0). }
      (** If b0  A is nonempty and b0  U then U  A is nonempty. **)
      assume HUAempty: U :/\: A = Empty.
      claim Hb0A_sub: b0 :/\: A c= U :/\: A.
      { let z. assume Hz: z :e b0 :/\: A.
        claim Hzb0: z :e b0.
        { exact (binintersectE1 b0 A z Hz). }
        claim HzA: z :e A.
        { exact (binintersectE2 b0 A z Hz). }
        claim HzU0: z :e U.
        { exact (Hb0subU z Hzb0). }
        exact (binintersectI U A z HzU0 HzA). }
      claim Hb0A_empty: b0 :/\: A = Empty.
      { apply Empty_Subq_eq.
        claim HUAE: U :/\: A c= Empty.
        { rewrite HUAempty.
          exact (Subq_ref Empty). }
        exact (Subq_tra (b0 :/\: A) (U :/\: A) Empty Hb0A_sub HUAE). }
      exact (Hb0neA Hb0A_empty). }
    exact (SepI X (fun x0:set => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) y (HYsub y Hy) HyCond).
  + exact Hy.
Qed.

(** Helper: Romega_tilde 0 is connected as closure of a connected subset **)
(** LATEX VERSION: The image of R under the singleton map is connected and dense in R^0~, so R^0~ is connected. **)
Theorem Romega_tilde0_connected :
  connected_space (Romega_tilde 0)
    (subspace_topology R_omega_space R_omega_product_topology (Romega_tilde 0)).
prove connected_space (Romega_tilde 0)
    (subspace_topology R_omega_space R_omega_product_topology (Romega_tilde 0)).
set X := R_omega_space.
set Tx := R_omega_product_topology.
set Y := Romega_tilde 0.
set Ty := subspace_topology X Tx Y.
set A := image_of Romega_singleton_map R.
claim HTx: topology_on X Tx.
{ exact Romega_product_topology_is_topology. }
claim HYsub: Y c= X.
{ exact (Romega_tilde_sub_Romega 0). }
claim HTy: topology_on Y Ty.
{ exact (subspace_topology_is_topology X Tx Y HTx HYsub). }
claim HAsubY: A c= Y.
{ exact image_of_Romega_singleton_map_sub_Romega_tilde0. }
claim HAconnX: connected_space A (subspace_topology X Tx A).
{ claim HRconn: connected_space R R_standard_topology.
  { exact interval_connected. }
  claim Hcont: continuous_map R R_standard_topology X Tx Romega_singleton_map.
  { exact Romega_singleton_map_continuous_prod. }
  exact (continuous_image_connected R R_standard_topology X Tx Romega_singleton_map HRconn Hcont). }
claim HsubEq: subspace_topology Y Ty A = subspace_topology X Tx A.
{ exact (ex16_1_subspace_transitive X Tx Y A HTx HYsub HAsubY). }
claim HAconn: connected_space A (subspace_topology Y Ty A).
{ rewrite HsubEq.
  exact HAconnX. }
claim Hdense: closure_of Y Ty A = Y.
{ exact Romega_tilde0_singletons_dense_in_subspace. }
exact (connected_space_if_dense_connected_subset Y Ty A HTy HAsubY HAconn Hdense).
Qed.

(** from 23 Example 7: each Romega_tilde n is connected in the product topology **) 
(** LATEX VERSION: Each R^n is connected, hence the subspace of sequences supported on {0,...,n} is connected. **)
Theorem Romega_tilde_connected : forall n:set,
  n :e omega ->
  connected_space (Romega_tilde n)
    (subspace_topology R_omega_space R_omega_product_topology (Romega_tilde n)).
let n. assume HnO: n :e omega.
set X := R_omega_space.
set Tx := R_omega_product_topology.
prove connected_space (Romega_tilde n) (subspace_topology X Tx (Romega_tilde n)).
claim HnNat: nat_p n.
{ exact (omega_nat_p n HnO). }
(** Induction on n. Romega_tilde n corresponds to sequences supported on {0,...,n}. **)
apply (nat_ind (fun k:set => connected_space (Romega_tilde k) (subspace_topology X Tx (Romega_tilde k)))).
- (** Base: k = 0. **)
  exact Romega_tilde0_connected.
- (** Step: k -> ordsucc k. **)
  let k. assume HkNat: nat_p k.
  assume IHk: connected_space (Romega_tilde k) (subspace_topology X Tx (Romega_tilde k)).
  prove connected_space (Romega_tilde (ordsucc k)) (subspace_topology X Tx (Romega_tilde (ordsucc k))).
  claim HkO: k :e omega.
  { exact (nat_p_omega k HkNat). }
  claim HRconn: connected_space R R_standard_topology.
  { exact interval_connected. }
  claim Hprod:
    connected_space (setprod (Romega_tilde k) R)
      (product_topology (Romega_tilde k) (subspace_topology X Tx (Romega_tilde k)) R R_standard_topology).
  { exact (finite_product_connected (Romega_tilde k) (subspace_topology X Tx (Romega_tilde k))
                                   R R_standard_topology IHk HRconn). }
  claim Hhom:
    homeomorphism
      (setprod (Romega_tilde k) R)
      (product_topology (Romega_tilde k) (subspace_topology X Tx (Romega_tilde k)) R R_standard_topology)
      (Romega_tilde (ordsucc k))
      (subspace_topology X Tx (Romega_tilde (ordsucc k)))
      (Romega_extend_map k).
  { exact (Romega_tilde_succ_homeomorphism k HkO). }
  exact (homeomorphism_preserves_connected
          (setprod (Romega_tilde k) R)
          (product_topology (Romega_tilde k) (subspace_topology X Tx (Romega_tilde k)) R R_standard_topology)
          (Romega_tilde (ordsucc k))
          (subspace_topology X Tx (Romega_tilde (ordsucc k)))
          (Romega_extend_map k)
          Hhom
          Hprod).
- exact HnNat.
Qed.

(** from 23 Example 7: Romega_infty is connected as a union of connected sets with a common point **) 
(** LATEX VERSION: R^infty is the union of the connected subspaces R^n and they share the zero sequence. **)
Theorem Romega_infty_connected :
  connected_space Romega_infty
    (subspace_topology R_omega_space R_omega_product_topology Romega_infty).
prove connected_space Romega_infty (subspace_topology R_omega_space R_omega_product_topology Romega_infty).
set X := R_omega_space.
set Tx := R_omega_product_topology.
set F := {Romega_tilde n|n :e omega}.
claim HTx: topology_on X Tx.
{ exact Romega_product_topology_is_topology. }
claim HFsub: forall C:set, C :e F -> C c= X.
{ let C. assume HC: C :e F.
  prove C c= X.
  apply (ReplE_impred omega (fun n:set => Romega_tilde n) C HC (C c= X)).
  let n. assume Hn: n :e omega. assume HCeq: C = Romega_tilde n.
  rewrite HCeq.
  exact (Romega_tilde_sub_Romega n). }
claim HFconn: forall C:set, C :e F -> connected_space C (subspace_topology X Tx C).
{ let C. assume HC: C :e F.
  prove connected_space C (subspace_topology X Tx C).
  apply (ReplE_impred omega (fun n:set => Romega_tilde n) C HC (connected_space C (subspace_topology X Tx C))).
  let n. assume Hn: n :e omega. assume HCeq: C = Romega_tilde n.
  rewrite HCeq.
  exact (Romega_tilde_connected n Hn). }
claim Hcommon: exists x:set, forall C:set, C :e F -> x :e C.
{ witness Romega_zero.
  let C. assume HC: C :e F.
  prove Romega_zero :e C.
  apply (ReplE_impred omega (fun n:set => Romega_tilde n) C HC (Romega_zero :e C)).
  let n. assume Hn: n :e omega. assume HCeq: C = Romega_tilde n.
  rewrite HCeq.
  exact (Romega_zero_in_Romega_tilde n Hn). }
claim HconnUnion: connected_space (Union F) (subspace_topology X Tx (Union F)).
{ exact (union_connected_common_point X Tx F HTx HFsub HFconn Hcommon). }
claim HUnionEq: Union F = Romega_infty.
{ reflexivity. }
rewrite HUnionEq.
rewrite HUnionEq at 1.
exact HconnUnion.
Qed.

(** from 23 Example 7: Romega_infty is dense in the product topology **) 
(** LATEX VERSION: Every basic open set in the product topology meets R^infty by modifying only finitely many coordinates. **)
Theorem Romega_infty_dense :
  closure_of R_omega_space R_omega_product_topology Romega_infty = R_omega_space.
prove closure_of R_omega_space R_omega_product_topology Romega_infty = R_omega_space.
apply set_ext.
- exact (closure_in_space R_omega_space R_omega_product_topology Romega_infty Romega_product_topology_is_topology).
- let x. assume Hx: x :e R_omega_space.
  prove x :e closure_of R_omega_space R_omega_product_topology Romega_infty.
  (** Use the defining Sep condition for closure_of. **)
  claim Hcond: forall U:set, U :e R_omega_product_topology -> x :e U -> U :/\: Romega_infty <> Empty.
  { let U. assume HU: U :e R_omega_product_topology.
    assume HxU: x :e U.
    prove U :/\: Romega_infty <> Empty.
    (** Reduce to a basis element b inside U containing x. **)
    set S := product_subbasis_full omega (const_space_family omega R R_standard_topology).
    set B := basis_of_subbasis R_omega_space S.
    claim HUpow: U :e Power R_omega_space.
    { exact (SepE1 (Power R_omega_space)
                  (fun U0:set => forall y :e U0, exists b0 :e B, y :e b0 /\ b0 c= U0)
                  U
                  HU). }
    claim HUl: forall y :e U, exists b0 :e B, y :e b0 /\ b0 c= U.
    { exact (SepE2 (Power R_omega_space)
                  (fun U0:set => forall y :e U0, exists b0 :e B, y :e b0 /\ b0 c= U0)
                  U
                  HU). }
    apply (HUl x HxU).
    let b0. assume Hb0pair.
    claim Hb0B: b0 :e B.
    { exact (andEL (b0 :e B) (x :e b0 /\ b0 c= U) Hb0pair). }
    claim Hb0xu: x :e b0 /\ b0 c= U.
    { exact (andER (b0 :e B) (x :e b0 /\ b0 c= U) Hb0pair). }
    claim Hxb0: x :e b0.
    { exact (andEL (x :e b0) (b0 c= U) Hb0xu). }
    claim Hb0subU: b0 c= U.
    { exact (andER (x :e b0) (b0 c= U) Hb0xu). }
    claim Hb0neA: b0 :/\: Romega_infty <> Empty.
    { exact (Romega_infty_meets_product_basis b0 x Hb0B Hxb0). }
    (** If b0  A is nonempty and b0  U then U  A is nonempty. **)
    assume HUAempty: U :/\: Romega_infty = Empty.
    claim Hb0A_sub: b0 :/\: Romega_infty c= U :/\: Romega_infty.
    { let y. assume Hy: y :e b0 :/\: Romega_infty.
      claim Hyb0: y :e b0.
      { exact (binintersectE1 b0 Romega_infty y Hy). }
      claim HyA: y :e Romega_infty.
      { exact (binintersectE2 b0 Romega_infty y Hy). }
      claim HyU: y :e U.
      { exact (Hb0subU y Hyb0). }
      exact (binintersectI U Romega_infty y HyU HyA). }
    claim Hb0A_empty: b0 :/\: Romega_infty = Empty.
    { apply Empty_Subq_eq.
      claim HUAE: U :/\: Romega_infty c= Empty.
      { let y. assume Hy: y :e U :/\: Romega_infty.
        prove y :e Empty.
        rewrite <- HUAempty.
        exact Hy. }
      exact (Subq_tra (b0 :/\: Romega_infty) (U :/\: Romega_infty) Empty Hb0A_sub HUAE). }
    exact (Hb0neA Hb0A_empty). }
exact (SepI R_omega_space
            (fun x0 => forall U:set, U :e R_omega_product_topology -> x0 :e U -> U :/\: Romega_infty <> Empty)
            x
            Hx
            Hcond).
Qed.

Theorem R_omega_product_connected :
  connected_space (product_space omega (const_space_family omega R R_standard_topology))
    (product_topology_full omega (const_space_family omega R R_standard_topology)).
prove connected_space (product_space omega (const_space_family omega R R_standard_topology))
    (product_topology_full omega (const_space_family omega R R_standard_topology)).
set Xi := const_space_family omega R R_standard_topology.
set X := product_space omega Xi.
set Tx := product_topology_full omega Xi.
set A := Romega_infty.
claim HTx: topology_on X Tx.
{ exact Romega_product_topology_is_topology. }
claim HAsub: A c= X.
{ exact Romega_infty_sub_Romega. }
claim HAconn: connected_space A (subspace_topology X Tx A).
{ exact Romega_infty_connected. }
claim Hdense: closure_of X Tx A = X.
{ exact Romega_infty_dense. }
exact (connected_space_if_dense_connected_subset X Tx A HTx HAsub HAconn Hdense).
Qed.

(** from 24 Definition: path and path connectedness **) 
(** LATEX VERSION: A path from x to y is a map p:[0,1] to X with p(0)=x and p(1)=y; X is path connected if every two points can be joined by a path. **)
Definition path_between : set -> set -> set -> set -> prop := fun X x y p =>
  function_on p unit_interval X /\
  apply_fun p 0 = x /\ apply_fun p 1 = y.
Definition path_connected_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall x y:set, x :e X -> y :e X ->
    exists p:set, path_between X x y p /\ continuous_map unit_interval unit_interval_topology X Tx p.

(** Helper: extract function and endpoints from path_between **)
Theorem path_between_pair0 : forall X x y p:set,
  path_between X x y p -> function_on p unit_interval X /\ apply_fun p 0 = x.
let X x y p.
assume H: path_between X x y p.
exact (andEL (function_on p unit_interval X /\ apply_fun p 0 = x)
             (apply_fun p 1 = y)
             H).
Qed.

Theorem path_between_function_on : forall X x y p:set,
  path_between X x y p -> function_on p unit_interval X.
let X x y p.
assume H: path_between X x y p.
claim H0: function_on p unit_interval X /\ apply_fun p 0 = x.
{ exact (path_between_pair0 X x y p H). }
exact (andEL (function_on p unit_interval X) (apply_fun p 0 = x) H0).
Qed.

Theorem path_between_at_zero : forall X x y p:set,
  path_between X x y p -> apply_fun p 0 = x.
let X x y p.
assume H: path_between X x y p.
claim H0: function_on p unit_interval X /\ apply_fun p 0 = x.
{ exact (path_between_pair0 X x y p H). }
exact (andER (function_on p unit_interval X) (apply_fun p 0 = x) H0).
Qed.

Theorem path_between_at_one : forall X x y p:set,
  path_between X x y p -> apply_fun p 1 = y.
let X x y p.
assume H: path_between X x y p.
exact (andER (function_on p unit_interval X /\ apply_fun p 0 = x)
             (apply_fun p 1 = y)
             H).
Qed.

Theorem path_betweenI : forall X x y p:set,
  function_on p unit_interval X ->
  apply_fun p 0 = x ->
  apply_fun p 1 = y ->
  path_between X x y p.
let X x y p.
assume Hfun: function_on p unit_interval X.
assume H0: apply_fun p 0 = x.
assume H1: apply_fun p 1 = y.
claim Hpair0: function_on p unit_interval X /\ apply_fun p 0 = x.
{ exact (andI (function_on p unit_interval X) (apply_fun p 0 = x) Hfun H0). }
exact (andI (function_on p unit_interval X /\ apply_fun p 0 = x) (apply_fun p 1 = y) Hpair0 H1).
Qed.

(** Helper: split a path witness pair (path_between and continuity) **)
Theorem path_witness_between : forall X Tx x y p:set,
  (path_between X x y p /\ continuous_map unit_interval unit_interval_topology X Tx p) ->
  path_between X x y p.
let X Tx x y p.
assume H: path_between X x y p /\ continuous_map unit_interval unit_interval_topology X Tx p.
exact (andEL (path_between X x y p)
             (continuous_map unit_interval unit_interval_topology X Tx p)
             H).
Qed.

Theorem path_witness_continuous : forall X Tx x y p:set,
  (path_between X x y p /\ continuous_map unit_interval unit_interval_topology X Tx p) ->
  continuous_map unit_interval unit_interval_topology X Tx p.
let X Tx x y p.
assume H: path_between X x y p /\ continuous_map unit_interval unit_interval_topology X Tx p.
exact (andER (path_between X x y p)
             (continuous_map unit_interval unit_interval_topology X Tx p)
             H).
Qed.

(** Helper: extract topology_on from path_connected_space **)
Theorem path_connected_space_topology : forall X Tx:set,
  path_connected_space X Tx -> topology_on X Tx.
let X Tx.
assume H: path_connected_space X Tx.
exact (andEL (topology_on X Tx)
             (forall x y:set, x :e X -> y :e X ->
               exists p:set, path_between X x y p /\ continuous_map unit_interval unit_interval_topology X Tx p)
             H).
Qed.

(** Helper: extract existence of paths from path_connected_space **)
Theorem path_connected_space_paths : forall X Tx x y:set,
  path_connected_space X Tx -> x :e X -> y :e X ->
  exists p:set, path_between X x y p /\ continuous_map unit_interval unit_interval_topology X Tx p.
let X Tx x y.
assume H: path_connected_space X Tx.
assume Hx: x :e X.
assume Hy: y :e X.
claim Hpaths: forall x0 y0:set, x0 :e X -> y0 :e X ->
  exists p:set, path_between X x0 y0 p /\ continuous_map unit_interval unit_interval_topology X Tx p.
{ exact (andER (topology_on X Tx)
               (forall x0 y0:set, x0 :e X -> y0 :e X ->
                 exists p:set, path_between X x0 y0 p /\ continuous_map unit_interval unit_interval_topology X Tx p)
               H). }
exact (Hpaths x y Hx Hy).
Qed.

(** Helper axioms for path_connected_implies_connected **)
Theorem unit_interval_connected : connected_space unit_interval unit_interval_topology.
prove topology_on unit_interval unit_interval_topology /\
  ~(exists U V:set, U :e unit_interval_topology /\ V :e unit_interval_topology /\ separation_of unit_interval U V).
apply andI.
- exact unit_interval_topology_on.
- admit.
Qed.

Theorem zero_one_in_unit_interval : 0 :e unit_interval /\ 1 :e unit_interval.
apply andI.
- exact zero_in_unit_interval.
- exact one_in_unit_interval.
Qed.

(** helper: for any two points in X there exists a path_between witness **)
(** LATEX VERSION: For any x,y in X there is a path (as a function) from x to y. **)
Theorem path_between_exists : forall X x y:set,
  x :e X -> y :e X -> exists p:set, path_between X x y p.
let X x y.
assume HxX: x :e X.
assume HyX: y :e X.
prove exists p:set, path_between X x y p.
set p := {(t, If_i (t = 0) x y)|t :e unit_interval}.
witness p.
prove path_between X x y p.
prove function_on p unit_interval X /\ apply_fun p 0 = x /\ apply_fun p 1 = y.
apply andI.
- (** function_on p unit_interval X /\ apply_fun p 0 = x **)
  apply andI.
  + (** function_on **)
    let t. assume HtI: t :e unit_interval.
    prove apply_fun p t :e X.
    claim Happ: apply_fun p t = If_i (t = 0) x y.
    { prove apply_fun p t = If_i (t = 0) x y.
      prove Eps_i (fun u:set => (t,u) :e p) = If_i (t = 0) x y.
      claim Hpair: (t, If_i (t = 0) x y) :e p.
      { exact (ReplI unit_interval (fun t0:set => (t0, If_i (t0 = 0) x y)) t HtI). }
      claim Heps: (t, Eps_i (fun u:set => (t,u) :e p)) :e p.
      { exact (Eps_i_ax (fun u:set => (t,u) :e p) (If_i (t = 0) x y) Hpair). }
      apply (ReplE_impred unit_interval (fun t0:set => (t0, If_i (t0 = 0) x y))
              (t, Eps_i (fun u:set => (t,u) :e p)) Heps
              (Eps_i (fun u:set => (t,u) :e p) = If_i (t = 0) x y)).
      let t0. assume Ht0: t0 :e unit_interval.
      assume Heq: (t, Eps_i (fun u:set => (t,u) :e p)) = (t0, If_i (t0 = 0) x y).
      claim Ht_eq: t = t0.
      { rewrite <- (tuple_2_0_eq t (Eps_i (fun u:set => (t,u) :e p))).
        rewrite <- (tuple_2_0_eq t0 (If_i (t0 = 0) x y)).
        rewrite Heq.
        reflexivity. }
      claim Hu_eq: Eps_i (fun u:set => (t,u) :e p) = If_i (t0 = 0) x y.
      { rewrite <- (tuple_2_1_eq t (Eps_i (fun u:set => (t,u) :e p))).
        rewrite <- (tuple_2_1_eq t0 (If_i (t0 = 0) x y)).
        rewrite Heq.
        reflexivity. }
      rewrite Hu_eq.
      rewrite <- Ht_eq.
      reflexivity. }
    rewrite Happ.
    apply (xm (t = 0)).
    - assume Ht0: t = 0.
      rewrite (If_i_1 (t = 0) x y Ht0).
      exact HxX.
    - assume Hnt0: ~(t = 0).
      rewrite (If_i_0 (t = 0) x y Hnt0).
      exact HyX.
  + (** apply_fun p 0 = x **)
    claim H01: 0 :e unit_interval /\ 1 :e unit_interval.
    { exact zero_one_in_unit_interval. }
    claim H0I: 0 :e unit_interval.
    { exact (andEL (0 :e unit_interval) (1 :e unit_interval) H01). }
    claim Happ0: apply_fun p 0 = If_i (0 = 0) x y.
    { prove apply_fun p 0 = If_i (0 = 0) x y.
      prove Eps_i (fun u:set => (0,u) :e p) = If_i (0 = 0) x y.
      claim Hpair: (0, If_i (0 = 0) x y) :e p.
      { exact (ReplI unit_interval (fun t0:set => (t0, If_i (t0 = 0) x y)) 0 H0I). }
      claim Heps: (0, Eps_i (fun u:set => (0,u) :e p)) :e p.
      { exact (Eps_i_ax (fun u:set => (0,u) :e p) (If_i (0 = 0) x y) Hpair). }
      apply (ReplE_impred unit_interval (fun t0:set => (t0, If_i (t0 = 0) x y))
              (0, Eps_i (fun u:set => (0,u) :e p)) Heps
              (Eps_i (fun u:set => (0,u) :e p) = If_i (0 = 0) x y)).
      let t0. assume Ht0: t0 :e unit_interval.
      assume Heq: (0, Eps_i (fun u:set => (0,u) :e p)) = (t0, If_i (t0 = 0) x y).
      claim Ht_eq: 0 = t0.
      { rewrite <- (tuple_2_0_eq 0 (Eps_i (fun u:set => (0,u) :e p))).
        rewrite <- (tuple_2_0_eq t0 (If_i (t0 = 0) x y)).
        rewrite Heq.
        reflexivity. }
      claim Hu_eq: Eps_i (fun u:set => (0,u) :e p) = If_i (t0 = 0) x y.
      { rewrite <- (tuple_2_1_eq 0 (Eps_i (fun u:set => (0,u) :e p))).
        rewrite <- (tuple_2_1_eq t0 (If_i (t0 = 0) x y)).
        rewrite Heq.
        reflexivity. }
      rewrite Hu_eq.
      rewrite <- Ht_eq.
      reflexivity. }
    rewrite Happ0.
    claim H00: 0 = 0.
    { reflexivity. }
    rewrite (If_i_1 (0 = 0) x y H00).
    reflexivity.
- (** apply_fun p 1 = y **)
  claim H01: 0 :e unit_interval /\ 1 :e unit_interval.
  { exact zero_one_in_unit_interval. }
  claim H1I: 1 :e unit_interval.
  { exact (andER (0 :e unit_interval) (1 :e unit_interval) H01). }
  claim Happ1: apply_fun p 1 = If_i (1 = 0) x y.
  { prove apply_fun p 1 = If_i (1 = 0) x y.
    prove Eps_i (fun u:set => (1,u) :e p) = If_i (1 = 0) x y.
    claim Hpair: (1, If_i (1 = 0) x y) :e p.
    { exact (ReplI unit_interval (fun t0:set => (t0, If_i (t0 = 0) x y)) 1 H1I). }
    claim Heps: (1, Eps_i (fun u:set => (1,u) :e p)) :e p.
    { exact (Eps_i_ax (fun u:set => (1,u) :e p) (If_i (1 = 0) x y) Hpair). }
    apply (ReplE_impred unit_interval (fun t0:set => (t0, If_i (t0 = 0) x y))
            (1, Eps_i (fun u:set => (1,u) :e p)) Heps
            (Eps_i (fun u:set => (1,u) :e p) = If_i (1 = 0) x y)).
    let t0. assume Ht0: t0 :e unit_interval.
    assume Heq: (1, Eps_i (fun u:set => (1,u) :e p)) = (t0, If_i (t0 = 0) x y).
    claim Ht_eq: 1 = t0.
    { rewrite <- (tuple_2_0_eq 1 (Eps_i (fun u:set => (1,u) :e p))).
      rewrite <- (tuple_2_0_eq t0 (If_i (t0 = 0) x y)).
      rewrite Heq.
      reflexivity. }
    claim Hu_eq: Eps_i (fun u:set => (1,u) :e p) = If_i (t0 = 0) x y.
    { rewrite <- (tuple_2_1_eq 1 (Eps_i (fun u:set => (1,u) :e p))).
      rewrite <- (tuple_2_1_eq t0 (If_i (t0 = 0) x y)).
      rewrite Heq.
      reflexivity. }
    rewrite Hu_eq.
    rewrite <- Ht_eq.
    reflexivity. }
  rewrite Happ1.
  claim Hneq: ~(1 = 0).
  { assume H10: 1 = 0.
    apply neq_0_1.
    rewrite H10.
    reflexivity. }
  rewrite (If_i_0 (1 = 0) x y Hneq).
  reflexivity.
Qed.

Theorem separation_has_elements : forall X U V:set,
  separation_of X U V ->
  (exists x:set, x :e U) /\ (exists y:set, y :e V).
let X U V. assume Hsep.
claim H1: (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty.
{ exact (andEL ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
               (U :\/: V = X) Hsep). }
claim H2: ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty.
{ exact (andEL (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty)
               (V <> Empty) H1). }
claim HUne: U <> Empty.
{ exact (andER (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty)) (U <> Empty) H2). }
claim HVne: V <> Empty.
{ exact (andER ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty)) (V <> Empty) H1). }
apply andI.
- exact (nonempty_has_element U HUne).
- exact (nonempty_has_element V HVne).
Qed.

Theorem separation_subsets : forall X U V:set,
  separation_of X U V ->
  U c= X /\ V c= X.
let X U V. assume Hsep.
claim H1: (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty.
{ exact (andEL ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
               (U :\/: V = X) Hsep). }
claim H2: ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty.
{ exact (andEL (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty)
               (V <> Empty) H1). }
claim H3: (U :e Power X /\ V :e Power X) /\ U :/\: V = Empty.
{ exact (andEL ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty)
               (U <> Empty) H2). }
claim Hleft: U :e Power X /\ V :e Power X.
{ exact (andEL (U :e Power X /\ V :e Power X) (U :/\: V = Empty) H3). }
apply andI.
- exact (PowerE X U (andEL (U :e Power X) (V :e Power X) Hleft)).
- exact (PowerE X V (andER (U :e Power X) (V :e Power X) Hleft)).
Qed.

Theorem subset_elem : forall A B x:set,
  A c= B -> x :e A -> x :e B.
let A B x. assume HAB Hx. exact (HAB x Hx).
Qed.

(** from 24: path connected implies connected **) 
(** LATEX VERSION: Every path connected space is connected. **)
Theorem path_connected_implies_connected : forall X Tx:set,
  path_connected_space X Tx -> connected_space X Tx.
let X Tx.
assume Hpath: path_connected_space X Tx.
prove connected_space X Tx.
(** Extract components from path_connected_space **)
claim HTx: topology_on X Tx.
{ exact (path_connected_space_topology X Tx Hpath). }
claim Hpath_prop: forall x y:set, x :e X -> y :e X -> exists p:set, path_between X x y p /\ continuous_map unit_interval unit_interval_topology X Tx p.
{ let x y.
  assume Hx: x :e X.
  assume Hy: y :e X.
  exact (path_connected_space_paths X Tx x y Hpath Hx Hy). }
(** Prove X is connected by contradiction **)
prove topology_on X Tx /\ ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).
apply andI.
- exact HTx.
- prove ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).
  assume HsepX: exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V.
  (** Extract the separation of X **)
  apply HsepX.
  let U. assume HsepX_V: exists V:set, U :e Tx /\ V :e Tx /\ separation_of X U V.
  apply HsepX_V.
  let V. assume HUV.
  (** Extract components from nested conjunction **)
  claim HU: U :e Tx.
  { exact (andEL (U :e Tx) (V :e Tx)
                 (andEL (U :e Tx /\ V :e Tx) (separation_of X U V) HUV)). }
  claim HV: V :e Tx.
  { exact (andER (U :e Tx) (V :e Tx)
                 (andEL (U :e Tx /\ V :e Tx) (separation_of X U V) HUV)). }
  claim HsepXUV: separation_of X U V.
  { exact (andER (U :e Tx /\ V :e Tx) (separation_of X U V) HUV). }
  (** Get elements from the separation **)
  claim Helems: (exists x:set, x :e U) /\ (exists y:set, y :e V).
  { exact (separation_has_elements X U V HsepXUV). }
  claim HexU: exists x:set, x :e U.
  { exact (andEL (exists x:set, x :e U) (exists y:set, y :e V) Helems). }
  claim HexV: exists y:set, y :e V.
  { exact (andER (exists x:set, x :e U) (exists y:set, y :e V) Helems). }
  (** Pick specific elements **)
  apply HexU.
  let x. assume Hx: x :e U.
  apply HexV.
  let y. assume Hy: y :e V.
  (** Show x, y are in X **)
  claim Hsubsets: U c= X /\ V c= X.
  { exact (separation_subsets X U V HsepXUV). }
  claim HU_sub: U c= X.
  { exact (andEL (U c= X) (V c= X) Hsubsets). }
  claim HV_sub: V c= X.
  { exact (andER (U c= X) (V c= X) Hsubsets). }
  claim HxinX: x :e X.
  { exact (subset_elem U X x HU_sub Hx). }
  claim HyinX: y :e X.
  { exact (subset_elem V X y HV_sub Hy). }
  (** Get continuous path from x to y **)
  claim Hpathxy: exists p:set, path_between X x y p /\ continuous_map unit_interval unit_interval_topology X Tx p.
  { exact (Hpath_prop x y HxinX HyinX). }
  apply Hpathxy.
  let p. assume Hp_and_cont.
  (** Extract path_between and continuity **)
  claim Hp: path_between X x y p.
  { exact (path_witness_between X Tx x y p Hp_and_cont). }
  claim Hpcont: continuous_map unit_interval unit_interval_topology X Tx p.
  { exact (path_witness_continuous X Tx x y p Hp_and_cont). }
  (** Extract function and endpoints from Hp (left-associative /\) **)
  claim Hpfunc: function_on p unit_interval X.
  { exact (path_between_function_on X x y p Hp). }
  claim Hp0eq: apply_fun p 0 = x.
  { exact (path_between_at_zero X x y p Hp). }
  claim Hp1eq: apply_fun p 1 = y.
  { exact (path_between_at_one X x y p Hp). }

  (** Extract disjointness and union from separation_of X U V **)
  claim Hsep_left: ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty).
  { exact (andEL ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                 (U :\/: V = X) HsepXUV). }
  claim Hsep_mid: ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty.
  { exact (andEL (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty)
                 (V <> Empty) Hsep_left). }
  claim Hsep_pow_disj: (U :e Power X /\ V :e Power X) /\ U :/\: V = Empty.
  { exact (andEL ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty)
                 (U <> Empty) Hsep_mid). }
  claim HdisjUV: U :/\: V = Empty.
  { exact (andER (U :e Power X /\ V :e Power X) (U :/\: V = Empty) Hsep_pow_disj). }
  claim HunionUV: U :\/: V = X.
  { exact (andER ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                 (U :\/: V = X) HsepXUV). }

  (** Show preimages form a separation of the unit interval **)
  set preU := preimage_of unit_interval p U.
  set preV := preimage_of unit_interval p V.
  claim Hsep_UV: separation_of unit_interval preU preV.
  { prove preU :e Power unit_interval /\ preV :e Power unit_interval /\ preU :/\: preV = Empty /\ preU <> Empty /\ preV <> Empty /\ preU :\/: preV = unit_interval.
    apply andI.
    - prove ((((preU :e Power unit_interval /\ preV :e Power unit_interval) /\ preU :/\: preV = Empty) /\ preU <> Empty) /\ preV <> Empty).
      apply andI.
      + prove (((preU :e Power unit_interval /\ preV :e Power unit_interval) /\ preU :/\: preV = Empty) /\ preU <> Empty).
        apply andI.
        - prove ((preU :e Power unit_interval /\ preV :e Power unit_interval) /\ preU :/\: preV = Empty).
          apply andI.
          + prove preU :e Power unit_interval /\ preV :e Power unit_interval.
            apply andI.
            - prove preU :e Power unit_interval.
              apply PowerI.
              let t. assume Ht: t :e preU.
              exact (SepE1 unit_interval (fun t0:set => apply_fun p t0 :e U) t Ht).
            - prove preV :e Power unit_interval.
              apply PowerI.
              let t. assume Ht: t :e preV.
              exact (SepE1 unit_interval (fun t0:set => apply_fun p t0 :e V) t Ht).
          + prove preU :/\: preV = Empty.
            apply Empty_eq.
            let t. assume Ht: t :e preU :/\: preV.
            apply (binintersectE preU preV t Ht).
            assume HtU: t :e preU.
            assume HtV: t :e preV.
            claim HpU: apply_fun p t :e U.
            { exact (SepE2 unit_interval (fun t0:set => apply_fun p t0 :e U) t HtU). }
            claim HpV: apply_fun p t :e V.
            { exact (SepE2 unit_interval (fun t0:set => apply_fun p t0 :e V) t HtV). }
            claim HpUV: apply_fun p t :e U :/\: V.
            { exact (binintersectI U V (apply_fun p t) HpU HpV). }
            claim Hfalse: apply_fun p t :e Empty.
            { rewrite <- HdisjUV. exact HpUV. }
            exact (EmptyE (apply_fun p t) Hfalse).
        - (** preU <> Empty **)
          assume Heq: preU = Empty.
          claim H01: 0 :e unit_interval /\ 1 :e unit_interval.
          { exact zero_one_in_unit_interval. }
          claim H0I: 0 :e unit_interval.
          { exact (andEL (0 :e unit_interval) (1 :e unit_interval) H01). }
          claim HxU: apply_fun p 0 :e U.
          { rewrite Hp0eq. exact Hx. }
          claim H0pre: 0 :e preU.
          { exact (SepI unit_interval (fun t0:set => apply_fun p t0 :e U) 0 H0I HxU). }
          claim Hsub: preU c= Empty.
          { rewrite Heq. exact (Subq_ref Empty). }
          claim H0Empty: 0 :e Empty.
          { exact (Hsub 0 H0pre). }
          exact (EmptyE 0 H0Empty).
      + (** preV <> Empty **)
        assume Heq: preV = Empty.
        claim H01: 0 :e unit_interval /\ 1 :e unit_interval.
        { exact zero_one_in_unit_interval. }
        claim H1I: 1 :e unit_interval.
        { exact (andER (0 :e unit_interval) (1 :e unit_interval) H01). }
        claim HyV: apply_fun p 1 :e V.
        { rewrite Hp1eq. exact Hy. }
        claim H1pre: 1 :e preV.
        { exact (SepI unit_interval (fun t0:set => apply_fun p t0 :e V) 1 H1I HyV). }
        claim Hsub: preV c= Empty.
        { rewrite Heq. exact (Subq_ref Empty). }
        claim H1Empty: 1 :e Empty.
        { exact (Hsub 1 H1pre). }
        exact (EmptyE 1 H1Empty).
    - prove preU :\/: preV = unit_interval.
      apply set_ext.
      + let t. assume Ht: t :e preU :\/: preV.
        prove t :e unit_interval.
        apply (binunionE preU preV t Ht).
        - assume HtU: t :e preU.
          exact (SepE1 unit_interval (fun t0:set => apply_fun p t0 :e U) t HtU).
        - assume HtV: t :e preV.
          exact (SepE1 unit_interval (fun t0:set => apply_fun p t0 :e V) t HtV).
      + let t. assume HtI: t :e unit_interval.
        prove t :e preU :\/: preV.
        claim HptX: apply_fun p t :e X.
        { exact (Hpfunc t HtI). }
        claim HptUV: apply_fun p t :e U :\/: V.
        { rewrite HunionUV. exact HptX. }
        apply (binunionE U V (apply_fun p t) HptUV).
        - assume HptU: apply_fun p t :e U.
          apply binunionI1.
          exact (SepI unit_interval (fun t0:set => apply_fun p t0 :e U) t HtI HptU).
        - assume HptV: apply_fun p t :e V.
          apply binunionI2.
          exact (SepI unit_interval (fun t0:set => apply_fun p t0 :e V) t HtI HptV). }
  (** Preimages are open in unit_interval_topology **)
  claim HpreimgU: preU :e unit_interval_topology.
  { exact (andER (topology_on unit_interval unit_interval_topology /\ topology_on X Tx /\ function_on p unit_interval X)
                 (forall V0:set, V0 :e Tx -> preimage_of unit_interval p V0 :e unit_interval_topology)
                 Hpcont U HU). }
  claim HpreimgV: preV :e unit_interval_topology.
  { exact (andER (topology_on unit_interval unit_interval_topology /\ topology_on X Tx /\ function_on p unit_interval X)
                 (forall V0:set, V0 :e Tx -> preimage_of unit_interval p V0 :e unit_interval_topology)
                 Hpcont V HV). }
  (** This gives a separation of unit_interval **)
  claim Hsep_exists: exists U0 V0:set, U0 :e unit_interval_topology /\ V0 :e unit_interval_topology /\ separation_of unit_interval U0 V0.
  { witness preU. witness preV.
    prove preU :e unit_interval_topology /\ preV :e unit_interval_topology /\ separation_of unit_interval preU preV.
    apply andI.
    - apply andI.
      + exact HpreimgU.
      + exact HpreimgV.
    - exact Hsep_UV. }
  (** Contradiction with connectedness of unit_interval **)
  claim Hunit_nosep: ~(exists U0 V0:set, U0 :e unit_interval_topology /\ V0 :e unit_interval_topology /\ separation_of unit_interval U0 V0).
  { exact (andER (topology_on unit_interval unit_interval_topology)
                 (~(exists U0 V0:set, U0 :e unit_interval_topology /\ V0 :e unit_interval_topology /\ separation_of unit_interval U0 V0))
                 unit_interval_connected). }
  apply Hunit_nosep.
  exact Hsep_exists.
Qed.

(** from 24 Example: punctured euclidean space is path connected (placeholder) **)
(** LATEX VERSION: The plane with the origin removed is path connected. **)
(** FIXED: Origin is the ordered pair (0,0) so the removed set is {(0,0)}; setprod 0 0 is  and does not represent the origin. **)
Theorem punctured_space_path_connected :
  path_connected_space (EuclidPlane :\: {(0,0)})
    (subspace_topology EuclidPlane R2_standard_topology (EuclidPlane :\: {(0,0)})).
prove path_connected_space (EuclidPlane :\: {(0,0)}) (subspace_topology EuclidPlane R2_standard_topology (EuclidPlane :\: {(0,0)})).
set X := EuclidPlane :\: {(0,0)}.
set Tx := subspace_topology EuclidPlane R2_standard_topology X.
prove topology_on X Tx /\
  forall x y:set, x :e X -> y :e X ->
    exists p:set, path_between X x y p /\ continuous_map unit_interval unit_interval_topology X Tx p.
apply andI.
- (** topology_on X Tx **)
  claim HtopPlane: topology_on EuclidPlane R2_standard_topology.
  { exact (product_topology_is_topology R R_standard_topology R R_standard_topology
           R_standard_topology_is_topology R_standard_topology_is_topology). }
  claim HXsub: X c= EuclidPlane.
  { exact (setminus_Subq EuclidPlane {(0,0)}). }
  exact (subspace_topology_is_topology EuclidPlane R2_standard_topology X HtopPlane HXsub).
- (** path connectedness (stub) **)
  let x y.
  assume Hx: x :e X.
  assume Hy: y :e X.
  prove exists p:set, path_between X x y p /\ continuous_map unit_interval unit_interval_topology X Tx p.
  admit.
Qed.

(** from 24: continuous surjective image of a path connected space is path connected **) 
(** LATEX VERSION: If f:XY is continuous and surjective and X is path connected, then Y is path connected. **)
Theorem continuous_image_path_connected : forall X Tx Y Ty f:set,
  path_connected_space X Tx ->
  continuous_map X Tx Y Ty f ->
  (forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun f x = y) ->
  path_connected_space Y Ty.
let X Tx Y Ty f.
assume Hpath: path_connected_space X Tx.
assume Hf: continuous_map X Tx Y Ty f.
assume Hsurj: forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun f x = y.
prove path_connected_space Y Ty.
(** Extract topology on Y from continuity hypothesis **)
claim Hf_left: (topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y.
{ exact (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
              (forall V:set, V :e Ty -> preimage_of X f V :e Tx) Hf). }
claim HTy: topology_on Y Ty.
{ exact (andER (topology_on X Tx) (topology_on Y Ty)
              (andEL (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y) Hf_left)). }
claim Hpath_prop: forall x y:set, x :e X -> y :e X ->
  exists p:set, path_between X x y p /\ continuous_map unit_interval unit_interval_topology X Tx p.
{ let x y.
  assume Hx: x :e X.
  assume Hy: y :e X.
  exact (path_connected_space_paths X Tx x y Hpath Hx Hy). }

prove topology_on Y Ty /\
  forall y1 y2:set, y1 :e Y -> y2 :e Y ->
    exists p:set, path_between Y y1 y2 p /\ continuous_map unit_interval unit_interval_topology Y Ty p.
apply andI.
- exact HTy.
- let y1 y2.
  assume Hy1: y1 :e Y.
  assume Hy2: y2 :e Y.
  prove exists p:set, path_between Y y1 y2 p /\ continuous_map unit_interval unit_interval_topology Y Ty p.
  (** Choose preimages x1,x2 in X with f(xi)=yi **)
  apply (Hsurj y1 Hy1).
  let x1. assume Hx1pair: x1 :e X /\ apply_fun f x1 = y1.
  apply (Hsurj y2 Hy2).
  let x2. assume Hx2pair: x2 :e X /\ apply_fun f x2 = y2.
  claim Hx1X: x1 :e X.
  { exact (andEL (x1 :e X) (apply_fun f x1 = y1) Hx1pair). }
  claim Hfx1: apply_fun f x1 = y1.
  { exact (andER (x1 :e X) (apply_fun f x1 = y1) Hx1pair). }
  claim Hx2X: x2 :e X.
  { exact (andEL (x2 :e X) (apply_fun f x2 = y2) Hx2pair). }
  claim Hfx2: apply_fun f x2 = y2.
  { exact (andER (x2 :e X) (apply_fun f x2 = y2) Hx2pair). }

  (** Get a path p in X from x1 to x2 **)
  apply (Hpath_prop x1 x2 Hx1X Hx2X).
  let p. assume Hp_pair: path_between X x1 x2 p /\ continuous_map unit_interval unit_interval_topology X Tx p.
  claim Hp_between: path_between X x1 x2 p.
  { exact (path_witness_between X Tx x1 x2 p Hp_pair). }
  claim Hp_cont: continuous_map unit_interval unit_interval_topology X Tx p.
  { exact (path_witness_continuous X Tx x1 x2 p Hp_pair). }

  (** Define the composed path q = f  p **)
  set q := compose_fun unit_interval p f.
  claim Hq_cont: continuous_map unit_interval unit_interval_topology Y Ty q.
  { exact (composition_continuous unit_interval unit_interval_topology X Tx Y Ty p f Hp_cont Hf). }
  claim Hq_left: (topology_on unit_interval unit_interval_topology /\ topology_on Y Ty) /\ function_on q unit_interval Y.
  { exact (andEL ((topology_on unit_interval unit_interval_topology /\ topology_on Y Ty) /\ function_on q unit_interval Y)
                (forall V:set, V :e Ty -> preimage_of unit_interval q V :e unit_interval_topology) Hq_cont). }
  claim Hq_fun: function_on q unit_interval Y.
  { exact (andER (topology_on unit_interval unit_interval_topology /\ topology_on Y Ty)
                (function_on q unit_interval Y) Hq_left). }

  (** Endpoints of q **)
  claim H01: 0 :e unit_interval /\ 1 :e unit_interval.
  { exact zero_one_in_unit_interval. }
  claim H0: 0 :e unit_interval.
  { exact (andEL (0 :e unit_interval) (1 :e unit_interval) H01). }
  claim H1: 1 :e unit_interval.
  { exact (andER (0 :e unit_interval) (1 :e unit_interval) H01). }

  claim Hp_left: function_on p unit_interval X /\ apply_fun p 0 = x1.
  { exact (path_between_pair0 X x1 x2 p Hp_between). }
  claim Hp0: apply_fun p 0 = x1.
  { exact (path_between_at_zero X x1 x2 p Hp_between). }
  claim Hp1: apply_fun p 1 = x2.
  { exact (path_between_at_one X x1 x2 p Hp_between). }

  claim Hq0: apply_fun q 0 = y1.
  { claim Hq0a: apply_fun q 0 = apply_fun f (apply_fun p 0).
    { exact (compose_fun_apply unit_interval p f 0 H0). }
    rewrite Hq0a.
    rewrite Hp0.
    rewrite Hfx1.
    reflexivity. }
  claim Hq1: apply_fun q 1 = y2.
  { claim Hq1a: apply_fun q 1 = apply_fun f (apply_fun p 1).
    { exact (compose_fun_apply unit_interval p f 1 H1). }
    rewrite Hq1a.
    rewrite Hp1.
    rewrite Hfx2.
    reflexivity. }

  witness q.
  prove path_between Y y1 y2 q /\ continuous_map unit_interval unit_interval_topology Y Ty q.
  apply andI.
  - (** path_between **)
    prove function_on q unit_interval Y /\ apply_fun q 0 = y1 /\ apply_fun q 1 = y2.
    apply andI.
    + apply andI.
      * exact Hq_fun.
      * exact Hq0.
    + exact Hq1.
  - exact Hq_cont.
Qed.

(** from 24 Definition: path components equivalence relation **) 
(** LATEX VERSION: The path component of x is the set of points y that can be joined to x by a path in X. **)
Definition path_component_of : set -> set -> set -> set := fun X Tx x =>
  {y :e X | exists p:set,
     function_on p unit_interval X /\
     continuous_map unit_interval unit_interval_topology X Tx p /\
     apply_fun p 0 = x /\ apply_fun p 1 = y}.

(** Helper axioms: path reversal and concatenation **)
Theorem path_component_symmetric_axiom : forall X Tx x y:set,
  topology_on X Tx -> x :e X -> y :e X ->
  y :e path_component_of X Tx x -> x :e path_component_of X Tx y.
let X Tx x y.
assume HTx: topology_on X Tx.
assume HxX: x :e X.
assume HyX: y :e X.
assume HyPc: y :e path_component_of X Tx x.
prove x :e path_component_of X Tx y.
prove x :e {z :e X | exists p:set,
     function_on p unit_interval X /\
     continuous_map unit_interval unit_interval_topology X Tx p /\
     apply_fun p 0 = y /\ apply_fun p 1 = z}.
apply SepI.
- exact HxX.
- (** extract a path p from x to y, then reverse it **)
  prove exists p:set,
     function_on p unit_interval X /\
     continuous_map unit_interval unit_interval_topology X Tx p /\
     apply_fun p 0 = y /\ apply_fun p 1 = x.
  claim Hex: exists p:set,
     function_on p unit_interval X /\
     continuous_map unit_interval unit_interval_topology X Tx p /\
     apply_fun p 0 = x /\ apply_fun p 1 = y.
  { exact (SepE2 X (fun y0:set => exists p:set,
       function_on p unit_interval X /\
       continuous_map unit_interval unit_interval_topology X Tx p /\
       apply_fun p 0 = x /\ apply_fun p 1 = y0) y HyPc). }
  set p0 := Eps_i (fun p:set =>
     function_on p unit_interval X /\
     continuous_map unit_interval unit_interval_topology X Tx p /\
     apply_fun p 0 = x /\ apply_fun p 1 = y).
  claim Hp0prop:
     function_on p0 unit_interval X /\
     continuous_map unit_interval unit_interval_topology X Tx p0 /\
     apply_fun p0 0 = x /\ apply_fun p0 1 = y.
  { exact (Eps_i_ex (fun p:set =>
       function_on p unit_interval X /\
       continuous_map unit_interval unit_interval_topology X Tx p /\
       apply_fun p 0 = x /\ apply_fun p 1 = y) Hex). }
  (** Hp0prop is a left-associated conjunction: (((P /\ Q) /\ R) /\ S) **)
  claim Hp0A:
    ((function_on p0 unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p0) /\
      apply_fun p0 0 = x) /\
    apply_fun p0 1 = y.
  { exact Hp0prop. }
  claim Hp0B:
    (function_on p0 unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p0) /\
    apply_fun p0 0 = x.
  { exact (andEL ((function_on p0 unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p0) /\
                   apply_fun p0 0 = x)
                 (apply_fun p0 1 = y)
                 Hp0A). }
  claim Hp0C: function_on p0 unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p0.
  { exact (andEL (function_on p0 unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p0)
                 (apply_fun p0 0 = x)
                 Hp0B). }
  claim Hp_fun: function_on p0 unit_interval X.
  { exact (andEL (function_on p0 unit_interval X)
                 (continuous_map unit_interval unit_interval_topology X Tx p0)
                 Hp0C). }
  claim Hp_cont: continuous_map unit_interval unit_interval_topology X Tx p0.
  { exact (andER (function_on p0 unit_interval X)
                 (continuous_map unit_interval unit_interval_topology X Tx p0)
                 Hp0C). }
  claim Hp0eq: apply_fun p0 0 = x.
  { exact (andER (function_on p0 unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p0)
                 (apply_fun p0 0 = x)
                 Hp0B). }
  claim Hp1eq: apply_fun p0 1 = y.
  { exact (andER ((function_on p0 unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p0) /\
                   apply_fun p0 0 = x)
                 (apply_fun p0 1 = y)
                 Hp0A). }

	  set q := compose_fun unit_interval flip_unit_interval p0.
	  witness q.
	  prove function_on q unit_interval X /\
	       continuous_map unit_interval unit_interval_topology X Tx q /\
	       apply_fun q 0 = y /\ apply_fun q 1 = x.
	  apply andI.
	  - (** left-associative goals: ((fun_on /\ cont) /\ q0eq) **)
	    apply andI.
	    + (** fun_on /\ cont **)
	      apply andI.
	      * exact (function_on_compose_fun unit_interval unit_interval X
	               flip_unit_interval p0
	               flip_unit_interval_function_on
	               Hp_fun).
	      * exact (composition_continuous unit_interval unit_interval_topology
	               unit_interval unit_interval_topology
	               X Tx
	               flip_unit_interval p0
	               flip_unit_interval_continuous
	               Hp_cont).
	    + (** q 0 = y **)
	      claim H0I: 0 :e unit_interval.
	      { exact zero_in_unit_interval. }
	      claim Hq0: apply_fun q 0 = apply_fun p0 (apply_fun flip_unit_interval 0).
	      { exact (compose_fun_apply unit_interval flip_unit_interval p0 0 H0I). }
	      rewrite Hq0.
	      rewrite flip_unit_interval_at_0.
	      rewrite Hp1eq.
	      reflexivity.
	  - (** q 1 = x **)
	    claim H1I: 1 :e unit_interval.
	    { exact one_in_unit_interval. }
	    claim Hq1: apply_fun q 1 = apply_fun p0 (apply_fun flip_unit_interval 1).
	    { exact (compose_fun_apply unit_interval flip_unit_interval p0 1 H1I). }
	    rewrite Hq1.
	    rewrite flip_unit_interval_at_1.
	    rewrite Hp0eq.
	    reflexivity.
Qed.

(** Helper infrastructure for concatenating paths on the unit interval **)
(** The midpoint is eps_ 1, and twice eps_ 1 equals 1. **)

(** left half of the unit interval: [0, eps_ 1] encoded by negated strict inequality **)
Definition unit_interval_left_half : set :=
  {t :e unit_interval | ~(Rlt (eps_ 1) t)}.

(** right half of the unit interval: [eps_ 1, 1] encoded by negated strict inequality **)
Definition unit_interval_right_half : set :=
  {t :e unit_interval | ~(Rlt t (eps_ 1))}.

Theorem unit_interval_left_half_sub : unit_interval_left_half c= unit_interval.
let t.
assume Ht: t :e unit_interval_left_half.
exact (SepE1 unit_interval (fun t0:set => ~(Rlt (eps_ 1) t0)) t Ht).
Qed.

Theorem unit_interval_right_half_sub : unit_interval_right_half c= unit_interval.
let t.
assume Ht: t :e unit_interval_right_half.
exact (SepE1 unit_interval (fun t0:set => ~(Rlt t0 (eps_ 1))) t Ht).
Qed.

(** scaling maps used for concatenation, defined only on the appropriate halves **)
Definition double_map_left_half : set := graph unit_interval_left_half (fun t:set => mul_SNo 2 t).
Definition double_minus_one_map_right_half : set :=
  graph unit_interval_right_half (fun t:set => add_SNo (mul_SNo 2 t) (minus_SNo 1)).

Theorem double_map_apply : forall t:set,
  t :e unit_interval_left_half ->
  apply_fun double_map_left_half t = mul_SNo 2 t.
let t.
assume Ht: t :e unit_interval_left_half.
rewrite (apply_fun_graph unit_interval_left_half (fun t0:set => mul_SNo 2 t0) t Ht).
reflexivity.
Qed.

Theorem double_minus_one_map_apply : forall t:set,
  t :e unit_interval_right_half ->
  apply_fun double_minus_one_map_right_half t = add_SNo (mul_SNo 2 t) (minus_SNo 1).
let t.
assume Ht: t :e unit_interval_right_half.
rewrite (apply_fun_graph unit_interval_right_half (fun t0:set => add_SNo (mul_SNo 2 t0) (minus_SNo 1)) t Ht).
reflexivity.
Qed.

(** helper: scaling by 2 via eps_ 1 preserves strict inequalities on R **)
Theorem Rlt_mul2_left_iff : forall a t:set,
  a :e R -> t :e R -> (Rlt a (mul_SNo 2 t) <-> Rlt (mul_SNo (eps_ 1) a) t).
let a t.
assume HaR: a :e R.
assume HtR: t :e R.
prove (Rlt a (mul_SNo 2 t) <-> Rlt (mul_SNo (eps_ 1) a) t).
apply iffI.
- assume Halt: Rlt a (mul_SNo 2 t).
  prove Rlt (mul_SNo (eps_ 1) a) t.
  claim HaS: SNo a.
  { exact (real_SNo a HaR). }
  claim HtS: SNo t.
  { exact (real_SNo t HtR). }
  claim H2S: SNo 2.
  { exact SNo_2. }
  claim He1S: SNo (eps_ 1).
  { exact SNo_eps_1. }
  claim Hm2tS: SNo (mul_SNo 2 t).
  { exact (SNo_mul_SNo 2 t H2S HtS). }
  claim H0lte1: 0 < (eps_ 1).
  { exact (RltE_lt 0 (eps_ 1) eps_1_pos_R). }
  claim HaltS: a < mul_SNo 2 t.
  { exact (RltE_lt a (mul_SNo 2 t) Halt). }
  claim Hmul: mul_SNo (eps_ 1) a < mul_SNo (eps_ 1) (mul_SNo 2 t).
  { exact (pos_mul_SNo_Lt (eps_ 1) a (mul_SNo 2 t) He1S H0lte1 HaS Hm2tS HaltS). }
  claim Heq: mul_SNo (eps_ 1) (mul_SNo 2 t) = t.
  { rewrite (mul_SNo_assoc (eps_ 1) 2 t He1S H2S HtS).
    rewrite (mul_SNo_com (eps_ 1) 2 He1S H2S).
    rewrite eps_1_half_eq2.
    exact (mul_SNo_oneL t HtS). }
  claim Hmul': mul_SNo (eps_ 1) a < t.
  { rewrite <- Heq.
    exact Hmul. }
  claim Hmule1aR: mul_SNo (eps_ 1) a :e R.
  { claim HdefR: R = real.
    { reflexivity. }
    rewrite HdefR.
    claim HaReal: a :e real.
    { rewrite <- HdefR.
      exact HaR. }
    claim He1Real: (eps_ 1) :e real.
    { rewrite <- HdefR.
      exact eps_1_in_R. }
    exact (real_mul_SNo (eps_ 1) He1Real a HaReal). }
  exact (RltI (mul_SNo (eps_ 1) a) t Hmule1aR HtR Hmul').
- assume Hlt: Rlt (mul_SNo (eps_ 1) a) t.
  prove Rlt a (mul_SNo 2 t).
  claim HaS: SNo a.
  { exact (real_SNo a HaR). }
  claim HtS: SNo t.
  { exact (real_SNo t HtR). }
  claim H2S: SNo 2.
  { exact SNo_2. }
  claim He1S: SNo (eps_ 1).
  { exact SNo_eps_1. }
  claim He1aS: SNo (mul_SNo (eps_ 1) a).
  { exact (SNo_mul_SNo (eps_ 1) a He1S HaS). }
  claim H0lt2: 0 < 2.
  { exact (SNoLt_0_2). }
  claim HltS: mul_SNo (eps_ 1) a < t.
  { exact (RltE_lt (mul_SNo (eps_ 1) a) t Hlt). }
  claim Hmul: mul_SNo 2 (mul_SNo (eps_ 1) a) < mul_SNo 2 t.
  { exact (pos_mul_SNo_Lt 2 (mul_SNo (eps_ 1) a) t H2S H0lt2 He1aS HtS HltS). }
  claim Heq: mul_SNo 2 (mul_SNo (eps_ 1) a) = a.
  { rewrite (mul_SNo_assoc 2 (eps_ 1) a H2S He1S HaS).
    rewrite eps_1_half_eq2.
    exact (mul_SNo_oneL a HaS). }
  claim Hmul': a < mul_SNo 2 t.
  { rewrite <- Heq at 1.
    exact Hmul. }
  claim H2tR: mul_SNo 2 t :e R.
  { claim HdefR: R = real.
    { reflexivity. }
    rewrite HdefR.
    claim H2Real: 2 :e real.
    { rewrite <- HdefR.
      exact real_2. }
    claim HtReal: t :e real.
    { rewrite <- HdefR.
      exact HtR. }
    exact (real_mul_SNo 2 H2Real t HtReal). }
  exact (RltI a (mul_SNo 2 t) HaR H2tR Hmul').
Qed.

(** helper: scaling by 2 via eps_ 1 on the right-hand side **)
Theorem Rlt_mul2_right_iff : forall t b:set,
  t :e R -> b :e R -> (Rlt (mul_SNo 2 t) b <-> Rlt t (mul_SNo (eps_ 1) b)).
let t b.
assume HtR: t :e R.
assume HbR: b :e R.
prove (Rlt (mul_SNo 2 t) b <-> Rlt t (mul_SNo (eps_ 1) b)).
apply iffI.
- assume Hlt: Rlt (mul_SNo 2 t) b.
  prove Rlt t (mul_SNo (eps_ 1) b).
  claim HtS: SNo t.
  { exact (real_SNo t HtR). }
  claim HbS: SNo b.
  { exact (real_SNo b HbR). }
  claim H2S: SNo 2.
  { exact SNo_2. }
  claim He1S: SNo (eps_ 1).
  { exact SNo_eps_1. }
  claim H2tS: SNo (mul_SNo 2 t).
  { exact (SNo_mul_SNo 2 t H2S HtS). }
  claim H0lte1: 0 < (eps_ 1).
  { exact (RltE_lt 0 (eps_ 1) eps_1_pos_R). }
  claim HltS: mul_SNo 2 t < b.
  { exact (RltE_lt (mul_SNo 2 t) b Hlt). }
  claim Hmul: mul_SNo (eps_ 1) (mul_SNo 2 t) < mul_SNo (eps_ 1) b.
  { exact (pos_mul_SNo_Lt (eps_ 1) (mul_SNo 2 t) b He1S H0lte1 H2tS HbS HltS). }
  claim Heq: mul_SNo (eps_ 1) (mul_SNo 2 t) = t.
  { rewrite (mul_SNo_assoc (eps_ 1) 2 t He1S H2S HtS).
    rewrite (mul_SNo_com (eps_ 1) 2 He1S H2S).
    rewrite eps_1_half_eq2.
    exact (mul_SNo_oneL t HtS). }
  claim Hmul': t < mul_SNo (eps_ 1) b.
  { rewrite <- Heq at 1.
    exact Hmul. }
  claim He1bR: mul_SNo (eps_ 1) b :e R.
  { claim HdefR: R = real.
    { reflexivity. }
    rewrite HdefR.
    claim HbReal: b :e real.
    { rewrite <- HdefR.
      exact HbR. }
    claim He1Real: (eps_ 1) :e real.
    { rewrite <- HdefR.
      exact eps_1_in_R. }
    exact (real_mul_SNo (eps_ 1) He1Real b HbReal). }
  exact (RltI t (mul_SNo (eps_ 1) b) HtR He1bR Hmul').
- assume Hlt: Rlt t (mul_SNo (eps_ 1) b).
  prove Rlt (mul_SNo 2 t) b.
  claim HtS: SNo t.
  { exact (real_SNo t HtR). }
  claim HbS: SNo b.
  { exact (real_SNo b HbR). }
  claim H2S: SNo 2.
  { exact SNo_2. }
  claim He1S: SNo (eps_ 1).
  { exact SNo_eps_1. }
  claim He1bS: SNo (mul_SNo (eps_ 1) b).
  { exact (SNo_mul_SNo (eps_ 1) b He1S HbS). }
  claim H0lt2: 0 < 2.
  { exact (SNoLt_0_2). }
  claim HltS: t < mul_SNo (eps_ 1) b.
  { exact (RltE_lt t (mul_SNo (eps_ 1) b) Hlt). }
  claim Hmul: mul_SNo 2 t < mul_SNo 2 (mul_SNo (eps_ 1) b).
  { exact (pos_mul_SNo_Lt 2 t (mul_SNo (eps_ 1) b) H2S H0lt2 HtS He1bS HltS). }
  claim Heq: mul_SNo 2 (mul_SNo (eps_ 1) b) = b.
  { rewrite (mul_SNo_assoc 2 (eps_ 1) b H2S He1S HbS).
    rewrite eps_1_half_eq2.
    exact (mul_SNo_oneL b HbS). }
  claim Hmul': mul_SNo 2 t < b.
  { rewrite <- Heq.
    exact Hmul. }
  claim H2tR: mul_SNo 2 t :e R.
  { claim HdefR: R = real.
    { reflexivity. }
    rewrite HdefR.
    claim H2Real: 2 :e real.
    { rewrite <- HdefR.
      exact real_2. }
    claim HtReal: t :e real.
    { rewrite <- HdefR.
      exact HtR. }
    exact (real_mul_SNo 2 H2Real t HtReal). }
  exact (RltI (mul_SNo 2 t) b H2tR HbR Hmul').
Qed.

Theorem zero_in_unit_interval_left_half : 0 :e unit_interval_left_half.
prove 0 :e unit_interval_left_half.
claim H0I: 0 :e unit_interval.
{ exact zero_in_unit_interval. }
exact (SepI unit_interval (fun t0:set => ~(Rlt (eps_ 1) t0))
           0 H0I
           (not_Rlt_sym 0 (eps_ 1) eps_1_pos_R)).
Qed.

Theorem eps_1_in_unit_interval_left_half : eps_ 1 :e unit_interval_left_half.
prove eps_ 1 :e unit_interval_left_half.
claim HeI: eps_ 1 :e unit_interval.
{ exact eps_1_in_unit_interval. }
claim Hnlt: ~(Rlt (eps_ 1) (eps_ 1)).
{ exact (not_Rlt_refl (eps_ 1) eps_1_in_R). }
exact (SepI unit_interval (fun t0:set => ~(Rlt (eps_ 1) t0)) (eps_ 1) HeI Hnlt).
Qed.

Theorem eps_1_in_unit_interval_right_half : eps_ 1 :e unit_interval_right_half.
prove eps_ 1 :e unit_interval_right_half.
claim HeI: eps_ 1 :e unit_interval.
{ exact eps_1_in_unit_interval. }
claim Hnlt: ~(Rlt (eps_ 1) (eps_ 1)).
{ exact (not_Rlt_refl (eps_ 1) eps_1_in_R). }
exact (SepI unit_interval (fun t0:set => ~(Rlt t0 (eps_ 1))) (eps_ 1) HeI Hnlt).
Qed.

Theorem one_in_unit_interval_right_half : 1 :e unit_interval_right_half.
prove 1 :e unit_interval_right_half.
claim H1I: 1 :e unit_interval.
{ exact one_in_unit_interval. }
claim Hnlt: ~(Rlt 1 (eps_ 1)).
{ exact (not_Rlt_sym (eps_ 1) 1 eps_1_lt1_R). }
exact (SepI unit_interval (fun t0:set => ~(Rlt t0 (eps_ 1))) 1 H1I Hnlt).
Qed.

Theorem double_map_at_0 : apply_fun double_map_left_half 0 = 0.
prove apply_fun double_map_left_half 0 = 0.
claim H0I: 0 :e unit_interval.
{ exact zero_in_unit_interval. }
rewrite (double_map_apply 0 zero_in_unit_interval_left_half).
rewrite (mul_SNo_zeroR 2 SNo_2).
reflexivity.
Qed.

Theorem double_map_at_eps1 : apply_fun double_map_left_half (eps_ 1) = 1.
prove apply_fun double_map_left_half (eps_ 1) = 1.
rewrite (double_map_apply (eps_ 1) eps_1_in_unit_interval_left_half).
exact eps_1_half_eq2.
Qed.

Theorem double_minus_one_map_at_eps1 : apply_fun double_minus_one_map_right_half (eps_ 1) = 0.
prove apply_fun double_minus_one_map_right_half (eps_ 1) = 0.
rewrite (double_minus_one_map_apply (eps_ 1) eps_1_in_unit_interval_right_half).
rewrite eps_1_half_eq2.
rewrite (add_SNo_minus_SNo_rinv 1 SNo_1).
reflexivity.
Qed.

Theorem double_minus_one_map_at_1 : apply_fun double_minus_one_map_right_half 1 = 1.
prove apply_fun double_minus_one_map_right_half 1 = 1.
rewrite (double_minus_one_map_apply 1 one_in_unit_interval_right_half).
rewrite (mul_SNo_oneR 2 SNo_2).
claim Hm1R: minus_SNo 1 :e R.
{ exact (real_minus_SNo 1 real_1). }
claim Hm1S: SNo (minus_SNo 1).
{ exact (real_SNo (minus_SNo 1) Hm1R). }
rewrite <- add_SNo_1_1_2 at 1.
rewrite <- (add_SNo_assoc 1 1 (minus_SNo 1) SNo_1 SNo_1 Hm1S) at 1.
claim Hinner: add_SNo 1 (minus_SNo 1) = 0.
{ exact (add_SNo_minus_SNo_rinv 1 SNo_1). }
rewrite Hinner.
rewrite (add_SNo_0R 1 SNo_1).
reflexivity.
Qed.

(** placeholders: properties needed to justify concatenation via the pasting lemma **)
Theorem unit_interval_halves_cover :
  unit_interval_left_half :\/: unit_interval_right_half = unit_interval.
prove unit_interval_left_half :\/: unit_interval_right_half = unit_interval.
apply set_ext.
- let t. assume Ht: t :e unit_interval_left_half :\/: unit_interval_right_half.
  prove t :e unit_interval.
  apply (binunionE unit_interval_left_half unit_interval_right_half t Ht).
  * assume HtL: t :e unit_interval_left_half.
    exact (unit_interval_left_half_sub t HtL).
  * assume HtR: t :e unit_interval_right_half.
    exact (unit_interval_right_half_sub t HtR).
- let t. assume HtI: t :e unit_interval.
  prove t :e unit_interval_left_half :\/: unit_interval_right_half.
  apply (xm (Rlt t (eps_ 1))).
  * assume Htlt: Rlt t (eps_ 1).
    claim Hnlt: ~(Rlt (eps_ 1) t).
    { exact (not_Rlt_sym t (eps_ 1) Htlt). }
    claim HtL: t :e unit_interval_left_half.
    { exact (SepI unit_interval (fun t0:set => ~(Rlt (eps_ 1) t0)) t HtI Hnlt). }
    exact (binunionI1 unit_interval_left_half unit_interval_right_half t HtL).
  * assume Hnlt: ~(Rlt t (eps_ 1)).
    claim HtR: t :e unit_interval_right_half.
    { exact (SepI unit_interval (fun t0:set => ~(Rlt t0 (eps_ 1))) t HtI Hnlt). }
    exact (binunionI2 unit_interval_left_half unit_interval_right_half t HtR).
Qed.

Theorem unit_interval_halves_closed :
  closed_in unit_interval unit_interval_topology unit_interval_left_half /\
  closed_in unit_interval unit_interval_topology unit_interval_right_half.
prove closed_in unit_interval unit_interval_topology unit_interval_left_half /\
  closed_in unit_interval unit_interval_topology unit_interval_right_half.
apply andI.
- (** left half is closed in the subspace topology **)
  apply (closed_inI unit_interval unit_interval_topology unit_interval_left_half).
  * exact unit_interval_topology_on.
  * exact unit_interval_left_half_sub.
  * set V := {x :e R|Rlt (eps_ 1) x}.
	set U := V :/\: unit_interval.
	witness U.
	apply andI.
	- (** U is open in the unit interval topology **)
	   claim Hut: unit_interval_topology = subspace_topology R R_standard_topology unit_interval.
	   { reflexivity. }
	   rewrite Hut.
	   claim HUpow: U :e Power unit_interval.
	   { exact (PowerI unit_interval U (binintersect_Subq_2 V unit_interval)). }
       claim Hex: exists W :e R_standard_topology, U = W :/\: unit_interval.
       { witness V.
         apply andI.
         - exact (open_ray_in_R_standard_topology (eps_ 1) eps_1_in_R).
         - reflexivity. }
       exact (SepI (Power unit_interval)
                   (fun U0:set => exists W :e R_standard_topology, U0 = W :/\: unit_interval)
                   U HUpow Hex).
	- (** left half is the complement of U in unit_interval **)
	   prove unit_interval_left_half = unit_interval :\: U.
	   apply set_ext.
       - let t. assume HtL: t :e unit_interval_left_half.
         prove t :e unit_interval :\: U.
         apply setminusI.
         + exact (unit_interval_left_half_sub t HtL).
         + assume HtU: t :e U.
           prove False.
           claim HtV: t :e V.
           { exact (binintersectE1 V unit_interval t HtU). }
           claim Hnlt: ~(Rlt (eps_ 1) t).
           { exact (SepE2 unit_interval (fun t0:set => ~(Rlt (eps_ 1) t0)) t HtL). }
           claim Hlt: Rlt (eps_ 1) t.
           { exact (SepE2 R (fun x0:set => Rlt (eps_ 1) x0) t HtV). }
           exact (Hnlt Hlt).
       - let t. assume Ht: t :e unit_interval :\: U.
         prove t :e unit_interval_left_half.
         claim HtI: t :e unit_interval.
         { exact (setminusE1 unit_interval U t Ht). }
         apply (SepI unit_interval (fun t0:set => ~(Rlt (eps_ 1) t0)) t HtI).
         prove ~(Rlt (eps_ 1) t).
         assume Hlt: Rlt (eps_ 1) t.
         prove False.
         claim HtR: t :e R.
         { exact (unit_interval_sub_R t HtI). }
         claim HtV: t :e V.
         { exact (SepI R (fun x0:set => Rlt (eps_ 1) x0) t HtR Hlt). }
         claim HtU2: t :e U.
         { exact (binintersectI V unit_interval t HtV HtI). }
         claim HnotU: t /:e U.
         { exact (setminusE2 unit_interval U t Ht). }
         exact (HnotU HtU2).
- (** right half is closed in the subspace topology **)
  apply (closed_inI unit_interval unit_interval_topology unit_interval_right_half).
  * exact unit_interval_topology_on.
  * exact unit_interval_right_half_sub.
  * set V := {x :e R|Rlt x (eps_ 1)}.
	set U := V :/\: unit_interval.
	witness U.
	apply andI.
	- (** U is open in the unit interval topology **)
	   claim Hut: unit_interval_topology = subspace_topology R R_standard_topology unit_interval.
	   { reflexivity. }
	   rewrite Hut.
	   claim HUpow: U :e Power unit_interval.
	   { exact (PowerI unit_interval U (binintersect_Subq_2 V unit_interval)). }
       claim Hex: exists W :e R_standard_topology, U = W :/\: unit_interval.
       { witness V.
         apply andI.
         - exact (open_left_ray_in_R_standard_topology (eps_ 1) eps_1_in_R).
         - reflexivity. }
       exact (SepI (Power unit_interval)
                   (fun U0:set => exists W :e R_standard_topology, U0 = W :/\: unit_interval)
                   U HUpow Hex).
	- (** right half is the complement of U in unit_interval **)
	   prove unit_interval_right_half = unit_interval :\: U.
	   apply set_ext.
       - let t. assume HtR: t :e unit_interval_right_half.
         prove t :e unit_interval :\: U.
         apply setminusI.
         + exact (unit_interval_right_half_sub t HtR).
         + assume HtU: t :e U.
           prove False.
           claim HtV: t :e V.
           { exact (binintersectE1 V unit_interval t HtU). }
           claim Hnlt: ~(Rlt t (eps_ 1)).
           { exact (SepE2 unit_interval (fun t0:set => ~(Rlt t0 (eps_ 1))) t HtR). }
           claim Hlt: Rlt t (eps_ 1).
           { exact (SepE2 R (fun x0:set => Rlt x0 (eps_ 1)) t HtV). }
           exact (Hnlt Hlt).
       - let t. assume Ht: t :e unit_interval :\: U.
         prove t :e unit_interval_right_half.
         claim HtI: t :e unit_interval.
         { exact (setminusE1 unit_interval U t Ht). }
         apply (SepI unit_interval (fun t0:set => ~(Rlt t0 (eps_ 1))) t HtI).
         prove ~(Rlt t (eps_ 1)).
         assume Hlt: Rlt t (eps_ 1).
         prove False.
         claim HtR: t :e R.
         { exact (unit_interval_sub_R t HtI). }
         claim HtV: t :e V.
         { exact (SepI R (fun x0:set => Rlt x0 (eps_ 1)) t HtR Hlt). }
         claim HtU2: t :e U.
         { exact (binintersectI V unit_interval t HtV HtI). }
         claim HnotU: t /:e U.
         { exact (setminusE2 unit_interval U t Ht). }
         exact (HnotU HtU2).
Qed.

Theorem unit_interval_halves_intersection :
  (unit_interval_left_half :/\: unit_interval_right_half) = {eps_ 1}.
prove (unit_interval_left_half :/\: unit_interval_right_half) = {eps_ 1}.
apply set_ext.
- let t. assume Ht: t :e (unit_interval_left_half :/\: unit_interval_right_half).
  prove t :e {eps_ 1}.
  claim HtL: t :e unit_interval_left_half.
  { exact (binintersectE1 unit_interval_left_half unit_interval_right_half t Ht). }
  claim HtR: t :e unit_interval_right_half.
  { exact (binintersectE2 unit_interval_left_half unit_interval_right_half t Ht). }
  claim HtI: t :e unit_interval.
  { exact (unit_interval_left_half_sub t HtL). }
  claim HtReal: t :e R.
  { exact (unit_interval_sub_R t HtI). }
  claim HeReal: eps_ 1 :e R.
  { exact eps_1_in_R. }
  claim HtS: SNo t.
  { exact (real_SNo t HtReal). }
  claim HeS: SNo (eps_ 1).
  { exact (real_SNo (eps_ 1) HeReal). }
  claim Hnlt_et: ~(Rlt (eps_ 1) t).
  { exact (SepE2 unit_interval (fun t0:set => ~(Rlt (eps_ 1) t0)) t HtL). }
  claim Hnlt_te: ~(Rlt t (eps_ 1)).
  { exact (SepE2 unit_interval (fun t0:set => ~(Rlt t0 (eps_ 1))) t HtR). }
  apply (SNoLt_trichotomy_or_impred t (eps_ 1) HtS HeS (t :e {eps_ 1})).
  * assume HtltS: t < (eps_ 1).
    claim Htlt: Rlt t (eps_ 1).
    { exact (RltI t (eps_ 1) HtReal HeReal HtltS). }
    apply FalseE.
    exact (Hnlt_te Htlt).
  * assume Heq: t = eps_ 1.
    rewrite Heq.
    exact (SingI (eps_ 1)).
  * assume HeltS: (eps_ 1) < t.
    claim Helt: Rlt (eps_ 1) t.
    { exact (RltI (eps_ 1) t HeReal HtReal HeltS). }
    apply FalseE.
    exact (Hnlt_et Helt).
 - let t. assume Ht: t :e {eps_ 1}.
  prove t :e (unit_interval_left_half :/\: unit_interval_right_half).
  claim Hteq: t = eps_ 1.
  { exact (SingE (eps_ 1) t Ht). }
  rewrite Hteq.
  claim HeI: eps_ 1 :e unit_interval.
  { exact eps_1_in_unit_interval. }
  claim Hnlt_e: ~(Rlt (eps_ 1) (eps_ 1)).
  { exact (not_Rlt_refl (eps_ 1) eps_1_in_R). }
  claim Hnlt_e2: ~(Rlt (eps_ 1) (eps_ 1)).
  { exact (not_Rlt_refl (eps_ 1) eps_1_in_R). }
  claim HeL: eps_ 1 :e unit_interval_left_half.
  { exact (SepI unit_interval (fun t0:set => ~(Rlt (eps_ 1) t0)) (eps_ 1) HeI Hnlt_e). }
  claim HeR: eps_ 1 :e unit_interval_right_half.
  { exact (SepI unit_interval (fun t0:set => ~(Rlt t0 (eps_ 1))) (eps_ 1) HeI Hnlt_e2). }
  exact (binintersectI unit_interval_left_half unit_interval_right_half (eps_ 1) HeL HeR).
Qed.

Theorem double_map_function_on :
  function_on double_map_left_half unit_interval_left_half unit_interval.
let t.
assume HtL: t :e unit_interval_left_half.
prove apply_fun double_map_left_half t :e unit_interval.
rewrite (double_map_apply t HtL).
prove mul_SNo 2 t :e unit_interval.
claim HtI: t :e unit_interval.
{ exact (unit_interval_left_half_sub t HtL). }
claim HtR: t :e R.
{ exact (unit_interval_sub_R t HtI). }
claim HtS: SNo t.
{ exact (real_SNo t HtR). }
claim H2R: 2 :e R.
{ exact two_in_R. }
claim HmulR: mul_SNo 2 t :e R.
{ exact (real_mul_SNo 2 H2R t HtR). }
apply (SepI R (fun s:set => ~(Rlt s 0) /\ ~(Rlt 1 s)) (mul_SNo 2 t) HmulR).
apply andI.
- (** show ~(mul_SNo 2 t < 0) **)
  assume Hlt: Rlt (mul_SNo 2 t) 0.
  prove False.
  claim H2S: SNo 2.
  { exact SNo_2. }
  claim HmulS: SNo (mul_SNo 2 t).
  { exact (SNo_mul_SNo 2 t H2S HtS). }
  claim Ht0nlt: ~(Rlt t 0).
  { claim Hconj: ~(Rlt t 0) /\ ~(Rlt 1 t).
    { exact (SepE2 R (fun u:set => ~(Rlt u 0) /\ ~(Rlt 1 u)) t HtI). }
    exact (andEL (~(Rlt t 0)) (~(Rlt 1 t)) Hconj). }
  claim H0le2: 0 <= 2.
  { exact (SNoLtLe 0 2 SNoLt_0_2). }
  claim H0let: 0 <= t.
  { prove 0 <= t.
    apply (SNoLtLe_or t 0 HtS SNo_0).
    - assume Htlt0: t < 0.
      claim Hrtlt: Rlt t 0.
      { exact (RltI t 0 HtR real_0 Htlt0). }
      apply FalseE.
      exact (Ht0nlt Hrtlt).
    - assume H0let': 0 <= t.
      exact H0let'. }
  claim H0lemul: 0 <= mul_SNo 2 t.
  { exact (mul_SNo_nonneg_nonneg 2 t H2S HtS H0le2 H0let). }
  claim HmulLt0: mul_SNo 2 t < 0.
  { exact (RltE_lt (mul_SNo 2 t) 0 Hlt). }
  claim Hcases: 0 < (mul_SNo 2 t) \/ 0 = (mul_SNo 2 t).
  { exact (SNoLeE 0 (mul_SNo 2 t) SNo_0 HmulS H0lemul). }
  apply Hcases.
  - assume Hpos: 0 < (mul_SNo 2 t).
    claim H00: 0 < 0.
    { exact (SNoLt_tra 0 (mul_SNo 2 t) 0 SNo_0 HmulS SNo_0 Hpos HmulLt0). }
    exact ((SNoLt_irref 0) H00).
	  - assume Heq: 0 = (mul_SNo 2 t).
	    claim H00: 0 < 0.
	    { rewrite Heq at 1.
	      exact HmulLt0. }
	    exact ((SNoLt_irref 0) H00).
- (** show ~(1 < mul_SNo 2 t) **)
  assume Hlt: Rlt 1 (mul_SNo 2 t).
  prove False.
  claim H2S: SNo 2.
  { exact SNo_2. }
  claim HmulS: SNo (mul_SNo 2 t).
  { exact (SNo_mul_SNo 2 t H2S HtS). }
  claim HeS: SNo (eps_ 1).
  { exact (real_SNo (eps_ 1) eps_1_in_R). }
  claim Hnlt: ~(Rlt (eps_ 1) t).
  { exact (SepE2 unit_interval (fun u:set => ~(Rlt (eps_ 1) u)) t HtL). }
  claim Htle: t <= (eps_ 1).
  { prove t <= (eps_ 1).
    apply (SNoLtLe_or (eps_ 1) t HeS HtS).
    - assume Hepslt: (eps_ 1) < t.
      claim Hrtlt: Rlt (eps_ 1) t.
      { exact (RltI (eps_ 1) t eps_1_in_R HtR Hepslt). }
      apply FalseE.
      exact (Hnlt Hrtlt).
    - assume Htle': t <= (eps_ 1).
      exact Htle'. }
  claim H0le2: 0 <= 2.
  { exact (SNoLtLe 0 2 SNoLt_0_2). }
  claim H2tLe: mul_SNo 2 t <= 1.
  { claim H2eps: mul_SNo 2 t <= mul_SNo 2 (eps_ 1).
    { exact (nonneg_mul_SNo_Le 2 t (eps_ 1) H2S H0le2 HtS HeS Htle). }
    prove mul_SNo 2 t <= 1.
    rewrite <- eps_1_half_eq2 at 2.
    exact H2eps. }
  claim H1lt: 1 < (mul_SNo 2 t).
  { exact (RltE_lt 1 (mul_SNo 2 t) Hlt). }
  claim Hcases: (mul_SNo 2 t) < 1 \/ (mul_SNo 2 t) = 1.
  { exact (SNoLeE (mul_SNo 2 t) 1 HmulS SNo_1 H2tLe). }
  apply Hcases.
  - assume Hlt2: (mul_SNo 2 t) < 1.
    claim H11: 1 < 1.
    { exact (SNoLt_tra 1 (mul_SNo 2 t) 1 SNo_1 HmulS SNo_1 H1lt Hlt2). }
    exact ((SNoLt_irref 1) H11).
  - assume Heq: (mul_SNo 2 t) = 1.
    claim H11: 1 < 1.
    { rewrite <- Heq at 2.
      exact H1lt. }
    exact ((SNoLt_irref 1) H11).
Qed.

Theorem double_minus_one_map_function_on :
  function_on double_minus_one_map_right_half unit_interval_right_half unit_interval.
let t.
assume HtH: t :e unit_interval_right_half.
prove apply_fun double_minus_one_map_right_half t :e unit_interval.
rewrite (double_minus_one_map_apply t HtH).
prove add_SNo (mul_SNo 2 t) (minus_SNo 1) :e unit_interval.

claim HtI: t :e unit_interval.
{ exact (unit_interval_right_half_sub t HtH). }
claim HtR: t :e R.
{ exact (unit_interval_sub_R t HtI). }
claim HtS: SNo t.
{ exact (real_SNo t HtR). }
claim HeR: eps_ 1 :e R.
{ exact eps_1_in_R. }
claim HeS: SNo (eps_ 1).
{ exact (real_SNo (eps_ 1) HeR). }
claim H2R: 2 :e R.
{ exact two_in_R. }
claim Hm1R: minus_SNo 1 :e R.
{ exact (real_minus_SNo 1 real_1). }
claim Hm1S: SNo (minus_SNo 1).
{ exact (real_SNo (minus_SNo 1) Hm1R). }
claim H2S: SNo 2.
{ exact SNo_2. }

claim HmulR: mul_SNo 2 t :e R.
{ exact (real_mul_SNo 2 H2R t HtR). }
claim HsR: add_SNo (mul_SNo 2 t) (minus_SNo 1) :e R.
{ exact (real_add_SNo (mul_SNo 2 t) HmulR (minus_SNo 1) Hm1R). }
claim HsS: SNo (add_SNo (mul_SNo 2 t) (minus_SNo 1)).
{ exact (real_SNo (add_SNo (mul_SNo 2 t) (minus_SNo 1)) HsR). }

apply (SepI R (fun u:set => ~(Rlt u 0) /\ ~(Rlt 1 u))
         (add_SNo (mul_SNo 2 t) (minus_SNo 1)) HsR).
apply andI.
- assume Hlt: Rlt (add_SNo (mul_SNo 2 t) (minus_SNo 1)) 0.
  prove False.
  claim Hslt0: add_SNo (mul_SNo 2 t) (minus_SNo 1) < 0.
  { exact (RltE_lt (add_SNo (mul_SNo 2 t) (minus_SNo 1)) 0 Hlt). }

  claim Hnlt_t_eps: ~(Rlt t (eps_ 1)).
  { exact (SepE2 unit_interval (fun u:set => ~(Rlt u (eps_ 1))) t HtH). }
  claim Hepsle_t: (eps_ 1) <= t.
  { prove (eps_ 1) <= t.
    apply (SNoLtLe_or t (eps_ 1) HtS HeS).
    - assume Htlt: t < (eps_ 1).
      claim Hrlt: Rlt t (eps_ 1).
      { exact (RltI t (eps_ 1) HtR HeR Htlt). }
      apply FalseE.
      exact (Hnlt_t_eps Hrlt).
    - assume Hle: (eps_ 1) <= t.
      exact Hle. }

  claim H0le2: 0 <= 2.
  { exact (SNoLtLe 0 2 SNoLt_0_2). }
  claim H2eps_le_2t: mul_SNo 2 (eps_ 1) <= mul_SNo 2 t.
  { exact (nonneg_mul_SNo_Le 2 (eps_ 1) t H2S H0le2 HeS HtS Hepsle_t). }
  claim H1le2t: 1 <= mul_SNo 2 t.
  { rewrite <- eps_1_half_eq2 at 1.
    exact H2eps_le_2t. }
  claim H0les: 0 <= add_SNo (mul_SNo 2 t) (minus_SNo 1).
  { prove 0 <= add_SNo (mul_SNo 2 t) (minus_SNo 1).
    rewrite <- (add_SNo_minus_SNo_rinv 1 SNo_1) at 1.
    exact (add_SNo_Le1 1 (minus_SNo 1) (mul_SNo 2 t)
             SNo_1 Hm1S (SNo_mul_SNo 2 t H2S HtS)
             H1le2t). }

  claim Hcases: 0 < add_SNo (mul_SNo 2 t) (minus_SNo 1) \/
                0 = add_SNo (mul_SNo 2 t) (minus_SNo 1).
  { exact (SNoLeE 0 (add_SNo (mul_SNo 2 t) (minus_SNo 1)) SNo_0 HsS H0les). }
  apply Hcases.
  - assume Hpos: 0 < add_SNo (mul_SNo 2 t) (minus_SNo 1).
    claim H00: 0 < 0.
    { exact (SNoLt_tra 0 (add_SNo (mul_SNo 2 t) (minus_SNo 1)) 0
             SNo_0 HsS SNo_0 Hpos Hslt0). }
    exact ((SNoLt_irref 0) H00).
  - assume Heq: 0 = add_SNo (mul_SNo 2 t) (minus_SNo 1).
    claim H00: 0 < 0.
    { rewrite Heq at 1.
      exact Hslt0. }
    exact ((SNoLt_irref 0) H00).
- assume Hlt: Rlt 1 (add_SNo (mul_SNo 2 t) (minus_SNo 1)).
  prove False.
  claim H1lts: 1 < add_SNo (mul_SNo 2 t) (minus_SNo 1).
  { exact (RltE_lt 1 (add_SNo (mul_SNo 2 t) (minus_SNo 1)) Hlt). }

  claim Hnlt_1t: ~(Rlt 1 t).
  { claim Hconj: ~(Rlt t 0) /\ ~(Rlt 1 t).
    { exact (SepE2 R (fun u:set => ~(Rlt u 0) /\ ~(Rlt 1 u)) t HtI). }
    exact (andER (~(Rlt t 0)) (~(Rlt 1 t)) Hconj). }
  claim Htle1: t <= 1.
  { prove t <= 1.
    apply (SNoLtLe_or 1 t SNo_1 HtS).
    - assume H1lt: 1 < t.
      claim Hrlt: Rlt 1 t.
      { exact (RltI 1 t real_1 HtR H1lt). }
      apply FalseE.
      exact (Hnlt_1t Hrlt).
    - assume Hle: t <= 1.
      exact Hle. }

  claim H0le2: 0 <= 2.
  { exact (SNoLtLe 0 2 SNoLt_0_2). }
  claim H2t_le_2: mul_SNo 2 t <= mul_SNo 2 1.
  { exact (nonneg_mul_SNo_Le 2 t 1 H2S H0le2 HtS SNo_1 Htle1). }
  claim H2t_le_2': mul_SNo 2 t <= 2.
  { rewrite <- (mul_SNo_oneR 2 SNo_2) at 2.
    exact H2t_le_2. }
  claim Hsle_2m1: add_SNo (mul_SNo 2 t) (minus_SNo 1) <= add_SNo 2 (minus_SNo 1).
  { exact (add_SNo_Le1 (mul_SNo 2 t) (minus_SNo 1) 2
           (SNo_mul_SNo 2 t H2S HtS) Hm1S SNo_2
           H2t_le_2'). }
  claim H2m1eq1: add_SNo 2 (minus_SNo 1) = 1.
  { rewrite <- add_SNo_1_1_2 at 1.
    rewrite <- (add_SNo_assoc 1 1 (minus_SNo 1) SNo_1 SNo_1 Hm1S) at 1.
    rewrite (add_SNo_minus_SNo_rinv 1 SNo_1) at 1.
    rewrite (add_SNo_0R 1 SNo_1) at 1.
    reflexivity. }
  claim Hsle1: add_SNo (mul_SNo 2 t) (minus_SNo 1) <= 1.
  { claim H2m1S: SNo (add_SNo 2 (minus_SNo 1)).
    { exact (SNo_add_SNo 2 (minus_SNo 1) SNo_2 Hm1S). }
    claim H2m1le1: add_SNo 2 (minus_SNo 1) <= 1.
    { rewrite H2m1eq1 at 1.
      exact (SNoLe_ref 1). }
    exact (SNoLe_tra (add_SNo (mul_SNo 2 t) (minus_SNo 1))
                     (add_SNo 2 (minus_SNo 1))
                     1
                     HsS H2m1S SNo_1
                     Hsle_2m1 H2m1le1). }

  claim Hcases: add_SNo (mul_SNo 2 t) (minus_SNo 1) < 1 \/
                add_SNo (mul_SNo 2 t) (minus_SNo 1) = 1.
  { exact (SNoLeE (add_SNo (mul_SNo 2 t) (minus_SNo 1)) 1 HsS SNo_1 Hsle1). }
  apply Hcases.
  - assume Hslt1: add_SNo (mul_SNo 2 t) (minus_SNo 1) < 1.
    claim H11: 1 < 1.
    { exact (SNoLt_tra 1 (add_SNo (mul_SNo 2 t) (minus_SNo 1)) 1
             SNo_1 HsS SNo_1 H1lts Hslt1). }
    exact ((SNoLt_irref 1) H11).
  - assume Heq: add_SNo (mul_SNo 2 t) (minus_SNo 1) = 1.
    claim H11: 1 < 1.
    { rewrite <- Heq at 2.
      exact H1lts. }
    exact ((SNoLt_irref 1) H11).
Qed.

Theorem double_map_continuous :
  continuous_map unit_interval_left_half
    (subspace_topology unit_interval unit_interval_topology unit_interval_left_half)
    unit_interval unit_interval_topology
    double_map_left_half.
prove continuous_map unit_interval_left_half
        (subspace_topology unit_interval unit_interval_topology unit_interval_left_half)
        unit_interval unit_interval_topology
        double_map_left_half.
(** range restriction: factor through R, then restrict codomain to unit_interval **)
claim HcontR: continuous_map unit_interval_left_half
  (subspace_topology unit_interval unit_interval_topology unit_interval_left_half)
  R R_standard_topology
  double_map_left_half.
{ set Tx := subspace_topology unit_interval unit_interval_topology unit_interval_left_half.
  set S := open_rays_subbasis R.

  claim HTui: topology_on unit_interval unit_interval_topology.
  { exact unit_interval_topology_on. }
  claim HTx: topology_on unit_interval_left_half Tx.
  { exact (subspace_topology_is_topology unit_interval unit_interval_topology unit_interval_left_half
           HTui
           unit_interval_left_half_sub). }

  claim HS: subbasis_on R S.
  { exact (open_rays_subbasis_is_subbasis R). }

  claim Hfun: function_on double_map_left_half unit_interval_left_half R.
  { let t. assume Ht: t :e unit_interval_left_half.
    prove apply_fun double_map_left_half t :e R.
    claim HtI: t :e unit_interval.
    { exact (unit_interval_left_half_sub t Ht). }
    claim HtR: t :e R.
    { exact (unit_interval_sub_R t HtI). }
    claim H2R: 2 :e R.
    { exact real_2. }
    claim HmulR: mul_SNo 2 t :e R.
    { claim HdefR: R = real.
      { reflexivity. }
      rewrite HdefR.
      claim H2Real: 2 :e real.
      { rewrite <- HdefR.
        exact H2R. }
      claim HtReal: t :e real.
      { rewrite <- HdefR.
        exact HtR. }
      exact (real_mul_SNo 2 H2Real t HtReal). }
    rewrite (double_map_apply t Ht).
    exact HmulR. }

  claim Hgen: generated_topology_from_subbasis R S = R_standard_topology.
  { rewrite (open_rays_subbasis_for_order_topology R).
    rewrite standard_topology_is_order_topology.
    reflexivity. }
  rewrite <- Hgen.

  claim HpreS: forall s:set, s :e S -> preimage_of unit_interval_left_half double_map_left_half s :e Tx.
  { let s. assume HsS: s :e S.
    prove preimage_of unit_interval_left_half double_map_left_half s :e Tx.
    apply (binunionE' ({I :e Power R | exists a :e R, I = open_ray_upper R a}
                       :\/:
                       {I :e Power R | exists b :e R, I = open_ray_lower R b})
                      {R}
                      s
                      (preimage_of unit_interval_left_half double_map_left_half s :e Tx)).
    - assume Hs0: s :e ({I :e Power R | exists a :e R, I = open_ray_upper R a}
                        :\/:
                        {I :e Power R | exists b :e R, I = open_ray_lower R b}).
      apply (binunionE' {I :e Power R | exists a :e R, I = open_ray_upper R a}
                        {I :e Power R | exists b :e R, I = open_ray_lower R b}
                        s
                        (preimage_of unit_interval_left_half double_map_left_half s :e Tx)).
      + assume Hsu: s :e {I :e Power R | exists a :e R, I = open_ray_upper R a}.
        claim Hex: exists a :e R, s = open_ray_upper R a.
        { exact (SepE2 (Power R)
                      (fun I0 : set => exists a :e R, I0 = open_ray_upper R a)
                      s Hsu). }
        apply Hex.
        let a. assume Hcore.
        apply Hcore.
        assume HaR: a :e R.
        assume Hseq: s = open_ray_upper R a.
        rewrite Hseq.

        set c := mul_SNo (eps_ 1) a.
        claim HcR: c :e R.
        { claim HdefR: R = real.
          { reflexivity. }
          rewrite HdefR.
          claim HaReal: a :e real.
          { rewrite <- HdefR.
            exact HaR. }
          claim He1Real: (eps_ 1) :e real.
          { rewrite <- HdefR.
            exact eps_1_in_R. }
          exact (real_mul_SNo (eps_ 1) He1Real a HaReal). }

        claim HpreEq: preimage_of unit_interval_left_half double_map_left_half (open_ray_upper R a)
                      = (open_ray_upper R c) :/\: unit_interval_left_half.
        { apply set_ext.
          - let t. assume Ht: t :e preimage_of unit_interval_left_half double_map_left_half (open_ray_upper R a).
            prove t :e (open_ray_upper R c) :/\: unit_interval_left_half.
            claim HtLH: t :e unit_interval_left_half.
            { exact (SepE1 unit_interval_left_half
                         (fun u : set => apply_fun double_map_left_half u :e open_ray_upper R a) t Ht). }
            claim HtI: t :e unit_interval.
            { exact (unit_interval_left_half_sub t HtLH). }
            claim HtR: t :e R.
            { exact (unit_interval_sub_R t HtI). }
            claim Himg: apply_fun double_map_left_half t :e open_ray_upper R a.
            { exact (SepE2 unit_interval_left_half
                         (fun u : set => apply_fun double_map_left_half u :e open_ray_upper R a) t Ht). }
            claim Hrel: order_rel R a (apply_fun double_map_left_half t).
            { exact (SepE2 R (fun x0 : set => order_rel R a x0) (apply_fun double_map_left_half t) Himg). }
            claim Hrlt: Rlt a (apply_fun double_map_left_half t).
            { exact (order_rel_R_implies_Rlt a (apply_fun double_map_left_half t) Hrel). }
            claim Hrlt2: Rlt a (mul_SNo 2 t).
            { rewrite <- (double_map_apply t HtLH).
              exact Hrlt. }
            claim Hrltc: Rlt c t.
            { exact (iffEL (Rlt a (mul_SNo 2 t)) (Rlt (mul_SNo (eps_ 1) a) t)
                          (Rlt_mul2_left_iff a t HaR HtR) Hrlt2). }
            claim HcRel: order_rel R c t.
            { exact (Rlt_implies_order_rel_R c t Hrltc). }
            claim HtRay: t :e open_ray_upper R c.
            { exact (SepI R (fun x0 : set => order_rel R c x0) t HtR HcRel). }
            exact (binintersectI (open_ray_upper R c) unit_interval_left_half t HtRay HtLH).
          - let t. assume Ht: t :e (open_ray_upper R c) :/\: unit_interval_left_half.
            prove t :e preimage_of unit_interval_left_half double_map_left_half (open_ray_upper R a).
            claim HtRay: t :e open_ray_upper R c.
            { exact (binintersectE1 (open_ray_upper R c) unit_interval_left_half t Ht). }
            claim HtLH: t :e unit_interval_left_half.
            { exact (binintersectE2 (open_ray_upper R c) unit_interval_left_half t Ht). }
            claim HtI: t :e unit_interval.
            { exact (unit_interval_left_half_sub t HtLH). }
            claim HtR: t :e R.
            { exact (unit_interval_sub_R t HtI). }
            claim Hrel: order_rel R c t.
            { exact (SepE2 R (fun x0 : set => order_rel R c x0) t HtRay). }
            claim Hrlt: Rlt c t.
            { exact (order_rel_R_implies_Rlt c t Hrel). }
            claim Hrlt2: Rlt a (mul_SNo 2 t).
            { exact (iffER (Rlt a (mul_SNo 2 t)) (Rlt (mul_SNo (eps_ 1) a) t)
                          (Rlt_mul2_left_iff a t HaR HtR) Hrlt). }
            claim Hrlt3: Rlt a (apply_fun double_map_left_half t).
            { rewrite (double_map_apply t HtLH).
              exact Hrlt2. }
            claim Hrel2: order_rel R a (apply_fun double_map_left_half t).
            { exact (Rlt_implies_order_rel_R a (apply_fun double_map_left_half t) Hrlt3). }
            claim HimgR: apply_fun double_map_left_half t :e R.
            { exact (Hfun t HtLH). }
            claim Himg: apply_fun double_map_left_half t :e open_ray_upper R a.
            { exact (SepI R (fun x0 : set => order_rel R a x0)
                          (apply_fun double_map_left_half t) HimgR Hrel2). }
            exact (SepI unit_interval_left_half
                        (fun u : set => apply_fun double_map_left_half u :e open_ray_upper R a)
                        t HtLH Himg). }

        rewrite HpreEq.
        prove (open_ray_upper R c) :/\: unit_interval_left_half :e Tx.
        prove (open_ray_upper R c) :/\: unit_interval_left_half :e
             {W :e Power unit_interval_left_half | exists Z :e unit_interval_topology,
                  W = Z :/\: unit_interval_left_half}.
        claim Hpow: (open_ray_upper R c) :/\: unit_interval_left_half :e Power unit_interval_left_half.
        { apply PowerI.
          let t. assume Ht: t :e (open_ray_upper R c) :/\: unit_interval_left_half.
          exact (binintersectE2 (open_ray_upper R c) unit_interval_left_half t Ht). }
        set Z0 := (open_ray_upper R c) :/\: unit_interval.
        claim HZ0: Z0 :e unit_interval_topology.
        { claim Hut: unit_interval_topology = subspace_topology R R_standard_topology unit_interval.
          { reflexivity. }
          rewrite Hut.
          prove Z0 :e {W :e Power unit_interval | exists Z :e R_standard_topology, W = Z :/\: unit_interval}.
          claim HZ0pow: Z0 :e Power unit_interval.
          { apply PowerI.
            let t. assume Ht: t :e Z0.
            exact (binintersectE2 (open_ray_upper R c) unit_interval t Ht). }
          claim HopenR: open_ray_upper R c :e R_standard_topology.
          { rewrite <- standard_topology_is_order_topology.
            claim HcS: c :e R.
            { exact HcR. }
            claim HsRay: open_ray_upper R c :e open_rays_subbasis R.
            { exact (open_ray_upper_in_open_rays_subbasis R c HcS). }
            exact (open_rays_subbasis_sub_order_topology R (open_ray_upper R c) HsRay). }
          claim Hex: exists Z :e R_standard_topology, Z0 = Z :/\: unit_interval.
          { witness (open_ray_upper R c).
            apply andI.
            - exact HopenR.
            - reflexivity. }
          exact (SepI (Power unit_interval)
                      (fun W0 : set => exists Z :e R_standard_topology, W0 = Z :/\: unit_interval)
                      Z0 HZ0pow Hex). }
        claim Heq: (open_ray_upper R c) :/\: unit_interval_left_half = Z0 :/\: unit_interval_left_half.
        { apply set_ext.
          - let t. assume Ht: t :e (open_ray_upper R c) :/\: unit_interval_left_half.
            prove t :e Z0 :/\: unit_interval_left_half.
            claim HtRay: t :e open_ray_upper R c.
            { exact (binintersectE1 (open_ray_upper R c) unit_interval_left_half t Ht). }
            claim HtLH: t :e unit_interval_left_half.
            { exact (binintersectE2 (open_ray_upper R c) unit_interval_left_half t Ht). }
            claim HtI: t :e unit_interval.
            { exact (unit_interval_left_half_sub t HtLH). }
            claim HtZ0: t :e Z0.
            { exact (binintersectI (open_ray_upper R c) unit_interval t HtRay HtI). }
            exact (binintersectI Z0 unit_interval_left_half t HtZ0 HtLH).
          - let t. assume Ht: t :e Z0 :/\: unit_interval_left_half.
            prove t :e (open_ray_upper R c) :/\: unit_interval_left_half.
            claim HtZ0: t :e Z0.
            { exact (binintersectE1 Z0 unit_interval_left_half t Ht). }
            claim HtLH: t :e unit_interval_left_half.
            { exact (binintersectE2 Z0 unit_interval_left_half t Ht). }
            claim HtRay: t :e open_ray_upper R c.
            { exact (binintersectE1 (open_ray_upper R c) unit_interval t HtZ0). }
            exact (binintersectI (open_ray_upper R c) unit_interval_left_half t HtRay HtLH). }
        claim Hex: exists Z :e unit_interval_topology,
          (open_ray_upper R c) :/\: unit_interval_left_half = Z :/\: unit_interval_left_half.
        { witness Z0.
          apply andI.
          - exact HZ0.
          - rewrite <- Heq.
            reflexivity. }
        exact (SepI (Power unit_interval_left_half)
                    (fun W0 : set => exists Z :e unit_interval_topology, W0 = Z :/\: unit_interval_left_half)
                    ((open_ray_upper R c) :/\: unit_interval_left_half)
                    Hpow
                    Hex).
      + assume Hsl: s :e {I :e Power R | exists b :e R, I = open_ray_lower R b}.
        claim Hex: exists b :e R, s = open_ray_lower R b.
        { exact (SepE2 (Power R)
                      (fun I0 : set => exists b :e R, I0 = open_ray_lower R b)
                      s Hsl). }
        apply Hex.
        let b. assume Hcore.
        apply Hcore.
        assume HbR: b :e R.
        assume Hseq: s = open_ray_lower R b.
        rewrite Hseq.

        set c := mul_SNo (eps_ 1) b.
        claim HcR: c :e R.
        { claim HdefR: R = real.
          { reflexivity. }
          rewrite HdefR.
          claim HbReal: b :e real.
          { rewrite <- HdefR.
            exact HbR. }
          claim He1Real: (eps_ 1) :e real.
          { rewrite <- HdefR.
            exact eps_1_in_R. }
          exact (real_mul_SNo (eps_ 1) He1Real b HbReal). }

        claim HpreEq: preimage_of unit_interval_left_half double_map_left_half (open_ray_lower R b)
                      = (open_ray_lower R c) :/\: unit_interval_left_half.
        { apply set_ext.
          - let t. assume Ht: t :e preimage_of unit_interval_left_half double_map_left_half (open_ray_lower R b).
            prove t :e (open_ray_lower R c) :/\: unit_interval_left_half.
            claim HtLH: t :e unit_interval_left_half.
            { exact (SepE1 unit_interval_left_half
                         (fun u : set => apply_fun double_map_left_half u :e open_ray_lower R b) t Ht). }
            claim HtI: t :e unit_interval.
            { exact (unit_interval_left_half_sub t HtLH). }
            claim HtR: t :e R.
            { exact (unit_interval_sub_R t HtI). }
            claim Himg: apply_fun double_map_left_half t :e open_ray_lower R b.
            { exact (SepE2 unit_interval_left_half
                         (fun u : set => apply_fun double_map_left_half u :e open_ray_lower R b) t Ht). }
            claim Hrel: order_rel R (apply_fun double_map_left_half t) b.
            { exact (SepE2 R (fun x0 : set => order_rel R x0 b) (apply_fun double_map_left_half t) Himg). }
            claim Hrlt: Rlt (apply_fun double_map_left_half t) b.
            { exact (order_rel_R_implies_Rlt (apply_fun double_map_left_half t) b Hrel). }
            claim Hrlt2: Rlt (mul_SNo 2 t) b.
            { rewrite <- (double_map_apply t HtLH) at 1.
              exact Hrlt. }
            claim Hrltc: Rlt t c.
            { exact (iffEL (Rlt (mul_SNo 2 t) b) (Rlt t (mul_SNo (eps_ 1) b))
                          (Rlt_mul2_right_iff t b HtR HbR) Hrlt2). }
            claim HcRel: order_rel R t c.
            { exact (Rlt_implies_order_rel_R t c Hrltc). }
            claim HtRay: t :e open_ray_lower R c.
            { exact (SepI R (fun x0 : set => order_rel R x0 c) t HtR HcRel). }
            exact (binintersectI (open_ray_lower R c) unit_interval_left_half t HtRay HtLH).
          - let t. assume Ht: t :e (open_ray_lower R c) :/\: unit_interval_left_half.
            prove t :e preimage_of unit_interval_left_half double_map_left_half (open_ray_lower R b).
            claim HtRay: t :e open_ray_lower R c.
            { exact (binintersectE1 (open_ray_lower R c) unit_interval_left_half t Ht). }
            claim HtLH: t :e unit_interval_left_half.
            { exact (binintersectE2 (open_ray_lower R c) unit_interval_left_half t Ht). }
            claim HtI: t :e unit_interval.
            { exact (unit_interval_left_half_sub t HtLH). }
            claim HtR: t :e R.
            { exact (unit_interval_sub_R t HtI). }
            claim Hrel: order_rel R t c.
            { exact (SepE2 R (fun x0 : set => order_rel R x0 c) t HtRay). }
            claim Hrlt: Rlt t c.
            { exact (order_rel_R_implies_Rlt t c Hrel). }
            claim Hrlt2: Rlt (mul_SNo 2 t) b.
            { exact (iffER (Rlt (mul_SNo 2 t) b) (Rlt t (mul_SNo (eps_ 1) b))
                          (Rlt_mul2_right_iff t b HtR HbR) Hrlt). }
            claim Hrlt3: Rlt (apply_fun double_map_left_half t) b.
            { rewrite (double_map_apply t HtLH) at 1.
              exact Hrlt2. }
            claim Hrel2: order_rel R (apply_fun double_map_left_half t) b.
            { exact (Rlt_implies_order_rel_R (apply_fun double_map_left_half t) b Hrlt3). }
            claim HimgR: apply_fun double_map_left_half t :e R.
            { exact (Hfun t HtLH). }
            claim Himg: apply_fun double_map_left_half t :e open_ray_lower R b.
            { exact (SepI R (fun x0 : set => order_rel R x0 b)
                          (apply_fun double_map_left_half t) HimgR Hrel2). }
            exact (SepI unit_interval_left_half
                        (fun u : set => apply_fun double_map_left_half u :e open_ray_lower R b)
                        t HtLH Himg). }

        rewrite HpreEq.
        prove (open_ray_lower R c) :/\: unit_interval_left_half :e Tx.
        prove (open_ray_lower R c) :/\: unit_interval_left_half :e
             {W :e Power unit_interval_left_half | exists Z :e unit_interval_topology,
                  W = Z :/\: unit_interval_left_half}.
        claim Hpow: (open_ray_lower R c) :/\: unit_interval_left_half :e Power unit_interval_left_half.
        { apply PowerI.
          let t. assume Ht: t :e (open_ray_lower R c) :/\: unit_interval_left_half.
          exact (binintersectE2 (open_ray_lower R c) unit_interval_left_half t Ht). }
        set Z0 := (open_ray_lower R c) :/\: unit_interval.
        claim HZ0: Z0 :e unit_interval_topology.
        { claim Hut: unit_interval_topology = subspace_topology R R_standard_topology unit_interval.
          { reflexivity. }
          rewrite Hut.
          prove Z0 :e {W :e Power unit_interval | exists Z :e R_standard_topology, W = Z :/\: unit_interval}.
          claim HZ0pow: Z0 :e Power unit_interval.
          { apply PowerI.
            let t. assume Ht: t :e Z0.
            exact (binintersectE2 (open_ray_lower R c) unit_interval t Ht). }
          claim HopenR: open_ray_lower R c :e R_standard_topology.
          { rewrite <- standard_topology_is_order_topology.
            claim HcS: c :e R.
            { exact HcR. }
            claim HsRay: open_ray_lower R c :e open_rays_subbasis R.
            { exact (open_ray_lower_in_open_rays_subbasis R c HcS). }
            exact (open_rays_subbasis_sub_order_topology R (open_ray_lower R c) HsRay). }
          claim Hex: exists Z :e R_standard_topology, Z0 = Z :/\: unit_interval.
          { witness (open_ray_lower R c).
            apply andI.
            - exact HopenR.
            - reflexivity. }
          exact (SepI (Power unit_interval)
                      (fun W0 : set => exists Z :e R_standard_topology, W0 = Z :/\: unit_interval)
                      Z0 HZ0pow Hex). }
        claim Heq: (open_ray_lower R c) :/\: unit_interval_left_half = Z0 :/\: unit_interval_left_half.
        { apply set_ext.
          - let t. assume Ht: t :e (open_ray_lower R c) :/\: unit_interval_left_half.
            prove t :e Z0 :/\: unit_interval_left_half.
            claim HtRay: t :e open_ray_lower R c.
            { exact (binintersectE1 (open_ray_lower R c) unit_interval_left_half t Ht). }
            claim HtLH: t :e unit_interval_left_half.
            { exact (binintersectE2 (open_ray_lower R c) unit_interval_left_half t Ht). }
            claim HtI: t :e unit_interval.
            { exact (unit_interval_left_half_sub t HtLH). }
            claim HtZ0: t :e Z0.
            { exact (binintersectI (open_ray_lower R c) unit_interval t HtRay HtI). }
            exact (binintersectI Z0 unit_interval_left_half t HtZ0 HtLH).
          - let t. assume Ht: t :e Z0 :/\: unit_interval_left_half.
            prove t :e (open_ray_lower R c) :/\: unit_interval_left_half.
            claim HtZ0: t :e Z0.
            { exact (binintersectE1 Z0 unit_interval_left_half t Ht). }
            claim HtLH: t :e unit_interval_left_half.
            { exact (binintersectE2 Z0 unit_interval_left_half t Ht). }
            claim HtRay: t :e open_ray_lower R c.
            { exact (binintersectE1 (open_ray_lower R c) unit_interval t HtZ0). }
            exact (binintersectI (open_ray_lower R c) unit_interval_left_half t HtRay HtLH). }
        claim Hex: exists Z :e unit_interval_topology,
          (open_ray_lower R c) :/\: unit_interval_left_half = Z :/\: unit_interval_left_half.
        { witness Z0.
          apply andI.
          - exact HZ0.
          - rewrite <- Heq.
            reflexivity. }
        exact (SepI (Power unit_interval_left_half)
                    (fun W0 : set => exists Z :e unit_interval_topology, W0 = Z :/\: unit_interval_left_half)
                    ((open_ray_lower R c) :/\: unit_interval_left_half)
                    Hpow
                    Hex).
      + exact Hs0.
    - assume HsR: s :e {R}.
      claim Hseq: s = R.
      { exact (SingE R s HsR). }
      rewrite Hseq.
      claim Heq: preimage_of unit_interval_left_half double_map_left_half R = unit_interval_left_half.
      { exact (preimage_of_whole unit_interval_left_half R double_map_left_half Hfun). }
      rewrite Heq.
      exact (topology_has_X unit_interval_left_half Tx HTx).
    - exact HsS. }

  exact (continuous_map_from_subbasis unit_interval_left_half Tx R S double_map_left_half
          HTx Hfun HS HpreS). }

claim Himg: forall t:set, t :e unit_interval_left_half -> apply_fun double_map_left_half t :e unit_interval.
{ let t. assume Ht: t :e unit_interval_left_half.
  exact (double_map_function_on t Ht). }

claim Hut: unit_interval_topology = subspace_topology R R_standard_topology unit_interval.
{ reflexivity. }
rewrite Hut.
exact (continuous_map_range_restrict unit_interval_left_half
        (subspace_topology unit_interval unit_interval_topology unit_interval_left_half)
        R R_standard_topology
        double_map_left_half
        unit_interval
        HcontR
        unit_interval_sub_R
        Himg).
Qed.

Theorem double_minus_one_map_continuous :
  continuous_map unit_interval_right_half
    (subspace_topology unit_interval unit_interval_topology unit_interval_right_half)
    unit_interval unit_interval_topology
    double_minus_one_map_right_half.
prove continuous_map unit_interval_right_half
        (subspace_topology unit_interval unit_interval_topology unit_interval_right_half)
        unit_interval unit_interval_topology
        double_minus_one_map_right_half.
(** range restriction: factor through R, then restrict codomain to unit_interval **)
claim HcontR: continuous_map unit_interval_right_half
  (subspace_topology unit_interval unit_interval_topology unit_interval_right_half)
  R R_standard_topology
  double_minus_one_map_right_half.
{ set Tx := subspace_topology unit_interval unit_interval_topology unit_interval_right_half.
  set S := open_rays_subbasis R.

  claim HTui: topology_on unit_interval unit_interval_topology.
  { exact unit_interval_topology_on. }
  claim HTx: topology_on unit_interval_right_half Tx.
  { exact (subspace_topology_is_topology unit_interval unit_interval_topology unit_interval_right_half
           HTui
           unit_interval_right_half_sub). }

  claim HS: subbasis_on R S.
  { exact (open_rays_subbasis_is_subbasis R). }

  claim Hfun: function_on double_minus_one_map_right_half unit_interval_right_half R.
  { let t. assume Ht: t :e unit_interval_right_half.
    prove apply_fun double_minus_one_map_right_half t :e R.
    claim HtI: t :e unit_interval.
    { exact (unit_interval_right_half_sub t Ht). }
    claim HtR: t :e R.
    { exact (unit_interval_sub_R t HtI). }
    claim H2R: 2 :e R.
    { exact real_2. }
    claim Hm1R: (minus_SNo 1) :e R.
    { claim HdefR: R = real.
      { reflexivity. }
      rewrite HdefR.
      exact (real_minus_SNo 1 real_1). }
    claim HmulR: mul_SNo 2 t :e R.
    { claim HdefR: R = real.
      { reflexivity. }
      rewrite HdefR.
      claim H2Real: 2 :e real.
      { rewrite <- HdefR.
        exact H2R. }
      claim HtReal: t :e real.
      { rewrite <- HdefR.
        exact HtR. }
      exact (real_mul_SNo 2 H2Real t HtReal). }
    claim HaddR: add_SNo (mul_SNo 2 t) (minus_SNo 1) :e R.
    { claim HdefR: R = real.
      { reflexivity. }
      rewrite HdefR.
      claim HmulReal: mul_SNo 2 t :e real.
      { rewrite <- HdefR.
        exact HmulR. }
      claim Hm1Real: (minus_SNo 1) :e real.
      { rewrite <- HdefR.
        exact Hm1R. }
      exact (real_add_SNo (mul_SNo 2 t) HmulReal (minus_SNo 1) Hm1Real). }
    rewrite (double_minus_one_map_apply t Ht).
    exact HaddR. }

  claim Hgen: generated_topology_from_subbasis R S = R_standard_topology.
  { rewrite (open_rays_subbasis_for_order_topology R).
    rewrite standard_topology_is_order_topology.
    reflexivity. }
  rewrite <- Hgen.

  claim Haddm1L: forall a x:set,
    a :e R -> x :e R -> (Rlt a (add_SNo x (minus_SNo 1)) <-> Rlt (add_SNo a 1) x).
  { let a x.
    assume HaR: a :e R.
    assume HxR: x :e R.
    prove (Rlt a (add_SNo x (minus_SNo 1)) <-> Rlt (add_SNo a 1) x).
    apply iffI.
    - assume Hlt: Rlt a (add_SNo x (minus_SNo 1)).
      prove Rlt (add_SNo a 1) x.
      claim HaS: SNo a.
      { exact (real_SNo a HaR). }
      claim HxS: SNo x.
      { exact (real_SNo x HxR). }
      claim Hm1S: SNo (minus_SNo 1).
      { exact (SNo_minus_SNo 1 SNo_1). }
      claim Hx_m1S: SNo (add_SNo x (minus_SNo 1)).
      { exact (SNo_add_SNo x (minus_SNo 1) HxS Hm1S). }
      claim HltS: a < add_SNo x (minus_SNo 1).
      { exact (RltE_lt a (add_SNo x (minus_SNo 1)) Hlt). }
      claim Hstep: add_SNo a 1 < add_SNo (add_SNo x (minus_SNo 1)) 1.
      { exact (add_SNo_Lt1 a 1 (add_SNo x (minus_SNo 1)) HaS SNo_1 Hx_m1S HltS). }
      claim Heq: add_SNo (add_SNo x (minus_SNo 1)) 1 = x.
      { rewrite <- (add_SNo_assoc x (minus_SNo 1) 1 HxS Hm1S SNo_1).
        rewrite (add_SNo_minus_SNo_linv 1 SNo_1).
        exact (add_SNo_0R x HxS). }
      claim Hstep2: add_SNo a 1 < x.
      { rewrite <- Heq.
        exact Hstep. }
      claim Ha1R: add_SNo a 1 :e R.
      { claim HdefR: R = real.
        { reflexivity. }
        rewrite HdefR.
        claim HaReal: a :e real.
        { rewrite <- HdefR.
          exact HaR. }
        exact (real_add_SNo a HaReal 1 real_1). }
      exact (RltI (add_SNo a 1) x Ha1R HxR Hstep2).
    - assume Hlt: Rlt (add_SNo a 1) x.
      prove Rlt a (add_SNo x (minus_SNo 1)).
      claim HaS: SNo a.
      { exact (real_SNo a HaR). }
      claim HxS: SNo x.
      { exact (real_SNo x HxR). }
      claim Hm1S: SNo (minus_SNo 1).
      { exact (SNo_minus_SNo 1 SNo_1). }
      claim Ha1S: SNo (add_SNo a 1).
      { exact (SNo_add_SNo a 1 HaS SNo_1). }
      claim HltS: add_SNo a 1 < x.
      { exact (RltE_lt (add_SNo a 1) x Hlt). }
      claim Hstep: add_SNo (add_SNo a 1) (minus_SNo 1) < add_SNo x (minus_SNo 1).
      { exact (add_SNo_Lt1 (add_SNo a 1) (minus_SNo 1) x Ha1S Hm1S HxS HltS). }
      claim Heq: add_SNo (add_SNo a 1) (minus_SNo 1) = a.
      { rewrite <- (add_SNo_assoc a 1 (minus_SNo 1) HaS SNo_1 Hm1S).
        rewrite (add_SNo_minus_SNo_rinv 1 SNo_1).
        exact (add_SNo_0R a HaS). }
      claim Hstep2: a < add_SNo x (minus_SNo 1).
      { rewrite <- Heq at 1.
        exact Hstep. }
      claim Hx_m1R: add_SNo x (minus_SNo 1) :e R.
      { claim HdefR: R = real.
        { reflexivity. }
        rewrite HdefR.
        claim HxReal: x :e real.
        { rewrite <- HdefR.
          exact HxR. }
        exact (real_add_SNo x HxReal (minus_SNo 1) (real_minus_SNo 1 real_1)). }
      exact (RltI a (add_SNo x (minus_SNo 1)) HaR Hx_m1R Hstep2). }

  claim Haddm1R: forall x b:set,
    x :e R -> b :e R -> (Rlt (add_SNo x (minus_SNo 1)) b <-> Rlt x (add_SNo b 1)).
  { let x b.
    assume HxR: x :e R.
    assume HbR: b :e R.
    prove (Rlt (add_SNo x (minus_SNo 1)) b <-> Rlt x (add_SNo b 1)).
    apply iffI.
    - assume Hlt: Rlt (add_SNo x (minus_SNo 1)) b.
      prove Rlt x (add_SNo b 1).
      claim HxS: SNo x.
      { exact (real_SNo x HxR). }
      claim HbS: SNo b.
      { exact (real_SNo b HbR). }
      claim Hm1S: SNo (minus_SNo 1).
      { exact (SNo_minus_SNo 1 SNo_1). }
      claim Hx_m1S: SNo (add_SNo x (minus_SNo 1)).
      { exact (SNo_add_SNo x (minus_SNo 1) HxS Hm1S). }
      claim HltS: add_SNo x (minus_SNo 1) < b.
      { exact (RltE_lt (add_SNo x (minus_SNo 1)) b Hlt). }
      claim Hstep: add_SNo (add_SNo x (minus_SNo 1)) 1 < add_SNo b 1.
      { exact (add_SNo_Lt1 (add_SNo x (minus_SNo 1)) 1 b Hx_m1S SNo_1 HbS HltS). }
      claim Heq: add_SNo (add_SNo x (minus_SNo 1)) 1 = x.
      { rewrite <- (add_SNo_assoc x (minus_SNo 1) 1 HxS Hm1S SNo_1).
        rewrite (add_SNo_minus_SNo_linv 1 SNo_1).
        exact (add_SNo_0R x HxS). }
      claim Hstep2: x < add_SNo b 1.
      { rewrite <- Heq at 1.
        exact Hstep. }
      claim Hb1R: add_SNo b 1 :e R.
      { claim HdefR: R = real.
        { reflexivity. }
        rewrite HdefR.
        claim HbReal: b :e real.
        { rewrite <- HdefR.
          exact HbR. }
        exact (real_add_SNo b HbReal 1 real_1). }
      exact (RltI x (add_SNo b 1) HxR Hb1R Hstep2).
    - assume Hlt: Rlt x (add_SNo b 1).
      prove Rlt (add_SNo x (minus_SNo 1)) b.
      claim HxS: SNo x.
      { exact (real_SNo x HxR). }
      claim HbS: SNo b.
      { exact (real_SNo b HbR). }
      claim Hm1S: SNo (minus_SNo 1).
      { exact (SNo_minus_SNo 1 SNo_1). }
      claim Hb1S: SNo (add_SNo b 1).
      { exact (SNo_add_SNo b 1 HbS SNo_1). }
      claim HltS: x < add_SNo b 1.
      { exact (RltE_lt x (add_SNo b 1) Hlt). }
      claim Hstep: add_SNo x (minus_SNo 1) < add_SNo (add_SNo b 1) (minus_SNo 1).
      { exact (add_SNo_Lt1 x (minus_SNo 1) (add_SNo b 1) HxS Hm1S Hb1S HltS). }
      claim Heq: add_SNo (add_SNo b 1) (minus_SNo 1) = b.
      { rewrite <- (add_SNo_assoc b 1 (minus_SNo 1) HbS SNo_1 Hm1S).
        rewrite (add_SNo_minus_SNo_rinv 1 SNo_1).
        exact (add_SNo_0R b HbS). }
      claim Hstep2: add_SNo x (minus_SNo 1) < b.
      { rewrite <- Heq.
        exact Hstep. }
      claim Hx_m1R: add_SNo x (minus_SNo 1) :e R.
      { claim HdefR: R = real.
        { reflexivity. }
        rewrite HdefR.
        claim HxReal: x :e real.
        { rewrite <- HdefR.
          exact HxR. }
        exact (real_add_SNo x HxReal (minus_SNo 1) (real_minus_SNo 1 real_1)). }
      exact (RltI (add_SNo x (minus_SNo 1)) b Hx_m1R HbR Hstep2). }

  claim HpreS: forall s:set, s :e S -> preimage_of unit_interval_right_half double_minus_one_map_right_half s :e Tx.
  { let s. assume HsS: s :e S.
    prove preimage_of unit_interval_right_half double_minus_one_map_right_half s :e Tx.
    apply (binunionE' ({I :e Power R | exists a :e R, I = open_ray_upper R a}
                       :\/:
                       {I :e Power R | exists b :e R, I = open_ray_lower R b})
                      {R}
                      s
                      (preimage_of unit_interval_right_half double_minus_one_map_right_half s :e Tx)).
    - assume Hs0: s :e ({I :e Power R | exists a :e R, I = open_ray_upper R a}
                        :\/:
                        {I :e Power R | exists b :e R, I = open_ray_lower R b}).
      apply (binunionE' {I :e Power R | exists a :e R, I = open_ray_upper R a}
                        {I :e Power R | exists b :e R, I = open_ray_lower R b}
                        s
                        (preimage_of unit_interval_right_half double_minus_one_map_right_half s :e Tx)).
      + assume Hsu: s :e {I :e Power R | exists a :e R, I = open_ray_upper R a}.
        claim Hex: exists a :e R, s = open_ray_upper R a.
        { exact (SepE2 (Power R)
                      (fun I0 : set => exists a :e R, I0 = open_ray_upper R a)
                      s Hsu). }
        apply Hex.
        let a. assume Hcore.
        apply Hcore.
        assume HaR: a :e R.
        assume Hseq: s = open_ray_upper R a.
        rewrite Hseq.

        set d := add_SNo a 1.
        set c := mul_SNo (eps_ 1) d.

        claim HdR: d :e R.
        { claim HdefR: R = real.
          { reflexivity. }
          rewrite HdefR.
          claim HaReal: a :e real.
          { rewrite <- HdefR.
            exact HaR. }
          exact (real_add_SNo a HaReal 1 real_1). }
        claim HcR: c :e R.
        { claim HdefR: R = real.
          { reflexivity. }
          rewrite HdefR.
          claim HdReal: d :e real.
          { rewrite <- HdefR.
            exact HdR. }
          exact (real_mul_SNo (eps_ 1) eps_1_in_R d HdReal). }

        claim HpreEq: preimage_of unit_interval_right_half double_minus_one_map_right_half (open_ray_upper R a)
                      = (open_ray_upper R c) :/\: unit_interval_right_half.
        { apply set_ext.
          - let t. assume Ht: t :e preimage_of unit_interval_right_half double_minus_one_map_right_half (open_ray_upper R a).
            prove t :e (open_ray_upper R c) :/\: unit_interval_right_half.
            claim HtRH: t :e unit_interval_right_half.
            { exact (SepE1 unit_interval_right_half
                         (fun u : set => apply_fun double_minus_one_map_right_half u :e open_ray_upper R a) t Ht). }
            claim HtI: t :e unit_interval.
            { exact (unit_interval_right_half_sub t HtRH). }
            claim HtR: t :e R.
            { exact (unit_interval_sub_R t HtI). }
            claim Himg: apply_fun double_minus_one_map_right_half t :e open_ray_upper R a.
            { exact (SepE2 unit_interval_right_half
                         (fun u : set => apply_fun double_minus_one_map_right_half u :e open_ray_upper R a) t Ht). }
            claim Hrel: order_rel R a (apply_fun double_minus_one_map_right_half t).
            { exact (SepE2 R (fun x0 : set => order_rel R a x0) (apply_fun double_minus_one_map_right_half t) Himg). }
            claim Hrlt: Rlt a (apply_fun double_minus_one_map_right_half t).
            { exact (order_rel_R_implies_Rlt a (apply_fun double_minus_one_map_right_half t) Hrel). }
            claim Hrlt2: Rlt a (add_SNo (mul_SNo 2 t) (minus_SNo 1)).
            { rewrite <- (double_minus_one_map_apply t HtRH).
              exact Hrlt. }
            claim H2tR: mul_SNo 2 t :e R.
            { claim HdefR: R = real.
              { reflexivity. }
              rewrite HdefR.
              claim H2Real: 2 :e real.
              { rewrite <- HdefR.
                exact real_2. }
              claim HtReal: t :e real.
              { rewrite <- HdefR.
                exact HtR. }
              exact (real_mul_SNo 2 H2Real t HtReal). }
            claim Hrlt3: Rlt d (mul_SNo 2 t).
            { exact (iffEL (Rlt a (add_SNo (mul_SNo 2 t) (minus_SNo 1))) (Rlt (add_SNo a 1) (mul_SNo 2 t))
                          (Haddm1L a (mul_SNo 2 t) HaR H2tR) Hrlt2). }
            claim Hrlt4: Rlt c t.
            { exact (iffEL (Rlt d (mul_SNo 2 t)) (Rlt (mul_SNo (eps_ 1) d) t)
                          (Rlt_mul2_left_iff d t HdR HtR) Hrlt3). }
            claim HcRel: order_rel R c t.
            { exact (Rlt_implies_order_rel_R c t Hrlt4). }
            claim HtRay: t :e open_ray_upper R c.
            { exact (SepI R (fun x0 : set => order_rel R c x0) t HtR HcRel). }
            exact (binintersectI (open_ray_upper R c) unit_interval_right_half t HtRay HtRH).
          - let t. assume Ht: t :e (open_ray_upper R c) :/\: unit_interval_right_half.
            prove t :e preimage_of unit_interval_right_half double_minus_one_map_right_half (open_ray_upper R a).
            claim HtRay: t :e open_ray_upper R c.
            { exact (binintersectE1 (open_ray_upper R c) unit_interval_right_half t Ht). }
            claim HtRH: t :e unit_interval_right_half.
            { exact (binintersectE2 (open_ray_upper R c) unit_interval_right_half t Ht). }
            claim HtI: t :e unit_interval.
            { exact (unit_interval_right_half_sub t HtRH). }
            claim HtR: t :e R.
            { exact (unit_interval_sub_R t HtI). }
            claim Hrel: order_rel R c t.
            { exact (SepE2 R (fun x0 : set => order_rel R c x0) t HtRay). }
            claim Hrlt: Rlt c t.
            { exact (order_rel_R_implies_Rlt c t Hrel). }
            claim Hrlt2: Rlt d (mul_SNo 2 t).
            { exact (iffER (Rlt d (mul_SNo 2 t)) (Rlt (mul_SNo (eps_ 1) d) t)
                          (Rlt_mul2_left_iff d t HdR HtR) Hrlt). }
            claim H2tR: mul_SNo 2 t :e R.
            { claim HdefR: R = real.
              { reflexivity. }
              rewrite HdefR.
              claim H2Real: 2 :e real.
              { rewrite <- HdefR.
                exact real_2. }
              claim HtReal: t :e real.
              { rewrite <- HdefR.
                exact HtR. }
              exact (real_mul_SNo 2 H2Real t HtReal). }
            claim Hrlt3: Rlt a (add_SNo (mul_SNo 2 t) (minus_SNo 1)).
            { exact (iffER (Rlt a (add_SNo (mul_SNo 2 t) (minus_SNo 1))) (Rlt (add_SNo a 1) (mul_SNo 2 t))
                          (Haddm1L a (mul_SNo 2 t) HaR H2tR) Hrlt2). }
            claim Hrlt4: Rlt a (apply_fun double_minus_one_map_right_half t).
            { rewrite (double_minus_one_map_apply t HtRH).
              exact Hrlt3. }
            claim Hrel2: order_rel R a (apply_fun double_minus_one_map_right_half t).
            { exact (Rlt_implies_order_rel_R a (apply_fun double_minus_one_map_right_half t) Hrlt4). }
            claim HimgR: apply_fun double_minus_one_map_right_half t :e R.
            { exact (Hfun t HtRH). }
            claim Himg: apply_fun double_minus_one_map_right_half t :e open_ray_upper R a.
            { exact (SepI R (fun x0 : set => order_rel R a x0)
                          (apply_fun double_minus_one_map_right_half t) HimgR Hrel2). }
            exact (SepI unit_interval_right_half
                        (fun u : set => apply_fun double_minus_one_map_right_half u :e open_ray_upper R a)
                        t HtRH Himg). }

        rewrite HpreEq.
        prove (open_ray_upper R c) :/\: unit_interval_right_half :e Tx.
        prove (open_ray_upper R c) :/\: unit_interval_right_half :e
             {W :e Power unit_interval_right_half | exists Z :e unit_interval_topology,
                  W = Z :/\: unit_interval_right_half}.
        claim Hpow: (open_ray_upper R c) :/\: unit_interval_right_half :e Power unit_interval_right_half.
        { apply PowerI.
          let t. assume Ht: t :e (open_ray_upper R c) :/\: unit_interval_right_half.
          exact (binintersectE2 (open_ray_upper R c) unit_interval_right_half t Ht). }
        set Z0 := (open_ray_upper R c) :/\: unit_interval.
        claim HZ0: Z0 :e unit_interval_topology.
        { claim Hut: unit_interval_topology = subspace_topology R R_standard_topology unit_interval.
          { reflexivity. }
          rewrite Hut.
          prove Z0 :e {W :e Power unit_interval | exists Z :e R_standard_topology, W = Z :/\: unit_interval}.
          claim HZ0pow: Z0 :e Power unit_interval.
          { apply PowerI.
            let t. assume Ht: t :e Z0.
            exact (binintersectE2 (open_ray_upper R c) unit_interval t Ht). }
          claim HopenR: open_ray_upper R c :e R_standard_topology.
          { rewrite <- standard_topology_is_order_topology.
            claim HsRay: open_ray_upper R c :e open_rays_subbasis R.
            { exact (open_ray_upper_in_open_rays_subbasis R c HcR). }
            exact (open_rays_subbasis_sub_order_topology R (open_ray_upper R c) HsRay). }
          claim Hex: exists Z :e R_standard_topology, Z0 = Z :/\: unit_interval.
          { witness (open_ray_upper R c).
            apply andI.
            - exact HopenR.
            - reflexivity. }
          exact (SepI (Power unit_interval)
                      (fun W0 : set => exists Z :e R_standard_topology, W0 = Z :/\: unit_interval)
                      Z0 HZ0pow Hex). }
        claim Heq: (open_ray_upper R c) :/\: unit_interval_right_half = Z0 :/\: unit_interval_right_half.
        { apply set_ext.
          - let t. assume Ht: t :e (open_ray_upper R c) :/\: unit_interval_right_half.
            prove t :e Z0 :/\: unit_interval_right_half.
            claim HtRay: t :e open_ray_upper R c.
            { exact (binintersectE1 (open_ray_upper R c) unit_interval_right_half t Ht). }
            claim HtRH: t :e unit_interval_right_half.
            { exact (binintersectE2 (open_ray_upper R c) unit_interval_right_half t Ht). }
            claim HtI: t :e unit_interval.
            { exact (unit_interval_right_half_sub t HtRH). }
            claim HtZ0: t :e Z0.
            { exact (binintersectI (open_ray_upper R c) unit_interval t HtRay HtI). }
            exact (binintersectI Z0 unit_interval_right_half t HtZ0 HtRH).
          - let t. assume Ht: t :e Z0 :/\: unit_interval_right_half.
            prove t :e (open_ray_upper R c) :/\: unit_interval_right_half.
            claim HtZ0: t :e Z0.
            { exact (binintersectE1 Z0 unit_interval_right_half t Ht). }
            claim HtRH: t :e unit_interval_right_half.
            { exact (binintersectE2 Z0 unit_interval_right_half t Ht). }
            claim HtRay: t :e open_ray_upper R c.
            { exact (binintersectE1 (open_ray_upper R c) unit_interval t HtZ0). }
            exact (binintersectI (open_ray_upper R c) unit_interval_right_half t HtRay HtRH). }
        claim Hex: exists Z :e unit_interval_topology,
          (open_ray_upper R c) :/\: unit_interval_right_half = Z :/\: unit_interval_right_half.
        { witness Z0.
          apply andI.
          - exact HZ0.
          - rewrite <- Heq.
            reflexivity. }
        exact (SepI (Power unit_interval_right_half)
                    (fun W0 : set => exists Z :e unit_interval_topology, W0 = Z :/\: unit_interval_right_half)
                    ((open_ray_upper R c) :/\: unit_interval_right_half)
                    Hpow
                    Hex).
      + assume Hsl: s :e {I :e Power R | exists b :e R, I = open_ray_lower R b}.
        claim Hex: exists b :e R, s = open_ray_lower R b.
        { exact (SepE2 (Power R)
                      (fun I0 : set => exists b :e R, I0 = open_ray_lower R b)
                      s Hsl). }
        apply Hex.
        let b. assume Hcore.
        apply Hcore.
        assume HbR: b :e R.
        assume Hseq: s = open_ray_lower R b.
        rewrite Hseq.

        set d := add_SNo b 1.
        set c := mul_SNo (eps_ 1) d.

        claim HdR: d :e R.
        { claim HdefR: R = real.
          { reflexivity. }
          rewrite HdefR.
          claim HbReal: b :e real.
          { rewrite <- HdefR.
            exact HbR. }
          exact (real_add_SNo b HbReal 1 real_1). }
        claim HcR: c :e R.
        { claim HdefR: R = real.
          { reflexivity. }
          rewrite HdefR.
          claim HdReal: d :e real.
          { rewrite <- HdefR.
            exact HdR. }
          exact (real_mul_SNo (eps_ 1) eps_1_in_R d HdReal). }

        claim HpreEq: preimage_of unit_interval_right_half double_minus_one_map_right_half (open_ray_lower R b)
                      = (open_ray_lower R c) :/\: unit_interval_right_half.
        { apply set_ext.
          - let t. assume Ht: t :e preimage_of unit_interval_right_half double_minus_one_map_right_half (open_ray_lower R b).
            prove t :e (open_ray_lower R c) :/\: unit_interval_right_half.
            claim HtRH: t :e unit_interval_right_half.
            { exact (SepE1 unit_interval_right_half
                         (fun u : set => apply_fun double_minus_one_map_right_half u :e open_ray_lower R b) t Ht). }
            claim HtI: t :e unit_interval.
            { exact (unit_interval_right_half_sub t HtRH). }
            claim HtR: t :e R.
            { exact (unit_interval_sub_R t HtI). }
            claim Himg: apply_fun double_minus_one_map_right_half t :e open_ray_lower R b.
            { exact (SepE2 unit_interval_right_half
                         (fun u : set => apply_fun double_minus_one_map_right_half u :e open_ray_lower R b) t Ht). }
            claim Hrel: order_rel R (apply_fun double_minus_one_map_right_half t) b.
            { exact (SepE2 R (fun x0 : set => order_rel R x0 b) (apply_fun double_minus_one_map_right_half t) Himg). }
            claim Hrlt: Rlt (apply_fun double_minus_one_map_right_half t) b.
            { exact (order_rel_R_implies_Rlt (apply_fun double_minus_one_map_right_half t) b Hrel). }
            claim Hrlt2: Rlt (add_SNo (mul_SNo 2 t) (minus_SNo 1)) b.
            { rewrite <- (double_minus_one_map_apply t HtRH).
              exact Hrlt. }
            claim H2tR: mul_SNo 2 t :e R.
            { claim HdefR: R = real.
              { reflexivity. }
              rewrite HdefR.
              claim H2Real: 2 :e real.
              { rewrite <- HdefR.
                exact real_2. }
              claim HtReal: t :e real.
              { rewrite <- HdefR.
                exact HtR. }
              exact (real_mul_SNo 2 H2Real t HtReal). }
            claim Hrlt3: Rlt (mul_SNo 2 t) d.
            { exact (iffEL (Rlt (add_SNo (mul_SNo 2 t) (minus_SNo 1)) b) (Rlt (mul_SNo 2 t) (add_SNo b 1))
                          (Haddm1R (mul_SNo 2 t) b H2tR HbR) Hrlt2). }
            claim Hrlt4: Rlt t c.
            { exact (iffEL (Rlt (mul_SNo 2 t) d) (Rlt t (mul_SNo (eps_ 1) d))
                          (Rlt_mul2_right_iff t d HtR HdR) Hrlt3). }
            claim HcRel: order_rel R t c.
            { exact (Rlt_implies_order_rel_R t c Hrlt4). }
            claim HtRay: t :e open_ray_lower R c.
            { exact (SepI R (fun x0 : set => order_rel R x0 c) t HtR HcRel). }
            exact (binintersectI (open_ray_lower R c) unit_interval_right_half t HtRay HtRH).
          - let t. assume Ht: t :e (open_ray_lower R c) :/\: unit_interval_right_half.
            prove t :e preimage_of unit_interval_right_half double_minus_one_map_right_half (open_ray_lower R b).
            claim HtRay: t :e open_ray_lower R c.
            { exact (binintersectE1 (open_ray_lower R c) unit_interval_right_half t Ht). }
            claim HtRH: t :e unit_interval_right_half.
            { exact (binintersectE2 (open_ray_lower R c) unit_interval_right_half t Ht). }
            claim HtI: t :e unit_interval.
            { exact (unit_interval_right_half_sub t HtRH). }
            claim HtR: t :e R.
            { exact (unit_interval_sub_R t HtI). }
            claim Hrel: order_rel R t c.
            { exact (SepE2 R (fun x0 : set => order_rel R x0 c) t HtRay). }
            claim Hrlt: Rlt t c.
            { exact (order_rel_R_implies_Rlt t c Hrel). }
            claim Hrlt2: Rlt (mul_SNo 2 t) d.
            { exact (iffER (Rlt (mul_SNo 2 t) d) (Rlt t (mul_SNo (eps_ 1) d))
                          (Rlt_mul2_right_iff t d HtR HdR) Hrlt). }
            claim H2tR: mul_SNo 2 t :e R.
            { claim HdefR: R = real.
              { reflexivity. }
              rewrite HdefR.
              claim H2Real: 2 :e real.
              { rewrite <- HdefR.
                exact real_2. }
              claim HtReal: t :e real.
              { rewrite <- HdefR.
                exact HtR. }
              exact (real_mul_SNo 2 H2Real t HtReal). }
            claim Hrlt3: Rlt (add_SNo (mul_SNo 2 t) (minus_SNo 1)) b.
            { exact (iffER (Rlt (add_SNo (mul_SNo 2 t) (minus_SNo 1)) b) (Rlt (mul_SNo 2 t) (add_SNo b 1))
                          (Haddm1R (mul_SNo 2 t) b H2tR HbR) Hrlt2). }
            claim Hrlt4: Rlt (apply_fun double_minus_one_map_right_half t) b.
            { rewrite (double_minus_one_map_apply t HtRH).
              exact Hrlt3. }
            claim Hrel2: order_rel R (apply_fun double_minus_one_map_right_half t) b.
            { exact (Rlt_implies_order_rel_R (apply_fun double_minus_one_map_right_half t) b Hrlt4). }
            claim HimgR: apply_fun double_minus_one_map_right_half t :e R.
            { exact (Hfun t HtRH). }
            claim Himg: apply_fun double_minus_one_map_right_half t :e open_ray_lower R b.
            { exact (SepI R (fun x0 : set => order_rel R x0 b)
                          (apply_fun double_minus_one_map_right_half t) HimgR Hrel2). }
            exact (SepI unit_interval_right_half
                        (fun u : set => apply_fun double_minus_one_map_right_half u :e open_ray_lower R b)
                        t HtRH Himg). }

        rewrite HpreEq.
        prove (open_ray_lower R c) :/\: unit_interval_right_half :e Tx.
        prove (open_ray_lower R c) :/\: unit_interval_right_half :e
             {W :e Power unit_interval_right_half | exists Z :e unit_interval_topology,
                  W = Z :/\: unit_interval_right_half}.
        claim Hpow: (open_ray_lower R c) :/\: unit_interval_right_half :e Power unit_interval_right_half.
        { apply PowerI.
          let t. assume Ht: t :e (open_ray_lower R c) :/\: unit_interval_right_half.
          exact (binintersectE2 (open_ray_lower R c) unit_interval_right_half t Ht). }
        set Z0 := (open_ray_lower R c) :/\: unit_interval.
        claim HZ0: Z0 :e unit_interval_topology.
        { claim Hut: unit_interval_topology = subspace_topology R R_standard_topology unit_interval.
          { reflexivity. }
          rewrite Hut.
          prove Z0 :e {W :e Power unit_interval | exists Z :e R_standard_topology, W = Z :/\: unit_interval}.
          claim HZ0pow: Z0 :e Power unit_interval.
          { apply PowerI.
            let t. assume Ht: t :e Z0.
            exact (binintersectE2 (open_ray_lower R c) unit_interval t Ht). }
          claim HopenR: open_ray_lower R c :e R_standard_topology.
          { rewrite <- standard_topology_is_order_topology.
            claim HsRay: open_ray_lower R c :e open_rays_subbasis R.
            { exact (open_ray_lower_in_open_rays_subbasis R c HcR). }
            exact (open_rays_subbasis_sub_order_topology R (open_ray_lower R c) HsRay). }
          claim Hex: exists Z :e R_standard_topology, Z0 = Z :/\: unit_interval.
          { witness (open_ray_lower R c).
            apply andI.
            - exact HopenR.
            - reflexivity. }
          exact (SepI (Power unit_interval)
                      (fun W0 : set => exists Z :e R_standard_topology, W0 = Z :/\: unit_interval)
                      Z0 HZ0pow Hex). }
        claim Heq: (open_ray_lower R c) :/\: unit_interval_right_half = Z0 :/\: unit_interval_right_half.
        { apply set_ext.
          - let t. assume Ht: t :e (open_ray_lower R c) :/\: unit_interval_right_half.
            prove t :e Z0 :/\: unit_interval_right_half.
            claim HtRay: t :e open_ray_lower R c.
            { exact (binintersectE1 (open_ray_lower R c) unit_interval_right_half t Ht). }
            claim HtRH: t :e unit_interval_right_half.
            { exact (binintersectE2 (open_ray_lower R c) unit_interval_right_half t Ht). }
            claim HtI: t :e unit_interval.
            { exact (unit_interval_right_half_sub t HtRH). }
            claim HtZ0: t :e Z0.
            { exact (binintersectI (open_ray_lower R c) unit_interval t HtRay HtI). }
            exact (binintersectI Z0 unit_interval_right_half t HtZ0 HtRH).
          - let t. assume Ht: t :e Z0 :/\: unit_interval_right_half.
            prove t :e (open_ray_lower R c) :/\: unit_interval_right_half.
            claim HtZ0: t :e Z0.
            { exact (binintersectE1 Z0 unit_interval_right_half t Ht). }
            claim HtRH: t :e unit_interval_right_half.
            { exact (binintersectE2 Z0 unit_interval_right_half t Ht). }
            claim HtRay: t :e open_ray_lower R c.
            { exact (binintersectE1 (open_ray_lower R c) unit_interval t HtZ0). }
            exact (binintersectI (open_ray_lower R c) unit_interval_right_half t HtRay HtRH). }
        claim Hex: exists Z :e unit_interval_topology,
          (open_ray_lower R c) :/\: unit_interval_right_half = Z :/\: unit_interval_right_half.
        { witness Z0.
          apply andI.
          - exact HZ0.
          - rewrite <- Heq.
            reflexivity. }
        exact (SepI (Power unit_interval_right_half)
                    (fun W0 : set => exists Z :e unit_interval_topology, W0 = Z :/\: unit_interval_right_half)
                    ((open_ray_lower R c) :/\: unit_interval_right_half)
                    Hpow
                    Hex).
      + exact Hs0.
    - assume HsR: s :e {R}.
      claim Hseq: s = R.
      { exact (SingE R s HsR). }
      rewrite Hseq.
      claim Heq: preimage_of unit_interval_right_half double_minus_one_map_right_half R = unit_interval_right_half.
      { exact (preimage_of_whole unit_interval_right_half R double_minus_one_map_right_half Hfun). }
      rewrite Heq.
      exact (topology_has_X unit_interval_right_half Tx HTx).
    - exact HsS. }

  exact (continuous_map_from_subbasis unit_interval_right_half Tx R S double_minus_one_map_right_half
          HTx Hfun HS HpreS). }

claim Himg: forall t:set, t :e unit_interval_right_half -> apply_fun double_minus_one_map_right_half t :e unit_interval.
{ let t. assume Ht: t :e unit_interval_right_half.
  exact (double_minus_one_map_function_on t Ht). }

claim Hut: unit_interval_topology = subspace_topology R R_standard_topology unit_interval.
{ reflexivity. }
rewrite Hut.
exact (continuous_map_range_restrict unit_interval_right_half
        (subspace_topology unit_interval unit_interval_topology unit_interval_right_half)
        R R_standard_topology
        double_minus_one_map_right_half
        unit_interval
        HcontR
        unit_interval_sub_R
        Himg).
Qed.

Theorem path_component_transitive_axiom : forall X Tx x y z:set,
  topology_on X Tx -> x :e X -> y :e X -> z :e X ->
  y :e path_component_of X Tx x -> z :e path_component_of X Tx y ->
  z :e path_component_of X Tx x.
let X Tx x y z.
assume HTx: topology_on X Tx.
assume HxX: x :e X.
assume HyX: y :e X.
assume HzX: z :e X.
assume HyPc: y :e path_component_of X Tx x.
assume HzPc: z :e path_component_of X Tx y.
prove z :e path_component_of X Tx x.
prove z :e {y0 :e X | exists p:set,
     function_on p unit_interval X /\
     continuous_map unit_interval unit_interval_topology X Tx p /\
     apply_fun p 0 = x /\ apply_fun p 1 = y0}.
apply SepI.
- exact HzX.
- (** extract p: xy and q: yz, then concatenate **)
  claim Hex1: exists p:set,
     function_on p unit_interval X /\
     continuous_map unit_interval unit_interval_topology X Tx p /\
     apply_fun p 0 = x /\ apply_fun p 1 = y.
  { exact (SepE2 X (fun y0:set => exists p:set,
       function_on p unit_interval X /\
       continuous_map unit_interval unit_interval_topology X Tx p /\
       apply_fun p 0 = x /\ apply_fun p 1 = y0) y HyPc). }
  claim Hex2: exists q:set,
     function_on q unit_interval X /\
     continuous_map unit_interval unit_interval_topology X Tx q /\
     apply_fun q 0 = y /\ apply_fun q 1 = z.
  { exact (SepE2 X (fun y0:set => exists p:set,
       function_on p unit_interval X /\
       continuous_map unit_interval unit_interval_topology X Tx p /\
       apply_fun p 0 = y /\ apply_fun p 1 = y0) z HzPc). }
  apply Hex1.
	  let p. assume Hp.
	  apply Hex2.
	  let q. assume Hq.
	  (** concatenate p and q to obtain a path from x to z **)
	  set pf := compose_fun unit_interval_left_half double_map_left_half p.
	  set qf := compose_fun unit_interval_right_half double_minus_one_map_right_half q.

  claim Hp_fun: function_on p unit_interval X.
  { claim HpA:
      ((function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p) /\
        apply_fun p 0 = x) /\
      apply_fun p 1 = y.
    { exact Hp. }
    claim HpB: (function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p) /\
      apply_fun p 0 = x.
    { exact (andEL ((function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p) /\
                     apply_fun p 0 = x)
                   (apply_fun p 1 = y)
                   HpA). }
    claim HpC: function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p.
    { exact (andEL (function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p)
                   (apply_fun p 0 = x)
                   HpB). }
    exact (andEL (function_on p unit_interval X)
                 (continuous_map unit_interval unit_interval_topology X Tx p)
                 HpC). }

  claim Hp_cont: continuous_map unit_interval unit_interval_topology X Tx p.
  { claim HpA:
      ((function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p) /\
        apply_fun p 0 = x) /\
      apply_fun p 1 = y.
    { exact Hp. }
    claim HpB: (function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p) /\
      apply_fun p 0 = x.
    { exact (andEL ((function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p) /\
                     apply_fun p 0 = x)
                   (apply_fun p 1 = y)
                   HpA). }
    claim HpC: function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p.
    { exact (andEL (function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p)
                   (apply_fun p 0 = x)
                   HpB). }
    exact (andER (function_on p unit_interval X)
                 (continuous_map unit_interval unit_interval_topology X Tx p)
                 HpC). }

  claim Hp0: apply_fun p 0 = x.
  { claim HpA:
      ((function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p) /\
        apply_fun p 0 = x) /\
      apply_fun p 1 = y.
    { exact Hp. }
    claim HpB: (function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p) /\
      apply_fun p 0 = x.
    { exact (andEL ((function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p) /\
                     apply_fun p 0 = x)
                   (apply_fun p 1 = y)
                   HpA). }
    exact (andER (function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p)
                 (apply_fun p 0 = x)
                 HpB). }

  claim Hp1: apply_fun p 1 = y.
  { claim HpA:
      ((function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p) /\
        apply_fun p 0 = x) /\
      apply_fun p 1 = y.
    { exact Hp. }
    exact (andER ((function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p) /\
                   apply_fun p 0 = x)
                 (apply_fun p 1 = y)
                 HpA). }

  claim Hq_fun: function_on q unit_interval X.
  { claim HqA:
      ((function_on q unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx q) /\
        apply_fun q 0 = y) /\
      apply_fun q 1 = z.
    { exact Hq. }
    claim HqB: (function_on q unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx q) /\
      apply_fun q 0 = y.
    { exact (andEL ((function_on q unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx q) /\
                     apply_fun q 0 = y)
                   (apply_fun q 1 = z)
                   HqA). }
    claim HqC: function_on q unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx q.
    { exact (andEL (function_on q unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx q)
                   (apply_fun q 0 = y)
                   HqB). }
    exact (andEL (function_on q unit_interval X)
                 (continuous_map unit_interval unit_interval_topology X Tx q)
                 HqC). }

  claim Hq_cont: continuous_map unit_interval unit_interval_topology X Tx q.
  { claim HqA:
      ((function_on q unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx q) /\
        apply_fun q 0 = y) /\
      apply_fun q 1 = z.
    { exact Hq. }
    claim HqB: (function_on q unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx q) /\
      apply_fun q 0 = y.
    { exact (andEL ((function_on q unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx q) /\
                     apply_fun q 0 = y)
                   (apply_fun q 1 = z)
                   HqA). }
    claim HqC: function_on q unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx q.
    { exact (andEL (function_on q unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx q)
                   (apply_fun q 0 = y)
                   HqB). }
    exact (andER (function_on q unit_interval X)
                 (continuous_map unit_interval unit_interval_topology X Tx q)
                 HqC). }

  claim Hq0: apply_fun q 0 = y.
  { claim HqA:
      ((function_on q unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx q) /\
        apply_fun q 0 = y) /\
      apply_fun q 1 = z.
    { exact Hq. }
    claim HqB: (function_on q unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx q) /\
      apply_fun q 0 = y.
    { exact (andEL ((function_on q unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx q) /\
                     apply_fun q 0 = y)
                   (apply_fun q 1 = z)
                   HqA). }
    exact (andER (function_on q unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx q)
                 (apply_fun q 0 = y)
                 HqB). }

  claim Hq1: apply_fun q 1 = z.
  { claim HqA:
      ((function_on q unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx q) /\
        apply_fun q 0 = y) /\
      apply_fun q 1 = z.
    { exact Hq. }
    exact (andER ((function_on q unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx q) /\
                   apply_fun q 0 = y)
                 (apply_fun q 1 = z)
                 HqA). }

	  claim Hpf_fun: function_on pf unit_interval_left_half X.
	  { exact (function_on_compose_fun unit_interval_left_half unit_interval X
	           double_map_left_half p
	           double_map_function_on
	           Hp_fun). }
	
	  claim Hqf_fun: function_on qf unit_interval_right_half X.
	  { exact (function_on_compose_fun unit_interval_right_half unit_interval X
	           double_minus_one_map_right_half q
	           double_minus_one_map_function_on
	           Hq_fun). }
	
	  claim Hpf_cont: continuous_map unit_interval_left_half
	    (subspace_topology unit_interval unit_interval_topology unit_interval_left_half)
	    X Tx pf.
	  { exact (composition_continuous unit_interval_left_half
	           (subspace_topology unit_interval unit_interval_topology unit_interval_left_half)
	           unit_interval unit_interval_topology
	           X Tx
	           double_map_left_half p
	           double_map_continuous
	           Hp_cont). }
	
	  claim Hqf_cont: continuous_map unit_interval_right_half
	    (subspace_topology unit_interval unit_interval_topology unit_interval_right_half)
	    X Tx qf.
	  { exact (composition_continuous unit_interval_right_half
	           (subspace_topology unit_interval unit_interval_topology unit_interval_right_half)
	           unit_interval unit_interval_topology
	           X Tx
	           double_minus_one_map_right_half q
	           double_minus_one_map_continuous
	           Hq_cont). }

  claim Hleft_closed: closed_in unit_interval unit_interval_topology unit_interval_left_half.
  { exact (andEL (closed_in unit_interval unit_interval_topology unit_interval_left_half)
                 (closed_in unit_interval unit_interval_topology unit_interval_right_half)
                 unit_interval_halves_closed). }
  claim Hright_closed: closed_in unit_interval unit_interval_topology unit_interval_right_half.
  { exact (andER (closed_in unit_interval unit_interval_topology unit_interval_left_half)
                 (closed_in unit_interval unit_interval_topology unit_interval_right_half)
                 unit_interval_halves_closed). }

	  claim Hagree: forall t:set,
	    t :e (unit_interval_left_half :/\: unit_interval_right_half) ->
	    apply_fun pf t = apply_fun qf t.
	  { let t.
	    assume Ht: t :e (unit_interval_left_half :/\: unit_interval_right_half).
	    claim HtSing: t :e {eps_ 1}.
	    { rewrite <- unit_interval_halves_intersection.
	      exact Ht. }
	    claim Hteq: t = eps_ 1.
	    { exact (SingE (eps_ 1) t HtSing). }
	    rewrite Hteq.
	    claim Hpf: apply_fun pf (eps_ 1) = apply_fun p (apply_fun double_map_left_half (eps_ 1)).
	    { exact (compose_fun_apply unit_interval_left_half double_map_left_half p (eps_ 1)
	             eps_1_in_unit_interval_left_half). }
	    claim Hqf: apply_fun qf (eps_ 1) = apply_fun q (apply_fun double_minus_one_map_right_half (eps_ 1)).
	    { exact (compose_fun_apply unit_interval_right_half double_minus_one_map_right_half q (eps_ 1)
	             eps_1_in_unit_interval_right_half). }
	    rewrite Hpf.
	    rewrite Hqf.
	    rewrite double_map_at_eps1.
	    rewrite double_minus_one_map_at_eps1.
	    rewrite Hp1.
	    rewrite Hq0.
	    reflexivity. }

  claim Hexh: exists h:set, continuous_map unit_interval unit_interval_topology X Tx h /\
    ((forall t:set, t :e unit_interval_left_half -> apply_fun h t = apply_fun pf t) /\
     (forall t:set, t :e unit_interval_right_half -> apply_fun h t = apply_fun qf t)).
	  { exact (pasting_lemma unit_interval
	           unit_interval_left_half
	           unit_interval_right_half
	           X
	           unit_interval_topology
	           Tx
	           pf qf
	           unit_interval_topology_on
	           Hleft_closed
	           Hright_closed
	           unit_interval_halves_cover
	           Hpf_cont
	           Hqf_cont
	           Hagree). }
  apply Hexh.
  let h.
  assume Hh: continuous_map unit_interval unit_interval_topology X Tx h /\
    ((forall t:set, t :e unit_interval_left_half -> apply_fun h t = apply_fun pf t) /\
     (forall t:set, t :e unit_interval_right_half -> apply_fun h t = apply_fun qf t)).
  prove exists p0:set,
    function_on p0 unit_interval X /\
    continuous_map unit_interval unit_interval_topology X Tx p0 /\
    apply_fun p0 0 = x /\ apply_fun p0 1 = z.
  witness h.
  prove function_on h unit_interval X /\
    continuous_map unit_interval unit_interval_topology X Tx h /\
    apply_fun h 0 = x /\ apply_fun h 1 = z.
  apply andI.
  - (** (function_on /\ continuous_map) /\ (apply_fun h 0 = x) **)
    apply andI.
    + (** function_on /\ continuous_map **)
      apply andI.
      * exact (continuous_map_function_on unit_interval unit_interval_topology X Tx h
               (andEL (continuous_map unit_interval unit_interval_topology X Tx h)
                      ((forall t:set, t :e unit_interval_left_half -> apply_fun h t = apply_fun pf t) /\
                       (forall t:set, t :e unit_interval_right_half -> apply_fun h t = apply_fun qf t))
                      Hh)).
      * exact (andEL (continuous_map unit_interval unit_interval_topology X Tx h)
                     ((forall t:set, t :e unit_interval_left_half -> apply_fun h t = apply_fun pf t) /\
                      (forall t:set, t :e unit_interval_right_half -> apply_fun h t = apply_fun qf t))
                     Hh).
    + (** apply_fun h 0 = x **)
      claim H0I: 0 :e unit_interval.
      { exact zero_in_unit_interval. }
      claim H0left: 0 :e unit_interval_left_half.
      { exact (SepI unit_interval (fun t0:set => ~(Rlt (eps_ 1) t0))
                 0 H0I
                 (not_Rlt_sym 0 (eps_ 1) eps_1_pos_R)). }
      claim Hleft: forall t:set, t :e unit_interval_left_half -> apply_fun h t = apply_fun pf t.
      { exact (andEL (forall t:set, t :e unit_interval_left_half -> apply_fun h t = apply_fun pf t)
                     (forall t:set, t :e unit_interval_right_half -> apply_fun h t = apply_fun qf t)
                     (andER (continuous_map unit_interval unit_interval_topology X Tx h)
                            ((forall t:set, t :e unit_interval_left_half -> apply_fun h t = apply_fun pf t) /\
                             (forall t:set, t :e unit_interval_right_half -> apply_fun h t = apply_fun qf t))
                            Hh)). }
	      rewrite (Hleft 0 H0left).
	      claim Hpf0: apply_fun pf 0 = apply_fun p (apply_fun double_map_left_half 0).
	      { exact (compose_fun_apply unit_interval_left_half double_map_left_half p 0
	               zero_in_unit_interval_left_half). }
	      rewrite Hpf0.
	      rewrite double_map_at_0.
	      rewrite Hp0.
	      reflexivity.
  - (** apply_fun h 1 = z **)
    claim H1I: 1 :e unit_interval.
    { exact one_in_unit_interval. }
    claim H1right: 1 :e unit_interval_right_half.
    { exact (SepI unit_interval (fun t0:set => ~(Rlt t0 (eps_ 1)))
               1 H1I
               (not_Rlt_sym (eps_ 1) 1 eps_1_lt1_R)). }
    claim Hright: forall t:set, t :e unit_interval_right_half -> apply_fun h t = apply_fun qf t.
    { exact (andER (forall t:set, t :e unit_interval_left_half -> apply_fun h t = apply_fun pf t)
                   (forall t:set, t :e unit_interval_right_half -> apply_fun h t = apply_fun qf t)
                   (andER (continuous_map unit_interval unit_interval_topology X Tx h)
                          ((forall t:set, t :e unit_interval_left_half -> apply_fun h t = apply_fun pf t) /\
                           (forall t:set, t :e unit_interval_right_half -> apply_fun h t = apply_fun qf t))
                          Hh)). }
	    rewrite (Hright 1 H1right).
	    claim Hqf1: apply_fun qf 1 = apply_fun q (apply_fun double_minus_one_map_right_half 1).
	    { exact (compose_fun_apply unit_interval_right_half double_minus_one_map_right_half q 1
	             one_in_unit_interval_right_half). }
	    rewrite Hqf1.
	    rewrite double_minus_one_map_at_1.
	    rewrite Hq1.
	    reflexivity.
Qed.

(** Helper: a path connected subspace lies inside a single path component **)
Theorem subspace_path_connected_implies_in_path_component : forall X Tx V y z:set,
  topology_on X Tx -> V c= X ->
  path_connected_space V (subspace_topology X Tx V) ->
  y :e V -> z :e V ->
  z :e path_component_of X Tx y.
let X Tx V y z.
assume HTx: topology_on X Tx.
assume HVsubX: V c= X.
assume HpathV: path_connected_space V (subspace_topology X Tx V).
assume HyV: y :e V.
assume HzV: z :e V.
prove z :e path_component_of X Tx y.
claim HyX: y :e X.
{ exact (HVsubX y HyV). }
claim HzX: z :e X.
{ exact (HVsubX z HzV). }
claim HtopV: topology_on V (subspace_topology X Tx V).
{ exact (path_connected_space_topology V (subspace_topology X Tx V) HpathV). }
claim Hpaths: forall x0 y0:set, x0 :e V -> y0 :e V ->
  exists p:set, path_between V x0 y0 p /\ continuous_map unit_interval unit_interval_topology V (subspace_topology X Tx V) p.
{ let x0 y0.
  assume Hx0: x0 :e V.
  assume Hy0: y0 :e V.
  exact (path_connected_space_paths V (subspace_topology X Tx V) x0 y0 HpathV Hx0 Hy0). }
claim Hex: exists p:set, path_between V y z p /\ continuous_map unit_interval unit_interval_topology V (subspace_topology X Tx V) p.
{ exact (Hpaths y z HyV HzV). }
apply Hex.
let p.
assume Hp: path_between V y z p /\ continuous_map unit_interval unit_interval_topology V (subspace_topology X Tx V) p.
claim Hpb: path_between V y z p.
{ exact (path_witness_between V (subspace_topology X Tx V) y z p Hp). }
claim HpcontV: continuous_map unit_interval unit_interval_topology V (subspace_topology X Tx V) p.
{ exact (path_witness_continuous V (subspace_topology X Tx V) y z p Hp). }
claim HpbL: function_on p unit_interval V /\ apply_fun p 0 = y.
{ exact (path_between_pair0 V y z p Hpb). }
claim Hp1: apply_fun p 1 = z.
{ exact (path_between_at_one V y z p Hpb). }
claim Hp0: apply_fun p 0 = y.
{ exact (path_between_at_zero V y z p Hpb). }
claim HpfunV: function_on p unit_interval V.
{ exact (path_between_function_on V y z p Hpb). }
set j := {(y0,y0) | y0 :e V}.
claim Hjdef: j = {(y0,y0) | y0 :e V}.
{ reflexivity. }
claim Hjfun: function_on j V X.
{ let v. assume HvV: v :e V.
  prove apply_fun j v :e X.
  claim Hjv: apply_fun j v = v.
  { rewrite Hjdef.
    exact (identity_function_apply V v HvV). }
  rewrite Hjv.
  exact (HVsubX v HvV). }
set q := compose_fun unit_interval p j.
claim Hqfun: function_on q unit_interval X.
{ exact (function_on_compose_fun unit_interval V X p j HpfunV Hjfun). }
claim HcontJ: continuous_map V (subspace_topology X Tx V) X Tx j.
{ prove topology_on V (subspace_topology X Tx V) /\ topology_on X Tx /\ function_on j V X /\
    forall U:set, U :e Tx -> preimage_of V j U :e subspace_topology X Tx V.
  apply andI.
  - apply andI.
    + apply andI.
      * exact HtopV.
      * exact HTx.
    + exact Hjfun.
  - let U. assume HU: U :e Tx.
    prove preimage_of V j U :e subspace_topology X Tx V.
    claim Heq: preimage_of V j U = U :/\: V.
    { apply set_ext.
      - let v. assume Hv: v :e preimage_of V j U.
        claim HvV: v :e V.
        { exact (SepE1 V (fun v0:set => apply_fun j v0 :e U) v Hv). }
        claim HjinU: apply_fun j v :e U.
    { exact (SepE2 V (fun v0:set => apply_fun j v0 :e U) v Hv). }
        claim Hjv0: apply_fun {(y0,y0) | y0 :e V} v = v.
        { exact (identity_function_apply V v HvV). }
        claim HjinU0: apply_fun {(y0,y0) | y0 :e V} v :e U.
        { rewrite <- Hjdef.
          exact HjinU. }
        claim HvU: v :e U.
        { rewrite <- Hjv0.
          exact HjinU0. }
        exact (binintersectI U V v HvU HvV).
      - let v. assume Hv: v :e U :/\: V.
        apply (binintersectE U V v Hv).
        assume HvU: v :e U.
        assume HvV: v :e V.
        prove v :e preimage_of V j U.
        prove v :e {v0 :e V | apply_fun j v0 :e U}.
        apply SepI.
        * exact HvV.
        * claim Hjv0: apply_fun {(y0,y0) | y0 :e V} v = v.
          { exact (identity_function_apply V v HvV). }
          prove apply_fun j v :e U.
          rewrite Hjdef.
          claim HvU0: apply_fun {(y0,y0) | y0 :e V} v :e U.
          { rewrite Hjv0.
            exact HvU. }
          exact HvU0. }
    rewrite Heq.
    prove U :/\: V :e subspace_topology X Tx V.
    prove U :/\: V :e {W :e Power V | exists V0 :e Tx, W = V0 :/\: V}.
    apply SepI.
    * apply PowerI.
      exact (binintersect_Subq_2 U V).
    * prove exists V0 :e Tx, U :/\: V = V0 :/\: V.
      witness U.
      apply andI.
      + exact HU.
      + reflexivity. }
claim Hqcont: continuous_map unit_interval unit_interval_topology X Tx q.
{ exact (composition_continuous unit_interval unit_interval_topology V (subspace_topology X Tx V) X Tx p j HpcontV HcontJ). }
claim H01: 0 :e unit_interval /\ 1 :e unit_interval.
{ exact zero_one_in_unit_interval. }
claim H0I: 0 :e unit_interval.
{ exact (andEL (0 :e unit_interval) (1 :e unit_interval) H01). }
claim H1I: 1 :e unit_interval.
{ exact (andER (0 :e unit_interval) (1 :e unit_interval) H01). }
claim Hq0: apply_fun q 0 = y.
{ claim Hq0def: apply_fun q 0 = apply_fun j (apply_fun p 0).
  { exact (compose_fun_apply unit_interval p j 0 H0I). }
  rewrite Hq0def.
  rewrite Hp0.
  claim Hjy: apply_fun j y = y.
  { rewrite Hjdef.
    exact (identity_function_apply V y HyV). }
  rewrite Hjy.
  reflexivity. }
claim Hq1: apply_fun q 1 = z.
{ claim Hq1def: apply_fun q 1 = apply_fun j (apply_fun p 1).
  { exact (compose_fun_apply unit_interval p j 1 H1I). }
  rewrite Hq1def.
  rewrite Hp1.
  claim Hjz: apply_fun j z = z.
  { rewrite Hjdef.
    exact (identity_function_apply V z HzV). }
  rewrite Hjz.
  reflexivity. }
prove z :e {y0 :e X | exists q0:set,
  function_on q0 unit_interval X /\
  continuous_map unit_interval unit_interval_topology X Tx q0 /\
  apply_fun q0 0 = y /\ apply_fun q0 1 = y0}.
apply SepI.
- exact HzX.
- prove exists q0:set,
    function_on q0 unit_interval X /\
    continuous_map unit_interval unit_interval_topology X Tx q0 /\
    apply_fun q0 0 = y /\ apply_fun q0 1 = z.
  witness q.
  prove function_on q unit_interval X /\
    continuous_map unit_interval unit_interval_topology X Tx q /\
    apply_fun q 0 = y /\ apply_fun q 1 = z.
  apply andI.
  - apply andI.
    + apply andI.
      * exact Hqfun.
      * exact Hqcont.
    + exact Hq0.
  - exact Hq1.
Qed.

(** Helper: path component is reflexive **)
(** LATEX VERSION: Any point is path connectible to itself via the constant path. **)
Theorem path_component_reflexive : forall X Tx x:set,
  topology_on X Tx -> x :e X -> x :e path_component_of X Tx x.
let X Tx x.
assume HTx: topology_on X Tx.
assume HxX: x :e X.
prove x :e path_component_of X Tx x.
prove x :e {y :e X | exists p:set,
     function_on p unit_interval X /\
     continuous_map unit_interval unit_interval_topology X Tx p /\
     apply_fun p 0 = x /\ apply_fun p 1 = y}.
apply SepI.
- exact HxX.
- (** constant path p(t)=x **)
  prove exists p:set, function_on p unit_interval X /\
    continuous_map unit_interval unit_interval_topology X Tx p /\
    apply_fun p 0 = x /\ apply_fun p 1 = x.
  set p := const_fun unit_interval x.
  witness p.
  prove function_on p unit_interval X /\
    continuous_map unit_interval unit_interval_topology X Tx p /\
    apply_fun p 0 = x /\ apply_fun p 1 = x.
  (** Conjunction is left-associative: (((A /\ B) /\ C) /\ D) **)
  apply andI.
  - (** (function_on /\ continuous_map) /\ (apply_fun p 0 = x) **)
    apply andI.
    + (** function_on /\ continuous_map **)
      apply andI.
      * (** function_on **)
        let t. assume HtI: t :e unit_interval.
        prove apply_fun p t :e X.
        claim Hpt: apply_fun p t = x.
        { exact (const_fun_apply unit_interval x t HtI). }
        rewrite Hpt.
        exact HxX.
      * (** continuous_map **)
        claim HtopI: topology_on unit_interval unit_interval_topology.
        { exact unit_interval_topology_on. }
        exact (const_fun_continuous unit_interval unit_interval_topology X Tx x HtopI HTx HxX).
    + (** apply_fun p 0 = x **)
      claim H01: 0 :e unit_interval /\ 1 :e unit_interval.
      { exact zero_one_in_unit_interval. }
      claim H0: 0 :e unit_interval.
      { exact (andEL (0 :e unit_interval) (1 :e unit_interval) H01). }
      exact (const_fun_apply unit_interval x 0 H0).
  - (** apply_fun p 1 = x **)
    claim H01: 0 :e unit_interval /\ 1 :e unit_interval.
    { exact zero_one_in_unit_interval. }
    claim H1: 1 :e unit_interval.
    { exact (andER (0 :e unit_interval) (1 :e unit_interval) H01). }
    exact (const_fun_apply unit_interval x 1 H1).
Qed.

(** from 24: path components form equivalence classes **) 
(** LATEX VERSION: Path components are equivalence classes under path-connectibility. **)
Theorem path_components_equivalence_relation : forall X Tx:set,
  topology_on X Tx ->
  (forall x:set, x :e X -> x :e path_component_of X Tx x) /\
  (forall x y:set, x :e X -> y :e X -> y :e path_component_of X Tx x -> x :e path_component_of X Tx y) /\
  (forall x y z:set, x :e X -> y :e X -> z :e X ->
     y :e path_component_of X Tx x -> z :e path_component_of X Tx y ->
     z :e path_component_of X Tx x).
let X Tx.
assume HTx: topology_on X Tx.
prove (forall x:set, x :e X -> x :e path_component_of X Tx x) /\
  (forall x y:set, x :e X -> y :e X -> y :e path_component_of X Tx x -> x :e path_component_of X Tx y) /\
  (forall x y z:set, x :e X -> y :e X -> z :e X ->
     y :e path_component_of X Tx x -> z :e path_component_of X Tx y ->
     z :e path_component_of X Tx x).
(** Conjunction is left-associative: (P1 /\ P2) /\ P3 **)
  apply andI.
  - (** P1 /\ P2 **)
    apply andI.
    * (** reflexive **)
      let x. assume HxX: x :e X.
      exact (path_component_reflexive X Tx x HTx HxX).
    * (** symmetric: reverse path **)
      let x y.
      assume HxX: x :e X.
      assume HyX: y :e X.
      assume HyPc: y :e path_component_of X Tx x.
      exact (path_component_symmetric_axiom X Tx x y HTx HxX HyX HyPc).
  - (** transitive: concatenate paths **)
    let x y z.
    assume HxX: x :e X.
    assume HyX: y :e X.
    assume HzX: z :e X.
    assume HyPc: y :e path_component_of X Tx x.
    assume HzPc: z :e path_component_of X Tx y.
    exact (path_component_transitive_axiom X Tx x y z HTx HxX HyX HzX HyPc HzPc).
Qed.

(** from 25 Definition: components and local connectedness **) 
(** LATEX VERSION: Component_of X Tx x is the union of connected subspaces containing x; locally_connected means every neighborhood contains a connected open neighborhood of the point. **)
Definition component_of : set -> set -> set -> set := fun X Tx x =>
  {y :e X | exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y :e C}.
Definition locally_connected : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall x:set, x :e X ->
    forall U:set, U :e Tx -> x :e U ->
      exists V:set, V :e Tx /\ x :e V /\ V c= U /\ connected_space V (subspace_topology X Tx V).

(** Helper: extract topology_on from locally_connected **)
Theorem locally_connected_topology : forall X Tx:set,
  locally_connected X Tx -> topology_on X Tx.
let X Tx.
assume H: locally_connected X Tx.
exact (andEL (topology_on X Tx)
             (forall x:set, x :e X ->
               forall U:set, U :e Tx -> x :e U ->
                 exists V:set, V :e Tx /\ x :e V /\ V c= U /\ connected_space V (subspace_topology X Tx V))
             H).
Qed.

(** Helper: extract local connectedness property **)
Theorem locally_connected_local : forall X Tx x U:set,
  locally_connected X Tx ->
  x :e X ->
  U :e Tx ->
  x :e U ->
  exists V:set, V :e Tx /\ x :e V /\ V c= U /\ connected_space V (subspace_topology X Tx V).
let X Tx x U.
assume H: locally_connected X Tx.
assume Hx: x :e X.
assume HU: U :e Tx.
assume HxU: x :e U.
claim Hprop: forall x0:set, x0 :e X ->
  forall U0:set, U0 :e Tx -> x0 :e U0 ->
    exists V:set, V :e Tx /\ x0 :e V /\ V c= U0 /\ connected_space V (subspace_topology X Tx V).
{ exact (andER (topology_on X Tx)
               (forall x0:set, x0 :e X ->
                 forall U0:set, U0 :e Tx -> x0 :e U0 ->
                   exists V:set, V :e Tx /\ x0 :e V /\ V c= U0 /\ connected_space V (subspace_topology X Tx V))
               H). }
exact (Hprop x Hx U HU HxU).
Qed.

(** from 25 Definition: locally path connected **)
(** LATEX VERSION: Locally path connected means each point has a neighborhood basis of path-connected sets. **)
Definition locally_path_connected : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall x:set, x :e X ->
    forall U:set, U :e Tx -> x :e U ->
      exists V:set, V :e Tx /\ x :e V /\ V c= U /\ path_connected_space V (subspace_topology X Tx V).

(** Helper: extract topology_on from locally_path_connected **)
Theorem locally_path_connected_topology : forall X Tx:set,
  locally_path_connected X Tx -> topology_on X Tx.
let X Tx.
assume H: locally_path_connected X Tx.
exact (andEL (topology_on X Tx)
             (forall x:set, x :e X ->
               forall U:set, U :e Tx -> x :e U ->
                 exists V:set, V :e Tx /\ x :e V /\ V c= U /\ path_connected_space V (subspace_topology X Tx V))
             H).
Qed.

(** Helper: extract local path connectedness property **)
Theorem locally_path_connected_local : forall X Tx x U:set,
  locally_path_connected X Tx ->
  x :e X ->
  U :e Tx ->
  x :e U ->
  exists V:set, V :e Tx /\ x :e V /\ V c= U /\ path_connected_space V (subspace_topology X Tx V).
let X Tx x U.
assume H: locally_path_connected X Tx.
assume Hx: x :e X.
assume HU: U :e Tx.
assume HxU: x :e U.
claim Hprop: forall x0:set, x0 :e X ->
  forall U0:set, U0 :e Tx -> x0 :e U0 ->
    exists V:set, V :e Tx /\ x0 :e V /\ V c= U0 /\ path_connected_space V (subspace_topology X Tx V).
{ exact (andER (topology_on X Tx)
               (forall x0:set, x0 :e X ->
                 forall U0:set, U0 :e Tx -> x0 :e U0 ->
                   exists V:set, V :e Tx /\ x0 :e V /\ V c= U0 /\ path_connected_space V (subspace_topology X Tx V))
               H). }
exact (Hprop x Hx U HU HxU).
Qed.

(** Helper: singleton subspace is connected **)
Theorem singleton_subspace_connected : forall X Tx x:set,
  topology_on X Tx -> x :e X ->
  connected_space {x} (subspace_topology X Tx {x}).
let X Tx x.
assume HTx: topology_on X Tx.
assume HxX: x :e X.
prove connected_space {x} (subspace_topology X Tx {x}).
prove topology_on {x} (subspace_topology X Tx {x}) /\
  ~(exists U V:set, U :e subspace_topology X Tx {x} /\ V :e subspace_topology X Tx {x} /\ separation_of {x} U V).
apply andI.
- (** topology_on {x} (subspace_topology X Tx {x}) **)
  claim Hsub: {x} c= X.
  { let y. assume Hy: y :e {x}.
    prove y :e X.
    claim HyEq: y = x.
    { exact (SingE x y Hy). }
    rewrite HyEq.
    exact HxX. }
  exact (subspace_topology_is_topology X Tx {x} HTx Hsub).
- (** no separation exists **)
  assume Hsep: exists U V:set, U :e subspace_topology X Tx {x} /\ V :e subspace_topology X Tx {x} /\ separation_of {x} U V.
  apply Hsep.
  let U. assume HexV: exists V:set, U :e subspace_topology X Tx {x} /\ V :e subspace_topology X Tx {x} /\ separation_of {x} U V.
  apply HexV.
  let V. assume HUV.
  claim HopenUV: (U :e subspace_topology X Tx {x} /\ V :e subspace_topology X Tx {x}) /\ separation_of {x} U V.
  { exact HUV. }
  claim Hsepof: separation_of {x} U V.
  { exact (andER (U :e subspace_topology X Tx {x} /\ V :e subspace_topology X Tx {x})
                 (separation_of {x} U V) HopenUV). }
  (** Extract U<>Empty, V<>Empty, and UV=Empty and Power-membership from separation_of **)
  claim Hpre: ((((U :e Power {x} /\ V :e Power {x}) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty).
  { exact (andEL ((((U :e Power {x} /\ V :e Power {x}) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                 (U :\/: V = {x}) Hsepof). }
  claim Hpre2: (((U :e Power {x} /\ V :e Power {x}) /\ U :/\: V = Empty) /\ U <> Empty).
  { exact (andEL (((U :e Power {x} /\ V :e Power {x}) /\ U :/\: V = Empty) /\ U <> Empty)
                 (V <> Empty) Hpre). }
  claim HUneq: U <> Empty.
  { exact (andER ((U :e Power {x} /\ V :e Power {x}) /\ U :/\: V = Empty) (U <> Empty) Hpre2). }
  claim HVneq: V <> Empty.
  { exact (andER ((((U :e Power {x} /\ V :e Power {x}) /\ U :/\: V = Empty) /\ U <> Empty)) (V <> Empty) Hpre). }
  claim HpowDisj: (U :e Power {x} /\ V :e Power {x}) /\ U :/\: V = Empty.
  { exact (andEL ((U :e Power {x} /\ V :e Power {x}) /\ U :/\: V = Empty) (U <> Empty) Hpre2). }
  claim HpowUV: U :e Power {x} /\ V :e Power {x}.
  { exact (andEL (U :e Power {x} /\ V :e Power {x}) (U :/\: V = Empty) HpowDisj). }
  claim HUpow: U :e Power {x}.
  { exact (andEL (U :e Power {x}) (V :e Power {x}) HpowUV). }
  claim HVpow: V :e Power {x}.
  { exact (andER (U :e Power {x}) (V :e Power {x}) HpowUV). }
  claim Hdisj: U :/\: V = Empty.
  { exact (andER (U :e Power {x} /\ V :e Power {x}) (U :/\: V = Empty) HpowDisj). }
  (** Pick uU and vV; both must equal x, contradiction with disjointness **)
  apply (nonempty_has_element U HUneq).
  let u. assume Hu: u :e U.
  apply (nonempty_has_element V HVneq).
  let v. assume Hv: v :e V.
  claim HUsub: U c= {x}.
  { exact (PowerE {x} U HUpow). }
  claim HVsub: V c= {x}.
  { exact (PowerE {x} V HVpow). }
  claim Hux: u = x.
  { exact (SingE x u (HUsub u Hu)). }
  claim Hvx: v = x.
  { exact (SingE x v (HVsub v Hv)). }
  claim HxU: x :e U.
  { rewrite <- Hux. exact Hu. }
  claim HxV: x :e V.
  { rewrite <- Hvx. exact Hv. }
  claim HxUV: x :e U :/\: V.
  { exact (binintersectI U V x HxU HxV). }
  claim HxE: x :e Empty.
  { rewrite <- Hdisj. exact HxUV. }
  exact (EmptyE x HxE).
Qed.

(** Helper: a point lies in its own component **)
Theorem point_in_component : forall X Tx x:set,
  topology_on X Tx -> x :e X -> x :e component_of X Tx x.
let X Tx x.
assume HTx: topology_on X Tx.
assume HxX: x :e X.
prove x :e component_of X Tx x.
prove x :e {y :e X | exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y :e C}.
apply SepI.
- exact HxX.
- prove exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ x :e C.
  witness {x}.
  prove connected_space {x} (subspace_topology X Tx {x}) /\ x :e {x} /\ x :e {x}.
  apply andI.
  + apply andI.
    - exact (singleton_subspace_connected X Tx x HTx HxX).
    - exact (SingI x).
  + exact (SingI x).
Qed.

(** Helper: connected subspace witness implies subset of X **)
Theorem connected_subspace_subset : forall X Tx C:set,
  topology_on X Tx ->
  connected_space C (subspace_topology X Tx C) ->
  C c= X.
let X Tx C.
assume HTx: topology_on X Tx.
assume HCconn: connected_space C (subspace_topology X Tx C).
prove C c= X.
claim HCtop: topology_on C (subspace_topology X Tx C).
{ exact (connected_space_topology C (subspace_topology X Tx C) HCconn). }
claim HCinSub: C :e subspace_topology X Tx C.
{ exact (topology_has_X C (subspace_topology X Tx C) HCtop). }
claim HexV: exists V :e Tx, C = V :/\: C.
{ exact (SepE2 (Power C) (fun U0:set => exists V :e Tx, U0 = V :/\: C) C HCinSub). }
apply HexV.
let V. assume HVpair.
claim HVTx: V :e Tx.
{ exact (andEL (V :e Tx) (C = V :/\: C) HVpair). }
claim HCeq: C = V :/\: C.
{ exact (andER (V :e Tx) (C = V :/\: C) HVpair). }
claim HCsubV: C c= V.
{ rewrite HCeq.
  exact (binintersect_Subq_1 V C). }
claim HVsubX: V c= X.
{ exact (topology_elem_subset X Tx V HTx HVTx). }
exact (Subq_tra C V X HCsubV HVsubX).
Qed.

(** Helper: the component of a point is connected **)
Theorem component_of_connected : forall X Tx x:set,
  topology_on X Tx -> x :e X ->
  connected_space (component_of X Tx x) (subspace_topology X Tx (component_of X Tx x)).
let X Tx x.
assume HTx: topology_on X Tx.
assume HxX: x :e X.
set F := {C :e Power X | connected_space C (subspace_topology X Tx C) /\ x :e C}.
claim HFsub: forall C:set, C :e F -> C c= X.
{ let C. assume HCinF: C :e F.
  claim HCpow: C :e Power X.
  { exact (SepE1 (Power X) (fun C0:set => connected_space C0 (subspace_topology X Tx C0) /\ x :e C0) C HCinF). }
  exact (PowerE X C HCpow). }
claim HFconn: forall C:set, C :e F -> connected_space C (subspace_topology X Tx C).
{ let C. assume HCinF: C :e F.
  claim HCpair: connected_space C (subspace_topology X Tx C) /\ x :e C.
  { exact (SepE2 (Power X) (fun C0:set => connected_space C0 (subspace_topology X Tx C0) /\ x :e C0) C HCinF). }
  exact (andEL (connected_space C (subspace_topology X Tx C)) (x :e C) HCpair). }
claim Hcommon: exists w:set, forall C:set, C :e F -> w :e C.
{ witness x.
  let C. assume HCinF: C :e F.
  claim HCpair: connected_space C (subspace_topology X Tx C) /\ x :e C.
  { exact (SepE2 (Power X) (fun C0:set => connected_space C0 (subspace_topology X Tx C0) /\ x :e C0) C HCinF). }
  exact (andER (connected_space C (subspace_topology X Tx C)) (x :e C) HCpair). }
claim HUnionConn: connected_space (Union F) (subspace_topology X Tx (Union F)).
{ exact (union_connected_common_point X Tx F HTx HFsub HFconn Hcommon). }
claim Heq: component_of X Tx x = Union F.
{ apply set_ext.
  - let y. assume Hy: y :e component_of X Tx x.
    prove y :e Union F.
    claim HexC: exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y :e C.
    { exact (SepE2 X (fun y0:set => exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y0 :e C) y Hy). }
    apply HexC.
    let C. assume HC: connected_space C (subspace_topology X Tx C) /\ x :e C /\ y :e C.
    claim HCconn: connected_space C (subspace_topology X Tx C).
    { exact (andEL (connected_space C (subspace_topology X Tx C)) (x :e C)
                   (andEL (connected_space C (subspace_topology X Tx C) /\ x :e C) (y :e C) HC)). }
    claim HxC: x :e C.
    { exact (andER (connected_space C (subspace_topology X Tx C)) (x :e C)
                   (andEL (connected_space C (subspace_topology X Tx C) /\ x :e C) (y :e C) HC)). }
    claim HyC: y :e C.
    { exact (andER (connected_space C (subspace_topology X Tx C) /\ x :e C) (y :e C) HC). }
    claim HCsubX: C c= X.
    { exact (connected_subspace_subset X Tx C HTx HCconn). }
    claim HCpow: C :e Power X.
    { exact (PowerI X C HCsubX). }
    claim HCinF: C :e F.
    { prove C :e {C0 :e Power X | connected_space C0 (subspace_topology X Tx C0) /\ x :e C0}.
      apply SepI.
      - exact HCpow.
      - prove connected_space C (subspace_topology X Tx C) /\ x :e C.
        apply andI.
        * exact HCconn.
        * exact HxC. }
    exact (UnionI F y C HyC HCinF).
  - let y. assume Hy: y :e Union F.
    prove y :e component_of X Tx x.
    apply (UnionE F y Hy).
    let C. assume Hex: y :e C /\ C :e F.
    claim HyC: y :e C.
    { exact (andEL (y :e C) (C :e F) Hex). }
    claim HCinF: C :e F.
    { exact (andER (y :e C) (C :e F) Hex). }
    claim HCsubX: C c= X.
    { exact (HFsub C HCinF). }
    claim HCpair: connected_space C (subspace_topology X Tx C) /\ x :e C.
    { exact (SepE2 (Power X) (fun C0:set => connected_space C0 (subspace_topology X Tx C0) /\ x :e C0) C HCinF). }
    claim HCconn: connected_space C (subspace_topology X Tx C).
    { exact (andEL (connected_space C (subspace_topology X Tx C)) (x :e C) HCpair). }
    claim HxC: x :e C.
    { exact (andER (connected_space C (subspace_topology X Tx C)) (x :e C) HCpair). }
    prove y :e {y0 :e X | exists D:set, connected_space D (subspace_topology X Tx D) /\ x :e D /\ y0 :e D}.
    apply SepI.
    - exact (HCsubX y HyC).
    - prove exists D:set, connected_space D (subspace_topology X Tx D) /\ x :e D /\ y :e D.
      witness C.
      prove connected_space C (subspace_topology X Tx C) /\ x :e C /\ y :e C.
      apply andI.
      + apply andI.
        * exact HCconn.
        * exact HxC.
      + exact HyC. }
prove connected_space (component_of X Tx x) (subspace_topology X Tx (component_of X Tx x)).
rewrite Heq.
exact HUnionConn.
Qed.

(** Helper: if y lies in the component of x, their components coincide **)
Theorem component_of_eq_if_in : forall X Tx x y:set,
  topology_on X Tx -> x :e X ->
  y :e component_of X Tx x ->
  component_of X Tx y = component_of X Tx x.
let X Tx x y.
assume HTx: topology_on X Tx.
assume HxX: x :e X.
assume HyComp: y :e component_of X Tx x.
prove component_of X Tx y = component_of X Tx x.
claim HyX: y :e X.
{ exact (SepE1 X (fun y0:set => exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y0 :e C) y HyComp). }
claim HexC: exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y :e C.
{ exact (SepE2 X (fun y0:set => exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y0 :e C) y HyComp). }
apply set_ext.
- let z. assume Hz: z :e component_of X Tx y.
  prove z :e component_of X Tx x.
  claim HzX: z :e X.
  { exact (SepE1 X (fun z0:set => exists D:set, connected_space D (subspace_topology X Tx D) /\ y :e D /\ z0 :e D) z Hz). }
  claim HexD: exists D:set, connected_space D (subspace_topology X Tx D) /\ y :e D /\ z :e D.
  { exact (SepE2 X (fun z0:set => exists D:set, connected_space D (subspace_topology X Tx D) /\ y :e D /\ z0 :e D) z Hz). }
  prove z :e {y0 :e X | exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y0 :e C}.
  apply SepI.
  - exact HzX.
  - (** build a connected witness containing x and z by union of connected sets through y **)
    set C := Eps_i (fun C0:set => connected_space C0 (subspace_topology X Tx C0) /\ x :e C0 /\ y :e C0).
    claim HC: connected_space C (subspace_topology X Tx C) /\ x :e C /\ y :e C.
    { exact (Eps_i_ex (fun C0:set => connected_space C0 (subspace_topology X Tx C0) /\ x :e C0 /\ y :e C0) HexC). }
    set D := Eps_i (fun D0:set => connected_space D0 (subspace_topology X Tx D0) /\ y :e D0 /\ z :e D0).
    claim HD: connected_space D (subspace_topology X Tx D) /\ y :e D /\ z :e D.
    { exact (Eps_i_ex (fun D0:set => connected_space D0 (subspace_topology X Tx D0) /\ y :e D0 /\ z :e D0) HexD). }
    claim HCconn: connected_space C (subspace_topology X Tx C).
    { exact (andEL (connected_space C (subspace_topology X Tx C)) (x :e C) (andEL (connected_space C (subspace_topology X Tx C) /\ x :e C) (y :e C) HC)). }
    claim HxC: x :e C.
    { exact (andER (connected_space C (subspace_topology X Tx C)) (x :e C)
                   (andEL (connected_space C (subspace_topology X Tx C) /\ x :e C) (y :e C) HC)). }
    claim HyC: y :e C.
    { exact (andER (connected_space C (subspace_topology X Tx C) /\ x :e C) (y :e C) HC). }
    claim HDconn: connected_space D (subspace_topology X Tx D).
    { exact (andEL (connected_space D (subspace_topology X Tx D)) (y :e D) (andEL (connected_space D (subspace_topology X Tx D) /\ y :e D) (z :e D) HD)). }
    claim HyD: y :e D.
    { exact (andER (connected_space D (subspace_topology X Tx D)) (y :e D)
                   (andEL (connected_space D (subspace_topology X Tx D) /\ y :e D) (z :e D) HD)). }
    claim HzD: z :e D.
    { exact (andER (connected_space D (subspace_topology X Tx D) /\ y :e D) (z :e D) HD). }
    claim HCsubX: C c= X.
    { exact (connected_subspace_subset X Tx C HTx HCconn). }
    claim HDsubX: D c= X.
    { exact (connected_subspace_subset X Tx D HTx HDconn). }
    (** connectedness of CD by common point y **)
    set F := UPair C D.
    claim HFsub: forall E:set, E :e F -> E c= X.
    { let E. assume HE: E :e F.
      apply (UPairE E C D HE (E c= X)).
      - assume HEq: E = C. rewrite HEq. exact HCsubX.
      - assume HEq: E = D. rewrite HEq. exact HDsubX. }
    claim HFconn: forall E:set, E :e F -> connected_space E (subspace_topology X Tx E).
    { let E. assume HE: E :e F.
      apply (UPairE E C D HE (connected_space E (subspace_topology X Tx E))).
      - assume HEq: E = C. rewrite HEq. exact HCconn.
      - assume HEq: E = D. rewrite HEq. exact HDconn. }
    claim Hcommon: exists w:set, forall E:set, E :e F -> w :e E.
    { witness y.
      let E. assume HE: E :e F.
      apply (UPairE E C D HE (y :e E)).
      - assume HEq: E = C. rewrite HEq. exact HyC.
      - assume HEq: E = D. rewrite HEq. exact HyD. }
    claim HUnionConn: connected_space (Union F) (subspace_topology X Tx (Union F)).
    { exact (union_connected_common_point X Tx F HTx HFsub HFconn Hcommon). }
    (** x and z are in Union(F) **)
    claim HCinF: C :e F.
    { exact (UPairI1 C D). }
    claim HDinF: D :e F.
    { exact (UPairI2 C D). }
    claim HxUF: x :e Union F.
    { exact (UnionI F x C HxC HCinF). }
    claim HzUF: z :e Union F.
    { exact (UnionI F z D HzD HDinF). }
    prove exists C0:set, connected_space C0 (subspace_topology X Tx C0) /\ x :e C0 /\ z :e C0.
    witness (Union F).
    prove connected_space (Union F) (subspace_topology X Tx (Union F)) /\ x :e Union F /\ z :e Union F.
    apply andI.
    - apply andI.
      + exact HUnionConn.
      + exact HxUF.
    - exact HzUF.
- let z. assume Hz: z :e component_of X Tx x.
  prove z :e component_of X Tx y.
  claim HzX: z :e X.
  { exact (SepE1 X (fun z0:set => exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ z0 :e C) z Hz). }
  claim HexCz: exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ z :e C.
  { exact (SepE2 X (fun z0:set => exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ z0 :e C) z Hz). }
  prove z :e {y0 :e X | exists C:set, connected_space C (subspace_topology X Tx C) /\ y :e C /\ y0 :e C}.
  apply SepI.
  - exact HzX.
  - (** symmetric argument swapping x and y **)
    set C := Eps_i (fun C0:set => connected_space C0 (subspace_topology X Tx C0) /\ x :e C0 /\ y :e C0).
    claim HC: connected_space C (subspace_topology X Tx C) /\ x :e C /\ y :e C.
    { exact (Eps_i_ex (fun C0:set => connected_space C0 (subspace_topology X Tx C0) /\ x :e C0 /\ y :e C0) HexC). }
    set D := Eps_i (fun D0:set => connected_space D0 (subspace_topology X Tx D0) /\ x :e D0 /\ z :e D0).
    claim HD: connected_space D (subspace_topology X Tx D) /\ x :e D /\ z :e D.
    { exact (Eps_i_ex (fun D0:set => connected_space D0 (subspace_topology X Tx D0) /\ x :e D0 /\ z :e D0) HexCz). }
    claim HCconn: connected_space C (subspace_topology X Tx C).
    { exact (andEL (connected_space C (subspace_topology X Tx C)) (x :e C) (andEL (connected_space C (subspace_topology X Tx C) /\ x :e C) (y :e C) HC)). }
    claim HxC: x :e C.
    { exact (andER (connected_space C (subspace_topology X Tx C)) (x :e C)
                   (andEL (connected_space C (subspace_topology X Tx C) /\ x :e C) (y :e C) HC)). }
    claim HyC: y :e C.
    { exact (andER (connected_space C (subspace_topology X Tx C) /\ x :e C) (y :e C) HC). }
    claim HDconn: connected_space D (subspace_topology X Tx D).
    { exact (andEL (connected_space D (subspace_topology X Tx D)) (x :e D) (andEL (connected_space D (subspace_topology X Tx D) /\ x :e D) (z :e D) HD)). }
    claim HxD: x :e D.
    { exact (andER (connected_space D (subspace_topology X Tx D)) (x :e D)
                   (andEL (connected_space D (subspace_topology X Tx D) /\ x :e D) (z :e D) HD)). }
    claim HzD: z :e D.
    { exact (andER (connected_space D (subspace_topology X Tx D) /\ x :e D) (z :e D) HD). }
    claim HCsubX: C c= X.
    { exact (connected_subspace_subset X Tx C HTx HCconn). }
    claim HDsubX: D c= X.
    { exact (connected_subspace_subset X Tx D HTx HDconn). }
    set F := UPair C D.
    claim HFsub: forall E:set, E :e F -> E c= X.
    { let E. assume HE: E :e F.
      apply (UPairE E C D HE (E c= X)).
      - assume HEq: E = C. rewrite HEq. exact HCsubX.
      - assume HEq: E = D. rewrite HEq. exact HDsubX. }
    claim HFconn: forall E:set, E :e F -> connected_space E (subspace_topology X Tx E).
    { let E. assume HE: E :e F.
      apply (UPairE E C D HE (connected_space E (subspace_topology X Tx E))).
      - assume HEq: E = C. rewrite HEq. exact HCconn.
      - assume HEq: E = D. rewrite HEq. exact HDconn. }
    claim Hcommon: exists w:set, forall E:set, E :e F -> w :e E.
    { witness x.
      let E. assume HE: E :e F.
      apply (UPairE E C D HE (x :e E)).
      - assume HEq: E = C. rewrite HEq. exact HxC.
      - assume HEq: E = D. rewrite HEq. exact HxD. }
    claim HUnionConn: connected_space (Union F) (subspace_topology X Tx (Union F)).
    { exact (union_connected_common_point X Tx F HTx HFsub HFconn Hcommon). }
    claim HCinF: C :e F.
    { exact (UPairI1 C D). }
    claim HDinF: D :e F.
    { exact (UPairI2 C D). }
    claim HyUF: y :e Union F.
    { exact (UnionI F y C HyC HCinF). }
    claim HzUF: z :e Union F.
    { exact (UnionI F z D HzD HDinF). }
    prove exists C0:set, connected_space C0 (subspace_topology X Tx C0) /\ y :e C0 /\ z :e C0.
    witness (Union F).
    prove connected_space (Union F) (subspace_topology X Tx (Union F)) /\ y :e Union F /\ z :e Union F.
    apply andI.
    - apply andI.
      + exact HUnionConn.
      + exact HyUF.
    - exact HzUF.
Qed.

(** helper: in a connected space, the component of any point is the whole space **)
(** LATEX VERSION: If X is connected then the component of any point is X. **)
Theorem component_of_whole : forall X Tx x:set,
  connected_space X Tx -> x :e X -> component_of X Tx x = X.
let X Tx x.
assume Hconn: connected_space X Tx.
assume HxX: x :e X.
prove component_of X Tx x = X.
claim HTx: topology_on X Tx.
{ exact (connected_space_topology X Tx Hconn). }
apply set_ext.
- let y. assume Hy: y :e component_of X Tx x.
  prove y :e X.
  exact (SepE1 X (fun y0:set => exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y0 :e C) y Hy).
- let y. assume HyX: y :e X.
  prove y :e component_of X Tx x.
  prove y :e {y0 :e X | exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y0 :e C}.
  apply SepI.
  - exact HyX.
  - claim Hsubeq: subspace_topology X Tx X = Tx.
    { exact (subspace_topology_whole X Tx HTx). }
    claim HconnSub: connected_space X (subspace_topology X Tx X).
    { rewrite Hsubeq.
      exact Hconn. }
    prove exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y :e C.
    witness X.
    apply andI.
    - apply andI.
      + exact HconnSub.
      + exact HxX.
    - exact HyX.
Qed.

(** helper: in a path connected space, the path component of any point is the whole space **)
(** LATEX VERSION: If X is path connected then the path component of any point is X. **)
Theorem path_component_of_whole : forall X Tx x:set,
  path_connected_space X Tx -> x :e X -> path_component_of X Tx x = X.
let X Tx x.
assume Hpath: path_connected_space X Tx.
assume HxX: x :e X.
prove path_component_of X Tx x = X.
claim HTx: topology_on X Tx.
{ exact (path_connected_space_topology X Tx Hpath). }
claim Hpathprop: forall x0 y0:set, x0 :e X -> y0 :e X ->
  exists p:set, path_between X x0 y0 p /\ continuous_map unit_interval unit_interval_topology X Tx p.
{ let x0 y0.
  assume Hx0: x0 :e X.
  assume Hy0: y0 :e X.
  exact (path_connected_space_paths X Tx x0 y0 Hpath Hx0 Hy0). }
apply set_ext.
- (** path_component_of subset X **)
  let y. assume Hy: y :e path_component_of X Tx x.
  prove y :e X.
  exact (SepE1 X (fun y0:set => exists p:set,
                    function_on p unit_interval X /\
                    continuous_map unit_interval unit_interval_topology X Tx p /\
                    apply_fun p 0 = x /\ apply_fun p 1 = y0) y Hy).
- (** X subset path_component_of **)
  let y. assume HyX: y :e X.
  prove y :e path_component_of X Tx x.
  prove y :e {y0 :e X | exists p:set,
     function_on p unit_interval X /\
     continuous_map unit_interval unit_interval_topology X Tx p /\
     apply_fun p 0 = x /\ apply_fun p 1 = y0}.
  apply SepI.
  - exact HyX.
  - claim Hex: exists p:set, path_between X x y p /\ continuous_map unit_interval unit_interval_topology X Tx p.
    { exact (Hpathprop x y HxX HyX). }
    apply Hex.
    let p.
    assume Hp: path_between X x y p /\ continuous_map unit_interval unit_interval_topology X Tx p.
    claim Hpb: path_between X x y p.
    { exact (path_witness_between X Tx x y p Hp). }
    claim Hcont: continuous_map unit_interval unit_interval_topology X Tx p.
    { exact (path_witness_continuous X Tx x y p Hp). }
    prove exists q:set, function_on q unit_interval X /\
      continuous_map unit_interval unit_interval_topology X Tx q /\
      apply_fun q 0 = x /\ apply_fun q 1 = y.
    witness p.
    prove function_on p unit_interval X /\
      continuous_map unit_interval unit_interval_topology X Tx p /\
      apply_fun p 0 = x /\ apply_fun p 1 = y.
    claim HpbL: function_on p unit_interval X /\ apply_fun p 0 = x.
    { exact (path_between_pair0 X x y p Hpb). }
    claim Hp1: apply_fun p 1 = y.
    { exact (path_between_at_one X x y p Hpb). }
    claim Hp0: apply_fun p 0 = x.
    { exact (path_between_at_zero X x y p Hpb). }
    claim Hfun: function_on p unit_interval X.
    { exact (path_between_function_on X x y p Hpb). }
    apply andI.
    - apply andI.
      + apply andI.
        * exact Hfun.
        * exact Hcont.
      + exact Hp0.
    - exact Hp1.
Qed.

Definition pairwise_disjoint : set -> prop := fun Fam =>
  forall U V:set, U :e Fam -> V :e Fam -> U <> V -> U :/\: V = Empty.
Definition covers : set -> set -> prop :=
  fun X U => forall x:set, x :e X -> exists u:set, u :e U /\ x :e u.

(** from 25: path components open in locally path connected spaces **) 
(** LATEX VERSION: In a locally path connected space, every path component is open. **)
Theorem path_components_open : forall X Tx:set,
  locally_path_connected X Tx ->
  forall x:set, x :e X ->
    open_in X Tx (path_component_of X Tx x).
let X Tx.
assume Hlpc: locally_path_connected X Tx.
let x.
assume Hx: x :e X.
prove open_in X Tx (path_component_of X Tx x).
prove topology_on X Tx /\ path_component_of X Tx x :e Tx.
claim HTx: topology_on X Tx.
{ exact (locally_path_connected_topology X Tx Hlpc). }
claim Hlpcprop: forall x0:set, x0 :e X ->
  forall U:set, U :e Tx -> x0 :e U ->
    exists V:set, V :e Tx /\ x0 :e V /\ V c= U /\ path_connected_space V (subspace_topology X Tx V).
{ let x0. assume Hx0: x0 :e X.
  let U. assume HU: U :e Tx.
  assume Hx0U: x0 :e U.
  exact (locally_path_connected_local X Tx x0 U Hlpc Hx0 HU Hx0U). }
apply andI.
- exact HTx.
- set P := path_component_of X Tx x.
  set Fam := {V :e Tx | V c= P /\ path_connected_space V (subspace_topology X Tx V)}.
  claim HFsub: Fam c= Tx.
  { let V. assume HV: V :e Fam.
    exact (SepE1 Tx (fun V0:set => V0 c= P /\ path_connected_space V0 (subspace_topology X Tx V0)) V HV). }
  claim HUnionTx: Union Fam :e Tx.
  { exact (topology_union_closed X Tx Fam HTx HFsub). }
  claim HUnionEq: Union Fam = P.
  { apply set_ext.
    - let y. assume Hy: y :e Union Fam.
      apply (UnionE Fam y Hy).
      let V. assume Hex: y :e V /\ V :e Fam.
      claim HyV: y :e V.
      { exact (andEL (y :e V) (V :e Fam) Hex). }
      claim HVFam: V :e Fam.
      { exact (andER (y :e V) (V :e Fam) Hex). }
      claim HVpair: V c= P /\ path_connected_space V (subspace_topology X Tx V).
      { exact (SepE2 Tx (fun V0:set => V0 c= P /\ path_connected_space V0 (subspace_topology X Tx V0)) V HVFam). }
      claim HVsubP: V c= P.
      { exact (andEL (V c= P) (path_connected_space V (subspace_topology X Tx V)) HVpair). }
      exact (HVsubP y HyV).
    - let y. assume HyP: y :e P.
      claim HyX: y :e X.
      { exact (SepE1 X (fun y0:set => exists p:set,
        function_on p unit_interval X /\
        continuous_map unit_interval unit_interval_topology X Tx p /\
        apply_fun p 0 = x /\ apply_fun p 1 = y0) y HyP). }
      claim HXTx: X :e Tx.
      { exact (topology_has_X X Tx HTx). }
      claim HexV: exists V:set, V :e Tx /\ y :e V /\ V c= X /\ path_connected_space V (subspace_topology X Tx V).
      { exact (Hlpcprop y HyX X HXTx HyX). }
      apply HexV.
      let V. assume HV: V :e Tx /\ y :e V /\ V c= X /\ path_connected_space V (subspace_topology X Tx V).
      claim HVpre: ((V :e Tx /\ y :e V) /\ V c= X).
      { exact (andEL ((V :e Tx /\ y :e V) /\ V c= X)
                     (path_connected_space V (subspace_topology X Tx V)) HV). }
      claim HVpath: path_connected_space V (subspace_topology X Tx V).
      { exact (andER ((V :e Tx /\ y :e V) /\ V c= X)
                     (path_connected_space V (subspace_topology X Tx V)) HV). }
      claim HVTx_y: V :e Tx /\ y :e V.
      { exact (andEL (V :e Tx /\ y :e V) (V c= X) HVpre). }
      claim HVTx: V :e Tx.
      { exact (andEL (V :e Tx) (y :e V) HVTx_y). }
      claim HyV: y :e V.
      { exact (andER (V :e Tx) (y :e V) HVTx_y). }
      claim HVsubX: V c= X.
      { exact (andER (V :e Tx /\ y :e V) (V c= X) HVpre). }
      claim HVsubP: V c= P.
      { let z. assume HzV: z :e V.
        prove z :e P.
        claim HzX: z :e X.
        { exact (HVsubX z HzV). }
        claim HzPcy: z :e path_component_of X Tx y.
        { exact (subspace_path_connected_implies_in_path_component X Tx V y z HTx HVsubX HVpath HyV HzV). }
        exact (path_component_transitive_axiom X Tx x y z HTx Hx HyX HzX HyP HzPcy). }
      claim HVinFam: V :e Fam.
      { prove V :e {V0 :e Tx | V0 c= P /\ path_connected_space V0 (subspace_topology X Tx V0)}.
        apply SepI.
        - exact HVTx.
        - prove V c= P /\ path_connected_space V (subspace_topology X Tx V).
          apply andI.
          * exact HVsubP.
          * exact HVpath. }
      exact (UnionI Fam y V HyV HVinFam). }
  rewrite <- HUnionEq.
  exact HUnionTx.
Qed.

(** from 25: components equal path components when locally path connected **) 
(** LATEX VERSION: In a locally path connected space, components coincide with path components. **)
Theorem components_equal_path_components : forall X Tx:set,
  locally_path_connected X Tx ->
  forall x:set, x :e X ->
    path_component_of X Tx x = component_of X Tx x.
let X Tx.
assume Hlpc: locally_path_connected X Tx.
let x.
assume Hx: x :e X.
prove path_component_of X Tx x = component_of X Tx x.
claim HTx: topology_on X Tx.
{ exact (locally_path_connected_topology X Tx Hlpc). }
claim Hlpcprop: forall x0:set, x0 :e X ->
  forall U:set, U :e Tx -> x0 :e U ->
    exists V:set, V :e Tx /\ x0 :e V /\ V c= U /\ path_connected_space V (subspace_topology X Tx V).
{ let x0. assume Hx0: x0 :e X.
  let U. assume HU: U :e Tx.
  assume Hx0U: x0 :e U.
  exact (locally_path_connected_local X Tx x0 U Hlpc Hx0 HU Hx0U). }
set P := path_component_of X Tx x.
set C := component_of X Tx x.
claim HCsubX: C c= X.
{ let y. assume Hy: y :e C.
  exact (SepE1 X (fun y0:set => exists C0:set, connected_space C0 (subspace_topology X Tx C0) /\ x :e C0 /\ y0 :e C0) y Hy). }
claim HopenP: open_in X Tx P.
{ exact (path_components_open X Tx Hlpc x Hx). }
claim HPinTx: P :e Tx.
{ exact (open_in_elem X Tx P HopenP). }
claim HxP: x :e P.
{ exact (path_component_reflexive X Tx x HTx Hx). }
claim HxC: x :e C.
{ exact (point_in_component X Tx x HTx Hx). }
apply set_ext.
- (** P  C **)
  let y. assume HyP: y :e P.
  prove y :e C.
  claim HyX: y :e X.
  { exact (SepE1 X (fun y0:set => exists p:set,
     function_on p unit_interval X /\
     continuous_map unit_interval unit_interval_topology X Tx p /\
     apply_fun p 0 = x /\ apply_fun p 1 = y0) y HyP). }
  claim Hex: exists p:set,
     function_on p unit_interval X /\
     continuous_map unit_interval unit_interval_topology X Tx p /\
     apply_fun p 0 = x /\ apply_fun p 1 = y.
  { exact (SepE2 X (fun y0:set => exists p:set,
     function_on p unit_interval X /\
     continuous_map unit_interval unit_interval_topology X Tx p /\
     apply_fun p 0 = x /\ apply_fun p 1 = y0) y HyP). }
  apply Hex.
  let p. assume Hp.
  claim H01: 0 :e unit_interval /\ 1 :e unit_interval.
  { exact zero_one_in_unit_interval. }
  claim H0I: 0 :e unit_interval.
  { exact (andEL (0 :e unit_interval) (1 :e unit_interval) H01). }
  claim H1I: 1 :e unit_interval.
  { exact (andER (0 :e unit_interval) (1 :e unit_interval) H01). }
  claim Htmp: ((function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p) /\ apply_fun p 0 = x) /\ apply_fun p 1 = y.
  { exact Hp. }
  claim Hp1: apply_fun p 1 = y.
  { exact (andER ((function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p) /\ apply_fun p 0 = x)
                 (apply_fun p 1 = y) Htmp). }
  claim Htmp2: (function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p) /\ apply_fun p 0 = x.
  { exact (andEL ((function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p) /\ apply_fun p 0 = x)
                 (apply_fun p 1 = y) Htmp). }
  claim Hp0: apply_fun p 0 = x.
  { exact (andER (function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p)
                 (apply_fun p 0 = x) Htmp2). }
  claim Hpfc: function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p.
  { exact (andEL (function_on p unit_interval X /\ continuous_map unit_interval unit_interval_topology X Tx p)
                 (apply_fun p 0 = x) Htmp2). }
  claim Hpfun: function_on p unit_interval X.
  { exact (andEL (function_on p unit_interval X) (continuous_map unit_interval unit_interval_topology X Tx p) Hpfc). }
  claim Hpcont: continuous_map unit_interval unit_interval_topology X Tx p.
  { exact (andER (function_on p unit_interval X) (continuous_map unit_interval unit_interval_topology X Tx p) Hpfc). }
  set Img := image_of p unit_interval.
  claim HimgConn: connected_space Img (subspace_topology X Tx Img).
  { exact (continuous_image_connected unit_interval unit_interval_topology X Tx p unit_interval_connected Hpcont). }
  claim HxImg: x :e Img.
  { claim Hpx: apply_fun p 0 :e Img.
    { exact (ReplI unit_interval (fun t:set => apply_fun p t) 0 H0I). }
    rewrite <- Hp0.
    exact Hpx. }
  claim HyImg: y :e Img.
  { claim Hpy: apply_fun p 1 :e Img.
    { exact (ReplI unit_interval (fun t:set => apply_fun p t) 1 H1I). }
    rewrite <- Hp1.
    exact Hpy. }
  prove y :e {y0 :e X | exists C0:set, connected_space C0 (subspace_topology X Tx C0) /\ x :e C0 /\ y0 :e C0}.
  apply SepI.
  - exact HyX.
  - prove exists C0:set, connected_space C0 (subspace_topology X Tx C0) /\ x :e C0 /\ y :e C0.
    witness Img.
    prove connected_space Img (subspace_topology X Tx Img) /\ x :e Img /\ y :e Img.
    apply andI.
    + apply andI.
      * exact HimgConn.
      * exact HxImg.
    + exact HyImg.
- (** C  P **)
  let y. assume HyC: y :e C.
  prove y :e P.
  set Tc := subspace_topology X Tx C.
  claim HCconn: connected_space C Tc.
  { exact (component_of_connected X Tx x HTx Hx). }
  claim HtopC: topology_on C Tc.
  { exact (andEL (topology_on C Tc)
                 (~(exists U V:set, U :e Tc /\ V :e Tc /\ separation_of C U V))
                 HCconn). }
  set A := P :/\: C.
  set D := C :\: P.
  claim HA_subC: A c= C.
  { exact (binintersect_Subq_2 P C). }
  claim HAopen: open_in C Tc A.
  { claim Hiff: open_in C Tc A <-> exists V :e Tx, A = V :/\: C.
    { exact (open_in_subspace_iff X Tx C A HTx HCsubX HA_subC). }
    apply (iffER (open_in C Tc A) (exists V :e Tx, A = V :/\: C) Hiff).
    prove exists V :e Tx, A = V :/\: C.
    witness P.
    apply andI.
    - exact HPinTx.
    - reflexivity. }
  (** D is open in the subspace topology on C **)
  set UFam := {W :e Tc | W c= D}.
  claim HUFsub: UFam c= Tc.
  { let W. assume HW: W :e UFam.
    exact (SepE1 Tc (fun W0:set => W0 c= D) W HW). }
  claim HUnionTc: Union UFam :e Tc.
  { exact (topology_union_closed C Tc UFam HtopC HUFsub). }
  claim HUnionEq: Union UFam = D.
  { apply set_ext.
    - let z. assume Hz: z :e Union UFam.
      apply (UnionE UFam z Hz).
      let W. assume HexW: z :e W /\ W :e UFam.
      claim HzW: z :e W.
      { exact (andEL (z :e W) (W :e UFam) HexW). }
      claim HWUF: W :e UFam.
      { exact (andER (z :e W) (W :e UFam) HexW). }
      claim HWsubD: W c= D.
      { exact (SepE2 Tc (fun W0:set => W0 c= D) W HWUF). }
      exact (HWsubD z HzW).
    - let z. assume HzD: z :e D.
      claim HzC: z :e C.
      { exact (setminusE1 C P z HzD). }
      claim HzNotP: z /:e P.
      { exact (setminusE2 C P z HzD). }
      claim HzX: z :e X.
      { exact (HCsubX z HzC). }
      claim HXTx: X :e Tx.
      { exact (topology_has_X X Tx HTx). }
      claim HexV: exists V:set, V :e Tx /\ z :e V /\ V c= X /\ path_connected_space V (subspace_topology X Tx V).
      { exact (Hlpcprop z HzX X HXTx HzX). }
      apply HexV.
      let V. assume HV: V :e Tx /\ z :e V /\ V c= X /\ path_connected_space V (subspace_topology X Tx V).
      claim HVpre: ((V :e Tx /\ z :e V) /\ V c= X).
      { exact (andEL ((V :e Tx /\ z :e V) /\ V c= X)
                     (path_connected_space V (subspace_topology X Tx V)) HV). }
      claim HVpath: path_connected_space V (subspace_topology X Tx V).
      { exact (andER ((V :e Tx /\ z :e V) /\ V c= X)
                     (path_connected_space V (subspace_topology X Tx V)) HV). }
      claim HVTx_z: V :e Tx /\ z :e V.
      { exact (andEL (V :e Tx /\ z :e V) (V c= X) HVpre). }
      claim HVTx: V :e Tx.
      { exact (andEL (V :e Tx) (z :e V) HVTx_z). }
      claim HzV: z :e V.
      { exact (andER (V :e Tx) (z :e V) HVTx_z). }
      claim HVsubX: V c= X.
      { exact (andER (V :e Tx /\ z :e V) (V c= X) HVpre). }
      set W := V :/\: C.
      claim HW_Tc: W :e Tc.
      { prove W :e {U :e Power C | exists V0 :e Tx, U = V0 :/\: C}.
        apply SepI.
        - apply PowerI.
          exact (binintersect_Subq_2 V C).
        - prove exists V0 :e Tx, W = V0 :/\: C.
          witness V.
          apply andI.
          + exact HVTx.
          + reflexivity. }
      claim HzW: z :e W.
      { exact (binintersectI V C z HzV HzC). }
      claim HWsubD: W c= D.
      { let t. assume HtW: t :e W.
        apply (binintersectE V C t HtW).
        assume HtV: t :e V.
        assume HtC: t :e C.
        prove t :e D.
        prove t :e C :\: P.
        apply setminusI.
        - exact HtC.
        - assume HtP: t :e P.
          claim HzPc_t: z :e path_component_of X Tx t.
          { exact (subspace_path_connected_implies_in_path_component X Tx V t z HTx HVsubX HVpath HtV HzV). }
          claim HtX: t :e X.
          { exact (HCsubX t HtC). }
          claim HzPc_x: z :e path_component_of X Tx x.
          { exact (path_component_transitive_axiom X Tx x t z HTx Hx HtX HzX HtP HzPc_t). }
          exact (HzNotP HzPc_x). }
      claim HWUF: W :e UFam.
      { prove W :e {W0 :e Tc | W0 c= D}.
        apply SepI.
        - exact HW_Tc.
        - exact HWsubD. }
      exact (UnionI UFam z W HzW HWUF). }
  claim HD_Tc: D :e Tc.
  { rewrite <- HUnionEq.
    exact HUnionTc. }
  claim HDopen: open_in C Tc D.
  { exact (open_inI C Tc D HtopC HD_Tc). }
  claim HAeq: A = C :\: D.
  { apply set_ext.
    - let t. assume HtA: t :e A.
      apply (binintersectE P C t HtA).
      assume HtP: t :e P.
      assume HtC: t :e C.
      prove t :e C :\: D.
      apply setminusI.
      + exact HtC.
      + assume HtD: t :e D.
        claim HtNotP: t /:e P.
        { exact (setminusE2 C P t HtD). }
        exact (HtNotP HtP).
    - let t. assume HtCD: t :e C :\: D.
      claim HtC: t :e C.
      { exact (setminusE1 C D t HtCD). }
      claim HtNotD: t /:e D.
      { exact (setminusE2 C D t HtCD). }
      claim HtP: t :e P.
      { apply (xm (t :e P)).
        - assume HtP0: t :e P. exact HtP0.
        - assume HtNotP: t /:e P.
          apply FalseE.
          apply HtNotD.
          exact (setminusI C P t HtC HtNotP). }
      exact (binintersectI P C t HtP HtC). }
  claim HAclosed: closed_in C Tc A.
  { claim HDinTc: D :e Tc.
    { exact HD_Tc. }
    claim Hcl: closed_in C Tc (C :\: D).
    { exact (closed_of_open_complement C Tc D HtopC HDinTc). }
    rewrite HAeq.
    exact Hcl. }
  (** show A = C by connectedness of C and clopen property of A **)
  claim HnoClopen: ~(exists B:set, B <> Empty /\ B <> C /\ open_in C Tc B /\ closed_in C Tc B).
  { exact (iffEL (connected_space C Tc)
                 (~(exists B:set, B <> Empty /\ B <> C /\ open_in C Tc B /\ closed_in C Tc B))
                 (connected_iff_no_nontrivial_clopen C Tc HtopC) HCconn). }
  claim HAne: A <> Empty.
  { exact (elem_implies_nonempty A x (binintersectI P C x HxP HxC)). }
  claim HAeqC: A = C.
  { apply (xm (A = C)).
    - assume H. exact H.
    - assume Hneq: A <> C.
      apply FalseE.
      apply HnoClopen.
      witness A.
      prove A <> Empty /\ A <> C /\ open_in C Tc A /\ closed_in C Tc A.
      apply andI.
      - apply andI.
        + apply andI.
          * exact HAne.
          * exact Hneq.
        + exact HAopen.
      - exact HAclosed. }
  claim HyA: y :e A.
  { rewrite HAeqC.
    exact HyC. }
  apply (binintersectE P C y HyA).
  assume HyP: y :e P.
  assume HyC0: y :e C.
  exact HyP.
Qed.

(** from 25: components are closed **) 
(** LATEX VERSION: Every component is closed in X. **)
Theorem components_are_closed : forall X Tx:set,
  topology_on X Tx ->
  forall x:set, x :e X -> closed_in X Tx (component_of X Tx x).
let X Tx.
assume HTx: topology_on X Tx.
let x.
assume Hx: x :e X.
prove closed_in X Tx (component_of X Tx x).
set A := component_of X Tx x.
set B := closure_of X Tx A.
claim HBdef: B = closure_of X Tx A.
{ reflexivity. }
claim HAsub: A c= X.
{ let y. assume Hy: y :e A.
  exact (SepE1 X (fun y0:set => exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y0 :e C) y Hy). }
claim HBsub: B c= X.
{ rewrite HBdef.
  exact (closure_in_space X Tx A HTx). }
claim HAB: A c= B.
{ rewrite HBdef.
  exact (subset_of_closure X Tx A HTx HAsub). }
claim HAconn: connected_space A (subspace_topology X Tx A).
{ exact (component_of_connected X Tx x HTx Hx). }
claim HBcl: B c= closure_of X Tx A.
{ rewrite HBdef.
  exact (Subq_ref (closure_of X Tx A)). }
claim HBconn: connected_space B (subspace_topology X Tx B).
{ exact (connected_with_limit_points X Tx A B HTx HAsub HBsub HAconn HAB HBcl). }
claim HBsubA: B c= A.
{ let y. assume Hy: y :e B.
  prove y :e A.
  prove y :e {y0 :e X | exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y0 :e C}.
  apply SepI.
  - exact (HBsub y Hy).
  - prove exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y :e C.
    witness B.
    prove connected_space B (subspace_topology X Tx B) /\ x :e B /\ y :e B.
    apply andI.
    + apply andI.
      * exact HBconn.
      * claim HxA: x :e A.
        { exact (point_in_component X Tx x HTx Hx). }
        exact (HAB x HxA).
    + exact Hy. }
claim Heq: B = A.
{ apply set_ext.
  - let y. assume Hy: y :e B.
    exact (HBsubA y Hy).
  - let y. assume Hy: y :e A.
    exact (HAB y Hy). }
claim HBclosed0: closed_in X Tx (closure_of X Tx A).
{ exact (closure_is_closed X Tx A HTx HAsub). }
claim HBclosed: closed_in X Tx B.
{ rewrite <- HBdef.
  exact HBclosed0. }
claim HAclosed: closed_in X Tx A.
{ rewrite <- Heq.
  exact HBclosed. }
exact HAclosed.
Qed.

(** from 25: components are open in locally connected spaces **) 
(** LATEX VERSION: In a locally connected space, every component is open. **)
Theorem components_are_open_in_locally_connected : forall X Tx:set,
  locally_connected X Tx ->
  forall x:set, x :e X -> open_in X Tx (component_of X Tx x).
let X Tx.
assume Hloc: locally_connected X Tx.
let x.
assume HxX: x :e X.
prove open_in X Tx (component_of X Tx x).
prove topology_on X Tx /\ component_of X Tx x :e Tx.
claim HTx: topology_on X Tx.
{ exact (locally_connected_topology X Tx Hloc). }
claim Hlocprop: forall y:set, y :e X ->
  forall U:set, U :e Tx -> y :e U ->
    exists V:set, V :e Tx /\ y :e V /\ V c= U /\ connected_space V (subspace_topology X Tx V).
{ let y. assume Hy: y :e X.
  let U. assume HU: U :e Tx.
  assume HyU: y :e U.
  exact (locally_connected_local X Tx y U Hloc Hy HU HyU). }
apply andI.
- exact HTx.
- set Comp := component_of X Tx x.
  set UFam := {V :e Tx | V c= Comp /\ connected_space V (subspace_topology X Tx V)}.
  claim HUFsub: UFam c= Tx.
  { let V. assume HV: V :e UFam.
    exact (SepE1 Tx (fun V0:set => V0 c= Comp /\ connected_space V0 (subspace_topology X Tx V0)) V HV). }
  claim HUnionTx: Union UFam :e Tx.
  { exact (topology_union_closed X Tx UFam HTx HUFsub). }
  claim HUnionEq: Union UFam = Comp.
  { apply set_ext.
    - let y. assume Hy: y :e Union UFam.
      apply (UnionE UFam y Hy).
      let V. assume Hex: y :e V /\ V :e UFam.
      claim HyV: y :e V.
      { exact (andEL (y :e V) (V :e UFam) Hex). }
      claim HVUF: V :e UFam.
      { exact (andER (y :e V) (V :e UFam) Hex). }
      claim HVpair: V c= Comp /\ connected_space V (subspace_topology X Tx V).
      { exact (SepE2 Tx (fun V0:set => V0 c= Comp /\ connected_space V0 (subspace_topology X Tx V0)) V HVUF). }
      claim HVsubComp: V c= Comp.
      { exact (andEL (V c= Comp) (connected_space V (subspace_topology X Tx V)) HVpair). }
      exact (HVsubComp y HyV).
    - let y. assume Hy: y :e Comp.
      claim HyX: y :e X.
      { exact (SepE1 X (fun y0:set => exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y0 :e C) y Hy). }
      claim HXTx: X :e Tx.
      { exact (topology_has_X X Tx HTx). }
      claim HexV: exists V:set, V :e Tx /\ y :e V /\ V c= X /\ connected_space V (subspace_topology X Tx V).
      { exact (Hlocprop y HyX X HXTx HyX). }
      apply HexV.
      let V. assume HV: V :e Tx /\ y :e V /\ V c= X /\ connected_space V (subspace_topology X Tx V).
      claim HVpre: ((V :e Tx /\ y :e V) /\ V c= X).
      { exact (andEL ((V :e Tx /\ y :e V) /\ V c= X)
                     (connected_space V (subspace_topology X Tx V)) HV). }
      claim HVconn: connected_space V (subspace_topology X Tx V).
      { exact (andER ((V :e Tx /\ y :e V) /\ V c= X)
                     (connected_space V (subspace_topology X Tx V)) HV). }
      claim HVTx_y: V :e Tx /\ y :e V.
      { exact (andEL (V :e Tx /\ y :e V) (V c= X) HVpre). }
      claim HVTx: V :e Tx.
      { exact (andEL (V :e Tx) (y :e V) HVTx_y). }
      claim HyV: y :e V.
      { exact (andER (V :e Tx) (y :e V) HVTx_y). }
      claim HVsubX: V c= X.
      { exact (andER (V :e Tx /\ y :e V) (V c= X) HVpre). }
      claim HcompEq: component_of X Tx y = component_of X Tx x.
      { exact (component_of_eq_if_in X Tx x y HTx HxX Hy). }
      claim HVsubComp: V c= Comp.
      { let z. assume HzV: z :e V.
        prove z :e Comp.
        claim HzX: z :e X.
        { exact (HVsubX z HzV). }
        claim HzCompy: z :e component_of X Tx y.
        { prove z :e {y0 :e X | exists C:set, connected_space C (subspace_topology X Tx C) /\ y :e C /\ y0 :e C}.
          apply SepI.
          - exact HzX.
          - prove exists C:set, connected_space C (subspace_topology X Tx C) /\ y :e C /\ z :e C.
            witness V.
            prove connected_space V (subspace_topology X Tx V) /\ y :e V /\ z :e V.
            apply andI.
            + apply andI.
              * exact HVconn.
              * exact HyV.
            + exact HzV. }
        rewrite <- HcompEq.
        exact HzCompy. }
      claim HVinUFam: V :e UFam.
      { prove V :e {V0 :e Tx | V0 c= Comp /\ connected_space V0 (subspace_topology X Tx V0)}.
        apply SepI.
        - exact HVTx.
        - prove V c= Comp /\ connected_space V (subspace_topology X Tx V).
          apply andI.
          * exact HVsubComp.
          * exact HVconn. }
      exact (UnionI UFam y V HyV HVinUFam). }
  claim HCompTx: Comp :e Tx.
  { rewrite <- HUnionEq.
    exact HUnionTx. }
  exact HCompTx.
Qed.

(** from 25: components partition the space **) 
(** LATEX VERSION: Components cover X and are pairwise disjoint. **)
Theorem components_partition_space : forall X Tx:set,
  topology_on X Tx ->
  covers X {component_of X Tx x | x :e X} /\
  pairwise_disjoint {component_of X Tx x | x :e X}.
let X Tx.
assume HTx: topology_on X Tx.
prove covers X {component_of X Tx x | x :e X} /\ pairwise_disjoint {component_of X Tx x | x :e X}.
apply andI.
- (** covers X by components **)
  let x. assume HxX: x :e X.
  witness (component_of X Tx x).
  prove component_of X Tx x :e {component_of X Tx x0|x0 :e X} /\ x :e component_of X Tx x.
  apply andI.
  - exact (ReplI X (fun x0:set => component_of X Tx x0) x HxX).
  - (** x lies in its own component (use singleton {x} as connected subspace) **)
    prove x :e component_of X Tx x.
    prove x :e {y :e X | exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y :e C}.
    apply SepI.
    - exact HxX.
    - prove exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ x :e C.
      witness {x}.
      prove connected_space {x} (subspace_topology X Tx {x}) /\ x :e {x} /\ x :e {x}.
      apply andI.
      + apply andI.
        * exact (singleton_subspace_connected X Tx x HTx HxX).
        * exact (SingI x).
      + exact (SingI x).
- (** pairwise disjointness of distinct components **)
  let U V.
  assume HU: U :e {component_of X Tx x | x :e X}.
  assume HV: V :e {component_of X Tx x | x :e X}.
  assume Hneq: U <> V.
  prove U :/\: V = Empty.
  (** represent U and V as components of points in X **)
  apply (ReplE_impred X (fun x0:set => component_of X Tx x0) U HU).
  let x1. assume Hx1X: x1 :e X.
  assume HUeq: U = component_of X Tx x1.
  apply (ReplE_impred X (fun x0:set => component_of X Tx x0) V HV).
  let x2. assume Hx2X: x2 :e X.
  assume HVeql: V = component_of X Tx x2.
  (** show intersection must be empty, else equality would follow **)
  apply Empty_eq.
  let z. assume Hz: z :e U :/\: V.
  apply (binintersectE U V z Hz).
  assume HzU: z :e U.
  assume HzV: z :e V.
  claim HzComp1: z :e component_of X Tx x1.
  { rewrite <- HUeq. exact HzU. }
  claim HzComp2: z :e component_of X Tx x2.
  { rewrite <- HVeql. exact HzV. }
  (** z lies in X by definition of component_of **)
  claim HzX: z :e X.
  { exact (SepE1 X (fun y0:set => exists C:set, connected_space C (subspace_topology X Tx C) /\ x1 :e C /\ y0 :e C) z HzComp1). }
  (** component(z) = component(x1) and component(z) = component(x2) **)
  claim Heq1: component_of X Tx z = component_of X Tx x1.
  { exact (component_of_eq_if_in X Tx x1 z HTx Hx1X HzComp1). }
  claim Heq2: component_of X Tx z = component_of X Tx x2.
  { exact (component_of_eq_if_in X Tx x2 z HTx Hx2X HzComp2). }
  claim HcompEq: component_of X Tx x1 = component_of X Tx x2.
  { rewrite <- Heq1.
    rewrite Heq2.
    reflexivity. }
  claim HUVeq: U = V.
  { rewrite HUeq.
    rewrite HVeql.
    exact HcompEq. }
  apply FalseE.
  exact (Hneq HUVeq).
Qed.

(** from 25: quotient of locally connected space is locally connected **) 
(** LATEX VERSION: Quotients of locally connected spaces remain locally connected. **)
Theorem quotient_preserves_local_connectedness : forall X Tx Y f:set,
  quotient_map X Tx Y f ->
  locally_connected X Tx ->
  locally_connected Y (quotient_topology X Tx Y f).
let X Tx Y f.
assume Hquot: quotient_map X Tx Y f.
assume Hloc: locally_connected X Tx.
prove locally_connected Y (quotient_topology X Tx Y f).
set Q := quotient_topology X Tx Y f.
prove topology_on Y Q /\
  forall y:set, y :e Y ->
    forall U:set, U :e Q -> y :e U ->
      exists V:set, V :e Q /\ y :e V /\ V c= U /\ connected_space V (subspace_topology Y Q V).
apply andI.
- (** topology_on Y Q **)
  claim HTx: topology_on X Tx.
  { exact (locally_connected_topology X Tx Hloc). }
  exact (quotient_topology_is_topology X Tx Y f HTx Hquot).
- (** neighborhood property (stub) **)
  let y. assume HyY: y :e Y.
  let U. assume HU: U :e Q.
  assume HyU: y :e U.
  (** Goal: find V open in Q with yVU and V connected in the subspace topology. **)
  admit.
Qed.

(** from 25 Definition: quasicomponent equivalence relation **) 
(** LATEX VERSION: The quasicomponent of x consists of points that cannot be separated from x by a clopen set. **)
Definition quasicomponent_of : set -> set -> set -> set := fun X Tx x =>
  {y :e X | forall U:set, open_in X Tx U -> closed_in X Tx U -> x :e U -> y :e U}.

(** from 25: components vs quasicomponents **) 
(** LATEX VERSION: Components are contained in quasicomponents; in locally connected spaces they are equal. **)
Theorem components_vs_quasicomponents : forall X Tx:set,
  topology_on X Tx ->
  (forall x:set, component_of X Tx x c= quasicomponent_of X Tx x) /\
  (locally_connected X Tx -> forall x:set, x :e X -> component_of X Tx x = quasicomponent_of X Tx x).
let X Tx.
assume HTx: topology_on X Tx.
prove (forall x:set, component_of X Tx x c= quasicomponent_of X Tx x) /\
  (locally_connected X Tx -> forall x:set, x :e X -> component_of X Tx x = quasicomponent_of X Tx x).
claim Hsub: forall x:set, component_of X Tx x c= quasicomponent_of X Tx x.
{ let x.
  prove component_of X Tx x c= quasicomponent_of X Tx x.
  let y. assume Hy: y :e component_of X Tx x.
  prove y :e quasicomponent_of X Tx x.
  prove y :e {y0 :e X | forall U:set, open_in X Tx U -> closed_in X Tx U -> x :e U -> y0 :e U}.
  apply SepI.
  - exact (SepE1 X (fun y0:set => exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y0 :e C) y Hy).
  - let U.
    assume HUopen: open_in X Tx U.
    assume HUclosed: closed_in X Tx U.
    assume HxU: x :e U.
    prove y :e U.
    apply (xm (U = X)).
    + assume HUeqX: U = X.
      rewrite HUeqX.
      exact (SepE1 X (fun y0:set => exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y0 :e C) y Hy).
    + assume HUnX: U <> X.
      claim HUsubX: U c= X.
      { exact (open_in_subset X Tx U HUopen). }
      claim HUne: U <> Empty.
      { exact (elem_implies_nonempty U x HxU). }
      claim HsepUX: separation_of X U (X :\: U).
      { exact (separation_of_complement X U HUsubX HUne HUnX). }
      claim HUinTx: U :e Tx.
      { exact (andER (topology_on X Tx) (U :e Tx) HUopen). }
      claim HcompOpen: open_in X Tx (X :\: U).
      { exact (open_of_closed_complement X Tx U HUclosed). }
      claim HcompinTx: (X :\: U) :e Tx.
      { exact (andER (topology_on X Tx) ((X :\: U) :e Tx) HcompOpen). }
      claim HexC: exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y :e C.
      { exact (SepE2 X (fun y0:set => exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y0 :e C) y Hy). }
      apply HexC.
      let C. assume HC.
      claim HCconn: connected_space C (subspace_topology X Tx C).
      { exact (andEL (connected_space C (subspace_topology X Tx C))
                     (x :e C) (andEL (connected_space C (subspace_topology X Tx C) /\ x :e C) (y :e C) HC)). }
      claim HxC: x :e C.
      { exact (andER (connected_space C (subspace_topology X Tx C)) (x :e C)
                     (andEL (connected_space C (subspace_topology X Tx C) /\ x :e C) (y :e C) HC)). }
      claim HyC: y :e C.
      { exact (andER (connected_space C (subspace_topology X Tx C) /\ x :e C) (y :e C) HC). }
      claim HCsubX: C c= X.
      { exact (connected_subspace_subset X Tx C HTx HCconn). }
      claim Hside: C c= U \/ C c= (X :\: U).
      { exact (connected_subset_in_separation_side X Tx U (X :\: U) C HTx HCsubX HCconn HUinTx HcompinTx HsepUX). }
      apply (Hside (y :e U)).
      - assume HCsubU: C c= U.
        exact (HCsubU y HyC).
      - assume HCsubComp: C c= (X :\: U).
        claim HxComp: x :e X :\: U.
        { exact (HCsubComp x HxC). }
        claim HxNotU: x /:e U.
        { exact (setminusE2 X U x HxComp). }
        apply FalseE.
        exact (HxNotU HxU). }
claim Heq: locally_connected X Tx -> forall x:set, x :e X -> component_of X Tx x = quasicomponent_of X Tx x.
{ assume Hloc: locally_connected X Tx.
  let x. assume HxX: x :e X.
  prove component_of X Tx x = quasicomponent_of X Tx x.
  apply set_ext.
  - let y. assume Hy: y :e component_of X Tx x.
    exact (Hsub x y Hy).
  - let y. assume HyQ: y :e quasicomponent_of X Tx x.
    prove y :e component_of X Tx x.
    claim HUopen: open_in X Tx (component_of X Tx x).
    { exact (components_are_open_in_locally_connected X Tx Hloc x HxX). }
    claim HUclosed: closed_in X Tx (component_of X Tx x).
    { exact (components_are_closed X Tx HTx x HxX). }
    claim HxU: x :e component_of X Tx x.
    { exact (point_in_component X Tx x HTx HxX). }
    claim Hprop: forall U:set, open_in X Tx U -> closed_in X Tx U -> x :e U -> y :e U.
    { exact (SepE2 X (fun y0:set => forall U:set, open_in X Tx U -> closed_in X Tx U -> x :e U -> y0 :e U) y HyQ). }
    exact (Hprop (component_of X Tx x) HUopen HUclosed HxU). }
apply andI.
- exact Hsub.
- exact Heq.
Qed.

(** from 23 Exercise: components and path components of  **) 
(** LATEX VERSION: In the lower limit topology on R, every component is a singleton. **)
Theorem ex23_Rl_components :
  component_of R R_lower_limit_topology 0 = {0} /\
  (forall x:set, x :e R -> component_of R R_lower_limit_topology x = {x}).
prove component_of R R_lower_limit_topology 0 = {0} /\ (forall x:set, x :e R -> component_of R R_lower_limit_topology x = {x}).
apply andI.
- (** component_of ... 0 = {0} **)
  admit.
- (** all components are singletons **)
  let x. assume HxR: x :e R.
  admit.
Qed.

(** from 23 Exercise: components of ^ in product/uniform/box topologies **) 
(** LATEX VERSION: For R to the omega, compare components in product and box type topologies. **)
Theorem ex23_Romega_components :
  component_of (product_space omega (const_space_family omega R R_standard_topology)) (product_topology_full omega (const_space_family omega R R_standard_topology)) (const_family omega 0) =
    product_space omega (const_space_family omega R R_standard_topology) /\
  component_of (product_space omega (const_space_family omega R R_standard_topology)) (box_topology omega (const_space_family omega R R_standard_topology)) (const_family omega 0) =
    {f :e product_space omega (const_space_family omega R R_standard_topology) | exists F:set, finite F /\ forall i:set, i :e omega :\: F -> apply_fun f i = 0}.
prove component_of (product_space omega (const_space_family omega R R_standard_topology)) (product_topology_full omega (const_space_family omega R R_standard_topology)) (const_family omega 0) = product_space omega (const_space_family omega R R_standard_topology) /\ component_of (product_space omega (const_space_family omega R R_standard_topology)) (box_topology omega (const_space_family omega R R_standard_topology)) (const_family omega 0) = {f :e product_space omega (const_space_family omega R R_standard_topology) | exists F:set, finite F /\ forall i:set, i :e omega :\: F -> apply_fun f i = 0}.
apply andI.
- (** product topology: connected **)
  admit.
- (** box topology: finite support condition **)
  admit.
Qed.

(** from 23 Exercise: ordered square locally connected but not locally path connected **) 
(** LATEX VERSION: The ordered square is locally connected but not locally path connected. **)
Theorem ex23_ordered_square_locally_conn_not_pathconn :
  locally_connected ordered_square ordered_square_topology /\
  ~ locally_path_connected ordered_square ordered_square_topology.
prove locally_connected ordered_square ordered_square_topology /\ ~ locally_path_connected ordered_square ordered_square_topology.
apply andI.
- (** locally_connected **)
  admit.
- (** not locally_path_connected **)
  admit.
Qed.

(** from 23 Exercise: connected open subsets of locally path connected spaces are path connected **) 
(** LATEX VERSION: In a locally path connected space, every open connected subset is path connected. **)
Theorem ex23_connected_open_sets_path_connected : forall X Tx U:set,
  locally_path_connected X Tx -> open_in X Tx U -> connected_space U (subspace_topology X Tx U) -> path_connected_space U (subspace_topology X Tx U).
let X Tx U.
assume Hlpc: locally_path_connected X Tx.
assume HU: open_in X Tx U.
assume Hconn: connected_space U (subspace_topology X Tx U).
prove path_connected_space U (subspace_topology X Tx U).
set Tu := subspace_topology X Tx U.
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x:set, x :e X ->
                 forall V:set, V :e Tx -> x :e V ->
                   exists W:set, W :e Tx /\ x :e W /\ W c= V /\ path_connected_space W (subspace_topology X Tx W))
               Hlpc). }
claim Hlpcprop: forall x:set, x :e X ->
  forall V:set, V :e Tx -> x :e V ->
    exists W:set, W :e Tx /\ x :e W /\ W c= V /\ path_connected_space W (subspace_topology X Tx W).
{ exact (andER (topology_on X Tx)
               (forall x:set, x :e X ->
                 forall V:set, V :e Tx -> x :e V ->
                   exists W:set, W :e Tx /\ x :e W /\ W c= V /\ path_connected_space W (subspace_topology X Tx W))
               Hlpc). }
claim HUsubX: U c= X.
{ exact (open_in_subset X Tx U HU). }
claim HUinTx: U :e Tx.
{ exact (open_in_elem X Tx U HU). }
claim HtopU: topology_on U Tu.
{ exact (subspace_topology_is_topology X Tx U HTx HUsubX). }

(** locally path connectedness is inherited by open subspaces **)
claim HlpcU: locally_path_connected U Tu.
{ prove topology_on U Tu /\
    forall x:set, x :e U ->
      forall V:set, V :e Tu -> x :e V ->
        exists W:set, W :e Tu /\ x :e W /\ W c= V /\ path_connected_space W (subspace_topology U Tu W).
  apply andI.
  - exact HtopU.
  - let x. assume HxU: x :e U.
    let V. assume HV: V :e Tu.
    assume HxV: x :e V.
    claim HxX: x :e X.
    { exact (HUsubX x HxU). }
    claim HVpowU: V :e Power U.
    { exact (SepE1 (Power U) (fun V0:set => exists W0 :e Tx, V0 = W0 :/\: U) V HV). }
    claim HVrep: exists W0 :e Tx, V = W0 :/\: U.
    { exact (SepE2 (Power U) (fun V0:set => exists W0 :e Tx, V0 = W0 :/\: U) V HV). }
    apply HVrep.
    let W0. assume HW0pair.
    claim HW0: W0 :e Tx.
    { exact (andEL (W0 :e Tx) (V = W0 :/\: U) HW0pair). }
    claim HVeql: V = W0 :/\: U.
    { exact (andER (W0 :e Tx) (V = W0 :/\: U) HW0pair). }
    claim HxWU: x :e W0 :/\: U.
    { rewrite <- HVeql. exact HxV. }
    claim HxW0: x :e W0.
    { exact (binintersectE1 W0 U x HxWU). }
    claim HWUinTx: (W0 :/\: U) :e Tx.
    { exact (topology_binintersect_closed X Tx W0 U HTx HW0 HUinTx). }
    claim HexW: exists W:set, W :e Tx /\ x :e W /\ W c= (W0 :/\: U) /\ path_connected_space W (subspace_topology X Tx W).
	    { exact (Hlpcprop x HxX (W0 :/\: U) HWUinTx HxWU). }
	    apply HexW.
	    let W. assume HW.
	    claim HWL: (W :e Tx /\ x :e W) /\ W c= (W0 :/\: U).
	    { exact (andEL ((W :e Tx /\ x :e W) /\ W c= (W0 :/\: U))
	                   (path_connected_space W (subspace_topology X Tx W)) HW). }
	    claim HWpath: path_connected_space W (subspace_topology X Tx W).
	    { exact (andER ((W :e Tx /\ x :e W) /\ W c= (W0 :/\: U))
	                   (path_connected_space W (subspace_topology X Tx W)) HW). }
	    claim HW12: W :e Tx /\ x :e W.
	    { exact (andEL (W :e Tx /\ x :e W) (W c= (W0 :/\: U)) HWL). }
	    claim HWsubWU: W c= (W0 :/\: U).
	    { exact (andER (W :e Tx /\ x :e W) (W c= (W0 :/\: U)) HWL). }
	    claim HWTx: W :e Tx.
	    { exact (andEL (W :e Tx) (x :e W) HW12). }
	    claim HxW: x :e W.
	    { exact (andER (W :e Tx) (x :e W) HW12). }
    claim HWsubU: W c= U.
    { let z. assume HzW: z :e W.
      claim HzWU: z :e W0 :/\: U.
      { exact (HWsubWU z HzW). }
      exact (binintersectE2 W0 U z HzWU). }
    claim HWpowU: W :e Power U.
    { exact (PowerI U W HWsubU). }
    claim HWUeq: W = W :/\: U.
	    { apply set_ext.
	      - let z. assume HzW: z :e W.
	        exact (binintersectI W U z HzW (HWsubU z HzW)).
	      - let z. assume HzWU: z :e W :/\: U.
	        exact (binintersectE1 W U z HzWU). }
	    claim HWTu: W :e Tu.
	    { claim HexWopen: open_in U Tu W.
	      { claim Hex: exists V0 :e Tx, W = V0 :/\: U.
	        { witness W.
	          apply andI.
	          - exact HWTx.
	          - exact HWUeq. }
	        exact (iffER (open_in U Tu W)
	                     (exists V0 :e Tx, W = V0 :/\: U)
	                     (open_in_subspace_iff X Tx U W HTx HUsubX HWsubU)
	                     Hex). }
	      exact (open_in_elem U Tu W HexWopen). }
    claim Hsubtrans: subspace_topology U Tu W = subspace_topology X Tx W.
    { exact (ex16_1_subspace_transitive X Tx U W HTx HUsubX HWsubU). }
    claim HWpathU: path_connected_space W (subspace_topology U Tu W).
    { rewrite Hsubtrans.
      exact HWpath. }
    witness W.
    prove W :e Tu /\ x :e W /\ W c= V /\ path_connected_space W (subspace_topology U Tu W).
    apply andI.
    - apply andI.
      + apply andI.
        * exact HWTu.
        * exact HxW.
      + prove W c= V.
        rewrite HVeql.
        exact HWsubWU.
    - exact HWpathU. }

prove topology_on U Tu /\
  forall x y:set, x :e U -> y :e U ->
    exists p:set, path_between U x y p /\ continuous_map unit_interval unit_interval_topology U Tu p.
apply andI.
- exact HtopU.
- let x y.
  assume HxU: x :e U.
  assume HyU: y :e U.
  set Pc := path_component_of U Tu x.
  claim HPcOpen: open_in U Tu Pc.
  { exact (path_components_open U Tu HlpcU x HxU). }
  claim HPcInTu: Pc :e Tu.
  { exact (open_in_elem U Tu Pc HPcOpen). }
  claim HxPc: x :e Pc.
  { exact (path_component_reflexive U Tu x HtopU HxU). }
  claim HPcNe: Pc <> Empty.
  { exact (elem_implies_nonempty Pc x HxPc). }
  (** show Pc is closed by showing its complement is open **)
  set D := U :\: Pc.
  set Fam := {path_component_of U Tu z | z :e D}.
  claim HFsub: Fam c= Tu.
  { let W. assume HW: W :e Fam.
    apply (ReplE_impred D (fun z:set => path_component_of U Tu z) W HW).
    let z. assume HzD: z :e D.
    assume HWeq: W = path_component_of U Tu z.
    claim HzU: z :e U.
    { exact (setminusE1 U Pc z HzD). }
    claim Hopenz: open_in U Tu (path_component_of U Tu z).
    { exact (path_components_open U Tu HlpcU z HzU). }
    claim HinTu: path_component_of U Tu z :e Tu.
    { exact (open_in_elem U Tu (path_component_of U Tu z) Hopenz). }
    rewrite HWeq.
    exact HinTu. }
  claim HUnionTu: Union Fam :e Tu.
  { exact (topology_union_closed U Tu Fam HtopU HFsub). }
  claim HUnionEq: Union Fam = D.
  { (** use equivalence relation properties of path components **)
    claim Heqrel: (forall z:set, z :e U -> z :e path_component_of U Tu z) /\
      (forall a b:set, a :e U -> b :e U -> b :e path_component_of U Tu a -> a :e path_component_of U Tu b) /\
      (forall a b c:set, a :e U -> b :e U -> c :e U ->
         b :e path_component_of U Tu a -> c :e path_component_of U Tu b ->
         c :e path_component_of U Tu a).
    { exact (path_components_equivalence_relation U Tu HtopU). }
    claim H12: (forall z:set, z :e U -> z :e path_component_of U Tu z) /\
      (forall a b:set, a :e U -> b :e U -> b :e path_component_of U Tu a -> a :e path_component_of U Tu b).
    { exact (andEL ((forall z:set, z :e U -> z :e path_component_of U Tu z) /\
                    (forall a b:set, a :e U -> b :e U -> b :e path_component_of U Tu a -> a :e path_component_of U Tu b))
                   (forall a b c:set, a :e U -> b :e U -> c :e U ->
                      b :e path_component_of U Tu a -> c :e path_component_of U Tu b ->
                      c :e path_component_of U Tu a)
                   Heqrel). }
    claim Hrefl: forall z:set, z :e U -> z :e path_component_of U Tu z.
    { exact (andEL (forall z:set, z :e U -> z :e path_component_of U Tu z)
                   (forall a b:set, a :e U -> b :e U -> b :e path_component_of U Tu a -> a :e path_component_of U Tu b)
                   H12). }
    claim Hsym: forall a b:set, a :e U -> b :e U -> b :e path_component_of U Tu a -> a :e path_component_of U Tu b.
    { exact (andER (forall z:set, z :e U -> z :e path_component_of U Tu z)
                   (forall a b:set, a :e U -> b :e U -> b :e path_component_of U Tu a -> a :e path_component_of U Tu b)
                   H12). }
    claim Htrans: forall a b c:set, a :e U -> b :e U -> c :e U ->
      b :e path_component_of U Tu a -> c :e path_component_of U Tu b ->
      c :e path_component_of U Tu a.
    { exact (andER ((forall z:set, z :e U -> z :e path_component_of U Tu z) /\
                    (forall a b:set, a :e U -> b :e U -> b :e path_component_of U Tu a -> a :e path_component_of U Tu b))
                   (forall a b c:set, a :e U -> b :e U -> c :e U ->
                      b :e path_component_of U Tu a -> c :e path_component_of U Tu b ->
                      c :e path_component_of U Tu a)
                   Heqrel). }
    apply set_ext.
    - let t. assume HtU: t :e Union Fam.
      apply (UnionE Fam t HtU).
      let W. assume Hex: t :e W /\ W :e Fam.
      claim HWt: t :e W.
      { exact (andEL (t :e W) (W :e Fam) Hex). }
      claim HWFam: W :e Fam.
      { exact (andER (t :e W) (W :e Fam) Hex). }
      claim HWdef: exists z :e D, W = path_component_of U Tu z.
      { exact (ReplE D (fun z:set => path_component_of U Tu z) W HWFam). }
      apply HWdef.
      let z. assume Hzpair.
      claim HzD: z :e D.
      { exact (andEL (z :e D) (W = path_component_of U Tu z) Hzpair). }
      claim HWeq: W = path_component_of U Tu z.
      { exact (andER (z :e D) (W = path_component_of U Tu z) Hzpair). }
      claim HtW: t :e W.
      { exact HWt. }
      claim HtPc_z: t :e path_component_of U Tu z.
      { rewrite <- HWeq.
        exact HtW. }
      claim HtU0: t :e U.
      { exact (SepE1 U (fun y0:set => exists p:set, function_on p unit_interval U /\
                 continuous_map unit_interval unit_interval_topology U Tu p /\
                 apply_fun p 0 = z /\ apply_fun p 1 = y0) t HtPc_z). }
      prove t :e D.
      prove t :e U :\: Pc.
      apply setminusI.
      - exact HtU0.
      - assume HtPc: t :e Pc.
        claim HzU: z :e U.
        { exact (setminusE1 U Pc z HzD). }
        claim HzNotPc: z /:e Pc.
        { exact (setminusE2 U Pc z HzD). }
        claim HzPc_t: z :e path_component_of U Tu t.
        { exact (Hsym z t HzU HtU0 HtPc_z). }
        claim HzPc_x: z :e path_component_of U Tu x.
        { exact (Htrans x t z HxU HtU0 HzU HtPc HzPc_t). }
        exact (HzNotPc HzPc_x).
    - let t. assume HtD: t :e D.
      prove t :e Union Fam.
      claim HtU0: t :e U.
      { exact (setminusE1 U Pc t HtD). }
      claim HtFam: path_component_of U Tu t :e Fam.
      { exact (ReplI D (fun z:set => path_component_of U Tu z) t HtD). }
      claim HtPc_t: t :e path_component_of U Tu t.
      { exact (Hrefl t HtU0). }
      exact (UnionI Fam t (path_component_of U Tu t) HtPc_t HtFam). }
  claim HDinTu: D :e Tu.
  { rewrite <- HUnionEq.
    exact HUnionTu. }
  claim HPcClosed: closed_in U Tu Pc.
  { apply (closed_inI U Tu Pc).
    - exact HtopU.
    - prove Pc c= U.
      let t. assume HtPc: t :e Pc.
      exact (SepE1 U (fun y0:set => exists p:set, function_on p unit_interval U /\
             continuous_map unit_interval unit_interval_topology U Tu p /\
             apply_fun p 0 = x /\ apply_fun p 1 = y0) t HtPc).
    - witness D.
      apply andI.
      + exact HDinTu.
      + (** Pc = U \\ D **)
        apply set_ext.
        * let t. assume HtPc: t :e Pc.
          prove t :e U :\: D.
          apply setminusI.
          - exact (SepE1 U (fun y0:set => exists p:set, function_on p unit_interval U /\
               continuous_map unit_interval unit_interval_topology U Tu p /\
               apply_fun p 0 = x /\ apply_fun p 1 = y0) t HtPc).
          - assume HtD: t :e D.
             claim HtNotPc: t /:e Pc.
             { exact (setminusE2 U Pc t HtD). }
             exact (HtNotPc HtPc).
        * let t. assume HtUD: t :e U :\: D.
          claim HtU: t :e U.
          { exact (setminusE1 U D t HtUD). }
          claim HtNotD: t /:e D.
          { exact (setminusE2 U D t HtUD). }
          apply (xm (t :e Pc)).
          - assume HtPc: t :e Pc. exact HtPc.
	          - assume HtNotPc: t /:e Pc.
	             apply FalseE.
	             apply HtNotD.
	             exact (setminusI U Pc t HtU HtNotPc). } 
	  (** conclude Pc = U by connectedness and clopen property **)
	  claim HnoClopen: ~(exists B:set, B <> Empty /\ B <> U /\ open_in U Tu B /\ closed_in U Tu B).
	  { exact (iffEL (connected_space U Tu)
	                 (~(exists B:set, B <> Empty /\ B <> U /\ open_in U Tu B /\ closed_in U Tu B))
                 (connected_iff_no_nontrivial_clopen U Tu HtopU) Hconn). }
  claim HPcEqU: Pc = U.
  { apply (xm (Pc = U)).
    - assume H. exact H.
    - assume Hneq: Pc <> U.
      apply FalseE.
      apply HnoClopen.
      witness Pc.
      prove Pc <> Empty /\ Pc <> U /\ open_in U Tu Pc /\ closed_in U Tu Pc.
      apply andI.
      - apply andI.
        + apply andI.
          * exact HPcNe.
          * exact Hneq.
        + exact HPcOpen.
      - exact HPcClosed. }
  claim HyPc: y :e Pc.
  { rewrite HPcEqU.
    exact HyU. }
  (** extract a path witness from membership in the path component **)
  claim HexPath: exists p:set,
    function_on p unit_interval U /\
    continuous_map unit_interval unit_interval_topology U Tu p /\
    apply_fun p 0 = x /\ apply_fun p 1 = y.
  { exact (SepE2 U (fun y0:set => exists p:set, function_on p unit_interval U /\
           continuous_map unit_interval unit_interval_topology U Tu p /\
           apply_fun p 0 = x /\ apply_fun p 1 = y0) y HyPc). }
  apply HexPath.
  let p. assume Hp.
  witness p.
  prove path_between U x y p /\ continuous_map unit_interval unit_interval_topology U Tu p.
  claim HpAB0: (function_on p unit_interval U /\
                continuous_map unit_interval unit_interval_topology U Tu p) /\
               apply_fun p 0 = x.
  { exact (andEL ((function_on p unit_interval U /\
                   continuous_map unit_interval unit_interval_topology U Tu p) /\
                  apply_fun p 0 = x)
                 (apply_fun p 1 = y) Hp). }
  claim Hp1: apply_fun p 1 = y.
  { exact (andER ((function_on p unit_interval U /\
                   continuous_map unit_interval unit_interval_topology U Tu p) /\
                  apply_fun p 0 = x)
                 (apply_fun p 1 = y) Hp). }
  claim HpAB: function_on p unit_interval U /\
              continuous_map unit_interval unit_interval_topology U Tu p.
  { exact (andEL (function_on p unit_interval U /\
                  continuous_map unit_interval unit_interval_topology U Tu p)
                 (apply_fun p 0 = x) HpAB0). }
  claim Hp0: apply_fun p 0 = x.
  { exact (andER (function_on p unit_interval U /\
                  continuous_map unit_interval unit_interval_topology U Tu p)
                 (apply_fun p 0 = x) HpAB0). }
  claim HpFun: function_on p unit_interval U.
  { exact (andEL (function_on p unit_interval U)
                 (continuous_map unit_interval unit_interval_topology U Tu p)
                 HpAB). }
  claim HpCont: continuous_map unit_interval unit_interval_topology U Tu p.
  { exact (andER (function_on p unit_interval U)
                 (continuous_map unit_interval unit_interval_topology U Tu p)
                 HpAB). }
  apply andI.
  - prove function_on p unit_interval U /\ apply_fun p 0 = x /\ apply_fun p 1 = y.
    apply andI.
    + apply andI.
      - exact HpFun.
      - exact Hp0.
    + exact Hp1.
  - exact HpCont.
Qed.

(** from 23 Exercise: examples of path connected but not locally connected subsets of ^2 **) 
(** LATEX VERSION: There exists a subset of the plane that is path connected but not locally connected. **)
Theorem ex23_path_connected_not_locally_connected_examples :
  exists A:set,
    A c= EuclidPlane /\ path_connected_space A (subspace_topology EuclidPlane R2_standard_topology A) /\
    ~ locally_connected A (subspace_topology EuclidPlane R2_standard_topology A).
prove exists A:set,
    A c= EuclidPlane /\ path_connected_space A (subspace_topology EuclidPlane R2_standard_topology A) /\
    ~ locally_connected A (subspace_topology EuclidPlane R2_standard_topology A).
admit.
Qed.

(** from 26 Definition: compact space **) 
(** LATEX VERSION: A space is compact if every open cover has a finite subcover. **)
Definition open_cover_of : set -> set -> set -> prop := fun X Tx Fam =>
  topology_on X Tx /\ Fam c= Power X /\ X c= Union Fam /\ (forall U:set, U :e Fam -> U :e Tx).

(** Helper: extract topology_on from open_cover_of **)
Theorem open_cover_of_topology : forall X Tx Fam:set,
  open_cover_of X Tx Fam -> topology_on X Tx.
let X Tx Fam.
assume H: open_cover_of X Tx Fam.
claim H0: ((topology_on X Tx /\ Fam c= Power X) /\ X c= Union Fam) /\ (forall U:set, U :e Fam -> U :e Tx).
{ exact H. }
claim H1: (topology_on X Tx /\ Fam c= Power X) /\ X c= Union Fam.
{ exact (andEL ((topology_on X Tx /\ Fam c= Power X) /\ X c= Union Fam)
               (forall U:set, U :e Fam -> U :e Tx)
               H0). }
claim H2: topology_on X Tx /\ Fam c= Power X.
{ exact (andEL (topology_on X Tx /\ Fam c= Power X)
               (X c= Union Fam)
               H1). }
exact (andEL (topology_on X Tx) (Fam c= Power X) H2).
Qed.

(** Helper: extract Fam c= Power X from open_cover_of **)
Theorem open_cover_of_family_sub : forall X Tx Fam:set,
  open_cover_of X Tx Fam -> Fam c= Power X.
let X Tx Fam.
assume H: open_cover_of X Tx Fam.
claim H0: ((topology_on X Tx /\ Fam c= Power X) /\ X c= Union Fam) /\ (forall U:set, U :e Fam -> U :e Tx).
{ exact H. }
claim H1: (topology_on X Tx /\ Fam c= Power X) /\ X c= Union Fam.
{ exact (andEL ((topology_on X Tx /\ Fam c= Power X) /\ X c= Union Fam)
               (forall U:set, U :e Fam -> U :e Tx)
               H0). }
claim H2: topology_on X Tx /\ Fam c= Power X.
{ exact (andEL (topology_on X Tx /\ Fam c= Power X)
               (X c= Union Fam)
               H1). }
exact (andER (topology_on X Tx) (Fam c= Power X) H2).
Qed.

(** Helper: extract cover property X c= Union Fam from open_cover_of **)
Theorem open_cover_of_covers : forall X Tx Fam:set,
  open_cover_of X Tx Fam -> X c= Union Fam.
let X Tx Fam.
assume H: open_cover_of X Tx Fam.
claim H0: ((topology_on X Tx /\ Fam c= Power X) /\ X c= Union Fam) /\ (forall U:set, U :e Fam -> U :e Tx).
{ exact H. }
claim H1: (topology_on X Tx /\ Fam c= Power X) /\ X c= Union Fam.
{ exact (andEL ((topology_on X Tx /\ Fam c= Power X) /\ X c= Union Fam)
               (forall U:set, U :e Fam -> U :e Tx)
               H0). }
exact (andER (topology_on X Tx /\ Fam c= Power X) (X c= Union Fam) H1).
Qed.

(** Helper: extract openness of cover members from open_cover_of **)
Theorem open_cover_of_members_open : forall X Tx Fam U:set,
  open_cover_of X Tx Fam -> U :e Fam -> U :e Tx.
let X Tx Fam U.
assume H: open_cover_of X Tx Fam.
assume HU: U :e Fam.
claim H0: ((topology_on X Tx /\ Fam c= Power X) /\ X c= Union Fam) /\ (forall U0:set, U0 :e Fam -> U0 :e Tx).
{ exact H. }
claim Hprop: forall U0:set, U0 :e Fam -> U0 :e Tx.
{ exact (andER ((topology_on X Tx /\ Fam c= Power X) /\ X c= Union Fam)
               (forall U0:set, U0 :e Fam -> U0 :e Tx)
               H0). }
exact (Hprop U HU).
Qed.

Definition has_finite_subcover : set -> set -> set -> prop := fun X Tx Fam =>
  exists G:set, G c= Fam /\ finite G /\ X c= Union G.

(** Helper: introduce `has_finite_subcover` with an explicit witness. **)
Theorem has_finite_subcoverI : forall X Tx Fam G:set,
  G c= Fam /\ finite G /\ X c= Union G -> has_finite_subcover X Tx Fam.
let X Tx Fam G.
assume HG: G c= Fam /\ finite G /\ X c= Union G.
prove has_finite_subcover X Tx Fam.
prove exists G1:set, G1 c= Fam /\ finite G1 /\ X c= Union G1.
witness G.
exact HG.
Qed.

Definition compact_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\ forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam.

(** Helper: extract topology_on from compact_space **)
Theorem compact_space_topology : forall X Tx:set,
  compact_space X Tx -> topology_on X Tx.
let X Tx.
assume H: compact_space X Tx.
exact (andEL (topology_on X Tx)
             (forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam)
             H).
Qed.

(** Helper: extract finite subcover property from compact_space **)
Theorem compact_space_subcover_property : forall X Tx:set,
  compact_space X Tx ->
  forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam.
let X Tx.
assume H: compact_space X Tx.
claim Hprop: forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam.
{ exact (andER (topology_on X Tx)
               (forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam)
               H). }
exact Hprop.
Qed.

(** from 26: open cover characterization **) 
(** LATEX VERSION: In a compact space, every open cover has a finite subcover. **)
Theorem Heine_Borel_subcover : forall X Tx Fam:set,
  compact_space X Tx ->
  open_cover_of X Tx Fam ->
  has_finite_subcover X Tx Fam.
let X Tx Fam.
assume Hcomp: compact_space X Tx.
assume HFam: open_cover_of X Tx Fam.
prove has_finite_subcover X Tx Fam.
exact (compact_space_subcover_property X Tx Hcomp Fam HFam).
Qed.

(** from 26 Lemma 26.1: covering a subspace by ambient opens **)
(** LATEX VERSION: A subspace Y is compact iff every cover of Y by open sets of X has a finite subcover. **)
(** FIXED: Use ambient cover condition (Fam c= Tx /\ Y c= Union Fam) instead of open_cover_of Y Tx Fam, since Tx is a topology on X. **)
Theorem compact_subspace_via_ambient_covers : forall X Tx Y:set,
  topology_on X Tx -> Y c= X ->
  (compact_space Y (subspace_topology X Tx Y) <->
    forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam).
let X Tx Y.
assume HTx: topology_on X Tx.
assume HY: Y c= X.
prove compact_space Y (subspace_topology X Tx Y) <->
    forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam.
set Ty := subspace_topology X Tx Y.
apply iffI.
- (** -> **)
  assume Hcomp: compact_space Y Ty.
  prove forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam.
  let Fam. assume Hcov: Fam c= Tx /\ Y c= Union Fam.
  claim HFamSub: Fam c= Tx.
  { exact (andEL (Fam c= Tx) (Y c= Union Fam) Hcov). }
  claim HYcov: Y c= Union Fam.
  { exact (andER (Fam c= Tx) (Y c= Union Fam) Hcov). }
  (** Turn the ambient cover into a subspace open cover by intersecting with Y. **)
  set FamY := {U :/\: Y|U :e Fam}.
  claim HtopY: topology_on Y Ty.
  { exact (andEL (topology_on Y Ty)
                 (forall Fam:set, open_cover_of Y Ty Fam -> has_finite_subcover Y Ty Fam)
                 Hcomp). }
  claim HcoverFamY: open_cover_of Y Ty FamY.
  { prove topology_on Y Ty /\ FamY c= Power Y /\ Y c= Union FamY /\ (forall U:set, U :e FamY -> U :e Ty).
    (** conjunction is left-associative: (((A /\ B) /\ C) /\ D) **)
    apply andI.
    - (** (A /\ B) /\ C **)
      apply andI.
      + (** A /\ B **)
        apply andI.
        * exact HtopY.
        * (** FamY c= Power Y **)
          let W. assume HW: W :e FamY.
          prove W :e Power Y.
          apply (ReplE_impred Fam (fun U:set => U :/\: Y) W HW).
          let U. assume HUfam: U :e Fam.
          assume HWeq: W = U :/\: Y.
          rewrite HWeq.
          apply PowerI.
          exact (binintersect_Subq_2 U Y).
      + (** Y c= Union FamY **)
        let y. assume HyY: y :e Y.
        prove y :e Union FamY.
        claim HyUnionFam: y :e Union Fam.
        { exact (HYcov y HyY). }
        apply (UnionE_impred Fam y HyUnionFam).
        let U. assume HyU: y :e U.
        assume HUfam: U :e Fam.
        prove y :e Union FamY.
        apply (UnionI FamY y (U :/\: Y)).
        - prove y :e U :/\: Y.
          exact (binintersectI U Y y HyU HyY).
        - prove (U :/\: Y) :e FamY.
          exact (ReplI Fam (fun V:set => V :/\: Y) U HUfam).
    - (** each cover element is open in the subspace topology **)
      let W. assume HW: W :e FamY.
      prove W :e Ty.
      apply (ReplE_impred Fam (fun U:set => U :/\: Y) W HW).
      let U. assume HUfam: U :e Fam.
      assume HWeq: W = U :/\: Y.
      rewrite HWeq.
      prove (U :/\: Y) :e subspace_topology X Tx Y.
      prove (U :/\: Y) :e {U0 :e Power Y | exists V :e Tx, U0 = V :/\: Y}.
      apply SepI.
      + apply PowerI.
        exact (binintersect_Subq_2 U Y).
      + prove exists V :e Tx, U :/\: Y = V :/\: Y.
        witness U.
        apply andI.
        * exact (HFamSub U HUfam).
        * reflexivity. }
  (** Apply compactness of Y in the subspace topology. **)
  claim Hsubcover: forall Fam0:set, open_cover_of Y Ty Fam0 -> has_finite_subcover Y Ty Fam0.
  { exact (andER (topology_on Y Ty)
                 (forall Fam0:set, open_cover_of Y Ty Fam0 -> has_finite_subcover Y Ty Fam0)
                 Hcomp). }
  claim HfinY: has_finite_subcover Y Ty FamY.
  { exact (Hsubcover FamY HcoverFamY). }
  apply HfinY.
  let GY. assume HGY: GY c= FamY /\ finite GY /\ Y c= Union GY.
  (** conjunction is left-associative: (A /\ B) /\ C **)
  claim HGYleft: GY c= FamY /\ finite GY.
  { exact (andEL (GY c= FamY /\ finite GY) (Y c= Union GY) HGY). }
  claim HGYsub: GY c= FamY.
  { exact (andEL (GY c= FamY) (finite GY) HGYleft). }
  claim HGYfin: finite GY.
  { exact (andER (GY c= FamY) (finite GY) HGYleft). }
  claim HGYcov: Y c= Union GY.
  { exact (andER (GY c= FamY /\ finite GY) (Y c= Union GY) HGY). }
	  (** Choose, for each W in GY, an ambient set U in Fam with W = U /\ Y. **)
	  set pickU := fun W:set => Eps_i (fun U:set => U :e Fam /\ W = U :/\: Y).
	  set G := {pickU W|W :e GY}.
		  prove exists G1:set, G1 c= Fam /\ finite G1 /\ Y c= Union G1.
		  witness G.
		  prove G c= Fam /\ finite G /\ Y c= Union G.
	  apply andI.
  - apply andI.
    + (** G c= Fam **)
      let U. assume HU: U :e G.
      prove U :e Fam.
      apply (ReplE_impred GY (fun W:set => pickU W) U HU).
      let W. assume HWGY: W :e GY.
      assume HeqU: U = pickU W.
      rewrite HeqU.
      (** show pickU W is in Fam using epsilon **)
      claim HWFamY: W :e FamY.
      { exact (HGYsub W HWGY). }
      claim HexU: exists U0:set, U0 :e Fam /\ W = U0 :/\: Y.
      { apply (ReplE_impred Fam (fun U1:set => U1 :/\: Y) W HWFamY).
        let U0. assume HU0fam: U0 :e Fam.
        assume HW0: W = U0 :/\: Y.
        witness U0.
        apply andI.
        - exact HU0fam.
        - exact HW0. }
      (** apply epsilon to obtain membership in Fam **)
      apply HexU.
      let U0. assume HU0pair: U0 :e Fam /\ W = U0 :/\: Y.
      claim HU0: U0 :e Fam.
      { exact (andEL (U0 :e Fam) (W = U0 :/\: Y) HU0pair). }
      exact (andEL (pickU W :e Fam) (W = pickU W :/\: Y)
                   (Eps_i_ax (fun U1:set => U1 :e Fam /\ W = U1 :/\: Y) U0 HU0pair)).
    + (** finite G **)
      exact (Repl_finite (fun W:set => pickU W) GY HGYfin).
  - (** Y c= Union G **)
    let y. assume HyY: y :e Y.
    prove y :e Union G.
    claim HyUGY: y :e Union GY.
    { exact (HGYcov y HyY). }
    apply (UnionE_impred GY y HyUGY).
    let W. assume HyW: y :e W.
    assume HWGY: W :e GY.
    prove y :e Union G.
    (** show y in pickU W **)
    claim HWFamY: W :e FamY.
    { exact (HGYsub W HWGY). }
    claim HexU: exists U0:set, U0 :e Fam /\ W = U0 :/\: Y.
    { apply (ReplE_impred Fam (fun U1:set => U1 :/\: Y) W HWFamY).
      let U0. assume HU0fam: U0 :e Fam.
      assume HW0: W = U0 :/\: Y.
      witness U0.
      apply andI.
      - exact HU0fam.
      - exact HW0. }
    claim Hpick: W = pickU W :/\: Y.
    { apply HexU.
      let U0. assume HU0pair: U0 :e Fam /\ W = U0 :/\: Y.
      exact (andER (pickU W :e Fam) (W = pickU W :/\: Y)
                   (Eps_i_ax (fun U1:set => U1 :e Fam /\ W = U1 :/\: Y) U0 HU0pair)). }
	  claim HyInPick: y :e pickU W.
	  { claim HyWY: y :e pickU W :/\: Y.
	    { rewrite <- Hpick at 1.
	      exact HyW. }
	    exact (binintersectE1 (pickU W) Y y HyWY). }
	    exact (UnionI G y (pickU W) HyInPick
	                  (ReplI GY (fun W0:set => pickU W0) W HWGY)).

- (** <- **)
  assume Hprop: forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam.
  prove compact_space Y Ty.
  prove topology_on Y Ty /\ forall Fam:set, open_cover_of Y Ty Fam -> has_finite_subcover Y Ty Fam.
  apply andI.
  - exact (subspace_topology_is_topology X Tx Y HTx HY).
	  - let Fam0. assume Hcov0: open_cover_of Y Ty Fam0.
	    prove has_finite_subcover Y Ty Fam0.
	    (** Extract cover facts **)
	    (** open_cover_of Y Ty Fam0 is left-associative: (((A /\ B) /\ C) /\ D) **)
	    claim Hcov0_ABC: (topology_on Y Ty /\ Fam0 c= Power Y) /\ Y c= Union Fam0.
	    { exact (andEL ((topology_on Y Ty /\ Fam0 c= Power Y) /\ Y c= Union Fam0)
	                   (forall U:set, U :e Fam0 -> U :e Ty) Hcov0). }
	    claim Hcov0_AB: topology_on Y Ty /\ Fam0 c= Power Y.
	    { exact (andEL (topology_on Y Ty /\ Fam0 c= Power Y) (Y c= Union Fam0) Hcov0_ABC). }
	    claim HF0subPow: Fam0 c= Power Y.
	    { exact (andER (topology_on Y Ty) (Fam0 c= Power Y) Hcov0_AB). }
	    claim HYcov0: Y c= Union Fam0.
	    { exact (andER (topology_on Y Ty /\ Fam0 c= Power Y) (Y c= Union Fam0) Hcov0_ABC). }
	    claim HF0open: forall U:set, U :e Fam0 -> U :e Ty.
	    { exact (andER ((topology_on Y Ty /\ Fam0 c= Power Y) /\ Y c= Union Fam0)
	                   (forall U:set, U :e Fam0 -> U :e Ty) Hcov0). }

    (** For each W in Fam0 choose an ambient open V in Tx with W = V /\ Y. **)
    set Vof := fun W:set => Eps_i (fun V:set => V :e Tx /\ W = V :/\: Y).
    set Fam := {Vof W|W :e Fam0}.
    claim HFamSub: Fam c= Tx.
    { let V. assume HV: V :e Fam.
      prove V :e Tx.
      apply (ReplE_impred Fam0 (fun W:set => Vof W) V HV).
      let W. assume HW: W :e Fam0.
      assume HVeq: V = Vof W.
      rewrite HVeq.
      (** epsilon yields Vof W in Tx **)
      claim HexV: exists V0:set, V0 :e Tx /\ W = V0 :/\: Y.
      { claim HWty: W :e Ty.
        { exact (HF0open W HW). }
        exact (SepE2 (Power Y) (fun U0:set => exists V0 :e Tx, U0 = V0 :/\: Y) W HWty). }
      apply HexV.
      let V0. assume HV0pair: V0 :e Tx /\ W = V0 :/\: Y.
      exact (andEL (Vof W :e Tx) (W = Vof W :/\: Y)
                   (Eps_i_ax (fun V1:set => V1 :e Tx /\ W = V1 :/\: Y) V0 HV0pair)). }

    claim HYcovFam: Y c= Union Fam.
    { let y. assume HyY: y :e Y.
      prove y :e Union Fam.
      claim HyUF0: y :e Union Fam0.
      { exact (HYcov0 y HyY). }
      apply (UnionE_impred Fam0 y HyUF0).
      let W. assume HyW: y :e W.
      assume HW: W :e Fam0.
      prove y :e Union Fam.
      claim HyV: y :e Vof W.
      { (** y in Vof W **)
        claim HexV: exists V0:set, V0 :e Tx /\ W = V0 :/\: Y.
        { claim HWty: W :e Ty.
          { exact (HF0open W HW). }
          exact (SepE2 (Power Y) (fun U0:set => exists V0 :e Tx, U0 = V0 :/\: Y) W HWty). }
        claim Hpick: W = Vof W :/\: Y.
        { apply HexV.
          let V0. assume HV0pair: V0 :e Tx /\ W = V0 :/\: Y.
          exact (andER (Vof W :e Tx) (W = Vof W :/\: Y)
                       (Eps_i_ax (fun V1:set => V1 :e Tx /\ W = V1 :/\: Y) V0 HV0pair)). }
        claim HyWY: y :e Vof W :/\: Y.
        { rewrite <- Hpick at 1.
          exact HyW. }
        exact (binintersectE1 (Vof W) Y y HyWY). }
      claim HVFam: (Vof W) :e Fam.
      { exact (ReplI Fam0 (fun W0:set => Vof W0) W HW). }
      exact (UnionI Fam y (Vof W) HyV HVFam). }

    (** Apply the ambient-cover property to get finite subcover G of Fam **)
    claim Hfin: has_finite_subcover Y Tx Fam.
    { exact (Hprop Fam (andI (Fam c= Tx) (Y c= Union Fam) HFamSub HYcovFam)). }
	    apply Hfin.
	    let G. assume HG: G c= Fam /\ finite G /\ Y c= Union G.
	    (** conjunction is left-associative: (A /\ B) /\ C **)
	    claim HGleft: G c= Fam /\ finite G.
	    { exact (andEL (G c= Fam /\ finite G) (Y c= Union G) HG). }
	    claim HGsub: G c= Fam.
	    { exact (andEL (G c= Fam) (finite G) HGleft). }
	    claim HGfin: finite G.
	    { exact (andER (G c= Fam) (finite G) HGleft). }
	    claim HGcov: Y c= Union G.
	    { exact (andER (G c= Fam /\ finite G) (Y c= Union G) HG). }

	    (** Convert G back to a finite subfamily of Fam0. **)
	    set Wof := fun V:set => Eps_i (fun W:set => W :e Fam0 /\ V = Vof W).
	    set G0 := {Wof V|V :e G}.
	    prove exists G1:set, G1 c= Fam0 /\ finite G1 /\ Y c= Union G1.
	    witness G0.
	    prove G0 c= Fam0 /\ finite G0 /\ Y c= Union G0.
    apply andI.
    - apply andI.
      + (** G0 c= Fam0 **)
        let W. assume HW: W :e G0.
        prove W :e Fam0.
        apply (ReplE_impred G (fun V:set => Wof V) W HW).
        let V. assume HVG: V :e G.
        assume HWof: W = Wof V.
        rewrite HWof.
        (** epsilon picks W in Fam0 **)
        claim HVFam: V :e Fam.
        { exact (HGsub V HVG). }
        claim HexW: exists W0:set, W0 :e Fam0 /\ V = Vof W0.
        { apply (ReplE_impred Fam0 (fun W0:set => Vof W0) V HVFam).
          let W0. assume HW0: W0 :e Fam0.
          assume HVeq: V = Vof W0.
          witness W0.
          apply andI.
          - exact HW0.
          - exact HVeq. }
        apply HexW.
        let W0. assume HW0pair: W0 :e Fam0 /\ V = Vof W0.
        exact (andEL (Wof V :e Fam0) (V = Vof (Wof V))
                     (Eps_i_ax (fun W1:set => W1 :e Fam0 /\ V = Vof W1) W0 HW0pair)).
      + (** finite G0 **)
        exact (Repl_finite (fun V:set => Wof V) G HGfin).
    - (** Y c= Union G0 **)
      let y. assume HyY: y :e Y.
      prove y :e Union G0.
      claim HyUG: y :e Union G.
      { exact (HGcov y HyY). }
      apply (UnionE_impred G y HyUG).
      let V. assume HyV: y :e V.
      assume HVG: V :e G.
      prove y :e Union G0.
      (** show y in Wof V, using that V = Vof (Wof V) and Wof V = (Vof (Wof V)) /\ Y **)
      claim HVFam: V :e Fam.
      { exact (HGsub V HVG). }
      claim HexW: exists W0:set, W0 :e Fam0 /\ V = Vof W0.
      { apply (ReplE_impred Fam0 (fun W0:set => Vof W0) V HVFam).
        let W0. assume HW0: W0 :e Fam0.
        assume HVeq: V = Vof W0.
        witness W0.
        apply andI.
        - exact HW0.
        - exact HVeq. }
      claim HVeq: V = Vof (Wof V).
      { apply HexW.
        let W0. assume HW0pair: W0 :e Fam0 /\ V = Vof W0.
        exact (andER (Wof V :e Fam0) (V = Vof (Wof V))
                     (Eps_i_ax (fun W1:set => W1 :e Fam0 /\ V = Vof W1) W0 HW0pair)). }
      claim HWty: (Wof V) :e Ty.
      { claim HWinFam0: (Wof V) :e Fam0.
        { apply HexW.
          let W0. assume HW0pair: W0 :e Fam0 /\ V = Vof W0.
          exact (andEL (Wof V :e Fam0) (V = Vof (Wof V))
                       (Eps_i_ax (fun W1:set => W1 :e Fam0 /\ V = Vof W1) W0 HW0pair)). }
        exact (HF0open (Wof V) HWinFam0). }
      claim HexV: exists V0:set, V0 :e Tx /\ (Wof V) = V0 :/\: Y.
      { exact (SepE2 (Power Y) (fun U0:set => exists V0 :e Tx, U0 = V0 :/\: Y) (Wof V) HWty). }
      claim HWrepr: (Wof V) = (Vof (Wof V)) :/\: Y.
      { apply HexV.
        let V0. assume HV0pair: V0 :e Tx /\ (Wof V) = V0 :/\: Y.
        exact (andER (Vof (Wof V) :e Tx) ((Wof V) = (Vof (Wof V)) :/\: Y)
                     (Eps_i_ax (fun V1:set => V1 :e Tx /\ (Wof V) = V1 :/\: Y) V0 HV0pair)). }
      claim HyInWof: y :e (Wof V).
      { rewrite HWrepr at 1.
        rewrite <- HVeq at 1.
        exact (binintersectI V Y y HyV HyY). }
      exact (UnionI G0 y (Wof V) HyInWof
                    (ReplI G (fun V0:set => Wof V0) V HVG)).
Qed.

(** from 26 Theorem 26.2: closed subspaces of compact spaces are compact **) 
(** LATEX VERSION: If X is compact and Y is closed in X, then Y is compact in the subspace topology. **)
Theorem closed_subspace_compact : forall X Tx Y:set,
  compact_space X Tx -> closed_in X Tx Y -> compact_space Y (subspace_topology X Tx Y).
let X Tx Y.
assume Hcomp: compact_space X Tx.
assume HY: closed_in X Tx Y.
prove compact_space Y (subspace_topology X Tx Y).
set Ty := subspace_topology X Tx Y.
claim HTx: topology_on X Tx.
{ exact (compact_space_topology X Tx Hcomp). }
claim HsubcoverX: forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam.
{ exact (compact_space_subcover_property X Tx Hcomp). }
claim HYsub: Y c= X.
{ exact (closed_in_subset X Tx Y HY). }
(** Choose an open complement U of Y in X. **)
claim HexU: exists U :e Tx, Y = X :\: U.
{ claim HYparts: Y c= X /\ exists U :e Tx, Y = X :\: U.
  { exact (andER (topology_on X Tx) (Y c= X /\ exists U :e Tx, Y = X :\: U) HY). }
  exact (andER (Y c= X) (exists U :e Tx, Y = X :\: U) HYparts). }
apply HexU.
let U.
assume HUpair: U :e Tx /\ Y = X :\: U.
claim HUu: U :e Tx.
{ exact (andEL (U :e Tx) (Y = X :\: U) HUpair). }
claim HYeq: Y = X :\: U.
{ exact (andER (U :e Tx) (Y = X :\: U) HUpair). }

(** Use the characterization via ambient open covers. **)
claim Hequiv:
  (compact_space Y Ty <->
    forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam).
{ exact (compact_subspace_via_ambient_covers X Tx Y HTx HYsub). }
apply (iffER (compact_space Y Ty)
             (forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam)
             Hequiv).

let Fam. assume HFamcov: Fam c= Tx /\ Y c= Union Fam.
claim HFamSub: Fam c= Tx.
{ exact (andEL (Fam c= Tx) (Y c= Union Fam) HFamcov). }
claim HYcovFam: Y c= Union Fam.
{ exact (andER (Fam c= Tx) (Y c= Union Fam) HFamcov). }

(** Extend the cover of Y by adding U; this covers X. **)
set CoverX := Fam :\/: {U}.
claim HcoverX: open_cover_of X Tx CoverX.
{ prove topology_on X Tx /\ CoverX c= Power X /\ X c= Union CoverX /\ (forall V:set, V :e CoverX -> V :e Tx).
  apply andI.
  - (** (CoverX c= Power X) /\ X c= Union CoverX **)
    apply andI.
    + (** topology_on X Tx /\ CoverX c= Power X **)
      apply andI.
      * exact HTx.
      * (** CoverX c= Power X **)
	        let V. assume HV: V :e CoverX.
	        prove V :e Power X.
	        apply (binunionE Fam {U} V HV).
	        - assume HVF: V :e Fam.
	           claim HVTx: V :e Tx.
	           { exact (HFamSub V HVF). }
	           claim HVsub: V c= X.
	           { exact (topology_elem_subset X Tx V HTx HVTx). }
	           exact (PowerI X V HVsub).
	        - assume HVU: V :e {U}.
	           claim HVe: V = U.
	           { exact (SingE U V HVU). }
	           rewrite HVe.
	           claim HUsub: U c= X.
	           { exact (topology_elem_subset X Tx U HTx HUu). }
	           exact (PowerI X U HUsub).
    + (** X c= Union CoverX **)
      let x. assume HxX: x :e X.
      prove x :e Union CoverX.
      apply (xm (x :e U)).
      * assume HxU: x :e U.
        exact (UnionI CoverX x U HxU (binunionI2 Fam {U} U (SingI U))).
      * assume HxnotU: ~ x :e U.
        claim HxY: x :e Y.
        { rewrite HYeq.
          exact (setminusI X U x HxX HxnotU). }
        claim HxUFam: x :e Union Fam.
        { exact (HYcovFam x HxY). }
        apply (UnionE_impred Fam x HxUFam).
        let V. assume HxV: x :e V.
        assume HVF: V :e Fam.
        prove x :e Union CoverX.
        exact (UnionI CoverX x V HxV (binunionI1 Fam {U} V HVF)).
  - (** each element of CoverX is open in Tx **)
    let V. assume HV: V :e CoverX.
    prove V :e Tx.
    apply (binunionE Fam {U} V HV).
    + assume HVF: V :e Fam.
      exact (HFamSub V HVF).
    + assume HVU: V :e {U}.
      claim HVe: V = U.
      { exact (SingE U V HVU). }
      rewrite HVe.
      exact HUu. }

(** Compactness of X gives a finite subcover of CoverX. **)
claim HfinCoverX: has_finite_subcover X Tx CoverX.
{ exact (HsubcoverX CoverX HcoverX). }
apply HfinCoverX.
let G. assume HG: G c= CoverX /\ finite G /\ X c= Union G.
claim HGleft: G c= CoverX /\ finite G.
{ exact (andEL (G c= CoverX /\ finite G) (X c= Union G) HG). }
claim HGsub: G c= CoverX.
{ exact (andEL (G c= CoverX) (finite G) HGleft). }
claim HGfin: finite G.
{ exact (andER (G c= CoverX) (finite G) HGleft). }
claim HGcovX: X c= Union G.
{ exact (andER (G c= CoverX /\ finite G) (X c= Union G) HG). }

(** Remove U from G to obtain a finite subcover drawn from Fam. **)
set G1 := G :\: {U}.
claim HG1subG: G1 c= G.
{ exact (setminus_Subq G {U}). }
claim HG1fin: finite G1.
{ exact (Subq_finite G HGfin G1 HG1subG). }
claim HG1subFam: G1 c= Fam.
{ let V. assume HVG1: V :e G1.
  prove V :e Fam.
  claim HVG: V :e G.
  { exact (setminusE1 G {U} V HVG1). }
  claim HVnotU: V /:e {U}.
  { exact (setminusE2 G {U} V HVG1). }
  claim HVinCover: V :e CoverX.
  { exact (HGsub V HVG). }
  apply (binunionE Fam {U} V HVinCover).
  - assume HVF: V :e Fam.
    exact HVF.
  - assume HVU: V :e {U}.
    prove V :e Fam.
    prove False.
    apply HVnotU.
    exact HVU. }
claim HYcovG1: Y c= Union G1.
{ let y. assume HyY: y :e Y.
  prove y :e Union G1.
  claim HyX: y :e X.
  { exact (HYsub y HyY). }
  claim HyUG: y :e Union G.
  { exact (HGcovX y HyX). }
  apply (UnionE_impred G y HyUG).
  let V. assume HyV: y :e V.
  assume HVG: V :e G.
  prove y :e Union G1.
  claim HVinCover: V :e CoverX.
  { exact (HGsub V HVG). }
  claim HVnotU: V /:e {U}.
  { apply (binunionE Fam {U} V HVinCover).
    - assume HVF: V :e Fam.
      prove V /:e {U}.
      assume HVU: V :e {U}.
      claim HVe: V = U.
      { exact (SingE U V HVU). }
	      (** y in Y implies y not in U **)
	      claim HyNotU: y /:e U.
	      { claim HyYU: y :e X :\: U.
	        { rewrite <- HYeq at 1.
	          exact HyY. }
	        exact (setminusE2 X U y HyYU). }
	      apply HyNotU.
	      rewrite <- HVe.
	      exact HyV.
	    - assume HVU: V :e {U}.
	      prove V /:e {U}.
	      assume HVU2: V :e {U}.
	      claim HVe: V = U.
	      { exact (SingE U V HVU2). }
	      claim HyNotU: y /:e U.
	      { claim HyYU: y :e X :\: U.
	        { rewrite <- HYeq at 1.
	          exact HyY. }
	        exact (setminusE2 X U y HyYU). }
	      apply HyNotU.
	      rewrite <- HVe.
	      exact HyV. }
  claim HVG1: V :e G1.
  { exact (setminusI G {U} V HVG HVnotU). }
  exact (UnionI G1 y V HyV HVG1). }

claim HG1left: G1 c= Fam /\ finite G1.
{ apply andI.
  - exact HG1subFam.
  - exact HG1fin. }
claim HG1triple: G1 c= Fam /\ finite G1 /\ Y c= Union G1.
{ apply andI.
  - exact HG1left.
  - exact HYcovG1. }
exact (has_finite_subcoverI Y Tx Fam G1 HG1triple).
Qed.

(** helper: separating point and compact set in Hausdorff space **)
(** This duplicates the proof of 26 Lemma 26.4, placed here so 26 Theorem 26.3 can use it without forward references. **)
Theorem Hausdorff_separate_point_compact_set_aux : forall X Tx Y x:set,
  Hausdorff_space X Tx -> Y c= X -> compact_space Y (subspace_topology X Tx Y) -> x :e X -> x /:e Y ->
  exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ Y c= V /\ U :/\: V = Empty.
let X Tx Y x.
assume HH: Hausdorff_space X Tx.
assume HYsub: Y c= X.
assume Hcomp: compact_space Y (subspace_topology X Tx Y).
assume HxX: x :e X.
assume Hx: x /:e Y.
prove exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ Y c= V /\ U :/\: V = Empty.
set Ty := subspace_topology X Tx Y.
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }
claim Hsep: forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
  exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
{ exact (andER (topology_on X Tx)
               (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }

(** Choose V_y and U_y for each y in Y. **)
set Vof := fun y:set =>
  Eps_i (fun V:set => exists U:set, U :e Tx /\ V :e Tx /\ x :e U /\ y :e V /\ U :/\: V = Empty).
set Uof := fun y:set =>
  Eps_i (fun U:set => U :e Tx /\ x :e U /\ U :/\: (Vof y) = Empty).

claim Vof_exists: forall y:set, y :e Y ->
  exists U:set, U :e Tx /\ (Vof y) :e Tx /\ x :e U /\ y :e (Vof y) /\ U :/\: (Vof y) = Empty.
{ let y. assume HyY: y :e Y.
  claim HyX: y :e X.
  { exact (HYsub y HyY). }
  claim Hneq: x <> y.
  { assume Heq: x = y.
    apply Hx.
    rewrite Heq.
    exact HyY. }
  claim Hex: exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ y :e V /\ U :/\: V = Empty.
  { exact (Hsep x y HxX HyX Hneq). }
  apply Hex.
  let U0. assume HexV0: exists V0:set, U0 :e Tx /\ V0 :e Tx /\ x :e U0 /\ y :e V0 /\ U0 :/\: V0 = Empty.
  apply HexV0.
  let V0. assume HUV0: U0 :e Tx /\ V0 :e Tx /\ x :e U0 /\ y :e V0 /\ U0 :/\: V0 = Empty.
  claim HpV0: exists U:set, U :e Tx /\ V0 :e Tx /\ x :e U /\ y :e V0 /\ U :/\: V0 = Empty.
  { witness U0.
    exact HUV0. }
  exact (Eps_i_ax (fun V:set => exists U:set, U :e Tx /\ V :e Tx /\ x :e U /\ y :e V /\ U :/\: V = Empty) V0 HpV0). }

claim Vof_in_Tx: forall y:set, y :e Y -> (Vof y) :e Tx.
{ let y. assume HyY: y :e Y.
  apply (Vof_exists y HyY).
  let U0. assume HU0: U0 :e Tx /\ (Vof y) :e Tx /\ x :e U0 /\ y :e (Vof y) /\ U0 :/\: (Vof y) = Empty.
  (** conjunction is left-associative **)
  claim HU0A: ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y).
  { exact (andEL (((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y))
                 (U0 :/\: (Vof y) = Empty) HU0). }
  claim HU0A1: (U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0.
  { exact (andEL ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) (y :e (Vof y)) HU0A). }
  claim HU0AB: U0 :e Tx /\ (Vof y) :e Tx.
  { exact (andEL (U0 :e Tx /\ (Vof y) :e Tx) (x :e U0) HU0A1). }
  exact (andER (U0 :e Tx) ((Vof y) :e Tx) HU0AB). }

claim y_in_Vof: forall y:set, y :e Y -> y :e (Vof y).
{ let y. assume HyY: y :e Y.
  apply (Vof_exists y HyY).
  let U0. assume HU0: U0 :e Tx /\ (Vof y) :e Tx /\ x :e U0 /\ y :e (Vof y) /\ U0 :/\: (Vof y) = Empty.
  claim HU0A: ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y).
  { exact (andEL (((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y))
                 (U0 :/\: (Vof y) = Empty) HU0). }
  exact (andER ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) (y :e (Vof y)) HU0A). }

claim Uof_props: forall y:set, y :e Y ->
  (Uof y) :e Tx /\ x :e (Uof y) /\ (Uof y) :/\: (Vof y) = Empty.
{ let y. assume HyY: y :e Y.
  claim HexU: exists U0:set, U0 :e Tx /\ x :e U0 /\ U0 :/\: (Vof y) = Empty.
  { apply (Vof_exists y HyY).
    let U0. assume HU0: U0 :e Tx /\ (Vof y) :e Tx /\ x :e U0 /\ y :e (Vof y) /\ U0 :/\: (Vof y) = Empty.
    witness U0.
    claim HU0A: ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y).
    { exact (andEL (((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y))
                   (U0 :/\: (Vof y) = Empty) HU0). }
    claim HU0A1: (U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0.
    { exact (andEL ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) (y :e (Vof y)) HU0A). }
    claim HU0AB: U0 :e Tx /\ (Vof y) :e Tx.
    { exact (andEL (U0 :e Tx /\ (Vof y) :e Tx) (x :e U0) HU0A1). }
    claim HU0Tx: U0 :e Tx.
    { exact (andEL (U0 :e Tx) ((Vof y) :e Tx) HU0AB). }
    claim HxU0: x :e U0.
    { exact (andER (U0 :e Tx /\ (Vof y) :e Tx) (x :e U0) HU0A1). }
    claim HU0disj: U0 :/\: (Vof y) = Empty.
    { exact (andER (((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y))
                   (U0 :/\: (Vof y) = Empty) HU0). }
    claim HU0pair: U0 :e Tx /\ x :e U0.
    { apply andI.
      - exact HU0Tx.
      - exact HxU0. }
    exact (andI (U0 :e Tx /\ x :e U0) (U0 :/\: (Vof y) = Empty) HU0pair HU0disj). }
  apply HexU.
  let U0. assume HU0: U0 :e Tx /\ x :e U0 /\ U0 :/\: (Vof y) = Empty.
  exact (Eps_i_ax (fun U:set => U :e Tx /\ x :e U /\ U :/\: (Vof y) = Empty) U0 HU0). }

(** Finite open cover of Y by the ambient opens Vof y. **)
set VFam := {Vof y|y :e Y}.
claim HVFamSub: VFam c= Tx.
{ let V. assume HV: V :e VFam.
  apply (ReplE_impred Y (fun y0:set => Vof y0) V HV).
  let y. assume HyY: y :e Y.
  assume HVe: V = Vof y.
  rewrite HVe.
  exact (Vof_in_Tx y HyY). }
claim HYcovVFam: Y c= Union VFam.
{ let y. assume HyY: y :e Y.
  prove y :e Union VFam.
  exact (UnionI VFam y (Vof y) (y_in_Vof y HyY) (ReplI Y (fun y0:set => Vof y0) y HyY)). }

(** Use compactness of Y in the subspace topology to obtain a finite subcover from VFam. **)
claim Hcovprop: forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam.
{ exact (iffEL (compact_space Y Ty)
               (forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam)
               (compact_subspace_via_ambient_covers X Tx Y HTx HYsub) Hcomp). }
claim Hfin: has_finite_subcover Y Tx VFam.
{ exact (Hcovprop VFam (andI (VFam c= Tx) (Y c= Union VFam) HVFamSub HYcovVFam)). }
apply Hfin.
let G. assume HG: G c= VFam /\ finite G /\ Y c= Union G.
claim HGleft: G c= VFam /\ finite G.
{ exact (andEL (G c= VFam /\ finite G) (Y c= Union G) HG). }
claim HGsub: G c= VFam.
{ exact (andEL (G c= VFam) (finite G) HGleft). }
claim HGfin: finite G.
{ exact (andER (G c= VFam) (finite G) HGleft). }
claim HGcov: Y c= Union G.
{ exact (andER (G c= VFam /\ finite G) (Y c= Union G) HG). }

(** Build the separating open sets U and V from the finite subcover G. **)
set V := Union G.
claim HGTX: G c= Tx.
{ let W. assume HW: W :e G.
  claim HWVFam: W :e VFam.
  { exact (HGsub W HW). }
  exact (HVFamSub W HWVFam). }
claim HVopen: V :e Tx.
{ exact (topology_union_closed X Tx G HTx HGTX). }
claim HYsubV: Y c= V.
{ exact HGcov. }

set pickY := fun V0:set => Eps_i (fun y0:set => y0 :e Y /\ V0 = Vof y0).
set UFam := {Uof (pickY V0)|V0 :e G}.
set U := intersection_of_family X UFam.

claim HUFamSub: UFam c= Tx.
{ let U0. assume HU0: U0 :e UFam.
  apply (ReplE_impred G (fun V0:set => Uof (pickY V0)) U0 HU0).
  let V0. assume HV0G: V0 :e G.
  assume HU0eq: U0 = Uof (pickY V0).
  rewrite HU0eq.
  claim Hpick: pickY V0 :e Y.
  { claim HV0VFam: V0 :e VFam.
    { exact (HGsub V0 HV0G). }
    apply (ReplE_impred Y (fun y0:set => Vof y0) V0 HV0VFam).
    let y0. assume Hy0Y: y0 :e Y.
    assume HV0eq: V0 = Vof y0.
    claim Hp: (y0 :e Y /\ V0 = Vof y0).
    { exact (andI (y0 :e Y) (V0 = Vof y0) Hy0Y HV0eq). }
    exact (andEL (pickY V0 :e Y) (V0 = Vof (pickY V0))
                 (Eps_i_ax (fun y:set => y :e Y /\ V0 = Vof y) y0 Hp)). }
  claim HUof: (Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)) /\ (Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty.
  { exact (Uof_props (pickY V0) Hpick). }
  claim HUof1: (Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)).
  { exact (andEL ((Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)))
                 ((Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty) HUof). }
  exact (andEL ((Uof (pickY V0)) :e Tx) (x :e (Uof (pickY V0))) HUof1). }

claim HUFamFin: finite UFam.
{ exact (Repl_finite (fun V0:set => Uof (pickY V0)) G HGfin). }
claim HUFamPow: UFam :e Power Tx.
{ exact (PowerI Tx UFam HUFamSub). }
claim HUopen: U :e Tx.
{ exact (finite_intersection_in_topology X Tx UFam HTx HUFamPow HUFamFin). }

claim HxU: x :e U.
{ prove x :e intersection_of_family X UFam.
  prove x :e {z :e X | forall T:set, T :e UFam -> z :e T}.
  apply SepI.
  - exact HxX.
  - let W. assume HW: W :e UFam.
    apply (ReplE_impred G (fun V0:set => Uof (pickY V0)) W HW).
    let V0. assume HV0G: V0 :e G.
    assume HWeq: W = Uof (pickY V0).
    rewrite HWeq.
    claim Hpick: pickY V0 :e Y.
    { claim HV0VFam: V0 :e VFam.
      { exact (HGsub V0 HV0G). }
      apply (ReplE_impred Y (fun y0:set => Vof y0) V0 HV0VFam).
      let y0. assume Hy0Y: y0 :e Y.
      assume HV0eq: V0 = Vof y0.
      claim Hp: (y0 :e Y /\ V0 = Vof y0).
      { exact (andI (y0 :e Y) (V0 = Vof y0) Hy0Y HV0eq). }
      exact (andEL (pickY V0 :e Y) (V0 = Vof (pickY V0))
                   (Eps_i_ax (fun y:set => y :e Y /\ V0 = Vof y) y0 Hp)). }
    claim HUof: (Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)) /\ (Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty.
    { exact (Uof_props (pickY V0) Hpick). }
    claim HUof1: (Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)).
    { exact (andEL ((Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)))
                   ((Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty) HUof). }
    exact (andER ((Uof (pickY V0)) :e Tx) (x :e (Uof (pickY V0))) HUof1). }

claim HUVdisj: U :/\: V = Empty.
{ apply Empty_Subq_eq.
  let z. assume Hz: z :e U :/\: V.
  prove False.
  claim HzU: z :e U.
  { exact (binintersectE1 U V z Hz). }
  claim HzV: z :e V.
  { exact (binintersectE2 U V z Hz). }
  claim HzUG: z :e Union G.
  { exact HzV. }
  apply (UnionE_impred G z HzUG).
  let V0. assume HzV0: z :e V0.
  assume HV0G: V0 :e G.
  claim HV0VFam: V0 :e VFam.
  { exact (HGsub V0 HV0G). }
  apply (ReplE_impred Y (fun y0:set => Vof y0) V0 HV0VFam).
  let y0. assume Hy0Y: y0 :e Y.
  assume HV0eq: V0 = Vof y0.
  claim Hp: y0 :e Y /\ V0 = Vof y0.
  { exact (andI (y0 :e Y) (V0 = Vof y0) Hy0Y HV0eq). }
  claim HpickY: pickY V0 :e Y /\ V0 = Vof (pickY V0).
  { exact (Eps_i_ax (fun y:set => y :e Y /\ V0 = Vof y) y0 Hp). }
  claim Hpick: pickY V0 :e Y.
  { exact (andEL (pickY V0 :e Y) (V0 = Vof (pickY V0)) HpickY). }
  claim HV0rep: V0 = Vof (pickY V0).
  { exact (andER (pickY V0 :e Y) (V0 = Vof (pickY V0)) HpickY). }
  claim HUof: (Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)) /\ (Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty.
  { exact (Uof_props (pickY V0) Hpick). }
  claim HUofdisj: (Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty.
  { exact (andER ((Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)))
                 ((Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty) HUof). }
  claim HzUof: z :e (Uof (pickY V0)).
  { claim Hall: forall T:set, T :e UFam -> z :e T.
    { exact (SepE2 X (fun z0:set => forall T:set, T :e UFam -> z0 :e T) z HzU). }
    apply Hall.
    exact (ReplI G (fun V1:set => Uof (pickY V1)) V0 HV0G). }
  claim HzVof: z :e (Vof (pickY V0)).
  { rewrite <- HV0rep at 1.
    exact HzV0. }
  claim HzInt: z :e (Uof (pickY V0)) :/\: (Vof (pickY V0)).
  { exact (binintersectI (Uof (pickY V0)) (Vof (pickY V0)) z HzUof HzVof). }
  claim HzEmpty: z :e Empty.
  { rewrite <- HUofdisj at 1.
    exact HzInt. }
  exact (EmptyE z HzEmpty False). }

witness U.
witness V.
prove U :e Tx /\ V :e Tx /\ x :e U /\ Y c= V /\ U :/\: V = Empty.
apply andI.
- apply andI.
  + apply andI.
    * apply andI.
      - exact HUopen.
      - exact HVopen.
    * exact HxU.
  + exact HYsubV.
- exact HUVdisj.
Qed.

(** from 26 Theorem 26.3: compact subspaces of Hausdorff spaces are closed **) 
(** LATEX VERSION: In a Hausdorff space, every compact subspace is closed. **)
Theorem compact_subspace_in_Hausdorff_closed : forall X Tx Y:set,
  Hausdorff_space X Tx -> Y c= X -> compact_space Y (subspace_topology X Tx Y) -> closed_in X Tx Y.
let X Tx Y.
assume HH: Hausdorff_space X Tx.
assume HYsub: Y c= X.
assume Hcomp: compact_space Y (subspace_topology X Tx Y).
prove closed_in X Tx Y.
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }
prove topology_on X Tx /\ (Y c= X /\ exists U :e Tx, Y = X :\: U).
apply andI.
- exact HTx.
- prove Y c= X /\ exists U :e Tx, Y = X :\: U.
  apply andI.
  + exact HYsub.
  + (** show X \\ Y is open and use double complement **)
    witness (X :\: Y).
    apply andI.
    * (** X\\Y :e Tx **)
      set UFam := {U :e Tx | exists x0:set, x0 :e X :\: Y /\ x0 :e U /\ U :/\: Y = Empty}.
      claim HUFamSub: UFam c= Tx.
      { let U. assume HU: U :e UFam.
        exact (SepE1 Tx (fun U0:set => exists x0:set, x0 :e X :\: Y /\ x0 :e U0 /\ U0 :/\: Y = Empty) U HU). }
      claim HUnionEq: Union UFam = X :\: Y.
      { apply set_ext.
        - let z. assume Hz: z :e Union UFam.
          prove z :e X :\: Y.
          apply (UnionE_impred UFam z Hz).
          let U. assume HzU: z :e U.
          assume HU: U :e UFam.
          claim HUtx: U :e Tx.
          { exact (SepE1 Tx (fun U0:set => exists x0:set, x0 :e X :\: Y /\ x0 :e U0 /\ U0 :/\: Y = Empty) U HU). }
          claim HUsubX: U c= X.
          { exact (topology_elem_subset X Tx U HTx HUtx). }
          claim HzX: z :e X.
          { exact (HUsubX z HzU). }
          claim Hpred: exists x0:set, x0 :e X :\: Y /\ x0 :e U /\ U :/\: Y = Empty.
          { exact (SepE2 Tx (fun U0:set => exists x0:set, x0 :e X :\: Y /\ x0 :e U0 /\ U0 :/\: Y = Empty) U HU). }
          apply Hpred.
          let x0. assume Hx0: x0 :e X :\: Y /\ x0 :e U /\ U :/\: Y = Empty.
          claim HUYempty: U :/\: Y = Empty.
          { exact (andER (x0 :e X :\: Y /\ x0 :e U) (U :/\: Y = Empty) Hx0). }
          claim HzNotY: z /:e Y.
          { assume HzY: z :e Y.
            claim HzInt: z :e U :/\: Y.
            { exact (binintersectI U Y z HzU HzY). }
	            claim HzEmpty: z :e Empty.
	            { rewrite <- HUYempty at 1.
	              exact HzInt. }
	            exact (EmptyE z HzEmpty False). }
	          exact (setminusI X Y z HzX HzNotY).
        - let z. assume Hz: z :e X :\: Y.
          prove z :e Union UFam.
          claim HzX: z :e X.
          { exact (setminusE1 X Y z Hz). }
          claim HzNotY: z /:e Y.
          { exact (setminusE2 X Y z Hz). }
          claim HexUV: exists U V:set, U :e Tx /\ V :e Tx /\ z :e U /\ Y c= V /\ U :/\: V = Empty.
          { exact (Hausdorff_separate_point_compact_set_aux X Tx Y z HH HYsub Hcomp HzX HzNotY). }
          apply HexUV.
          let U. assume HexV: exists V:set, U :e Tx /\ V :e Tx /\ z :e U /\ Y c= V /\ U :/\: V = Empty.
          apply HexV.
          let V. assume Hconj: U :e Tx /\ V :e Tx /\ z :e U /\ Y c= V /\ U :/\: V = Empty.
          claim HconjA: ((U :e Tx /\ V :e Tx) /\ z :e U) /\ Y c= V.
          { exact (andEL (((U :e Tx /\ V :e Tx) /\ z :e U) /\ Y c= V) (U :/\: V = Empty) Hconj). }
          claim HUVempty: U :/\: V = Empty.
          { exact (andER (((U :e Tx /\ V :e Tx) /\ z :e U) /\ Y c= V) (U :/\: V = Empty) Hconj). }
          claim HUVz: (U :e Tx /\ V :e Tx) /\ z :e U.
          { exact (andEL ((U :e Tx /\ V :e Tx) /\ z :e U) (Y c= V) HconjA). }
          claim HUtx: U :e Tx.
          { exact (andEL (U :e Tx) (V :e Tx)
                         (andEL (U :e Tx /\ V :e Tx) (z :e U) HUVz)). }
          claim HzU: z :e U.
          { exact (andER (U :e Tx /\ V :e Tx) (z :e U) HUVz). }
          claim HYsubV: Y c= V.
          { exact (andER ((U :e Tx /\ V :e Tx) /\ z :e U) (Y c= V) HconjA). }
          (** show U /\\ Y = Empty using Y c= V and U /\\ V = Empty **)
          claim HUYsub: U :/\: Y c= U :/\: V.
          { let t. assume Ht: t :e U :/\: Y.
            prove t :e U :/\: V.
            claim HtU: t :e U.
            { exact (binintersectE1 U Y t Ht). }
            claim HtY: t :e Y.
            { exact (binintersectE2 U Y t Ht). }
            claim HtV: t :e V.
            { exact (HYsubV t HtY). }
            exact (binintersectI U V t HtU HtV). }
          claim HUYempty: U :/\: Y = Empty.
          { apply Empty_Subq_eq.
            let t. assume Ht: t :e U :/\: Y.
            prove False.
            claim HtUV: t :e U :/\: V.
            { exact (HUYsub t Ht). }
            claim HtEmpty: t :e Empty.
            { rewrite <- HUVempty at 1.
              exact HtUV. }
            exact (EmptyE t HtEmpty False). }
          claim HzXY: z :e X :\: Y.
          { exact (setminusI X Y z HzX HzNotY). }
          claim HUinUFam: U :e UFam.
          { apply (SepI Tx
                        (fun U0:set => exists x0:set, x0 :e X :\: Y /\ x0 :e U0 /\ U0 :/\: Y = Empty)
                        U
                        HUtx).
            witness z.
            (** conjunction is left-associative **)
            apply andI.
            + apply andI.
              * exact HzXY.
              * exact HzU.
            + exact HUYempty. }
          exact (UnionI UFam z U HzU HUinUFam). }
      (** Union UFam is open, hence X\\Y is open **)
      rewrite <- HUnionEq at 1.
      exact (topology_union_closed X Tx UFam HTx HUFamSub).
	    * (** Y = X \\ (X \\ Y) **)
	      symmetry.
	      exact (setminus_setminus_eq X Y HYsub).
Qed.

(** from 26 Lemma 26.4: separating point and compact set in Hausdorff space **)
(** LATEX VERSION: In a Hausdorff space, a point not in a compact set can be separated from that compact set by disjoint open sets. **)
(** FIXED: Point disjointness is x /:e Y (x not an element of Y), not x :/\: Y = Empty which treats x as a set. **)
Theorem Hausdorff_separate_point_compact_set : forall X Tx Y x:set,
  Hausdorff_space X Tx -> Y c= X -> compact_space Y (subspace_topology X Tx Y) -> x :e X -> x /:e Y ->
  exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ Y c= V /\ U :/\: V = Empty.
let X Tx Y x.
assume HH: Hausdorff_space X Tx.
assume HYsub: Y c= X.
assume Hcomp: compact_space Y (subspace_topology X Tx Y).
assume HxX: x :e X.
assume Hx: x /:e Y.
prove exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ Y c= V /\ U :/\: V = Empty.
set Ty := subspace_topology X Tx Y.
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }
claim Hsep: forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
  exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
{ exact (andER (topology_on X Tx)
               (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }

(** Choose V_y and U_y for each y in Y. **)
set Vof := fun y:set =>
  Eps_i (fun V:set => exists U:set, U :e Tx /\ V :e Tx /\ x :e U /\ y :e V /\ U :/\: V = Empty).
set Uof := fun y:set =>
  Eps_i (fun U:set => U :e Tx /\ x :e U /\ U :/\: (Vof y) = Empty).

claim Vof_exists: forall y:set, y :e Y ->
  exists U:set, U :e Tx /\ (Vof y) :e Tx /\ x :e U /\ y :e (Vof y) /\ U :/\: (Vof y) = Empty.
{ let y. assume HyY: y :e Y.
  claim HyX: y :e X.
  { exact (HYsub y HyY). }
  claim Hneq: x <> y.
  { assume Heq: x = y.
    apply Hx.
    rewrite Heq.
    exact HyY. }
  claim Hex: exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ y :e V /\ U :/\: V = Empty.
  { exact (Hsep x y HxX HyX Hneq). }
  apply Hex.
  let U0. assume HexV0: exists V0:set, U0 :e Tx /\ V0 :e Tx /\ x :e U0 /\ y :e V0 /\ U0 :/\: V0 = Empty.
  apply HexV0.
  let V0. assume HUV0: U0 :e Tx /\ V0 :e Tx /\ x :e U0 /\ y :e V0 /\ U0 :/\: V0 = Empty.
  claim HpV0: exists U:set, U :e Tx /\ V0 :e Tx /\ x :e U /\ y :e V0 /\ U :/\: V0 = Empty.
  { witness U0.
    exact HUV0. }
  exact (Eps_i_ax (fun V:set => exists U:set, U :e Tx /\ V :e Tx /\ x :e U /\ y :e V /\ U :/\: V = Empty) V0 HpV0). }

claim Vof_in_Tx: forall y:set, y :e Y -> (Vof y) :e Tx.
{ let y. assume HyY: y :e Y.
  apply (Vof_exists y HyY).
  let U0. assume HU0: U0 :e Tx /\ (Vof y) :e Tx /\ x :e U0 /\ y :e (Vof y) /\ U0 :/\: (Vof y) = Empty.
  (** conjunction is left-associative **)
  claim HU0A: ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y).
  { exact (andEL (((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y))
                 (U0 :/\: (Vof y) = Empty) HU0). }
  claim HU0A1: (U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0.
  { exact (andEL ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) (y :e (Vof y)) HU0A). }
  claim HU0AB: U0 :e Tx /\ (Vof y) :e Tx.
  { exact (andEL (U0 :e Tx /\ (Vof y) :e Tx) (x :e U0) HU0A1). }
  exact (andER (U0 :e Tx) ((Vof y) :e Tx) HU0AB). }

claim y_in_Vof: forall y:set, y :e Y -> y :e (Vof y).
{ let y. assume HyY: y :e Y.
  apply (Vof_exists y HyY).
  let U0. assume HU0: U0 :e Tx /\ (Vof y) :e Tx /\ x :e U0 /\ y :e (Vof y) /\ U0 :/\: (Vof y) = Empty.
  claim HU0A: ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y).
  { exact (andEL (((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y))
                 (U0 :/\: (Vof y) = Empty) HU0). }
  exact (andER ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) (y :e (Vof y)) HU0A). }

claim Uof_props: forall y:set, y :e Y ->
  (Uof y) :e Tx /\ x :e (Uof y) /\ (Uof y) :/\: (Vof y) = Empty.
{ let y. assume HyY: y :e Y.
  claim HexU: exists U0:set, U0 :e Tx /\ x :e U0 /\ U0 :/\: (Vof y) = Empty.
  { apply (Vof_exists y HyY).
	    let U0. assume HU0: U0 :e Tx /\ (Vof y) :e Tx /\ x :e U0 /\ y :e (Vof y) /\ U0 :/\: (Vof y) = Empty.
	    witness U0.
	    claim HU0A: ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y).
	    { exact (andEL (((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y))
	                   (U0 :/\: (Vof y) = Empty) HU0). }
	    claim HU0A1: (U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0.
	    { exact (andEL ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) (y :e (Vof y)) HU0A). }
	    claim HU0AB: U0 :e Tx /\ (Vof y) :e Tx.
	    { exact (andEL (U0 :e Tx /\ (Vof y) :e Tx) (x :e U0) HU0A1). }
	    claim HU0Tx: U0 :e Tx.
	    { exact (andEL (U0 :e Tx) ((Vof y) :e Tx) HU0AB). }
	    claim HxU0: x :e U0.
	    { exact (andER (U0 :e Tx /\ (Vof y) :e Tx) (x :e U0) HU0A1). }
		    claim HU0disj: U0 :/\: (Vof y) = Empty.
		    { exact (andER (((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y))
		                   (U0 :/\: (Vof y) = Empty) HU0). }
		    claim HU0pair: U0 :e Tx /\ x :e U0.
		    { apply andI.
		      - exact HU0Tx.
		      - exact HxU0. }
		    exact (andI (U0 :e Tx /\ x :e U0) (U0 :/\: (Vof y) = Empty) HU0pair HU0disj). }
  apply HexU.
  let U0. assume HU0: U0 :e Tx /\ x :e U0 /\ U0 :/\: (Vof y) = Empty.
  exact (Eps_i_ax (fun U:set => U :e Tx /\ x :e U /\ U :/\: (Vof y) = Empty) U0 HU0). }

(** Finite open cover of Y by the ambient opens Vof y. **)
set VFam := {Vof y|y :e Y}.
claim HVFamSub: VFam c= Tx.
{ let V. assume HV: V :e VFam.
  apply (ReplE_impred Y (fun y0:set => Vof y0) V HV).
  let y. assume HyY: y :e Y.
  assume HVe: V = Vof y.
  rewrite HVe.
  exact (Vof_in_Tx y HyY). }
claim HYcovVFam: Y c= Union VFam.
{ let y. assume HyY: y :e Y.
  prove y :e Union VFam.
  exact (UnionI VFam y (Vof y) (y_in_Vof y HyY) (ReplI Y (fun y0:set => Vof y0) y HyY)). }

(** Use compactness of Y in the subspace topology to obtain a finite subcover from VFam. **)
claim Hcovprop: forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam.
{ exact (iffEL (compact_space Y Ty)
               (forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam)
               (compact_subspace_via_ambient_covers X Tx Y HTx HYsub) Hcomp). }
claim Hfin: has_finite_subcover Y Tx VFam.
{ exact (Hcovprop VFam (andI (VFam c= Tx) (Y c= Union VFam) HVFamSub HYcovVFam)). }
apply Hfin.
let G. assume HG: G c= VFam /\ finite G /\ Y c= Union G.
claim HGleft: G c= VFam /\ finite G.
{ exact (andEL (G c= VFam /\ finite G) (Y c= Union G) HG). }
claim HGsub: G c= VFam.
{ exact (andEL (G c= VFam) (finite G) HGleft). }
claim HGfin: finite G.
{ exact (andER (G c= VFam) (finite G) HGleft). }
claim HGcov: Y c= Union G.
{ exact (andER (G c= VFam /\ finite G) (Y c= Union G) HG). }

(** Build the separating open sets U and V from the finite subcover G. **)
set V := Union G.
claim HGTX: G c= Tx.
{ let W. assume HW: W :e G.
  claim HWVFam: W :e VFam.
  { exact (HGsub W HW). }
  exact (HVFamSub W HWVFam). }
claim HVopen: V :e Tx.
{ exact (topology_union_closed X Tx G HTx HGTX). }
claim HYsubV: Y c= V.
{ exact HGcov. }

set pickY := fun V0:set => Eps_i (fun y0:set => y0 :e Y /\ V0 = Vof y0).
set UFam := {Uof (pickY V0)|V0 :e G}.
set U := intersection_of_family X UFam.

claim HUFamSub: UFam c= Tx.
{ let U0. assume HU0: U0 :e UFam.
  apply (ReplE_impred G (fun V0:set => Uof (pickY V0)) U0 HU0).
  let V0. assume HV0G: V0 :e G.
  assume HU0eq: U0 = Uof (pickY V0).
  rewrite HU0eq.
  claim Hpick: pickY V0 :e Y.
  { claim HV0VFam: V0 :e VFam.
    { exact (HGsub V0 HV0G). }
    apply (ReplE_impred Y (fun y0:set => Vof y0) V0 HV0VFam).
    let y0. assume Hy0Y: y0 :e Y.
    assume HV0eq: V0 = Vof y0.
    claim Hp: (y0 :e Y /\ V0 = Vof y0).
    { exact (andI (y0 :e Y) (V0 = Vof y0) Hy0Y HV0eq). }
    exact (andEL (pickY V0 :e Y) (V0 = Vof (pickY V0))
                 (Eps_i_ax (fun y:set => y :e Y /\ V0 = Vof y) y0 Hp)). }
  claim HUof: (Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)) /\ (Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty.
  { exact (Uof_props (pickY V0) Hpick). }
  claim HUof1: (Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)).
  { exact (andEL ((Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)))
                 ((Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty) HUof). }
  exact (andEL ((Uof (pickY V0)) :e Tx) (x :e (Uof (pickY V0))) HUof1). }

claim HUFamFin: finite UFam.
{ exact (Repl_finite (fun V0:set => Uof (pickY V0)) G HGfin). }
claim HUFamPow: UFam :e Power Tx.
{ exact (PowerI Tx UFam HUFamSub). }
claim HUopen: U :e Tx.
{ exact (finite_intersection_in_topology X Tx UFam HTx HUFamPow HUFamFin). }

claim HxU: x :e U.
{ prove x :e intersection_of_family X UFam.
  prove x :e {z :e X | forall T:set, T :e UFam -> z :e T}.
  apply SepI.
  - exact HxX.
  - let W. assume HW: W :e UFam.
    apply (ReplE_impred G (fun V0:set => Uof (pickY V0)) W HW).
    let V0. assume HV0G: V0 :e G.
    assume HWeq: W = Uof (pickY V0).
    rewrite HWeq.
    claim Hpick: pickY V0 :e Y.
    { claim HV0VFam: V0 :e VFam.
      { exact (HGsub V0 HV0G). }
      apply (ReplE_impred Y (fun y0:set => Vof y0) V0 HV0VFam).
      let y0. assume Hy0Y: y0 :e Y.
      assume HV0eq: V0 = Vof y0.
      claim Hp: (y0 :e Y /\ V0 = Vof y0).
      { exact (andI (y0 :e Y) (V0 = Vof y0) Hy0Y HV0eq). }
      exact (andEL (pickY V0 :e Y) (V0 = Vof (pickY V0))
                   (Eps_i_ax (fun y:set => y :e Y /\ V0 = Vof y) y0 Hp)). }
    claim HUof: (Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)) /\ (Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty.
    { exact (Uof_props (pickY V0) Hpick). }
    claim HUof1: (Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)).
    { exact (andEL ((Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)))
                   ((Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty) HUof). }
    exact (andER ((Uof (pickY V0)) :e Tx) (x :e (Uof (pickY V0))) HUof1). }

claim HUVdisj: U :/\: V = Empty.
{ apply Empty_Subq_eq.
  let z. assume Hz: z :e U :/\: V.
  prove False.
  claim HzU: z :e U.
  { exact (binintersectE1 U V z Hz). }
  claim HzV: z :e V.
  { exact (binintersectE2 U V z Hz). }
  claim HzUG: z :e Union G.
  { exact HzV. }
  apply (UnionE_impred G z HzUG).
  let V0. assume HzV0: z :e V0.
  assume HV0G: V0 :e G.
  claim HV0VFam: V0 :e VFam.
  { exact (HGsub V0 HV0G). }
  apply (ReplE_impred Y (fun y0:set => Vof y0) V0 HV0VFam).
  let y0. assume Hy0Y: y0 :e Y.
  assume HV0eq: V0 = Vof y0.
  claim Hp: y0 :e Y /\ V0 = Vof y0.
  { exact (andI (y0 :e Y) (V0 = Vof y0) Hy0Y HV0eq). }
  claim HpickY: pickY V0 :e Y /\ V0 = Vof (pickY V0).
  { exact (Eps_i_ax (fun y:set => y :e Y /\ V0 = Vof y) y0 Hp). }
  claim Hpick: pickY V0 :e Y.
  { exact (andEL (pickY V0 :e Y) (V0 = Vof (pickY V0)) HpickY). }
  claim HV0rep: V0 = Vof (pickY V0).
  { exact (andER (pickY V0 :e Y) (V0 = Vof (pickY V0)) HpickY). }
  claim HUof: (Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)) /\ (Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty.
  { exact (Uof_props (pickY V0) Hpick). }
  claim HUofdisj: (Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty.
  { exact (andER ((Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)))
                 ((Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty) HUof). }
  claim HzUof: z :e (Uof (pickY V0)).
  { claim Hall: forall T:set, T :e UFam -> z :e T.
    { exact (SepE2 X (fun z0:set => forall T:set, T :e UFam -> z0 :e T) z HzU). }
    apply Hall.
    exact (ReplI G (fun V1:set => Uof (pickY V1)) V0 HV0G). }
  claim HzVof: z :e (Vof (pickY V0)).
  { rewrite <- HV0rep at 1.
    exact HzV0. }
  claim HzInt: z :e (Uof (pickY V0)) :/\: (Vof (pickY V0)).
  { exact (binintersectI (Uof (pickY V0)) (Vof (pickY V0)) z HzUof HzVof). }
  claim HzEmpty: z :e Empty.
  { rewrite <- HUofdisj at 1.
    exact HzInt. }
  exact (EmptyE z HzEmpty False). }

witness U.
witness V.
prove U :e Tx /\ V :e Tx /\ x :e U /\ Y c= V /\ U :/\: V = Empty.
apply andI.
- apply andI.
  + apply andI.
    * apply andI.
      - exact HUopen.
      - exact HVopen.
    * exact HxU.
  + exact HYsubV.
- exact HUVdisj.
Qed.

(** from 26 Theorem 26.5: compactness preserved under continuous maps **) 
(** LATEX VERSION: The continuous image of a compact space is compact (in the subspace topology on the image). **)
Definition image_of_fun : set -> set -> set := fun f X => image_of f X.

Theorem continuous_image_compact : forall X Tx Y Ty f:set,
  compact_space X Tx -> continuous_map X Tx Y Ty f ->
  compact_space (image_of_fun f X) (subspace_topology Y Ty (image_of_fun f X)).
let X Tx Y Ty f.
assume Hcomp: compact_space X Tx.
assume Hf: continuous_map X Tx Y Ty f.
prove compact_space (image_of_fun f X) (subspace_topology Y Ty (image_of_fun f X)).
set Img := image_of_fun f X.
set Timg := subspace_topology Y Ty Img.
claim HTx: topology_on X Tx.
{ exact (compact_space_topology X Tx Hcomp). }
claim HsubcoverX: forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam.
{ exact (compact_space_subcover_property X Tx Hcomp). }

claim Hf_left: ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y) /\ (forall V:set, V :e Ty -> preimage_of X f V :e Tx).
{ exact Hf. }
claim Hf_mid: (topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y.
{ exact (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               Hf_left). }
claim Hf_pre: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
{ exact (andER ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               Hf_left). }
claim HtopXY: topology_on X Tx /\ topology_on Y Ty.
{ exact (andEL (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y) Hf_mid). }
claim HTy: topology_on Y Ty.
{ exact (andER (topology_on X Tx) (topology_on Y Ty) HtopXY). }
claim Hfun: function_on f X Y.
{ exact (andER (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y) Hf_mid). }

claim HImgSubY: Img c= Y.
{ let y. assume Hy: y :e Img.
  apply (ReplE_impred X (fun x0:set => apply_fun f x0) y Hy).
  let x0. assume Hx0X: x0 :e X.
  assume Heq: y = apply_fun f x0.
  rewrite Heq.
  exact (Hfun x0 Hx0X). }

claim Hprop: forall Fam:set, (Fam c= Ty /\ Img c= Union Fam) -> has_finite_subcover Img Ty Fam.
{ let Fam. assume Hcov: Fam c= Ty /\ Img c= Union Fam.
  claim HFamSub: Fam c= Ty.
  { exact (andEL (Fam c= Ty) (Img c= Union Fam) Hcov). }
  claim HImgCov: Img c= Union Fam.
  { exact (andER (Fam c= Ty) (Img c= Union Fam) Hcov). }

  set PreFam := {preimage_of X f V|V :e Fam}.

  claim HPrePow: PreFam c= Power X.
  { let W. assume HW: W :e PreFam.
    apply (ReplE_impred Fam (fun V0:set => preimage_of X f V0) W HW).
    let V0. assume HV0: V0 :e Fam.
    assume HWeq: W = preimage_of X f V0.
    rewrite HWeq.
    prove preimage_of X f V0 :e Power X.
    apply PowerI.
    let x0. assume Hx0: x0 :e preimage_of X f V0.
    apply (SepE X (fun u:set => apply_fun f u :e V0) x0 Hx0).
    assume Hx0X. assume _. exact Hx0X. }

  claim HPreOpen: forall W:set, W :e PreFam -> W :e Tx.
  { let W. assume HW: W :e PreFam.
    apply (ReplE_impred Fam (fun V0:set => preimage_of X f V0) W HW).
    let V0. assume HV0: V0 :e Fam.
    assume HWeq: W = preimage_of X f V0.
    claim HV0Ty: V0 :e Ty.
    { exact (HFamSub V0 HV0). }
    rewrite HWeq.
    exact (Hf_pre V0 HV0Ty). }

  claim HXcov: X c= Union PreFam.
  { let x0. assume Hx0X: x0 :e X.
    prove x0 :e Union PreFam.
    claim HyImg: apply_fun f x0 :e Img.
    { exact (ReplI X (fun x1:set => apply_fun f x1) x0 Hx0X). }
    claim HyUnion: apply_fun f x0 :e Union Fam.
    { exact (HImgCov (apply_fun f x0) HyImg). }
    apply (UnionE_impred Fam (apply_fun f x0) HyUnion).
    let V0. assume HyV0: apply_fun f x0 :e V0.
    assume HV0: V0 :e Fam.
    claim Hx0Pre: x0 :e preimage_of X f V0.
    { prove x0 :e {u :e X | apply_fun f u :e V0}.
      apply SepI.
      - exact Hx0X.
      - exact HyV0. }
    exact (UnionI PreFam x0 (preimage_of X f V0) Hx0Pre
                 (ReplI Fam (fun V1:set => preimage_of X f V1) V0 HV0)). }

  claim HopenCov: open_cover_of X Tx PreFam.
  { prove topology_on X Tx /\ PreFam c= Power X /\ X c= Union PreFam /\ (forall U:set, U :e PreFam -> U :e Tx).
    apply andI.
    - (** left-associative: ((A /\ B) /\ C) **)
      apply andI.
      + apply andI.
        * exact HTx.
        * exact HPrePow.
      + exact HXcov.
    - exact HPreOpen. }

  claim HfinPre: has_finite_subcover X Tx PreFam.
  { exact (HsubcoverX PreFam HopenCov). }

  apply HfinPre.
  let Gpre. assume HGpre: Gpre c= PreFam /\ finite Gpre /\ X c= Union Gpre.
  claim HGpreLeft: Gpre c= PreFam /\ finite Gpre.
  { exact (andEL (Gpre c= PreFam /\ finite Gpre) (X c= Union Gpre) HGpre). }
  claim HGpreSub: Gpre c= PreFam.
  { exact (andEL (Gpre c= PreFam) (finite Gpre) HGpreLeft). }
  claim HGpreFin: finite Gpre.
  { exact (andER (Gpre c= PreFam) (finite Gpre) HGpreLeft). }
  claim HXcovGpre: X c= Union Gpre.
  { exact (andER (Gpre c= PreFam /\ finite Gpre) (X c= Union Gpre) HGpre). }

  set pickV := fun W:set => Eps_i (fun V0:set => V0 :e Fam /\ W = preimage_of X f V0).
  set G := {pickV W|W :e Gpre}.

  claim HGsubFam: G c= Fam.
  { let V0. assume HV0: V0 :e G.
    apply (ReplE_impred Gpre (fun W0:set => pickV W0) V0 HV0).
    let W0. assume HW0G: W0 :e Gpre.
    assume HV0eq: V0 = pickV W0.
    claim HW0Pre: W0 :e PreFam.
    { exact (HGpreSub W0 HW0G). }
    claim Hex: exists V1:set, V1 :e Fam /\ W0 = preimage_of X f V1.
    { apply (ReplE_impred Fam (fun V2:set => preimage_of X f V2) W0 HW0Pre).
      let V2. assume HV2: V2 :e Fam.
      assume HW0eq2: W0 = preimage_of X f V2.
      witness V2.
      exact (andI (V2 :e Fam) (W0 = preimage_of X f V2) HV2 HW0eq2). }
    apply Hex.
    let V1. assume HV1: V1 :e Fam /\ W0 = preimage_of X f V1.
    claim Hpick: pickV W0 :e Fam /\ W0 = preimage_of X f (pickV W0).
    { exact (Eps_i_ax (fun V:set => V :e Fam /\ W0 = preimage_of X f V) V1 HV1). }
    rewrite HV0eq.
    exact (andEL (pickV W0 :e Fam) (W0 = preimage_of X f (pickV W0)) Hpick). }

  claim HGfin: finite G.
  { exact (Repl_finite (fun W0:set => pickV W0) Gpre HGpreFin). }

  claim HImgCovG: Img c= Union G.
  { let y. assume Hy: y :e Img.
    prove y :e Union G.
    apply (ReplE_impred X (fun x0:set => apply_fun f x0) y Hy).
    let x0. assume Hx0X: x0 :e X.
    assume Heq: y = apply_fun f x0.
    claim Hx0UG: x0 :e Union Gpre.
    { exact (HXcovGpre x0 Hx0X). }
    apply (UnionE_impred Gpre x0 Hx0UG).
    let W0. assume Hx0W0: x0 :e W0.
    assume HW0G: W0 :e Gpre.
    claim HW0Pre: W0 :e PreFam.
    { exact (HGpreSub W0 HW0G). }
    claim Hex: exists V1:set, V1 :e Fam /\ W0 = preimage_of X f V1.
    { apply (ReplE_impred Fam (fun V2:set => preimage_of X f V2) W0 HW0Pre).
      let V2. assume HV2: V2 :e Fam.
      assume HW0eq2: W0 = preimage_of X f V2.
      witness V2.
      exact (andI (V2 :e Fam) (W0 = preimage_of X f V2) HV2 HW0eq2). }
    apply Hex.
    let V1. assume HV1: V1 :e Fam /\ W0 = preimage_of X f V1.
    claim Hpick: pickV W0 :e Fam /\ W0 = preimage_of X f (pickV W0).
    { exact (Eps_i_ax (fun V:set => V :e Fam /\ W0 = preimage_of X f V) V1 HV1). }
    claim HW0eq: W0 = preimage_of X f (pickV W0).
    { exact (andER (pickV W0 :e Fam) (W0 = preimage_of X f (pickV W0)) Hpick). }
    claim Hx0Pre: x0 :e preimage_of X f (pickV W0).
    { rewrite <- HW0eq at 1.
      exact Hx0W0. }
    claim HyV: apply_fun f x0 :e pickV W0.
    { apply (SepE X (fun u:set => apply_fun f u :e pickV W0) x0 Hx0Pre).
      assume _. assume Hy0. exact Hy0. }
    rewrite Heq.
    exact (UnionI G (apply_fun f x0) (pickV W0) HyV (ReplI Gpre (fun W1:set => pickV W1) W0 HW0G)). }

  exact (has_finite_subcoverI Img Ty Fam G (andI (G c= Fam /\ finite G) (Img c= Union G)
                                                 (andI (G c= Fam) (finite G) HGsubFam HGfin)
                                                 HImgCovG)). }

exact (iffER (compact_space Img Timg)
             (forall Fam:set, (Fam c= Ty /\ Img c= Union Fam) -> has_finite_subcover Img Ty Fam)
             (compact_subspace_via_ambient_covers Y Ty Img HTy HImgSubY)
             Hprop).
Qed.

(** from 26: tube lemma used in product compactness **)
(** LATEX VERSION: Tube lemma: in XY with Y compact, a neighborhood of {x0}Y contains some UY. **)
(** FIXED: Use setprod U {y} c= N (subset) rather than setprod U y :e N; tube lemma encodes UY c= N and can be viewed pointwise as forall y:e Y, setprod U {y} c= N. **)
Theorem tube_lemma : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  compact_space Y Ty ->
  forall x0:set, x0 :e X ->
  forall N:set, N :e product_topology X Tx Y Ty /\ setprod {x0} Y c= N ->
    exists U:set, U :e Tx /\ x0 :e U /\
      setprod U Y c= N.
let X Tx Y Ty.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
assume Hcomp: compact_space Y Ty.
let x0.
assume Hx0: x0 :e X.
let N.
assume HN: N :e product_topology X Tx Y Ty /\ setprod {x0} Y c= N.
prove exists U:set, U :e Tx /\ x0 :e U /\ setprod U Y c= N.
(** Use that N is open in the topology generated by the product basis, then cover Y by suitable open slices. **)
set B := product_subbasis X Tx Y Ty.
claim HBasis: basis_on (setprod X Y) B.
{ exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
claim HNtop: N :e generated_topology (setprod X Y) B.
{ exact (andEL (N :e product_topology X Tx Y Ty) (setprod {x0} Y c= N) HN). }
claim HNsub: setprod {x0} Y c= N.
{ exact (andER (N :e product_topology X Tx Y Ty) (setprod {x0} Y c= N) HN). }
claim HNrefine: forall p :e N, exists b :e B, p :e b /\ b c= N.
{ exact (SepE2 (Power (setprod X Y))
               (fun U0:set => forall x :e U0, exists b :e B, x :e b /\ b c= U0)
               N HNtop). }
set VFam := {V :e Ty|exists U:set, U :e Tx /\ x0 :e U /\ setprod U V c= N}.
claim HVFamSubTy: VFam c= Ty.
{ let V. assume HV: V :e VFam.
  exact (SepE1 Ty (fun V0:set => exists U:set, U :e Tx /\ x0 :e U /\ setprod U V0 c= N) V HV). }
claim HtopY: topology_on Y Ty.
{ exact (compact_space_topology Y Ty Hcomp). }
claim HTyPow: Ty c= Power Y.
{ exact (topology_subset_axiom Y Ty HtopY). }
claim HVFamPowY: VFam c= Power Y.
{ let V. assume HV: V :e VFam.
  claim HVTy: V :e Ty.
  { exact (HVFamSubTy V HV). }
  exact (HTyPow V HVTy). }
claim HYcov: Y c= Union VFam.
{ let y. assume Hy: y :e Y.
  prove y :e Union VFam.
  set p := (x0,y).
  claim HpXY: p :e setprod {x0} Y.
  { exact (tuple_2_setprod {x0} Y x0 (SingI x0) y Hy). }
  claim HpN: p :e N.
  { exact (HNsub p HpXY). }
  claim Hrect: exists b :e B, p :e b /\ b c= N.
  { exact (HNrefine p HpN). }
  apply Hrect.
  let b. assume Hbpair.
  claim HbB: b :e B.
  { exact (andEL (b :e B) (p :e b /\ b c= N) Hbpair). }
  claim Hbprop: p :e b /\ b c= N.
  { exact (andER (b :e B) (p :e b /\ b c= N) Hbpair). }
  claim Hpb: p :e b.
  { exact (andEL (p :e b) (b c= N) Hbprop). }
  claim HbsubN: b c= N.
  { exact (andER (p :e b) (b c= N) Hbprop). }
  apply (famunionE_impred Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) b HbB).
  let U0. assume HU0Tx: U0 :e Tx.
  assume HbIn: b :e {rectangle_set U0 V0|V0 :e Ty}.
  apply (ReplE_impred Ty (fun V0:set => rectangle_set U0 V0) b HbIn).
  let V0. assume HV0Ty: V0 :e Ty.
  assume HbEq: b = rectangle_set U0 V0.
  claim HpUV: p :e setprod U0 V0.
  { prove p :e rectangle_set U0 V0.
    rewrite <- HbEq at 1.
    exact Hpb. }
  claim HpXY0: p :e setprod {x0} {y}.
  { exact (tuple_2_setprod {x0} {y} x0 (SingI x0) y (SingI y)). }
  claim Hcoords: x0 :e U0 /\ y :e V0.
  { exact (setprod_coords_in x0 y U0 V0 p HpXY0 HpUV). }
  claim Hx0U0: x0 :e U0.
  { exact (andEL (x0 :e U0) (y :e V0) Hcoords). }
  claim HyV0: y :e V0.
  { exact (andER (x0 :e U0) (y :e V0) Hcoords). }
  claim HrectSub: setprod U0 V0 c= N.
  { rewrite <- HbEq at 1.
    exact HbsubN. }
  claim HV0Fam: V0 :e VFam.
  { apply (SepI Ty (fun V1:set => exists U1:set, U1 :e Tx /\ x0 :e U1 /\ setprod U1 V1 c= N) V0 HV0Ty).
    witness U0.
    exact (andI (U0 :e Tx /\ x0 :e U0) (setprod U0 V0 c= N)
                (andI (U0 :e Tx) (x0 :e U0) HU0Tx Hx0U0)
                HrectSub). }
  exact (UnionI VFam y V0 HyV0 HV0Fam). }
claim HVFamCover: open_cover_of Y Ty VFam.
{ prove topology_on Y Ty /\ VFam c= Power Y /\ Y c= Union VFam /\ (forall U:set, U :e VFam -> U :e Ty).
  (** conjunction is left-associative: (((A /\ B) /\ C) /\ D) **)
  apply andI.
  - apply andI.
    + apply andI.
      * exact HtopY.
      * exact HVFamPowY.
    + exact HYcov.
  - let V. assume HV: V :e VFam.
    exact (HVFamSubTy V HV). }
claim Hfin: has_finite_subcover Y Ty VFam.
{ exact (Heine_Borel_subcover Y Ty VFam Hcomp HVFamCover). }
apply Hfin.
let G. assume HGtriple: G c= VFam /\ finite G /\ Y c= Union G.
set pickU := fun V:set => Eps_i (fun U0:set => U0 :e Tx /\ x0 :e U0 /\ setprod U0 V c= N).
claim HpickU: forall V:set, V :e VFam -> pickU V :e Tx /\ x0 :e pickU V /\ setprod (pickU V) V c= N.
{ let V. assume HV: V :e VFam.
  claim Hex: exists U0:set, U0 :e Tx /\ x0 :e U0 /\ setprod U0 V c= N.
  { exact (SepE2 Ty (fun V0:set => exists U0:set, U0 :e Tx /\ x0 :e U0 /\ setprod U0 V0 c= N) V HV). }
  apply Hex.
  let U0. assume HU0: U0 :e Tx /\ x0 :e U0 /\ setprod U0 V c= N.
  claim Hax: pickU V :e Tx /\ x0 :e pickU V /\ setprod (pickU V) V c= N.
  { exact (Eps_i_ax (fun U1:set => U1 :e Tx /\ x0 :e U1 /\ setprod U1 V c= N) U0 HU0). }
  exact Hax. }
claim HGsub: G c= VFam.
{ exact (andEL (G c= VFam) (finite G) (andEL (G c= VFam /\ finite G) (Y c= Union G) HGtriple)). }
claim HGfin: finite G.
{ exact (andER (G c= VFam) (finite G) (andEL (G c= VFam /\ finite G) (Y c= Union G) HGtriple)). }
claim HYcovG: Y c= Union G.
{ exact (andER (G c= VFam /\ finite G) (Y c= Union G) HGtriple). }
set UFam := {pickU V|V :e G}.
claim HUFamFin: finite UFam.
{ exact (Repl_finite (fun V:set => pickU V) G HGfin). }
claim HUFamPow: UFam :e Power Tx.
{ apply PowerI Tx UFam.
  let U0. assume HU0: U0 :e UFam.
  prove U0 :e Tx.
  apply (ReplE_impred G (fun V0:set => pickU V0) U0 HU0).
  let V0. assume HV0G: V0 :e G.
  assume HU0Eq: U0 = pickU V0.
  claim HV0Fam: V0 :e VFam.
  { exact (HGsub V0 HV0G). }
  claim HU0Prop: pickU V0 :e Tx /\ x0 :e pickU V0 /\ setprod (pickU V0) V0 c= N.
  { exact (HpickU V0 HV0Fam). }
  claim HU0AB: pickU V0 :e Tx /\ x0 :e pickU V0.
  { exact (andEL (pickU V0 :e Tx /\ x0 :e pickU V0) (setprod (pickU V0) V0 c= N) HU0Prop). }
  claim HU0Tx: pickU V0 :e Tx.
  { exact (andEL (pickU V0 :e Tx) (x0 :e pickU V0) HU0AB). }
  rewrite HU0Eq.
  exact HU0Tx. }
set U := intersection_of_family X UFam.
claim HUinTx: U :e Tx.
{ exact (finite_intersection_in_topology X Tx UFam HTx HUFamPow HUFamFin). }
claim Hx0U: x0 :e U.
{ prove x0 :e intersection_of_family X UFam.
  claim Hall: forall W:set, W :e UFam -> x0 :e W.
  { let W. assume HW: W :e UFam.
    prove x0 :e W.
    apply (ReplE_impred G (fun V0:set => pickU V0) W HW).
    let V0. assume HV0G: V0 :e G.
    assume HWEq: W = pickU V0.
    claim HV0Fam: V0 :e VFam.
    { exact (HGsub V0 HV0G). }
    claim HWProp: pickU V0 :e Tx /\ x0 :e pickU V0 /\ setprod (pickU V0) V0 c= N.
    { exact (HpickU V0 HV0Fam). }
    claim HWPropAB: pickU V0 :e Tx /\ x0 :e pickU V0.
    { exact (andEL (pickU V0 :e Tx /\ x0 :e pickU V0) (setprod (pickU V0) V0 c= N) HWProp). }
    claim Hx0Pick: x0 :e pickU V0.
    { exact (andER (pickU V0 :e Tx) (x0 :e pickU V0) HWPropAB). }
    rewrite HWEq.
    exact Hx0Pick. }
  exact (SepI X (fun x:set => forall W:set, W :e UFam -> x :e W) x0 Hx0 Hall). }
claim HUsubN: setprod U Y c= N.
{ let p. assume Hp: p :e setprod U Y.
  prove p :e N.
  claim Hp0: p 0 :e U.
  { exact (ap0_Sigma U (fun u:set => Y) p Hp). }
  claim Hp1: p 1 :e Y.
  { exact (ap1_Sigma U (fun u:set => Y) p Hp). }
  claim HpEta: p = (p 0, p 1).
  { exact (setprod_eta U Y p Hp). }
  claim Hp1InUnion: p 1 :e Union G.
  { exact (HYcovG (p 1) Hp1). }
  apply (UnionE_impred G (p 1) Hp1InUnion).
  let V0. assume Hp1V0: p 1 :e V0.
  assume HV0G: V0 :e G.
  claim HV0Fam: V0 :e VFam.
  { exact (HGsub V0 HV0G). }
  claim HV0Ty: V0 :e Ty.
  { exact (HVFamSubTy V0 HV0Fam). }
  claim Hpick: pickU V0 :e Tx /\ x0 :e pickU V0 /\ setprod (pickU V0) V0 c= N.
  { exact (HpickU V0 HV0Fam). }
  claim HrectSubN: setprod (pickU V0) V0 c= N.
  { exact (andER (pickU V0 :e Tx /\ x0 :e pickU V0) (setprod (pickU V0) V0 c= N) Hpick). }
  claim Hp0Pick: p 0 :e pickU V0.
  { claim Hp0All: forall W:set, W :e UFam -> p 0 :e W.
    { exact (SepE2 X (fun x:set => forall W:set, W :e UFam -> x :e W) (p 0) Hp0). }
    claim Hmem: pickU V0 :e UFam.
    { exact (ReplI G (fun V1:set => pickU V1) V0 HV0G). }
    exact (Hp0All (pickU V0) Hmem). }
  claim HpairIn: (p 0, p 1) :e setprod (pickU V0) V0.
  { exact (tuple_2_setprod (pickU V0) V0 (p 0) Hp0Pick (p 1) Hp1V0). }
  claim HpN: (p 0, p 1) :e N.
  { exact (HrectSubN (p 0, p 1) HpairIn). }
  rewrite HpEta.
  exact HpN. }
witness U.
exact (andI (U :e Tx /\ x0 :e U) (setprod U Y c= N)
            (andI (U :e Tx) (x0 :e U) HUinTx Hx0U)
            HUsubN).
Qed.

(** from 26 Theorem 26.6: compact-to-Hausdorff bijection is a homeomorphism **) 
(** LATEX VERSION: A continuous bijection from compact space to Hausdorff space is a homeomorphism. **)
Definition bijection : set -> set -> set -> prop := fun X Y f =>
  function_on f X Y /\
  (forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun f x = y /\
     (forall x':set, x' :e X -> apply_fun f x' = y -> x' = x)).

Definition inv_fun_graph : set -> set -> set -> set := fun X f Y =>
  {(y, inv X (fun x:set => apply_fun f x) y)|y :e Y}.

Theorem inv_fun_graph_apply : forall X Y f y:set,
  y :e Y -> apply_fun (inv_fun_graph X f Y) y = inv X (fun x:set => apply_fun f x) y.
let X Y f y.
assume Hy: y :e Y.
prove apply_fun (inv_fun_graph X f Y) y = inv X (fun x:set => apply_fun f x) y.
prove apply_fun {(y0, inv X (fun x:set => apply_fun f x) y0) | y0 :e Y} y = inv X (fun x:set => apply_fun f x) y.
prove Eps_i (fun z => (y,z) :e {(y0, inv X (fun x:set => apply_fun f x) y0) | y0 :e Y}) =
      inv X (fun x:set => apply_fun f x) y.
claim H1: (y, inv X (fun x:set => apply_fun f x) y) :e {(y0, inv X (fun x:set => apply_fun f x) y0) | y0 :e Y}.
{ exact (ReplI Y (fun y0:set => (y0, inv X (fun x:set => apply_fun f x) y0)) y Hy). }
claim H2: (y, Eps_i (fun z => (y,z) :e {(y0, inv X (fun x:set => apply_fun f x) y0) | y0 :e Y})) :e
          {(y0, inv X (fun x:set => apply_fun f x) y0) | y0 :e Y}.
{ exact (Eps_i_ax (fun z => (y,z) :e {(y0, inv X (fun x:set => apply_fun f x) y0) | y0 :e Y})
                  (inv X (fun x:set => apply_fun f x) y) H1). }
apply (ReplE_impred Y (fun y0:set => (y0, inv X (fun x:set => apply_fun f x) y0))
                    (y, Eps_i (fun z => (y,z) :e {(y0, inv X (fun x:set => apply_fun f x) y0) | y0 :e Y})) H2).
let y0.
assume Hy0: y0 :e Y.
assume Heq: (y, Eps_i (fun z => (y,z) :e {(y1, inv X (fun x:set => apply_fun f x) y1) | y1 :e Y})) =
            (y0, inv X (fun x:set => apply_fun f x) y0).
claim Hy_eq: y = y0.
{ rewrite <- (tuple_2_0_eq y (Eps_i (fun z => (y,z) :e {(y1, inv X (fun x:set => apply_fun f x) y1) | y1 :e Y}))).
  rewrite <- (tuple_2_0_eq y0 (inv X (fun x:set => apply_fun f x) y0)).
  rewrite Heq.
  reflexivity. }
claim Hz_eq: Eps_i (fun z => (y,z) :e {(y1, inv X (fun x:set => apply_fun f x) y1) | y1 :e Y}) =
             inv X (fun x:set => apply_fun f x) y0.
{ rewrite <- (tuple_2_1_eq y (Eps_i (fun z => (y,z) :e {(y1, inv X (fun x:set => apply_fun f x) y1) | y1 :e Y}))).
  rewrite <- (tuple_2_1_eq y0 (inv X (fun x:set => apply_fun f x) y0)).
  rewrite Heq.
  reflexivity. }
rewrite Hz_eq.
rewrite <- Hy_eq.
reflexivity.
Qed.

Theorem bijection_surj : forall X Y f y:set,
  bijection X Y f -> y :e Y -> exists x:set, x :e X /\ apply_fun f x = y.
let X Y f y.
assume Hbij: bijection X Y f.
assume Hy: y :e Y.
apply Hbij.
assume Hfun: function_on f X Y.
assume Huniq.
apply (Huniq y Hy).
let x.
assume Hx: x :e X /\ apply_fun f x = y /\ (forall x':set, x' :e X -> apply_fun f x' = y -> x' = x).
witness x.
claim Hx0: x :e X /\ apply_fun f x = y.
{ exact (andEL (x :e X /\ apply_fun f x = y)
               (forall x':set, x' :e X -> apply_fun f x' = y -> x' = x) Hx). }
exact Hx0.
Qed.

Theorem bijection_inj : forall X Y f u v:set,
  bijection X Y f -> u :e X -> v :e X -> apply_fun f u = apply_fun f v -> u = v.
let X Y f u v.
assume Hbij: bijection X Y f.
assume HuX: u :e X.
assume HvX: v :e X.
assume Heq: apply_fun f u = apply_fun f v.
apply Hbij.
assume Hfun: function_on f X Y.
assume Huniq.
claim HyY: apply_fun f u :e Y.
{ exact (Hfun u HuX). }
apply (Huniq (apply_fun f u) HyY).
let x.
assume Hx: x :e X /\ apply_fun f x = apply_fun f u /\
           (forall x':set, x' :e X -> apply_fun f x' = apply_fun f u -> x' = x).
claim Hxuniq: forall x':set, x' :e X -> apply_fun f x' = apply_fun f u -> x' = x.
{ exact (andER (x :e X /\ apply_fun f x = apply_fun f u)
               (forall x':set, x' :e X -> apply_fun f x' = apply_fun f u -> x' = x)
               Hx). }
claim Hu: u = x.
{ apply (Hxuniq u HuX).
  reflexivity. }
claim Hv: v = x.
{ apply (Hxuniq v HvX).
  symmetry.
  exact Heq. }
rewrite Hu.
rewrite Hv.
reflexivity.
Qed.

Theorem inv_fun_graph_right_inverse : forall X Y f y:set,
  bijection X Y f -> y :e Y -> apply_fun f (apply_fun (inv_fun_graph X f Y) y) = y.
let X Y f y.
assume Hbij: bijection X Y f.
assume Hy: y :e Y.
prove apply_fun f (apply_fun (inv_fun_graph X f Y) y) = y.
claim Hginv: apply_fun (inv_fun_graph X f Y) y = inv X (fun u:set => apply_fun f u) y.
{ exact (inv_fun_graph_apply X Y f y Hy). }
rewrite Hginv.
claim Hsurj: forall w :e Y, exists u :e X, apply_fun f u = w.
{ let w. assume Hw: w :e Y.
  claim Hex: exists u:set, u :e X /\ apply_fun f u = w.
  { exact (bijection_surj X Y f w Hbij Hw). }
  exact Hex. }
claim Hpair: inv X (fun u:set => apply_fun f u) y :e X /\
             apply_fun f (inv X (fun u:set => apply_fun f u) y) = y.
{ exact (surj_rinv X Y (fun u:set => apply_fun f u) Hsurj y Hy). }
exact (andER (inv X (fun u:set => apply_fun f u) y :e X)
             (apply_fun f (inv X (fun u:set => apply_fun f u) y) = y)
             Hpair).
Qed.

Theorem inv_fun_graph_left_inverse : forall X Y f x:set,
  bijection X Y f -> x :e X -> apply_fun (inv_fun_graph X f Y) (apply_fun f x) = x.
let X Y f x.
assume Hbij: bijection X Y f.
assume Hx: x :e X.
prove apply_fun (inv_fun_graph X f Y) (apply_fun f x) = x.
claim Hfun: function_on f X Y.
{ exact (andEL (function_on f X Y)
               (forall y:set, y :e Y -> exists x0:set, x0 :e X /\ apply_fun f x0 = y /\ (forall x':set, x' :e X -> apply_fun f x' = y -> x' = x0))
               Hbij). }
claim HyY: apply_fun f x :e Y.
{ exact (Hfun x Hx). }
claim Hginv: apply_fun (inv_fun_graph X f Y) (apply_fun f x) =
             inv X (fun u:set => apply_fun f u) (apply_fun f x).
{ exact (inv_fun_graph_apply X Y f (apply_fun f x) HyY). }
rewrite Hginv.
claim Hinj: forall u v :e X, apply_fun f u = apply_fun f v -> u = v.
{ let u. assume Hu: u :e X.
  let v. assume Hv: v :e X.
  assume Heq.
  exact (bijection_inj X Y f u v Hbij Hu Hv Heq). }
exact (inj_linv X (fun u:set => apply_fun f u) Hinj x Hx).
Qed.

Theorem inv_fun_graph_preimage_eq_image : forall X Y f A:set,
  bijection X Y f -> A c= X ->
  preimage_of Y (inv_fun_graph X f Y) A = image_of_fun f A.
let X Y f A.
assume Hbij: bijection X Y f.
assume HA: A c= X.
set g := inv_fun_graph X f Y.
apply set_ext.
- let y. assume Hy: y :e preimage_of Y g A.
  prove y :e image_of_fun f A.
  claim HyY: y :e Y.
  { exact (SepE1 Y (fun u:set => apply_fun g u :e A) y Hy). }
  claim HgyA: apply_fun g y :e A.
  { exact (SepE2 Y (fun u:set => apply_fun g u :e A) y Hy). }
  claim Heq: apply_fun f (apply_fun g y) = y.
  { exact (inv_fun_graph_right_inverse X Y f y Hbij HyY). }
  claim HyImg: apply_fun f (apply_fun g y) :e image_of_fun f A.
  { exact (ReplI A (fun x0:set => apply_fun f x0) (apply_fun g y) HgyA). }
  rewrite <- Heq.
  exact HyImg.
- let y. assume Hy: y :e image_of_fun f A.
  prove y :e preimage_of Y g A.
  apply (ReplE_impred A (fun x0:set => apply_fun f x0) y Hy).
  let x.
  assume HxA: x :e A.
  assume Heq: y = apply_fun f x.
  prove y :e {u :e Y | apply_fun g u :e A}.
  apply SepI.
  + claim HxX: x :e X.
    { exact (HA x HxA). }
    claim Hfun: function_on f X Y.
    { exact (andEL (function_on f X Y)
                   (forall y0:set, y0 :e Y -> exists x0:set, x0 :e X /\ apply_fun f x0 = y0 /\ (forall x':set, x' :e X -> apply_fun f x' = y0 -> x' = x0))
                   Hbij). }
    rewrite Heq.
    exact (Hfun x HxX).
  + prove apply_fun g y :e A.
    rewrite Heq.
    claim HxX: x :e X.
    { exact (HA x HxA). }
    claim Hinv: apply_fun g (apply_fun f x) = x.
    { exact (inv_fun_graph_left_inverse X Y f x Hbij HxX). }
    rewrite Hinv.
    exact HxA.
Qed.

Definition Abs : set -> set := abs_SNo.

Theorem compact_to_Hausdorff_inverse_continuous : forall X Tx Y Ty f:set,
  compact_space X Tx -> Hausdorff_space Y Ty ->
  continuous_map X Tx Y Ty f -> bijection X Y f ->
  continuous_map Y Ty X Tx (inv_fun_graph X f Y).
let X Tx Y Ty f.
assume Hcomp: compact_space X Tx.
assume HH: Hausdorff_space Y Ty.
assume Hcont: continuous_map X Tx Y Ty f.
assume Hbij: bijection X Y f.
set g := inv_fun_graph X f Y.
prove continuous_map Y Ty X Tx g.
prove topology_on Y Ty /\ topology_on X Tx /\ function_on g Y X /\
      forall V:set, V :e Tx -> preimage_of Y g V :e Ty.
claim HTx: topology_on X Tx.
{ exact (compact_space_topology X Tx Hcomp). }
claim HTy: topology_on Y Ty.
{ exact (andEL (topology_on Y Ty)
               (forall x1 x2:set, x1 :e Y -> x2 :e Y -> x1 <> x2 ->
                 exists U V:set, U :e Ty /\ V :e Ty /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }
claim Hfun: function_on f X Y.
{ exact (andEL (function_on f X Y)
               (forall y:set, y :e Y -> exists x0:set, x0 :e X /\ apply_fun f x0 = y /\ (forall x':set, x' :e X -> apply_fun f x' = y -> x' = x0))
               Hbij). }
claim Hgfun: function_on g Y X.
{ let y. assume Hy: y :e Y.
  prove apply_fun g y :e X.
  claim Hginv: apply_fun g y = inv X (fun u:set => apply_fun f u) y.
  { exact (inv_fun_graph_apply X Y f y Hy). }
  rewrite Hginv.
  claim Hsurj: forall w :e Y, exists u :e X, apply_fun f u = w.
  { let w. assume Hw: w :e Y.
    claim Hex: exists u:set, u :e X /\ apply_fun f u = w.
    { exact (bijection_surj X Y f w Hbij Hw). }
    exact Hex. }
  claim Hpair: inv X (fun u:set => apply_fun f u) y :e X /\
               apply_fun f (inv X (fun u:set => apply_fun f u) y) = y.
  { exact (surj_rinv X Y (fun u:set => apply_fun f u) Hsurj y Hy). }
  exact (andEL (inv X (fun u:set => apply_fun f u) y :e X)
               (apply_fun f (inv X (fun u:set => apply_fun f u) y) = y)
               Hpair). }

apply andI.
- apply andI.
  + apply andI.
    * exact HTy.
    * exact HTx.
  + exact Hgfun.
- let V. assume HV: V :e Tx.
  prove preimage_of Y g V :e Ty.
  set C := X :\: V.
  claim HCclosed: closed_in X Tx C.
  { exact (closed_of_open_complement X Tx V HTx HV). }
  claim HCsub: C c= X.
  { exact (closed_in_subset X Tx C HCclosed). }
  claim HpreCeq: preimage_of Y g C = image_of_fun f C.
  { exact (inv_fun_graph_preimage_eq_image X Y f C Hbij HCsub). }
  claim HimgSubY: image_of_fun f C c= Y.
  { let y. assume Hy: y :e image_of_fun f C.
    apply (ReplE_impred C (fun x0:set => apply_fun f x0) y Hy).
    let x0. assume Hx0C: x0 :e C.
    assume Heq: y = apply_fun f x0.
    claim Hx0X: x0 :e X.
    { exact (HCsub x0 Hx0C). }
    rewrite Heq.
    exact (Hfun x0 Hx0X). }
  claim HcompC: compact_space C (subspace_topology X Tx C).
  { exact (closed_subspace_compact X Tx C Hcomp HCclosed). }
  claim HcontC: continuous_map C (subspace_topology X Tx C) Y Ty f.
  { exact (continuous_on_subspace X Tx Y Ty f C HTx HCsub Hcont). }
  claim HimgComp: compact_space (image_of_fun f C) (subspace_topology Y Ty (image_of_fun f C)).
  { exact (continuous_image_compact C (subspace_topology X Tx C) Y Ty f HcompC HcontC). }
  claim HimgClosed: closed_in Y Ty (image_of_fun f C).
  { exact (compact_subspace_in_Hausdorff_closed Y Ty (image_of_fun f C) HH HimgSubY HimgComp). }
  claim HpreClosed: closed_in Y Ty (preimage_of Y g C).
  { rewrite HpreCeq at 1.
    exact HimgClosed. }
  claim Hop: open_in Y Ty (Y :\: preimage_of Y g C).
  { exact (open_of_closed_complement Y Ty (preimage_of Y g C) HpreClosed). }
  claim HopTy: (Y :\: preimage_of Y g C) :e Ty.
  { exact (andER (topology_on Y Ty) ((Y :\: preimage_of Y g C) :e Ty) Hop). }
  claim HpreEq: preimage_of Y g V = Y :\: preimage_of Y g C.
  { apply set_ext.
    - let y. assume Hy: y :e preimage_of Y g V.
      prove y :e Y :\: preimage_of Y g C.
      claim HyY: y :e Y.
      { exact (SepE1 Y (fun u:set => apply_fun g u :e V) y Hy). }
      claim HgyV: apply_fun g y :e V.
      { exact (SepE2 Y (fun u:set => apply_fun g u :e V) y Hy). }
      apply setminusI.
      + exact HyY.
      + assume HyC: y :e preimage_of Y g C.
        claim HgyC: apply_fun g y :e C.
        { exact (SepE2 Y (fun u:set => apply_fun g u :e C) y HyC). }
        apply (setminusE X V (apply_fun g y) HgyC).
        assume _. assume HnotV.
        exact (HnotV HgyV).
    - let y. assume Hy: y :e Y :\: preimage_of Y g C.
      prove y :e preimage_of Y g V.
      apply (setminusE Y (preimage_of Y g C) y Hy).
      assume HyY: y :e Y.
      assume HyNot: y /:e preimage_of Y g C.
      prove y :e {u :e Y | apply_fun g u :e V}.
      apply SepI.
      + exact HyY.
      + prove apply_fun g y :e V.
        claim HgyX: apply_fun g y :e X.
        { exact (Hgfun y HyY). }
        apply (xm (apply_fun g y :e V)).
        - assume HVin. exact HVin.
        - assume HnotV: ~(apply_fun g y :e V).
          claim HnotVin: apply_fun g y /:e V.
          { assume H0. exact (HnotV H0). }
          claim HgyC: apply_fun g y :e C.
          { exact (setminusI X V (apply_fun g y) HgyX HnotVin). }
          claim HyC: y :e preimage_of Y g C.
          { prove y :e {u :e Y | apply_fun g u :e C}.
            apply SepI.
            - exact HyY.
            - exact HgyC. }
          apply FalseE.
          exact (HyNot HyC). }
  rewrite HpreEq.
  exact HopTy.
Qed.

Theorem compact_to_Hausdorff_bijection_homeomorphism : forall X Tx Y Ty f:set,
  compact_space X Tx -> Hausdorff_space Y Ty ->
  continuous_map X Tx Y Ty f -> bijection X Y f ->
  homeomorphism X Tx Y Ty f.
let X Tx Y Ty f.
assume Hcomp: compact_space X Tx.
assume HH: Hausdorff_space Y Ty.
assume Hcont: continuous_map X Tx Y Ty f.
assume Hbij: bijection X Y f.
prove homeomorphism X Tx Y Ty f.
prove continuous_map X Tx Y Ty f /\
      exists g:set, continuous_map Y Ty X Tx g /\
        (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
        (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y).
apply andI.
- exact Hcont.
- set g := inv_fun_graph X f Y.
  witness g.
  apply andI.
  + apply andI.
    * exact (compact_to_Hausdorff_inverse_continuous X Tx Y Ty f Hcomp HH Hcont Hbij).
    * let x. assume Hx: x :e X.
      prove apply_fun g (apply_fun f x) = x.
      claim Hfun: function_on f X Y.
      { exact (andEL (function_on f X Y)
                     (forall y:set, y :e Y -> exists x0:set, x0 :e X /\ apply_fun f x0 = y /\ (forall x':set, x' :e X -> apply_fun f x' = y -> x' = x0))
                     Hbij). }
      claim HyY: apply_fun f x :e Y.
      { exact (Hfun x Hx). }
      claim Hginv: apply_fun g (apply_fun f x) = inv X (fun u:set => apply_fun f u) (apply_fun f x).
      { exact (inv_fun_graph_apply X Y f (apply_fun f x) HyY). }
      rewrite Hginv.
      claim Hinj: forall u v :e X, apply_fun f u = apply_fun f v -> u = v.
      { let u. assume Hu: u :e X.
        let v. assume Hv: v :e X.
        assume Heq.
        exact (bijection_inj X Y f u v Hbij Hu Hv Heq). }
      exact (inj_linv X (fun u:set => apply_fun f u) Hinj x Hx).
  + let y. assume Hy: y :e Y.
    prove apply_fun f (apply_fun g y) = y.
    claim Hginv: apply_fun g y = inv X (fun u:set => apply_fun f u) y.
    { exact (inv_fun_graph_apply X Y f y Hy). }
    rewrite Hginv.
    claim Hsurj: forall w :e Y, exists u :e X, apply_fun f u = w.
    { let w. assume Hw: w :e Y.
      claim Hex: exists u:set, u :e X /\ apply_fun f u = w.
      { exact (bijection_surj X Y f w Hbij Hw). }
      exact Hex. }
    claim Hpair: inv X (fun u:set => apply_fun f u) y :e X /\
                 apply_fun f (inv X (fun u:set => apply_fun f u) y) = y.
    { exact (surj_rinv X Y (fun u:set => apply_fun f u) Hsurj y Hy). }
    exact (andER (inv X (fun u:set => apply_fun f u) y :e X)
                 (apply_fun f (inv X (fun u:set => apply_fun f u) y) = y)
                 Hpair).
Qed.

(** LATEX VERSION: A subset A is bounded if |x|M for some real M. **)
Definition bounded_subset_of_reals : set -> prop := fun A =>
  exists M:set, M :e R /\ forall x:set, x :e A -> ~(Rlt M (Abs x)).

(** helper: elements of omega are reals **)
Theorem omega_in_R : forall n:set, n :e omega -> n :e R.
let n. assume Hn: n :e omega.
claim HnSNoS: n :e SNoS_ omega.
{ exact (omega_SNoS_omega n Hn). }
exact (SNoS_omega_real n HnSNoS).
Qed.

(** helper: successors of naturals are reals **)
Theorem ordsucc_in_R : forall n:set, n :e omega -> ordsucc n :e R.
let n. assume Hn: n :e omega.
exact (omega_in_R (ordsucc n) (omega_ordsucc n Hn)).
Qed.

(** helper: an interval around 0 bounds Abs **)
Theorem interval_bounds_Abs : forall M x:set,
  M :e R -> x :e R ->
  Rlt (minus_SNo M) x -> Rlt x M ->
  ~(Rlt M (Abs x)).
let M x.
assume HM: M :e R.
assume HxR: x :e R.
assume Hlx: Rlt (minus_SNo M) x.
assume HxM: Rlt x M.
assume HMAbs: Rlt M (Abs x).
claim HAbsR: Abs x :e R.
{ exact (RltE_right M (Abs x) HMAbs). }
claim HxS: SNo x.
{ exact (real_SNo x HxR). }
apply (SNoLt_trichotomy_or_impred x 0 HxS SNo_0 False).
- assume Hxlt0: x < 0.
  claim Habseq: Abs x = minus_SNo x.
  { exact (neg_abs_SNo x HxS Hxlt0). }
  claim HMltAbs: M < Abs x.
  { exact (RltE_lt M (Abs x) HMAbs). }
  claim HMltnegx: M < minus_SNo x.
  { rewrite <- Habseq.
    exact HMltAbs. }
  claim Hlxs: minus_SNo M < x.
  { exact (RltE_lt (minus_SNo M) x Hlx). }
  claim HmR: minus_SNo M :e R.
  { exact (real_minus_SNo M HM). }
  claim HmS: SNo (minus_SNo M).
  { exact (real_SNo (minus_SNo M) HmR). }
  claim Hnegxlt: minus_SNo x < minus_SNo (minus_SNo M).
  { exact (minus_SNo_Lt_contra (minus_SNo M) x HmS HxS Hlxs). }
  claim Hminv: minus_SNo (minus_SNo M) = M.
  { exact (minus_SNo_invol M (real_SNo M HM)). }
  claim HnegxltM: minus_SNo x < M.
  { rewrite <- Hminv.
    exact Hnegxlt. }
  claim HAbsltM: Abs x < M.
  { rewrite Habseq at 1.
    exact HnegxltM. }
  claim HRltAbsM: Rlt (Abs x) M.
  { exact (RltI (Abs x) M HAbsR HM HAbsltM). }
  claim HMM: Rlt M M.
  { exact (Rlt_tra M (Abs x) M HMAbs HRltAbsM). }
  exact ((not_Rlt_refl M HM) HMM).
- assume Hxeq0: x = 0.
  claim H0le0: 0 <= 0.
  { apply (SNoLtLe_or 0 0 SNo_0 SNo_0 (0 <= 0)).
    - assume H00: 0 < 0.
      exact (SNoLtLe 0 0 H00).
    - assume H. exact H. }
  claim Habseq: Abs 0 = 0.
  { exact (nonneg_abs_SNo 0 H0le0). }
  claim Hx0M: Rlt 0 M.
  { rewrite <- Hxeq0.
    exact HxM. }
  claim HMlt0: Rlt M 0.
  { claim HAbsx0: Abs x = 0.
    { rewrite Hxeq0 at 1.
      exact Habseq. }
    rewrite <- HAbsx0.
    exact HMAbs. }
  claim HMM: Rlt M M.
  { exact (Rlt_tra M 0 M HMlt0 Hx0M). }
  exact ((not_Rlt_refl M HM) HMM).
- assume H0ltx: 0 < x.
  claim H0lex: 0 <= x.
  { exact (SNoLtLe 0 x H0ltx). }
  claim Habseq: Abs x = x.
  { exact (nonneg_abs_SNo x H0lex). }
  claim HMltAbs: M < Abs x.
  { exact (RltE_lt M (Abs x) HMAbs). }
  claim HMltx: M < x.
  { rewrite <- Habseq.
    exact HMltAbs. }
  claim HxltM: x < M.
  { exact (RltE_lt x M HxM). }
  claim HRltMx: Rlt M x.
  { exact (RltI M x HM HxR HMltx). }
  claim HRltxM: Rlt x M.
  { exact HxM. }
  claim HMM: Rlt M M.
  { exact (Rlt_tra M x M HRltMx HRltxM). }
  exact ((not_Rlt_refl M HM) HMM).
Qed.

(** from 26 Theorem 26.7: finite products of compact spaces are compact **) 
(** LATEX VERSION: Finite product of compact spaces is compact. **)
Theorem finite_product_compact : forall X Tx Y Ty:set,
  compact_space X Tx -> compact_space Y Ty ->
  compact_space (setprod X Y) (product_topology X Tx Y Ty).
let X Tx Y Ty.
assume HX: compact_space X Tx.
assume HY: compact_space Y Ty.
prove compact_space (setprod X Y) (product_topology X Tx Y Ty).
prove topology_on (setprod X Y) (product_topology X Tx Y Ty) /\
      forall Fam:set,
        open_cover_of (setprod X Y) (product_topology X Tx Y Ty) Fam ->
        has_finite_subcover (setprod X Y) (product_topology X Tx Y Ty) Fam.
claim HTx: topology_on X Tx.
{ exact (compact_space_topology X Tx HX). }
claim HTy: topology_on Y Ty.
{ exact (compact_space_topology Y Ty HY). }
apply andI.
- exact (product_topology_is_topology X Tx Y Ty HTx HTy).
- let Fam. assume HFam: open_cover_of (setprod X Y) (product_topology X Tx Y Ty) Fam.
  prove has_finite_subcover (setprod X Y) (product_topology X Tx Y Ty) Fam.
  set UFam := {U :e Tx|exists H:set, H c= Fam /\ finite H /\ setprod U Y c= Union H}.
  claim HcovUFam: open_cover_of X Tx UFam.
  { prove topology_on X Tx /\ UFam c= Power X /\ X c= Union UFam /\ (forall U:set, U :e UFam -> U :e Tx).
    claim HUFamSubTx: UFam c= Tx.
    { let U. assume HU: U :e UFam.
      exact (SepE1 Tx (fun U0:set => exists H:set, H c= Fam /\ finite H /\ setprod U0 Y c= Union H) U HU). }
    claim HTxPow: Tx c= Power X.
    { exact (topology_subset_axiom X Tx HTx). }
    claim HUFamPow: UFam c= Power X.
    { let U. assume HU: U :e UFam.
      claim HUTx: U :e Tx.
      { exact (HUFamSubTx U HU). }
      exact (HTxPow U HUTx). }
    apply andI.
    - apply andI.
      + apply andI.
        * exact HTx.
        * exact HUFamPow.
      + prove X c= Union UFam.
        let x. assume Hx: x :e X.
        prove x :e Union UFam.
        claim HexTube: exists U:set,
          U :e Tx /\ x :e U /\
          exists H:set, H c= Fam /\ finite H /\ setprod U Y c= Union H.
        { (** Reduce to producing a finite subfamily H of Fam that covers {x}Y, then apply tube_lemma to N = Union H. **)
          claim HFamOpen: forall U0:set, U0 :e Fam -> U0 :e product_topology X Tx Y Ty.
          { let U0. assume HU0: U0 :e Fam.
            exact (open_cover_of_members_open (setprod X Y) (product_topology X Tx Y Ty) Fam U0 HFam HU0). }
          claim HexSlice: exists H:set, H c= Fam /\ finite H /\ setprod {x} Y c= Union H.
          { (** Build an open cover of Y by second-coordinate slices coming from rectangles inside members of Fam. **)
            claim HcovXY: setprod X Y c= Union Fam.
            { exact (open_cover_of_covers (setprod X Y) (product_topology X Tx Y Ty) Fam HFam). }
            set B := product_subbasis X Tx Y Ty.
            claim HBasis: basis_on (setprod X Y) B.
            { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
            set VFam := {V :e Ty|exists U0:set, U0 :e Tx /\ x :e U0 /\ exists N0:set, N0 :e Fam /\ setprod U0 V c= N0}.
            claim HVFamSubTy: VFam c= Ty.
            { let V. assume HV: V :e VFam.
              exact (SepE1 Ty (fun V0:set => exists U0:set, U0 :e Tx /\ x :e U0 /\ exists N0:set, N0 :e Fam /\ setprod U0 V0 c= N0) V HV). }
            claim HTyPow: Ty c= Power Y.
            { exact (topology_subset_axiom Y Ty HTy). }
            claim HVFamPow: VFam c= Power Y.
            { let V. assume HV: V :e VFam.
              claim HVTy: V :e Ty.
              { exact (HVFamSubTy V HV). }
              exact (HTyPow V HVTy). }
            claim HYcovV: Y c= Union VFam.
            { let y. assume Hy: y :e Y.
              prove y :e Union VFam.
              set p := (x,y).
              claim HpXY: p :e setprod X Y.
              { exact (tuple_2_setprod X Y x Hx y Hy). }
              claim HpInUnion: p :e Union Fam.
              { exact (HcovXY p HpXY). }
              apply (UnionE_impred Fam p HpInUnion).
              let N0. assume HpN0: p :e N0.
              assume HN0Fam: N0 :e Fam.
              claim HN0Top: N0 :e generated_topology (setprod X Y) B.
              { exact (HFamOpen N0 HN0Fam). }
              claim HN0refine: forall q :e N0, exists b :e B, q :e b /\ b c= N0.
              { exact (SepE2 (Power (setprod X Y))
                             (fun U0:set => forall q :e U0, exists b :e B, q :e b /\ b c= U0)
                             N0 HN0Top). }
              claim Hexb: exists b :e B, p :e b /\ b c= N0.
              { exact (HN0refine p HpN0). }
              apply Hexb.
              let b. assume Hbpair.
              claim HbB: b :e B.
              { exact (andEL (b :e B) (p :e b /\ b c= N0) Hbpair). }
              claim Hbprop: p :e b /\ b c= N0.
              { exact (andER (b :e B) (p :e b /\ b c= N0) Hbpair). }
              claim Hpb: p :e b.
              { exact (andEL (p :e b) (b c= N0) Hbprop). }
              claim HbsubN0: b c= N0.
              { exact (andER (p :e b) (b c= N0) Hbprop). }
              apply (famunionE_impred Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) b HbB).
              let U0. assume HU0Tx: U0 :e Tx.
              assume HbIn: b :e {rectangle_set U0 V0|V0 :e Ty}.
              apply (ReplE_impred Ty (fun V0:set => rectangle_set U0 V0) b HbIn).
              let V0. assume HV0Ty: V0 :e Ty.
              assume HbEq: b = rectangle_set U0 V0.
              claim HpUV: p :e setprod U0 V0.
              { prove p :e rectangle_set U0 V0.
                rewrite <- HbEq at 1.
                exact Hpb. }
              claim HpXY0: p :e setprod {x} {y}.
              { exact (tuple_2_setprod {x} {y} x (SingI x) y (SingI y)). }
              claim Hcoords: x :e U0 /\ y :e V0.
              { exact (setprod_coords_in x y U0 V0 p HpXY0 HpUV). }
              claim HxU0: x :e U0.
              { exact (andEL (x :e U0) (y :e V0) Hcoords). }
              claim HyV0: y :e V0.
              { exact (andER (x :e U0) (y :e V0) Hcoords). }
              claim HrectSub: setprod U0 V0 c= N0.
              { rewrite <- HbEq at 1.
                exact HbsubN0. }
              claim HV0Fam: V0 :e VFam.
              { apply (SepI Ty (fun V1:set => exists U1:set, U1 :e Tx /\ x :e U1 /\ exists N1:set, N1 :e Fam /\ setprod U1 V1 c= N1) V0 HV0Ty).
                witness U0.
                prove U0 :e Tx /\ x :e U0 /\ exists N1:set, N1 :e Fam /\ setprod U0 V0 c= N1.
                apply andI.
                - exact (andI (U0 :e Tx) (x :e U0) HU0Tx HxU0).
                - witness N0.
                  exact (andI (N0 :e Fam) (setprod U0 V0 c= N0) HN0Fam HrectSub). }
              exact (UnionI VFam y V0 HyV0 HV0Fam). }
            claim HVFamCover: open_cover_of Y Ty VFam.
            { prove topology_on Y Ty /\ VFam c= Power Y /\ Y c= Union VFam /\ (forall U0:set, U0 :e VFam -> U0 :e Ty).
              apply andI.
              - apply andI.
                + apply andI.
                  * exact HTy.
                  * exact HVFamPow.
                + exact HYcovV.
              - let V. assume HV: V :e VFam.
                exact (HVFamSubTy V HV). }
            claim HfinV: has_finite_subcover Y Ty VFam.
            { exact (Heine_Borel_subcover Y Ty VFam HY HVFamCover). }
            apply HfinV.
            let G. assume HG: G c= VFam /\ finite G /\ Y c= Union G.
            claim HGsub: G c= VFam.
            { exact (andEL (G c= VFam) (finite G) (andEL (G c= VFam /\ finite G) (Y c= Union G) HG)). }
            claim HGfin: finite G.
            { exact (andER (G c= VFam) (finite G) (andEL (G c= VFam /\ finite G) (Y c= Union G) HG)). }
            claim HYcovG: Y c= Union G.
            { exact (andER (G c= VFam /\ finite G) (Y c= Union G) HG). }
            set pickU := fun V:set => Eps_i (fun U0:set => U0 :e Tx /\ x :e U0 /\ exists N0:set, N0 :e Fam /\ setprod U0 V c= N0).
            claim HpickU: forall V:set, V :e VFam -> pickU V :e Tx /\ x :e pickU V /\ exists N0:set, N0 :e Fam /\ setprod (pickU V) V c= N0.
            { let V. assume HV: V :e VFam.
              claim Hex: exists U0:set, U0 :e Tx /\ x :e U0 /\ exists N0:set, N0 :e Fam /\ setprod U0 V c= N0.
              { exact (SepE2 Ty (fun V0:set => exists U0:set, U0 :e Tx /\ x :e U0 /\ exists N0:set, N0 :e Fam /\ setprod U0 V0 c= N0) V HV). }
              apply Hex.
              let U0. assume HU0: U0 :e Tx /\ x :e U0 /\ exists N0:set, N0 :e Fam /\ setprod U0 V c= N0.
              exact (Eps_i_ax (fun U1:set => U1 :e Tx /\ x :e U1 /\ exists N0:set, N0 :e Fam /\ setprod U1 V c= N0) U0 HU0). }
            set pickN := fun V:set => Eps_i (fun N0:set => N0 :e Fam /\ setprod (pickU V) V c= N0).
            claim HpickN: forall V:set, V :e VFam -> pickN V :e Fam /\ setprod (pickU V) V c= pickN V.
            { let V. assume HV: V :e VFam.
              claim Hprop: pickU V :e Tx /\ x :e pickU V /\ exists N0:set, N0 :e Fam /\ setprod (pickU V) V c= N0.
              { exact (HpickU V HV). }
              claim HpropAB: pickU V :e Tx /\ x :e pickU V.
              { exact (andEL (pickU V :e Tx /\ x :e pickU V) (exists N0:set, N0 :e Fam /\ setprod (pickU V) V c= N0) Hprop). }
              claim HexN: exists N0:set, N0 :e Fam /\ setprod (pickU V) V c= N0.
              { exact (andER (pickU V :e Tx /\ x :e pickU V) (exists N0:set, N0 :e Fam /\ setprod (pickU V) V c= N0) Hprop). }
              apply HexN.
              let N0. assume HN0: N0 :e Fam /\ setprod (pickU V) V c= N0.
              exact (Eps_i_ax (fun N1:set => N1 :e Fam /\ setprod (pickU V) V c= N1) N0 HN0). }
            set H := {pickN V|V :e G}.
            witness H.
            apply andI.
            - apply andI.
              + prove H c= Fam.
                let N0. assume HN0: N0 :e H.
                apply (ReplE_impred G (fun V0:set => pickN V0) N0 HN0).
                let V0. assume HV0G: V0 :e G.
                assume HN0Eq: N0 = pickN V0.
                claim HV0Fam: V0 :e VFam.
                { exact (HGsub V0 HV0G). }
                claim HNprop: pickN V0 :e Fam /\ setprod (pickU V0) V0 c= pickN V0.
                { exact (HpickN V0 HV0Fam). }
                claim HN0Fam: pickN V0 :e Fam.
                { exact (andEL (pickN V0 :e Fam) (setprod (pickU V0) V0 c= pickN V0) HNprop). }
                rewrite HN0Eq.
                exact HN0Fam.
              + exact (Repl_finite (fun V0:set => pickN V0) G HGfin).
            - prove setprod {x} Y c= Union H.
              let p. assume Hp: p :e setprod {x} Y.
              prove p :e Union H.
                  claim Hp0: p 0 :e {x}.
                  { exact (ap0_Sigma {x} (fun _:set => Y) p Hp). }
                  claim Hp1: p 1 :e Y.
                  { exact (ap1_Sigma {x} (fun _:set => Y) p Hp). }
                  claim Hp0eq: p 0 = x.
                  { exact (SingE x (p 0) Hp0). }
                  claim HpEta: p = (p 0, p 1).
                  { exact (setprod_eta {x} Y p Hp). }
                  claim Hp1InUnion: p 1 :e Union G.
                  { exact (HYcovG (p 1) Hp1). }
                  apply (UnionE_impred G (p 1) Hp1InUnion).
                  let V0. assume Hp1V0: p 1 :e V0.
                  assume HV0G: V0 :e G.
                  claim HV0Fam: V0 :e VFam.
                  { exact (HGsub V0 HV0G). }
                  claim HUN: pickU V0 :e Tx /\ x :e pickU V0 /\ exists N0:set, N0 :e Fam /\ setprod (pickU V0) V0 c= N0.
                  { exact (HpickU V0 HV0Fam). }
                  claim HUNAB: pickU V0 :e Tx /\ x :e pickU V0.
                  { exact (andEL (pickU V0 :e Tx /\ x :e pickU V0) (exists N0:set, N0 :e Fam /\ setprod (pickU V0) V0 c= N0) HUN). }
                  claim HxPick: x :e pickU V0.
                  { exact (andER (pickU V0 :e Tx) (x :e pickU V0) HUNAB). }
                  claim HNprop: pickN V0 :e Fam /\ setprod (pickU V0) V0 c= pickN V0.
                  { exact (HpickN V0 HV0Fam). }
                  claim HrectSub: setprod (pickU V0) V0 c= pickN V0.
                  { exact (andER (pickN V0 :e Fam) (setprod (pickU V0) V0 c= pickN V0) HNprop). }
                  claim HpInRect: (x, p 1) :e setprod (pickU V0) V0.
                  { exact (tuple_2_setprod (pickU V0) V0 x HxPick (p 1) Hp1V0). }
                  claim HpInN: (x, p 1) :e pickN V0.
                  { exact (HrectSub (x, p 1) HpInRect). }
                  claim HNinH: pickN V0 :e H.
                  { exact (ReplI G (fun V1:set => pickN V1) V0 HV0G). }
                  rewrite HpEta.
                  rewrite Hp0eq at 1.
	                  exact (UnionI H (x, p 1) (pickN V0) HpInN HNinH).
	          }
	          apply HexSlice.
          let H. assume HH: H c= Fam /\ finite H /\ setprod {x} Y c= Union H.
          claim HHsub: H c= Fam.
          { exact (andEL (H c= Fam) (finite H) (andEL (H c= Fam /\ finite H) (setprod {x} Y c= Union H) HH)). }
          claim HHfin: finite H.
          { exact (andER (H c= Fam) (finite H) (andEL (H c= Fam /\ finite H) (setprod {x} Y c= Union H) HH)). }
          claim HHcov: setprod {x} Y c= Union H.
          { exact (andER (H c= Fam /\ finite H) (setprod {x} Y c= Union H) HH). }
          claim HHsubTop: H c= product_topology X Tx Y Ty.
          { let N0. assume HN0: N0 :e H.
            claim HN0Fam: N0 :e Fam.
            { exact (HHsub N0 HN0). }
            exact (HFamOpen N0 HN0Fam). }
          claim HtopProd: topology_on (setprod X Y) (product_topology X Tx Y Ty).
          { exact (product_topology_is_topology X Tx Y Ty HTx HTy). }
          claim HNtop: Union H :e product_topology X Tx Y Ty.
          { exact (topology_union_closed (setprod X Y) (product_topology X Tx Y Ty) H HtopProd HHsubTop). }
          claim Htube: exists U:set, U :e Tx /\ x :e U /\ setprod U Y c= Union H.
          { exact (tube_lemma X Tx Y Ty HTx HTy HY x Hx (Union H)
                 (andI ((Union H) :e product_topology X Tx Y Ty) (setprod {x} Y c= Union H) HNtop HHcov)). }
          apply Htube.
          let U. assume HU: U :e Tx /\ x :e U /\ setprod U Y c= Union H.
          claim HUAB0: U :e Tx /\ x :e U.
          { exact (andEL (U :e Tx /\ x :e U) (setprod U Y c= Union H) HU). }
          witness U.
          apply andI.
          - exact HUAB0.
          - witness H.
            exact (andI (H c= Fam /\ finite H) (setprod U Y c= Union H)
                        (andI (H c= Fam) (finite H) HHsub HHfin)
                        (andER (U :e Tx /\ x :e U) (setprod U Y c= Union H) HU)). }
        apply HexTube.
        let U. assume HU: U :e Tx /\ x :e U /\ exists H:set, H c= Fam /\ finite H /\ setprod U Y c= Union H.
        claim HUAB: U :e Tx /\ x :e U.
        { exact (andEL (U :e Tx /\ x :e U) (exists H:set, H c= Fam /\ finite H /\ setprod U Y c= Union H) HU). }
        claim HUtx: U :e Tx.
        { exact (andEL (U :e Tx) (x :e U) HUAB). }
        claim HxU: x :e U.
        { exact (andER (U :e Tx) (x :e U) HUAB). }
        claim HexH: exists H:set, H c= Fam /\ finite H /\ setprod U Y c= Union H.
        { exact (andER (U :e Tx /\ x :e U) (exists H:set, H c= Fam /\ finite H /\ setprod U Y c= Union H) HU). }
        claim HUinUFam: U :e UFam.
        { apply (SepI Tx (fun U0:set => exists H:set, H c= Fam /\ finite H /\ setprod U0 Y c= Union H) U HUtx).
          exact HexH. }
        exact (UnionI UFam x U HxU HUinUFam).
    - let U. assume HU: U :e UFam.
      exact (HUFamSubTx U HU). }
  claim HfinUFam: has_finite_subcover X Tx UFam.
  { exact (Heine_Borel_subcover X Tx UFam HX HcovUFam). }
  apply HfinUFam.
  let K. assume HK: K c= UFam /\ finite K /\ X c= Union K.
  claim HKsub: K c= UFam.
  { exact (andEL (K c= UFam) (finite K) (andEL (K c= UFam /\ finite K) (X c= Union K) HK)). }
  claim HKfin: finite K.
  { exact (andER (K c= UFam) (finite K) (andEL (K c= UFam /\ finite K) (X c= Union K) HK)). }
  claim HXcovK: X c= Union K.
  { exact (andER (K c= UFam /\ finite K) (X c= Union K) HK). }
  set pickH := fun U:set => Eps_i (fun H:set => H c= Fam /\ finite H /\ setprod U Y c= Union H).
  claim HpickH: forall U:set, U :e UFam -> pickH U c= Fam /\ finite (pickH U) /\ setprod U Y c= Union (pickH U).
  { let U. assume HU: U :e UFam.
    claim Hex: exists H:set, H c= Fam /\ finite H /\ setprod U Y c= Union H.
    { exact (SepE2 Tx (fun U0:set => exists H:set, H c= Fam /\ finite H /\ setprod U0 Y c= Union H) U HU). }
    apply Hex.
    let H0. assume HH0: H0 c= Fam /\ finite H0 /\ setprod U Y c= Union H0.
    exact (Eps_i_ax (fun H:set => H c= Fam /\ finite H /\ setprod U Y c= Union H) H0 HH0). }
  set G := \/_ U :e K, pickH U.
  prove has_finite_subcover (setprod X Y) (product_topology X Tx Y Ty) Fam.
  prove exists G0:set, G0 c= Fam /\ finite G0 /\ setprod X Y c= Union G0.
  witness G.
  apply andI.
  - prove G c= Fam /\ finite G.
    apply andI.
    + prove G c= Fam.
      let N. assume HN: N :e G.
      prove N :e Fam.
      apply (famunionE_impred K (fun U0:set => pickH U0) N HN).
      let U0. assume HU0K: U0 :e K.
      assume HNin: N :e pickH U0.
      claim HU0UFam: U0 :e UFam.
      { exact (HKsub U0 HU0K). }
      claim Hprop: pickH U0 c= Fam /\ finite (pickH U0) /\ setprod U0 Y c= Union (pickH U0).
      { exact (HpickH U0 HU0UFam). }
      claim HpropAB: pickH U0 c= Fam /\ finite (pickH U0).
      { exact (andEL (pickH U0 c= Fam /\ finite (pickH U0)) (setprod U0 Y c= Union (pickH U0)) Hprop). }
      claim HsubFam: pickH U0 c= Fam.
      { exact (andEL (pickH U0 c= Fam) (finite (pickH U0)) HpropAB). }
      exact (HsubFam N HNin).
    + prove finite G.
      claim HpEmpty: Empty c= UFam -> finite (\/_ U :e Empty, pickH U).
      { assume _.
        rewrite (famunion_Empty (fun U:set => pickH U)).
        exact finite_Empty. }
      claim HpStep: forall K0 y:set,
        finite K0 -> y /:e K0 ->
        (K0 c= UFam -> finite (\/_ U :e K0, pickH U)) ->
        ((K0 :\/: {y}) c= UFam -> finite (\/_ U :e (K0 :\/: {y}), pickH U)).
      { let K0 y.
        assume HK0fin HyNotin IH.
        assume Hsub: (K0 :\/: {y}) c= UFam.
        claim HK0sub: K0 c= UFam.
        { let U. assume HU: U :e K0.
          exact (Hsub U (binunionI1 K0 {y} U HU)). }
        claim HyUFam: y :e UFam.
        { exact (Hsub y (binunionI2 K0 {y} y (SingI y))). }
        claim Hfin0: finite (\/_ U :e K0, pickH U).
        { exact (IH HK0sub). }
        claim HpropY: pickH y c= Fam /\ finite (pickH y) /\ setprod y Y c= Union (pickH y).
        { exact (HpickH y HyUFam). }
        claim HpropYAB: pickH y c= Fam /\ finite (pickH y).
        { exact (andEL (pickH y c= Fam /\ finite (pickH y)) (setprod y Y c= Union (pickH y)) HpropY). }
        claim HfinY: finite (pickH y).
        { exact (andER (pickH y c= Fam) (finite (pickH y)) HpropYAB). }
        claim Heq: (\/_ U :e (K0 :\/: {y}), pickH U) = (\/_ U :e K0, pickH U) :\/: pickH y.
        { apply set_ext.
          - let N. assume HN: N :e (\/_ U :e (K0 :\/: {y}), pickH U).
            prove N :e (\/_ U :e K0, pickH U) :\/: pickH y.
            apply (famunionE_impred (K0 :\/: {y}) (fun U1:set => pickH U1) N HN).
            let U1. assume HU1: U1 :e K0 :\/: {y}.
            assume HNin: N :e pickH U1.
            apply (binunionE' K0 {y} U1 (N :e (\/_ U :e K0, pickH U) :\/: pickH y)).
            + assume HU1K0: U1 :e K0.
              apply binunionI1.
              exact (famunionI K0 (fun U2:set => pickH U2) U1 N HU1K0 HNin).
            + assume HU1y: U1 :e {y}.
              claim HU1eq: U1 = y.
              { exact (SingE y U1 HU1y). }
              claim HNy: N :e pickH y.
              { prove N :e pickH y.
                rewrite <- HU1eq at 1.
                exact HNin. }
              exact (binunionI2 (\/_ U :e K0, pickH U) (pickH y) N HNy).
            + exact HU1.
          - let N. assume HN: N :e (\/_ U :e K0, pickH U) :\/: pickH y.
            prove N :e (\/_ U :e (K0 :\/: {y}), pickH U).
            apply (binunionE' (\/_ U :e K0, pickH U) (pickH y) N (N :e (\/_ U :e (K0 :\/: {y}), pickH U))).
            + assume HN0: N :e (\/_ U :e K0, pickH U).
              apply (famunionE_impred K0 (fun U1:set => pickH U1) N HN0).
              let U1. assume HU1K0: U1 :e K0.
              assume HN1: N :e pickH U1.
              exact (famunionI (K0 :\/: {y}) (fun U2:set => pickH U2) U1 N (binunionI1 K0 {y} U1 HU1K0) HN1).
            + assume HNy: N :e pickH y.
              exact (famunionI (K0 :\/: {y}) (fun U2:set => pickH U2) y N (binunionI2 K0 {y} y (SingI y)) HNy).
            + exact HN. }
        rewrite Heq.
        exact (binunion_finite (\/_ U :e K0, pickH U) Hfin0 (pickH y) HfinY). }
      claim Hall: K c= UFam -> finite (\/_ U :e K, pickH U).
      { exact (finite_ind (fun K0:set => K0 c= UFam -> finite (\/_ U :e K0, pickH U)) HpEmpty HpStep K HKfin). }
      exact (Hall HKsub).
  - let p. assume Hp: p :e setprod X Y.
    prove p :e Union G.
    claim Hp0X: p 0 :e X.
    { exact (ap0_Sigma X (fun _:set => Y) p Hp). }
    claim Hp1Y: p 1 :e Y.
    { exact (ap1_Sigma X (fun _:set => Y) p Hp). }
    claim HpEta: p = (p 0, p 1).
    { exact (setprod_eta X Y p Hp). }
    claim Hp0InUnion: p 0 :e Union K.
    { exact (HXcovK (p 0) Hp0X). }
    apply (UnionE_impred K (p 0) Hp0InUnion).
    let U0. assume Hp0U0: p 0 :e U0.
    assume HU0K: U0 :e K.
    claim HU0UFam: U0 :e UFam.
    { exact (HKsub U0 HU0K). }
    claim Hprop: pickH U0 c= Fam /\ finite (pickH U0) /\ setprod U0 Y c= Union (pickH U0).
    { exact (HpickH U0 HU0UFam). }
    claim HcovU0: setprod U0 Y c= Union (pickH U0).
    { exact (andER (pickH U0 c= Fam /\ finite (pickH U0)) (setprod U0 Y c= Union (pickH U0)) Hprop). }
    claim HpInU0Y: (p 0, p 1) :e setprod U0 Y.
    { exact (tuple_2_setprod U0 Y (p 0) Hp0U0 (p 1) Hp1Y). }
    claim HpInUnionPick: (p 0, p 1) :e Union (pickH U0).
    { exact (HcovU0 (p 0, p 1) HpInU0Y). }
    apply (UnionE_impred (pickH U0) (p 0, p 1) HpInUnionPick).
    let N. assume HpN: (p 0, p 1) :e N.
    assume HNpick: N :e pickH U0.
    claim HNinG: N :e G.
    { exact (famunionI K (fun U1:set => pickH U1) U0 N HU0K HNpick). }
    rewrite HpEta.
    exact (UnionI G (p 0, p 1) N HpN HNinG).
Qed.

(** from 26 Exercises: compactness examples and properties **) 
(** LATEX VERSION: Exercises: unit interval closed in , unit interval compact, etc. **)
Theorem unit_interval_compact_axiom : compact_space unit_interval unit_interval_topology.
admit.
Qed.
Theorem ex26_compactness_exercises :
  (closed_in R R_standard_topology unit_interval) /\
  (compact_space unit_interval unit_interval_topology).
 prove closed_in R R_standard_topology unit_interval /\ compact_space unit_interval unit_interval_topology.
 apply andI.
- (** unit interval is closed in R **)
  prove closed_in R R_standard_topology unit_interval.
  claim HT: topology_on R R_standard_topology.
  { exact R_standard_topology_is_topology_local. }
  prove topology_on R R_standard_topology /\ (unit_interval c= R /\ exists U :e R_standard_topology, unit_interval = R :\: U).
  apply andI.
  - exact HT.
  - apply andI.
    + (** unit_interval c= R **)
      let x. assume Hx: x :e unit_interval.
      prove x :e R.
      exact (SepE1 R (fun x0:set => ~(Rlt x0 0) /\ ~(Rlt 1 x0)) x Hx).
    + (** witness the open complement **)
      set L0 := {x :e R|Rlt x 0}.
      set R1 := {x :e R|Rlt 1 x}.
      set U := L0 :\/: R1.
      witness U.
      apply andI.
      * (** U is open in R_standard_topology **)
        claim HL0: L0 :e R_standard_topology.
        { exact (open_left_ray_in_R_standard_topology 0 real_0). }
        claim HR1: R1 :e R_standard_topology.
        { exact (open_ray_in_R_standard_topology 1 real_1). }
        exact (topology_binunion_closed R R_standard_topology L0 R1 HT HL0 HR1).
      * (** unit_interval = R \\ U **)
        apply set_ext.
        { let x. assume Hx: x :e unit_interval.
          prove x :e R :\: U.
          claim HxR: x :e R.
          { exact (SepE1 R (fun x0:set => ~(Rlt x0 0) /\ ~(Rlt 1 x0)) x Hx). }
          claim Hxprop: ~(Rlt x 0) /\ ~(Rlt 1 x).
          { exact (SepE2 R (fun x0:set => ~(Rlt x0 0) /\ ~(Rlt 1 x0)) x Hx). }
          claim Hnx0: ~(Rlt x 0).
          { exact (andEL (~(Rlt x 0)) (~(Rlt 1 x)) Hxprop). }
          claim Hn1x: ~(Rlt 1 x).
          { exact (andER (~(Rlt x 0)) (~(Rlt 1 x)) Hxprop). }
          apply (setminusI R U x HxR).
          assume Hxu: x :e U.
          apply (binunionE L0 R1 x Hxu).
          - assume HxL: x :e L0.
            claim Hlt: Rlt x 0.
            { exact (SepE2 R (fun x0:set => Rlt x0 0) x HxL). }
            exact (Hnx0 Hlt).
          - assume HxR1: x :e R1.
            claim Hlt: Rlt 1 x.
            { exact (SepE2 R (fun x0:set => Rlt 1 x0) x HxR1). }
            exact (Hn1x Hlt). }
        { let x. assume Hx: x :e R :\: U.
          prove x :e unit_interval.
          claim HxR: x :e R.
          { exact (setminusE1 R U x Hx). }
          claim HxnotU: x /:e U.
          { exact (setminusE2 R U x Hx). }
          apply (SepI R (fun x0:set => ~(Rlt x0 0) /\ ~(Rlt 1 x0)) x HxR).
          apply andI.
          - (** ~(x < 0) **)
            assume Hlt: Rlt x 0.
            prove False.
            claim HxL0: x :e L0.
            { exact (SepI R (fun x0:set => Rlt x0 0) x HxR Hlt). }
            claim HxU: x :e U.
            { exact (binunionI1 L0 R1 x HxL0). }
            exact (HxnotU HxU).
          - (** ~(1 < x) **)
            assume Hlt: Rlt 1 x.
            prove False.
            claim HxR1: x :e R1.
            { exact (SepI R (fun x0:set => Rlt 1 x0) x HxR Hlt). }
            claim HxU: x :e U.
            { exact (binunionI2 L0 R1 x HxR1). }
            exact (HxnotU HxU). }
- (** compactness part **)
  exact unit_interval_compact_axiom.
Qed.

(** from 26/27: Heine-Borel on  (closed and bounded sets) **) 
(** LATEX VERSION: HeineBorel: compact subsets of  are closed and bounded; converses addressed. **)
Theorem Heine_Borel_closed_bounded : forall A:set,
  A c= R ->
  compact_space A (subspace_topology R R_standard_topology A) ->
  closed_in R R_standard_topology A /\ bounded_subset_of_reals A.
let A.
assume HA: A c= R.
assume Hcomp: compact_space A (subspace_topology R R_standard_topology A).
prove closed_in R R_standard_topology A /\ bounded_subset_of_reals A.
apply andI.
- exact (compact_subspace_in_Hausdorff_closed R R_standard_topology A R_standard_topology_Hausdorff HA Hcomp).
- (** boundedness **)
	  apply (xm (A = Empty)).
	  + assume HA0: A = Empty.
	    prove exists M:set, M :e R /\ forall x:set, x :e A -> ~(Rlt M (Abs x)).
	    witness 0.
	    apply andI.
	    * exact real_0.
	    * let x. assume HxA: x :e A.
	      prove ~(Rlt 0 (Abs x)).
	      assume H.
	      claim HxE: x :e Empty.
	      { rewrite <- HA0.
	        exact HxA. }
	      exact (EmptyE x HxE).
	  + assume HAne: ~(A = Empty).
	    prove exists M:set, M :e R /\ forall x:set, x :e A -> ~(Rlt M (Abs x)).
	    claim HTtop: topology_on R R_standard_topology.
	    { exact R_standard_topology_is_topology_local. }
    claim Hiff:
      compact_space A (subspace_topology R R_standard_topology A) <->
        forall Fam:set, (Fam c= R_standard_topology /\ A c= Union Fam) ->
          has_finite_subcover A R_standard_topology Fam.
    { exact (compact_subspace_via_ambient_covers R R_standard_topology A HTtop HA). }
    claim Hcovprop:
      forall Fam:set, (Fam c= R_standard_topology /\ A c= Union Fam) ->
        has_finite_subcover A R_standard_topology Fam.
    { exact (iffEL (compact_space A (subspace_topology R R_standard_topology A))
                   (forall Fam:set, (Fam c= R_standard_topology /\ A c= Union Fam) ->
                      has_finite_subcover A R_standard_topology Fam)
                   Hiff Hcomp). }
    set f := fun n:set => open_interval (minus_SNo (ordsucc n)) (ordsucc n).
    set Fam0 := {f n|n :e omega}.
    claim HFam0sub: Fam0 c= R_standard_topology.
    { let U. assume HU: U :e Fam0.
      apply (ReplE_impred omega (fun n0:set => f n0) U HU (U :e R_standard_topology)).
      let n0. assume Hn0: n0 :e omega.
      assume Heq: U = f n0.
      rewrite Heq.
      prove f n0 :e R_standard_topology.
      claim Hbasis: basis_on R R_standard_basis.
      { exact R_standard_basis_is_basis_local. }
      claim Hn0s: ordsucc n0 :e R.
      { exact (ordsucc_in_R n0 Hn0). }
      claim Hmn0R: minus_SNo (ordsucc n0) :e R.
      { exact (real_minus_SNo (ordsucc n0) Hn0s). }
      claim HfInBasis: f n0 :e R_standard_basis.
      { set a := minus_SNo (ordsucc n0).
        set b := ordsucc n0.
        claim HaR: a :e R.
        { exact Hmn0R. }
        claim HbR: b :e R.
        { exact Hn0s. }
        claim Hinner: open_interval a b :e {open_interval a bb|bb :e R}.
        { exact (ReplI R (fun bb:set => open_interval a bb) b HbR). }
        exact (famunionI R (fun aa:set => {open_interval aa bb|bb :e R}) a (open_interval a b) HaR Hinner). }
      exact (basis_in_generated R R_standard_basis (f n0) Hbasis HfInBasis). }
    claim HAcover: A c= Union Fam0.
    { let x. assume HxA: x :e A.
      prove x :e Union Fam0.
      claim HxR: x :e R.
      { exact (HA x HxA). }
      (** Find an index n with x in f n. **)
      claim Hup: exists N:set, N :e omega /\ x < N.
      { apply (real_E x HxR (exists N:set, N :e omega /\ x < N)).
        assume HxS: SNo x.
        assume Hlev: SNoLev x :e ordsucc omega.
        assume HxSNoS: x :e SNoS_ (ordsucc omega).
        assume HmOmLt: minus_SNo omega < x.
        assume HxLtOm: x < omega.
        assume Huniq.
        assume Happrox.
        exact (SNoS_ordsucc_omega_bdd_above x HxSNoS HxLtOm). }
      claim Hlow: exists N:set, N :e omega /\ minus_SNo N < x.
      { apply (real_E x HxR (exists N:set, N :e omega /\ minus_SNo N < x)).
        assume HxS: SNo x.
        assume Hlev: SNoLev x :e ordsucc omega.
        assume HxSNoS: x :e SNoS_ (ordsucc omega).
        assume HmOmLt: minus_SNo omega < x.
        assume HxLtOm: x < omega.
        assume Huniq.
        assume Happrox.
        exact (SNoS_ordsucc_omega_bdd_below x HxSNoS HmOmLt). }
      apply Hup.
      let Nup. assume Hupconj.
      claim HNup: Nup :e omega.
      { exact (andEL (Nup :e omega) (x < Nup) Hupconj). }
      claim HxNup: x < Nup.
      { exact (andER (Nup :e omega) (x < Nup) Hupconj). }
      apply Hlow.
      let Nlow. assume Hlowconj.
      claim HNlow: Nlow :e omega.
      { exact (andEL (Nlow :e omega) (minus_SNo Nlow < x) Hlowconj). }
      claim HNlowx: minus_SNo Nlow < x.
      { exact (andER (Nlow :e omega) (minus_SNo Nlow < x) Hlowconj). }
      set n := Nup :\/: Nlow.
      claim HnO: n :e omega.
      { exact (omega_binunion Nup Nlow HNup HNlow). }
      claim Hordomega: ordinal omega.
      { exact omega_ordinal. }
      claim HordNup: ordinal Nup.
      { exact (ordinal_Hered omega Hordomega Nup HNup). }
      claim HordNlow: ordinal Nlow.
      { exact (ordinal_Hered omega Hordomega Nlow HNlow). }
      claim Hordn: ordinal n.
      { exact (ordinal_Hered omega Hordomega n HnO). }
      claim HNupSub: Nup c= n.
      { let t. assume Ht: t :e Nup.
        exact (binunionI1 Nup Nlow t Ht). }
      claim HNlowSub: Nlow c= n.
      { let t. assume Ht: t :e Nlow.
        exact (binunionI2 Nup Nlow t Ht). }
      claim HNupLe: Nup <= n.
      { exact (ordinal_Subq_SNoLe Nup n HordNup Hordn HNupSub). }
      claim HNlowLe: Nlow <= n.
      { exact (ordinal_Subq_SNoLe Nlow n HordNlow Hordn HNlowSub). }
      claim HxS: SNo x.
      { exact (real_SNo x HxR). }
      claim HNupS: SNo Nup.
      { exact (omega_SNo Nup HNup). }
      claim HnS: SNo n.
      { exact (omega_SNo n HnO). }
      claim Hxlt_n: x < n.
      { exact (SNoLtLe_tra x Nup n HxS HNupS HnS HxNup HNupLe). }
      claim Hn_in_ordsucc: n :e ordsucc n.
      { exact (ordsuccI2 n). }
      claim Hord_ordsucc: ordinal (ordsucc n).
      { exact (ordinal_ordsucc n Hordn). }
      claim Hnlt_ordsucc: n < ordsucc n.
      { exact (ordinal_In_SNoLt (ordsucc n) Hord_ordsucc n Hn_in_ordsucc). }
      claim HordS: SNo (ordsucc n).
      { exact (omega_SNo (ordsucc n) (omega_ordsucc n HnO)). }
      claim Hxlt_ordsucc: x < ordsucc n.
      { exact (SNoLt_tra x n (ordsucc n) HxS HnS HordS Hxlt_n Hnlt_ordsucc). }
      (** Lower bound: - ordsucc n < x. **)
      claim HNlowS: SNo Nlow.
      { exact (omega_SNo Nlow HNlow). }
      claim Hneg_nS: SNo (minus_SNo n).
      { exact (SNo_minus_SNo n HnS). }
      claim Hneg_NlowS: SNo (minus_SNo Nlow).
      { exact (SNo_minus_SNo Nlow HNlowS). }
      claim Hle_neg: minus_SNo n <= minus_SNo Nlow.
      { exact (minus_SNo_Le_contra Nlow n HNlowS HnS HNlowLe). }
      claim Hneglow_lt_x: minus_SNo Nlow < x.
      { exact HNlowx. }
      claim Hneg_n_lt_x: minus_SNo n < x.
      { exact (SNoLeLt_tra (minus_SNo n) (minus_SNo Nlow) x Hneg_nS Hneg_NlowS HxS Hle_neg Hneglow_lt_x). }
      claim Hnlt_ordsucc_neg: minus_SNo (ordsucc n) < minus_SNo n.
      { exact (minus_SNo_Lt_contra n (ordsucc n) HnS HordS Hnlt_ordsucc). }
      claim Hneg_ordsucc_lt_x: minus_SNo (ordsucc n) < x.
      { exact (SNoLt_tra (minus_SNo (ordsucc n)) (minus_SNo n) x
                         (SNo_minus_SNo (ordsucc n) HordS)
                         Hneg_nS
                         HxS
                         Hnlt_ordsucc_neg
                         Hneg_n_lt_x). }
      (** Now x is in the open interval. **)
      claim HordsuccR: ordsucc n :e R.
      { exact (ordsucc_in_R n HnO). }
      claim HnegordsuccR: minus_SNo (ordsucc n) :e R.
      { exact (real_minus_SNo (ordsucc n) HordsuccR). }
      claim HRltL: Rlt (minus_SNo (ordsucc n)) x.
      { exact (RltI (minus_SNo (ordsucc n)) x HnegordsuccR HxR Hneg_ordsucc_lt_x). }
      claim HRltR: Rlt x (ordsucc n).
      { exact (RltI x (ordsucc n) HxR HordsuccR Hxlt_ordsucc). }
      claim HxIn: x :e f n.
      { exact (SepI R (fun x0:set => Rlt (minus_SNo (ordsucc n)) x0 /\ Rlt x0 (ordsucc n))
                   x HxR (andI (Rlt (minus_SNo (ordsucc n)) x) (Rlt x (ordsucc n)) HRltL HRltR)). }
      claim HfnFam: f n :e Fam0.
      { exact (ReplI omega (fun n0:set => f n0) n HnO). }
      exact (UnionI Fam0 x (f n) HxIn HfnFam). }
    claim Hfincover: has_finite_subcover A R_standard_topology Fam0.
    { exact (Hcovprop Fam0 (andI (Fam0 c= R_standard_topology) (A c= Union Fam0) HFam0sub HAcover)). }
    apply Hfincover.
    let G. assume HGtriple.
    claim HGsub: G c= Fam0.
    { exact (andEL (G c= Fam0) (finite G) (andEL (G c= Fam0 /\ finite G) (A c= Union G) HGtriple)). }
    claim HGfin: finite G.
    { exact (andER (G c= Fam0) (finite G) (andEL (G c= Fam0 /\ finite G) (A c= Union G) HGtriple)). }
    claim HAcovG: A c= Union G.
    { exact (andER (G c= Fam0 /\ finite G) (A c= Union G) HGtriple). }
    set pickN := fun U:set => Eps_i (fun n0:set => n0 :e omega /\ U = f n0).
    set Nset := {pickN U|U :e G}.
    claim HNsetFin: finite Nset.
    { exact (Repl_finite (fun U0:set => pickN U0) G HGfin). }
    claim HexA: exists x:set, x :e A.
    { exact (nonempty_has_element A HAne). }
    apply HexA.
    let x0. assume Hx0A: x0 :e A.
    claim Hx0UG: x0 :e Union G.
    { exact (HAcovG x0 Hx0A). }
    claim HexU0: exists U0:set, x0 :e U0 /\ U0 :e G.
    { exact (iffEL (x0 :e Union G)
                   (exists Y:set, x0 :e Y /\ Y :e G)
                   (UnionEq G x0) Hx0UG). }
    apply HexU0.
    let U0. assume HU0conj.
    claim HU0G: U0 :e G.
    { exact (andER (x0 :e U0) (U0 :e G) HU0conj). }
    claim HU0Fam0: U0 :e Fam0.
    { exact (HGsub U0 HU0G). }
    claim Hexn0: exists n0:set, n0 :e omega /\ U0 = f n0.
    { exact (ReplE omega (fun n0:set => f n0) U0 HU0Fam0). }
    claim HpickU0: pickN U0 :e omega /\ U0 = f (pickN U0).
    { exact (Eps_i_ex (fun n0:set => n0 :e omega /\ U0 = f n0) Hexn0). }
    claim HpickU0O: pickN U0 :e omega.
    { exact (andEL (pickN U0 :e omega) (U0 = f (pickN U0)) HpickU0). }
    claim HNsetNe: Nset <> Empty.
    { apply (elem_implies_nonempty Nset (pickN U0)).
      exact (ReplI G (fun U:set => pickN U) U0 HU0G). }
    claim HAllSNo: forall y :e Nset, SNo y.
    { let y. assume Hy: y :e Nset.
      apply (ReplE_impred G (fun U:set => pickN U) y Hy (SNo y)).
      let U. assume HU: U :e G.
      assume Hey: y = pickN U.
      rewrite Hey.
      claim HUfam: U :e Fam0.
      { exact (HGsub U HU). }
      claim Hexn: exists n0:set, n0 :e omega /\ U = f n0.
      { exact (ReplE omega (fun n0:set => f n0) U HUfam). }
      claim Hpick: pickN U :e omega /\ U = f (pickN U).
      { exact (Eps_i_ex (fun n0:set => n0 :e omega /\ U = f n0) Hexn). }
      claim HpickO: pickN U :e omega.
      { exact (andEL (pickN U :e omega) (U = f (pickN U)) Hpick). }
      exact (omega_SNo (pickN U) HpickO). }
    claim Hexmax: exists nmax:set, SNo_max_of Nset nmax.
    { exact (finite_max_exists Nset (fun y Hy => HAllSNo y Hy) HNsetFin HNsetNe). }
    apply Hexmax.
    let nmax. assume Hmax.
    claim HnmaxIn: nmax :e Nset.
    { exact (andEL (nmax :e Nset) (SNo nmax) (andEL (nmax :e Nset /\ SNo nmax) (forall y :e Nset, SNo y -> y <= nmax) Hmax)). }
    claim HnmaxS: SNo nmax.
    { exact (andER (nmax :e Nset) (SNo nmax) (andEL (nmax :e Nset /\ SNo nmax) (forall y :e Nset, SNo y -> y <= nmax) Hmax)). }
    claim Hmaxprop: forall y :e Nset, SNo y -> y <= nmax.
    { exact (andER (nmax :e Nset /\ SNo nmax) (forall y :e Nset, SNo y -> y <= nmax) Hmax). }
    (** The bound is M = ordsucc nmax. **)
    set M := ordsucc nmax.
    witness M.
    apply andI.
    * claim HnmaxO: nmax :e omega.
      { apply (ReplE_impred G (fun U:set => pickN U) nmax HnmaxIn (nmax :e omega)).
        let U. assume HU: U :e G.
        assume Heq: nmax = pickN U.
        rewrite Heq.
        claim HUfam: U :e Fam0.
        { exact (HGsub U HU). }
        claim Hexn: exists n0:set, n0 :e omega /\ U = f n0.
        { exact (ReplE omega (fun n0:set => f n0) U HUfam). }
        claim Hpick: pickN U :e omega /\ U = f (pickN U).
        { exact (Eps_i_ex (fun n0:set => n0 :e omega /\ U = f n0) Hexn). }
        exact (andEL (pickN U :e omega) (U = f (pickN U)) Hpick). }
      exact (ordsucc_in_R nmax HnmaxO).
    * let x. assume HxA: x :e A.
      prove ~(Rlt M (Abs x)).
      claim HxUG: x :e Union G.
      { exact (HAcovG x HxA). }
      (** Use UnionEq via iff to extract a witness. **)
      claim HexU: exists U:set, x :e U /\ U :e G.
      { exact (iffEL (x :e Union G) (exists Y:set, x :e Y /\ Y :e G) (UnionEq G x) HxUG). }
      apply HexU.
      let U. assume HUconj.
      claim HUinG: U :e G.
      { exact (andER (x :e U) (U :e G) HUconj). }
      claim HxU: x :e U.
      { exact (andEL (x :e U) (U :e G) HUconj). }
      claim HUfam: U :e Fam0.
      { exact (HGsub U HUinG). }
      claim Hexn: exists n0:set, n0 :e omega /\ U = f n0.
      { exact (ReplE omega (fun n0:set => f n0) U HUfam). }
      claim Hpick: pickN U :e omega /\ U = f (pickN U).
      { exact (Eps_i_ex (fun n0:set => n0 :e omega /\ U = f n0) Hexn). }
      claim HnU: pickN U :e omega.
      { exact (andEL (pickN U :e omega) (U = f (pickN U)) Hpick). }
      claim HUeq: U = f (pickN U).
      { exact (andER (pickN U :e omega) (U = f (pickN U)) Hpick). }
      claim HNin: pickN U :e Nset.
      { exact (ReplI G (fun U0:set => pickN U0) U HUinG). }
      claim HNle: pickN U <= nmax.
      { exact (Hmaxprop (pickN U) HNin (omega_SNo (pickN U) HnU)). }
      claim HordsuccLe: ordsucc (pickN U) <= M.
      { (** use n<=nmax implies n+1 <= nmax+1 **)
        claim HnU_S: SNo (pickN U).
        { exact (omega_SNo (pickN U) HnU). }
        claim HnmaxO: nmax :e omega.
        { apply (ReplE_impred G (fun U0:set => pickN U0) nmax HnmaxIn (nmax :e omega)).
          let U1. assume HU1: U1 :e G.
          assume Heq: nmax = pickN U1.
          rewrite Heq.
          claim HU1fam: U1 :e Fam0.
          { exact (HGsub U1 HU1). }
          claim Hexn1: exists n0:set, n0 :e omega /\ U1 = f n0.
          { exact (ReplE omega (fun n0:set => f n0) U1 HU1fam). }
          claim Hpick1: pickN U1 :e omega /\ U1 = f (pickN U1).
          { exact (Eps_i_ex (fun n0:set => n0 :e omega /\ U1 = f n0) Hexn1). }
          exact (andEL (pickN U1 :e omega) (U1 = f (pickN U1)) Hpick1). }
        claim Hnmax_S: SNo nmax.
        { exact (omega_SNo nmax HnmaxO). }
        claim H1S: SNo 1.
        { exact SNo_1. }
        claim Hadd: add_SNo (pickN U) 1 <= add_SNo nmax 1.
        { exact (add_SNo_Le1 (pickN U) 1 nmax HnU_S H1S Hnmax_S HNle). }
        claim Hm1: add_SNo (pickN U) 1 = ordsucc (pickN U).
        { exact (add_SNo_1_ordsucc (pickN U) HnU). }
        claim Hm2: add_SNo nmax 1 = ordsucc nmax.
        { exact (add_SNo_1_ordsucc nmax HnmaxO). }
        rewrite <- Hm1.
        rewrite <- Hm2.
        exact Hadd. }
      claim HxUfn: x :e f (pickN U).
      { rewrite <- HUeq.
        exact HxU. }
      claim HxR: x :e R.
      { exact (HA x HxA). }
      claim Hxconj: Rlt (minus_SNo (ordsucc (pickN U))) x /\ Rlt x (ordsucc (pickN U)).
      { exact (SepE2 R (fun x0:set => Rlt (minus_SNo (ordsucc (pickN U))) x0 /\ Rlt x0 (ordsucc (pickN U))) x HxUfn). }
      claim HxL: Rlt (minus_SNo (ordsucc (pickN U))) x.
      { exact (andEL (Rlt (minus_SNo (ordsucc (pickN U))) x) (Rlt x (ordsucc (pickN U))) Hxconj). }
      claim HxRgt: Rlt x (ordsucc (pickN U)).
      { exact (andER (Rlt (minus_SNo (ordsucc (pickN U))) x) (Rlt x (ordsucc (pickN U))) Hxconj). }
      (** Strengthen bounds to M. **)
      (** Use interval_bounds_Abs with endpoints -M and M. **)
      claim HNsetSubOmega: Nset c= omega.
      { let y. assume Hy: y :e Nset.
        apply (ReplE_impred G (fun U0:set => pickN U0) y Hy (y :e omega)).
        let U0. assume HU0: U0 :e G.
        assume Hey: y = pickN U0.
        rewrite Hey.
        claim HU0fam: U0 :e Fam0.
        { exact (HGsub U0 HU0). }
        claim Hexn0: exists n0:set, n0 :e omega /\ U0 = f n0.
        { exact (ReplE omega (fun n0:set => f n0) U0 HU0fam). }
        claim Hpick0: pickN U0 :e omega /\ U0 = f (pickN U0).
        { exact (Eps_i_ex (fun n0:set => n0 :e omega /\ U0 = f n0) Hexn0). }
        exact (andEL (pickN U0 :e omega) (U0 = f (pickN U0)) Hpick0). }
      claim HnmaxO: nmax :e omega.
      { exact (HNsetSubOmega nmax HnmaxIn). }
      claim HM: M :e R.
      { exact (ordsucc_in_R nmax HnmaxO). }
      claim HxS: SNo x.
      { exact (real_SNo x HxR). }
      claim HM_S: SNo M.
      { exact (real_SNo M HM). }
      claim HmU: ordsucc (pickN U) :e R.
      { exact (ordsucc_in_R (pickN U) HnU). }
      claim HmU_S: SNo (ordsucc (pickN U)).
      { exact (omega_SNo (ordsucc (pickN U)) (omega_ordsucc (pickN U) HnU)). }
      claim HxltmU: x < ordsucc (pickN U).
      { exact (RltE_lt x (ordsucc (pickN U)) HxRgt). }
      claim HxltM: x < M.
      { exact (SNoLtLe_tra x (ordsucc (pickN U)) M HxS HmU_S HM_S HxltmU HordsuccLe). }
      claim HRltxM: Rlt x M.
      { exact (RltI x M HxR HM HxltM). }
      claim HnegM_R: minus_SNo M :e R.
      { exact (real_minus_SNo M HM). }
      claim HnegM_S: SNo (minus_SNo M).
      { exact (SNo_minus_SNo M HM_S). }
      claim HnegmU_S: SNo (minus_SNo (ordsucc (pickN U))).
      { exact (SNo_minus_SNo (ordsucc (pickN U)) HmU_S). }
      claim Hxgt_negmU: minus_SNo (ordsucc (pickN U)) < x.
      { exact (RltE_lt (minus_SNo (ordsucc (pickN U))) x HxL). }
      claim Hle_neg: minus_SNo M <= minus_SNo (ordsucc (pickN U)).
      { exact (minus_SNo_Le_contra (ordsucc (pickN U)) M HmU_S HM_S HordsuccLe). }
      claim HnegM_lt_x: minus_SNo M < x.
      { exact (SNoLeLt_tra (minus_SNo M) (minus_SNo (ordsucc (pickN U))) x HnegM_S HnegmU_S HxS Hle_neg Hxgt_negmU). }
      claim HRltnegMx: Rlt (minus_SNo M) x.
      { exact (RltI (minus_SNo M) x HnegM_R HxR HnegM_lt_x). }
      exact (interval_bounds_Abs M x HM HxR HRltnegMx HRltxM).
Qed.

(** from 27: compact subspaces of  are closed and bounded **) 
(** LATEX VERSION: Any compact subspace of  is closed and bounded. **)
Theorem compact_real_closed_bounded : forall A:set,
  compact_space A (subspace_topology R R_standard_topology A) ->
  closed_in R R_standard_topology A /\ bounded_subset_of_reals A.
let A.
assume Hcomp: compact_space A (subspace_topology R R_standard_topology A).
prove closed_in R R_standard_topology A /\ bounded_subset_of_reals A.
claim HtopA: topology_on A (subspace_topology R R_standard_topology A).
{ exact (andEL (topology_on A (subspace_topology R R_standard_topology A))
               (forall Fam:set, open_cover_of A (subspace_topology R R_standard_topology A) Fam ->
                  has_finite_subcover A (subspace_topology R R_standard_topology A) Fam)
               Hcomp). }
claim HAin: A :e subspace_topology R R_standard_topology A.
{ exact (topology_has_X A (subspace_topology R R_standard_topology A) HtopA). }
claim HexV: exists V :e R_standard_topology, A = V :/\: A.
{ exact (SepE2 (Power A)
               (fun U0:set => exists V :e R_standard_topology, U0 = V :/\: A)
               A HAin). }
apply HexV.
let V. assume HVpair.
claim HV: V :e R_standard_topology.
{ exact (andEL (V :e R_standard_topology) (A = V :/\: A) HVpair). }
claim HAeq: A = V :/\: A.
{ exact (andER (V :e R_standard_topology) (A = V :/\: A) HVpair). }
claim HT: topology_on R R_standard_topology.
{ exact R_standard_topology_is_topology_local. }
claim HVsubR: V c= R.
{ exact (topology_elem_subset R R_standard_topology V HT HV). }
claim HA: A c= R.
{ let x. assume HxA: x :e A.
  claim HxVA: x :e V :/\: A.
  { rewrite <- HAeq.
    exact HxA. }
  claim HxV: x :e V.
  { exact (binintersectE1 V A x HxVA). }
  exact (HVsubR x HxV). }
exact (Heine_Borel_closed_bounded A HA Hcomp).
Qed.

(** from 28 Definition: limit point compactness **) 
(** LATEX VERSION: Limit point compact means every infinite subset has a limit point in X. **)
Definition limit_point_compact : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall A:set, A c= X -> infinite A -> exists x:set, limit_point_of X Tx A x.

(** Helper: extract topology_on from limit_point_compact **)
Theorem limit_point_compact_topology : forall X Tx:set,
  limit_point_compact X Tx -> topology_on X Tx.
let X Tx.
assume H: limit_point_compact X Tx.
exact (andEL (topology_on X Tx)
             (forall A:set, A c= X -> infinite A -> exists x:set, limit_point_of X Tx A x)
             H).
Qed.

(** Helper: extract limit point property from limit_point_compact **)
Theorem limit_point_compact_property : forall X Tx A:set,
  limit_point_compact X Tx -> A c= X -> infinite A -> exists x:set, limit_point_of X Tx A x.
let X Tx A.
assume H: limit_point_compact X Tx.
assume HA: A c= X.
assume Hinf: infinite A.
claim Hprop: forall A0:set, A0 c= X -> infinite A0 -> exists x:set, limit_point_of X Tx A0 x.
{ exact (andER (topology_on X Tx)
               (forall A0:set, A0 c= X -> infinite A0 -> exists x:set, limit_point_of X Tx A0 x)
               H). }
exact (Hprop A HA Hinf).
Qed.

(** LATEX VERSION: Compact  limit point compact. **)
Theorem compact_implies_limit_point_compact : forall X Tx:set,
  compact_space X Tx -> limit_point_compact X Tx.
let X Tx.
assume Hcomp: compact_space X Tx.
prove limit_point_compact X Tx.
claim HTx: topology_on X Tx.
{ exact (compact_space_topology X Tx Hcomp). }
prove topology_on X Tx /\
  forall A:set, A c= X -> infinite A -> exists x:set, limit_point_of X Tx A x.
apply andI.
- exact HTx.
- let A.
  assume HA: A c= X.
  assume HinfA: infinite A.
  prove exists x:set, limit_point_of X Tx A x.
  apply (xm (exists x:set, limit_point_of X Tx A x)).
  + assume Hex: exists x:set, limit_point_of X Tx A x.
    exact Hex.
  + assume Hnone: ~(exists x:set, limit_point_of X Tx A x).
    prove exists x:set, limit_point_of X Tx A x.
    apply FalseE.
    prove False.

    set Fam := {U :e Tx | exists x:set, x :e X /\ x :e U /\ ~(exists y:set, y :e A /\ y <> x /\ y :e U)}.

    claim HFam_in_Tx: forall U:set, U :e Fam -> U :e Tx.
    { let U. assume HU: U :e Fam.
      exact (SepE1 Tx (fun U0:set => exists x:set, x :e X /\ x :e U0 /\ ~(exists y:set, y :e A /\ y <> x /\ y :e U0)) U HU). }

    claim HFam_sub_PowX: Fam c= Power X.
    { let U. assume HU: U :e Fam.
      prove U :e Power X.
      claim HUinTx: U :e Tx.
      { exact (HFam_in_Tx U HU). }
      claim HUsubX: U c= X.
      { exact (topology_elem_subset X Tx U HTx HUinTx). }
      exact (PowerI X U HUsubX). }

    claim HX_sub_UnionFam: X c= Union Fam.
    { let x. assume HxX: x :e X.
      prove x :e Union Fam.
      claim HnotLp: ~ limit_point_of X Tx A x.
      { assume Hlp: limit_point_of X Tx A x.
        apply Hnone.
        witness x.
        exact Hlp. }

      claim HnotForall: ~(forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U).
      { assume Hall: forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
        apply HnotLp.
        prove topology_on X Tx /\ x :e X /\ forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
        apply andI.
        - apply andI.
          + exact HTx.
          + exact HxX.
        - exact Hall. }

      claim HexU: exists U:set, ~(U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U).
      { exact (not_all_ex_demorgan_i (fun U:set => U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U) HnotForall). }
      apply HexU.
      let U.
      assume HnotImp: ~(U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U).

      claim HUinTx: U :e Tx.
      { apply (xm (U :e Tx)).
        - assume HU: U :e Tx.
          exact HU.
        - assume HUn: U /:e Tx.
          prove U :e Tx.
          apply FalseE.
          prove False.
          claim Himp: U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
          { assume HU0: U :e Tx.
            assume _.
            apply FalseE.
            exact (HUn HU0). }
          exact (HnotImp Himp). }

      claim HxU: x :e U.
      { apply (xm (x :e U)).
        - assume Hxu: x :e U.
          exact Hxu.
        - assume HxUn: x /:e U.
          prove x :e U.
          apply FalseE.
          prove False.
          claim Himp: U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
          { assume _.
            assume Hxu: x :e U.
            apply FalseE.
            exact (HxUn Hxu). }
          exact (HnotImp Himp). }

      claim HnoY: ~(exists y:set, y :e A /\ y <> x /\ y :e U).
      { assume Hexy: exists y:set, y :e A /\ y <> x /\ y :e U.
        prove False.
        claim Himp: U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
        { assume _. assume _. exact Hexy. }
        exact (HnotImp Himp). }

      claim HUinFam: U :e Fam.
      { apply (SepI Tx
                    (fun U0:set => exists x0:set, x0 :e X /\ x0 :e U0 /\ ~(exists y:set, y :e A /\ y <> x0 /\ y :e U0))
                    U HUinTx).
        witness x.
        apply andI.
        - apply andI.
          + exact HxX.
          + exact HxU.
        - exact HnoY. }

      exact (UnionI Fam x U HxU HUinFam). }

    claim HFam_cover: open_cover_of X Tx Fam.
    { prove topology_on X Tx /\ Fam c= Power X /\ X c= Union Fam /\ (forall U:set, U :e Fam -> U :e Tx).
      apply andI.
      - prove (topology_on X Tx /\ Fam c= Power X) /\ X c= Union Fam.
        apply andI.
        + prove topology_on X Tx /\ Fam c= Power X.
          apply andI.
          * exact HTx.
          * exact HFam_sub_PowX.
        + exact HX_sub_UnionFam.
      - exact HFam_in_Tx. }

    claim Hsub: has_finite_subcover X Tx Fam.
    { exact (Heine_Borel_subcover X Tx Fam Hcomp HFam_cover). }
    apply Hsub.
    let G.
    assume HG: G c= Fam /\ finite G /\ X c= Union G.

    claim HG1: G c= Fam /\ finite G.
    { exact (andEL (G c= Fam /\ finite G) (X c= Union G) HG). }
    claim HGsub: G c= Fam.
    { exact (andEL (G c= Fam) (finite G) HG1). }
    claim HGfin: finite G.
    { exact (andER (G c= Fam) (finite G) HG1). }
    claim HXcovG: X c= Union G.
    { exact (andER (G c= Fam /\ finite G) (X c= Union G) HG). }

    set pickX := fun U:set => Eps_i (fun x:set => x :e X /\ x :e U /\ ~(exists y:set, y :e A /\ y <> x /\ y :e U)).
    set Ximg := {pickX U|U :e G}.

    claim HXimgFin: finite Ximg.
    { exact (Repl_finite (fun U:set => pickX U) G HGfin). }

    claim HAsubXimg: A c= Ximg.
    { let a. assume HaA: a :e A.
      prove a :e Ximg.
      claim HaX: a :e X.
      { exact (HA a HaA). }
      claim HaUnionG: a :e Union G.
      { exact (HXcovG a HaX). }
      apply (UnionE_impred G a HaUnionG).
      let U.
      assume HaU: a :e U.
      assume HUinG: U :e G.

      claim HUinFam: U :e Fam.
      { exact (HGsub U HUinG). }
      claim HexxU: exists x:set, x :e X /\ x :e U /\ ~(exists y:set, y :e A /\ y <> x /\ y :e U).
      { exact (SepE2 Tx
                    (fun U0:set => exists x:set, x :e X /\ x :e U0 /\ ~(exists y:set, y :e A /\ y <> x /\ y :e U0))
                    U HUinFam). }
      claim HpickProp: pickX U :e X /\ pickX U :e U /\ ~(exists y:set, y :e A /\ y <> pickX U /\ y :e U).
      { apply HexxU.
        let x0.
        assume Hx0: x0 :e X /\ x0 :e U /\ ~(exists y:set, y :e A /\ y <> x0 /\ y :e U).
        exact (Eps_i_ax (fun x:set => x :e X /\ x :e U /\ ~(exists y:set, y :e A /\ y <> x /\ y :e U)) x0 Hx0). }

      claim HnoOther: ~(exists y:set, y :e A /\ y <> pickX U /\ y :e U).
      { exact (andER (pickX U :e X /\ pickX U :e U) (~(exists y:set, y :e A /\ y <> pickX U /\ y :e U)) HpickProp). }

      claim HaEq: a = pickX U.
      { apply (xm (a = pickX U)).
        - assume Heq: a = pickX U.
          exact Heq.
        - assume Hneq: a <> pickX U.
          prove a = pickX U.
          apply FalseE.
          prove False.
          claim Hexy: exists y:set, y :e A /\ y <> pickX U /\ y :e U.
          { witness a.
            apply andI.
            - apply andI.
              + exact HaA.
              + exact Hneq.
            - exact HaU. }
          exact (HnoOther Hexy). }

      claim HpickInImg: pickX U :e Ximg.
      { exact (ReplI G (fun U0:set => pickX U0) U HUinG). }
      rewrite HaEq.
      exact HpickInImg. }

    claim HfinA: finite A.
    { exact (Subq_finite Ximg HXimgFin A HAsubXimg). }
    exact (HinfA HfinA).
Qed.

(** from 28: limit point compactness vs compactness **) 
(** LATEX VERSION: Limit point compact need not imply compact; provides counterexample placeholder. **)
Theorem limit_point_compact_not_necessarily_compact :
  exists X Tx:set, limit_point_compact X Tx /\ ~ compact_space X Tx.
prove exists X Tx:set, limit_point_compact X Tx /\ ~ compact_space X Tx.
admit.
Qed.

(** from 29 Definition: local compactness **) 
(** LATEX VERSION: Locally compact means each point has a neighborhood whose closure is compact. **)
Definition locally_compact : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall x:set, x :e X ->
    exists U:set, U :e Tx /\ x :e U /\
      compact_space (closure_of X Tx U) (subspace_topology X Tx (closure_of X Tx U)).

(** Helper: extract topology_on from locally_compact **)
Theorem locally_compact_topology : forall X Tx:set,
  locally_compact X Tx -> topology_on X Tx.
let X Tx.
assume H: locally_compact X Tx.
exact (andEL (topology_on X Tx)
             (forall x:set, x :e X ->
               exists U:set, U :e Tx /\ x :e U /\
                 compact_space (closure_of X Tx U) (subspace_topology X Tx (closure_of X Tx U)))
             H).
Qed.

(** Helper: extract local compactness neighborhood property **)
Theorem locally_compact_local : forall X Tx x:set,
  locally_compact X Tx ->
  x :e X ->
  exists U:set, U :e Tx /\ x :e U /\
    compact_space (closure_of X Tx U) (subspace_topology X Tx (closure_of X Tx U)).
let X Tx x.
assume H: locally_compact X Tx.
assume Hx: x :e X.
claim Hprop: forall x0:set, x0 :e X ->
  exists U:set, U :e Tx /\ x0 :e U /\
    compact_space (closure_of X Tx U) (subspace_topology X Tx (closure_of X Tx U)).
{ exact (andER (topology_on X Tx)
               (forall x0:set, x0 :e X ->
                 exists U:set, U :e Tx /\ x0 :e U /\
                   compact_space (closure_of X Tx U) (subspace_topology X Tx (closure_of X Tx U)))
               H). }
exact (Hprop x Hx).
Qed.

(** LATEX VERSION: In Hausdorff spaces, compact subsets are closed. **)
Theorem Hausdorff_compact_sets_closed : forall X Tx A:set,
  Hausdorff_space X Tx ->
  A c= X ->
  compact_space A (subspace_topology X Tx A) ->
  closed_in X Tx A.
let X Tx A.
assume HH: Hausdorff_space X Tx.
assume HA: A c= X.
assume Hcomp: compact_space A (subspace_topology X Tx A).
prove closed_in X Tx A.
exact (compact_subspace_in_Hausdorff_closed X Tx A HH HA Hcomp).
Qed.

(** from 29: one-point compactification placeholder **) 
(** LATEX VERSION: One-point compactification of a locally compact Hausdorff space. **)
Definition one_point_compactification : set -> set -> set -> set -> prop := fun X Tx Y Ty =>
  compact_space Y Ty /\ Hausdorff_space Y Ty /\ X c= Y /\
  exists p:set, p :e Y /\ ~ p :e X /\
    subspace_topology Y Ty X = Tx /\
    (forall y:set, y :e Y -> y :e X \/ y = p).

Theorem one_point_compactification_exists : forall X Tx:set,
  locally_compact X Tx -> Hausdorff_space X Tx ->
  exists Y Ty:set, one_point_compactification X Tx Y Ty.
let X Tx.
assume Hlc: locally_compact X Tx.
assume HH: Hausdorff_space X Tx.
prove exists Y Ty:set, one_point_compactification X Tx Y Ty.
admit.
Qed.

(** from 29 Exercises: local compactness and compactification **) 
(** LATEX VERSION: Exercises on constructing one-point compactifications. **)
Theorem ex29_local_compactness_exercises :
  forall X Tx:set, locally_compact X Tx -> Hausdorff_space X Tx ->
  exists Y Ty:set, one_point_compactification X Tx Y Ty.
let X Tx.
assume Hlc: locally_compact X Tx.
assume HH: Hausdorff_space X Tx.
prove exists Y Ty:set, one_point_compactification X Tx Y Ty.
exact (one_point_compactification_exists X Tx Hlc HH).
Qed.

(** from exercises after 29: directed sets **)
(** LATEX VERSION: Directed set definition (nonempty, every pair has an upper bound). **)
(** FIXED: Upper bound condition uses exists k:e J with (i :e k \/ i = k) and (j :e k \/ j = k), interpreting <= via von Neumann ordinals. **) 
(** SUSPICIOUS DEFINITION: Directed-set order is encoded by membership on ordinals (i :e k \/ i = k), while general topology uses abstract preorders; later translations may be needed. **) 
Definition directed_set : set -> prop := fun J =>
  (J <> Empty /\ forall i:set, i :e J -> ordinal i)
  /\ forall i j:set, i :e J -> j :e J ->
    exists k:set, k :e J /\ (i :e k \/ i = k) /\ (j :e k \/ j = k).

(** helper: directed sets are nonempty **)
Theorem directed_set_nonempty : forall J:set, directed_set J -> J <> Empty.
let J. assume HJ: directed_set J.
prove J <> Empty.
claim Hleft: J <> Empty /\ forall i:set, i :e J -> ordinal i.
{ exact (andEL (J <> Empty /\ forall i:set, i :e J -> ordinal i)
               (forall i j:set, i :e J -> j :e J ->
                 exists k:set, k :e J /\ (i :e k \/ i = k) /\ (j :e k \/ j = k))
               HJ). }
exact (andEL (J <> Empty) (forall i:set, i :e J -> ordinal i) Hleft).
Qed.

(** helper: elements of a directed set are ordinals **)
Theorem directed_set_ordinals : forall J:set,
  directed_set J -> forall i:set, i :e J -> ordinal i.
let J. assume HJ: directed_set J.
prove forall i:set, i :e J -> ordinal i.
let i. assume HiJ: i :e J.
claim Hleft: J <> Empty /\ forall i0:set, i0 :e J -> ordinal i0.
{ exact (andEL (J <> Empty /\ forall i0:set, i0 :e J -> ordinal i0)
               (forall i j:set, i :e J -> j :e J ->
                 exists k:set, k :e J /\ (i :e k \/ i = k) /\ (j :e k \/ j = k))
               HJ). }
claim Hord: forall i0:set, i0 :e J -> ordinal i0.
{ exact (andER (J <> Empty) (forall i0:set, i0 :e J -> ordinal i0) Hleft). }
exact (Hord i HiJ).
Qed.

(** helper: upper bound property of a directed set **)
Theorem directed_set_upper_bound_property : forall J:set,
  directed_set J ->
  forall i j:set, i :e J -> j :e J ->
    exists k:set, k :e J /\ (i :e k \/ i = k) /\ (j :e k \/ j = k).
let J. assume HJ: directed_set J.
prove forall i j:set, i :e J -> j :e J ->
  exists k:set, k :e J /\ (i :e k \/ i = k) /\ (j :e k \/ j = k).
let i j. assume HiJ: i :e J. assume HjJ: j :e J.
claim Hright:
  forall i0 j0:set, i0 :e J -> j0 :e J ->
    exists k:set, k :e J /\ (i0 :e k \/ i0 = k) /\ (j0 :e k \/ j0 = k).
{ exact (andER (J <> Empty /\ forall t:set, t :e J -> ordinal t)
               (forall i0 j0:set, i0 :e J -> j0 :e J ->
                 exists k:set, k :e J /\ (i0 :e k \/ i0 = k) /\ (j0 :e k \/ j0 = k))
               HJ). }
exact (Hright i j HiJ HjJ).
Qed.

(** helper: every element in a directed set has an upper bound in the set **)
(** LATEX VERSION: In a directed set J, for each i in J there exists k in J with i  k. **)
Theorem directed_set_upper_bound : forall J i:set,
  directed_set J -> i :e J -> exists k:set, k :e J /\ (i :e k \/ i = k).
let J i.
assume HJ: directed_set J.
assume HiJ: i :e J.
prove exists k:set, k :e J /\ (i :e k \/ i = k).
claim Hdir: forall a b:set, a :e J -> b :e J ->
  exists k:set, k :e J /\ (a :e k \/ a = k) /\ (b :e k \/ b = k).
{ exact (directed_set_upper_bound_property J HJ). }
claim Hexk: exists k:set, k :e J /\ (i :e k \/ i = k) /\ (i :e k \/ i = k).
{ exact (Hdir i i HiJ HiJ). }
apply Hexk.
let k.
assume Hk: k :e J /\ (i :e k \/ i = k) /\ (i :e k \/ i = k).
witness k.
prove k :e J /\ (i :e k \/ i = k).
claim Hk1: k :e J /\ (i :e k \/ i = k).
{ exact (andEL (k :e J /\ (i :e k \/ i = k)) (i :e k \/ i = k) Hk). }
exact Hk1.
Qed.

(** helper: upper bound for two elements in a directed set **)
(** LATEX VERSION: In a directed set J, for i,j in J there exists k in J with i  k and j  k. **)
Theorem directed_set_pair_upper_bound : forall J i j:set,
  directed_set J -> i :e J -> j :e J ->
  exists k:set, k :e J /\ (i :e k \/ i = k) /\ (j :e k \/ j = k).
let J i j.
assume HJ: directed_set J.
assume HiJ: i :e J.
assume HjJ: j :e J.
prove exists k:set, k :e J /\ (i :e k \/ i = k) /\ (j :e k \/ j = k).
claim Hdir: forall a b:set, a :e J -> b :e J ->
  exists k:set, k :e J /\ (a :e k \/ a = k) /\ (b :e k \/ b = k).
{ exact (directed_set_upper_bound_property J HJ). }
exact (Hdir i j HiJ HjJ).
Qed.

(** from exercises after 29: examples of directed sets **) 
(** LATEX VERSION: Simple closure properties/examples of directed sets (placeholder). **)
Theorem examples_of_directed_sets : forall J:set,
  directed_set J -> directed_set J.
let J.
assume H: directed_set J.
prove directed_set J.
exact H.
Qed.

(** from exercises after 29: cofinal subsets of directed sets are directed **)
(** LATEX VERSION: Cofinal subset of a directed set is directed. **)
(** FIXED: Cofinality hypothesis must say: forall i:e J, exists k:e K with i<=k (i :e k \/ i = k); old version was trivially true from i:e J. **)
Theorem cofinal_subset_directed : forall J K:set,
  directed_set J -> K c= J ->
  (forall i:set, i :e J -> exists k:set, k :e K /\ (i :e k \/ i = k)) ->
  directed_set K.
let J K.
assume HJ: directed_set J.
assume HK: K c= J.
assume Hcofinal: forall i:set, i :e J -> exists k:set, k :e K /\ (i :e k \/ i = k).
prove directed_set K.
prove (K <> Empty /\ forall i:set, i :e K -> ordinal i)
  /\ forall i j:set, i :e K -> j :e K ->
    exists k:set, k :e K /\ (i :e k \/ i = k) /\ (j :e k \/ j = k).
apply andI.
- (** K is nonempty and all its elements are ordinals **)
  prove K <> Empty /\ forall i:set, i :e K -> ordinal i.
  apply andI.
  + (** nonempty **)
    assume HK0: K = Empty.
    prove False.
    claim HJ0: J <> Empty.
    { exact (directed_set_nonempty J HJ). }
    claim Hexj: exists j0:set, j0 :e J.
    { exact (nonempty_has_element J HJ0). }
    apply Hexj.
    let j0. assume Hj0: j0 :e J.
    claim Hexk: exists k:set, k :e K /\ (j0 :e k \/ j0 = k).
    { exact (Hcofinal j0 Hj0). }
    apply Hexk.
    let k. assume Hkpair.
    claim HkK: k :e K.
    { exact (andEL (k :e K) (j0 :e k \/ j0 = k) Hkpair). }
    claim HkE: k :e Empty.
    { rewrite <- HK0. exact HkK. }
    exact (EmptyE k HkE).
  + (** ordinals **)
    let i. assume HiK: i :e K.
    claim HiJ: i :e J.
    { exact (HK i HiK). }
    exact (directed_set_ordinals J HJ i HiJ).
- (** upper bound in K from directedness in J and cofinality **)
  let i j.
  assume HiK: i :e K.
  assume HjK: j :e K.
  prove exists k:set, k :e K /\ (i :e k \/ i = k) /\ (j :e k \/ j = k).
  claim HiJ: i :e J.
  { exact (HK i HiK). }
  claim HjJ: j :e J.
  { exact (HK j HjK). }
  claim Hexm: exists m:set, m :e J /\ (i :e m \/ i = m) /\ (j :e m \/ j = m).
  { exact (directed_set_upper_bound_property J HJ i j HiJ HjJ). }
  apply Hexm.
  let m. assume Hmpair.
  claim Hmleft: (m :e J /\ (i :e m \/ i = m)).
  { exact (andEL (m :e J /\ (i :e m \/ i = m))
                 (j :e m \/ j = m)
                 Hmpair). }
  claim HmJ: m :e J.
  { exact (andEL (m :e J) (i :e m \/ i = m) Hmleft). }
  claim Him: i :e m \/ i = m.
  { exact (andER (m :e J) (i :e m \/ i = m) Hmleft). }
  claim Hjm: j :e m \/ j = m.
  { exact (andER (m :e J /\ (i :e m \/ i = m))
                 (j :e m \/ j = m)
                 Hmpair). }
  claim Hexk0: exists k0:set, k0 :e K /\ (m :e k0 \/ m = k0).
  { exact (Hcofinal m HmJ). }
  apply Hexk0.
  let k0. assume Hk0pair.
  claim Hk0K: k0 :e K.
  { exact (andEL (k0 :e K) (m :e k0 \/ m = k0) Hk0pair). }
  claim Hmk0: m :e k0 \/ m = k0.
  { exact (andER (k0 :e K) (m :e k0 \/ m = k0) Hk0pair). }
  witness k0.
  prove k0 :e K /\ (i :e k0 \/ i = k0) /\ (j :e k0 \/ j = k0).
  apply andI.
  - (** k0 in K and i  k0 **)
    apply andI.
    + exact Hk0K.
    + (** i  k0 **)
      apply (Him (i :e k0 \/ i = k0)).
      * (** case i :e m **)
        assume Himem: i :e m.
        apply (Hmk0 (i :e k0 \/ i = k0)).
        { assume Hmink0: m :e k0.
          claim Hk0J: k0 :e J.
          { exact (HK k0 Hk0K). }
          claim Hordk0: ordinal k0.
          { exact (directed_set_ordinals J HJ k0 Hk0J). }
          claim Htransk0: TransSet k0.
          { exact (ordinal_TransSet k0 Hordk0). }
          claim HmSub: m c= k0.
          { exact (Htransk0 m Hmink0). }
          exact (orIL (i :e k0) (i = k0) (HmSub i Himem)). }
        { assume Hmeq: m = k0.
          rewrite <- Hmeq.
          exact (orIL (i :e m) (i = m) Himem). }
      * (** case i = m **)
        assume Hieq: i = m.
        apply (Hmk0 (i :e k0 \/ i = k0)).
        { assume Hmink0: m :e k0.
          rewrite Hieq.
          exact (orIL (m :e k0) (m = k0) Hmink0). }
        { assume Hmeq: m = k0.
          rewrite Hieq.
          exact (orIR (m :e k0) (m = k0) Hmeq). }
  - (** j  k0 **)
    apply (Hjm (j :e k0 \/ j = k0)).
      * (** case j :e m **)
        assume Hjmem: j :e m.
        apply (Hmk0 (j :e k0 \/ j = k0)).
        { assume Hmink0: m :e k0.
          claim Hk0J: k0 :e J.
          { exact (HK k0 Hk0K). }
          claim Hordk0: ordinal k0.
          { exact (directed_set_ordinals J HJ k0 Hk0J). }
          claim Htransk0: TransSet k0.
          { exact (ordinal_TransSet k0 Hordk0). }
          claim HmSub: m c= k0.
          { exact (Htransk0 m Hmink0). }
          exact (orIL (j :e k0) (j = k0) (HmSub j Hjmem)). }
        { assume Hmeq: m = k0.
          rewrite <- Hmeq.
          exact (orIL (j :e m) (j = m) Hjmem). }
      * (** case j = m **)
        assume Hjeq: j = m.
        apply (Hmk0 (j :e k0 \/ j = k0)).
        { assume Hmink0: m :e k0.
          rewrite Hjeq.
          exact (orIL (m :e k0) (m = k0) Hmink0). }
        { assume Hmeq: m = k0.
          rewrite Hjeq.
          exact (orIR (m :e k0) (m = k0) Hmeq). }
Qed.

(** from exercises after 29: nets as functions from directed sets **) 
(** LATEX VERSION: A net is a function from a directed set into a space. **)
Definition net_on : set -> prop := fun net =>
  exists J X:set, directed_set J /\ function_on net J X.

(** from exercises after 29: subnet definition placeholder **)
(** LATEX VERSION: Definition of subnet (Exercise, placeholder formalization). **)
(** FIXED: Cofinality condition is forall j:e J, exists k0:e K, forall k:e K with k0<=k, we have j<=phi(k); old version forced phi to be constant; also subnet values satisfy sub(k) = net(phi(k)) in the same codomain X. **) 
(** SUSPICIOUS DEFINITION: subnet_of packages shared codomain and cofinal map; relating it to net_converges may require an index-alignment lemma since net_converges hides the index set. **) 
Definition subnet_of : set -> set -> prop := fun net sub =>
  exists J K X phi:set,
    directed_set J /\ directed_set K /\
    function_on net J X /\ function_on sub K X /\
    function_on phi K J /\
    (forall j:set, j :e J -> exists k0:set, k0 :e K /\
      forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
        (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
    (forall k:set, k :e K ->
      apply_fun sub k = apply_fun net (apply_fun phi k)).

(** helper: a subnet is a net **)
(** LATEX VERSION: Any subnet is itself a net on some directed set. **)
Theorem subnet_implies_net_on : forall net sub:set, subnet_of net sub -> net_on sub.
let net sub.
assume Hsub: subnet_of net sub.
prove net_on sub.
apply Hsub.
let J. assume Hrest: exists K X phi:set,
  directed_set J /\ directed_set K /\
  function_on net J X /\ function_on sub K X /\
  function_on phi K J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).
apply Hrest.
let K. assume Hrest2: exists X phi:set,
  directed_set J /\ directed_set K /\
  function_on net J X /\ function_on sub K X /\
  function_on phi K J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).
apply Hrest2.
let X. assume Hrest3: exists phi:set,
  directed_set J /\ directed_set K /\
  function_on net J X /\ function_on sub K X /\
  function_on phi K J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).
apply Hrest3.
let phi. assume Hdata:
  directed_set J /\ directed_set K /\
  function_on net J X /\ function_on sub K X /\
  function_on phi K J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).
prove exists J0 X0:set, directed_set J0 /\ function_on sub J0 X0.
witness K.
witness X.
prove directed_set K /\ function_on sub K X.
(** destruct subnet_of data by repeated conjunction elimination **)
apply Hdata.
assume Hcore Heq.
apply Hcore.
assume Hcore2 Hcofinal.
apply Hcore2.
assume Hcore3 Hphi_on.
apply Hcore3.
assume Hcore4 Hsubfun.
apply Hcore4.
assume HJK Hnetfun.
apply HJK.
assume HdirJ HdirK.
apply andI.
- exact HdirK.
- exact Hsubfun.
Qed.

(** helper: if sub is a subnet, net is a net **)
(** LATEX VERSION: The original function in a subnet pair is also a net. **)
Theorem subnet_implies_net_on_source : forall net sub:set, subnet_of net sub -> net_on net.
let net sub.
assume Hsub: subnet_of net sub.
prove net_on net.
apply Hsub.
let J. assume Hrest: exists K X phi:set,
  directed_set J /\ directed_set K /\
  function_on net J X /\ function_on sub K X /\
  function_on phi K J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).
apply Hrest.
let K. assume Hrest2: exists X phi:set,
  directed_set J /\ directed_set K /\
  function_on net J X /\ function_on sub K X /\
  function_on phi K J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).
apply Hrest2.
let X. assume Hrest3: exists phi:set,
  directed_set J /\ directed_set K /\
  function_on net J X /\ function_on sub K X /\
  function_on phi K J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).
apply Hrest3.
let phi. assume Hdata:
  directed_set J /\ directed_set K /\
  function_on net J X /\ function_on sub K X /\
  function_on phi K J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).
prove exists J0 X0:set, directed_set J0 /\ function_on net J0 X0.
witness J.
witness X.
prove directed_set J /\ function_on net J X.
apply Hdata.
assume Hcore Heq.
apply Hcore.
assume Hcore2 Hcofinal.
apply Hcore2.
assume Hcore3 Hphi_on.
apply Hcore3.
assume Hcore4 Hsubfun.
apply Hcore4.
assume HJK Hnetfun.
apply HJK.
assume HdirJ HdirK.
apply andI.
- exact HdirJ.
- exact Hnetfun.
Qed.

(** helper: a net is a subnet of itself **)
(** LATEX VERSION: Every net is a subnet of itself via the identity index map. **)
Theorem subnet_of_refl_witnessed : forall J X net:set,
  directed_set J -> function_on net J X -> subnet_of net net.
let J X net.
assume HdirJ: directed_set J.
assume Hnetfun: function_on net J X.
prove subnet_of net net.
prove exists J0 K0 X0 phi:set,
  directed_set J0 /\ directed_set K0 /\
  function_on net J0 X0 /\ function_on net K0 X0 /\
  function_on phi K0 J0 /\
  (forall j:set, j :e J0 -> exists k0:set, k0 :e K0 /\
    forall k:set, k :e K0 -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K0 ->
    apply_fun net k = apply_fun net (apply_fun phi k)).
witness J.
witness J.
witness X.
set phi := {(y,y) | y :e J}.
witness phi.
prove directed_set J /\ directed_set J /\
  function_on net J X /\ function_on net J X /\
  function_on phi J J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e J /\
    forall k:set, k :e J -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e J ->
    apply_fun net k = apply_fun net (apply_fun phi k)).
apply andI.
- (** P: ((((directed_set /\ directed_set) /\ fun /\ fun) /\ phi_on) /\ cofinal) **)
  apply andI.
  + (** R: (((directed_set /\ directed_set) /\ fun /\ fun) /\ phi_on) **)
    apply andI.
    * (** S: ((directed_set /\ directed_set) /\ fun) /\ fun **)
      apply andI.
      { (** T: (directed_set /\ directed_set) /\ fun **)
        apply andI.
        - (** U: directed_set /\ directed_set **)
          apply andI.
          + exact HdirJ.
          + exact HdirJ.
        - exact Hnetfun. }
      { exact Hnetfun. }
    * (** function_on phi J J **)
      let k. assume HkJ: k :e J.
      prove apply_fun phi k :e J.
      claim Hphi: apply_fun phi k = k.
      { exact (identity_function_apply J k HkJ). }
      rewrite Hphi.
      exact HkJ.
  + (** cofinality via identity **)
    let j. assume HjJ: j :e J.
    witness j.
    prove j :e J /\
      forall k:set, k :e J -> (j :e k \/ j = k) ->
        (j :e apply_fun phi k \/ j = apply_fun phi k).
    apply andI.
    - exact HjJ.
    - let k. assume HkJ: k :e J. assume Hjle: j :e k \/ j = k.
      claim Hphi: apply_fun phi k = k.
      { exact (identity_function_apply J k HkJ). }
      rewrite Hphi.
      exact Hjle.
- (** pointwise equality net = net o phi **)
  let k. assume HkJ: k :e J.
  claim Hphi: apply_fun phi k = k.
  { exact (identity_function_apply J k HkJ). }
  rewrite Hphi.
  reflexivity.
Qed.

(** helper: if net_on net then subnet_of net net **)
(** LATEX VERSION: Every net admits the trivial subnet given by itself. **)
Theorem subnet_of_refl : forall net:set, net_on net -> subnet_of net net.
let net. assume Hnet: net_on net.
prove subnet_of net net.
apply Hnet.
let J. assume Hrest: exists X:set, directed_set J /\ function_on net J X.
apply Hrest.
let X. assume HJX: directed_set J /\ function_on net J X.
claim HdirJ: directed_set J.
{ exact (andEL (directed_set J) (function_on net J X) HJX). }
claim Hfun: function_on net J X.
{ exact (andER (directed_set J) (function_on net J X) HJX). }
exact (subnet_of_refl_witnessed J X net HdirJ Hfun).
Qed.

(** from exercises after 29: accumulation point of a net **)
(** LATEX VERSION: An accumulation point of a net means every neighborhood contains infinitely many (or cofinal) net points; placeholder formalization. **)
(** FIXED: accumulation_point_of_net now includes Tx, quantifies only over U:e Tx with x:e U, and uses cofinality forall j0:e J, exists j>=j0 with net(j):e U; net is a function into X. **) 
(** SUSPICIOUS DEFINITION: Index comparison uses membership-based <= (j0 :e j \/ j0 = j), which is tailored to ordinal indices and may require alignment lemmas later. **) 
Definition accumulation_point_of_net : set -> set -> set -> set -> prop := fun X Tx net x =>
  exists J:set, topology_on X Tx /\ directed_set J /\ function_on net J X /\ x :e X /\
    forall U:set, U :e Tx -> x :e U ->
      forall j0:set, j0 :e J ->
        exists j:set, j :e J /\ (j0 :e j \/ j0 = j) /\ apply_fun net j :e U.

(** from exercises after 29: net convergence **)
(** LATEX VERSION: A net converges to x if eventually in every neighborhood U of x. **)
(** FIXED: net_converges uses eventuality: forall U:e Tx with x:e U, exists i0:e J such that forall i:e J with i0<=i (i0 :e i \/ i0 = i), we have net(i):e U; old version only required one index in each neighborhood. **) 
(** SUSPICIOUS DEFINITION: As above, this uses membership-based comparison on the index set; it is adequate for ordinal-indexed nets but may require extra axioms for arbitrary directed sets. **)
Definition net_converges : set -> set -> set -> set -> prop := fun X Tx net x =>
  exists J:set, topology_on X Tx /\ directed_set J /\ function_on net J X /\ x :e X /\
    forall U:set, U :e Tx -> x :e U ->
      exists i0:set, i0 :e J /\
        forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U.

(** helper: convergent nets have accumulation points at the limit **)
(** LATEX VERSION: If a net converges to x, then x is an accumulation point of the net. **)
Theorem net_converges_implies_accumulation_point : forall X Tx net x:set,
  net_converges X Tx net x -> accumulation_point_of_net X Tx net x.
let X Tx net x.
assume Hconv: net_converges X Tx net x.
prove accumulation_point_of_net X Tx net x.
apply Hconv.
let J.
assume HJ:
  topology_on X Tx /\ directed_set J /\ function_on net J X /\ x :e X /\
    forall U:set, U :e Tx -> x :e U ->
      exists i0:set, i0 :e J /\
        forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U.
prove accumulation_point_of_net X Tx net x.
prove exists J0:set, topology_on X Tx /\ directed_set J0 /\ function_on net J0 X /\ x :e X /\
  forall U:set, U :e Tx -> x :e U ->
    forall j0:set, j0 :e J0 ->
      exists j:set, j :e J0 /\ (j0 :e j \/ j0 = j) /\ apply_fun net j :e U.
witness J.
claim Hcore:
  topology_on X Tx /\ directed_set J /\ function_on net J X /\ x :e X.
{ exact (andEL (topology_on X Tx /\ directed_set J /\ function_on net J X /\ x :e X)
               (forall U:set, U :e Tx -> x :e U ->
                 exists i0:set, i0 :e J /\
                   forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U)
               HJ). }
claim Htail:
  forall U:set, U :e Tx -> x :e U ->
    exists i0:set, i0 :e J /\
      forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U.
{ exact (andER (topology_on X Tx /\ directed_set J /\ function_on net J X /\ x :e X)
               (forall U:set, U :e Tx -> x :e U ->
                 exists i0:set, i0 :e J /\
                   forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U)
               HJ). }
claim Htopdirfun:
  topology_on X Tx /\ directed_set J /\ function_on net J X.
{ exact (andEL (topology_on X Tx /\ directed_set J /\ function_on net J X)
               (x :e X)
               Hcore). }
claim HTd: topology_on X Tx /\ directed_set J.
{ exact (andEL (topology_on X Tx /\ directed_set J)
               (function_on net J X)
               Htopdirfun). }
claim HdirJ: directed_set J.
{ exact (andER (topology_on X Tx) (directed_set J) HTd). }
claim HfunJ: function_on net J X.
{ exact (andER (topology_on X Tx /\ directed_set J)
               (function_on net J X)
               Htopdirfun). }
claim HxX: x :e X.
{ exact (andER (topology_on X Tx /\ directed_set J /\ function_on net J X)
               (x :e X)
               Hcore). }
prove topology_on X Tx /\ directed_set J /\ function_on net J X /\ x :e X /\
  forall U:set, U :e Tx -> x :e U ->
    forall j0:set, j0 :e J ->
      exists j:set, j :e J /\ (j0 :e j \/ j0 = j) /\ apply_fun net j :e U.
apply andI.
- exact Hcore.
- let U.
  assume HU: U :e Tx.
  assume HxU: x :e U.
  prove forall j0:set, j0 :e J ->
    exists j:set, j :e J /\ (j0 :e j \/ j0 = j) /\ apply_fun net j :e U.
  let j0. assume Hj0: j0 :e J.
  claim Hexi0:
    exists i0:set, i0 :e J /\
      forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U.
  { exact (Htail U HU HxU). }
  apply Hexi0.
  let i0. assume Hi0pair.
  claim Hi0J: i0 :e J.
  { exact (andEL (i0 :e J)
                 (forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U)
                 Hi0pair). }
  claim Hi0tail:
    forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U.
  { exact (andER (i0 :e J)
                 (forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U)
                 Hi0pair). }
  claim Hexk: exists k:set, k :e J /\ (i0 :e k \/ i0 = k) /\ (j0 :e k \/ j0 = k).
  { exact (directed_set_pair_upper_bound J i0 j0 HdirJ Hi0J Hj0). }
  apply Hexk.
  let k. assume Hkpair.
  claim Hkleft: k :e J /\ (i0 :e k \/ i0 = k).
  { exact (andEL (k :e J /\ (i0 :e k \/ i0 = k))
                 (j0 :e k \/ j0 = k)
                 Hkpair). }
  claim HkJ: k :e J.
  { exact (andEL (k :e J) (i0 :e k \/ i0 = k) Hkleft). }
  claim Hi0k: i0 :e k \/ i0 = k.
  { exact (andER (k :e J) (i0 :e k \/ i0 = k) Hkleft). }
  claim Hj0k: j0 :e k \/ j0 = k.
  { exact (andER (k :e J /\ (i0 :e k \/ i0 = k))
                 (j0 :e k \/ j0 = k)
                 Hkpair). }
  witness k.
  prove (k :e J /\ (j0 :e k \/ j0 = k)) /\ apply_fun net k :e U.
  apply andI.
  - apply andI.
    + exact HkJ.
    + exact Hj0k.
  - exact (Hi0tail k HkJ Hi0k).
Qed.

(** helper: any convergent net is a net_on **)
(** LATEX VERSION: If a net converges, then it is a net (it has some directed index set). **)
Theorem net_converges_implies_net_on : forall X Tx net x:set,
  net_converges X Tx net x -> net_on net.
let X Tx net x.
assume H: net_converges X Tx net x.
prove net_on net.
apply H.
let J.
assume HJ: topology_on X Tx /\ directed_set J /\ function_on net J X /\ x :e X /\
  forall U:set, U :e Tx -> x :e U ->
    exists i0:set, i0 :e J /\
      forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U.
prove net_on net.
prove exists J0 X0:set, directed_set J0 /\ function_on net J0 X0.
witness J.
witness X.
claim HJJ: topology_on X Tx /\ directed_set J /\ function_on net J X /\ x :e X.
{ exact (andEL (topology_on X Tx /\ directed_set J /\ function_on net J X /\ x :e X)
               (forall U:set, U :e Tx -> x :e U ->
                 exists i0:set, i0 :e J /\
                   forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U)
               HJ). }
claim HJdirfun: topology_on X Tx /\ directed_set J /\ function_on net J X.
{ exact (andEL (topology_on X Tx /\ directed_set J /\ function_on net J X) (x :e X) HJJ). }
claim HJdir: topology_on X Tx /\ directed_set J.
{ exact (andEL (topology_on X Tx /\ directed_set J) (function_on net J X) HJdirfun). }
claim HdirJ: directed_set J.
{ exact (andER (topology_on X Tx) (directed_set J) HJdir). }
claim HfunJ: function_on net J X.
{ exact (andER (topology_on X Tx /\ directed_set J) (function_on net J X) HJdirfun). }
exact (andI (directed_set J) (function_on net J X) HdirJ HfunJ).
Qed.

(** from exercises after 29: convergence of subnets **) 
(** LATEX VERSION: Convergent nets have convergent subnets to same limit. **)
Theorem subnet_preserves_convergence : forall X Tx net sub x:set,
  net_converges X Tx net x -> subnet_of net sub -> net_converges X Tx sub x.
let X Tx net sub x.
assume Hnet: net_converges X Tx net x.
assume Hsub: subnet_of net sub.
prove net_converges X Tx sub x.
admit.
Qed.

(** helper: subnet preserves convergence for fixed index set witnesses **)
(** LATEX VERSION: If net converges along J and sub is obtained by a cofinal map phi:KJ, then sub converges. **)
Theorem subnet_preserves_convergence_witnessed :
  forall X Tx net sub x J K phi:set,
    topology_on X Tx ->
    directed_set J ->
    directed_set K ->
    function_on net J X ->
    function_on phi K J ->
    (forall j:set, j :e J -> exists k0:set, k0 :e K /\
      forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
        (j :e apply_fun phi k \/ j = apply_fun phi k)) ->
    (forall k:set, k :e K ->
      apply_fun sub k = apply_fun net (apply_fun phi k)) ->
    x :e X ->
    (forall U:set, U :e Tx -> x :e U ->
      exists j0:set, j0 :e J /\
        forall j:set, j :e J -> (j0 :e j \/ j0 = j) ->
          apply_fun net j :e U) ->
    net_converges X Tx sub x.
let X Tx net sub x J K phi.
assume HTx: topology_on X Tx.
assume HdirJ: directed_set J.
assume HdirK: directed_set K.
assume Hnetfun: function_on net J X.
assume Hphi: function_on phi K J.
assume Hcofinal:
  forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k).
assume Hsubeq:
  forall k:set, k :e K -> apply_fun sub k = apply_fun net (apply_fun phi k).
assume HxX: x :e X.
assume Htail:
  forall U:set, U :e Tx -> x :e U ->
    exists j0:set, j0 :e J /\
      forall j:set, j :e J -> (j0 :e j \/ j0 = j) ->
        apply_fun net j :e U.
prove net_converges X Tx sub x.
prove exists J0:set, topology_on X Tx /\ directed_set J0 /\ function_on sub J0 X /\ x :e X /\
  forall U:set, U :e Tx -> x :e U ->
    exists i0:set, i0 :e J0 /\
      forall i:set, i :e J0 -> (i0 :e i \/ i0 = i) -> apply_fun sub i :e U.
witness K.
apply andI.
- apply andI.
  * apply andI.
    { apply andI.
      - exact HTx.
      - exact HdirK. }
    { (** function_on sub K X **)
      let k. assume HkK: k :e K.
      prove apply_fun sub k :e X.
      claim Hsubk: apply_fun sub k = apply_fun net (apply_fun phi k).
      { exact (Hsubeq k HkK). }
      rewrite Hsubk.
      claim HphikJ: apply_fun phi k :e J.
      { exact (Hphi k HkK). }
      exact (Hnetfun (apply_fun phi k) HphikJ). }
  * exact HxX.
- let U.
  assume HU: U :e Tx.
  assume HxU: x :e U.
  prove exists i0:set, i0 :e K /\
    forall i:set, i :e K -> (i0 :e i \/ i0 = i) -> apply_fun sub i :e U.
  claim Hexj0:
    exists j0:set, j0 :e J /\
      forall j:set, j :e J -> (j0 :e j \/ j0 = j) -> apply_fun net j :e U.
  { exact (Htail U HU HxU). }
  apply Hexj0.
  let j0. assume Hj0pair.
  claim Hj0J: j0 :e J.
  { exact (andEL (j0 :e J)
                 (forall j:set, j :e J -> (j0 :e j \/ j0 = j) -> apply_fun net j :e U)
                 Hj0pair). }
  claim Hj0tail:
    forall j:set, j :e J -> (j0 :e j \/ j0 = j) -> apply_fun net j :e U.
  { exact (andER (j0 :e J)
                 (forall j:set, j :e J -> (j0 :e j \/ j0 = j) -> apply_fun net j :e U)
                 Hj0pair). }
  claim Hexk0:
    exists k0:set, k0 :e K /\
      forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
        (j0 :e apply_fun phi k \/ j0 = apply_fun phi k).
  { exact (Hcofinal j0 Hj0J). }
  apply Hexk0.
  let k0. assume Hk0pair.
  claim Hk0K: k0 :e K.
  { exact (andEL (k0 :e K)
                 (forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
                    (j0 :e apply_fun phi k \/ j0 = apply_fun phi k))
                 Hk0pair). }
  claim Hk0prop:
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j0 :e apply_fun phi k \/ j0 = apply_fun phi k).
  { exact (andER (k0 :e K)
                 (forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
                    (j0 :e apply_fun phi k \/ j0 = apply_fun phi k))
                 Hk0pair). }
  witness k0.
  apply andI.
  - exact Hk0K.
  - let k. assume HkK: k :e K.
    assume Hk0k: k0 :e k \/ k0 = k.
    prove apply_fun sub k :e U.
    claim Hj0phik: j0 :e apply_fun phi k \/ j0 = apply_fun phi k.
    { exact (Hk0prop k HkK Hk0k). }
    claim HphikJ: apply_fun phi k :e J.
    { exact (Hphi k HkK). }
    claim HnetU: apply_fun net (apply_fun phi k) :e U.
    { exact (Hj0tail (apply_fun phi k) HphikJ Hj0phik). }
    claim Hsubk: apply_fun sub k = apply_fun net (apply_fun phi k).
    { exact (Hsubeq k HkK). }
    rewrite Hsubk.
    exact HnetU.
Qed.

(** from exercises after 29: closure via nets **) 
(** LATEX VERSION: Closure characterized by existence of a convergent net. **)
Theorem closure_via_nets : forall X Tx A x:set,
  topology_on X Tx ->
  (x :e closure_of X Tx A <-> exists net:set, net_on net /\ net_converges X Tx net x).
let X Tx A x.
assume HTx: topology_on X Tx.
prove x :e closure_of X Tx A <-> exists net:set, net_on net /\ net_converges X Tx net x.
admit.
Qed.

(** from exercises after 29: continuity via nets **)
(** LATEX VERSION: Continuity iff every convergent net's image converges. **)
(** FIXED: continuity_via_nets uses net_converges Y Ty (compose_fun J net f) (apply_fun f x); old version used net itself and converged to Empty. **)
Theorem continuity_via_nets : forall X Tx Y Ty f:set,
  topology_on X Tx -> topology_on Y Ty ->
  (continuous_map X Tx Y Ty f <->
    forall J X0 net:set, directed_set J -> function_on net J X0 ->
      forall x:set, net_converges X Tx net x ->
        net_converges Y Ty (compose_fun J net f) (apply_fun f x)).
let X Tx Y Ty f.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove continuous_map X Tx Y Ty f <->
    forall J X0 net:set, directed_set J -> function_on net J X0 ->
      forall x:set, net_converges X Tx net x ->
        net_converges Y Ty (compose_fun J net f) (apply_fun f x).
admit.
Qed.

(** from exercises after 29: accumulation points and subnets **)
(** LATEX VERSION: Every accumulation point of a net has a subnet converging to it. **)
Theorem subnet_converges_to_accumulation : forall X Tx net x:set,
  accumulation_point_of_net X Tx net x -> exists sub:set, subnet_of net sub /\ net_converges X Tx sub x.
let X Tx net x.
assume Hacc: accumulation_point_of_net X Tx net x.
prove exists sub:set, subnet_of net sub /\ net_converges X Tx sub x.
admit.
Qed.

(** from exercises after 29: compactness via nets **) 
(** LATEX VERSION: Compactness characterized by every net having a convergent subnet. **)
Theorem compact_iff_every_net_has_convergent_subnet : forall X Tx:set,
  topology_on X Tx ->
  (compact_space X Tx <-> forall net:set, net_on net -> exists sub x:set, subnet_of net sub /\ net_converges X Tx sub x).
let X Tx.
assume HTx: topology_on X Tx.
prove compact_space X Tx <-> forall net:set, net_on net -> exists sub x:set, subnet_of net sub /\ net_converges X Tx sub x.
admit.
Qed.

(** from 30 Definition 30.1: countable basis at a point / first countable **) 
(** LATEX VERSION: Countable sets and related notions from 30 (countability axioms). **)
Definition countable_set : set -> prop := fun A => countable A.

(** LATEX VERSION: Countable subcollection V of U. **)
Definition countable_subcollection : set -> set -> prop := fun V U => V c= U /\ countable_set V.

(** LATEX VERSION: Countable index set. **)
Definition countable_index_set : set -> prop := fun I => countable_set I.

(** Helper for 30 Theorem 30.2: product topology from a cylinder subbasis. **)
(** LATEX VERSION: The product topology is generated by the cylinder subbasis. **)
Definition countable_product_topology_subbasis : set -> set -> set := fun I Xi =>
  generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi).

(** Helper: cylinder family is a subbasis on nonempty products. **)
Theorem product_subbasis_full_subbasis_on : forall I Xi:set,
  I <> Empty ->
  (forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i)) ->
  subbasis_on (product_space I Xi) (product_subbasis_full I Xi).
let I Xi.
assume HIne: I <> Empty.
assume HcompTop: forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i).
prove subbasis_on (product_space I Xi) (product_subbasis_full I Xi).
prove product_subbasis_full I Xi c= Power (product_space I Xi) /\ Union (product_subbasis_full I Xi) = product_space I Xi.
apply andI.
- (** product_subbasis_full I Xi c= Power (product_space I Xi) **)
  let s. assume Hs: s :e product_subbasis_full I Xi.
  prove s :e Power (product_space I Xi).
  apply PowerI.
  let f. assume Hf: f :e s.
  prove f :e product_space I Xi.
  set F := (fun i:set => {product_cylinder I Xi i U|U :e space_family_topology Xi i}).
  claim HsF: s :e (\/_ i :e I, F i).
  { exact Hs. }
  apply (famunionE_impred I F s HsF (f :e product_space I Xi)).
  let i.
  assume HiI: i :e I.
  assume HsFi: s :e F i.
  claim HexU: exists U :e space_family_topology Xi i, s = product_cylinder I Xi i U.
  { exact (ReplE (space_family_topology Xi i) (fun U0:set => product_cylinder I Xi i U0) s HsFi). }
  apply HexU.
  let U.
  assume HUand: U :e space_family_topology Xi i /\ s = product_cylinder I Xi i U.
  claim Hseq: s = product_cylinder I Xi i U.
  { exact (andER (U :e space_family_topology Xi i) (s = product_cylinder I Xi i U) HUand). }
  claim HfCyl: f :e product_cylinder I Xi i U.
  { rewrite <- Hseq. exact Hf. }
  exact (SepE1 (product_space I Xi)
               (fun f0:set => i :e I /\ U :e space_family_topology Xi i /\ apply_fun f0 i :e U)
               f HfCyl).
- (** Union (product_subbasis_full I Xi) = product_space I Xi **)
  apply set_ext.
  + let f. assume HfU: f :e Union (product_subbasis_full I Xi).
    prove f :e product_space I Xi.
    apply (UnionE_impred (product_subbasis_full I Xi) f HfU (f :e product_space I Xi)).
    let s. assume Hfs: f :e s. assume Hs: s :e product_subbasis_full I Xi.
    claim HsPow: s :e Power (product_space I Xi).
    { apply PowerI.
      let g. assume Hg: g :e s.
      prove g :e product_space I Xi.
      set F := (fun i:set => {product_cylinder I Xi i U|U :e space_family_topology Xi i}).
      claim HsF: s :e (\/_ i :e I, F i).
      { exact Hs. }
      apply (famunionE_impred I F s HsF (g :e product_space I Xi)).
      let i.
      assume HiI: i :e I.
      assume HsFi: s :e F i.
      claim HexU: exists U :e space_family_topology Xi i, s = product_cylinder I Xi i U.
      { exact (ReplE (space_family_topology Xi i) (fun U0:set => product_cylinder I Xi i U0) s HsFi). }
      apply HexU.
      let U.
      assume HUand: U :e space_family_topology Xi i /\ s = product_cylinder I Xi i U.
      claim Hseq: s = product_cylinder I Xi i U.
      { exact (andER (U :e space_family_topology Xi i) (s = product_cylinder I Xi i U) HUand). }
      claim HgCyl: g :e product_cylinder I Xi i U.
      { rewrite <- Hseq. exact Hg. }
      exact (SepE1 (product_space I Xi)
                   (fun f0:set => i :e I /\ U :e space_family_topology Xi i /\ apply_fun f0 i :e U)
                   g HgCyl).
    }
    exact (PowerE (product_space I Xi) s HsPow f Hfs).
  + let f. assume HfX: f :e product_space I Xi.
    prove f :e Union (product_subbasis_full I Xi).
    apply (xm (exists i:set, i :e I)).
    * assume Hexi: exists i:set, i :e I.
      apply Hexi.
      let i. assume HiI: i :e I.
      claim Htopi: topology_on (space_family_set Xi i) (space_family_topology Xi i).
      { exact (HcompTop i HiI). }
      claim Ht1: (((space_family_topology Xi i c= Power (space_family_set Xi i) /\ Empty :e space_family_topology Xi i) /\ space_family_set Xi i :e space_family_topology Xi i) /\ (forall UFam :e Power (space_family_topology Xi i), Union UFam :e space_family_topology Xi i)) /\ (forall U :e space_family_topology Xi i, forall V :e space_family_topology Xi i, U :/\: V :e space_family_topology Xi i).
      { exact Htopi. }
      claim Ht2: ((space_family_topology Xi i c= Power (space_family_set Xi i) /\ Empty :e space_family_topology Xi i) /\ space_family_set Xi i :e space_family_topology Xi i) /\ (forall UFam :e Power (space_family_topology Xi i), Union UFam :e space_family_topology Xi i).
      { exact (andEL (((space_family_topology Xi i c= Power (space_family_set Xi i) /\ Empty :e space_family_topology Xi i) /\ space_family_set Xi i :e space_family_topology Xi i) /\ (forall UFam :e Power (space_family_topology Xi i), Union UFam :e space_family_topology Xi i))
                     (forall U :e space_family_topology Xi i, forall V :e space_family_topology Xi i, U :/\: V :e space_family_topology Xi i)
                     Ht1). }
      claim Ht3: (space_family_topology Xi i c= Power (space_family_set Xi i) /\ Empty :e space_family_topology Xi i) /\ space_family_set Xi i :e space_family_topology Xi i.
      { exact (andEL ((space_family_topology Xi i c= Power (space_family_set Xi i) /\ Empty :e space_family_topology Xi i) /\ space_family_set Xi i :e space_family_topology Xi i)
                     (forall UFam :e Power (space_family_topology Xi i), Union UFam :e space_family_topology Xi i)
                     Ht2). }
      claim HUopen: space_family_set Xi i :e space_family_topology Xi i.
      { exact (andER (space_family_topology Xi i c= Power (space_family_set Xi i) /\ Empty :e space_family_topology Xi i)
                     (space_family_set Xi i :e space_family_topology Xi i)
                     Ht3). }
      set s := product_cylinder I Xi i (space_family_set Xi i).
      claim HsRepl: s :e {product_cylinder I Xi i U|U :e space_family_topology Xi i}.
      { exact (ReplI (space_family_topology Xi i) (fun U0:set => product_cylinder I Xi i U0)
                     (space_family_set Xi i) HUopen). }
      claim HsSub: s :e product_subbasis_full I Xi.
      { exact (famunionI I (fun i0:set => {product_cylinder I Xi i0 U|U :e space_family_topology Xi i0})
                       i s HiI HsRepl). }
      claim HfProp: function_on f I (space_family_union I Xi) /\ forall j:set, j :e I -> apply_fun f j :e space_family_set Xi j.
      { exact (SepE2 (Power (setprod I (space_family_union I Xi)))
                     (fun f0:set => function_on f0 I (space_family_union I Xi) /\ forall j:set, j :e I -> apply_fun f0 j :e space_family_set Xi j)
                     f HfX). }
      claim HfCoord: forall j:set, j :e I -> apply_fun f j :e space_family_set Xi j.
      { exact (andER (function_on f I (space_family_union I Xi))
                     (forall j:set, j :e I -> apply_fun f j :e space_family_set Xi j)
                     HfProp). }
      claim Hfi: apply_fun f i :e space_family_set Xi i.
      { exact (HfCoord i HiI). }
      claim HfInS: f :e s.
      { exact (SepI (product_space I Xi)
                    (fun f0:set => i :e I /\ space_family_set Xi i :e space_family_topology Xi i /\ apply_fun f0 i :e space_family_set Xi i)
                    f HfX
                    (andI (i :e I /\ space_family_set Xi i :e space_family_topology Xi i)
                          (apply_fun f i :e space_family_set Xi i)
                          (andI (i :e I) (space_family_set Xi i :e space_family_topology Xi i) HiI HUopen)
                          Hfi)). }
      exact (UnionI (product_subbasis_full I Xi) f s HfInS HsSub).
    * assume Hnex: ~(exists i:set, i :e I).
      prove f :e Union (product_subbasis_full I Xi).
      claim Hall: forall i:set, i /:e I.
      { let i. assume HiI: i :e I.
        prove False.
        apply Hnex.
        witness i.
        exact HiI. }
      claim HIeq: I = Empty.
      { exact (Empty_eq I Hall). }
      claim Hfalse: False.
      { apply HIne. exact HIeq. }
      exact (FalseE Hfalse (f :e Union (product_subbasis_full I Xi))).
Qed.

(** Helper: cartesian product with Empty is Empty. **)
Theorem setprod_Empty_left : forall Y:set, setprod Empty Y = Empty.
let Y.
apply set_ext.
- let p. assume Hp: p :e setprod Empty Y.
  prove p :e Empty.
  claim Hp0: (p 0) :e Empty.
  { exact (ap0_Sigma Empty (fun _:set => Y) p Hp). }
  exact (EmptyE (p 0) Hp0 (p :e Empty)).
- let p. assume Hp: p :e Empty.
  prove p :e setprod Empty Y.
  exact (EmptyE p Hp (p :e setprod Empty Y)).
Qed.

(** Helper: basis on X from the singleton {X}. **)
Theorem basis_on_singleton : forall X:set, basis_on X {X}.
let X.
prove {X} c= Power X
  /\ (forall x :e X, exists b :e {X}, x :e b)
  /\ (forall b1 :e {X}, forall b2 :e {X}, forall x:set,
        x :e b1 -> x :e b2 ->
        exists b3 :e {X}, x :e b3 /\ b3 c= b1 :/\: b2).
apply andI.
- apply andI.
  + (** {X} c= Power X **)
    let b. assume Hb: b :e {X}.
    prove b :e Power X.
    claim HbX: b = X.
    { exact (SingE X b Hb). }
    rewrite HbX.
    exact (Self_In_Power X).
  + (** covering property **)
    let x. assume HxX: x :e X.
    prove exists b :e {X}, x :e b.
    witness X.
    apply andI.
    * exact (SingI X).
    * exact HxX.
- (** intersection property **)
  let b1. assume Hb1: b1 :e {X}.
  let b2. assume Hb2: b2 :e {X}.
  let x. assume Hxb1: x :e b1. assume Hxb2: x :e b2.
  prove exists b3 :e {X}, x :e b3 /\ b3 c= b1 :/\: b2.
  claim Hb1X: b1 = X.
  { exact (SingE X b1 Hb1). }
  claim Hb2X: b2 = X.
  { exact (SingE X b2 Hb2). }
  witness X.
  apply andI.
  + exact (SingI X).
	  + prove x :e X /\ X c= b1 :/\: b2.
	    apply andI.
	    * rewrite <- Hb1X. exact Hxb1.
	    * let y. assume HyX: y :e X.
      prove y :e b1 :/\: b2.
      claim Hyb1: y :e b1.
      { rewrite Hb1X. exact HyX. }
      claim Hyb2: y :e b2.
      { rewrite Hb2X. exact HyX. }
      exact (binintersectI b1 b2 y Hyb1 Hyb2).
Qed.

(** Helper: the product space indexed by Empty has exactly the empty function. **)
Theorem product_space_empty_index : forall Xi:set, product_space Empty Xi = {Empty}.
let Xi.
apply set_ext.
- let f. assume Hf: f :e product_space Empty Xi.
  prove f :e {Empty}.
  claim HfPow: f :e Power (setprod Empty (space_family_union Empty Xi)).
  { exact (SepE1 (Power (setprod Empty (space_family_union Empty Xi)))
                 (fun f0:set => function_on f0 Empty (space_family_union Empty Xi) /\
                   forall i:set, i :e Empty -> apply_fun f0 i :e space_family_set Xi i)
                 f Hf). }
  claim Heqprod: setprod Empty (space_family_union Empty Xi) = Empty.
  { exact (setprod_Empty_left (space_family_union Empty Xi)). }
	  claim HfPowE: f :e Power Empty.
	  { rewrite <- Heqprod. exact HfPow. }
  claim Hsub: f c= Empty.
  { exact (PowerE Empty f HfPowE). }
  claim Hall: forall x:set, x /:e f.
  { let x. assume Hx: x :e f.
    prove False.
    claim HxE: x :e Empty.
    { exact (Hsub x Hx). }
    exact (EmptyE x HxE False). }
  claim HfEq: f = Empty.
  { exact (Empty_eq f Hall). }
  rewrite HfEq.
  exact (SingI Empty).
- let f. assume Hf: f :e {Empty}.
  prove f :e product_space Empty Xi.
  claim Hfeq: f = Empty.
  { exact (SingE Empty f Hf). }
  rewrite Hfeq.
  claim Hpow: Empty :e Power (setprod Empty (space_family_union Empty Xi)).
  { claim Heqprod: setprod Empty (space_family_union Empty Xi) = Empty.
    { exact (setprod_Empty_left (space_family_union Empty Xi)). }
    rewrite Heqprod.
    exact (Empty_In_Power Empty). }
  claim Hpred: function_on Empty Empty (space_family_union Empty Xi) /\
    forall i:set, i :e Empty -> apply_fun Empty i :e space_family_set Xi i.
  { apply andI.
    - let x. assume Hx: x :e Empty.
      prove apply_fun Empty x :e space_family_union Empty Xi.
      exact (EmptyE x Hx (apply_fun Empty x :e space_family_union Empty Xi)).
    - let i. assume Hi: i :e Empty.
      prove apply_fun Empty i :e space_family_set Xi i.
      exact (EmptyE i Hi (apply_fun Empty i :e space_family_set Xi i)). }
  exact (SepI (Power (setprod Empty (space_family_union Empty Xi)))
              (fun f0:set => function_on f0 Empty (space_family_union Empty Xi) /\
                forall i:set, i :e Empty -> apply_fun f0 i :e space_family_set Xi i)
              Empty Hpow Hpred).
Qed.

(** Helper: nonempty empty-subbasis gives singleton basis {X}. **)
Theorem basis_of_subbasis_empty_eq : forall X:set,
  X <> Empty ->
  basis_of_subbasis X Empty = {X}.
let X.
assume HXne: X <> Empty.
apply set_ext.
- let b. assume Hb: b :e basis_of_subbasis X Empty.
  prove b :e {X}.
  claim Hbfin: b :e finite_intersections_of X Empty.
  { exact (SepE1 (finite_intersections_of X Empty) (fun b0:set => b0 <> Empty) b Hb). }
  claim HexF: exists F :e finite_subcollections Empty, b = intersection_of_family X F.
  { exact (ReplE (finite_subcollections Empty) (fun F0:set => intersection_of_family X F0) b Hbfin). }
  apply HexF.
  let F. assume HFpair. apply HFpair.
  assume HF: F :e finite_subcollections Empty.
  assume Hbeq: b = intersection_of_family X F.
  claim HFpow: F :e Power Empty.
  { exact (SepE1 (Power Empty) (fun F0:set => finite F0) F HF). }
  claim HFsub: F c= Empty.
  { exact (PowerE Empty F HFpow). }
  claim Hall: forall x:set, x /:e F.
  { let x. assume Hx: x :e F.
    prove False.
    claim HxE: x :e Empty.
    { exact (HFsub x Hx). }
    exact (EmptyE x HxE False). }
  claim HFeq: F = Empty.
  { exact (Empty_eq F Hall). }
  claim HbX: b = X.
  { rewrite Hbeq.
    rewrite HFeq.
    exact (intersection_of_family_empty_eq X). }
  rewrite HbX.
  exact (SingI X).
- let b. assume Hb: b :e {X}.
  prove b :e basis_of_subbasis X Empty.
  claim HbX: b = X.
  { exact (SingE X b Hb). }
  rewrite HbX.
  claim HF: Empty :e finite_subcollections Empty.
  { exact (SepI (Power Empty) (fun F0:set => finite F0)
                Empty (Empty_In_Power Empty) finite_Empty). }
  claim Hfin: intersection_of_family X Empty :e finite_intersections_of X Empty.
  { exact (ReplI (finite_subcollections Empty) (fun F0:set => intersection_of_family X F0) Empty HF). }
  claim HXfin: X :e finite_intersections_of X Empty.
	{ claim Heq: X = intersection_of_family X Empty.
	  { rewrite (intersection_of_family_empty_eq X).
	    reflexivity. }
	  rewrite Heq at 1.
	  exact Hfin. }
  exact (SepI (finite_intersections_of X Empty) (fun b0:set => b0 <> Empty)
              X HXfin HXne).
Qed.

(** Helper for 30 Theorem 30.2: empty-index product topology is a topology. **)
(** LATEX VERSION: The empty product carries the topology generated by the empty cylinder family, which is a topology. **)
Theorem countable_product_topology_subbasis_empty_is_topology : forall Xi:set,
  topology_on (product_space Empty Xi) (countable_product_topology_subbasis Empty Xi).
let Xi.
prove topology_on (product_space Empty Xi) (countable_product_topology_subbasis Empty Xi).
claim HTdef: countable_product_topology_subbasis Empty Xi =
  generated_topology_from_subbasis (product_space Empty Xi) (product_subbasis_full Empty Xi).
{ reflexivity. }
rewrite HTdef.
				          claim HS0: product_subbasis_full Empty Xi = Empty.
				          { exact (famunion_Empty (fun i:set => {product_cylinder Empty Xi i U|U :e space_family_topology Xi i})). }
				          rewrite HS0.
				          claim HGTS0: generated_topology_from_subbasis (product_space Empty Xi) Empty =
				            generated_topology (product_space Empty Xi) (basis_of_subbasis (product_space Empty Xi) Empty).
				          { reflexivity. }
				          rewrite HGTS0.
				          claim HX0ne: product_space Empty Xi <> Empty.
				          { assume HX0E: product_space Empty Xi = Empty.
				            claim Hem: Empty :e product_space Empty Xi.
				            { rewrite (product_space_empty_index Xi).
    exact (SingI Empty). }
	  claim HemE: Empty :e Empty.
	  { rewrite <- HX0E at 2. exact Hem. }
	  exact (EmptyE Empty HemE False). }
claim HB0eq: basis_of_subbasis (product_space Empty Xi) Empty = {product_space Empty Xi}.
{ exact (basis_of_subbasis_empty_eq (product_space Empty Xi) HX0ne). }
claim HB0: basis_on (product_space Empty Xi) (basis_of_subbasis (product_space Empty Xi) Empty).
{ rewrite HB0eq.
  exact (basis_on_singleton (product_space Empty Xi)). }
exact (lemma_topology_from_basis (product_space Empty Xi) (basis_of_subbasis (product_space Empty Xi) Empty) HB0).
Qed.

(** Helper: power set of a natural has finite size **)
(** LATEX VERSION: For n in omega, Power n is equipotent to 2^n. **)
Theorem equip_Power_nat : forall n:set, nat_p n -> equip (Power n) (exp_nat 2 n).
let n.
assume Hn: nat_p n.
claim Hnn: equip n n.
{ exact (equip_ref n). }
exact (equip_finite_Power n Hn n Hnn).
Qed.

(** helper: image of countable set is countable **)
Theorem countable_image : forall X:set, countable_set X ->
  forall F:set->set, countable_set {F x|x :e X}.
let X.
assume HX: countable_set X.
let F.
prove countable_set {F x|x :e X}.
prove countable {F x|x :e X}.
prove atleastp {F x|x :e X} omega.
prove exists g : set->set, inj {F x|x :e X} omega g.
apply HX.
let h : set->set.
assume Hh: inj X omega h.
set pre : set->set := fun y => Eps_i (fun x => x :e X /\ y = F x).
set g : set->set := fun y => h (pre y).
witness g.
apply (injI {F x|x :e X} omega g).
- let y. assume Hy: y :e {F x|x :e X}.
  prove g y :e omega.
  apply (ReplE_impred X F y Hy).
  let x.
  assume HxX: x :e X.
  assume HyFx: y = F x.
  claim Hpreprop: pre y :e X /\ y = F (pre y).
  { exact (Eps_i_ax (fun x0 => x0 :e X /\ y = F x0) x (andI (x :e X) (y = F x) HxX HyFx)). }
  claim HpreX: pre y :e X.
  { exact (andEL (pre y :e X) (y = F (pre y)) Hpreprop). }
  claim Hhmap: forall u :e X, h u :e omega.
  { exact (andEL (forall u :e X, h u :e omega) (forall u v :e X, h u = h v -> u = v) Hh). }
  claim Hgy: g y = h (pre y).
  { reflexivity. }
  rewrite Hgy.
  exact (Hhmap (pre y) HpreX).
- let y1. assume Hy1: y1 :e {F x|x :e X}.
  let y2. assume Hy2: y2 :e {F x|x :e X}.
  assume Hg: g y1 = g y2.
  prove y1 = y2.
  claim Hhinj: forall u v :e X, h u = h v -> u = v.
  { exact (andER (forall u :e X, h u :e omega) (forall u v :e X, h u = h v -> u = v) Hh). }
  apply (ReplE_impred X F y1 Hy1).
  let x1.
  assume Hx1X: x1 :e X.
  assume Hy1Fx1: y1 = F x1.
  apply (ReplE_impred X F y2 Hy2).
  let x2.
  assume Hx2X: x2 :e X.
  assume Hy2Fx2: y2 = F x2.
  claim Hpre1: pre y1 :e X /\ y1 = F (pre y1).
  { exact (Eps_i_ax (fun x0 => x0 :e X /\ y1 = F x0) x1 (andI (x1 :e X) (y1 = F x1) Hx1X Hy1Fx1)). }
  claim Hpre2: pre y2 :e X /\ y2 = F (pre y2).
  { exact (Eps_i_ax (fun x0 => x0 :e X /\ y2 = F x0) x2 (andI (x2 :e X) (y2 = F x2) Hx2X Hy2Fx2)). }
  claim Hpre1X: pre y1 :e X.
  { exact (andEL (pre y1 :e X) (y1 = F (pre y1)) Hpre1). }
  claim Hpre2X: pre y2 :e X.
  { exact (andEL (pre y2 :e X) (y2 = F (pre y2)) Hpre2). }
  claim Hg1: g y1 = h (pre y1).
  { reflexivity. }
  claim Hg2: g y2 = h (pre y2).
  { reflexivity. }
  claim Heqh: h (pre y1) = h (pre y2).
  { rewrite <- Hg1. rewrite <- Hg2. exact Hg. }
  claim Heqpre: pre y1 = pre y2.
  { exact (Hhinj (pre y1) Hpre1X (pre y2) Hpre2X Heqh). }
  claim Hy1pre: y1 = F (pre y1).
  { exact (andER (pre y1 :e X) (y1 = F (pre y1)) Hpre1). }
  claim Hy2pre: y2 = F (pre y2).
  { exact (andER (pre y2 :e X) (y2 = F (pre y2)) Hpre2). }
  rewrite Hy1pre.
  rewrite Hy2pre.
  rewrite Heqpre.
  reflexivity.
Qed.

(** Helper: finite subsets of omega are countable as a family **)
(** LATEX VERSION: The collection of all finite subsets of omega is countable. **)
Theorem finite_subcollections_omega_countable : countable (finite_subcollections omega).
prove exists code : set -> set, inj (finite_subcollections omega) omega code.

(** Step 1: countability of Sigma_ n :e omega, Power n **)
set S := Sigma_ n :e omega, Power n.

claim Homega_countable: countable omega.
{ prove exists f : set -> set, inj omega omega f.
	  witness (fun n => n).
	  apply (injI omega omega (fun n => n)).
	  - let n. assume Hn: n :e omega.
	    prove (fun n0:set => n0) n :e omega.
	    exact Hn.
	  - let a. assume Ha: a :e omega.
	    let b. assume Hb: b :e omega.
	    assume Heq: (fun n0:set => n0) a = (fun n0:set => n0) b.
	    prove a = b.
	    exact Heq. }

claim Hpow_countable: forall n:set, n :e omega -> countable (Power n).
{ let n.
  assume Hn: n :e omega.
  prove countable (Power n).
  apply (finite_countable (Power n)).
  prove finite (Power n).
  prove exists m :e omega, equip (Power n) m.
  claim Hn_nat: nat_p n.
  { exact (omega_nat_p n Hn). }
  claim HequipPow: equip (Power n) (exp_nat 2 n).
  { exact (equip_Power_nat n Hn_nat). }
  claim Hpow_nat: nat_p (exp_nat 2 n).
  { exact (exp_nat_p 2 nat_2 n Hn_nat). }
  claim Hpow_omega: (exp_nat 2 n) :e omega.
  { exact (nat_p_omega (exp_nat 2 n) Hpow_nat). }
  witness (exp_nat 2 n).
  apply andI.
  - exact Hpow_omega.
  - exact HequipPow. }

claim HS_countable: countable S.
{ exact (Sigma_countable omega Homega_countable (fun n:set => Power n) Hpow_countable). }

(** Step 2: boundedness of finite subsets of omega **)
claim finite_sub_omega_bounded:
  forall F:set, F c= omega -> finite F -> exists n :e omega, forall m :e F, m :e n.
{ let F.
  assume HFsub: F c= omega.
  assume HFfin: finite F.
  claim Hp0: (Empty c= omega -> exists n :e omega, forall m :e Empty, m :e n).
  { assume Hsub0: Empty c= omega.
    prove exists n :e omega, forall m :e Empty, m :e n.
    witness 0.
    apply andI.
    - exact (nat_p_omega 0 nat_0).
    - let m. assume Hm: m :e Empty.
      apply FalseE.
      exact (EmptyE m Hm). }
  claim Hpstep: forall A y, finite A -> y /:e A ->
    (A c= omega -> exists n :e omega, forall m :e A, m :e n) ->
    (A :\/: {y} c= omega -> exists n0 :e omega, forall m:set, m :e A :\/: {y} -> m :e n0).
  { let A y.
    assume HAfin: finite A.
    assume HyA: y /:e A.
    assume HpA: (A c= omega -> exists n :e omega, forall m :e A, m :e n).
    assume HsubAy: A :\/: {y} c= omega.
    claim HsubA: A c= omega.
    { exact (Subq_tra A (A :\/: {y}) omega (binunion_Subq_1 A {y}) HsubAy). }
    claim Hexn: exists n :e omega, forall m :e A, m :e n.
    { exact (HpA HsubA). }
    apply Hexn.
    let n.
    assume Hnand.
    claim Hn: n :e omega.
    { exact (andEL (n :e omega) (forall m :e A, m :e n) Hnand). }
    claim Hnprop: forall m :e A, m :e n.
    { exact (andER (n :e omega) (forall m :e A, m :e n) Hnand). }
    prove exists n0 :e omega, forall m:set, m :e A :\/: {y} -> m :e n0.
    claim Hy_in_union: y :e A :\/: {y}.
    { apply binunionI2. exact (SingI y). }
    claim Hy_omega: y :e omega.
    { exact (HsubAy y Hy_in_union). }
    claim Hysucc_omega: ordsucc y :e omega.
    { exact (omega_ordsucc y Hy_omega). }
    claim Hn_union_omega: n :\/: ordsucc y :e omega.
    { exact (omega_binunion n (ordsucc y) Hn Hysucc_omega). }
    set n0 := ordsucc (n :\/: ordsucc y).
    claim Hn0_omega: n0 :e omega.
    { exact (omega_ordsucc (n :\/: ordsucc y) Hn_union_omega). }
    witness n0.
    apply andI.
    - exact Hn0_omega.
    - let m. assume Hm: m :e A :\/: {y}.
      prove m :e n0.
      apply (binunionE A {y} m Hm).
      + assume HmA: m :e A.
        claim Hmn: m :e n.
        { exact (Hnprop m HmA). }
        claim HmnU: m :e n :\/: ordsucc y.
        { exact (binunionI1 n (ordsucc y) m Hmn). }
        exact (ordsuccI1 (n :\/: ordsucc y) m HmnU).
      + assume HmY: m :e {y}.
        claim Hmy: m = y.
        { exact (SingE y m HmY). }
        rewrite Hmy.
        claim Hy_in_succ: y :e ordsucc y.
        { exact (ordsuccI2 y). }
        claim Hy_in_U: y :e n :\/: ordsucc y.
        { exact (binunionI2 n (ordsucc y) y Hy_in_succ). }
        exact (ordsuccI1 (n :\/: ordsucc y) y Hy_in_U). }
  claim HpF: (F c= omega -> exists n :e omega, forall m :e F, m :e n).
  { exact (finite_ind (fun A => A c= omega -> exists n :e omega, forall m :e A, m :e n)
                      Hp0 Hpstep F HFfin). }
  apply HpF.
  exact HFsub. }

(** Step 3: build an injection into S and compose with the countable injection of S **)
apply HS_countable.
let codeS : set -> set.
assume HcodeS: inj S omega codeS.
set bound : set -> set := fun F =>
  Eps_i (fun n => n :e omega /\ forall m:set, m :e F -> m :e n).
set emb : set -> set := fun F => (bound F, F).
set code : set -> set := fun F => codeS (emb F).
witness code.

apply (injI (finite_subcollections omega) omega code).
- let F.
  assume HF: F :e finite_subcollections omega.
  prove code F :e omega.
  claim HFpow: F :e Power omega.
  { exact (SepE1 (Power omega) (fun F0:set => finite F0) F HF). }
  claim HFsub: F c= omega.
  { exact (PowerE omega F HFpow). }
  claim HFfin: finite F.
  { exact (SepE2 (Power omega) (fun F0:set => finite F0) F HF). }
  claim Hexb: exists n :e omega, forall m :e F, m :e n.
  { exact (finite_sub_omega_bounded F HFsub HFfin). }
  claim Hboundprop: bound F :e omega /\ forall m:set, m :e F -> m :e bound F.
  { exact (Eps_i_ex (fun n => n :e omega /\ forall m:set, m :e F -> m :e n) Hexb). }
  claim Hbound_omega: bound F :e omega.
  { exact (andEL (bound F :e omega) (forall m:set, m :e F -> m :e bound F) Hboundprop). }
  claim Hbound_sub: forall m:set, m :e F -> m :e bound F.
  { exact (andER (bound F :e omega) (forall m:set, m :e F -> m :e bound F) Hboundprop). }
  claim HFpowB: F :e Power (bound F).
  { claim Hsub: F c= bound F.
    { let m. assume Hm: m :e F.
      exact (Hbound_sub m Hm). }
    exact (PowerI (bound F) F Hsub). }
  claim HembS: emb F :e S.
  { exact (tuple_2_Sigma omega (fun n:set => Power n) (bound F) Hbound_omega F HFpowB). }
  claim Hmap: forall u :e S, codeS u :e omega.
  { exact (andEL (forall u :e S, codeS u :e omega)
                 (forall u v :e S, codeS u = codeS v -> u = v)
                 HcodeS). }
  claim Hdef: code F = codeS (emb F).
  { reflexivity. }
  rewrite Hdef.
  exact (Hmap (emb F) HembS).
- let F1.
  assume HF1: F1 :e finite_subcollections omega.
  let F2.
  assume HF2: F2 :e finite_subcollections omega.
  assume Heq: code F1 = code F2.
  prove F1 = F2.
  claim HF1pow: F1 :e Power omega.
  { exact (SepE1 (Power omega) (fun F0:set => finite F0) F1 HF1). }
  claim HF2pow: F2 :e Power omega.
  { exact (SepE1 (Power omega) (fun F0:set => finite F0) F2 HF2). }
  claim HF1sub: F1 c= omega.
  { exact (PowerE omega F1 HF1pow). }
  claim HF2sub: F2 c= omega.
  { exact (PowerE omega F2 HF2pow). }
  claim HF1fin: finite F1.
  { exact (SepE2 (Power omega) (fun F0:set => finite F0) F1 HF1). }
  claim HF2fin: finite F2.
  { exact (SepE2 (Power omega) (fun F0:set => finite F0) F2 HF2). }
  claim Hexb1: exists n :e omega, forall m :e F1, m :e n.
  { exact (finite_sub_omega_bounded F1 HF1sub HF1fin). }
  claim Hexb2: exists n :e omega, forall m :e F2, m :e n.
  { exact (finite_sub_omega_bounded F2 HF2sub HF2fin). }
  claim Hb1: bound F1 :e omega /\ forall m:set, m :e F1 -> m :e bound F1.
  { exact (Eps_i_ex (fun n => n :e omega /\ forall m:set, m :e F1 -> m :e n) Hexb1). }
  claim Hb2: bound F2 :e omega /\ forall m:set, m :e F2 -> m :e bound F2.
  { exact (Eps_i_ex (fun n => n :e omega /\ forall m:set, m :e F2 -> m :e n) Hexb2). }
  claim Hbound1: bound F1 :e omega.
  { exact (andEL (bound F1 :e omega) (forall m:set, m :e F1 -> m :e bound F1) Hb1). }
  claim Hbound2: bound F2 :e omega.
  { exact (andEL (bound F2 :e omega) (forall m:set, m :e F2 -> m :e bound F2) Hb2). }
  claim HF1powB: F1 :e Power (bound F1).
  { claim Hsub: F1 c= bound F1.
    { let m. assume Hm: m :e F1.
      claim Hsubm: forall m0:set, m0 :e F1 -> m0 :e bound F1.
      { exact (andER (bound F1 :e omega) (forall m0:set, m0 :e F1 -> m0 :e bound F1) Hb1). }
      exact (Hsubm m Hm). }
    exact (PowerI (bound F1) F1 Hsub). }
  claim HF2powB: F2 :e Power (bound F2).
  { claim Hsub: F2 c= bound F2.
    { let m. assume Hm: m :e F2.
      claim Hsubm: forall m0:set, m0 :e F2 -> m0 :e bound F2.
      { exact (andER (bound F2 :e omega) (forall m0:set, m0 :e F2 -> m0 :e bound F2) Hb2). }
      exact (Hsubm m Hm). }
    exact (PowerI (bound F2) F2 Hsub). }
  claim Hemb1: emb F1 :e S.
  { exact (tuple_2_Sigma omega (fun n:set => Power n) (bound F1) Hbound1 F1 HF1powB). }
  claim Hemb2: emb F2 :e S.
  { exact (tuple_2_Sigma omega (fun n:set => Power n) (bound F2) Hbound2 F2 HF2powB). }
  claim Hcodeinj: forall u v :e S, codeS u = codeS v -> u = v.
  { exact (andER (forall u :e S, codeS u :e omega)
                 (forall u v :e S, codeS u = codeS v -> u = v)
                 HcodeS). }
  claim Hdef1: code F1 = codeS (emb F1).
  { reflexivity. }
  claim Hdef2: code F2 = codeS (emb F2).
  { reflexivity. }
  claim HeqS: codeS (emb F1) = codeS (emb F2).
  { rewrite <- Hdef1.
    rewrite <- Hdef2.
    exact Heq. }
  claim HembEq: emb F1 = emb F2.
  { exact (Hcodeinj (emb F1) Hemb1 (emb F2) Hemb2 HeqS). }
  claim HF1Eq: F1 = F2.
  { claim Hemb1def: emb F1 = (bound F1, F1).
    { reflexivity. }
    claim Hemb2def: emb F2 = (bound F2, F2).
    { reflexivity. }
    claim Hproj1: (emb F1) 1 = F1.
    { rewrite Hemb1def.
      exact (tuple_2_1_eq (bound F1) F1). }
    claim Hproj2: (emb F2) 1 = F2.
    { rewrite Hemb2def.
      exact (tuple_2_1_eq (bound F2) F2). }
    claim HapEq: (emb F1) 1 = (emb F2) 1.
    { rewrite HembEq.
      reflexivity. }
    rewrite <- Hproj1.
    rewrite <- Hproj2.
    exact HapEq. }
  exact HF1Eq.
Qed.

(** Helper: finite subcollections of a countable set are countable **)
(** LATEX VERSION: The set of all finite subcollections of a countable set is countable. **)
Theorem finite_subcollections_countable : forall S:set,
  countable_set S -> countable_set (finite_subcollections S).
let S. assume HS: countable_set S.
prove countable_set (finite_subcollections S).
prove countable (finite_subcollections S).
prove exists h : set -> set, inj (finite_subcollections S) omega h.
apply HS.
let f : set -> set.
assume Hf: inj S omega f.
(** It is standard that the family of finite subsets of omega is countable. **)
claim HFinOmega: countable (finite_subcollections omega).
{ exact finite_subcollections_omega_countable. }
apply HFinOmega.
let code : set -> set.
assume Hcode: inj (finite_subcollections omega) omega code.
set ImgF : set -> set := fun F => {f x|x :e F}.
set h : set -> set := fun F => code (ImgF F).
witness h.
apply (injI (finite_subcollections S) omega h).
- let F. assume HF: F :e finite_subcollections S.
  prove h F :e omega.
  claim HFpow: F :e Power S.
  { exact (SepE1 (Power S) (fun F0:set => finite F0) F HF). }
  claim HFfin: finite F.
  { exact (SepE2 (Power S) (fun F0:set => finite F0) F HF). }
  claim Hfmap: forall a :e S, f a :e omega.
  { exact (andEL (forall a :e S, f a :e omega)
                 (forall a b :e S, f a = f b -> a = b)
                 Hf). }
  claim HImgPow: ImgF F :e Power omega.
  { exact (image_In_Power S omega f Hfmap F HFpow). }
  claim HImgFin: finite (ImgF F).
  { exact (Repl_finite f F HFfin). }
  claim HImg: ImgF F :e finite_subcollections omega.
  { exact (SepI (Power omega) (fun F0:set => finite F0) (ImgF F) HImgPow HImgFin). }
  claim Hcodemap: forall u :e finite_subcollections omega, code u :e omega.
  { exact (andEL (forall u :e finite_subcollections omega, code u :e omega)
                 (forall u v :e finite_subcollections omega, code u = code v -> u = v)
                 Hcode). }
  claim Hhdef: h F = code (ImgF F).
  { reflexivity. }
  rewrite Hhdef.
  exact (Hcodemap (ImgF F) HImg).
- let F1. assume HF1: F1 :e finite_subcollections S.
  let F2. assume HF2: F2 :e finite_subcollections S.
  assume Heq: h F1 = h F2.
  prove F1 = F2.
  claim HF1pow: F1 :e Power S.
  { exact (SepE1 (Power S) (fun F0:set => finite F0) F1 HF1). }
  claim HF2pow: F2 :e Power S.
  { exact (SepE1 (Power S) (fun F0:set => finite F0) F2 HF2). }
  claim HF1sub: F1 c= S.
  { exact (PowerE S F1 HF1pow). }
  claim HF2sub: F2 c= S.
  { exact (PowerE S F2 HF2pow). }
  claim Hf_inj: forall a b :e S, f a = f b -> a = b.
  { exact (andER (forall a :e S, f a :e omega)
                 (forall a b :e S, f a = f b -> a = b)
                 Hf). }
  claim Hfmap: forall a :e S, f a :e omega.
  { exact (andEL (forall a :e S, f a :e omega)
                 (forall a b :e S, f a = f b -> a = b)
                 Hf). }
  claim HImg1: ImgF F1 :e finite_subcollections omega.
  { claim HF1fin: finite F1.
    { exact (SepE2 (Power S) (fun F0:set => finite F0) F1 HF1). }
    claim HImgPow: ImgF F1 :e Power omega.
    { exact (image_In_Power S omega f Hfmap F1 HF1pow). }
    claim HImgFin: finite (ImgF F1).
    { exact (Repl_finite f F1 HF1fin). }
    exact (SepI (Power omega) (fun F0:set => finite F0) (ImgF F1) HImgPow HImgFin). }
  claim HImg2: ImgF F2 :e finite_subcollections omega.
  { claim HF2fin: finite F2.
    { exact (SepE2 (Power S) (fun F0:set => finite F0) F2 HF2). }
    claim HImgPow: ImgF F2 :e Power omega.
    { exact (image_In_Power S omega f Hfmap F2 HF2pow). }
    claim HImgFin: finite (ImgF F2).
    { exact (Repl_finite f F2 HF2fin). }
    exact (SepI (Power omega) (fun F0:set => finite F0) (ImgF F2) HImgPow HImgFin). }
  claim Hcodeinj: forall u v :e finite_subcollections omega, code u = code v -> u = v.
  { exact (andER (forall u :e finite_subcollections omega, code u :e omega)
                 (forall u v :e finite_subcollections omega, code u = code v -> u = v)
                 Hcode). }
  claim Hhdef1: h F1 = code (ImgF F1).
  { reflexivity. }
  claim Hhdef2: h F2 = code (ImgF F2).
  { reflexivity. }
  claim HeqImg: ImgF F1 = ImgF F2.
  { apply (Hcodeinj (ImgF F1) HImg1 (ImgF F2) HImg2).
    claim Hcodeeq: code (ImgF F1) = code (ImgF F2).
    { claim Hc1: code (ImgF F1) = h F1.
      { symmetry. exact Hhdef1. }
      claim Hc2: h F2 = code (ImgF F2).
      { exact Hhdef2. }
      claim Hmid: code (ImgF F1) = h F2.
      { exact (eq_i_tra (code (ImgF F1)) (h F1) (h F2) Hc1 Heq). }
      exact (eq_i_tra (code (ImgF F1)) (h F2) (code (ImgF F2)) Hmid Hc2). }
    exact Hcodeeq. }
  apply set_ext.
  + let x. assume Hx1: x :e F1.
    prove x :e F2.
    claim HxS: x :e S.
    { exact (HF1sub x Hx1). }
    claim Hfx1: f x :e ImgF F1.
    { exact (ReplI F1 f x Hx1). }
    claim Hfx2: f x :e ImgF F2.
    { rewrite <- HeqImg. exact Hfx1. }
    apply (ReplE_impred F2 f (f x) Hfx2).
    let y. assume Hy2: y :e F2.
    assume Hfxy: f x = f y.
    claim HyS: y :e S.
    { exact (HF2sub y Hy2). }
    claim Heqxy: x = y.
    { exact (Hf_inj x HxS y HyS Hfxy). }
    rewrite Heqxy.
    exact Hy2.
  + let x. assume Hx2: x :e F2.
    prove x :e F1.
    claim HxS: x :e S.
    { exact (HF2sub x Hx2). }
    claim Hfx2: f x :e ImgF F2.
    { exact (ReplI F2 f x Hx2). }
    claim Hfx1: f x :e ImgF F1.
    { rewrite HeqImg. exact Hfx2. }
    apply (ReplE_impred F1 f (f x) Hfx1).
    let y. assume Hy1: y :e F1.
    assume Hfxy: f x = f y.
    claim HyS: y :e S.
    { exact (HF1sub y Hy1). }
    claim Heqxy: x = y.
    { exact (Hf_inj x HxS y HyS Hfxy). }
    rewrite Heqxy.
    exact Hy1.
Qed.

(** Helper: finite intersections of a countable family form a countable family **)
(** LATEX VERSION: The family of finite intersections of members of a countable family is countable. **)
Theorem finite_intersections_of_countable : forall X S:set,
  countable_set S -> countable_set (finite_intersections_of X S).
let X S. assume HS: countable_set S.
prove countable_set (finite_intersections_of X S).
set FS := finite_subcollections S.
claim HFS: countable_set FS.
{ exact (finite_subcollections_countable S HS). }
exact (countable_image FS HFS (fun F0:set => intersection_of_family X F0)).
Qed.

(** Helper: the basis from a countable subbasis is countable **)
(** LATEX VERSION: If a subbasis is countable, then the associated basis of nonempty finite intersections is countable. **)
Theorem basis_of_subbasis_countable : forall X S:set,
  countable_set S -> countable_set (basis_of_subbasis X S).
let X S. assume HS: countable_set S.
prove countable_set (basis_of_subbasis X S).
claim Hfin: countable_set (finite_intersections_of X S).
{ exact (finite_intersections_of_countable X S HS). }
prove countable (basis_of_subbasis X S).
apply (Subq_countable (basis_of_subbasis X S) (finite_intersections_of X S)).
- exact Hfin.
- let b. assume Hb: b :e basis_of_subbasis X S.
  prove b :e finite_intersections_of X S.
  exact (SepE1 (finite_intersections_of X S) (fun b0:set => b0 <> Empty) b Hb).
Qed.
(** LATEX VERSION: Real sequences and uniform metric/topology on R^ (setup). **)
(** FIXED: real_sequences is setexp R omega (functions omega -> R), not Power R; uses setexp from TRUSTED_DEFS.txt. **)
Definition real_sequences : set := setexp R omega.
Definition uniform_metric_Romega : set := Eps_i (fun d => metric_on real_sequences d).
Definition uniform_topology : set := metric_topology real_sequences uniform_metric_Romega.
(** LATEX VERSION: Open cover and Lindelf space definitions. **)
Definition open_cover : set -> set -> set -> prop :=
  fun X Tx U => (forall u:set, u :e U -> u :e Tx) /\ covers X U.
Definition Lindelof_space : set -> set -> prop :=
  fun X Tx => topology_on X Tx /\ forall U:set, open_cover X Tx U -> exists V:set, countable_subcollection V U /\ covers X V.
(** LATEX VERSION: Sorgenfrey line and its lower limit topology. **)
Definition Sorgenfrey_line : set := R.
Definition Sorgenfrey_topology : set := R_lower_limit_topology.


(** LATEX VERSION: Countable basis at x (Definition 30.1). **)
(** FIXED: countable_basis_at uses a countable local basis B c= Tx at x, not a global basis_on X B; avoids collapsing first countable into second countable. **)
Definition countable_basis_at : set -> set -> set -> prop := fun X Tx x =>
  topology_on X Tx /\ x :e X /\
  exists B:set, B c= Tx /\ countable_set B /\
    (forall b:set, b :e B -> x :e b) /\
    (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e B /\ b c= U).

(** from 30 Definition 30.1: first-countable space **) 
(** LATEX VERSION: First countable means each point has a countable neighborhood basis. **)
Definition first_countable_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\ forall x:set, x :e X -> countable_basis_at X Tx x.

(** helper: countable local basis at a point in a nonempty countable product of first-countable spaces **)
(** LATEX VERSION: The usual product argument produces a countable neighborhood basis at a point. **)
Theorem product_countable_basis_at_point_if_components_first_countable : forall I Xi f:set,
  countable_index_set I ->
  I <> Empty ->
  (forall i:set, i :e I -> first_countable_space (space_family_set Xi i) (space_family_topology Xi i)) ->
  f :e product_space I Xi ->
  countable_basis_at (product_space I Xi) (countable_product_topology_subbasis I Xi) f.
let I Xi f.
assume HIcount.
assume HIn0.
assume Hcomp.
assume Hf.
prove countable_basis_at (product_space I Xi) (countable_product_topology_subbasis I Xi) f.
set X := product_space I Xi.
set Tx := countable_product_topology_subbasis I Xi.
set Sfull := product_subbasis_full I Xi.
claim Hfprop: function_on f I (space_family_union I Xi) /\ forall i:set, i :e I -> apply_fun f i :e space_family_set Xi i.
{ exact (SepE2 (Power (setprod I (space_family_union I Xi)))
               (fun f0:set => function_on f0 I (space_family_union I Xi) /\
                 forall i:set, i :e I -> apply_fun f0 i :e space_family_set Xi i)
               f
               Hf). }
claim Hcompf: forall i:set, i :e I -> apply_fun f i :e space_family_set Xi i.
{ exact (andER (function_on f I (space_family_union I Xi))
               (forall i:set, i :e I -> apply_fun f i :e space_family_set Xi i)
               Hfprop). }
claim HcompTop: forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i).
{ let i. assume HiI: i :e I.
  exact (andEL (topology_on (space_family_set Xi i) (space_family_topology Xi i))
               (forall x:set, x :e space_family_set Xi i -> countable_basis_at (space_family_set Xi i) (space_family_topology Xi i) x)
               (Hcomp i HiI)). }
claim HSfull: subbasis_on X Sfull.
{ exact (product_subbasis_full_subbasis_on I Xi HIn0 HcompTop). }
claim HBasisFull: basis_on X (basis_of_subbasis X Sfull).
{ exact (finite_intersections_basis_of_subbasis X Sfull HSfull). }
claim HTprod: topology_on X Tx.
{ claim HTdef: Tx = generated_topology_from_subbasis X Sfull.
  { reflexivity. }
  rewrite HTdef.
  exact (topology_from_subbasis_is_topology X Sfull HSfull). }

set Bsel : set -> set := fun i =>
  Eps_i (fun B0:set =>
    B0 c= space_family_topology Xi i /\ countable_set B0 /\
      (forall b:set, b :e B0 -> apply_fun f i :e b) /\
      (forall U:set, U :e space_family_topology Xi i -> apply_fun f i :e U -> exists b:set, b :e B0 /\ b c= U)).

claim HBsel: forall i:set, i :e I ->
  (Bsel i) c= space_family_topology Xi i /\ countable_set (Bsel i) /\
    (forall b:set, b :e (Bsel i) -> apply_fun f i :e b) /\
    (forall U:set, U :e space_family_topology Xi i -> apply_fun f i :e U -> exists b:set, b :e (Bsel i) /\ b c= U).
{ let i. assume HiI: i :e I.
  claim Hfc_i: first_countable_space (space_family_set Xi i) (space_family_topology Xi i).
  { exact (Hcomp i HiI). }
  claim Hcb_all: forall x:set, x :e space_family_set Xi i ->
    countable_basis_at (space_family_set Xi i) (space_family_topology Xi i) x.
  { exact (andER (topology_on (space_family_set Xi i) (space_family_topology Xi i))
                 (forall x:set, x :e space_family_set Xi i -> countable_basis_at (space_family_set Xi i) (space_family_topology Xi i) x)
                 Hfc_i). }
  claim Hfi: apply_fun f i :e space_family_set Xi i.
  { exact (Hcompf i HiI). }
  claim Hcbi: countable_basis_at (space_family_set Xi i) (space_family_topology Xi i) (apply_fun f i).
  { exact (Hcb_all (apply_fun f i) Hfi). }
  claim HexB0: exists B0:set,
    B0 c= space_family_topology Xi i /\ countable_set B0 /\
      (forall b:set, b :e B0 -> apply_fun f i :e b) /\
      (forall U:set, U :e space_family_topology Xi i -> apply_fun f i :e U -> exists b:set, b :e B0 /\ b c= U).
  { exact (andER (topology_on (space_family_set Xi i) (space_family_topology Xi i) /\ apply_fun f i :e space_family_set Xi i)
                 (exists B0:set,
                   B0 c= space_family_topology Xi i /\ countable_set B0 /\
                     (forall b:set, b :e B0 -> apply_fun f i :e b) /\
                     (forall U:set, U :e space_family_topology Xi i -> apply_fun f i :e U -> exists b:set, b :e B0 /\ b c= U))
                 Hcbi). }
  apply HexB0.
  let B0. assume HB0.
  exact (Eps_i_ax (fun B1:set =>
      B1 c= space_family_topology Xi i /\ countable_set B1 /\
        (forall b:set, b :e B1 -> apply_fun f i :e b) /\
        (forall U:set, U :e space_family_topology Xi i -> apply_fun f i :e U -> exists b:set, b :e B1 /\ b c= U))
    B0 HB0). }

set Ssmall : set := \/_ i :e I, {product_cylinder I Xi i U|U :e Bsel i}.
set FSsmall := finite_subcollections Ssmall.
set B : set := {intersection_of_family X F0|F0 :e FSsmall}.

claim HSsmall_count: countable_set Ssmall.
{ claim HIc: countable I.
  { exact HIcount. }
  claim HBsel_count: forall i:set, i :e I -> countable (Bsel i).
  { let i. assume HiI: i :e I.
    claim HBi: (Bsel i) c= space_family_topology Xi i /\ countable_set (Bsel i) /\
      (forall b:set, b :e (Bsel i) -> apply_fun f i :e b) /\
      (forall U:set, U :e space_family_topology Xi i -> apply_fun f i :e U -> exists b:set, b :e (Bsel i) /\ b c= U).
    { exact (HBsel i HiI). }
    claim Hcore: ((Bsel i) c= space_family_topology Xi i /\ countable_set (Bsel i)) /\
      (forall b:set, b :e (Bsel i) -> apply_fun f i :e b).
    { exact (andEL (((Bsel i) c= space_family_topology Xi i /\ countable_set (Bsel i)) /\
                    (forall b:set, b :e (Bsel i) -> apply_fun f i :e b))
                   (forall U:set, U :e space_family_topology Xi i -> apply_fun f i :e U -> exists b:set, b :e (Bsel i) /\ b c= U)
                   HBi). }
    claim Hpair: (Bsel i) c= space_family_topology Xi i /\ countable_set (Bsel i).
    { exact (andEL ((Bsel i) c= space_family_topology Xi i /\ countable_set (Bsel i))
                   (forall b:set, b :e (Bsel i) -> apply_fun f i :e b)
                   Hcore). }
    exact (andER ((Bsel i) c= space_family_topology Xi i) (countable_set (Bsel i)) Hpair). }
  claim HSig: countable (Sigma_ i :e I, Bsel i).
  { exact (Sigma_countable I HIc Bsel HBsel_count). }
  claim HSig_set: countable_set (Sigma_ i :e I, Bsel i).
  { exact HSig. }
  set F : set -> set := fun p => product_cylinder I Xi (p 0) (p 1).
  set Img := {F p|p :e Sigma_ i :e I, Bsel i}.
  claim HImg_count: countable_set Img.
  { exact (countable_image (Sigma_ i :e I, Bsel i) HSig_set F). }
  apply (Subq_countable Ssmall Img).
  - exact HImg_count.
  - let s. assume Hs: s :e Ssmall.
    prove s :e Img.
    apply (famunionE_impred I (fun i0:set => {product_cylinder I Xi i0 U|U :e Bsel i0}) s Hs).
    let i0. assume Hi0I: i0 :e I.
    assume HsFi0: s :e {product_cylinder I Xi i0 U|U :e Bsel i0}.
    apply (ReplE_impred (Bsel i0) (fun U0:set => product_cylinder I Xi i0 U0) s HsFi0).
    let U0. assume HU0B: U0 :e Bsel i0.
    assume HsEq: s = product_cylinder I Xi i0 U0.
    claim HpSig: (i0,U0) :e Sigma_ i :e I, Bsel i.
    { exact (tuple_2_Sigma I Bsel i0 Hi0I U0 HU0B). }
    claim HFp: F (i0,U0) = product_cylinder I Xi i0 U0.
    { claim HFdef: F (i0,U0) = product_cylinder I Xi ((i0,U0) 0) ((i0,U0) 1).
      { reflexivity. }
      rewrite HFdef.
      rewrite (tuple_2_0_eq i0 U0).
      rewrite (tuple_2_1_eq i0 U0).
      reflexivity. }
    rewrite HsEq.
    rewrite <- HFp.
    exact (ReplI (Sigma_ i :e I, Bsel i) F (i0,U0) HpSig). }

claim HFSsmall: countable_set FSsmall.
{ exact (finite_subcollections_countable Ssmall HSsmall_count). }
claim HBcount: countable_set B.
{ exact (countable_image FSsmall HFSsmall (fun F0:set => intersection_of_family X F0)). }

claim HSsmall_in_Tx: forall s:set, s :e Ssmall -> s :e Tx.
{ let s. assume Hs: s :e Ssmall.
  apply (famunionE_impred I (fun i0:set => {product_cylinder I Xi i0 U|U :e Bsel i0}) s Hs).
  let i0. assume Hi0I: i0 :e I.
  assume HsFi0: s :e {product_cylinder I Xi i0 U|U :e Bsel i0}.
  apply (ReplE_impred (Bsel i0) (fun U0:set => product_cylinder I Xi i0 U0) s HsFi0).
  let U0. assume HU0B: U0 :e Bsel i0.
  assume HsEq: s = product_cylinder I Xi i0 U0.
  claim HBU0: (Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0) /\
    (forall b:set, b :e (Bsel i0) -> apply_fun f i0 :e b) /\
    (forall V:set, V :e space_family_topology Xi i0 -> apply_fun f i0 :e V -> exists b:set, b :e (Bsel i0) /\ b c= V).
  { exact (HBsel i0 Hi0I). }
  claim Hcore: ((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0)) /\
    (forall b:set, b :e (Bsel i0) -> apply_fun f i0 :e b).
  { exact (andEL (((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0)) /\
                  (forall b:set, b :e (Bsel i0) -> apply_fun f i0 :e b))
                 (forall V:set, V :e space_family_topology Xi i0 -> apply_fun f i0 :e V -> exists b:set, b :e (Bsel i0) /\ b c= V)
                 HBU0). }
  claim HsubTop: (Bsel i0) c= space_family_topology Xi i0.
  { exact (andEL ((Bsel i0) c= space_family_topology Xi i0)
                 (countable_set (Bsel i0))
                 (andEL ((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0))
                        (forall b:set, b :e (Bsel i0) -> apply_fun f i0 :e b)
                        Hcore)). }
  claim HU0Top: U0 :e space_family_topology Xi i0.
  { exact (HsubTop U0 HU0B). }
  set cyl := product_cylinder I Xi i0 U0.
  claim HcylSfull: cyl :e Sfull.
  { exact (famunionI I (fun i1:set => {product_cylinder I Xi i1 U|U :e space_family_topology Xi i1})
                   i0 cyl Hi0I (ReplI (space_family_topology Xi i0) (fun U:set => product_cylinder I Xi i0 U) U0 HU0Top)). }
  claim HfiU0: apply_fun f i0 :e U0.
  { exact ((andER ((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0))
                  (forall b:set, b :e (Bsel i0) -> apply_fun f i0 :e b)
                  Hcore) U0 HU0B). }
  claim HfCyl: f :e cyl.
  { exact (SepI X (fun f0:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f0 i0 :e U0)
               f Hf (andI (i0 :e I /\ U0 :e space_family_topology Xi i0) (apply_fun f i0 :e U0)
                        (andI (i0 :e I) (U0 :e space_family_topology Xi i0) Hi0I HU0Top) HfiU0)). }
  claim HcylNe: cyl <> Empty.
  { assume HCeq: cyl = Empty.
    claim HfEmp: f :e Empty.
    { rewrite <- HCeq. exact HfCyl. }
    exact (EmptyE f HfEmp False). }
  claim HcylInBasis: cyl :e basis_of_subbasis X Sfull.
  { exact (subbasis_elem_in_basis X Sfull cyl HSfull HcylSfull HcylNe). }
  claim HcylOpen: cyl :e generated_topology X (basis_of_subbasis X Sfull).
  { exact (generated_topology_contains_basis X (basis_of_subbasis X Sfull) HBasisFull cyl HcylInBasis). }
  claim HTdef: Tx = generated_topology X (basis_of_subbasis X Sfull).
  { reflexivity. }
  rewrite HTdef.
  rewrite HsEq.
  claim HcylDef: cyl = product_cylinder I Xi i0 U0.
  { reflexivity. }
  rewrite <- HcylDef.
  exact HcylOpen. }

prove topology_on X Tx /\ f :e X /\
  exists B0:set, B0 c= Tx /\ countable_set B0 /\
    (forall b:set, b :e B0 -> f :e b) /\
    (forall U:set, U :e Tx -> f :e U -> exists b:set, b :e B0 /\ b c= U).
apply andI.
 - apply andI.
   + exact HTprod.
   + exact Hf.
 - witness B.
   prove B c= Tx /\ countable_set B /\
     (forall b:set, b :e B -> f :e b) /\
     (forall U:set, U :e Tx -> f :e U -> exists b:set, b :e B /\ b c= U).
   apply andI.
   - apply andI.
     + (** B c= Tx and countable_set B **)
       apply andI.
       * let b. assume Hb: b :e B.
         prove b :e Tx.
         apply (ReplE_impred FSsmall (fun F0:set => intersection_of_family X F0) b Hb).
         let F0. assume HF0: F0 :e FSsmall.
         assume HbEq: b = intersection_of_family X F0.
         claim HF0pow: F0 :e Power Ssmall.
         { exact (SepE1 (Power Ssmall) (fun F1:set => finite F1) F0 HF0). }
         claim HF0subS: F0 c= Ssmall.
         { exact (PowerE Ssmall F0 HF0pow). }
         claim HF0fin: finite F0.
         { exact (SepE2 (Power Ssmall) (fun F1:set => finite F1) F0 HF0). }
         claim HF0subT: F0 c= Tx.
         { let s. assume HsF0: s :e F0.
           claim HsS: s :e Ssmall.
           { exact (HF0subS s HsF0). }
           exact (HSsmall_in_Tx s HsS). }
         claim HF0PowT: F0 :e Power Tx.
         { apply PowerI. exact HF0subT. }
         claim Hinter: intersection_of_family X F0 :e Tx.
         { exact (finite_intersection_in_topology X Tx F0 HTprod HF0PowT HF0fin). }
         rewrite HbEq.
         exact Hinter.
       * exact HBcount.
     + (** every b in B contains f **)
       let b. assume Hb: b :e B.
       prove f :e b.
       apply (ReplE_impred FSsmall (fun F0:set => intersection_of_family X F0) b Hb).
       let F0. assume HF0: F0 :e FSsmall.
       assume HbEq: b = intersection_of_family X F0.
       claim HF0pow: F0 :e Power Ssmall.
       { exact (SepE1 (Power Ssmall) (fun F1:set => finite F1) F0 HF0). }
       claim HF0subS: F0 c= Ssmall.
       { exact (PowerE Ssmall F0 HF0pow). }
       rewrite HbEq.
       claim Hprop: forall s:set, s :e F0 -> f :e s.
       { let s. assume HsF0: s :e F0.
         claim HsS: s :e Ssmall.
         { exact (HF0subS s HsF0). }
         apply (famunionE_impred I (fun i0:set => {product_cylinder I Xi i0 U|U :e Bsel i0}) s HsS).
         let i0. assume Hi0I: i0 :e I.
         assume HsFi0: s :e {product_cylinder I Xi i0 U|U :e Bsel i0}.
         apply (ReplE_impred (Bsel i0) (fun U0:set => product_cylinder I Xi i0 U0) s HsFi0).
         let U0. assume HU0B: U0 :e Bsel i0.
         assume HsEq: s = product_cylinder I Xi i0 U0.
         claim HBU0: (Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0) /\
           (forall b0:set, b0 :e (Bsel i0) -> apply_fun f i0 :e b0) /\
           (forall V:set, V :e space_family_topology Xi i0 -> apply_fun f i0 :e V -> exists b0:set, b0 :e (Bsel i0) /\ b0 c= V).
         { exact (HBsel i0 Hi0I). }
         claim Hcore: ((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0)) /\
           (forall b0:set, b0 :e (Bsel i0) -> apply_fun f i0 :e b0).
         { exact (andEL (((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0)) /\
                         (forall b0:set, b0 :e (Bsel i0) -> apply_fun f i0 :e b0))
                        (forall V:set, V :e space_family_topology Xi i0 -> apply_fun f i0 :e V -> exists b0:set, b0 :e (Bsel i0) /\ b0 c= V)
                        HBU0). }
         claim HU0Top: U0 :e space_family_topology Xi i0.
         { exact ((andEL ((Bsel i0) c= space_family_topology Xi i0) (countable_set (Bsel i0))
                         (andEL ((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0))
                                (forall b0:set, b0 :e (Bsel i0) -> apply_fun f i0 :e b0)
                                Hcore)) U0 HU0B). }
         claim HfiU0: apply_fun f i0 :e U0.
         { exact ((andER ((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0))
                         (forall b0:set, b0 :e (Bsel i0) -> apply_fun f i0 :e b0)
                         Hcore) U0 HU0B). }
         rewrite HsEq.
         exact (SepI X (fun f0:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f0 i0 :e U0)
                  f Hf (andI (i0 :e I /\ U0 :e space_family_topology Xi i0) (apply_fun f i0 :e U0)
                           (andI (i0 :e I) (U0 :e space_family_topology Xi i0) Hi0I HU0Top)
                           HfiU0)). }
       exact (SepI X (fun x0:set => forall U:set, U :e F0 -> x0 :e U) f Hf Hprop).
   - (** neighborhood refinement **)
     let U. assume HU: U :e Tx.
     assume HfU: f :e U.
     prove exists b:set, b :e B /\ b c= U.
      claim HTdef: Tx = generated_topology X (basis_of_subbasis X Sfull).
      { reflexivity. }
      claim HUgen: U :e generated_topology X (basis_of_subbasis X Sfull).
      { rewrite <- HTdef. exact HU. }
      claim HUlocal: forall x :e U, exists b0 :e basis_of_subbasis X Sfull, x :e b0 /\ b0 c= U.
      { exact (SepE2 (Power X)
                     (fun U0:set => forall x0 :e U0, exists b0 :e basis_of_subbasis X Sfull, x0 :e b0 /\ b0 c= U0)
                     U HUgen). }
      claim Hexb0: exists b0 :e basis_of_subbasis X Sfull, f :e b0 /\ b0 c= U.
      { exact (HUlocal f HfU). }
      apply Hexb0.
      let b0. assume Hb0pair.
      claim Hb0B: b0 :e basis_of_subbasis X Sfull.
      { exact (andEL (b0 :e basis_of_subbasis X Sfull) (f :e b0 /\ b0 c= U) Hb0pair). }
      claim Hb0prop: f :e b0 /\ b0 c= U.
      { exact (andER (b0 :e basis_of_subbasis X Sfull) (f :e b0 /\ b0 c= U) Hb0pair). }
      claim Hfb0: f :e b0.
      { exact (andEL (f :e b0) (b0 c= U) Hb0prop). }
      claim Hb0subU: b0 c= U.
      { exact (andER (f :e b0) (b0 c= U) Hb0prop). }
      claim Hb0fin: b0 :e finite_intersections_of X Sfull.
      { exact (SepE1 (finite_intersections_of X Sfull) (fun b1:set => b1 <> Empty) b0 Hb0B). }
      claim HexF0: exists F0 :e finite_subcollections Sfull, b0 = intersection_of_family X F0.
      { exact (ReplE (finite_subcollections Sfull) (fun F0:set => intersection_of_family X F0) b0 Hb0fin). }
      apply HexF0.
      let F0. assume HF0pair.
      claim HF0: F0 :e finite_subcollections Sfull.
      { exact (andEL (F0 :e finite_subcollections Sfull) (b0 = intersection_of_family X F0) HF0pair). }
      claim Hb0eq: b0 = intersection_of_family X F0.
      { exact (andER (F0 :e finite_subcollections Sfull) (b0 = intersection_of_family X F0) HF0pair). }
      claim HF0pow: F0 :e Power Sfull.
      { exact (SepE1 (Power Sfull) (fun F1:set => finite F1) F0 HF0). }
      claim HF0sub: F0 c= Sfull.
      { exact (PowerE Sfull F0 HF0pow). }
      claim HF0fin: finite F0.
      { exact (SepE2 (Power Sfull) (fun F1:set => finite F1) F0 HF0). }
      claim HfIntF0: f :e intersection_of_family X F0.
      { rewrite <- Hb0eq. exact Hfb0. }

      set p : set -> prop := fun F:set =>
        F c= Sfull -> f :e intersection_of_family X F ->
          exists G:set, G :e finite_subcollections Ssmall /\
            f :e intersection_of_family X G /\ intersection_of_family X G c= intersection_of_family X F.

      claim HpEmpty: p Empty.
      { prove Empty c= Sfull -> f :e intersection_of_family X Empty ->
          exists G:set, G :e finite_subcollections Ssmall /\
            f :e intersection_of_family X G /\ intersection_of_family X G c= intersection_of_family X Empty.
        assume Hsub0. assume Hf0.
        witness Empty.
        apply andI.
        - apply andI.
          + claim HEmptyPow: Empty :e Power Ssmall.
            { apply PowerI.
              let x. assume Hx: x :e Empty.
              exact (EmptyE x Hx (x :e Ssmall)). }
            exact (SepI (Power Ssmall) (fun F1:set => finite F1) Empty HEmptyPow finite_Empty).
          + exact Hf0.
        - exact (Subq_ref (intersection_of_family X Empty)). }

      claim HpStep: forall F y:set, finite F -> y /:e F -> p F -> p (F :\/: {y}).
      { let F y. assume HFfin: finite F. assume HyNot: y /:e F. assume HpF: p F.
        prove p (F :\/: {y}).
        assume HsubFY: (F :\/: {y}) c= Sfull.
        assume HfIntFY: f :e intersection_of_family X (F :\/: {y}).
        claim HsubF: F c= Sfull.
        { let s. assume HsF: s :e F.
          exact (HsubFY s (binunionI1 F {y} s HsF)). }
        claim HySfull: y :e Sfull.
        { exact (HsubFY y (binunionI2 F {y} y (SingI y))). }
        claim HfInY: f :e y.
        { claim Hall: forall U0:set, U0 :e (F :\/: {y}) -> f :e U0.
          { exact (SepE2 X (fun x0:set => forall U0:set, U0 :e (F :\/: {y}) -> x0 :e U0) f HfIntFY). }
          exact (Hall y (binunionI2 F {y} y (SingI y))). }
        claim HfIntF: f :e intersection_of_family X F.
        { claim HpropF: forall s:set, s :e F -> f :e s.
          { let s. assume HsF: s :e F.
            claim HsFY: s :e (F :\/: {y}).
            { exact (binunionI1 F {y} s HsF). }
            exact ((SepE2 X (fun x0:set => forall U0:set, U0 :e (F :\/: {y}) -> x0 :e U0) f HfIntFY) s HsFY). }
          exact (SepI X (fun x0:set => forall U0:set, U0 :e F -> x0 :e U0) f Hf HpropF). }
        claim HexG0: exists G0:set, G0 :e finite_subcollections Ssmall /\
          f :e intersection_of_family X G0 /\ intersection_of_family X G0 c= intersection_of_family X F.
        { exact (HpF HsubF HfIntF). }
        apply HexG0.
        let G0. assume HG0pair.
        claim HG0core: G0 :e finite_subcollections Ssmall /\ f :e intersection_of_family X G0.
        { exact (andEL (G0 :e finite_subcollections Ssmall /\ f :e intersection_of_family X G0)
                       (intersection_of_family X G0 c= intersection_of_family X F)
                       HG0pair). }
        claim HG0: G0 :e finite_subcollections Ssmall.
        { exact (andEL (G0 :e finite_subcollections Ssmall) (f :e intersection_of_family X G0) HG0core). }
        claim HfIntG0: f :e intersection_of_family X G0.
        { exact (andER (G0 :e finite_subcollections Ssmall) (f :e intersection_of_family X G0) HG0core). }
        claim HG0sub: intersection_of_family X G0 c= intersection_of_family X F.
        { exact (andER (G0 :e finite_subcollections Ssmall /\ f :e intersection_of_family X G0)
                       (intersection_of_family X G0 c= intersection_of_family X F)
                       HG0pair). }

        claim HexRef: exists y0:set, y0 :e Ssmall /\ y0 c= y /\ f :e y0.
        { apply (famunionE_impred I (fun i0:set => {product_cylinder I Xi i0 U|U :e space_family_topology Xi i0}) y HySfull).
          let i0. assume Hi0I: i0 :e I.
          assume HyFi0: y :e {product_cylinder I Xi i0 U|U :e space_family_topology Xi i0}.
          apply (ReplE_impred (space_family_topology Xi i0) (fun U0:set => product_cylinder I Xi i0 U0) y HyFi0).
          let V0. assume HV0Top: V0 :e space_family_topology Xi i0.
          assume HyEq: y = product_cylinder I Xi i0 V0.
          claim HfCyl: f :e product_cylinder I Xi i0 V0.
          { rewrite <- HyEq. exact HfInY. }
          claim HfiV0: apply_fun f i0 :e V0.
          { exact (andER (i0 :e I /\ V0 :e space_family_topology Xi i0)
                         (apply_fun f i0 :e V0)
                         (SepE2 X (fun f0:set => i0 :e I /\ V0 :e space_family_topology Xi i0 /\ apply_fun f0 i0 :e V0) f HfCyl)). }
          claim HBi0: (Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0) /\
            (forall b0:set, b0 :e (Bsel i0) -> apply_fun f i0 :e b0) /\
            (forall U0:set, U0 :e space_family_topology Xi i0 -> apply_fun f i0 :e U0 -> exists b0:set, b0 :e (Bsel i0) /\ b0 c= U0).
          { exact (HBsel i0 Hi0I). }
          claim Href_i0: forall U0:set, U0 :e space_family_topology Xi i0 -> apply_fun f i0 :e U0 -> exists b0:set, b0 :e (Bsel i0) /\ b0 c= U0.
          { exact (andER (((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0)) /\
                          (forall b0:set, b0 :e (Bsel i0) -> apply_fun f i0 :e b0))
                         (forall U0:set, U0 :e space_family_topology Xi i0 -> apply_fun f i0 :e U0 -> exists b0:set, b0 :e (Bsel i0) /\ b0 c= U0)
                         HBi0). }
          claim Hexb0: exists b0:set, b0 :e (Bsel i0) /\ b0 c= V0.
          { exact (Href_i0 V0 HV0Top HfiV0). }
	          apply Hexb0.
	          let b0. assume Hb0pair.
	          claim Hb0B: b0 :e (Bsel i0).
	          { exact (andEL (b0 :e (Bsel i0)) (b0 c= V0) Hb0pair). }
	          claim Hb0sub: b0 c= V0.
	          { exact (andER (b0 :e (Bsel i0)) (b0 c= V0) Hb0pair). }
	          claim Hcore_i0: ((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0)) /\
	            (forall b1:set, b1 :e (Bsel i0) -> apply_fun f i0 :e b1).
	          { exact (andEL (((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0)) /\
	                          (forall b0:set, b0 :e (Bsel i0) -> apply_fun f i0 :e b0))
	                         (forall U0:set, U0 :e space_family_topology Xi i0 -> apply_fun f i0 :e U0 -> exists b0:set, b0 :e (Bsel i0) /\ b0 c= U0)
	                         HBi0). }
	          claim HsubTop: (Bsel i0) c= space_family_topology Xi i0.
	          { exact (andEL ((Bsel i0) c= space_family_topology Xi i0)
	                         (countable_set (Bsel i0))
	                         (andEL ((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0))
	                                (forall b1:set, b1 :e (Bsel i0) -> apply_fun f i0 :e b1)
	                                Hcore_i0)). }
	          claim Hb0Top: b0 :e space_family_topology Xi i0.
	          { exact (HsubTop b0 Hb0B). }
	          claim Hforallb: forall b1:set, b1 :e (Bsel i0) -> apply_fun f i0 :e b1.
	          { exact (andER ((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0))
	                         (forall b1:set, b1 :e (Bsel i0) -> apply_fun f i0 :e b1)
	                         Hcore_i0). }
	          claim Hfb0: apply_fun f i0 :e b0.
	          { exact (Hforallb b0 Hb0B). }
	          set y0 := product_cylinder I Xi i0 b0.
	          witness y0.
	          apply andI.
	          - apply andI.
	            + exact (famunionI I (fun i1:set => {product_cylinder I Xi i1 U|U :e Bsel i1})
	                         i0 y0 Hi0I (ReplI (Bsel i0) (fun U0:set => product_cylinder I Xi i0 U0) b0 Hb0B)).
	            + let g. assume Hg: g :e y0.
	              prove g :e y.
	              claim HgCyl: g :e product_cylinder I Xi i0 b0.
	              { exact Hg. }
	              claim Hgprop: i0 :e I /\ b0 :e space_family_topology Xi i0 /\ apply_fun g i0 :e b0.
	              { exact (SepE2 X (fun g0:set => i0 :e I /\ b0 :e space_family_topology Xi i0 /\ apply_fun g0 i0 :e b0) g HgCyl). }
	              claim Hgi0: apply_fun g i0 :e b0.
	              { exact (andER (i0 :e I /\ b0 :e space_family_topology Xi i0) (apply_fun g i0 :e b0) Hgprop). }
	              claim Hgi0V0: apply_fun g i0 :e V0.
	              { exact (Hb0sub (apply_fun g i0) Hgi0). }
	              rewrite HyEq.
	              exact (SepI X (fun g0:set => i0 :e I /\ V0 :e space_family_topology Xi i0 /\ apply_fun g0 i0 :e V0)
	                       g (SepE1 X (fun g0:set => i0 :e I /\ b0 :e space_family_topology Xi i0 /\ apply_fun g0 i0 :e b0) g HgCyl)
	                       (andI (i0 :e I /\ V0 :e space_family_topology Xi i0) (apply_fun g i0 :e V0)
	                            (andI (i0 :e I) (V0 :e space_family_topology Xi i0) Hi0I HV0Top) Hgi0V0)).
	          - exact (SepI X (fun f0:set => i0 :e I /\ b0 :e space_family_topology Xi i0 /\ apply_fun f0 i0 :e b0)
	                   f Hf (andI (i0 :e I /\ b0 :e space_family_topology Xi i0) (apply_fun f i0 :e b0)
	                            (andI (i0 :e I) (b0 :e space_family_topology Xi i0) Hi0I Hb0Top)
	                            Hfb0)). }
 

        apply HexRef.
        let y0. assume Hy0pair.
        claim Hy0S: y0 :e Ssmall.
        { claim Hy0core: (y0 :e Ssmall /\ y0 c= y).
          { exact (andEL (y0 :e Ssmall /\ y0 c= y) (f :e y0) Hy0pair). }
          exact (andEL (y0 :e Ssmall) (y0 c= y) Hy0core). }
        claim Hy0suby: y0 c= y.
        { claim Hy0core: (y0 :e Ssmall /\ y0 c= y).
          { exact (andEL (y0 :e Ssmall /\ y0 c= y) (f :e y0) Hy0pair). }
          exact (andER (y0 :e Ssmall) (y0 c= y) Hy0core). }
        claim Hfy0: f :e y0.
        { exact (andER (y0 :e Ssmall /\ y0 c= y) (f :e y0) Hy0pair). }

        set G := G0 :\/: {y0}.
        witness G.
        apply andI.
        - apply andI.
          + (** G in finite_subcollections Ssmall **)
            claim HG0pow: G0 :e Power Ssmall.
            { exact (SepE1 (Power Ssmall) (fun F1:set => finite F1) G0 HG0). }
            claim HG0subS: G0 c= Ssmall.
            { exact (PowerE Ssmall G0 HG0pow). }
            claim HG0fin: finite G0.
            { exact (SepE2 (Power Ssmall) (fun F1:set => finite F1) G0 HG0). }
            claim HGsub: G c= Ssmall.
            { let s. assume HsG: s :e G.
              apply (binunionE' G0 {y0} s (s :e Ssmall)).
              - assume HsG0: s :e G0.
                exact (HG0subS s HsG0).
              - assume Hsy0: s :e {y0}.
                rewrite (SingE y0 s Hsy0).
                exact Hy0S.
              - exact HsG. }
            claim HGpow: G :e Power Ssmall.
            { apply PowerI. exact HGsub. }
	            claim HGfin: finite G.
	            { exact (adjoin_finite G0 y0 HG0fin). }
	            exact (SepI (Power Ssmall) (fun F1:set => finite F1) G HGpow HGfin).
	          + (** f in intersection_of_family X G **)
	            claim HpropG: forall s:set, s :e G -> f :e s.
	            { let s. assume HsG: s :e G.
	              apply (binunionE' G0 {y0} s (f :e s)).
	              - assume HsG0: s :e G0.
	                exact ((SepE2 X (fun x0:set => forall U0:set, U0 :e G0 -> x0 :e U0) f HfIntG0) s HsG0).
	              - assume Hsy0: s :e {y0}.
	                rewrite (SingE y0 s Hsy0).
	                exact Hfy0.
	              - exact HsG. }
	            exact (SepI X (fun x0:set => forall U0:set, U0 :e G -> x0 :e U0) f Hf HpropG).
	        - (** inclusion: intersection_of_family X G c= intersection_of_family X (F :\/: {y}) **)
	          let z. assume Hz: z :e intersection_of_family X G.
	          prove z :e intersection_of_family X (F :\/: {y}).
	          claim HzX: z :e X.
	          { exact (SepE1 X (fun x0:set => forall U0:set, U0 :e G -> x0 :e U0) z Hz). }
	          claim HzG: forall U0:set, U0 :e G -> z :e U0.
	          { exact (SepE2 X (fun x0:set => forall U0:set, U0 :e G -> x0 :e U0) z Hz). }
	          claim HzG0: z :e intersection_of_family X G0.
	          { claim HzG0prop: forall s:set, s :e G0 -> z :e s.
	            { let s. assume HsG0: s :e G0.
	              exact (HzG s (binunionI1 G0 {y0} s HsG0)). }
	            exact (SepI X (fun x0:set => forall U0:set, U0 :e G0 -> x0 :e U0) z HzX HzG0prop). }
	          claim HzF: z :e intersection_of_family X F.
	          { exact (HG0sub z HzG0). }
	          claim Hzy0: z :e y0.
	          { exact (HzG y0 (binunionI2 G0 {y0} y0 (SingI y0))). }
	          claim Hzy: z :e y.
	          { exact (Hy0suby z Hzy0). }
	          claim HzFYprop: forall s:set, s :e (F :\/: {y}) -> z :e s.
	          { let s. assume HsFY: s :e (F :\/: {y}).
	            apply (binunionE' F {y} s (z :e s)).
	            - assume HsF: s :e F.
	              exact ((SepE2 X (fun x0:set => forall U0:set, U0 :e F -> x0 :e U0) z HzF) s HsF).
	            - assume Hsy: s :e {y}.
	              rewrite (SingE y s Hsy).
	              exact Hzy.
	            - exact HsFY. }
		          exact (SepI X (fun x0:set => forall U0:set, U0 :e (F :\/: {y}) -> x0 :e U0) z HzX HzFYprop).
	      }

	      claim Hpref: p F0.
	      { exact (finite_ind p HpEmpty HpStep F0 HF0fin). }
      claim HexG: exists G:set, G :e finite_subcollections Ssmall /\
        f :e intersection_of_family X G /\ intersection_of_family X G c= intersection_of_family X F0.
      { exact (Hpref HF0sub HfIntF0). }
      apply HexG.
      let G. assume HGpair.
      claim HGcore: G :e finite_subcollections Ssmall /\ f :e intersection_of_family X G.
      { exact (andEL (G :e finite_subcollections Ssmall /\ f :e intersection_of_family X G)
                     (intersection_of_family X G c= intersection_of_family X F0)
                     HGpair). }
      claim HG: G :e finite_subcollections Ssmall.
      { exact (andEL (G :e finite_subcollections Ssmall) (f :e intersection_of_family X G) HGcore). }
      claim HGsub: intersection_of_family X G c= intersection_of_family X F0.
      { exact (andER (G :e finite_subcollections Ssmall /\ f :e intersection_of_family X G)
                     (intersection_of_family X G c= intersection_of_family X F0)
                     HGpair). }
      set b := intersection_of_family X G.
      witness b.
      apply andI.
      - exact (ReplI FSsmall (fun F1:set => intersection_of_family X F1) G HG).
      - let z. assume Hz: z :e b.
        prove z :e U.
        claim HzF0: z :e intersection_of_family X F0.
        { exact (HGsub z Hz). }
        claim Hzb0: z :e b0.
        { rewrite Hb0eq.
          exact HzF0. }
        exact (Hb0subU z Hzb0).
Qed.

(** from 30 Theorem 30.1(a): sequences and closure in first-countable spaces **) 
(** LATEX VERSION: In first-countable spaces, sequential closure detects topological closure. **)
Theorem first_countable_sequences_detect_closure : forall X Tx A x:set,
  topology_on X Tx ->
  (exists seq:set, sequence_in seq A /\ converges_to X Tx seq x) ->
  x :e closure_of X Tx A.
let X Tx A x.
assume HTx: topology_on X Tx.
assume Hseq: exists seq:set, sequence_in seq A /\ converges_to X Tx seq x.
prove x :e closure_of X Tx A.
apply Hseq.
let seq. assume Hseqpair.
claim Hseqin: sequence_in seq A.
{ exact (andEL (sequence_in seq A) (converges_to X Tx seq x) Hseqpair). }
claim Hconv: converges_to X Tx seq x.
{ exact (andER (sequence_in seq A) (converges_to X Tx seq x) Hseqpair). }
claim HxX: x :e X.
{ claim Hleft: (topology_on X Tx /\ sequence_on seq X) /\ x :e X.
  { exact (andEL ((topology_on X Tx /\ sequence_on seq X) /\ x :e X)
                 (forall U:set, U :e Tx -> x :e U -> exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U)
                 Hconv). }
  exact (andER (topology_on X Tx /\ sequence_on seq X) (x :e X) Hleft). }
claim Hcliff: x :e closure_of X Tx A <-> (forall U :e Tx, x :e U -> U :/\: A <> Empty).
{ exact (closure_characterization X Tx A x HTx HxX). }
apply (iffER (x :e closure_of X Tx A) (forall U :e Tx, x :e U -> U :/\: A <> Empty) Hcliff).
prove forall U :e Tx, x :e U -> U :/\: A <> Empty.
let U. assume HU: U :e Tx. assume HxU: x :e U.
claim Hevent: exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U.
{ claim Htail0: forall V:set, V :e Tx -> x :e V ->
    exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e V.
  { exact (andER ((topology_on X Tx /\ sequence_on seq X) /\ x :e X)
                 (forall V:set, V :e Tx -> x :e V -> exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e V)
                 Hconv). }
  exact (Htail0 U HU HxU). }
apply Hevent.
let N. assume HNpair.
claim HNomega: N :e omega.
{ exact (andEL (N :e omega) (forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U) HNpair). }
claim Htail: forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U.
{ exact (andER (N :e omega) (forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U) HNpair). }
claim HyU: apply_fun seq N :e U.
{ exact (Htail N HNomega (Subq_ref N)). }
claim HyA: apply_fun seq N :e A.
{ exact (Hseqin N HNomega). }
prove U :/\: A <> Empty.
assume HUAEq: U :/\: A = Empty.
claim HyUA: apply_fun seq N :e U :/\: A.
{ exact (binintersectI U A (apply_fun seq N) HyU HyA). }
claim HyEmp: apply_fun seq N :e Empty.
{ rewrite <- HUAEq. exact HyUA. }
exact (EmptyE (apply_fun seq N) HyEmp False).
Qed.

(** from 30 Theorem 30.1(b): sequences and continuity in first-countable spaces **)
(** LATEX VERSION: Sequential criterion for continuity in first-countable spaces. **)
(** FIXED: Correct convergence target and image limit: if x_n converges to x then f(x_n) converges to f(x). **)
Theorem first_countable_sequences_detect_continuity : forall X Tx Y Ty f:set,
  topology_on X Tx -> topology_on Y Ty ->
  (continuous_map X Tx Y Ty f ->
    forall x seq:set, sequence_on seq X -> converges_to X Tx seq x -> converges_to Y Ty (map_sequence f seq) (apply_fun f x)).
let X Tx Y Ty f.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove continuous_map X Tx Y Ty f ->
    forall x seq:set, sequence_on seq X -> converges_to X Tx seq x -> converges_to Y Ty (map_sequence f seq) (apply_fun f x).
assume Hcont: continuous_map X Tx Y Ty f.
let x seq.
assume Hseqon: sequence_on seq X.
assume Hconv: converges_to X Tx seq x.
prove converges_to Y Ty (map_sequence f seq) (apply_fun f x).
claim Hcont_left: (topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y.
{ exact (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               Hcont). }
claim Hfun: function_on f X Y.
{ exact (andER (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y) Hcont_left). }
claim Hpre: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
{ exact (andER ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               Hcont). }
claim Hconv_left: (topology_on X Tx /\ sequence_on seq X) /\ x :e X.
{ exact (andEL ((topology_on X Tx /\ sequence_on seq X) /\ x :e X)
               (forall U:set, U :e Tx -> x :e U -> exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U)
               Hconv). }
claim HxX: x :e X.
{ exact (andER (topology_on X Tx /\ sequence_on seq X) (x :e X) Hconv_left). }
claim HfxY: apply_fun f x :e Y.
{ exact (Hfun x HxX). }
prove topology_on Y Ty /\ sequence_on (map_sequence f seq) Y /\ apply_fun f x :e Y /\
      forall V:set, V :e Ty -> apply_fun f x :e V ->
        exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun (map_sequence f seq) n :e V.
apply andI.
- (** left: (topology_on Y Ty /\ sequence_on ...) /\ apply_fun f x :e Y **)
  apply andI.
  + (** topology_on Y Ty /\ sequence_on (map_sequence f seq) Y **)
    apply andI.
    * exact HTy.
    * prove sequence_on (map_sequence f seq) Y.
      let n. assume Hn: n :e omega.
      prove apply_fun (map_sequence f seq) n :e Y.
      claim HseqnX: apply_fun seq n :e X.
      { exact (Hseqon n Hn). }
      claim Hcomp: apply_fun (map_sequence f seq) n = apply_fun f (apply_fun seq n).
      { exact (compose_fun_apply omega seq f n Hn). }
      rewrite Hcomp.
      exact (Hfun (apply_fun seq n) HseqnX).
  + exact HfxY.
- (** right: neighborhood condition **)
  let V. assume HV: V :e Ty. assume HfxV: apply_fun f x :e V.
  set U := preimage_of X f V.
  claim HUDef: U = preimage_of X f V.
  { reflexivity. }
  claim HUopen: U :e Tx.
  { rewrite HUDef. exact (Hpre V HV). }
  claim HxU: x :e U.
  { rewrite HUDef.
    exact (SepI X (fun x0:set => apply_fun f x0 :e V) x HxX HfxV). }
  claim Htail0: forall W:set, W :e Tx -> x :e W ->
    exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e W.
  { exact (andER ((topology_on X Tx /\ sequence_on seq X) /\ x :e X)
                 (forall W:set, W :e Tx -> x :e W -> exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e W)
                 Hconv). }
  claim Hevent: exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U.
  { exact (Htail0 U HUopen HxU). }
  apply Hevent.
  let N. assume HNpair.
  claim HNomega: N :e omega.
  { exact (andEL (N :e omega) (forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U) HNpair). }
  claim Htail: forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U.
  { exact (andER (N :e omega) (forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U) HNpair). }
  witness N.
  apply andI.
  + exact HNomega.
  + let n. assume Hn: n :e omega. assume HNsub: N c= n.
    claim HseqnU: apply_fun seq n :e U.
    { exact (Htail n Hn HNsub). }
    claim HseqnU0: apply_fun seq n :e preimage_of X f V.
    { rewrite <- HUDef. exact HseqnU. }
    claim HfnV: apply_fun f (apply_fun seq n) :e V.
    { exact (SepE2 X (fun x0:set => apply_fun f x0 :e V) (apply_fun seq n) HseqnU0). }
    claim Hcomp: apply_fun (map_sequence f seq) n = apply_fun f (apply_fun seq n).
    { exact (compose_fun_apply omega seq f n Hn). }
    rewrite Hcomp.
    exact HfnV.
Qed.

(** from 30 Definition: second-countable space **) 
(** LATEX VERSION: Second countable means existence of a countable basis for the topology. **)
Definition second_countable_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\ exists B:set, basis_on X B /\ countable_set B /\ basis_generates X B Tx.

(** from 30 Example 1: R^n has countable basis **) 
(** LATEX VERSION: Euclidean spaces have a countable basis, hence are second countable. **)
Theorem euclidean_spaces_second_countable : forall n:set,
  second_countable_space (euclidean_space n) (euclidean_topology n).
let n.
prove second_countable_space (euclidean_space n) (euclidean_topology n).
admit.
Qed.

(** from 30 Example 2: uniform topology on R^omega not second countable **) 
(** LATEX VERSION: The uniform topology on the space of real sequences is first countable but not second countable. **)
Theorem Romega_uniform_first_not_second_countable :
  first_countable_space real_sequences uniform_topology /\
  ~ second_countable_space real_sequences uniform_topology.
prove first_countable_space real_sequences uniform_topology /\ ~ second_countable_space real_sequences uniform_topology.
admit.
Qed.

(** from 30 Theorem 30.2: countability axioms preserved by subspaces and countable products **)
(** LATEX VERSION: First/second countability are inherited by subspaces and countable products (Theorem 30.2). **)
(** FIXED: Product clauses quantify i only over i:e I (not all sets). **) 
Theorem countability_axioms_subspace_product : forall X Tx:set,
  topology_on X Tx ->
  (forall A:set, A c= X -> first_countable_space X Tx -> first_countable_space A (subspace_topology X Tx A)) /\
  (forall A:set, A c= X -> second_countable_space X Tx -> second_countable_space A (subspace_topology X Tx A)) /\
  (forall I Xi:set, countable_index_set I ->
    (forall i:set, i :e I -> first_countable_space (space_family_set Xi i) (space_family_topology Xi i)) ->
    first_countable_space (countable_product_space I Xi) (countable_product_topology_subbasis I Xi)) /\
  (forall I Xi:set, countable_index_set I ->
    (forall i:set, i :e I -> second_countable_space (space_family_set Xi i) (space_family_topology Xi i)) ->
    second_countable_space (countable_product_space I Xi) (countable_product_topology_subbasis I Xi)).
let X Tx.
assume HTx: topology_on X Tx.
prove (forall A:set, A c= X -> first_countable_space X Tx -> first_countable_space A (subspace_topology X Tx A)) /\
  (forall A:set, A c= X -> second_countable_space X Tx -> second_countable_space A (subspace_topology X Tx A)) /\
  (forall I Xi:set, countable_index_set I ->
    (forall i:set, i :e I -> first_countable_space (space_family_set Xi i) (space_family_topology Xi i)) ->
    first_countable_space (countable_product_space I Xi) (countable_product_topology_subbasis I Xi)) /\
  (forall I Xi:set, countable_index_set I ->
    (forall i:set, i :e I -> second_countable_space (space_family_set Xi i) (space_family_topology Xi i)) ->
    second_countable_space (countable_product_space I Xi) (countable_product_topology_subbasis I Xi)).
apply andI.
- (** first three clauses **)
  apply andI.
  + (** first two clauses **)
    apply andI.
    * (** first countable preserved by subspaces **)
      let A. assume HA: A c= X.
      assume Hfc: first_countable_space X Tx.
      prove first_countable_space A (subspace_topology X Tx A).
      claim HtopSub: topology_on A (subspace_topology X Tx A).
      { exact (subspace_topology_is_topology X Tx A HTx HA). }
      claim HfcTop: topology_on X Tx.
      { exact (andEL (topology_on X Tx) (forall x:set, x :e X -> countable_basis_at X Tx x) Hfc). }
      claim HfcAt: forall x:set, x :e X -> countable_basis_at X Tx x.
      { exact (andER (topology_on X Tx) (forall x:set, x :e X -> countable_basis_at X Tx x) Hfc). }
      prove topology_on A (subspace_topology X Tx A) /\
           forall x:set, x :e A -> countable_basis_at A (subspace_topology X Tx A) x.
      apply andI.
      { exact HtopSub. }
      { let x. assume HxA: x :e A.
        prove countable_basis_at A (subspace_topology X Tx A) x.
        claim HxX: x :e X.
        { exact (HA x HxA). }
        claim Hcbx: countable_basis_at X Tx x.
        { exact (HfcAt x HxX). }
        claim Hcbx_left: (topology_on X Tx /\ x :e X) /\ exists Bx:set,
          Bx c= Tx /\ countable_set Bx /\ (forall b:set, b :e Bx -> x :e b) /\
          (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e Bx /\ b c= U).
        { exact Hcbx. }
        claim HexBx: exists Bx:set,
          Bx c= Tx /\ countable_set Bx /\ (forall b:set, b :e Bx -> x :e b) /\
          (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e Bx /\ b c= U).
        { exact (andER (topology_on X Tx /\ x :e X)
                       (exists Bx:set, Bx c= Tx /\ countable_set Bx /\ (forall b:set, b :e Bx -> x :e b) /\
                                        (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e Bx /\ b c= U))
                       Hcbx_left). }
        prove topology_on A (subspace_topology X Tx A) /\ x :e A /\
          exists BxA:set,
            BxA c= subspace_topology X Tx A /\ countable_set BxA /\
              (forall b:set, b :e BxA -> x :e b) /\
              (forall U0:set, U0 :e subspace_topology X Tx A -> x :e U0 -> exists b:set, b :e BxA /\ b c= U0).
        apply andI.
        - apply andI.
          + exact HtopSub.
          + exact HxA.
        - apply HexBx.
            let Bx. assume HBxpair.
            claim Htmp1: (Bx c= Tx /\ countable_set Bx) /\ (forall b:set, b :e Bx -> x :e b).
            { exact (andEL ((Bx c= Tx /\ countable_set Bx) /\ (forall b:set, b :e Bx -> x :e b))
                           (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e Bx /\ b c= U)
                           HBxpair). }
            claim HBxref: forall U:set, U :e Tx -> x :e U -> exists b:set, b :e Bx /\ b c= U.
            { exact (andER ((Bx c= Tx /\ countable_set Bx) /\ (forall b:set, b :e Bx -> x :e b))
                           (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e Bx /\ b c= U)
                           HBxpair). }
            claim Htmp2: Bx c= Tx /\ countable_set Bx.
            { exact (andEL (Bx c= Tx /\ countable_set Bx)
                           (forall b:set, b :e Bx -> x :e b)
                           Htmp1). }
            claim HBxmem: forall b:set, b :e Bx -> x :e b.
            { exact (andER (Bx c= Tx /\ countable_set Bx)
                           (forall b:set, b :e Bx -> x :e b)
                           Htmp1). }
            claim HBxsub: Bx c= Tx.
            { exact (andEL (Bx c= Tx) (countable_set Bx) Htmp2). }
            claim HBxcount: countable_set Bx.
            { exact (andER (Bx c= Tx) (countable_set Bx) Htmp2). }
            set BxA := {b :/\: A | b :e Bx}.
            witness BxA.
            apply andI.
            - (** left: (subset and countable) and neighborhood membership **)
              apply andI.
              + (** subset and countable_set **)
                apply andI.
                * prove BxA c= subspace_topology X Tx A.
                  let c. assume Hc: c :e BxA.
                  prove c :e subspace_topology X Tx A.
                  apply (ReplE_impred Bx (fun b0:set => b0 :/\: A) c Hc).
                  let b. assume HbBx: b :e Bx. assume Hceq: c = b :/\: A.
                  claim HbTx: b :e Tx.
                  { exact (HBxsub b HbBx). }
                  claim HcPowA: c :e Power A.
                  { apply PowerI A c.
                    let y. assume Hyc: y :e c.
                    claim HybA: y :e b :/\: A.
                    { rewrite <- Hceq. exact Hyc. }
                    exact (binintersectE2 b A y HybA). }
                  claim HcProp: exists V :e Tx, c = V :/\: A.
                  { witness b.
                    apply andI.
                    - exact HbTx.
                    - exact Hceq. }
                  exact (SepI (Power A) (fun U0:set => exists V :e Tx, U0 = V :/\: A) c HcPowA HcProp).
                * exact (countable_image Bx HBxcount (fun b0:set => b0 :/\: A)).
              + (** each element contains x **)
                let c. assume Hc: c :e BxA.
                prove x :e c.
                apply (ReplE_impred Bx (fun b0:set => b0 :/\: A) c Hc).
                let b. assume HbBx: b :e Bx. assume Hceq: c = b :/\: A.
                claim Hxb: x :e b.
                { exact (HBxmem b HbBx). }
                claim HxBA: x :e b :/\: A.
                { exact (binintersectI b A x Hxb HxA). }
                rewrite Hceq.
                exact HxBA.
            - (** refinement for subspace neighborhoods **)
              let U0.
              assume HU0: U0 :e subspace_topology X Tx A.
              assume HxU0: x :e U0.
              claim HU0prop: exists V :e Tx, U0 = V :/\: A.
              { exact (SepE2 (Power A) (fun U1:set => exists V :e Tx, U1 = V :/\: A) U0 HU0). }
              apply HU0prop.
              let V. assume HVpair.
              claim HVTx: V :e Tx.
              { exact (andEL (V :e Tx) (U0 = V :/\: A) HVpair). }
              claim HU0eq: U0 = V :/\: A.
              { exact (andER (V :e Tx) (U0 = V :/\: A) HVpair). }
              claim HxVA: x :e V :/\: A.
              { rewrite <- HU0eq. exact HxU0. }
              claim HxV: x :e V.
              { exact (binintersectE1 V A x HxVA). }
              claim Hexb: exists b:set, b :e Bx /\ b c= V.
              { exact (HBxref V HVTx HxV). }
              apply Hexb.
              let b. assume Hbpair3.
              claim HbBx: b :e Bx.
              { exact (andEL (b :e Bx) (b c= V) Hbpair3). }
              claim HbsubV: b c= V.
              { exact (andER (b :e Bx) (b c= V) Hbpair3). }
              set c := b :/\: A.
              witness c.
              apply andI.
              - prove c :e BxA.
                exact (ReplI Bx (fun b0:set => b0 :/\: A) b HbBx).
              - prove c c= U0.
                let y. assume Hyc: y :e c.
                claim Hyb: y :e b.
                { exact (binintersectE1 b A y Hyc). }
                claim HyA: y :e A.
                { exact (binintersectE2 b A y Hyc). }
                claim HyV: y :e V.
                { exact (HbsubV y Hyb). }
                claim HyVA: y :e V :/\: A.
                { exact (binintersectI V A y HyV HyA). }
                rewrite HU0eq.
                exact HyVA.
      }
    * (** second countable preserved by subspaces **)
      let A. assume HA: A c= X.
      assume Hsc: second_countable_space X Tx.
      prove second_countable_space A (subspace_topology X Tx A).
      claim HtopSub: topology_on A (subspace_topology X Tx A).
      { exact (subspace_topology_is_topology X Tx A HTx HA). }
      claim HexB: exists B:set, basis_on X B /\ countable_set B /\ basis_generates X B Tx.
      { exact (andER (topology_on X Tx) (exists B:set, basis_on X B /\ countable_set B /\ basis_generates X B Tx) Hsc). }
      apply HexB.
      let B. assume HBpair.
      claim HBmid: (basis_on X B /\ countable_set B) /\ basis_generates X B Tx.
      { exact HBpair. }
      claim HBasisCount: basis_on X B /\ countable_set B.
      { exact (andEL (basis_on X B /\ countable_set B) (basis_generates X B Tx) HBmid). }
      claim HBgener: basis_generates X B Tx.
      { exact (andER (basis_on X B /\ countable_set B) (basis_generates X B Tx) HBmid). }
      claim HBasis: basis_on X B.
      { exact (andEL (basis_on X B) (countable_set B) HBasisCount). }
      claim HBcount: countable_set B.
      { exact (andER (basis_on X B) (countable_set B) HBasisCount). }
      claim HgenEq: generated_topology X B = Tx.
      { exact (andER (basis_on X B) (generated_topology X B = Tx) HBgener). }
      claim HBgen: basis_on X B /\ generated_topology X B = Tx.
      { apply andI.
        - exact HBasis.
        - exact HgenEq. }
      claim HsubB: basis_on A {b :/\: A | b :e B} /\ generated_topology A {b :/\: A | b :e B} = subspace_topology X Tx A.
      { exact (subspace_basis X Tx A B HTx HA HBgen). }
      claim HBsubA: basis_on A {b :/\: A | b :e B}.
      { exact (andEL (basis_on A {b :/\: A | b :e B})
                     (generated_topology A {b :/\: A | b :e B} = subspace_topology X Tx A)
                     HsubB). }
      claim HgenSubEq: generated_topology A {b :/\: A | b :e B} = subspace_topology X Tx A.
      { exact (andER (basis_on A {b :/\: A | b :e B})
                     (generated_topology A {b :/\: A | b :e B} = subspace_topology X Tx A)
                     HsubB). }
      prove topology_on A (subspace_topology X Tx A) /\
           exists B0:set, basis_on A B0 /\ countable_set B0 /\ basis_generates A B0 (subspace_topology X Tx A).
      apply andI.
      { exact HtopSub. }
      { witness {b :/\: A | b :e B}.
        apply andI.
        - (** basis_on and countable_set **)
          apply andI.
          + exact HBsubA.
          + exact (countable_image B HBcount (fun b0:set => b0 :/\: A)).
        - (** basis_generates **)
          prove basis_on A {b :/\: A | b :e B} /\
                generated_topology A {b :/\: A | b :e B} = subspace_topology X Tx A.
          apply andI.
          + exact HBsubA.
          + exact HgenSubEq. }
	  + (** first countable for countable products **)
	    let I Xi.
	    assume HIcount: countable_index_set I.
	    assume Hcomp: forall i:set, i :e I -> first_countable_space (space_family_set Xi i) (space_family_topology Xi i).
	    prove first_countable_space (countable_product_space I Xi) (countable_product_topology_subbasis I Xi).
	    prove topology_on (countable_product_space I Xi) (countable_product_topology_subbasis I Xi) /\
	         forall f:set, f :e countable_product_space I Xi -> countable_basis_at (countable_product_space I Xi) (countable_product_topology_subbasis I Xi) f.
	    apply andI.
		    - (** topology_on for product **)
		      apply (xm (I = Empty)).
		      + assume HI0: I = Empty.
		        rewrite HI0.
		        exact (countable_product_topology_subbasis_empty_is_topology Xi).
		      + assume HIn0: ~(I = Empty).
		        claim HcompTop: forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i).
		        { let i. assume HiI: i :e I.
		          exact (andEL (topology_on (space_family_set Xi i) (space_family_topology Xi i))
		                       (forall x:set, x :e space_family_set Xi i -> countable_basis_at (space_family_set Xi i) (space_family_topology Xi i) x)
		                       (Hcomp i HiI)). }
		        claim HS: subbasis_on (product_space I Xi) (product_subbasis_full I Xi).
		        { exact (product_subbasis_full_subbasis_on I Xi HIn0 HcompTop). }
		        claim HB: basis_on (product_space I Xi) (basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi)).
		        { exact (finite_intersections_basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi) HS). }
		        exact (lemma_topology_from_basis (product_space I Xi) (basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi)) HB).
		    - (** local countable basis at points **)
		      let f. assume Hf: f :e countable_product_space I Xi.
		      prove countable_basis_at (countable_product_space I Xi) (countable_product_topology_subbasis I Xi) f.
		      apply (xm (I = Empty)).
		      + assume HI0: I = Empty.
		        claim Hf0: f :e product_space Empty Xi.
		        { rewrite <- HI0. exact Hf. }
		        rewrite HI0.
		        prove countable_basis_at (product_space Empty Xi) (countable_product_topology_subbasis Empty Xi) f.
		        claim HT0: topology_on (product_space Empty Xi) (countable_product_topology_subbasis Empty Xi).
		        { exact (countable_product_topology_subbasis_empty_is_topology Xi). }
			        prove topology_on (product_space Empty Xi) (countable_product_topology_subbasis Empty Xi) /\ f :e product_space Empty Xi /\
			          exists B:set, B c= countable_product_topology_subbasis Empty Xi /\ countable_set B /\
			            (forall b:set, b :e B -> f :e b) /\
			            (forall U:set, U :e countable_product_topology_subbasis Empty Xi -> f :e U -> exists b:set, b :e B /\ b c= U).
			        apply andI.
			        - apply andI.
			          + exact HT0.
			          + exact Hf0.
			        - witness (Sing (product_space Empty Xi)).
			          prove ((Sing (product_space Empty Xi) c= countable_product_topology_subbasis Empty Xi /\ countable_set (Sing (product_space Empty Xi))) /\
			            (forall b:set, b :e Sing (product_space Empty Xi) -> f :e b)) /\
			              (forall U:set, U :e countable_product_topology_subbasis Empty Xi -> f :e U -> exists b:set, b :e Sing (product_space Empty Xi) /\ b c= U).
			          apply andI.
			          - apply andI.
			            + (** B c= Tx and countable_set **)
			              apply andI.
			              - (** B c= Tx **)
			                let b. assume Hb: b :e Sing (product_space Empty Xi).
			                prove b :e countable_product_topology_subbasis Empty Xi.
			                claim HbX0: b = product_space Empty Xi.
			                { exact (SingE (product_space Empty Xi) b Hb). }
			                rewrite HbX0.
			                exact (topology_has_X (product_space Empty Xi) (countable_product_topology_subbasis Empty Xi) HT0).
			              - (** countable_set B **)
			                exact (finite_countable (Sing (product_space Empty Xi)) (Sing_finite (product_space Empty Xi))).
			            + (** every b in B contains f **)
			              let b. assume Hb: b :e Sing (product_space Empty Xi).
			              prove f :e b.
			              claim HbX0: b = product_space Empty Xi.
			              { exact (SingE (product_space Empty Xi) b Hb). }
			              rewrite HbX0.
			              exact Hf0.
			          - (** neighborhood refinement **)
			            let U. assume HU: U :e countable_product_topology_subbasis Empty Xi.
			            assume HfU: f :e U.
			            prove exists b:set, b :e Sing (product_space Empty Xi) /\ b c= U.
			            witness (product_space Empty Xi).
			            apply andI.
			            + exact (SingI (product_space Empty Xi)).
			            + claim HX0eq: product_space Empty Xi = {Empty}.
			              { exact (product_space_empty_index Xi). }
			              claim Hf0eq: f = Empty.
			              { apply (SingE Empty f).
			                rewrite <- HX0eq.
			                exact Hf0. }
			              let y. assume HyX0: y :e product_space Empty Xi.
			              prove y :e U.
			              claim Hy0: y = Empty.
			              { apply (SingE Empty y).
			                rewrite <- HX0eq.
			                exact HyX0. }
			              rewrite Hy0.
			              rewrite <- Hf0eq.
			              exact HfU.
			      + assume HIn0: ~(I = Empty).
			        prove countable_basis_at (countable_product_space I Xi) (countable_product_topology_subbasis I Xi) f.
			        (** Expand the definition; only the existence of a countable local base is postponed. **)
			        claim HcompTop: forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i).
			        { let i. assume HiI: i :e I.
			          exact (andEL (topology_on (space_family_set Xi i) (space_family_topology Xi i))
			                       (forall x:set, x :e space_family_set Xi i -> countable_basis_at (space_family_set Xi i) (space_family_topology Xi i) x)
			                       (Hcomp i HiI)). }
			        claim HS: subbasis_on (product_space I Xi) (product_subbasis_full I Xi).
			        { exact (product_subbasis_full_subbasis_on I Xi HIn0 HcompTop). }
			        claim HB: basis_on (product_space I Xi) (basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi)).
			        { exact (finite_intersections_basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi) HS). }
			        claim HTprod: topology_on (product_space I Xi) (countable_product_topology_subbasis I Xi).
			        { exact (lemma_topology_from_basis (product_space I Xi) (basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi)) HB). }
			        prove topology_on (product_space I Xi) (countable_product_topology_subbasis I Xi) /\ f :e product_space I Xi /\
			          exists B:set, B c= countable_product_topology_subbasis I Xi /\ countable_set B /\
			            (forall b:set, b :e B -> f :e b) /\
			            (forall U:set, U :e countable_product_topology_subbasis I Xi -> f :e U -> exists b:set, b :e B /\ b c= U).
				        apply andI.
				        - apply andI.
				          + exact HTprod.
				          + exact Hf.
				        - claim Hcb: countable_basis_at (product_space I Xi) (countable_product_topology_subbasis I Xi) f.
				          { exact (product_countable_basis_at_point_if_components_first_countable I Xi f HIcount HIn0 Hcomp Hf). }
				          exact (andER (topology_on (product_space I Xi) (countable_product_topology_subbasis I Xi) /\ f :e product_space I Xi)
				                       (exists B:set, B c= countable_product_topology_subbasis I Xi /\ countable_set B /\
				                         (forall b:set, b :e B -> f :e b) /\
				                         (forall U:set, U :e countable_product_topology_subbasis I Xi -> f :e U -> exists b:set, b :e B /\ b c= U))
				                       Hcb).
		- (** second countable for countable products **)
		  let I Xi.
		  assume HIcount: countable_index_set I.
		  assume Hcomp: forall i:set, i :e I -> second_countable_space (space_family_set Xi i) (space_family_topology Xi i).
		  prove second_countable_space (countable_product_space I Xi) (countable_product_topology_subbasis I Xi).
	  prove topology_on (countable_product_space I Xi) (countable_product_topology_subbasis I Xi) /\
	       exists B:set, basis_on (countable_product_space I Xi) B /\ countable_set B /\ basis_generates (countable_product_space I Xi) B (countable_product_topology_subbasis I Xi).
	  apply andI.
		  - (** topology_on for product **)
		    apply (xm (I = Empty)).
		    + assume HI0: I = Empty.
		      rewrite HI0.
		      exact (countable_product_topology_subbasis_empty_is_topology Xi).
		    + assume HIn0: ~(I = Empty).
		      claim HcompTop: forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i).
		      { let i. assume HiI: i :e I.
		        exact (andEL (topology_on (space_family_set Xi i) (space_family_topology Xi i))
		                     (exists B0:set, basis_on (space_family_set Xi i) B0 /\ countable_set B0 /\ basis_generates (space_family_set Xi i) B0 (space_family_topology Xi i))
		                     (Hcomp i HiI)). }
		      claim HS: subbasis_on (product_space I Xi) (product_subbasis_full I Xi).
		      { exact (product_subbasis_full_subbasis_on I Xi HIn0 HcompTop). }
		      claim HB: basis_on (product_space I Xi) (basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi)).
		      { exact (finite_intersections_basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi) HS). }
		      exact (lemma_topology_from_basis (product_space I Xi) (basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi)) HB).
		  - (** existence of countable basis **)
			    apply (xm (I = Empty)).
			    + assume HI0: I = Empty.
			      rewrite HI0.
			      witness (Sing (product_space Empty Xi)).
			      apply andI.
			      - apply andI.
			        + exact (basis_on_singleton (product_space Empty Xi)).
			        + exact (finite_countable (Sing (product_space Empty Xi)) (Sing_finite (product_space Empty Xi))).
			      - (** basis_generates **)
			        prove basis_on (product_space Empty Xi) {product_space Empty Xi} /\
			          generated_topology (product_space Empty Xi) {product_space Empty Xi} = countable_product_topology_subbasis Empty Xi.
			        apply andI.
			        + exact (basis_on_singleton (product_space Empty Xi)).
			        + claim HTdef: countable_product_topology_subbasis Empty Xi =
			            generated_topology_from_subbasis (product_space Empty Xi) (product_subbasis_full Empty Xi).
			          { reflexivity. }
			          rewrite HTdef.
				          claim HS0: product_subbasis_full Empty Xi = Empty.
				          { exact (famunion_Empty (fun i:set => {product_cylinder Empty Xi i U|U :e space_family_topology Xi i})). }
				          rewrite HS0.
				          claim HGTS0: generated_topology_from_subbasis (product_space Empty Xi) Empty =
				            generated_topology (product_space Empty Xi) (basis_of_subbasis (product_space Empty Xi) Empty).
				          { reflexivity. }
				          rewrite HGTS0.
				          claim HX0ne: product_space Empty Xi <> Empty.
				          { assume HX0E: product_space Empty Xi = Empty.
				            claim Hem: Empty :e product_space Empty Xi.
			            { rewrite (product_space_empty_index Xi).
			              exact (SingI Empty). }
			            claim HemE: Empty :e Empty.
			            { rewrite <- HX0E at 2. exact Hem. }
			            exact (EmptyE Empty HemE False). }
			          claim HB0eq: basis_of_subbasis (product_space Empty Xi) Empty = {product_space Empty Xi}.
			          { exact (basis_of_subbasis_empty_eq (product_space Empty Xi) HX0ne). }
			          rewrite HB0eq.
			          reflexivity.
					    + assume HIn0: ~(I = Empty).
					      set Bsel : set->set := fun i =>
					        Eps_i (fun B0:set =>
					          basis_on (space_family_set Xi i) B0 /\ countable_set B0 /\ basis_generates (space_family_set Xi i) B0 (space_family_topology Xi i)).
					      set Ssmall : set := \/_ i :e I, {product_cylinder I Xi i U|U :e Bsel i}.
					      claim HBsel: forall i:set, i :e I ->
					        basis_on (space_family_set Xi i) (Bsel i) /\ countable_set (Bsel i) /\ basis_generates (space_family_set Xi i) (Bsel i) (space_family_topology Xi i).
					      { let i. assume HiI: i :e I.
					        claim HexB0: exists B0:set, basis_on (space_family_set Xi i) B0 /\ countable_set B0 /\ basis_generates (space_family_set Xi i) B0 (space_family_topology Xi i).
					        { exact (andER (topology_on (space_family_set Xi i) (space_family_topology Xi i))
					                      (exists B0:set, basis_on (space_family_set Xi i) B0 /\ countable_set B0 /\ basis_generates (space_family_set Xi i) B0 (space_family_topology Xi i))
					                      (Hcomp i HiI)). }
					        apply HexB0.
					        let B0. assume HB0: basis_on (space_family_set Xi i) B0 /\ countable_set B0 /\ basis_generates (space_family_set Xi i) B0 (space_family_topology Xi i).
					        exact (Eps_i_ax (fun B1:set => basis_on (space_family_set Xi i) B1 /\ countable_set B1 /\ basis_generates (space_family_set Xi i) B1 (space_family_topology Xi i)) B0 HB0). }
					      claim HSsmall: subbasis_on (product_space I Xi) Ssmall.
					      { prove Ssmall c= Power (product_space I Xi) /\ Union Ssmall = product_space I Xi.
					        apply andI.
					        - let s. assume Hs: s :e Ssmall.
					          prove s :e Power (product_space I Xi).
					          apply (famunionE_impred I (fun i0:set => {product_cylinder I Xi i0 U|U :e Bsel i0}) s Hs).
					          let i0. assume Hi0I. assume HsFi0: s :e {product_cylinder I Xi i0 U|U :e Bsel i0}.
					          apply (ReplE_impred (Bsel i0) (fun U0:set => product_cylinder I Xi i0 U0) s HsFi0).
					          let U0. assume HU0B: U0 :e Bsel i0.
					          assume HsEq: s = product_cylinder I Xi i0 U0.
					          rewrite HsEq.
					          apply PowerI.
					          let f0. assume Hf0: f0 :e product_cylinder I Xi i0 U0.
					          exact (SepE1 (product_space I Xi) (fun f1:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e U0) f0 Hf0).
					        - apply set_ext.
					          + let f0. assume Hf0: f0 :e Union Ssmall.
					            prove f0 :e product_space I Xi.
					            apply UnionE_impred Ssmall f0 Hf0.
					            let s. assume Hf0s: f0 :e s. assume Hs: s :e Ssmall.
						            apply (famunionE_impred I (fun i0:set => {product_cylinder I Xi i0 U|U :e Bsel i0}) s Hs).
						            let i0. assume Hi0I. assume HsFi0: s :e {product_cylinder I Xi i0 U|U :e Bsel i0}.
						            apply (ReplE_impred (Bsel i0) (fun U0:set => product_cylinder I Xi i0 U0) s HsFi0).
						            let U0. assume HU0B: U0 :e Bsel i0.
						            assume HsEq: s = product_cylinder I Xi i0 U0.
						            claim HsPow: s :e Power (product_space I Xi).
						            { rewrite HsEq.
						              apply PowerI.
						              let f1. assume Hf1: f1 :e product_cylinder I Xi i0 U0.
						              exact (SepE1 (product_space I Xi) (fun f2:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f2 i0 :e U0) f1 Hf1). }
						            claim HsSub: s c= product_space I Xi.
						            { exact (PowerE (product_space I Xi) s HsPow). }
						            exact (HsSub f0 Hf0s).
					          + let f0. assume Hf0: f0 :e product_space I Xi.
					            prove f0 :e Union Ssmall.
					            claim Hexi: exists i0:set, i0 :e I.
					            { exact (nonempty_has_element I HIn0). }
					            apply Hexi.
					            let i0. assume Hi0I: i0 :e I.
					            claim HBsel_i0c: basis_on (space_family_set Xi i0) (Bsel i0) /\ countable_set (Bsel i0).
					            { exact (andEL (basis_on (space_family_set Xi i0) (Bsel i0) /\ countable_set (Bsel i0))
					                           (basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0))
					                           (HBsel i0 Hi0I)). }
					            claim HBsel_i0: basis_on (space_family_set Xi i0) (Bsel i0).
					            { exact (andEL (basis_on (space_family_set Xi i0) (Bsel i0))
					                           (countable_set (Bsel i0))
					                           HBsel_i0c). }
					            claim HBcover: forall x :e space_family_set Xi i0, exists b :e Bsel i0, x :e b.
					            { exact (andER (Bsel i0 c= Power (space_family_set Xi i0))
					                           (forall x :e space_family_set Xi i0, exists b :e Bsel i0, x :e b)
					                           (andEL (Bsel i0 c= Power (space_family_set Xi i0) /\ (forall x :e space_family_set Xi i0, exists b :e Bsel i0, x :e b))
					                                  (forall b1 :e Bsel i0, forall b2 :e Bsel i0, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e Bsel i0, x :e b3 /\ b3 c= b1 :/\: b2)
					                                  HBsel_i0)). }
					            claim Hf0prop: function_on f0 I (space_family_union I Xi) /\ forall i:set, i :e I -> apply_fun f0 i :e space_family_set Xi i.
					            { exact (SepE2 (Power (setprod I (space_family_union I Xi)))
					                         (fun f1:set => function_on f1 I (space_family_union I Xi) /\ forall i:set, i :e I -> apply_fun f1 i :e space_family_set Xi i)
					                         f0 Hf0). }
					            claim Hcompf0: forall i:set, i :e I -> apply_fun f0 i :e space_family_set Xi i.
					            { exact (andER (function_on f0 I (space_family_union I Xi))
					                           (forall i:set, i :e I -> apply_fun f0 i :e space_family_set Xi i)
					                           Hf0prop). }
					            claim Hfi0: apply_fun f0 i0 :e space_family_set Xi i0.
					            { exact (Hcompf0 i0 Hi0I). }
					            apply (HBcover (apply_fun f0 i0) Hfi0).
					            let U0. assume HU0pair.
					            claim HU0B: U0 :e Bsel i0.
					            { exact (andEL (U0 :e Bsel i0) (apply_fun f0 i0 :e U0) HU0pair). }
					            claim Hfi0U0: apply_fun f0 i0 :e U0.
					            { exact (andER (U0 :e Bsel i0) (apply_fun f0 i0 :e U0) HU0pair). }
					            claim HBgen_i0: basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0).
					            { exact (andER (basis_on (space_family_set Xi i0) (Bsel i0) /\ countable_set (Bsel i0))
					                           (basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0))
					                           (HBsel i0 Hi0I)). }
					            claim HTeq: generated_topology (space_family_set Xi i0) (Bsel i0) = space_family_topology Xi i0.
					            { exact (andER (basis_on (space_family_set Xi i0) (Bsel i0))
					                           (generated_topology (space_family_set Xi i0) (Bsel i0) = space_family_topology Xi i0)
					                           HBgen_i0). }
					            claim HU0Gen: U0 :e generated_topology (space_family_set Xi i0) (Bsel i0).
					            { exact (generated_topology_contains_basis (space_family_set Xi i0) (Bsel i0) HBsel_i0 U0 HU0B). }
					            claim HU0Top: U0 :e space_family_topology Xi i0.
					            { rewrite <- HTeq. exact HU0Gen. }
					            set C0 : set := product_cylinder I Xi i0 U0.
					            claim Hf0C0: f0 :e C0.
					            { exact (SepI (product_space I Xi) (fun f1:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e U0)
					                         f0 Hf0 (andI (i0 :e I /\ U0 :e space_family_topology Xi i0) (apply_fun f0 i0 :e U0)
					                                      (andI (i0 :e I) (U0 :e space_family_topology Xi i0) Hi0I HU0Top) Hfi0U0)). }
					            claim HC0in: C0 :e Ssmall.
					            { exact (famunionI I (fun i1:set => {product_cylinder I Xi i1 U|U :e Bsel i1})
					                             i0 C0 Hi0I (ReplI (Bsel i0) (fun U:set => product_cylinder I Xi i0 U) U0 HU0B)). }
					            exact (UnionI Ssmall f0 C0 Hf0C0 HC0in). }
					      witness (basis_of_subbasis (product_space I Xi) Ssmall).
					      apply andI.
					      - (** basis_on and countable_set **)
					        apply andI.
					        + claim HS: subbasis_on (product_space I Xi) Ssmall.
					          { exact HSsmall. }
					          exact (finite_intersections_basis_of_subbasis (product_space I Xi) Ssmall HS).
						        + (** countable_set of basis_of_subbasis from a countable subbasis **)
						          claim HSsmall_count: countable_set Ssmall.
						          { (** show Ssmall is an image of a countable dependent sum **)
						            claim HIc: countable I.
						            { exact HIcount. }
						            claim HBsel_count: forall i:set, i :e I -> countable (Bsel i).
						            { let i. assume HiI: i :e I.
						              claim HBi: basis_on (space_family_set Xi i) (Bsel i) /\ countable_set (Bsel i).
						              { exact (andEL (basis_on (space_family_set Xi i) (Bsel i) /\ countable_set (Bsel i))
						                             (basis_generates (space_family_set Xi i) (Bsel i) (space_family_topology Xi i))
						                             (HBsel i HiI)). }
						              exact (andER (basis_on (space_family_set Xi i) (Bsel i))
						                           (countable_set (Bsel i))
						                           HBi). }
						            claim HSig: countable (Sigma_ i :e I, Bsel i).
						            { exact (Sigma_countable I HIc Bsel HBsel_count). }
						            claim HSig_set: countable_set (Sigma_ i :e I, Bsel i).
						            { exact HSig. }
						            set F : set -> set := fun p => product_cylinder I Xi (p 0) (p 1).
						            set Img := {F p|p :e Sigma_ i :e I, Bsel i}.
						            claim HImg_count: countable_set Img.
						            { exact (countable_image (Sigma_ i :e I, Bsel i) HSig_set F). }
						            apply (Subq_countable Ssmall Img).
						            - exact HImg_count.
						            - let s. assume Hs: s :e Ssmall.
						              prove s :e Img.
						              apply (famunionE_impred I (fun i0:set => {product_cylinder I Xi i0 U|U :e Bsel i0}) s Hs).
						              let i0. assume Hi0I: i0 :e I.
						              assume HsFi0: s :e {product_cylinder I Xi i0 U|U :e Bsel i0}.
						              apply (ReplE_impred (Bsel i0) (fun U0:set => product_cylinder I Xi i0 U0) s HsFi0).
						              let U0. assume HU0B: U0 :e Bsel i0.
						              assume HsEq: s = product_cylinder I Xi i0 U0.
							              claim HpSig: (i0,U0) :e Sigma_ i :e I, Bsel i.
							              { exact (tuple_2_Sigma I Bsel i0 Hi0I U0 HU0B). }
							              claim HFp: F (i0,U0) = product_cylinder I Xi i0 U0.
							              { claim HFdef: F (i0,U0) = product_cylinder I Xi ((i0,U0) 0) ((i0,U0) 1).
							                { reflexivity. }
							                rewrite HFdef.
							                rewrite (tuple_2_0_eq i0 U0).
							                rewrite (tuple_2_1_eq i0 U0).
							                reflexivity. }
							              rewrite HsEq.
							              rewrite <- HFp.
							              exact (ReplI (Sigma_ i :e I, Bsel i) F (i0,U0) HpSig). }
						          exact (basis_of_subbasis_countable (product_space I Xi) Ssmall HSsmall_count).
					      - (** basis_generates **)
					        prove basis_on (product_space I Xi) (basis_of_subbasis (product_space I Xi) Ssmall) /\
					          generated_topology (product_space I Xi) (basis_of_subbasis (product_space I Xi) Ssmall) = countable_product_topology_subbasis I Xi.
					        apply andI.
					        + claim HS: subbasis_on (product_space I Xi) Ssmall.
					          { exact HSsmall. }
					          exact (finite_intersections_basis_of_subbasis (product_space I Xi) Ssmall HS).
					        + (** generated_topology equality with cylinder subbasis **)
					          claim HGTSsmall: generated_topology_from_subbasis (product_space I Xi) Ssmall =
					            generated_topology (product_space I Xi) (basis_of_subbasis (product_space I Xi) Ssmall).
					          { reflexivity. }
					          rewrite <- HGTSsmall.
					          claim HcompTop2: forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i).
					          { let i. assume HiI: i :e I.
					            exact (andEL (topology_on (space_family_set Xi i) (space_family_topology Xi i))
					                         (exists B0:set, basis_on (space_family_set Xi i) B0 /\ countable_set B0 /\ basis_generates (space_family_set Xi i) B0 (space_family_topology Xi i))
					                         (Hcomp i HiI)). }
					          claim HSfull: subbasis_on (product_space I Xi) (product_subbasis_full I Xi).
					          { exact (product_subbasis_full_subbasis_on I Xi HIn0 HcompTop2). }
					          claim HTdef: countable_product_topology_subbasis I Xi =
					            generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi).
					          { reflexivity. }
					          rewrite HTdef.
					          (** Compare generated topologies from the two subbases Ssmall and product_subbasis_full **)
					          apply set_ext.
					          + let U. assume HU: U :e generated_topology_from_subbasis (product_space I Xi) Ssmall.
					            prove U :e generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi).
					            claim HTfull: topology_on (product_space I Xi)
					              (generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi)).
					            { exact (topology_from_subbasis_is_topology (product_space I Xi) (product_subbasis_full I Xi) HSfull). }
					            claim HBfull: basis_on (product_space I Xi)
					              (basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi)).
					            { exact (finite_intersections_basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi) HSfull). }
					            claim HSsmall_sub_Tfull: Ssmall c=
					              generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi).
					            { let s. assume Hs: s :e Ssmall.
					              prove s :e generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi).
					              apply (famunionE_impred I (fun i0:set => {product_cylinder I Xi i0 U0|U0 :e Bsel i0}) s Hs).
					              let i0. assume Hi0I. assume HsFi0: s :e {product_cylinder I Xi i0 U0|U0 :e Bsel i0}.
					              apply (ReplE_impred (Bsel i0) (fun U0:set => product_cylinder I Xi i0 U0) s HsFi0).
					              let U0. assume HU0B: U0 :e Bsel i0.
					              assume HsEq: s = product_cylinder I Xi i0 U0.
					              claim HBsel_i0c: basis_on (space_family_set Xi i0) (Bsel i0) /\ countable_set (Bsel i0).
					              { exact (andEL (basis_on (space_family_set Xi i0) (Bsel i0) /\ countable_set (Bsel i0))
					                             (basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0))
					                             (HBsel i0 Hi0I)). }
					              claim HBsel_i0: basis_on (space_family_set Xi i0) (Bsel i0).
					              { exact (andEL (basis_on (space_family_set Xi i0) (Bsel i0))
					                             (countable_set (Bsel i0))
					                             HBsel_i0c). }
					              claim HBgen_i0: basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0).
					              { exact (andER (basis_on (space_family_set Xi i0) (Bsel i0) /\ countable_set (Bsel i0))
					                             (basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0))
					                             (HBsel i0 Hi0I)). }
					              claim HTeq_i0: generated_topology (space_family_set Xi i0) (Bsel i0) = space_family_topology Xi i0.
					              { exact (andER (basis_on (space_family_set Xi i0) (Bsel i0))
					                             (generated_topology (space_family_set Xi i0) (Bsel i0) = space_family_topology Xi i0)
					                             HBgen_i0). }
					              claim HU0Gen: U0 :e generated_topology (space_family_set Xi i0) (Bsel i0).
					              { exact (generated_topology_contains_basis (space_family_set Xi i0) (Bsel i0) HBsel_i0 U0 HU0B). }
					              claim HU0Top: U0 :e space_family_topology Xi i0.
					              { rewrite <- HTeq_i0. exact HU0Gen. }
					              claim HsSfull: s :e product_subbasis_full I Xi.
					              { rewrite HsEq.
					                exact (famunionI I (fun i1:set => {product_cylinder I Xi i1 U|U :e space_family_topology Xi i1})
					                         i0 (product_cylinder I Xi i0 U0) Hi0I
					                         (ReplI (space_family_topology Xi i0) (fun U:set => product_cylinder I Xi i0 U) U0 HU0Top)). }
					              apply (xm (s = Empty)).
					              - assume HsE: s = Empty.
					                rewrite HsE.
					                exact (topology_has_empty (product_space I Xi)
					                      (generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi)) HTfull).
					              - assume HsNE: ~(s = Empty).
					                claim HsBasis: s :e basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi).
					                { exact (subbasis_elem_in_basis (product_space I Xi) (product_subbasis_full I Xi) s HSfull HsSfull HsNE). }
					                exact (basis_in_generated (product_space I Xi)
					                      (basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi))
					                      s HBfull HsBasis).
					            }
					            claim Hinc: generated_topology_from_subbasis (product_space I Xi) Ssmall c=
					              generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi).
					            { exact (topology_generated_by_basis_is_minimal (product_space I Xi) Ssmall
					                      (generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi))
					                      HSsmall HTfull HSsmall_sub_Tfull). }
					            exact (Hinc U HU).
					          + let U. assume HU: U :e generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi).
					            prove U :e generated_topology_from_subbasis (product_space I Xi) Ssmall.
					            claim HTsmall: topology_on (product_space I Xi)
					              (generated_topology_from_subbasis (product_space I Xi) Ssmall).
					            { exact (topology_from_subbasis_is_topology (product_space I Xi) Ssmall HSsmall). }
					            claim HSfull_sub_Tsmall: product_subbasis_full I Xi c=
					              generated_topology_from_subbasis (product_space I Xi) Ssmall.
					            { let s. assume HsSfull: s :e product_subbasis_full I Xi.
					              prove s :e generated_topology_from_subbasis (product_space I Xi) Ssmall.
					              set Bsm := basis_of_subbasis (product_space I Xi) Ssmall.
					              claim HBsmBasis: basis_on (product_space I Xi) Bsm.
					              { exact (finite_intersections_basis_of_subbasis (product_space I Xi) Ssmall HSsmall). }
					              claim HGTS: generated_topology_from_subbasis (product_space I Xi) Ssmall =
					                generated_topology (product_space I Xi) Bsm.
					              { reflexivity. }
					              rewrite HGTS.
					              (** Destructure s as a cylinder at some coordinate **)
					              apply (famunionE_impred I (fun i0:set => {product_cylinder I Xi i0 U0|U0 :e space_family_topology Xi i0}) s HsSfull).
					              let i0. assume Hi0I. assume HsFi0: s :e {product_cylinder I Xi i0 U0|U0 :e space_family_topology Xi i0}.
					              apply (ReplE_impred (space_family_topology Xi i0) (fun U0:set => product_cylinder I Xi i0 U0) s HsFi0).
					              let U0. assume HU0Top: U0 :e space_family_topology Xi i0.
					              assume HsEq: s = product_cylinder I Xi i0 U0.
					              (** Represent U0 as union of basis elements from Bsel i0 **)
					              claim HBsel_i0c: basis_on (space_family_set Xi i0) (Bsel i0) /\ countable_set (Bsel i0).
					              { exact (andEL (basis_on (space_family_set Xi i0) (Bsel i0) /\ countable_set (Bsel i0))
					                             (basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0))
					                             (HBsel i0 Hi0I)). }
					              claim HBsel_i0: basis_on (space_family_set Xi i0) (Bsel i0).
					              { exact (andEL (basis_on (space_family_set Xi i0) (Bsel i0))
					                             (countable_set (Bsel i0))
					                             HBsel_i0c). }
					              claim HBgen_i0: basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0).
					              { exact (andER (basis_on (space_family_set Xi i0) (Bsel i0) /\ countable_set (Bsel i0))
					                             (basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0))
					                             (HBsel i0 Hi0I)). }
					              claim HTeq_i0: generated_topology (space_family_set Xi i0) (Bsel i0) = space_family_topology Xi i0.
					              { exact (andER (basis_on (space_family_set Xi i0) (Bsel i0))
					                             (generated_topology (space_family_set Xi i0) (Bsel i0) = space_family_topology Xi i0)
					                             HBgen_i0). }
					              claim HU0Gen: U0 :e generated_topology (space_family_set Xi i0) (Bsel i0).
					              { rewrite HTeq_i0. exact HU0Top. }
					              claim HTgen: topology_on (space_family_set Xi i0) (generated_topology (space_family_set Xi i0) (Bsel i0)).
					              { exact (lemma_topology_from_basis (space_family_set Xi i0) (Bsel i0) HBsel_i0). }
					              claim HU0open: open_in (space_family_set Xi i0) (generated_topology (space_family_set Xi i0) (Bsel i0)) U0.
					              { exact (andI (topology_on (space_family_set Xi i0) (generated_topology (space_family_set Xi i0) (Bsel i0)))
					                           (U0 :e generated_topology (space_family_set Xi i0) (Bsel i0))
					                           HTgen HU0Gen). }
					              claim HexFam: exists Fam :e Power (Bsel i0), Union Fam = U0.
					              { exact (open_sets_as_unions_of_basis (space_family_set Xi i0) (Bsel i0) HBsel_i0 U0 HU0open). }
					              apply HexFam.
					              let Fam. assume HFampair.
					              claim HFamPow: Fam :e Power (Bsel i0).
					              { exact (andEL (Fam :e Power (Bsel i0)) (Union Fam = U0) HFampair). }
					              claim HUnionFam: Union Fam = U0.
					              { exact (andER (Fam :e Power (Bsel i0)) (Union Fam = U0) HFampair). }
					              claim HFamSub: Fam c= Bsel i0.
					              { exact (PowerE (Bsel i0) Fam HFamPow). }
					              set FamCyl := {product_cylinder I Xi i0 V|V :e Fam}.
					              claim HUnionCyl: Union FamCyl = product_cylinder I Xi i0 U0.
					              { apply set_ext.
					                - let f. assume HfU: f :e Union FamCyl.
					                  prove f :e product_cylinder I Xi i0 U0.
					                  apply (UnionE_impred FamCyl f HfU).
					                  let c. assume Hfc: f :e c. assume Hc: c :e FamCyl.
					                  apply (ReplE_impred Fam (fun V0:set => product_cylinder I Xi i0 V0) c Hc).
					                  let V0. assume HV0Fam: V0 :e Fam.
					                  assume HcEq: c = product_cylinder I Xi i0 V0.
					                  claim HV0B: V0 :e Bsel i0.
					                  { exact (HFamSub V0 HV0Fam). }
					                  claim HV0subU0: V0 c= U0.
					                  { let x. assume HxV0: x :e V0.
					                    claim HxUF: x :e Union Fam.
					                    { exact (UnionI Fam x V0 HxV0 HV0Fam). }
						                    rewrite <- HUnionFam.
						                    exact HxUF. }
					                  claim HfCylV0: f :e product_cylinder I Xi i0 V0.
					                  { rewrite <- HcEq. exact Hfc. }
					                  claim HfX: f :e product_space I Xi.
					                  { exact (SepE1 (product_space I Xi) (fun f1:set => i0 :e I /\ V0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e V0) f HfCylV0). }
					                  claim Hfcond: (i0 :e I /\ V0 :e space_family_topology Xi i0) /\ apply_fun f i0 :e V0.
					                  { exact (SepE2 (product_space I Xi) (fun f1:set => i0 :e I /\ V0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e V0) f HfCylV0). }
					                  claim Hfi0V0: apply_fun f i0 :e V0.
					                  { exact (andER (i0 :e I /\ V0 :e space_family_topology Xi i0) (apply_fun f i0 :e V0) Hfcond). }
						                  claim Hfi0U0: apply_fun f i0 :e U0.
						                  { exact (HV0subU0 (apply_fun f i0) Hfi0V0). }
						                  claim HpredU0: (i0 :e I /\ U0 :e space_family_topology Xi i0) /\ apply_fun f i0 :e U0.
						                  { apply andI.
						                    - apply andI.
						                      + exact Hi0I.
						                      + exact HU0Top.
						                    - exact Hfi0U0. }
						                  exact (SepI (product_space I Xi) (fun f1:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e U0)
						                             f HfX HpredU0).
					                - let f. assume HfC: f :e product_cylinder I Xi i0 U0.
					                  prove f :e Union FamCyl.
					                  claim Hfcond: (i0 :e I /\ U0 :e space_family_topology Xi i0) /\ apply_fun f i0 :e U0.
					                  { exact (SepE2 (product_space I Xi) (fun f1:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e U0) f HfC). }
					                  claim Hfi0U0: apply_fun f i0 :e U0.
					                  { exact (andER (i0 :e I /\ U0 :e space_family_topology Xi i0) (apply_fun f i0 :e U0) Hfcond). }
					                  claim Hfi0UF: apply_fun f i0 :e Union Fam.
					                  { rewrite HUnionFam. exact Hfi0U0. }
					                  apply (UnionE_impred Fam (apply_fun f i0) Hfi0UF).
					                  let V0. assume Hfi0V0: apply_fun f i0 :e V0. assume HV0Fam: V0 :e Fam.
					                  set C0 := product_cylinder I Xi i0 V0.
					                  claim HC0Fam: C0 :e FamCyl.
					                  { exact (ReplI Fam (fun V1:set => product_cylinder I Xi i0 V1) V0 HV0Fam). }
						                  claim HfC0: f :e C0.
						                  { claim HfX: f :e product_space I Xi.
						                    { exact (SepE1 (product_space I Xi) (fun f1:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e U0) f HfC). }
						                    claim HV0B: V0 :e Bsel i0.
						                    { exact (HFamSub V0 HV0Fam). }
						                    claim HBgen_i0T: basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0).
						                    { exact (andER (basis_on (space_family_set Xi i0) (Bsel i0) /\ countable_set (Bsel i0))
						                                   (basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0))
						                                   (HBsel i0 Hi0I)). }
						                    claim HTeq2: generated_topology (space_family_set Xi i0) (Bsel i0) = space_family_topology Xi i0.
						                    { exact (andER (basis_on (space_family_set Xi i0) (Bsel i0))
						                                   (generated_topology (space_family_set Xi i0) (Bsel i0) = space_family_topology Xi i0)
						                                   HBgen_i0T). }
						                    claim HV0Gen: V0 :e generated_topology (space_family_set Xi i0) (Bsel i0).
						                    { exact (generated_topology_contains_basis (space_family_set Xi i0) (Bsel i0) HBsel_i0 V0 HV0B). }
						                    claim HV0Top: V0 :e space_family_topology Xi i0.
						                    { rewrite <- HTeq2. exact HV0Gen. }
						                    claim HpredV0: (i0 :e I /\ V0 :e space_family_topology Xi i0) /\ apply_fun f i0 :e V0.
						                    { apply andI.
						                      - apply andI.
						                        + exact Hi0I.
						                        + exact HV0Top.
						                      - exact Hfi0V0. }
						                    exact (SepI (product_space I Xi) (fun f1:set => i0 :e I /\ V0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e V0)
						                               f HfX HpredV0). }
					                  exact (UnionI FamCyl f C0 HfC0 HC0Fam). }
						              (** Restrict to nonempty cylinders to get a family of basis elements **)
						              set FamCylN := {c :e FamCyl|c <> Empty}.
						              claim HFamCylNPow: FamCylN :e Power Bsm.
						              { claim HFamCylNsub: FamCylN c= Bsm.
						                { let c. assume HcN: c :e FamCylN.
						                  prove c :e Bsm.
						                  claim HcFam: c :e FamCyl.
						                  { exact (SepE1 FamCyl (fun c0:set => c0 <> Empty) c HcN). }
						                  claim HcNe: c <> Empty.
						                  { exact (SepE2 FamCyl (fun c0:set => c0 <> Empty) c HcN). }
						                  apply (ReplE_impred Fam (fun V0:set => product_cylinder I Xi i0 V0) c HcFam).
						                  let V0. assume HV0Fam: V0 :e Fam.
						                  assume HcEq: c = product_cylinder I Xi i0 V0.
						                  claim HV0B: V0 :e Bsel i0.
						                  { exact (HFamSub V0 HV0Fam). }
						                  claim HC0in: product_cylinder I Xi i0 V0 :e Ssmall.
						                  { exact (famunionI I (fun i1:set => {product_cylinder I Xi i1 U|U :e Bsel i1})
						                           i0 (product_cylinder I Xi i0 V0) Hi0I
						                           (ReplI (Bsel i0) (fun U:set => product_cylinder I Xi i0 U) V0 HV0B)). }
						                  claim HC0S: c :e Ssmall.
						                  { rewrite HcEq. exact HC0in. }
						                  exact (subbasis_elem_in_basis (product_space I Xi) Ssmall c HSsmall HC0S HcNe). }
						                exact (PowerI Bsm FamCylN HFamCylNsub). }
					              claim HUnionN: Union FamCylN = Union FamCyl.
					              { apply set_ext.
					                - let f. assume HfUN: f :e Union FamCylN.
					                  prove f :e Union FamCyl.
					                  apply (UnionE_impred FamCylN f HfUN).
					                  let c. assume Hfc: f :e c. assume HcN: c :e FamCylN.
					                  claim HcFam: c :e FamCyl.
					                  { exact (SepE1 FamCyl (fun c0:set => c0 <> Empty) c HcN). }
					                  exact (UnionI FamCyl f c Hfc HcFam).
					                - let f. assume HfU: f :e Union FamCyl.
					                  prove f :e Union FamCylN.
					                  apply (UnionE_impred FamCyl f HfU).
					                  let c. assume Hfc: f :e c. assume HcFam: c :e FamCyl.
						                  claim HcNe: c <> Empty.
						                  { assume HcE: c = Empty.
						                    claim Hbad: f :e Empty.
						                    { rewrite <- HcE. exact Hfc. }
						                    exact (EmptyE f Hbad False). }
					                  claim HcN: c :e FamCylN.
					                  { exact (SepI FamCyl (fun c0:set => c0 <> Empty) c HcFam HcNe). }
					                  exact (UnionI FamCylN f c Hfc HcN). }
							              claim HopenS: open_in (product_space I Xi) (generated_topology (product_space I Xi) Bsm) s.
							              { apply (basis_generates_open_sets (product_space I Xi) Bsm HBsmBasis s).
							                witness FamCylN.
							                apply andI.
							                - exact HFamCylNPow.
							                - apply set_ext.
							                  + let f. assume HfU: f :e Union FamCylN.
							                    prove f :e s.
							                    apply (UnionE_impred FamCylN f HfU).
							                    let c. assume Hfc: f :e c. assume HcN: c :e FamCylN.
							                    claim HcFam: c :e FamCyl.
							                    { exact (SepE1 FamCyl (fun c0:set => c0 <> Empty) c HcN). }
							                    apply (ReplE_impred Fam (fun V0:set => product_cylinder I Xi i0 V0) c HcFam).
							                    let V0. assume HV0Fam: V0 :e Fam.
							                    assume HcEq: c = product_cylinder I Xi i0 V0.
							                    claim HV0subU0: V0 c= U0.
							                    { let x. assume HxV0: x :e V0.
							                      claim HxUF: x :e Union Fam.
							                      { exact (UnionI Fam x V0 HxV0 HV0Fam). }
							                      rewrite <- HUnionFam.
							                      exact HxUF. }
							                    claim HfCylV0: f :e product_cylinder I Xi i0 V0.
							                    { rewrite <- HcEq. exact Hfc. }
							                    claim HfX: f :e product_space I Xi.
							                    { exact (SepE1 (product_space I Xi) (fun f1:set => i0 :e I /\ V0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e V0) f HfCylV0). }
							                    claim Hfcond: (i0 :e I /\ V0 :e space_family_topology Xi i0) /\ apply_fun f i0 :e V0.
							                    { exact (SepE2 (product_space I Xi) (fun f1:set => i0 :e I /\ V0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e V0) f HfCylV0). }
							                    claim Hfi0V0: apply_fun f i0 :e V0.
							                    { exact (andER (i0 :e I /\ V0 :e space_family_topology Xi i0) (apply_fun f i0 :e V0) Hfcond). }
							                    claim Hfi0U0: apply_fun f i0 :e U0.
							                    { exact (HV0subU0 (apply_fun f i0) Hfi0V0). }
							                    claim HpredU0: (i0 :e I /\ U0 :e space_family_topology Xi i0) /\ apply_fun f i0 :e U0.
							                    { apply andI.
							                      - apply andI.
							                        + exact Hi0I.
							                        + exact HU0Top.
							                      - exact Hfi0U0. }
							                    rewrite HsEq.
							                    exact (SepI (product_space I Xi) (fun f1:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e U0)
							                               f HfX HpredU0).
							                  + let f. assume HfS: f :e s.
							                    prove f :e Union FamCylN.
							                    claim HfCylU0: f :e product_cylinder I Xi i0 U0.
							                    { rewrite <- HsEq. exact HfS. }
							                    claim Hfcond: (i0 :e I /\ U0 :e space_family_topology Xi i0) /\ apply_fun f i0 :e U0.
							                    { exact (SepE2 (product_space I Xi) (fun f1:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e U0) f HfCylU0). }
							                    claim Hfi0U0: apply_fun f i0 :e U0.
							                    { exact (andER (i0 :e I /\ U0 :e space_family_topology Xi i0) (apply_fun f i0 :e U0) Hfcond). }
							                    claim Hfi0UF: apply_fun f i0 :e Union Fam.
							                    { rewrite HUnionFam. exact Hfi0U0. }
							                    apply (UnionE_impred Fam (apply_fun f i0) Hfi0UF).
							                    let V0. assume Hfi0V0: apply_fun f i0 :e V0. assume HV0Fam: V0 :e Fam.
							                    set C0 := product_cylinder I Xi i0 V0.
							                    claim HC0Fam: C0 :e FamCyl.
							                    { exact (ReplI Fam (fun V1:set => product_cylinder I Xi i0 V1) V0 HV0Fam). }
							                    claim HfC0: f :e C0.
							                    { claim HfX: f :e product_space I Xi.
							                      { exact (SepE1 (product_space I Xi) (fun f1:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e U0) f HfCylU0). }
								                      claim HpredV0: (i0 :e I /\ V0 :e space_family_topology Xi i0) /\ apply_fun f i0 :e V0.
								                      { apply andI.
								                        - apply andI.
								                          + exact Hi0I.
								                          + claim HV0B: V0 :e Bsel i0.
								                            { exact (HFamSub V0 HV0Fam). }
								                            claim HV0Gen: V0 :e generated_topology (space_family_set Xi i0) (Bsel i0).
								                            { exact (generated_topology_contains_basis (space_family_set Xi i0) (Bsel i0) HBsel_i0 V0 HV0B). }
								                            claim HV0Top: V0 :e space_family_topology Xi i0.
								                            { rewrite <- HTeq_i0. exact HV0Gen. }
								                            exact HV0Top.
								                        - exact Hfi0V0. }
							                      exact (SepI (product_space I Xi) (fun f1:set => i0 :e I /\ V0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e V0)
							                                 f HfX HpredV0). }
							                    claim HC0ne: C0 <> Empty.
							                    { assume HC0E: C0 = Empty.
							                      claim Hbad: f :e Empty.
							                      { rewrite <- HC0E. exact HfC0. }
							                      exact (EmptyE f Hbad False). }
							                    claim HC0N: C0 :e FamCylN.
							                    { exact (SepI FamCyl (fun c0:set => c0 <> Empty) C0 HC0Fam HC0ne). }
							                    exact (UnionI FamCylN f C0 HfC0 HC0N). }
					              exact (andER (topology_on (product_space I Xi) (generated_topology (product_space I Xi) Bsm))
					                           (s :e generated_topology (product_space I Xi) Bsm)
					                           HopenS). }
					            claim Hinc: generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi) c=
					              generated_topology_from_subbasis (product_space I Xi) Ssmall.
					            { exact (topology_generated_by_basis_is_minimal (product_space I Xi) (product_subbasis_full I Xi)
					                      (generated_topology_from_subbasis (product_space I Xi) Ssmall)
					                      HSfull HTsmall HSfull_sub_Tsmall). }
					            exact (Hinc U HU).
Qed.

(** from 30 Definition: dense subset **) 
(** LATEX VERSION: A is dense in X if its closure equals X. **)
Definition dense_in : set -> set -> set -> prop := fun A X Tx => closure_of X Tx A = X.

(** from 30 Theorem 30.3(a): countable basis implies Lindelf **) 
(** LATEX VERSION: A second-countable space is Lindelf (every open cover has countable subcover). **)
Theorem countable_basis_implies_Lindelof : forall X Tx:set,
  topology_on X Tx ->
  second_countable_space X Tx ->
  forall U:set, open_cover X Tx U -> exists V:set, countable_subcollection V U /\ covers X V.
let X Tx.
assume HTx: topology_on X Tx.
assume Hscc: second_countable_space X Tx.
let U.
assume HU: open_cover X Tx U.
prove exists V:set, countable_subcollection V U /\ covers X V.
claim HUopen: forall u:set, u :e U -> u :e Tx.
{ exact (andEL (forall u:set, u :e U -> u :e Tx) (covers X U) HU). }
claim HUcov: covers X U.
{ exact (andER (forall u:set, u :e U -> u :e Tx) (covers X U) HU). }
claim HexB: exists B:set, basis_on X B /\ countable_set B /\ basis_generates X B Tx.
{ exact (andER (topology_on X Tx) (exists B:set, basis_on X B /\ countable_set B /\ basis_generates X B Tx) Hscc). }
apply HexB.
let B. assume HBpair.
claim HBmid: (basis_on X B /\ countable_set B) /\ basis_generates X B Tx.
{ exact HBpair. }
claim HBasisCount: basis_on X B /\ countable_set B.
{ exact (andEL (basis_on X B /\ countable_set B) (basis_generates X B Tx) HBmid). }
claim HBgener: basis_generates X B Tx.
{ exact (andER (basis_on X B /\ countable_set B) (basis_generates X B Tx) HBmid). }
claim HBasis: basis_on X B.
{ exact (andEL (basis_on X B) (countable_set B) HBasisCount). }
claim HBcount: countable_set B.
{ exact (andER (basis_on X B) (countable_set B) HBasisCount). }
claim HgenEq: generated_topology X B = Tx.
{ exact (andER (basis_on X B) (generated_topology X B = Tx) HBgener). }
(** basis elements that refine the cover **)
set B0 := {b :e B | exists u:set, u :e U /\ b c= u}.
set choose : set->set := fun b => Eps_i (fun u => u :e U /\ b c= u).
set V := {choose b|b :e B0}.
witness V.
apply andI.
- (** V is a countable subcollection of U **)
  prove countable_subcollection V U.
  prove V c= U /\ countable_set V.
  apply andI.
  + (** V c= U **)
    let v. assume Hv: v :e V.
    prove v :e U.
    apply (ReplE_impred B0 choose v Hv).
    let b.
    assume Hb0: b :e B0.
    assume HvEq: v = choose b.
    claim Hb0prop: exists u:set, u :e U /\ b c= u.
    { exact (SepE2 B (fun b0:set => exists u:set, u :e U /\ b0 c= u) b Hb0). }
    apply Hb0prop.
    let u.
    assume Hupair: u :e U /\ b c= u.
    claim Hchooseprop: choose b :e U /\ b c= choose b.
    { exact (Eps_i_ax (fun u0 => u0 :e U /\ b c= u0) u Hupair). }
    claim HchooseU: choose b :e U.
    { exact (andEL (choose b :e U) (b c= choose b) Hchooseprop). }
    rewrite HvEq.
    exact HchooseU.
  + (** countable_set V **)
    claim HB0sub: B0 c= B.
    { let b. assume Hb0: b :e B0.
      exact (SepE1 B (fun b0:set => exists u:set, u :e U /\ b0 c= u) b Hb0). }
    claim HB0count: countable_set B0.
    { exact (Subq_countable B0 B HBcount HB0sub). }
    exact (countable_image B0 HB0count choose).
- (** V covers X **)
  prove covers X V.
  let x. assume HxX: x :e X.
  apply (HUcov x HxX).
  let u. assume Hupair.
  claim HuU: u :e U.
  { exact (andEL (u :e U) (x :e u) Hupair). }
  claim Hxu: x :e u.
  { exact (andER (u :e U) (x :e u) Hupair). }
  claim HuTx: u :e Tx.
  { exact (HUopen u HuU). }
  claim HuGen: u :e generated_topology X B.
  { rewrite HgenEq. exact HuTx. }
  claim Href: forall z :e u, exists b :e B, z :e b /\ b c= u.
  { exact (SepE2 (Power X) (fun U0:set => forall z :e U0, exists b :e B, z :e b /\ b c= U0) u HuGen). }
  claim Hexb: exists b :e B, x :e b /\ b c= u.
  { exact (Href x Hxu). }
  apply Hexb.
  let b. assume Hbpair.
  claim HbB: b :e B.
  { exact (andEL (b :e B) (x :e b /\ b c= u) Hbpair). }
  claim Hbprop: x :e b /\ b c= u.
  { exact (andER (b :e B) (x :e b /\ b c= u) Hbpair). }
  claim Hxb: x :e b.
  { exact (andEL (x :e b) (b c= u) Hbprop). }
  claim Hbsubu: b c= u.
  { exact (andER (x :e b) (b c= u) Hbprop). }
  claim Hb0: b :e B0.
  { apply (SepI B (fun b0:set => exists u0:set, u0 :e U /\ b0 c= u0) b HbB).
    witness u.
    apply andI.
    - exact HuU.
    - exact Hbsubu. }
  claim Hchooseprop: choose b :e U /\ b c= choose b.
  { exact (Eps_i_ax (fun u0 => u0 :e U /\ b c= u0) u (andI (u :e U) (b c= u) HuU Hbsubu)). }
  claim Hbsubchoose: b c= choose b.
  { exact (andER (choose b :e U) (b c= choose b) Hchooseprop). }
  claim Hxchoose: x :e choose b.
  { exact (Hbsubchoose x Hxb). }
  witness choose b.
  apply andI.
  + exact (ReplI B0 choose b Hb0).
  + exact Hxchoose.
Qed.

(** from 30 Theorem 30.3(b): countable basis yields countable dense subset **) 
(** LATEX VERSION: Second-countable spaces are separable (have countable dense subset). **)
Theorem countable_basis_implies_separable : forall X Tx:set,
  topology_on X Tx ->
  second_countable_space X Tx ->
  exists D:set, countable_set D /\ dense_in D X Tx.
let X Tx.
assume HTx: topology_on X Tx.
assume Hscc: second_countable_space X Tx.
prove exists D:set, countable_set D /\ dense_in D X Tx.
claim HexB: exists B:set, basis_on X B /\ countable_set B /\ basis_generates X B Tx.
{ exact (andER (topology_on X Tx) (exists B:set, basis_on X B /\ countable_set B /\ basis_generates X B Tx) Hscc). }
apply HexB.
let B. assume HBpair.
claim HBmid: (basis_on X B /\ countable_set B) /\ basis_generates X B Tx.
{ exact HBpair. }
claim HBasisCount: basis_on X B /\ countable_set B.
{ exact (andEL (basis_on X B /\ countable_set B) (basis_generates X B Tx) HBmid). }
claim HBgener: basis_generates X B Tx.
{ exact (andER (basis_on X B /\ countable_set B) (basis_generates X B Tx) HBmid). }
claim HBasis: basis_on X B.
{ exact (andEL (basis_on X B) (countable_set B) HBasisCount). }
claim HBcount: countable_set B.
{ exact (andER (basis_on X B) (countable_set B) HBasisCount). }
claim HgenEq: generated_topology X B = Tx.
{ exact (andER (basis_on X B) (generated_topology X B = Tx) HBgener). }
(** pick one point from each nonempty basis element **)
set B1 := {b :e B | b <> Empty}.
set pick : set->set := fun b => Eps_i (fun x => x :e b).
set D := {pick b|b :e B1}.
witness D.
apply andI.
- (** D is countable **)
  prove countable_set D.
  claim HB1sub: B1 c= B.
  { let b. assume Hb1: b :e B1.
    exact (SepE1 B (fun b0:set => b0 <> Empty) b Hb1). }
  claim HB1count: countable_set B1.
  { exact (Subq_countable B1 B HBcount HB1sub). }
  exact (countable_image B1 HB1count pick).
- (** D is dense: closure_of X Tx D = X **)
  prove dense_in D X Tx.
  prove closure_of X Tx D = X.
  apply set_ext.
  + (** closure  X **)
    exact (closure_in_space X Tx D HTx).
  + (** X  closure **)
    let x. assume HxX: x :e X.
    prove x :e closure_of X Tx D.
    claim Hcliff: x :e closure_of X Tx D <-> (forall U :e Tx, x :e U -> U :/\: D <> Empty).
    { exact (closure_characterization X Tx D x HTx HxX). }
    claim Hneigh: forall U :e Tx, x :e U -> U :/\: D <> Empty.
    { let U. assume HU: U :e Tx. assume HxU: x :e U.
    claim HUgen: U :e generated_topology X B.
    { rewrite HgenEq. exact HU. }
    claim Href: forall z :e U, exists b :e B, z :e b /\ b c= U.
    { exact (SepE2 (Power X) (fun U0:set => forall z :e U0, exists b :e B, z :e b /\ b c= U0) U HUgen). }
    claim Hexb: exists b :e B, x :e b /\ b c= U.
    { exact (Href x HxU). }
    apply Hexb.
    let b. assume Hbpair.
    claim HbB: b :e B.
    { exact (andEL (b :e B) (x :e b /\ b c= U) Hbpair). }
    claim Hbprop: x :e b /\ b c= U.
    { exact (andER (b :e B) (x :e b /\ b c= U) Hbpair). }
    claim Hxb: x :e b.
    { exact (andEL (x :e b) (b c= U) Hbprop). }
    claim HbsubU: b c= U.
    { exact (andER (x :e b) (b c= U) Hbprop). }
    claim Hbne: b <> Empty.
    { assume HbE: b = Empty.
      claim HxEmp: x :e Empty.
      { rewrite <- HbE. exact Hxb. }
      exact (EmptyE x HxEmp False). }
    claim Hb1: b :e B1.
    { exact (SepI B (fun b0:set => b0 <> Empty) b HbB Hbne). }
    claim Hpickb: pick b :e b.
    { exact (Eps_i_ax (fun x0 => x0 :e b) x Hxb). }
    claim HpickU: pick b :e U.
    { exact (HbsubU (pick b) Hpickb). }
    claim HpickD: pick b :e D.
    { exact (ReplI B1 pick b Hb1). }
    prove U :/\: D <> Empty.
    assume HUD: U :/\: D = Empty.
    claim Hwd: pick b :e U :/\: D.
    { exact (binintersectI U D (pick b) HpickU HpickD). }
    claim HwdE: pick b :e Empty.
    { rewrite <- HUD. exact Hwd. }
    exact (EmptyE (pick b) HwdE False).
    }
    exact (iffER (x :e closure_of X Tx D) (forall U :e Tx, x :e U -> U :/\: D <> Empty) Hcliff Hneigh).
Qed.

(** from 30 Example 3: Sorgenfrey line countability properties **) 
(** LATEX VERSION: Sorgenfrey line is first countable, separable, Lindelf, but not second countable. **)
Theorem Sorgenfrey_line_countability :
  first_countable_space Sorgenfrey_line Sorgenfrey_topology /\
  dense_in rational_numbers Sorgenfrey_line Sorgenfrey_topology /\
  Lindelof_space Sorgenfrey_line Sorgenfrey_topology /\
  ~ second_countable_space Sorgenfrey_line Sorgenfrey_topology.
prove first_countable_space Sorgenfrey_line Sorgenfrey_topology /\
  dense_in rational_numbers Sorgenfrey_line Sorgenfrey_topology /\
  Lindelof_space Sorgenfrey_line Sorgenfrey_topology /\
  ~ second_countable_space Sorgenfrey_line Sorgenfrey_topology.
admit.
Qed.

(** placeholders for later refinement of product/separation constructions **) 
(** LATEX VERSION: Sorgenfrey plane topology = product of two Sorgenfrey lines. **)
Definition Sorgenfrey_plane_topology : set :=
  product_topology Sorgenfrey_line Sorgenfrey_topology Sorgenfrey_line Sorgenfrey_topology.
(** LATEX VERSION: One-point sets closed predicate (T1-like helper). **)
Definition one_point_sets_closed : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\ forall x:set, x :e X -> closed_in X Tx {x}.

(** from 31 Definition: regular and normal spaces **)
(** LATEX VERSION: Regular space: points and closed sets can be separated by disjoint open sets. **)
Definition regular_space : set -> set -> prop := fun X Tx =>
  one_point_sets_closed X Tx /\
  forall x:set, x :e X ->
    forall F:set, closed_in X Tx F -> x /:e F ->
      exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty.

(** LATEX VERSION: Normal space: disjoint closed sets can be separated by disjoint opens. **)
Definition normal_space : set -> set -> prop := fun X Tx =>
  one_point_sets_closed X Tx /\
  forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
    exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.

(** Helper: discrete topology is normal **)
Theorem discrete_normal_space : forall X:set,
  normal_space X (discrete_topology X).
let X.
prove normal_space X (discrete_topology X).
claim HTx: topology_on X (discrete_topology X).
{ exact (discrete_topology_on X). }
prove one_point_sets_closed X (discrete_topology X) /\
  forall A B:set, closed_in X (discrete_topology X) A -> closed_in X (discrete_topology X) B -> A :/\: B = Empty ->
    exists U V:set, U :e discrete_topology X /\ V :e discrete_topology X /\ A c= U /\ B c= V /\ U :/\: V = Empty.
apply andI.
- (** one_point_sets_closed **)
  prove topology_on X (discrete_topology X) /\ forall x:set, x :e X -> closed_in X (discrete_topology X) {x}.
  apply andI.
  - exact HTx.
  - let x. assume HxX: x :e X.
    prove closed_in X (discrete_topology X) {x}.
    set U := X :\: {x}.
    claim HUsub: U c= X.
    { apply setminus_Subq. }
    claim HUopen: U :e discrete_topology X.
    { exact (discrete_open_all X U HUsub). }
    claim HclosedComp: closed_in X (discrete_topology X) (X :\: U).
    { exact (closed_of_open_complement X (discrete_topology X) U HTx HUopen). }
    claim HsingSub: {x} c= X.
    { exact (singleton_subset x X HxX). }
    claim Heq: X :\: U = {x}.
    { claim HUdef: U = X :\: {x}.
      { reflexivity. }
      rewrite HUdef.
      exact (setminus_setminus_eq X {x} HsingSub). }
    rewrite <- Heq.
    exact HclosedComp.
- (** separation of disjoint closed sets **)
  let A B.
  assume HA: closed_in X (discrete_topology X) A.
  assume HB: closed_in X (discrete_topology X) B.
  assume Hdisj: A :/\: B = Empty.
  prove exists U V:set,
    U :e discrete_topology X /\ V :e discrete_topology X /\ A c= U /\ B c= V /\ U :/\: V = Empty.
  witness A.
  witness B.
  claim HAsub: A c= X.
  { exact (closed_in_subset X (discrete_topology X) A HA). }
  claim HBsub: B c= X.
  { exact (closed_in_subset X (discrete_topology X) B HB). }
  claim HAopen: A :e discrete_topology X.
  { exact (discrete_open_all X A HAsub). }
  claim HBopen: B :e discrete_topology X.
  { exact (discrete_open_all X B HBsub). }
  apply andI.
  - prove ((A :e discrete_topology X /\ B :e discrete_topology X) /\ A c= A) /\ B c= B.
    apply andI.
    + prove (A :e discrete_topology X /\ B :e discrete_topology X) /\ A c= A.
      apply andI.
      * apply andI.
        - exact HAopen.
        - exact HBopen.
      * exact (Subq_ref A).
    + exact (Subq_ref B).
  - exact Hdisj.
Qed.

(** from 31: regular implies Hausdorff, normal implies regular **)
(** LATEX VERSION: It is clear that a regular space is Hausdorff, and that a normal space is regular. **)
Theorem regular_space_implies_Hausdorff : forall X Tx:set,
  regular_space X Tx -> Hausdorff_space X Tx.
let X Tx.
assume Hreg: regular_space X Tx.
prove Hausdorff_space X Tx.
claim HT1: one_point_sets_closed X Tx.
{ exact (andEL (one_point_sets_closed X Tx)
               (forall x:set, x :e X ->
                 forall F:set, closed_in X Tx F -> x /:e F ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty)
               Hreg). }
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x:set, x :e X -> closed_in X Tx {x})
               HT1). }
claim Hsing: forall x:set, x :e X -> closed_in X Tx {x}.
{ exact (andER (topology_on X Tx)
               (forall x:set, x :e X -> closed_in X Tx {x})
               HT1). }
claim HSepReg:
  forall x:set, x :e X ->
    forall F:set, closed_in X Tx F -> x /:e F ->
      exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty.
{ exact (andER (one_point_sets_closed X Tx)
               (forall x:set, x :e X ->
                 forall F:set, closed_in X Tx F -> x /:e F ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty)
               Hreg). }
prove topology_on X Tx /\
      forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
        exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
apply andI.
- exact HTx.
- let x1 x2.
  assume Hx1X: x1 :e X.
  assume Hx2X: x2 :e X.
  assume Hneq: x1 <> x2.
  prove exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
  claim Hcl: closed_in X Tx {x2}.
  { exact (Hsing x2 Hx2X). }
  claim Hx1not: x1 /:e {x2}.
  { assume Hx1in: x1 :e {x2}.
    claim Heq: x1 = x2.
    { exact (SingE x2 x1 Hx1in). }
    exact (Hneq Heq). }
  claim Hex: exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ {x2} c= V /\ U :/\: V = Empty.
  { exact (HSepReg x1 Hx1X {x2} Hcl Hx1not). }
  set U0 := Eps_i (fun U:set => exists V:set,
    U :e Tx /\ V :e Tx /\ x1 :e U /\ {x2} c= V /\ U :/\: V = Empty).
  claim HU0ex: exists V:set,
    U0 :e Tx /\ V :e Tx /\ x1 :e U0 /\ {x2} c= V /\ U0 :/\: V = Empty.
  { exact (Eps_i_ex (fun U:set => exists V:set,
      U :e Tx /\ V :e Tx /\ x1 :e U /\ {x2} c= V /\ U :/\: V = Empty) Hex). }
  set V0 := Eps_i (fun V:set => U0 :e Tx /\ V :e Tx /\ x1 :e U0 /\ {x2} c= V /\ U0 :/\: V = Empty).
  claim HV0prop: U0 :e Tx /\ V0 :e Tx /\ x1 :e U0 /\ {x2} c= V0 /\ U0 :/\: V0 = Empty.
  { exact (Eps_i_ex (fun V:set => U0 :e Tx /\ V :e Tx /\ x1 :e U0 /\ {x2} c= V /\ U0 :/\: V = Empty)
                    HU0ex). }
  claim H1234: (((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) /\ {x2} c= V0).
  { exact (andEL ((((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) /\ {x2} c= V0))
                 (U0 :/\: V0 = Empty)
                 HV0prop). }
  claim HdisjUV: U0 :/\: V0 = Empty.
  { exact (andER ((((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) /\ {x2} c= V0))
                 (U0 :/\: V0 = Empty)
                 HV0prop). }
  claim H123: ((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0).
  { exact (andEL ((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0)
                 ({x2} c= V0)
                 H1234). }
  claim H12: (U0 :e Tx /\ V0 :e Tx).
  { exact (andEL (U0 :e Tx /\ V0 :e Tx) (x1 :e U0) H123). }
  claim HUx1: x1 :e U0.
  { exact (andER (U0 :e Tx /\ V0 :e Tx) (x1 :e U0) H123). }
  claim HVsub: {x2} c= V0.
  { exact (andER ((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) ({x2} c= V0) H1234). }
  claim Hx2V0: x2 :e V0.
  { apply HVsub. exact (SingI x2). }
  witness U0.
  witness V0.
  apply and5I.
  - exact (andEL (U0 :e Tx) (V0 :e Tx) H12).
  - exact (andER (U0 :e Tx) (V0 :e Tx) H12).
  - exact HUx1.
  - exact Hx2V0.
  - exact HdisjUV.
Qed.

Theorem normal_space_implies_regular : forall X Tx:set,
  normal_space X Tx -> regular_space X Tx.
let X Tx.
assume Hnorm: normal_space X Tx.
prove regular_space X Tx.
claim HT1: one_point_sets_closed X Tx.
{ exact (andEL (one_point_sets_closed X Tx)
               (forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty)
               Hnorm). }
claim Hsing: forall x:set, x :e X -> closed_in X Tx {x}.
{ exact (andER (topology_on X Tx)
               (forall x:set, x :e X -> closed_in X Tx {x})
               HT1). }
claim HSepNorm:
  forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
    exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.
{ exact (andER (one_point_sets_closed X Tx)
               (forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty)
               Hnorm). }
prove one_point_sets_closed X Tx /\
      forall x:set, x :e X ->
        forall F:set, closed_in X Tx F -> x /:e F ->
          exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty.
apply andI.
- exact HT1.
- let x. assume HxX: x :e X.
  let F. assume HFcl: closed_in X Tx F.
  assume HxnotF: x /:e F.
  prove exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty.
  claim Hclx: closed_in X Tx {x}.
  { exact (Hsing x HxX). }
  claim Hdisj: {x} :/\: F = Empty.
  { apply Empty_Subq_eq.
    let z. assume Hz: z :e {x} :/\: F.
    prove z :e Empty.
    claim Hz1: z :e {x}.
    { exact (binintersectE1 {x} F z Hz). }
    claim Hz2: z :e F.
    { exact (binintersectE2 {x} F z Hz). }
    claim Hzx: z = x.
    { exact (SingE x z Hz1). }
    claim HxinF: x :e F.
    { rewrite <- Hzx. exact Hz2. }
    apply FalseE.
    exact (HxnotF HxinF). }
  claim Hex: exists U V:set, U :e Tx /\ V :e Tx /\ {x} c= U /\ F c= V /\ U :/\: V = Empty.
  { exact (HSepNorm {x} F Hclx HFcl Hdisj). }
  set U0 := Eps_i (fun U:set => exists V:set,
    U :e Tx /\ V :e Tx /\ {x} c= U /\ F c= V /\ U :/\: V = Empty).
  claim HU0ex: exists V:set,
    U0 :e Tx /\ V :e Tx /\ {x} c= U0 /\ F c= V /\ U0 :/\: V = Empty.
  { exact (Eps_i_ex (fun U:set => exists V:set,
      U :e Tx /\ V :e Tx /\ {x} c= U /\ F c= V /\ U :/\: V = Empty) Hex). }
  set V0 := Eps_i (fun V:set => U0 :e Tx /\ V :e Tx /\ {x} c= U0 /\ F c= V /\ U0 :/\: V = Empty).
  claim HV0prop: U0 :e Tx /\ V0 :e Tx /\ {x} c= U0 /\ F c= V0 /\ U0 :/\: V0 = Empty.
  { exact (Eps_i_ex (fun V:set => U0 :e Tx /\ V :e Tx /\ {x} c= U0 /\ F c= V /\ U0 :/\: V = Empty)
                    HU0ex). }
  claim H1234: (((U0 :e Tx /\ V0 :e Tx) /\ {x} c= U0) /\ F c= V0).
  { exact (andEL ((((U0 :e Tx /\ V0 :e Tx) /\ {x} c= U0) /\ F c= V0))
                 (U0 :/\: V0 = Empty)
                 HV0prop). }
  claim HdisjUV: U0 :/\: V0 = Empty.
  { exact (andER ((((U0 :e Tx /\ V0 :e Tx) /\ {x} c= U0) /\ F c= V0))
                 (U0 :/\: V0 = Empty)
                 HV0prop). }
  claim H123: ((U0 :e Tx /\ V0 :e Tx) /\ {x} c= U0).
  { exact (andEL ((U0 :e Tx /\ V0 :e Tx) /\ {x} c= U0)
                 (F c= V0)
                 H1234). }
  claim H12: (U0 :e Tx /\ V0 :e Tx).
  { exact (andEL (U0 :e Tx /\ V0 :e Tx) ({x} c= U0) H123). }
  claim Hsubx: {x} c= U0.
  { exact (andER (U0 :e Tx /\ V0 :e Tx) ({x} c= U0) H123). }
  claim HFsub: F c= V0.
  { exact (andER ((U0 :e Tx /\ V0 :e Tx) /\ {x} c= U0) (F c= V0) H1234). }
  claim HxU0: x :e U0.
  { apply Hsubx. exact (SingI x). }
  witness U0.
  witness V0.
  apply and5I.
  - exact (andEL (U0 :e Tx) (V0 :e Tx) H12).
  - exact (andER (U0 :e Tx) (V0 :e Tx) H12).
  - exact HxU0.
  - exact HFsub.
  - exact HdisjUV.
Qed.

(** LATEX VERSION: Families of Hausdorff/regular/completely regular spaces (helpers). **)
Definition Hausdorff_spaces_family : set -> set -> prop := fun I Xi =>
  forall i:set, i :e I -> Hausdorff_space (product_component Xi i) (product_component_topology Xi i).
Definition regular_spaces_family : set -> set -> prop := fun I Xi =>
  forall i:set, i :e I -> regular_space (product_component Xi i) (product_component_topology Xi i).
(** LATEX VERSION: Uncountable set helper. **)
Definition uncountable_set : set -> prop := fun X => ~ countable_set X.
(** LATEX VERSION: Well-ordered set helper. **)
Definition well_ordered_set : set -> prop := fun X =>
  exists alpha:set, ordinal alpha /\ equip X alpha.
(** LATEX VERSION: Completely regular family helper. **)
(** moved below after completely_regular_space is defined **)
(** LATEX VERSION: Separating family of functions (embedding setup). **)
Definition separating_family_of_functions : set -> set -> set -> set -> prop :=
  fun X Tx F J =>
    topology_on X Tx /\ F c= function_space X J /\
    (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
       exists f:set, f :e F /\ apply_fun f x1 <> apply_fun f x2).
(** LATEX VERSION: Embedding predicate. **)
(** FIXED: embedding_of uses homeomorphism X Tx (image_of f X) (subspace_topology Y Ty (image_of f X)) f, not merely continuous injective. **) 
Definition embedding_of : set -> set -> set -> set -> set -> prop := fun X Tx Y Ty f =>
  homeomorphism X Tx (image_of f X) (subspace_topology Y Ty (image_of f X)) f.
(** LATEX VERSION: Power and unit-interval cubes helpers; metrizability predicate. **)
Definition power_real : set -> set := fun J => function_space J R.
Definition unit_interval_power : set -> set := fun J => function_space J unit_interval.
Definition metrizable : set -> set -> prop := fun X Tx =>
  exists d:set, metric_on X d /\ metric_topology X d = Tx.

(** from 30 Example 4: product of Lindelf spaces need not be Lindelf **) 
(** LATEX VERSION: The product of two Lindelf Sorgenfrey lines (the Sorgenfrey plane) is not Lindelf. **)
Theorem Sorgenfrey_plane_not_Lindelof :
  ~ Lindelof_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology.
prove ~ Lindelof_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology.
admit.
Qed.

(** from 30 Example 5: subspace of Lindelf space need not be Lindelf **) 
(** LATEX VERSION: A subspace of a Lindelf space can fail to be Lindelf (ordered square strip example). **)
Theorem ordered_square_subspace_not_Lindelof :
  Lindelof_space ordered_square ordered_square_topology /\
  ~ Lindelof_space ordered_square_open_strip ordered_square_subspace_topology.
prove Lindelof_space ordered_square ordered_square_topology /\ ~ Lindelof_space ordered_square_open_strip ordered_square_subspace_topology.
admit.
Qed.

(** from 31 Lemma 31.1: closure-neighborhood reformulations of regular/normal **) 
(** LATEX VERSION: Lemma 31.1: characterizations of regular/normal via closures and neighborhoods (assuming T1). **)
Theorem regular_normal_via_closure : forall X Tx:set,
  topology_on X Tx ->
  (one_point_sets_closed X Tx -> (regular_space X Tx <->
     forall x U:set, x :e X -> U :e Tx -> x :e U -> exists V:set, V :e Tx /\ x :e V /\ closure_of X Tx V c= U)) /\
  (one_point_sets_closed X Tx -> (normal_space X Tx <->
     forall A U:set, closed_in X Tx A -> U :e Tx -> A c= U -> exists V:set, V :e Tx /\ A c= V /\ closure_of X Tx V c= U)).
let X Tx.
assume HTx: topology_on X Tx.
prove (one_point_sets_closed X Tx -> (regular_space X Tx <->
     forall x U:set, x :e X -> U :e Tx -> x :e U -> exists V:set, V :e Tx /\ x :e V /\ closure_of X Tx V c= U)) /\
  (one_point_sets_closed X Tx -> (normal_space X Tx <->
     forall A U:set, closed_in X Tx A -> U :e Tx -> A c= U -> exists V:set, V :e Tx /\ A c= V /\ closure_of X Tx V c= U)).
apply andI.
- (** Regular part **)
  assume HT1: one_point_sets_closed X Tx.
  prove regular_space X Tx <->
       forall x U:set, x :e X -> U :e Tx -> x :e U ->
         exists V:set, V :e Tx /\ x :e V /\ closure_of X Tx V c= U.
  apply iffI.
  * assume Hreg: regular_space X Tx.
    prove forall x U:set, x :e X -> U :e Tx -> x :e U ->
         exists V:set, V :e Tx /\ x :e V /\ closure_of X Tx V c= U.
    claim HSepReg:
      forall x:set, x :e X ->
        forall F:set, closed_in X Tx F -> x /:e F ->
          exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty.
    { exact (andER (one_point_sets_closed X Tx)
                   (forall x:set, x :e X ->
                     forall F:set, closed_in X Tx F -> x /:e F ->
                       exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty)
                   Hreg). }
    let x U.
    assume HxX: x :e X.
    assume HU: U :e Tx.
    assume HxU: x :e U.
    set B := X :\: U.
    claim HBcl: closed_in X Tx B.
    { exact (closed_of_open_complement X Tx U HTx HU). }
    claim HxnotB: x /:e B.
    { assume HxB: x :e B.
      claim HxnotU: x /:e U.
      { exact (setminusE2 X U x HxB). }
      exact (HxnotU HxU). }
    claim Hex: exists V W:set, V :e Tx /\ W :e Tx /\ x :e V /\ B c= W /\ V :/\: W = Empty.
    { exact (HSepReg x HxX B HBcl HxnotB). }
    set V0 := Eps_i (fun V:set => exists W:set, V :e Tx /\ W :e Tx /\ x :e V /\ B c= W /\ V :/\: W = Empty).
    claim HV0ex: exists W:set, V0 :e Tx /\ W :e Tx /\ x :e V0 /\ B c= W /\ V0 :/\: W = Empty.
    { exact (Eps_i_ex (fun V:set => exists W:set, V :e Tx /\ W :e Tx /\ x :e V /\ B c= W /\ V :/\: W = Empty) Hex). }
    set W0 := Eps_i (fun W:set => V0 :e Tx /\ W :e Tx /\ x :e V0 /\ B c= W /\ V0 :/\: W = Empty).
    claim HW0prop: V0 :e Tx /\ W0 :e Tx /\ x :e V0 /\ B c= W0 /\ V0 :/\: W0 = Empty.
    { exact (Eps_i_ex (fun W:set => V0 :e Tx /\ W :e Tx /\ x :e V0 /\ B c= W /\ V0 :/\: W = Empty)
                      HV0ex). }
    claim H1234: (((V0 :e Tx /\ W0 :e Tx) /\ x :e V0) /\ B c= W0).
    { exact (andEL ((((V0 :e Tx /\ W0 :e Tx) /\ x :e V0) /\ B c= W0))
                   (V0 :/\: W0 = Empty)
                   HW0prop). }
    claim HdisjVW: V0 :/\: W0 = Empty.
    { exact (andER ((((V0 :e Tx /\ W0 :e Tx) /\ x :e V0) /\ B c= W0))
                   (V0 :/\: W0 = Empty)
                   HW0prop). }
    claim H123: ((V0 :e Tx /\ W0 :e Tx) /\ x :e V0).
    { exact (andEL ((V0 :e Tx /\ W0 :e Tx) /\ x :e V0) (B c= W0) H1234). }
    claim H12: (V0 :e Tx /\ W0 :e Tx).
    { exact (andEL (V0 :e Tx /\ W0 :e Tx) (x :e V0) H123). }
    claim HV0Tx: V0 :e Tx.
    { exact (andEL (V0 :e Tx) (W0 :e Tx) H12). }
    claim HW0Tx: W0 :e Tx.
    { exact (andER (V0 :e Tx) (W0 :e Tx) H12). }
    claim HxV0: x :e V0.
    { exact (andER (V0 :e Tx /\ W0 :e Tx) (x :e V0) H123). }
    claim HBsubW0: B c= W0.
    { exact (andER ((V0 :e Tx /\ W0 :e Tx) /\ x :e V0) (B c= W0) H1234). }
    claim HdisjWV: W0 :/\: V0 = Empty.
    { apply Empty_Subq_eq.
      let z. assume Hz: z :e W0 :/\: V0.
      prove z :e Empty.
      claim HzW: z :e W0.
      { exact (binintersectE1 W0 V0 z Hz). }
      claim HzV: z :e V0.
      { exact (binintersectE2 W0 V0 z Hz). }
      claim HzVW: z :e V0 :/\: W0.
      { exact (binintersectI V0 W0 z HzV HzW). }
      claim HzE: z :e Empty.
      { rewrite <- HdisjVW. exact HzVW. }
      exact HzE. }
	    claim HclV0subU: closure_of X Tx V0 c= U.
	    { let z. assume Hzcl: z :e closure_of X Tx V0.
	      prove z :e U.
	      claim HzX: z :e X.
	      { exact (SepE1 X (fun z0:set => forall N:set, N :e Tx -> z0 :e N -> N :/\: V0 <> Empty) z Hzcl). }
	      apply xm (z :e U).
	      - assume HzU: z :e U.
	        exact HzU.
	      - assume HznotU: z /:e U.
	        claim HzB: z :e B.
	        { exact (setminusI X U z HzX HznotU). }
	        claim HzW0: z :e W0.
	        { exact (HBsubW0 z HzB). }
	        claim Hcliff: z :e closure_of X Tx V0 <-> (forall N :e Tx, z :e N -> N :/\: V0 <> Empty).
	        { exact (closure_characterization X Tx V0 z HTx HzX). }
	        claim Hneigh: forall N :e Tx, z :e N -> N :/\: V0 <> Empty.
	        { exact (iffEL (z :e closure_of X Tx V0)
	                       (forall N :e Tx, z :e N -> N :/\: V0 <> Empty)
	                       Hcliff Hzcl). }
	        claim Hcontr: W0 :/\: V0 <> Empty.
	        { exact (Hneigh W0 HW0Tx HzW0). }
	        apply FalseE.
	        exact (Hcontr HdisjWV). }
	    witness V0.
	    apply andI.
	    - apply andI.
	      + exact HV0Tx.
      + exact HxV0.
    - exact HclV0subU.
  * assume Hcrit:
      forall x U:set, x :e X -> U :e Tx -> x :e U ->
        exists V:set, V :e Tx /\ x :e V /\ closure_of X Tx V c= U.
    prove regular_space X Tx.
    prove one_point_sets_closed X Tx /\
         forall x:set, x :e X ->
           forall F:set, closed_in X Tx F -> x /:e F ->
             exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty.
    apply andI.
    - exact HT1.
    - let x. assume HxX: x :e X.
      let F. assume HFcl: closed_in X Tx F.
      assume HxnotF: x /:e F.
      prove exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty.
      set U0 := X :\: F.
      claim Hop0: open_in X Tx U0.
      { exact (open_of_closed_complement X Tx F HFcl). }
      claim HU0Tx: U0 :e Tx.
      { exact (andER (topology_on X Tx) (U0 :e Tx) Hop0). }
      claim HxU0: x :e U0.
      { exact (setminusI X F x HxX HxnotF). }
      claim HexV: exists V:set, V :e Tx /\ x :e V /\ closure_of X Tx V c= U0.
      { exact (Hcrit x U0 HxX HU0Tx HxU0). }
      set V0 := Eps_i (fun V:set => V :e Tx /\ x :e V /\ closure_of X Tx V c= U0).
	      claim HV0prop: V0 :e Tx /\ x :e V0 /\ closure_of X Tx V0 c= U0.
	      { exact (Eps_i_ex (fun V:set => V :e Tx /\ x :e V /\ closure_of X Tx V c= U0) HexV). }
	      claim HV0TxHx: V0 :e Tx /\ x :e V0.
	      { exact (andEL (V0 :e Tx /\ x :e V0) (closure_of X Tx V0 c= U0) HV0prop). }
	      claim HV0Tx: V0 :e Tx.
	      { exact (andEL (V0 :e Tx) (x :e V0) HV0TxHx). }
	      claim HxV0: x :e V0.
	      { exact (andER (V0 :e Tx) (x :e V0) HV0TxHx). }
	      claim Hclsub: closure_of X Tx V0 c= U0.
	      { exact (andER (V0 :e Tx /\ x :e V0) (closure_of X Tx V0 c= U0) HV0prop). }
      claim HTsub: Tx c= Power X.
      { exact (topology_subset_axiom X Tx HTx). }
      claim HV0subX: V0 c= X.
      { exact (PowerE X V0 (HTsub V0 HV0Tx)). }
      claim HclV0cl: closed_in X Tx (closure_of X Tx V0).
      { exact (closure_is_closed X Tx V0 HTx HV0subX). }
      set W0 := X :\: closure_of X Tx V0.
      claim HopW: open_in X Tx W0.
      { exact (open_of_closed_complement X Tx (closure_of X Tx V0) HclV0cl). }
      claim HW0Tx: W0 :e Tx.
      { exact (andER (topology_on X Tx) (W0 :e Tx) HopW). }
	      claim HFsubW0: F c= W0.
	      { let z. assume HzF: z :e F.
	        prove z :e W0.
	        claim HFsubX: F c= X.
	        { exact (closed_in_subset X Tx F HFcl). }
	        claim HzX: z :e X.
	        { exact (HFsubX z HzF). }
	        apply xm (z :e closure_of X Tx V0).
	        - assume Hzcl: z :e closure_of X Tx V0.
	          claim HzU0: z :e U0.
	          { exact (Hclsub z Hzcl). }
	          claim HznotF2: z /:e F.
	          { exact (setminusE2 X F z HzU0). }
	          apply FalseE.
	          exact (HznotF2 HzF).
	        - assume Hznotcl: z /:e closure_of X Tx V0.
	          exact (setminusI X (closure_of X Tx V0) z HzX Hznotcl).
	        }
      claim HVsubcl: V0 c= closure_of X Tx V0.
      { exact (subset_of_closure X Tx V0 HTx HV0subX). }
      claim Hdisj: V0 :/\: W0 = Empty.
      { apply Empty_Subq_eq.
        let z. assume Hz: z :e V0 :/\: W0.
        prove z :e Empty.
        claim HzV: z :e V0.
        { exact (binintersectE1 V0 W0 z Hz). }
        claim HzW: z :e W0.
        { exact (binintersectE2 V0 W0 z Hz). }
        claim Hzcl: z :e closure_of X Tx V0.
        { exact (HVsubcl z HzV). }
        claim Hznotcl: z /:e closure_of X Tx V0.
        { exact (setminusE2 X (closure_of X Tx V0) z HzW). }
        apply FalseE.
        exact (Hznotcl Hzcl). }
      witness V0.
      witness W0.
      apply andI.
      - apply andI.
        + apply andI.
          * apply andI.
            { exact HV0Tx. }
            { exact HW0Tx. }
          * exact HxV0.
        + exact HFsubW0.
      - exact Hdisj.

- (** Normal part **)
  assume HT1: one_point_sets_closed X Tx.
  prove normal_space X Tx <->
       forall A U:set, closed_in X Tx A -> U :e Tx -> A c= U ->
         exists V:set, V :e Tx /\ A c= V /\ closure_of X Tx V c= U.
  apply iffI.
  * assume Hnorm: normal_space X Tx.
    prove forall A U:set, closed_in X Tx A -> U :e Tx -> A c= U ->
         exists V:set, V :e Tx /\ A c= V /\ closure_of X Tx V c= U.
    claim HSepNorm:
      forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
        exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.
    { exact (andER (one_point_sets_closed X Tx)
                   (forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
                     exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty)
                   Hnorm). }
    let A U.
    assume HAcl: closed_in X Tx A.
    assume HU: U :e Tx.
    assume HAsubU: A c= U.
    set B := X :\: U.
    claim HBcl: closed_in X Tx B.
    { exact (closed_of_open_complement X Tx U HTx HU). }
    claim HABdisj: A :/\: B = Empty.
    { apply Empty_Subq_eq.
      let z. assume Hz: z :e A :/\: B.
      prove z :e Empty.
      claim HzA: z :e A.
      { exact (binintersectE1 A B z Hz). }
      claim HzB: z :e B.
      { exact (binintersectE2 A B z Hz). }
      claim HzU: z :e U.
      { exact (HAsubU z HzA). }
      claim HznotU: z /:e U.
      { exact (setminusE2 X U z HzB). }
      apply FalseE.
      exact (HznotU HzU). }
    claim Hex: exists V W:set, V :e Tx /\ W :e Tx /\ A c= V /\ B c= W /\ V :/\: W = Empty.
    { exact (HSepNorm A B HAcl HBcl HABdisj). }
    set V0 := Eps_i (fun V:set => exists W:set, V :e Tx /\ W :e Tx /\ A c= V /\ B c= W /\ V :/\: W = Empty).
    claim HV0ex: exists W:set, V0 :e Tx /\ W :e Tx /\ A c= V0 /\ B c= W /\ V0 :/\: W = Empty.
    { exact (Eps_i_ex (fun V:set => exists W:set, V :e Tx /\ W :e Tx /\ A c= V /\ B c= W /\ V :/\: W = Empty) Hex). }
    set W0 := Eps_i (fun W:set => V0 :e Tx /\ W :e Tx /\ A c= V0 /\ B c= W /\ V0 :/\: W = Empty).
    claim HW0prop: V0 :e Tx /\ W0 :e Tx /\ A c= V0 /\ B c= W0 /\ V0 :/\: W0 = Empty.
    { exact (Eps_i_ex (fun W:set => V0 :e Tx /\ W :e Tx /\ A c= V0 /\ B c= W /\ V0 :/\: W = Empty)
                      HV0ex). }
    claim H1234: (((V0 :e Tx /\ W0 :e Tx) /\ A c= V0) /\ B c= W0).
    { exact (andEL ((((V0 :e Tx /\ W0 :e Tx) /\ A c= V0) /\ B c= W0))
                   (V0 :/\: W0 = Empty)
                   HW0prop). }
    claim HdisjVW: V0 :/\: W0 = Empty.
    { exact (andER ((((V0 :e Tx /\ W0 :e Tx) /\ A c= V0) /\ B c= W0))
                   (V0 :/\: W0 = Empty)
                   HW0prop). }
    claim H123: ((V0 :e Tx /\ W0 :e Tx) /\ A c= V0).
    { exact (andEL ((V0 :e Tx /\ W0 :e Tx) /\ A c= V0) (B c= W0) H1234). }
    claim H12: (V0 :e Tx /\ W0 :e Tx).
    { exact (andEL (V0 :e Tx /\ W0 :e Tx) (A c= V0) H123). }
    claim HV0Tx: V0 :e Tx.
    { exact (andEL (V0 :e Tx) (W0 :e Tx) H12). }
    claim HW0Tx: W0 :e Tx.
    { exact (andER (V0 :e Tx) (W0 :e Tx) H12). }
    claim HAsubV0: A c= V0.
    { exact (andER (V0 :e Tx /\ W0 :e Tx) (A c= V0) H123). }
    claim HBsubW0: B c= W0.
    { exact (andER ((V0 :e Tx /\ W0 :e Tx) /\ A c= V0) (B c= W0) H1234). }
    claim HdisjWV: W0 :/\: V0 = Empty.
    { apply Empty_Subq_eq.
      let z. assume Hz: z :e W0 :/\: V0.
      prove z :e Empty.
      claim HzW: z :e W0.
      { exact (binintersectE1 W0 V0 z Hz). }
      claim HzV: z :e V0.
      { exact (binintersectE2 W0 V0 z Hz). }
      claim HzVW: z :e V0 :/\: W0.
      { exact (binintersectI V0 W0 z HzV HzW). }
      claim HzE: z :e Empty.
      { rewrite <- HdisjVW. exact HzVW. }
      exact HzE. }
	    claim HclV0subU: closure_of X Tx V0 c= U.
	    { let z. assume Hzcl: z :e closure_of X Tx V0.
	      prove z :e U.
	      claim HzX: z :e X.
	      { exact (SepE1 X (fun z0:set => forall N:set, N :e Tx -> z0 :e N -> N :/\: V0 <> Empty) z Hzcl). }
	      apply xm (z :e U).
	      - assume HzU: z :e U.
	        exact HzU.
	      - assume HznotU: z /:e U.
	        claim HzB: z :e B.
	        { exact (setminusI X U z HzX HznotU). }
	        claim HzW0: z :e W0.
	        { exact (HBsubW0 z HzB). }
	        claim Hcliff: z :e closure_of X Tx V0 <-> (forall N :e Tx, z :e N -> N :/\: V0 <> Empty).
	        { exact (closure_characterization X Tx V0 z HTx HzX). }
	        claim Hneigh: forall N :e Tx, z :e N -> N :/\: V0 <> Empty.
	        { exact (iffEL (z :e closure_of X Tx V0)
	                       (forall N :e Tx, z :e N -> N :/\: V0 <> Empty)
	                       Hcliff Hzcl). }
	        claim Hcontr: W0 :/\: V0 <> Empty.
	        { exact (Hneigh W0 HW0Tx HzW0). }
	        apply FalseE.
	        exact (Hcontr HdisjWV). }
	    witness V0.
	    apply andI.
	    - apply andI.
      + exact HV0Tx.
      + exact HAsubV0.
    - exact HclV0subU.
  * assume Hcrit:
      forall A U:set, closed_in X Tx A -> U :e Tx -> A c= U ->
        exists V:set, V :e Tx /\ A c= V /\ closure_of X Tx V c= U.
    prove normal_space X Tx.
    prove one_point_sets_closed X Tx /\
         forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
           exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.
    apply andI.
    - exact HT1.
    - let A. let B.
      assume HAcl: closed_in X Tx A.
      assume HBcl: closed_in X Tx B.
      assume Hdisj: A :/\: B = Empty.
      prove exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.
      set U0 := X :\: B.
      claim Hop0: open_in X Tx U0.
      { exact (open_of_closed_complement X Tx B HBcl). }
      claim HU0Tx: U0 :e Tx.
      { exact (andER (topology_on X Tx) (U0 :e Tx) Hop0). }
	      claim HAsubU0: A c= U0.
	      { let z. assume HzA: z :e A.
	        prove z :e U0.
	        claim HAsubX: A c= X.
	        { exact (closed_in_subset X Tx A HAcl). }
	        claim HzX: z :e X.
	        { exact (HAsubX z HzA). }
	        apply xm (z :e B).
	        - assume HzB: z :e B.
	          claim HzAB: z :e A :/\: B.
	          { exact (binintersectI A B z HzA HzB). }
	          claim HzE: z :e Empty.
	          { rewrite <- Hdisj. exact HzAB. }
	          apply FalseE.
	          exact (EmptyE z HzE False).
	        - assume HznotB: z /:e B.
	          exact (setminusI X B z HzX HznotB). }
      claim HexV: exists V:set, V :e Tx /\ A c= V /\ closure_of X Tx V c= U0.
      { exact (Hcrit A U0 HAcl HU0Tx HAsubU0). }
	      set V0 := Eps_i (fun V:set => V :e Tx /\ A c= V /\ closure_of X Tx V c= U0).
	      claim HV0prop: V0 :e Tx /\ A c= V0 /\ closure_of X Tx V0 c= U0.
	      { exact (Eps_i_ex (fun V:set => V :e Tx /\ A c= V /\ closure_of X Tx V c= U0) HexV). }
	      claim HV0TxHA: V0 :e Tx /\ A c= V0.
	      { exact (andEL (V0 :e Tx /\ A c= V0) (closure_of X Tx V0 c= U0) HV0prop). }
	      claim HV0Tx: V0 :e Tx.
	      { exact (andEL (V0 :e Tx) (A c= V0) HV0TxHA). }
	      claim HAsubV0: A c= V0.
	      { exact (andER (V0 :e Tx) (A c= V0) HV0TxHA). }
	      claim Hclsub: closure_of X Tx V0 c= U0.
	      { exact (andER (V0 :e Tx /\ A c= V0) (closure_of X Tx V0 c= U0) HV0prop). }
      claim HTsub: Tx c= Power X.
      { exact (topology_subset_axiom X Tx HTx). }
      claim HV0subX: V0 c= X.
      { exact (PowerE X V0 (HTsub V0 HV0Tx)). }
      claim HclV0cl: closed_in X Tx (closure_of X Tx V0).
      { exact (closure_is_closed X Tx V0 HTx HV0subX). }
      set W0 := X :\: closure_of X Tx V0.
      claim HopW: open_in X Tx W0.
      { exact (open_of_closed_complement X Tx (closure_of X Tx V0) HclV0cl). }
      claim HW0Tx: W0 :e Tx.
      { exact (andER (topology_on X Tx) (W0 :e Tx) HopW). }
	      claim HBsubW0: B c= W0.
	      { let z. assume HzB: z :e B.
	        prove z :e W0.
	        claim HBsubX: B c= X.
	        { exact (closed_in_subset X Tx B HBcl). }
	        claim HzX: z :e X.
	        { exact (HBsubX z HzB). }
	        apply xm (z :e closure_of X Tx V0).
	        - assume Hzcl: z :e closure_of X Tx V0.
	          claim HzU0: z :e U0.
	          { exact (Hclsub z Hzcl). }
	          claim HznotB: z /:e B.
	          { exact (setminusE2 X B z HzU0). }
	          apply FalseE.
	          exact (HznotB HzB).
	        - assume Hznotcl: z /:e closure_of X Tx V0.
	          exact (setminusI X (closure_of X Tx V0) z HzX Hznotcl). }
      claim HVsubcl: V0 c= closure_of X Tx V0.
      { exact (subset_of_closure X Tx V0 HTx HV0subX). }
      claim HdisjVW: V0 :/\: W0 = Empty.
      { apply Empty_Subq_eq.
        let z. assume Hz: z :e V0 :/\: W0.
        prove z :e Empty.
        claim HzV: z :e V0.
        { exact (binintersectE1 V0 W0 z Hz). }
        claim HzW: z :e W0.
        { exact (binintersectE2 V0 W0 z Hz). }
        claim Hzcl: z :e closure_of X Tx V0.
        { exact (HVsubcl z HzV). }
        claim Hznotcl: z /:e closure_of X Tx V0.
        { exact (setminusE2 X (closure_of X Tx V0) z HzW). }
        apply FalseE.
        exact (Hznotcl Hzcl). }
		      witness V0.
		      witness W0.
		      apply andI.
		      - apply andI.
		        + apply andI.
		          - apply andI.
		            + exact HV0Tx.
		            + exact HW0Tx.
		          - exact HAsubV0.
		        + exact HBsubW0.
		      - exact HdisjVW.
		Qed.

(** from 31 Theorem 31.2: subspaces/products preserve Hausdorff and regular **) 
(** LATEX VERSION: Hausdorff/regular properties preserved under subspaces and products (with factorwise assumptions). **)
Theorem product_topology_full_Hausdorff_axiom : forall I Xi:set,
  Hausdorff_spaces_family I Xi ->
  Hausdorff_space (product_space I Xi) (product_topology_full I Xi).
admit.
Qed.

Theorem product_topology_full_regular_axiom : forall I Xi:set,
  regular_spaces_family I Xi ->
  regular_space (product_space I Xi) (product_topology_full I Xi).
admit.
Qed.

Theorem separation_axioms_subspace_product : forall X Tx:set,
  topology_on X Tx ->
  (forall Y:set, Y c= X -> Hausdorff_space X Tx -> Hausdorff_space Y (subspace_topology X Tx Y)) /\
  (forall I Xi:set, Hausdorff_spaces_family I Xi -> Hausdorff_space (product_space I Xi) (product_topology_full I Xi)) /\
  (forall Y:set, Y c= X -> regular_space X Tx -> regular_space Y (subspace_topology X Tx Y)) /\
  (forall I Xi:set, regular_spaces_family I Xi -> regular_space (product_space I Xi) (product_topology_full I Xi)).
	let X Tx.
	assume HTx: topology_on X Tx.
	prove (forall Y:set, Y c= X -> Hausdorff_space X Tx -> Hausdorff_space Y (subspace_topology X Tx Y)) /\
	  (forall I Xi:set, Hausdorff_spaces_family I Xi -> Hausdorff_space (product_space I Xi) (product_topology_full I Xi)) /\
	  (forall Y:set, Y c= X -> regular_space X Tx -> regular_space Y (subspace_topology X Tx Y)) /\
	  (forall I Xi:set, regular_spaces_family I Xi -> regular_space (product_space I Xi) (product_topology_full I Xi)).
	apply andI.
	- apply andI.
		  + apply andI.
		    - let Y. assume HYsub: Y c= X.
		      assume HH: Hausdorff_space X Tx.
		      prove Hausdorff_space Y (subspace_topology X Tx Y).
		      exact (ex17_12_subspace_Hausdorff X Tx Y HH HYsub).
		    - let I Xi. assume HHfam: Hausdorff_spaces_family I Xi.
		      exact (product_topology_full_Hausdorff_axiom I Xi HHfam).
			  + let Y. assume HYsub: Y c= X.
			    assume Hreg: regular_space X Tx.
			    prove one_point_sets_closed Y (subspace_topology X Tx Y) /\
		      forall y0:set, y0 :e Y ->
		        forall F0:set, closed_in Y (subspace_topology X Tx Y) F0 -> y0 /:e F0 ->
		          exists U V:set, U :e subspace_topology X Tx Y /\ V :e subspace_topology X Tx Y /\ y0 :e U /\ F0 c= V /\ U :/\: V = Empty.
		    claim HTy: topology_on Y (subspace_topology X Tx Y).
		    { exact (subspace_topology_is_topology X Tx Y HTx HYsub). }
	    claim HT1X: one_point_sets_closed X Tx.
	    { exact (andEL (one_point_sets_closed X Tx)
	                   (forall x:set, x :e X ->
	                     forall F:set, closed_in X Tx F -> x /:e F ->
	                       exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty)
	                   Hreg). }
	    claim HsingX: forall x:set, x :e X -> closed_in X Tx {x}.
	    { exact (andER (topology_on X Tx) (forall x:set, x :e X -> closed_in X Tx {x}) HT1X). }
	    claim HsepX:
	      forall x:set, x :e X ->
	        forall F:set, closed_in X Tx F -> x /:e F ->
	          exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty.
	    { exact (andER (one_point_sets_closed X Tx)
	                   (forall x:set, x :e X ->
	                     forall F:set, closed_in X Tx F -> x /:e F ->
	                       exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty)
	                   Hreg). }
		    apply andI.
			    - prove topology_on Y (subspace_topology X Tx Y) /\
			        forall y:set, y :e Y -> closed_in Y (subspace_topology X Tx Y) {y}.
			      apply andI.
			      + exact HTy.
			      + let y. assume HyY: y :e Y.
			        prove closed_in Y (subspace_topology X Tx Y) {y}.
		        claim HyX: y :e X.
		        { exact (HYsub y HyY). }
	        apply (iffER (closed_in Y (subspace_topology X Tx Y) {y})
	                     (exists C:set, closed_in X Tx C /\ {y} = C :/\: Y)
	                     (closed_in_subspace_iff_intersection X Tx Y {y} HTx HYsub)).
	        witness {y}.
	        apply andI.
	        - exact (HsingX y HyX).
	        - apply set_ext.
	          + let z. assume Hz: z :e {y}.
	            prove z :e {y} :/\: Y.
	            claim Hzeq: z = y.
	            { exact (SingE y z Hz). }
	            rewrite Hzeq.
	            exact (binintersectI {y} Y y (SingI y) HyY).
	          + let z. assume Hz: z :e {y} :/\: Y.
	            prove z :e {y}.
	            exact (binintersectE1 {y} Y z Hz).
		    - let y. assume HyY: y :e Y.
		      let F. assume HFcl: closed_in Y (subspace_topology X Tx Y) F.
		      assume HynotF: y /:e F.
		      prove exists U V:set, U :e subspace_topology X Tx Y /\ V :e subspace_topology X Tx Y /\ y :e U /\ F c= V /\ U :/\: V = Empty.
		      claim HyX: y :e X.
		      { exact (HYsub y HyY). }
	      claim HexC: exists C:set, closed_in X Tx C /\ F = C :/\: Y.
	      { exact (iffEL (closed_in Y (subspace_topology X Tx Y) F)
	                     (exists C:set, closed_in X Tx C /\ F = C :/\: Y)
	                     (closed_in_subspace_iff_intersection X Tx Y F HTx HYsub)
	                     HFcl). }
		      set C0 := Eps_i (fun C:set => closed_in X Tx C /\ F = C :/\: Y).
		      claim HC0prop: closed_in X Tx C0 /\ F = C0 :/\: Y.
		      { exact (Eps_i_ex (fun C:set => closed_in X Tx C /\ F = C :/\: Y) HexC). }
	      claim HC0cl: closed_in X Tx C0.
	      { exact (andEL (closed_in X Tx C0) (F = C0 :/\: Y) HC0prop). }
	      claim HFeq: F = C0 :/\: Y.
	      { exact (andER (closed_in X Tx C0) (F = C0 :/\: Y) HC0prop). }
	      claim HynotC0: y /:e C0.
	      { assume HyC0: y :e C0.
	        prove False.
	        claim HyF: y :e F.
	        { rewrite HFeq.
	          exact (binintersectI C0 Y y HyC0 HyY). }
	        exact (HynotF HyF). }
		      claim HexUV: exists U V:set, U :e Tx /\ V :e Tx /\ y :e U /\ C0 c= V /\ U :/\: V = Empty.
		      { exact (HsepX y HyX C0 HC0cl HynotC0). }
		      set Ux := Eps_i (fun U:set =>
		        exists V:set, U :e Tx /\ V :e Tx /\ y :e U /\ C0 c= V /\ U :/\: V = Empty).
		      claim HUxprop: exists V:set, Ux :e Tx /\ V :e Tx /\ y :e Ux /\ C0 c= V /\ Ux :/\: V = Empty.
		      { exact (Eps_i_ex (fun U:set =>
		               exists V:set, U :e Tx /\ V :e Tx /\ y :e U /\ C0 c= V /\ U :/\: V = Empty) HexUV). }
		      set Vx := Eps_i (fun V:set => Ux :e Tx /\ V :e Tx /\ y :e Ux /\ C0 c= V /\ Ux :/\: V = Empty).
		      claim HVxprop: Ux :e Tx /\ Vx :e Tx /\ y :e Ux /\ C0 c= Vx /\ Ux :/\: Vx = Empty.
		      { exact (Eps_i_ex (fun V:set => Ux :e Tx /\ V :e Tx /\ y :e Ux /\ C0 c= V /\ Ux :/\: V = Empty) HUxprop). }
		      claim H1234: ((Ux :e Tx /\ Vx :e Tx) /\ y :e Ux) /\ C0 c= Vx.
		      { exact (andEL (((Ux :e Tx /\ Vx :e Tx) /\ y :e Ux) /\ C0 c= Vx)
		                     (Ux :/\: Vx = Empty)
		                     HVxprop). }
		      claim HdisjUV: Ux :/\: Vx = Empty.
		      { exact (andER (((Ux :e Tx /\ Vx :e Tx) /\ y :e Ux) /\ C0 c= Vx)
		                     (Ux :/\: Vx = Empty)
		                     HVxprop). }
		      claim H123: (Ux :e Tx /\ Vx :e Tx) /\ y :e Ux.
		      { exact (andEL ((Ux :e Tx /\ Vx :e Tx) /\ y :e Ux) (C0 c= Vx) H1234). }
		      claim HC0subVx: C0 c= Vx.
		      { exact (andER ((Ux :e Tx /\ Vx :e Tx) /\ y :e Ux) (C0 c= Vx) H1234). }
		      claim H12: Ux :e Tx /\ Vx :e Tx.
		      { exact (andEL (Ux :e Tx /\ Vx :e Tx) (y :e Ux) H123). }
		      claim HyUx: y :e Ux.
		      { exact (andER (Ux :e Tx /\ Vx :e Tx) (y :e Ux) H123). }
		      claim HUxTx: Ux :e Tx.
		      { exact (andEL (Ux :e Tx) (Vx :e Tx) H12). }
		      claim HVxTx: Vx :e Tx.
		      { exact (andER (Ux :e Tx) (Vx :e Tx) H12). }
		      set U0 := Ux :/\: Y.
		      set V0 := Vx :/\: Y.
		      witness U0.
		      witness V0.
		      apply andI.
		      - apply andI.
		        + apply andI.
		          - apply andI.
		            + prove U0 :e subspace_topology X Tx Y.
		              claim HU0subY: U0 c= Y.
		              { exact (binintersect_Subq_2 Ux Y). }
		              claim HU0pow: U0 :e Power Y.
		              { exact (PowerI Y U0 HU0subY). }
		              claim HU0ex: exists V :e Tx, U0 = V :/\: Y.
		              { witness Ux.
		                apply andI.
		                - exact HUxTx.
		                - reflexivity. }
		              exact (SepI (Power Y) (fun U:set => exists V :e Tx, U = V :/\: Y) U0 HU0pow HU0ex).
		            + prove V0 :e subspace_topology X Tx Y.
		              claim HV0subY: V0 c= Y.
		              { exact (binintersect_Subq_2 Vx Y). }
		              claim HV0pow: V0 :e Power Y.
		              { exact (PowerI Y V0 HV0subY). }
		              claim HV0ex: exists V :e Tx, V0 = V :/\: Y.
		              { witness Vx.
		                apply andI.
		                - exact HVxTx.
		                - reflexivity. }
		              exact (SepI (Power Y) (fun U:set => exists V :e Tx, U = V :/\: Y) V0 HV0pow HV0ex).
		          - exact (binintersectI Ux Y y HyUx HyY).
		        + let z. assume HzF: z :e F.
		          prove z :e V0.
		          claim HzCY: z :e C0 :/\: Y.
		          { rewrite <- HFeq. exact HzF. }
		          claim HzC0: z :e C0.
		          { exact (binintersectE1 C0 Y z HzCY). }
		          claim HzY: z :e Y.
		          { exact (binintersectE2 C0 Y z HzCY). }
		          claim HzVx: z :e Vx.
		          { exact (HC0subVx z HzC0). }
		          exact (binintersectI Vx Y z HzVx HzY).
		      - apply Empty_Subq_eq.
		        let z. assume Hz: z :e U0 :/\: V0.
		        prove z :e Empty.
		        claim HzU0: z :e U0.
		        { exact (binintersectE1 U0 V0 z Hz). }
		        claim HzV0: z :e V0.
		        { exact (binintersectE2 U0 V0 z Hz). }
		        claim HzUx: z :e Ux.
		        { exact (binintersectE1 Ux Y z HzU0). }
		        claim HzVx: z :e Vx.
		        { exact (binintersectE1 Vx Y z HzV0). }
		        claim HzUV: z :e Ux :/\: Vx.
		        { exact (binintersectI Ux Vx z HzUx HzVx). }
			        rewrite <- HdisjUV.
			        exact HzUV.
		- let I Xi. assume Hrfam: regular_spaces_family I Xi.
		  exact (product_topology_full_regular_axiom I Xi Hrfam).
Qed.

(** from 31 Example 1 setup: R_K space **) 
(** LATEX VERSION: Let R_K denote the real line equipped later with the K-topology. **)
Definition R_K : set := R.

(** from 31 Example 1: R_K Hausdorff but not regular **) 
(** LATEX VERSION: The K-topology on  is Hausdorff but not regular. **)
Theorem RK_not_regular_axiom : ~ regular_space R_K R_K_topology.
admit.
Qed.
Theorem RK_Hausdorff_not_regular :
  Hausdorff_space R_K R_K_topology /\ ~ regular_space R_K R_K_topology.
prove Hausdorff_space R_K R_K_topology /\ ~ regular_space R_K R_K_topology.
apply andI.
- (** Hausdorff part follows from earlier theorem about R_K_topology **)
  claim HRKeq: R_K = R.
  { reflexivity. }
  rewrite HRKeq.
  exact R_K_topology_Hausdorff.
- (** Not regular: standard counterexample at 0 using closed set K_set; pending full formal proof. **)
  exact RK_not_regular_axiom.
Qed.

(** from 31 Example 2: Sorgenfrey line normal **) 
(** LATEX VERSION: The Sorgenfrey line is normal. **)
Theorem Sorgenfrey_line_normal : normal_space Sorgenfrey_line Sorgenfrey_topology.
prove normal_space Sorgenfrey_line Sorgenfrey_topology.
admit.
Qed.

(** from 31 Example 3: Sorgenfrey plane not normal **) 
(** LATEX VERSION: The Sorgenfrey plane is regular but not normal. **)
Theorem Sorgenfrey_plane_not_normal :
  regular_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology /\
  ~ normal_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology.
prove regular_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology /\
  ~ normal_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology.
admit.
Qed.

(** from 32 Theorem 32.1: regular space with countable basis is normal **) 
(** LATEX VERSION: Regular + second countable  normal (Theorem 32.1). **)
Theorem regular_countable_basis_normal : forall X Tx:set,
  regular_space X Tx -> second_countable_space X Tx -> normal_space X Tx.
let X Tx.
assume Hreg: regular_space X Tx.
assume Hscc: second_countable_space X Tx.
prove normal_space X Tx.
admit.
Qed.

(** from 32 Theorem 32.4: well-ordered sets are normal in order topology **) 
(** LATEX VERSION: Well-ordered sets with the order topology are normal. **)
Theorem well_ordered_sets_normal : forall X:set,
  well_ordered_set X -> normal_space X (order_topology X).
let X.
assume Hwo: well_ordered_set X.
prove normal_space X (order_topology X).
admit.
Qed.
(** from 32 Theorem 32.2: metrizable spaces are normal **) 
(** LATEX VERSION: Every metrizable space is normal. **)
Theorem metrizable_spaces_normal : forall X d:set,
  metric_on X d -> normal_space X (metric_topology X d).
let X d.
assume Hd: metric_on X d.
prove normal_space X (metric_topology X d).
admit.
Qed.

(** from 32 Theorem 32.3: compact Hausdorff spaces are normal **) 
(** LATEX VERSION: Compact Hausdorff  normal (Theorem 32.3). **)
Theorem compact_Hausdorff_normal : forall X Tx:set,
  compact_space X Tx -> Hausdorff_space X Tx -> normal_space X Tx.
let X Tx.
assume Hcomp: compact_space X Tx.
assume HH: Hausdorff_space X Tx.
prove normal_space X Tx.
claim HTx: topology_on X Tx.
{ exact (compact_space_topology X Tx Hcomp). }
claim HT1: one_point_sets_closed X Tx.
{ prove topology_on X Tx /\ forall x:set, x :e X -> closed_in X Tx {x}.
  apply andI.
  - exact HTx.
  - let x. assume HxX: x :e X.
    exact (Hausdorff_singletons_closed X Tx x HH HxX). }
prove one_point_sets_closed X Tx /\
  forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
    exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.
apply andI.
- exact HT1.
- let A B.
  assume HAcl: closed_in X Tx A.
  assume HBcl: closed_in X Tx B.
  assume Hdisj: A :/\: B = Empty.
  prove exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.
  claim HAsubX: A c= X.
  { exact (closed_in_subset X Tx A HAcl). }
  claim HBsubX: B c= X.
  { exact (closed_in_subset X Tx B HBcl). }
  claim HcompA: compact_space A (subspace_topology X Tx A).
  { exact (closed_subspace_compact X Tx A Hcomp HAcl). }
  claim HcompB: compact_space B (subspace_topology X Tx B).
  { exact (closed_subspace_compact X Tx B Hcomp HBcl). }

  (** For each aA, separate a from compact B. **)
  set Uof := fun a:set =>
    Eps_i (fun U:set => exists V:set, U :e Tx /\ V :e Tx /\ a :e U /\ B c= V /\ U :/\: V = Empty).
  set Vof := fun a:set =>
    Eps_i (fun V:set => Uof a :e Tx /\ V :e Tx /\ a :e Uof a /\ B c= V /\ Uof a :/\: V = Empty).

  claim UVprop: forall a:set, a :e A ->
    Uof a :e Tx /\ (Vof a :e Tx /\ (a :e Uof a /\ (B c= Vof a /\ Uof a :/\: Vof a = Empty))).
  { let a. assume HaA: a :e A.
    claim HaX: a :e X.
    { exact (HAsubX a HaA). }
    claim HanotB: a /:e B.
    { assume HaB: a :e B.
      claim HaAB: a :e A :/\: B.
      { exact (binintersectI A B a HaA HaB). }
      claim HaE: a :e Empty.
      { rewrite <- Hdisj. exact HaAB. }
      apply FalseE.
      exact (EmptyE a HaE False). }
    claim HexUV: exists U V:set, U :e Tx /\ V :e Tx /\ a :e U /\ B c= V /\ U :/\: V = Empty.
    { exact (Hausdorff_separate_point_compact_set X Tx B a HH HBsubX HcompB HaX HanotB). }
    claim HUof: exists V:set, Uof a :e Tx /\ V :e Tx /\ a :e Uof a /\ B c= V /\ Uof a :/\: V = Empty.
    { exact (Eps_i_ex (fun U:set => exists V:set, U :e Tx /\ V :e Tx /\ a :e U /\ B c= V /\ U :/\: V = Empty) HexUV). }
    claim HVof: Uof a :e Tx /\ Vof a :e Tx /\ a :e Uof a /\ B c= Vof a /\ Uof a :/\: Vof a = Empty.
    { exact (Eps_i_ex (fun V:set => Uof a :e Tx /\ V :e Tx /\ a :e Uof a /\ B c= V /\ Uof a :/\: V = Empty) HUof). }
    (** Repackage the left-associated 5-way conjunction into a right-associated form. **)
    claim H1234: ((Uof a :e Tx /\ Vof a :e Tx) /\ a :e Uof a) /\ B c= Vof a.
    { exact (andEL (((Uof a :e Tx /\ Vof a :e Tx) /\ a :e Uof a) /\ B c= Vof a)
                   (Uof a :/\: Vof a = Empty)
                   HVof). }
    claim H5: Uof a :/\: Vof a = Empty.
    { exact (andER (((Uof a :e Tx /\ Vof a :e Tx) /\ a :e Uof a) /\ B c= Vof a)
                   (Uof a :/\: Vof a = Empty)
                   HVof). }
    claim H123: (Uof a :e Tx /\ Vof a :e Tx) /\ a :e Uof a.
    { exact (andEL ((Uof a :e Tx /\ Vof a :e Tx) /\ a :e Uof a)
                   (B c= Vof a)
                   H1234). }
    claim H4: B c= Vof a.
    { exact (andER ((Uof a :e Tx /\ Vof a :e Tx) /\ a :e Uof a)
                   (B c= Vof a)
                   H1234). }
    claim H12: Uof a :e Tx /\ Vof a :e Tx.
    { exact (andEL (Uof a :e Tx /\ Vof a :e Tx)
                   (a :e Uof a)
                   H123). }
    claim H3: a :e Uof a.
    { exact (andER (Uof a :e Tx /\ Vof a :e Tx)
                   (a :e Uof a)
                   H123). }
    claim HUofTx: Uof a :e Tx.
    { exact (andEL (Uof a :e Tx) (Vof a :e Tx) H12). }
    claim HVofTx: Vof a :e Tx.
    { exact (andER (Uof a :e Tx) (Vof a :e Tx) H12). }
    apply andI.
    - exact HUofTx.
	    - apply andI.
	      + exact HVofTx.
	      + apply andI.
	        * exact H3.
	        * apply andI.
	          - exact H4.
	          - exact H5. }

  (** Cover A by opens Uof a. **)
  set Fam := {Uof a|a :e A}.
  claim HFamSub: Fam c= Tx.
  { let U. assume HU: U :e Fam.
    apply (ReplE_impred A (fun a:set => Uof a) U HU (U :e Tx)).
    let a. assume HaA: a :e A.
    assume HUeq: U = Uof a.
    claim HUofTx: Uof a :e Tx.
    { exact (andEL (Uof a :e Tx)
                   (Vof a :e Tx /\ (a :e Uof a /\ (B c= Vof a /\ Uof a :/\: Vof a = Empty)))
                   (UVprop a HaA)). }
    rewrite HUeq.
    exact HUofTx. }
  claim HAcov: A c= Union Fam.
  { let a. assume HaA: a :e A.
    prove a :e Union Fam.
    claim HaU: a :e Uof a.
    { exact (andEL (a :e Uof a)
                   (B c= Vof a /\ Uof a :/\: Vof a = Empty)
                   (andER (Vof a :e Tx)
                          (a :e Uof a /\ (B c= Vof a /\ Uof a :/\: Vof a = Empty))
                          (andER (Uof a :e Tx)
                                 (Vof a :e Tx /\ (a :e Uof a /\ (B c= Vof a /\ Uof a :/\: Vof a = Empty)))
                                 (UVprop a HaA)))). }
    claim HUinFam: Uof a :e Fam.
    { exact (ReplI A (fun a0:set => Uof a0) a HaA). }
    exact (UnionI Fam a (Uof a) HaU HUinFam). }

  (** Use compactness of A to extract a finite subcover from Fam. **)
  claim HcoverProp: forall Fam0:set, (Fam0 c= Tx /\ A c= Union Fam0) -> has_finite_subcover A Tx Fam0.
  { claim Hequiv:
      (compact_space A (subspace_topology X Tx A) <->
        forall Fam0:set, (Fam0 c= Tx /\ A c= Union Fam0) -> has_finite_subcover A Tx Fam0).
    { exact (compact_subspace_via_ambient_covers X Tx A HTx HAsubX). }
    exact (iffEL (compact_space A (subspace_topology X Tx A))
                 (forall Fam0:set, (Fam0 c= Tx /\ A c= Union Fam0) -> has_finite_subcover A Tx Fam0)
                 Hequiv HcompA). }

  claim Hfin: has_finite_subcover A Tx Fam.
  { exact (HcoverProp Fam (andI (Fam c= Tx) (A c= Union Fam) HFamSub HAcov)). }
  apply Hfin.
  let G. assume HG: G c= Fam /\ finite G /\ A c= Union G.
  claim HGleft: G c= Fam /\ finite G.
  { exact (andEL (G c= Fam /\ finite G) (A c= Union G) HG). }
  claim HGsubFam: G c= Fam.
  { exact (andEL (G c= Fam) (finite G) HGleft). }
  claim HGfin: finite G.
  { exact (andER (G c= Fam) (finite G) HGleft). }
  claim HAcovG: A c= Union G.
  { exact (andER (G c= Fam /\ finite G) (A c= Union G) HG). }
  claim HGsubTx: G c= Tx.
  { let U. assume HU: U :e G.
    prove U :e Tx.
    claim HUfam: U :e Fam.
    { exact (HGsubFam U HU). }
    exact (HFamSub U HUfam). }

  (** Define U = union of the finite subcover G. **)
  set U := Union G.
  claim HUtx: U :e Tx.
  { exact (topology_union_closed X Tx G HTx HGsubTx). }

  (** Pick an index a(U) for each UG with U = Uof a(U). **)
  set Wof := fun U0:set => Eps_i (fun a:set => a :e A /\ U0 = Uof a).
  claim Wof_spec: forall U0:set, U0 :e G -> Wof U0 :e A /\ U0 = Uof (Wof U0).
  { let U0. assume HU0G: U0 :e G.
    claim HU0Fam: U0 :e Fam.
    { exact (HGsubFam U0 HU0G). }
    claim Hexa: exists a:set, a :e A /\ U0 = Uof a.
    { apply (ReplE_impred A (fun a0:set => Uof a0) U0 HU0Fam (exists a:set, a :e A /\ U0 = Uof a)).
      let a. assume HaA: a :e A.
      assume HU0eq: U0 = Uof a.
      witness a.
      apply andI.
      - exact HaA.
      - exact HU0eq. }
    apply Hexa.
    let a. assume HaPair: a :e A /\ U0 = Uof a.
    exact (Eps_i_ax (fun a0:set => a0 :e A /\ U0 = Uof a0) a HaPair). }

  (** Define the corresponding family of V's and take their finite intersection. **)
  set GV := {Vof (Wof U0)|U0 :e G}.
  claim HGVfin: finite GV.
  { exact (Repl_finite (fun U0:set => Vof (Wof U0)) G HGfin). }
  claim HGVsubTx: GV c= Tx.
  { let V. assume HV: V :e GV.
    apply (ReplE_impred G (fun U0:set => Vof (Wof U0)) V HV (V :e Tx)).
    let U0. assume HU0G: U0 :e G.
    assume HVe: V = Vof (Wof U0).
    claim HWofA: Wof U0 :e A.
    { exact (andEL (Wof U0 :e A) (U0 = Uof (Wof U0)) (Wof_spec U0 HU0G)). }
    claim HVofTx: Vof (Wof U0) :e Tx.
    { exact (andEL (Vof (Wof U0) :e Tx)
                   (Wof U0 :e Uof (Wof U0) /\ (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty))
                   (andER (Uof (Wof U0) :e Tx)
                          (Vof (Wof U0) :e Tx /\ (Wof U0 :e Uof (Wof U0) /\ (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty)))
                          (UVprop (Wof U0) HWofA))). }
    rewrite HVe.
    exact HVofTx. }

  set V := intersection_of_family X GV.
  claim HVtx: V :e Tx.
  { claim HGVpow: GV :e Power Tx.
    { apply PowerI.
      exact HGVsubTx. }
    exact (finite_intersection_in_topology X Tx GV HTx HGVpow HGVfin). }

  (** B is contained in V since each Vof a contains B. **)
  claim HBsubV: B c= V.
  { let b. assume HbB: b :e B.
    prove b :e V.
    claim HbPred: forall U1:set, U1 :e GV -> b :e U1.
    { let W. assume HW: W :e GV.
      prove b :e W.
      apply (ReplE_impred G (fun U0:set => Vof (Wof U0)) W HW (b :e W)).
      let U0. assume HU0G: U0 :e G.
      assume HWeq: W = Vof (Wof U0).
      claim HWofA: Wof U0 :e A.
      { exact (andEL (Wof U0 :e A) (U0 = Uof (Wof U0)) (Wof_spec U0 HU0G)). }
      claim HUV1:
        Vof (Wof U0) :e Tx /\
        (Wof U0 :e Uof (Wof U0) /\ (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty)).
      { exact (andER (Uof (Wof U0) :e Tx)
                     (Vof (Wof U0) :e Tx /\ (Wof U0 :e Uof (Wof U0) /\ (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty)))
                     (UVprop (Wof U0) HWofA)). }
      claim HUV2:
        Wof U0 :e Uof (Wof U0) /\ (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty).
      { exact (andER (Vof (Wof U0) :e Tx)
                     (Wof U0 :e Uof (Wof U0) /\ (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty))
                     HUV1). }
      claim HUV3: B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty.
      { exact (andER (Wof U0 :e Uof (Wof U0))
                     (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty)
                     HUV2). }
      claim HBsubVof: B c= Vof (Wof U0).
      { exact (andEL (B c= Vof (Wof U0))
                     (Uof (Wof U0) :/\: Vof (Wof U0) = Empty)
                     HUV3). }
      rewrite HWeq.
      exact (HBsubVof b HbB). }
    exact (SepI X (fun x:set => forall U1:set, U1 :e GV -> x :e U1) b (HBsubX b HbB) HbPred). }

  (** U and V are disjoint. **)
  claim HUVdisj: U :/\: V = Empty.
  { apply Empty_Subq_eq.
    let z. assume Hz: z :e U :/\: V.
    prove z :e Empty.
    claim HzU: z :e U.
    { exact (binintersectE1 U V z Hz). }
    claim HzV: z :e V.
    { exact (binintersectE2 U V z Hz). }
    apply (UnionE_impred G z HzU (z :e Empty)).
    let U0. assume HzU0: z :e U0.
    assume HU0G: U0 :e G.
    claim HWofA: Wof U0 :e A.
    { exact (andEL (Wof U0 :e A) (U0 = Uof (Wof U0)) (Wof_spec U0 HU0G)). }
    claim HU0eq: U0 = Uof (Wof U0).
    { exact (andER (Wof U0 :e A) (U0 = Uof (Wof U0)) (Wof_spec U0 HU0G)). }
    claim HVinGV: Vof (Wof U0) :e GV.
    { exact (ReplI G (fun U1:set => Vof (Wof U1)) U0 HU0G). }
    claim HzVof: z :e Vof (Wof U0).
    { exact (SepE2 X (fun x:set => forall U1:set, U1 :e GV -> x :e U1) z HzV (Vof (Wof U0)) HVinGV). }
    claim HzUof: z :e Uof (Wof U0).
    { rewrite <- HU0eq. exact HzU0. }
    claim Hdisj0: Uof (Wof U0) :/\: Vof (Wof U0) = Empty.
    { claim HUV1:
        Vof (Wof U0) :e Tx /\
        (Wof U0 :e Uof (Wof U0) /\ (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty)).
      { exact (andER (Uof (Wof U0) :e Tx)
                     (Vof (Wof U0) :e Tx /\ (Wof U0 :e Uof (Wof U0) /\ (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty)))
                     (UVprop (Wof U0) HWofA)). }
      claim HUV2:
        Wof U0 :e Uof (Wof U0) /\ (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty).
      { exact (andER (Vof (Wof U0) :e Tx)
                     (Wof U0 :e Uof (Wof U0) /\ (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty))
                     HUV1). }
      claim HUV3: B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty.
      { exact (andER (Wof U0 :e Uof (Wof U0))
                     (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty)
                     HUV2). }
      exact (andER (B c= Vof (Wof U0))
                   (Uof (Wof U0) :/\: Vof (Wof U0) = Empty)
                   HUV3). }
    claim HzUV0: z :e Uof (Wof U0) :/\: Vof (Wof U0).
    { exact (binintersectI (Uof (Wof U0)) (Vof (Wof U0)) z HzUof HzVof). }
    rewrite <- Hdisj0.
    exact HzUV0. }

  (** Build the final neighborhoods. **)
  witness U.
  witness V.
  apply andI.
  - apply andI.
    - apply andI.
      - apply andI.
        - exact HUtx.
        - exact HVtx.
      - exact HAcovG.
    - exact HBsubV.
  - exact HUVdisj.
Qed.

(** from 32 Example 1: uncountable product of R not normal **) 
(** LATEX VERSION: An uncountable product of  with product topology need not be normal. **)
Theorem uncountable_product_R_not_normal : forall J:set,
  uncountable_set J -> ~ normal_space (product_space J (const_space_family J R R_standard_topology)) (product_topology_full J (const_space_family J R R_standard_topology)).
let J.
assume HJ: uncountable_set J.
prove ~ normal_space (product_space J (const_space_family J R R_standard_topology)) (product_topology_full J (const_space_family J R R_standard_topology)).
admit.
Qed.

(** from 32 Example 2: SOmega x SbarOmega not normal **)
(** LATEX VERSION: Product S_S_ gives a non-normal example. **)
(** FIXED: Use the binary product topology on S_Omega  Sbar_Omega, not a function-space product indexed by S_Omega  Sbar_Omega. **) 
Definition S_Omega : set := omega.
Definition Sbar_Omega : set := Power omega.
Definition SOmega_topology : set := discrete_topology S_Omega.
Definition SbarOmega_topology : set := discrete_topology Sbar_Omega.

Theorem SOmega_SbarOmega_not_normal :
  normal_space S_Omega SOmega_topology /\ normal_space Sbar_Omega SbarOmega_topology /\
  ~ normal_space (setprod S_Omega Sbar_Omega) (product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology).
prove normal_space S_Omega SOmega_topology /\ normal_space Sbar_Omega SbarOmega_topology /\
  ~ normal_space (setprod S_Omega Sbar_Omega) (product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology).
apply andI.
- prove normal_space S_Omega SOmega_topology /\ normal_space Sbar_Omega SbarOmega_topology.
  apply andI.
  * claim HSO: SOmega_topology = discrete_topology S_Omega.
    { reflexivity. }
    rewrite HSO.
    exact (discrete_normal_space S_Omega).
  * claim HSb: SbarOmega_topology = discrete_topology Sbar_Omega.
    { reflexivity. }
	    rewrite HSb.
	    exact (discrete_normal_space Sbar_Omega).
	- admit.
Qed.

(** from 33 Theorem 33.1 (Urysohn lemma): continuous function separating closed sets in normal space **)
(** LATEX VERSION: Urysohn lemma: In a normal space, disjoint closed sets can be separated by continuous f: X[a,b]. **)
(** FIXED: Urysohn_lemma includes separation conditions f|A = a and f|B = b, not merely existence of some continuous f. **) 
Definition closed_interval : set -> set -> set := fun a b =>
  {x :e R | ~(Rlt x a) /\ ~(Rlt b x)}.

Theorem Urysohn_lemma : forall X Tx A B a b:set,
  normal_space X Tx -> closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
  exists f:set, continuous_map X Tx (closed_interval a b) (order_topology (closed_interval a b)) f /\
    (forall x:set, x :e A -> apply_fun f x = a) /\
    (forall x:set, x :e B -> apply_fun f x = b).
let X Tx A B a b.
assume Hnorm: normal_space X Tx.
assume HA: closed_in X Tx A.
assume HB: closed_in X Tx B.
assume Hdisj: A :/\: B = Empty.
prove exists f:set, continuous_map X Tx (closed_interval a b) (order_topology (closed_interval a b)) f /\
    (forall x:set, x :e A -> apply_fun f x = a) /\
    (forall x:set, x :e B -> apply_fun f x = b).
admit.
Qed.

(** from 33 Definition: completely regular space **) 
(** LATEX VERSION: Completely regular (Tikhonov) spaces admit continuous [0,1]-valued functions separating point and closed set. **)
Definition completely_regular_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall x:set, x :e X ->
    forall F:set, closed_in X Tx F -> x /:e F ->
      exists f:set,
        continuous_map X Tx R R_standard_topology f /\
        apply_fun f x = 0 /\ forall y:set, y :e F -> apply_fun f y = 1.

(** LATEX VERSION: Completely regular family helper. **)
Definition completely_regular_spaces_family : set -> set -> prop := fun I Xi =>
  forall i:set, i :e I ->
    completely_regular_space (product_component Xi i) (product_component_topology Xi i).

(** Helper: any function is continuous from a discrete domain **)
Theorem continuous_from_discrete : forall X Y Ty f:set,
  topology_on Y Ty ->
  function_on f X Y ->
  continuous_map X (discrete_topology X) Y Ty f.
let X Y Ty f.
assume HTy: topology_on Y Ty.
assume Hfun: function_on f X Y.
prove continuous_map X (discrete_topology X) Y Ty f.
claim HTx: topology_on X (discrete_topology X).
{ exact (discrete_topology_on X). }
prove topology_on X (discrete_topology X) /\ topology_on Y Ty /\ function_on f X Y /\
  forall V:set, V :e Ty -> preimage_of X f V :e discrete_topology X.
apply andI.
- prove (topology_on X (discrete_topology X) /\ topology_on Y Ty) /\ function_on f X Y.
  apply andI.
  * apply andI.
    - exact HTx.
    - exact HTy.
  * exact Hfun.
- let V. assume HV: V :e Ty.
  prove preimage_of X f V :e discrete_topology X.
  claim Hsub: preimage_of X f V c= X.
  { let x. assume Hx: x :e preimage_of X f V.
    exact (SepE1 X (fun u => apply_fun f u :e V) x Hx). }
  exact (discrete_open_all X (preimage_of X f V) Hsub).
Qed.

(** Helper: congruence for tuple coordinates **)
Theorem tuple_2_0_congr : forall a b c d:set, (a,b) = (c,d) -> a = c.
let a b c d.
assume Heq: (a,b) = (c,d).
prove a = c.
rewrite <- (tuple_2_0_eq a b) at 1.
rewrite <- (tuple_2_0_eq c d).
rewrite Heq.
reflexivity.
Qed.

Theorem tuple_2_1_congr : forall a b c d:set, (a,b) = (c,d) -> b = d.
let a b c d.
assume Heq: (a,b) = (c,d).
prove b = d.
rewrite <- (tuple_2_1_eq a b) at 1.
rewrite <- (tuple_2_1_eq c d).
rewrite Heq.
reflexivity.
Qed.

(** Helper: projections from membership in const_fun graphs **)
Theorem const_fun_pair_first : forall A x a y:set, (a,y) :e const_fun A x -> a :e A.
let A x a y.
assume H: (a,y) :e const_fun A x.
prove a :e A.
apply (ReplE_impred A (fun a0:set => (a0,x)) (a,y) H (a :e A)).
let a0. assume Ha0: a0 :e A.
assume Heq: (a,y) = (a0,x).
claim Ha: a = a0.
{ exact (tuple_2_0_congr a y a0 x Heq). }
rewrite Ha.
exact Ha0.
Qed.

Theorem const_fun_pair_second : forall A x a y:set, (a,y) :e const_fun A x -> y = x.
let A x a y.
assume H: (a,y) :e const_fun A x.
prove y = x.
apply (ReplE_impred A (fun a0:set => (a0,x)) (a,y) H (y = x)).
let a0. assume _: a0 :e A.
assume Heq: (a,y) = (a0,x).
exact (tuple_2_1_congr a y a0 x Heq).
Qed.

(** Helper: discrete topology is completely regular **)
Theorem discrete_completely_regular_space : forall X:set,
  completely_regular_space X (discrete_topology X).
let X.
prove completely_regular_space X (discrete_topology X).
claim HTx: topology_on X (discrete_topology X).
{ exact (discrete_topology_on X). }
prove topology_on X (discrete_topology X) /\
  forall x:set, x :e X ->
    forall F:set, closed_in X (discrete_topology X) F -> x /:e F ->
      exists f:set,
        continuous_map X (discrete_topology X) R R_standard_topology f /\
        apply_fun f x = 0 /\ forall y:set, y :e F -> apply_fun f y = 1.
apply andI.
- exact HTx.
- let x. assume HxX: x :e X.
  let F. assume HFcl: closed_in X (discrete_topology X) F.
  assume HxnotF: x /:e F.
  prove exists f:set,
    continuous_map X (discrete_topology X) R R_standard_topology f /\
    apply_fun f x = 0 /\ forall y:set, y :e F -> apply_fun f y = 1.
  claim HFsubX: F c= X.
  { exact (closed_in_subset X (discrete_topology X) F HFcl). }
  set A0 := X :\: F.
  claim HA0def: A0 = X :\: F.
  { reflexivity. }
  set f := (const_fun A0 0) :\/: (const_fun F 1).
  witness f.
  claim HRtop: topology_on R R_standard_topology.
  { exact R_standard_topology_is_topology. }
  claim H0R: 0 :e R.
  { exact real_0. }
  claim H1R: 1 :e R.
  { exact real_1. }

  claim Happ0: forall z:set, z :e X -> z /:e F -> apply_fun f z = 0.
  { let z. assume HzX: z :e X.
    assume HznotF: z /:e F.
    prove apply_fun f z = 0.
    claim HzA0: z :e A0.
    { rewrite HA0def.
      exact (setminusI X F z HzX HznotF). }
    claim Hpair0: (z,0) :e f.
    { apply binunionI1.
      exact (ReplI A0 (fun a0:set => (a0,0)) z HzA0). }
    claim Hzgraph: (z, apply_fun f z) :e f.
    { exact (Eps_i_ax (fun y:set => (z,y) :e f) 0 Hpair0). }
    apply (binunionE' (const_fun A0 0) (const_fun F 1) (z, apply_fun f z) (apply_fun f z = 0)).
    - assume Hleft: (z, apply_fun f z) :e const_fun A0 0.
      exact (const_fun_pair_second A0 0 z (apply_fun f z) Hleft).
    - assume Hright: (z, apply_fun f z) :e const_fun F 1.
      claim HzF: z :e F.
      { exact (const_fun_pair_first F 1 z (apply_fun f z) Hright). }
      apply FalseE.
      exact (HznotF HzF).
    - exact Hzgraph. }

  claim Happ1: forall z:set, z :e X -> z :e F -> apply_fun f z = 1.
  { let z. assume HzX: z :e X.
    assume HzF: z :e F.
    prove apply_fun f z = 1.
    claim Hpair1: (z,1) :e f.
    { apply binunionI2.
      exact (ReplI F (fun a0:set => (a0,1)) z HzF). }
    claim Hzgraph: (z, apply_fun f z) :e f.
    { exact (Eps_i_ax (fun y:set => (z,y) :e f) 1 Hpair1). }
    apply (binunionE' (const_fun A0 0) (const_fun F 1) (z, apply_fun f z) (apply_fun f z = 1)).
    - assume Hleft: (z, apply_fun f z) :e const_fun A0 0.
      claim HzA0: z :e A0.
      { exact (const_fun_pair_first A0 0 z (apply_fun f z) Hleft). }
      claim HznotF: z /:e F.
      { claim HzXF: z :e X :\: F.
        { rewrite <- HA0def.
          exact HzA0. }
        exact (setminusE2 X F z HzXF). }
      apply FalseE.
      exact (HznotF HzF).
    - assume Hright: (z, apply_fun f z) :e const_fun F 1.
      exact (const_fun_pair_second F 1 z (apply_fun f z) Hright).
    - exact Hzgraph. }

  claim Hfun: function_on f X R.
  { let z. assume HzX: z :e X.
    prove apply_fun f z :e R.
    apply (xm (z :e F)).
    - assume HzF: z :e F.
      claim Hz1: apply_fun f z = 1.
      { exact (Happ1 z HzX HzF). }
      rewrite Hz1.
      exact H1R.
    - assume HznotF: z /:e F.
      claim Hz0: apply_fun f z = 0.
      { exact (Happ0 z HzX HznotF). }
      rewrite Hz0.
      exact H0R. }

  claim Hcont: continuous_map X (discrete_topology X) R R_standard_topology f.
  { exact (continuous_from_discrete X R R_standard_topology f HRtop Hfun). }

  claim Hfx0: apply_fun f x = 0.
  { exact (Happ0 x HxX HxnotF). }
  claim HfF1: forall y:set, y :e F -> apply_fun f y = 1.
  { let y. assume HyF: y :e F.
    claim HyX: y :e X.
    { exact (HFsubX y HyF). }
    exact (Happ1 y HyX HyF). }

  apply andI.
  * prove continuous_map X (discrete_topology X) R R_standard_topology f /\ apply_fun f x = 0.
    apply andI.
    - exact Hcont.
    - exact Hfx0.
  * exact HfF1.
Qed.

(** Helper: discrete topology is Hausdorff **)
Theorem discrete_Hausdorff_space : forall X:set,
  Hausdorff_space X (discrete_topology X).
let X.
prove Hausdorff_space X (discrete_topology X).
claim HTx: topology_on X (discrete_topology X).
{ exact (discrete_topology_on X). }
prove topology_on X (discrete_topology X) /\
  forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
    exists U V:set, U :e discrete_topology X /\ V :e discrete_topology X /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
apply andI.
- exact HTx.
- let x1 x2.
  assume Hx1X: x1 :e X.
  assume Hx2X: x2 :e X.
  assume Hneq: x1 <> x2.
  prove exists U V:set,
    U :e discrete_topology X /\ V :e discrete_topology X /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
  witness {x1}.
  witness {x2}.
  claim HUopen: {x1} :e discrete_topology X.
  { claim Hsx1: {x1} c= X.
    { exact (singleton_subset x1 X Hx1X). }
    exact (discrete_open_all X {x1} Hsx1). }
  claim HVopen: {x2} :e discrete_topology X.
  { claim Hsx2: {x2} c= X.
    { exact (singleton_subset x2 X Hx2X). }
    exact (discrete_open_all X {x2} Hsx2). }
  claim Hdisj: {x1} :/\: {x2} = Empty.
  { apply Empty_Subq_eq.
    let z. assume Hz: z :e {x1} :/\: {x2}.
    prove z :e Empty.
    claim Hz1: z :e {x1}.
    { exact (binintersectE1 {x1} {x2} z Hz). }
    claim Hz2: z :e {x2}.
    { exact (binintersectE2 {x1} {x2} z Hz). }
    claim Hzx1: z = x1.
    { exact (SingE x1 z Hz1). }
    claim Hzx2: z = x2.
    { exact (SingE x2 z Hz2). }
    claim Hx1x2: x1 = x2.
    { rewrite <- Hzx1.
      rewrite <- Hzx2.
      reflexivity. }
    apply FalseE.
    exact (Hneq Hx1x2). }
  apply and5I.
  - exact HUopen.
  - exact HVopen.
  - exact (SingI x1).
  - exact (SingI x2).
  - exact Hdisj.
Qed.

(** from 33 Definition: Tychonoff space **) 
(** LATEX VERSION: Tychonoff = completely regular and Hausdorff. **)
Definition Tychonoff_space : set -> set -> prop := fun X Tx =>
  completely_regular_space X Tx /\ Hausdorff_space X Tx.

(** from 33 Theorem 33.2: subspaces/products of completely regular spaces **) 
(** LATEX VERSION: Subspaces and products of completely regular spaces remain completely regular. **)
Theorem completely_regular_subspace_product : forall X Tx:set,
  topology_on X Tx ->
  (forall Y:set, Y c= X -> completely_regular_space X Tx -> completely_regular_space Y (subspace_topology X Tx Y)) /\
  (forall I Xi:set, completely_regular_spaces_family I Xi -> completely_regular_space (product_space I Xi) (product_topology_full I Xi)).
let X Tx.
assume HTx: topology_on X Tx.
prove (forall Y:set, Y c= X -> completely_regular_space X Tx -> completely_regular_space Y (subspace_topology X Tx Y)) /\
  (forall I Xi:set, completely_regular_spaces_family I Xi -> completely_regular_space (product_space I Xi) (product_topology_full I Xi)).
apply andI.
- (** subspaces **)
  let Y. assume HYsub: Y c= X.
  assume HcrX: completely_regular_space X Tx.
  prove completely_regular_space Y (subspace_topology X Tx Y).
  claim HsepX:
    forall x:set, x :e X ->
      forall F:set, closed_in X Tx F -> x /:e F ->
        exists f:set, continuous_map X Tx R R_standard_topology f /\
          apply_fun f x = 0 /\ forall y:set, y :e F -> apply_fun f y = 1.
  { exact (andER (topology_on X Tx)
                 (forall x:set, x :e X ->
                   forall F:set, closed_in X Tx F -> x /:e F ->
                     exists f:set,
                       continuous_map X Tx R R_standard_topology f /\
                       apply_fun f x = 0 /\ forall y:set, y :e F -> apply_fun f y = 1)
                 HcrX). }
  claim HTsub: topology_on Y (subspace_topology X Tx Y).
  { exact (subspace_topology_is_topology X Tx Y HTx HYsub). }
  prove topology_on Y (subspace_topology X Tx Y) /\
    forall y:set, y :e Y ->
      forall F:set, closed_in Y (subspace_topology X Tx Y) F -> y /:e F ->
        exists f:set,
          continuous_map Y (subspace_topology X Tx Y) R R_standard_topology f /\
          apply_fun f y = 0 /\ forall z:set, z :e F -> apply_fun f z = 1.
  apply andI.
  * exact HTsub.
  * let y. assume HyY: y :e Y.
    let F. assume HFcl: closed_in Y (subspace_topology X Tx Y) F.
    assume HynotF: y /:e F.
    prove exists f:set,
      continuous_map Y (subspace_topology X Tx Y) R R_standard_topology f /\
      apply_fun f y = 0 /\ forall z:set, z :e F -> apply_fun f z = 1.
    claim HexC: exists C:set, closed_in X Tx C /\ F = C :/\: Y.
    { exact (iffEL (closed_in Y (subspace_topology X Tx Y) F)
                   (exists C:set, closed_in X Tx C /\ F = C :/\: Y)
                   (closed_in_subspace_iff_intersection X Tx Y F HTx HYsub)
                   HFcl). }
    apply HexC.
    let C. assume HCpair.
    claim HCcl: closed_in X Tx C.
    { exact (andEL (closed_in X Tx C) (F = C :/\: Y) HCpair). }
    claim HFeq: F = C :/\: Y.
    { exact (andER (closed_in X Tx C) (F = C :/\: Y) HCpair). }
    claim HyX: y :e X.
    { exact (HYsub y HyY). }
    claim HyNotC: y /:e C.
    { assume HyC: y :e C.
      claim HyCY: y :e C :/\: Y.
      { exact (binintersectI C Y y HyC HyY). }
      claim HyF: y :e F.
      { rewrite HFeq.
        exact HyCY. }
      exact (HynotF HyF). }
    claim Hexf: exists f:set,
      continuous_map X Tx R R_standard_topology f /\
      apply_fun f y = 0 /\ forall z:set, z :e C -> apply_fun f z = 1.
    { exact (HsepX y HyX C HCcl HyNotC). }
    apply Hexf.
    let f. assume Hfprop.
    witness f.
    claim Hfleft: continuous_map X Tx R R_standard_topology f /\ apply_fun f y = 0.
    { exact (andEL (continuous_map X Tx R R_standard_topology f /\ apply_fun f y = 0)
                   (forall z:set, z :e C -> apply_fun f z = 1)
                   Hfprop). }
    claim Hfcont: continuous_map X Tx R R_standard_topology f.
    { exact (andEL (continuous_map X Tx R R_standard_topology f) (apply_fun f y = 0) Hfleft). }
    claim Hfy0: apply_fun f y = 0.
    { exact (andER (continuous_map X Tx R R_standard_topology f) (apply_fun f y = 0) Hfleft). }
    claim HfC: forall z:set, z :e C -> apply_fun f z = 1.
    { exact (andER (continuous_map X Tx R R_standard_topology f /\ apply_fun f y = 0)
                   (forall z:set, z :e C -> apply_fun f z = 1)
                   Hfprop). }
    apply andI.
    + prove continuous_map Y (subspace_topology X Tx Y) R R_standard_topology f /\ apply_fun f y = 0.
      apply andI.
      - exact (continuous_on_subspace X Tx R R_standard_topology f Y HTx HYsub Hfcont).
      - exact Hfy0.
    + let z. assume HzF: z :e F.
      prove apply_fun f z = 1.
      claim HzCY: z :e C :/\: Y.
      { rewrite <- HFeq.
        exact HzF. }
      claim HzC: z :e C.
      { exact (binintersectE1 C Y z HzCY). }
      exact (HfC z HzC).
- (** products **)
  let I Xi. assume Hfam: completely_regular_spaces_family I Xi.
  admit.
Qed.

(** from 33 Example 1: products giving completely regular but not normal spaces **) 
(** LATEX VERSION: Sorgenfrey plane is completely regular but not normal. **)
Theorem Sorgenfrey_plane_completely_regular_not_normal :
  completely_regular_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology /\
  ~ normal_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology.
prove completely_regular_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology /\
  ~ normal_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology.
apply andI.
- admit.
- claim Hnot: ~ normal_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology.
  { exact (andER (regular_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology)
                 (~ normal_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology)
                 (Sorgenfrey_plane_not_normal)). }
  exact Hnot.
Qed.

(** from 33 Example 1 cont.: SOmega x SbarOmega completely regular not normal **)
(** LATEX VERSION: Another example of completely regular but non-normal product. **)
(** FIXED: Use product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology on S_Omega  Sbar_Omega (not a mismatched topology on a function space). **) 
Theorem SOmega_SbarOmega_completely_regular_not_normal :
  completely_regular_space (setprod S_Omega Sbar_Omega) (product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology) /\
  ~ normal_space (setprod S_Omega Sbar_Omega) (product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology).
prove completely_regular_space (setprod S_Omega Sbar_Omega) (product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology) /\
  ~ normal_space (setprod S_Omega Sbar_Omega) (product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology).
apply andI.
- admit.
- claim Hnot:
    ~ normal_space (setprod S_Omega Sbar_Omega) (product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology).
  { exact (andER (normal_space S_Omega SOmega_topology /\ normal_space Sbar_Omega SbarOmega_topology)
                 (~ normal_space (setprod S_Omega Sbar_Omega) (product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology))
                 (SOmega_SbarOmega_not_normal)). }
  exact Hnot.
Qed.

(** from 34 Theorem 34.1: Urysohn metrization theorem **) 
(** LATEX VERSION: Regular second-countable spaces are metrizable (Urysohn). **)
Theorem Urysohn_metrization_theorem : forall X Tx:set,
  regular_space X Tx -> second_countable_space X Tx -> exists d:set, metric_on X d /\ metric_topology X d = Tx.
let X Tx.
assume Hreg: regular_space X Tx.
assume Hscc: second_countable_space X Tx.
prove exists d:set, metric_on X d /\ metric_topology X d = Tx.
admit.
Qed.

(** from 34 Theorem 34.2: Imbedding via separating family of functions **) 
(** LATEX VERSION: Embedding into product of reals via separating family of continuous functions. **)
Theorem embedding_via_functions : forall X Tx:set,
  topology_on X Tx -> one_point_sets_closed X Tx ->
  forall F J:set, separating_family_of_functions X Tx F J ->
    exists Fmap:set, embedding_of X Tx (power_real J) (product_topology_full J (const_space_family J R R_standard_topology)) Fmap.
let X Tx.
assume HTx: topology_on X Tx.
assume Hclosed: one_point_sets_closed X Tx.
let F J.
assume Hsep: separating_family_of_functions X Tx F J.
prove exists Fmap:set, embedding_of X Tx (power_real J) (product_topology_full J (const_space_family J R R_standard_topology)) Fmap.
admit.
Qed.

(** from 34 Corollary 34.3: completely regular iff embeds in [0,1]^J **) 
(** LATEX VERSION: Completely regular iff embeds into a Tychonoff cube [0,1]^J. **)
Theorem completely_regular_iff_embeds_in_cube : forall X Tx:set,
  (completely_regular_space X Tx <->
    exists J:set, exists Fmap:set, embedding_of X Tx (unit_interval_power J) (product_topology_full J (const_space_family J unit_interval (subspace_topology R R_standard_topology unit_interval))) Fmap).
let X Tx.
prove (completely_regular_space X Tx <->
    exists J:set, exists Fmap:set, embedding_of X Tx (unit_interval_power J) (product_topology_full J (const_space_family J unit_interval (subspace_topology R R_standard_topology unit_interval))) Fmap).
admit.
Qed.

(** from 35 Theorem 35.1: Tietze extension theorem **) 
(** LATEX VERSION: Tietze extension theorem for normal spaces and intervals. **)
Theorem Tietze_extension_interval : forall X Tx A a b f:set,
  normal_space X Tx -> closed_in X Tx A ->
  continuous_map A (subspace_topology X Tx A) (closed_interval a b) (order_topology (closed_interval a b)) f ->
  exists g:set, continuous_map X Tx (closed_interval a b) (order_topology (closed_interval a b)) g /\
    (forall x:set, x :e A -> apply_fun g x = apply_fun f x).
let X Tx A a b f.
assume Hnorm: normal_space X Tx.
assume HA: closed_in X Tx A.
assume Hf: continuous_map A (subspace_topology X Tx A) (closed_interval a b) (order_topology (closed_interval a b)) f.
prove exists g:set, continuous_map X Tx (closed_interval a b) (order_topology (closed_interval a b)) g /\
    (forall x:set, x :e A -> apply_fun g x = apply_fun f x).
admit.
Qed.

Theorem Tietze_extension_real : forall X Tx A f:set,
  normal_space X Tx -> closed_in X Tx A ->
  continuous_map A (subspace_topology X Tx A) R R_standard_topology f ->
  exists g:set, continuous_map X Tx R R_standard_topology g /\
    (forall x:set, x :e A -> apply_fun g x = apply_fun f x).
let X Tx A f.
assume Hnorm: normal_space X Tx.
assume HA: closed_in X Tx A.
assume Hf: continuous_map A (subspace_topology X Tx A) R R_standard_topology f.
prove exists g:set, continuous_map X Tx R R_standard_topology g /\
    (forall x:set, x :e A -> apply_fun g x = apply_fun f x).
admit.
Qed.

(** from 36 Definition: m-manifold **) 
(** LATEX VERSION: An m-manifold is Hausdorff and second countable (dimension suppressed here). **)
Definition m_manifold : set -> set -> prop := fun X Tx => Hausdorff_space X Tx /\ second_countable_space X Tx.

(** from 36 Definition: partition of unity dominated by a cover **) 
(** LATEX VERSION: Partition of unity subordinate to an open cover (dominated). **)
Definition partition_of_unity_dominated : set -> set -> set -> prop := fun X Tx U =>
  topology_on X Tx /\ open_cover X Tx U /\
  exists P:set,
    P c= function_space X R /\
    (forall f:set, f :e P -> continuous_map X Tx R R_standard_topology f) /\
    (forall x:set, x :e X ->
      exists F:set, finite F /\ F c= P /\
        (forall f:set, f :e P -> apply_fun f x <> 0 -> f :e F) /\
        (forall f:set, f :e F ->
           exists u:set, u :e U /\ {y :e X|apply_fun f y <> 0} c= u)).

(** from 36 Theorem 36.1: existence of finite partition of unity on normal space **) 
(** LATEX VERSION: On a normal space, every finite open cover has a partition of unity subordinate to it. **)
Theorem finite_partition_of_unity_exists : forall X Tx U:set,
  normal_space X Tx -> finite U -> open_cover X Tx U -> exists P:set, partition_of_unity_dominated X Tx U.
let X Tx U.
assume Hnorm: normal_space X Tx.
assume Hfin: finite U.
assume Hcover: open_cover X Tx U.
prove exists P:set, partition_of_unity_dominated X Tx U.
admit.
Qed.

(** from 36 Theorem: compact manifold embeds in Euclidean space **) 
(** LATEX VERSION: Any compact manifold embeds in some Euclidean space. **)
Theorem compact_manifold_embeds_in_Euclidean : forall X Tx:set,
  m_manifold X Tx -> compact_space X Tx -> exists N:set, exists e:set,
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e.
let X Tx.
assume Hman: m_manifold X Tx.
assume Hcomp: compact_space X Tx.
prove exists N:set, exists e:set,
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e.
admit.
Qed.

(** from 37 Theorem: Tychonoff theorem **)
(** LATEX VERSION: Arbitrary product of compact spaces is compact (Tychonoff). **)
(** FIXED: Hypothesis quantifies i only over i:e I (not all sets). **) 
Theorem Tychonoff_theorem : forall I Xi:set,
  (forall i:set, i :e I -> compact_space (product_component Xi i) (product_component_topology Xi i)) ->
  compact_space (product_space I Xi) (product_topology_full I Xi).
let I Xi.
assume Hcomp: forall i:set, i :e I -> compact_space (product_component Xi i) (product_component_topology Xi i).
prove compact_space (product_space I Xi) (product_topology_full I Xi).
admit.
Qed.

(** from 38 Definition: Stone-Cech compactification and universal property **) 
(** LATEX VERSION: Stoneech compactification X defined via universal property; placeholder representation. **)
Definition Stone_Cech_compactification : set -> set -> set := fun X Tx =>
  {p :e Power (Power (Power X)) |
    exists Y Ty e:set,
      p = setprod (setprod Y Ty) e /\
      compact_space Y Ty /\ Hausdorff_space Y Ty /\ embedding_of X Tx Y Ty e}.
Theorem Stone_Cech_universal_property : forall X Tx:set,
  Tychonoff_space X Tx ->
  exists Ty:set,
    compact_space (Stone_Cech_compactification X Tx) Ty /\
    Hausdorff_space (Stone_Cech_compactification X Tx) Ty.
let X Tx.
assume HT: Tychonoff_space X Tx.
prove exists Ty:set,
  compact_space (Stone_Cech_compactification X Tx) Ty /\
  Hausdorff_space (Stone_Cech_compactification X Tx) Ty.
admit.
Qed.

(** from 39 Definition: locally finite family and refinement **) 
(** LATEX VERSION: Refinement and locally finite families/bases (NagataSmirnov context). **)
Definition refine_of : set -> set -> prop := fun V U =>
  forall v:set, v :e V -> exists u:set, u :e U /\ v c= u.
Definition locally_finite_family : set -> set -> set -> prop := fun X Tx F =>
  topology_on X Tx /\
  forall x:set, x :e X ->
    exists N:set, N :e Tx /\ x :e N /\
      exists S:set, finite S /\ S c= F /\
        forall A:set, A :e F -> A :/\: N <> Empty -> A :e S.
Definition locally_finite_basis : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  exists B:set, basis_on X B /\ locally_finite_family X Tx B.
Definition sigma_locally_finite_basis : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  exists Fams:set, countable_set Fams /\
    Fams c= Power (Power X) /\
    (forall F:set, F :e Fams -> locally_finite_family X Tx F) /\
    basis_on X (Union Fams) /\
    forall b:set, b :e Union Fams -> b :e Tx.

(** from 40 Nagata-Smirnov metrization theorem **) 
(** LATEX VERSION: NagataSmirnov: A regular space with a -locally-finite basis is metrizable. **)
Theorem Nagata_Smirnov_metrization : forall X Tx:set,
  regular_space X Tx -> sigma_locally_finite_basis X Tx -> metrizable X Tx.
let X Tx.
assume Hreg: regular_space X Tx.
assume Hbasis: sigma_locally_finite_basis X Tx.
prove metrizable X Tx.
admit.
Qed.

(** from 41 Definition: paracompact space **) 
(** LATEX VERSION: Paracompact = every open cover has a locally finite open refinement. **)
Definition paracompact_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall U:set, open_cover X Tx U ->
    exists V:set, open_cover X Tx V /\ locally_finite_family X Tx V /\ refine_of V U.

(** from 41 Theorem: existence of locally finite refinements **) 
(** LATEX VERSION: Any paracompact space admits a locally finite open refinement of every open cover. **)
Theorem locally_finite_refinement : forall X Tx U:set,
  paracompact_space X Tx -> open_cover X Tx U -> exists V:set, open_cover X Tx V /\ locally_finite_family X Tx V.
let X Tx U.
assume Hpara: paracompact_space X Tx.
assume Hcover: open_cover X Tx U.
prove exists V:set, open_cover X Tx V /\ locally_finite_family X Tx V.
(** Extract the forall from paracompact definition **)
claim Hforall: forall U0:set, open_cover X Tx U0 ->
    exists V:set, open_cover X Tx V /\ locally_finite_family X Tx V /\ refine_of V U0.
{ exact (andER (topology_on X Tx)
               (forall U0:set, open_cover X Tx U0 ->
                  exists V:set, open_cover X Tx V /\ locally_finite_family X Tx V /\ refine_of V U0)
               Hpara). }
(** Apply to U and extract V **)
claim Hexists: exists V:set, open_cover X Tx V /\ locally_finite_family X Tx V /\ refine_of V U.
{ exact (Hforall U Hcover). }
apply Hexists.
let V. assume HV.
witness V.
(** Extract just the first two conjuncts, dropping refine_of **)
exact (andEL (open_cover X Tx V /\ locally_finite_family X Tx V) (refine_of V U) HV).
Qed.

(** from 41 Theorem: paracompact Hausdorff implies normal **) 
(** LATEX VERSION: Paracompact Hausdorff spaces are normal. **)
Theorem paracompact_Hausdorff_normal : forall X Tx:set,
  paracompact_space X Tx -> Hausdorff_space X Tx -> normal_space X Tx.
let X Tx.
assume Hpara: paracompact_space X Tx.
assume HH: Hausdorff_space X Tx.
prove normal_space X Tx.
admit.
Qed.

(** from 42 Smirnov metrization theorem **) 
(** LATEX VERSION: Smirnov metrization: regular spaces with a locally finite basis are metrizable. **)
Theorem Smirnov_metrization : forall X Tx:set,
  regular_space X Tx -> locally_finite_basis X Tx -> metrizable X Tx.
let X Tx.
assume Hreg: regular_space X Tx.
assume Hbasis: locally_finite_basis X Tx.
prove metrizable X Tx.
admit.
Qed.

(** helper: Cauchy sequence in a metric space **)
(** LATEX VERSION: Cauchy sequence definition (metric). **)
(** FIXED: cauchy_sequence requires sequence_on seq X and uses N c= m and N c= n (eventuality) plus eps :e R and Rlt 0 eps; metric is applied as apply_fun d (seq(m), seq(n)). **) 
Definition cauchy_sequence : set -> set -> set -> prop := fun X d seq =>
  metric_on X d /\ sequence_on seq X /\
  forall eps:set, eps :e R /\ Rlt 0 eps ->
    exists N:set, N :e omega /\
      forall m n:set, m :e omega -> n :e omega -> N c= m -> N c= n ->
        Rlt (apply_fun d (apply_fun seq m, apply_fun seq n)) eps.

(** Helper: cauchy_sequence plus totality of the metric graph on XX **)
Definition cauchy_sequence_total : set -> set -> set -> prop := fun X d seq =>
  metric_on_total X d /\ sequence_on seq X /\
  forall eps:set, eps :e R /\ Rlt 0 eps ->
    exists N:set, N :e omega /\
      forall m n:set, m :e omega -> n :e omega -> N c= m -> N c= n ->
        Rlt (apply_fun d (apply_fun seq m, apply_fun seq n)) eps.

Theorem cauchy_sequence_total_imp : forall X d seq:set,
  cauchy_sequence_total X d seq -> cauchy_sequence X d seq.
let X d seq. assume H.
claim Hleft: metric_on_total X d /\ sequence_on seq X.
{ exact (andEL (metric_on_total X d /\ sequence_on seq X)
               (forall eps:set, eps :e R /\ Rlt 0 eps ->
                 exists N:set, N :e omega /\
                   forall m n:set, m :e omega -> n :e omega -> N c= m -> N c= n ->
                     Rlt (apply_fun d (apply_fun seq m, apply_fun seq n)) eps)
               H). }
claim Hmt: metric_on_total X d.
{ exact (andEL (metric_on_total X d) (sequence_on seq X) Hleft). }
claim Hseq: sequence_on seq X.
{ exact (andER (metric_on_total X d) (sequence_on seq X) Hleft). }
claim Htail: forall eps:set, eps :e R /\ Rlt 0 eps ->
  exists N:set, N :e omega /\
    forall m n:set, m :e omega -> n :e omega -> N c= m -> N c= n ->
      Rlt (apply_fun d (apply_fun seq m, apply_fun seq n)) eps.
{ exact (andER (metric_on_total X d /\ sequence_on seq X)
               (forall eps:set, eps :e R /\ Rlt 0 eps ->
                 exists N:set, N :e omega /\
                   forall m n:set, m :e omega -> n :e omega -> N c= m -> N c= n ->
                     Rlt (apply_fun d (apply_fun seq m, apply_fun seq n)) eps)
               H). }
prove metric_on X d /\ sequence_on seq X /\
  forall eps:set, eps :e R /\ Rlt 0 eps ->
    exists N:set, N :e omega /\
      forall m n:set, m :e omega -> n :e omega -> N c= m -> N c= n ->
        Rlt (apply_fun d (apply_fun seq m, apply_fun seq n)) eps.
apply andI.
- apply andI.
  + exact (metric_on_total_imp_metric_on X d Hmt).
  + exact Hseq.
- exact Htail.
Qed.

(** from 43 Definition: complete metric space **) 
(** LATEX VERSION: Completeness: every Cauchy sequence converges. **)
(** FIXED: complete_metric_space quantifies over seq with sequence_on seq X, matching cauchy_sequence. **) 
Definition complete_metric_space : set -> set -> prop := fun X d =>
  metric_on X d /\
  forall seq:set, sequence_on seq X -> cauchy_sequence X d seq ->
    exists x:set, converges_to X (metric_topology X d) seq x.

(** Helper: complete_metric_space plus totality of the metric graph on XX **)
Definition complete_metric_space_total : set -> set -> prop := fun X d =>
  metric_on_total X d /\
  forall seq:set, sequence_on seq X -> cauchy_sequence_total X d seq ->
    exists x:set, converges_to X (metric_topology X d) seq x.
(** FIXED: discrete_metric uses ordered pairs ((x,y), value) and famunion; it represents d(x,y)=0 if x=y and 1 otherwise. **) 
Definition discrete_metric : set -> set := fun X =>
  famunion X (fun x => {((x,y), If_i (x = y) 0 1) | y :e X}).
(** helper: placeholder metric on euclidean_space n **) 
Definition euclidean_metric : set -> set := fun n => discrete_metric (euclidean_space n).

(** helper: bounded product metric on R^omega **) 
(** LATEX VERSION: Bounded product metric on R^ (placeholder). **)
Definition bounded_product_metric : set -> set := fun J => discrete_metric (power_real J).

(** from 43 Lemma 43.1: Cauchy with convergent subsequence converges **) 
(** LATEX VERSION: In a metric space, a Cauchy sequence with a convergent subsequence converges to the same limit. **)
Theorem Cauchy_with_convergent_subsequence_converges : forall X d seq x:set,
  metric_on X d -> cauchy_sequence X d seq ->
  (exists subseq:set, subseq c= seq /\ converges_to X (metric_topology X d) subseq x) ->
  converges_to X (metric_topology X d) seq x.
admit.
Qed.

(** from 43 Theorem 43.2: Euclidean space is complete **) 
(** LATEX VERSION: Euclidean spaces are complete metric spaces. **)
Theorem Euclidean_space_complete : forall k:set,
  complete_metric_space (euclidean_space k) (euclidean_metric k).
admit.
Qed.

(** from 43 Lemma 43.3: product convergence via projections **) 
(** LATEX VERSION: Convergence in a product metric topology iff coordinatewise convergence. **)
Theorem product_sequence_convergence_iff_coordinates : forall X J:set,
  X = product_space J (const_space_family J R R_standard_topology) ->
  forall seq x:set,
    converges_to X (product_topology_full J (const_space_family J R R_standard_topology)) seq x <->
    (forall j:set, j :e J ->
    converges_to (product_component (const_space_family J R R_standard_topology) j)
                   (product_component_topology (const_space_family J R R_standard_topology) j)
                   (Repl seq (fun s => apply_fun s j))
                   (apply_fun x j)).
admit.
Qed.

(** from 43 Theorem 43.4: complete metric on R^omega **) 
(** LATEX VERSION: The bounded product metric makes R^ complete. **)
Theorem product_Romega_complete : complete_metric_space (power_real omega) (bounded_product_metric omega).
admit.
Qed.

(** from 44 Theorem: space-filling curve existence **) 
(** LATEX VERSION: Existence of a continuous surjection from [0,1] onto the unit square (Peano curve). **)
Definition unit_square : set := setprod unit_interval unit_interval.
Definition unit_square_topology : set :=
  product_topology unit_interval unit_interval_topology unit_interval unit_interval_topology.
Theorem space_filling_curve : exists f:set, continuous_map unit_interval unit_interval_topology unit_square unit_square_topology f.
admit.
Qed.

(** from 45 Definition: sequential compactness **)
(** LATEX VERSION: Sequentially compact: every sequence has a convergent subsequence/limit in X. **)
(** FIXED: sequentially_compact requires existence of a convergent subsequence, not that every sequence converges. **) 
Definition sequentially_compact : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall seq:set, sequence_on seq X ->
    exists subseq:set, exists x:set, subseq c= seq /\ converges_to X Tx subseq x.

(** from 45 Theorem: compactness in metric spaces equivalences **) 
(** LATEX VERSION: In metric spaces, compact  sequentially compact. **)
Theorem compact_metric_equivalences : forall X d:set,
  metric_on X d ->
  (compact_space X (metric_topology X d) <-> sequentially_compact X (metric_topology X d)).
admit.
Qed.

(** from 46 Definition: pointwise and compact convergence topologies **) 
(** LATEX VERSION: Topologies of pointwise and compact convergence on function spaces (placeholders). **)
Definition pointwise_convergence_topology : set -> set -> set -> set -> set :=
  fun X Tx Y Ty => generated_topology (function_space X Y) Empty.
Definition compact_convergence_topology : set -> set -> set -> set -> set :=
  fun X Tx Y Ty => generated_topology (function_space X Y) Empty.
(** FIXED: equicontinuous_family uses the implication apply_fun f x :e V -> forall y:e U, apply_fun f y :e V, not a global condition forcing all f to map U into V. **) 
Definition equicontinuous_family : set -> set -> set -> set -> set -> prop :=
  fun X Tx Y Ty F =>
    topology_on X Tx /\ topology_on Y Ty /\ F c= function_space X Y /\
    forall x:set, x :e X ->
      forall V:set, V :e Ty ->
        exists U:set, U :e Tx /\ x :e U /\
          forall f:set, f :e F -> apply_fun f x :e V ->
            forall y:set, y :e U -> apply_fun f y :e V.
Definition relatively_compact_in_compact_convergence : set -> set -> set -> set -> set -> prop :=
  fun X Tx Y Ty F =>
    topology_on X Tx /\ topology_on Y Ty /\ F c= function_space X Y /\
    compact_space F (compact_convergence_topology X Tx Y Ty).

(** from 47 Ascoli theorem **) 
(** LATEX VERSION: AscoliArzel theorem (placeholder statement) on compact convergence. **)
Theorem Ascoli_theorem : forall X Tx Y Ty F:set,
  compact_space X Tx -> Hausdorff_space Y Ty ->
  equicontinuous_family X Tx Y Ty F -> relatively_compact_in_compact_convergence X Tx Y Ty F.
admit.
Qed.

(** helper: intersection over a family within a universe X **) 
(** LATEX VERSION: Intersection_over_family X Fam collects points lying in every member of Fam. **)
Definition intersection_over_family : set -> set -> set :=
  fun X Fam => {x :e X|forall U:set, U :e Fam -> x :e U}.

(** from 48 Definition: Baire space **)
(** LATEX VERSION: A Baire space is one where countable intersections of dense open sets are dense. **)
Definition Baire_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall U:set,
    U c= Tx -> countable_set U ->
    (forall u:set, u :e U -> u :e Tx /\ dense_in u X Tx) ->
    dense_in (intersection_over_family X U) X Tx.

(** from 48 Lemma 48.1: dense G_delta characterization of Baire space **)
(** LATEX VERSION: Equivalent dense G_ characterization of Baire spaces. **)
Theorem Baire_space_dense_Gdelta : forall X Tx:set,
  Baire_space X Tx ->
  forall U:set,
    U c= Tx -> countable_set U ->
    (forall u:set, u :e U -> u :e Tx /\ dense_in u X Tx) ->
    dense_in (intersection_over_family X U) X Tx.
let X Tx.
assume HB: Baire_space X Tx.
let U.
assume HUsub: U c= Tx.
assume HUcount: countable_set U.
assume HUdense: forall u:set, u :e U -> u :e Tx /\ dense_in u X Tx.
prove dense_in (intersection_over_family X U) X Tx.
claim Hprop: forall U0:set,
  U0 c= Tx -> countable_set U0 ->
  (forall u:set, u :e U0 -> u :e Tx /\ dense_in u X Tx) ->
  dense_in (intersection_over_family X U0) X Tx.
{ exact (andER (topology_on X Tx)
               (forall U0:set,
                 U0 c= Tx -> countable_set U0 ->
                 (forall u:set, u :e U0 -> u :e Tx /\ dense_in u X Tx) ->
                 dense_in (intersection_over_family X U0) X Tx)
               HB). }
exact (Hprop U HUsub HUcount HUdense).
Qed.

(** from 48 Theorem: Baire category theorem for complete metric spaces **)
(** LATEX VERSION: Complete metric spaces are Baire. **)
Theorem Baire_category_complete_metric : forall X d:set,
  complete_metric_space X d -> Baire_space X (metric_topology X d).
admit.
Qed.

(** from 48 Theorem: compact Hausdorff spaces are Baire spaces **)
(** LATEX VERSION: Compact Hausdorff spaces are Baire. **)
Theorem Baire_category_compact_Hausdorff : forall X Tx:set,
  compact_space X Tx -> Hausdorff_space X Tx -> Baire_space X Tx.
admit.
Qed.

(** from 48 Theorem: Baire category theorem general version **)
(** LATEX VERSION: General Baire category consequence: nonempty open sets in Baire space. **)
(** FIXED: Corrected Baire_space to take both X and Tx parameters. **)
Theorem Baire_category_theorem : forall X Tx:set,
  Baire_space X Tx -> forall U:set, open_in X Tx U -> U <> Empty.
admit.
Qed.

(** from 49 Definition: differentiability and nowhere-differentiable function **) 
(** LATEX VERSION: A function is differentiable at x if the difference quotient (f(x+h)-f(x))/h tends to a limit as h0 (with x+h in the domain); nowhere differentiable means differentiable at no point. **)
Definition differentiable_at : set -> set -> prop := fun f x =>
  function_on f unit_interval R /\ x :e unit_interval /\
  exists L:set, L :e R /\
    forall eps:set, eps :e R -> Rlt 0 eps ->
      exists delta:set, delta :e R /\ Rlt 0 delta /\
        forall h:set, h :e R ->
          ~(h = 0) ->
          Rlt 0 (Abs h) ->
          Rlt (Abs h) delta ->
          (add_SNo x h) :e unit_interval ->
          Rlt (Abs (add_SNo
                      (div_SNo (add_SNo (apply_fun f (add_SNo x h)) (minus_SNo (apply_fun f x))) h)
                      (minus_SNo L))) eps.
Definition nowhere_differentiable : set -> prop := fun f =>
  function_on f unit_interval R /\ forall x:set, x :e unit_interval -> ~ differentiable_at f x.

(** from 49 Definition: the function space C(I,R) and the sets U_n **)
(** LATEX VERSION: Let C be the space of continuous maps f:IR. For n2, define U_n as the set of f such that for some 0<h1/n one has _h f > n. **)
(** note: the pointwise difference-quotient predicate is formalized, but deeper analytic facts are still handled via later axioms/theorems **)
Definition I_topology : set := unit_interval_topology.
Theorem I_topology_on : topology_on unit_interval I_topology.
prove topology_on unit_interval I_topology.
exact unit_interval_topology_on.
Qed.
Definition continuous_real_on_I : set -> prop := fun f =>
  continuous_map unit_interval I_topology R R_standard_topology f.
Definition C_I_R : set := {f :e function_space unit_interval R | continuous_real_on_I f}.

(** from 49 Theorem 49.1: approximation by nowhere-differentiable functions **)
(** LATEX VERSION: Given continuous h and epsilon>0, there exists continuous g with |h(x)-g(x)|<epsilon for all x, such that g is nowhere differentiable. **)
Theorem theorem_49_1_nowhere_differentiable_approx : forall h eps:set,
  continuous_map unit_interval I_topology R R_standard_topology h ->
  eps :e R ->
  Rlt 0 eps ->
  exists g:set,
    continuous_map unit_interval I_topology R R_standard_topology g /\
    nowhere_differentiable g /\
    forall x:set, x :e unit_interval ->
      Rlt (Abs (add_SNo (apply_fun h x) (minus_SNo (apply_fun g x)))) eps.
admit.
Qed.

Definition diffquot_forward_abs : set -> set -> set -> set := fun f x h =>
  Abs (div_SNo (add_SNo (apply_fun f (add_SNo x h)) (minus_SNo (apply_fun f x))) h).
Definition diffquot_backward_abs : set -> set -> set -> set := fun f x h =>
  Abs (div_SNo (add_SNo (apply_fun f (add_SNo x (minus_SNo h))) (minus_SNo (apply_fun f x))) (minus_SNo h)).

Definition Delta_gt : set -> set -> set -> set -> prop := fun f x h n =>
  (add_SNo x h :e unit_interval /\ Rlt n (diffquot_forward_abs f x h))
  \/
  (add_SNo x (minus_SNo h) :e unit_interval /\ Rlt n (diffquot_backward_abs f x h)).

Definition U_n : set -> set := fun n =>
  {f :e C_I_R | n :e omega /\ 2 c= n /\
    exists h:set, h :e R /\ Rlt 0 h /\ Rle h (div_SNo 1 n) /\
      forall x:set, x :e unit_interval -> Delta_gt f x h n}.

(** from 49 Existence: nowhere-differentiable function **) 
(** LATEX VERSION: Existence of a continuous nowhere-differentiable function. **)
Theorem nowhere_differentiable_function_exists :
  exists f:set,
    continuous_map unit_interval I_topology R R_standard_topology f /\
    nowhere_differentiable f.
set h := const_fun unit_interval 0.
claim Hh: continuous_map unit_interval I_topology R R_standard_topology h.
{ exact (const_fun_continuous unit_interval I_topology R R_standard_topology 0
         I_topology_on R_standard_topology_is_topology real_0). }
claim Hex: exists g:set,
  continuous_map unit_interval I_topology R R_standard_topology g /\
  nowhere_differentiable g /\
  forall x:set, x :e unit_interval ->
    Rlt (Abs (add_SNo (apply_fun h x) (minus_SNo (apply_fun g x)))) 1.
{ exact (theorem_49_1_nowhere_differentiable_approx h 1 Hh real_1 Rlt_0_1). }
set g := Eps_i (fun g0:set =>
  continuous_map unit_interval I_topology R R_standard_topology g0 /\
  nowhere_differentiable g0 /\
  forall x:set, x :e unit_interval ->
    Rlt (Abs (add_SNo (apply_fun h x) (minus_SNo (apply_fun g0 x)))) 1).
claim HgP:
  continuous_map unit_interval I_topology R R_standard_topology g /\
  nowhere_differentiable g /\
  forall x:set, x :e unit_interval ->
    Rlt (Abs (add_SNo (apply_fun h x) (minus_SNo (apply_fun g x)))) 1.
{ exact (Eps_i_ex (fun g0:set =>
    continuous_map unit_interval I_topology R R_standard_topology g0 /\
    nowhere_differentiable g0 /\
    forall x:set, x :e unit_interval ->
      Rlt (Abs (add_SNo (apply_fun h x) (minus_SNo (apply_fun g0 x)))) 1) Hex). }
claim HgCN: continuous_map unit_interval I_topology R R_standard_topology g /\ nowhere_differentiable g.
{ exact (andEL (continuous_map unit_interval I_topology R R_standard_topology g /\ nowhere_differentiable g)
               (forall x:set, x :e unit_interval ->
                 Rlt (Abs (add_SNo (apply_fun h x) (minus_SNo (apply_fun g x)))) 1)
               HgP). }
witness g.
exact HgCN.
Qed.

(** helper: finite cardinality via equip to an ordinal **) 
(** LATEX VERSION: Cardinality_exact/at_most helper predicates for dimension theory. **)
Definition cardinality_exact : set -> set -> prop := fun S n =>
  ordinal n /\ equip S n.
Definition cardinality_at_most : set -> set -> prop := fun S n =>
  ordinal n /\ exists k:set, ordinal k /\ k c= n /\ equip S k.

(** from 50 Definition: order of a collection of subsets **) 
(** LATEX VERSION: A collection A has order m+1 if some point lies in m+1 elements of A, and no point lies in more than m+1 elements of A. **)
Definition collection_has_order_at_m_plus_one : set -> set -> set -> prop :=
  fun X A m =>
    ordinal m /\
    (exists x:set, x :e X /\
      exists Fam:set, Fam c= A /\ finite Fam /\
        cardinality_exact Fam (ordsucc m) /\
        forall U:set, U :e Fam -> x :e U) /\
    forall x:set, x :e X ->
      cardinality_at_most {U :e A|x :e U} (ordsucc m).

(** from 50 Definition (derived): order at most m+1 **) 
(** LATEX VERSION: A collection A has order at most m+1 if no point lies in more than m+1 elements of A. **)
Definition collection_has_order_at_most_m_plus_one : set -> set -> set -> prop :=
  fun X A m =>
    ordinal m /\
    forall x:set, x :e X ->
      cardinality_at_most {U :e A|x :e U} (ordsucc m).

(** from 50 Definition: covering dimension and finite dimensionality **)
(** LATEX VERSION: For a topological space (X,Tx), we write dim(X)  n if for every open cover A of X\n+   there exists an open cover B refining A that has order at most n+1. **)
(** Helper: refinement of covers (as families of subsets) **)
(** LATEX VERSION: B refines A if every element of B is contained in some element of A. **)
Definition refines_cover : set -> set -> prop := fun B A =>
  forall U:set, U :e B -> exists V:set, V :e A /\ U c= V.

Definition covering_dimension : set -> set -> set -> prop := fun X Tx n =>
  topology_on X Tx /\ n :e omega /\
    forall A:set, open_cover_of X Tx A ->
      exists B:set,
        open_cover_of X Tx B /\
        refines_cover B A /\
        collection_has_order_at_most_m_plus_one X B n.
(** LATEX VERSION: X is finite dimensional if dim(X)  m for some m. **)
Definition finite_dimensional_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  exists m:set, m :e omega /\
    forall A:set, open_cover_of X Tx A ->
      exists B:set,
        open_cover_of X Tx B /\
        refines_cover B A /\
        collection_has_order_at_most_m_plus_one X B m.

(** from 50 Theorem: compact subspace of R^n has dimension at most n **) 
(** LATEX VERSION: Compact subspace of ^n has covering dimension  n. **)
Theorem compact_subspace_Rn_dimension_le : forall N X:set,
  X c= (euclidean_space N) ->
  compact_space X (subspace_topology (euclidean_space N) (euclidean_topology N) X) ->
  covering_dimension X (subspace_topology (euclidean_space N) (euclidean_topology N) X) N.
admit.
Qed.

(** from 50 Theorem: compact m-manifold has dimension at most m **) 
(** LATEX VERSION: Compact m-manifold has covering dimension  m. **)
Theorem compact_manifold_dimension_le : forall X Tx m:set,
  m_manifold X Tx -> compact_space X Tx -> covering_dimension X Tx m.
admit.
Qed.

(** from 50 Theorem (Menger-Nbeling): compact metrizable space of dimension m embeds in R^{2m+1} **) 
(** LATEX VERSION: MengerNbeling embedding theorem (placeholder). **)
Theorem Menger_Nobeling_embedding : forall X Tx m:set,
  compact_space X Tx -> metrizable X Tx -> covering_dimension X Tx m ->
  exists N:set, exists e:set,
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e.
admit.
Qed.

(** from 50 Theorem 50.1: dimension of closed subspace bounded by ambient **) 
(** LATEX VERSION: Dimension of a closed subspace does not exceed that of the ambient space. **)
Theorem dimension_closed_subspace_le : forall X Tx Y n:set,
  covering_dimension X Tx n -> closed_in X Tx Y ->
  covering_dimension Y (subspace_topology X Tx Y) n.
admit.
Qed.

(** from 50 Theorem 50.2: dimension of union of closed sets is max **)
(** LATEX VERSION: If X = Y  Z where Y,Z are closed in X, then dim(X)  max(dim(Y),dim(Z)) (and in fact equality holds for finite-dimensional spaces). **)
Theorem dimension_union_closed_max : forall X Tx Y Z n:set,
  topology_on X Tx ->
  Y c= X -> Z c= X ->
  closed_in X Tx Y -> closed_in X Tx Z ->
  covering_dimension Y (subspace_topology X Tx Y) n ->
  covering_dimension Z (subspace_topology X Tx Z) n ->
  covering_dimension (Y :\/: Z) (subspace_topology X Tx (Y :\/: Z)) n.
admit.
Qed.

(** from 50 Corollary 50.3: finite union of closed finite-dimensional sets **)
(** LATEX VERSION: If X is a finite union of closed subspaces each of dimension  n, then X has dimension  n. **)
Theorem dimension_finite_union_closed_max : forall X Tx Fam n:set,
  topology_on X Tx ->
  finite Fam ->
  (forall Y:set, Y :e Fam -> Y c= X /\ closed_in X Tx Y /\ covering_dimension Y (subspace_topology X Tx Y) n) ->
  covering_dimension (Union Fam) (subspace_topology X Tx (Union Fam)) n.
admit.
Qed.

(** from 50 Example 4: compact 1-manifold has dimension 1 **)
(** LATEX VERSION: Every compact 1-manifold X has topological dimension 1. **)
Theorem compact_1_manifold_dimension_1 : forall X Tx:set,
  compact_space X Tx -> m_manifold X Tx -> covering_dimension X Tx (Sing Empty).
admit.
Qed.

(** from 50 Example 5: compact 2-manifold has dimension at most 2 **)
(** LATEX VERSION: Every compact 2-manifold X has topological dimension at most 2. **)
Definition two : set := Sing (Sing Empty).
Theorem compact_2_manifold_dimension_le_2 : forall X Tx:set,
  compact_space X Tx -> m_manifold X Tx -> covering_dimension X Tx two.
admit.
Qed.

(** from 50 Example 6: arcs and linear graphs **)
(** LATEX VERSION: An arc is a space homeomorphic to [0,1]; a linear graph is a finite union of arcs meeting at most at common endpoints. **)
Definition arc : set -> set -> prop := fun X Tx =>
  exists f:set, homeomorphism unit_interval unit_interval_topology X Tx f.

(** Helper: arc is a topological space **)
Theorem arc_is_topological_space : forall X Tx:set,
  arc X Tx -> topology_on X Tx.
let X Tx.
assume Harc.
apply Harc.
let f.
assume Hhom.
claim Hcont: continuous_map unit_interval unit_interval_topology X Tx f.
{ exact (andEL (continuous_map unit_interval unit_interval_topology X Tx f)
               (exists g:set, continuous_map X Tx unit_interval unit_interval_topology g /\
                 (forall x:set, x :e unit_interval -> apply_fun g (apply_fun f x) = x) /\
                 (forall y:set, y :e X -> apply_fun f (apply_fun g y) = y))
               Hhom). }
claim Habc: (topology_on unit_interval unit_interval_topology /\ topology_on X Tx) /\ function_on f unit_interval X.
{ exact (andEL ((topology_on unit_interval unit_interval_topology /\ topology_on X Tx) /\ function_on f unit_interval X)
               (forall V:set, V :e Tx -> preimage_of unit_interval f V :e unit_interval_topology)
               Hcont). }
claim Hab: topology_on unit_interval unit_interval_topology /\ topology_on X Tx.
{ exact (andEL (topology_on unit_interval unit_interval_topology /\ topology_on X Tx)
               (function_on f unit_interval X)
               Habc). }
exact (andER (topology_on unit_interval unit_interval_topology) (topology_on X Tx) Hab).
Qed.

Definition end_points_of_arc : set -> set -> set -> set -> prop := fun X Tx p q =>
  arc X Tx /\
  p :e X /\ q :e X /\
  p <> q /\
  connected_space (X :\: (Sing p)) Tx /\
  connected_space (X :\: (Sing q)) Tx.

Definition linear_graph : set -> set -> prop := fun G Tg =>
  Hausdorff_space G Tg /\
  exists Arcs:set,
    finite Arcs /\
    (forall A:set, A :e Arcs ->
      exists Ta:set, arc A Ta /\ A c= G) /\
    G = Union Arcs /\
    (forall A B:set, A :e Arcs -> B :e Arcs -> A <> B ->
      exists p:set, (A :/\: B = Empty \/ A :/\: B = Sing p)).

(** from 50 Example 6: linear graphs have dimension 1 **)
(** LATEX VERSION: A linear graph G has topological dimension 1. **)
Theorem linear_graph_dimension_1 : forall G Tg:set,
  linear_graph G Tg -> covering_dimension G Tg (Sing Empty).
admit.
Qed.

(** from 50 Example 7: general position in R^3 (preliminary) **)
(** LATEX VERSION: In R^3, points are in general position if no three are collinear and no four are coplanar. **)
(** helper: coordinate selectors on points in euclidean_space 3 **)
Definition R3_xcoord : set -> set := fun p => p 0.
Definition R3_ycoord : set -> set := fun p => p 1.
Definition R3_zcoord : set -> set := fun p => p 2.

(** helper: differences of coordinates **)
Definition R3_dx : set -> set -> set := fun p q =>
  add_SNo (R3_xcoord q) (minus_SNo (R3_xcoord p)).
Definition R3_dy : set -> set -> set := fun p q =>
  add_SNo (R3_ycoord q) (minus_SNo (R3_ycoord p)).
Definition R3_dz : set -> set -> set := fun p q =>
  add_SNo (R3_zcoord q) (minus_SNo (R3_zcoord p)).

(** helper: 2 by 2 determinant a d minus b c **)
Definition det2_SNo : set -> set -> set -> set -> set := fun a b c d =>
  add_SNo (mul_SNo a d) (minus_SNo (mul_SNo b c)).

(** helper: 3 by 3 determinant for rows (a1,a2,a3), (b1,b2,b3), (c1,c2,c3) **)
Definition det3_SNo : set -> set -> set -> set -> set -> set -> set -> set -> set -> set :=
  fun a1 a2 a3 b1 b2 b3 c1 c2 c3 =>
    add_SNo
      (mul_SNo a1 (det2_SNo b2 b3 c2 c3))
      (add_SNo
        (minus_SNo (mul_SNo a2 (det2_SNo b1 b3 c1 c3)))
        (mul_SNo a3 (det2_SNo b1 b2 c1 c2))).

Definition collinear_in_R3 : set -> set -> set -> prop := fun p q r =>
  p :e (euclidean_space 3) /\ q :e (euclidean_space 3) /\ r :e (euclidean_space 3) /\
  det2_SNo (R3_dx p q) (R3_dy p q) (R3_dx p r) (R3_dy p r) = 0 /\
  det2_SNo (R3_dx p q) (R3_dz p q) (R3_dx p r) (R3_dz p r) = 0 /\
  det2_SNo (R3_dy p q) (R3_dz p q) (R3_dy p r) (R3_dz p r) = 0.

Definition coplanar_in_R3 : set -> set -> set -> set -> prop := fun p q r s =>
  p :e (euclidean_space 3) /\ q :e (euclidean_space 3) /\ r :e (euclidean_space 3) /\ s :e (euclidean_space 3) /\
  det3_SNo
    (R3_dx p q) (R3_dy p q) (R3_dz p q)
    (R3_dx p r) (R3_dy p r) (R3_dz p r)
    (R3_dx p s) (R3_dy p s) (R3_dz p s) = 0.

(** from 50: geometrically independent (affinely independent) points in R^N **)
(** LATEX VERSION: Points {x,...,x} in R^N are geometrically independent if ax=0 and a=0 imply all a=0. **)
(** stub: actual condition needs vector space operations on R^N; we only record that S lies in some euclidean_space N **)
Definition geometrically_independent : set -> prop := fun S =>
  exists N:set, N :e omega /\ S c= euclidean_space N.

(** from 50: plane determined by geometrically independent points **)
(** LATEX VERSION: The plane P determined by geometrically independent points {x,...,x} is the set of all x = tx where t=1. **)
(** stub: needs proper formulation of affine combination in euclidean_space N **)
Definition affine_plane : set -> set := fun S =>
  Eps_i (fun P:set =>
    exists N:set, N :e omega /\ S c= euclidean_space N /\ P c= euclidean_space N).

(** from 50: k-plane in R^N **)
(** LATEX VERSION: A k-plane in R^N is the affine plane determined by k+1 geometrically independent points. **)
Definition k_plane : set -> set -> prop := fun k P =>
  k :e omega /\
  exists S:set,
    geometrically_independent S /\
    finite S /\
    (exists kp1:set, kp1 = k :\/: (Sing k) /\ equip S kp1) /\
    P = affine_plane S.

(** from 50: general position in R^N **)
(** LATEX VERSION: A set A in R^N is in general position if every subset with N+1 points is geometrically independent. **)
Definition general_position_RN : set -> set -> prop := fun N A =>
  N :e omega /\
  A c= euclidean_space N /\
  forall S:set, S c= A ->
    (forall Np1:set, Np1 = N :\/: (Sing N) ->
      (exists f:set -> set, inj S Np1 f) -> geometrically_independent S).

(** from 50 Lemma 50.4: approximation in general position **)
(** LATEX VERSION: Given finite {x,...,x} in R^N and >0, there exists {y,...,y} in general position with |x-y|< for all i. **)
(** stub: proper ordering and metric conditions need to be formulated **)
Theorem finite_set_approximation_general_position : forall N:set, forall pts:set, forall delta:set,
  N :e omega ->
  finite pts ->
  pts c= euclidean_space N ->
  delta :e R ->
  exists pts':set,
    general_position_RN N pts' /\
    finite pts' /\
    equip pts pts'.
admit.
Qed.

(** from 50 Theorem 50.5: Menger-Nbeling embedding theorem **)
(** LATEX VERSION: Every compact metrizable space X of topological dimension m can be embedded in R^{2m+1}. **)
(** FIXED: Dimension parameter uses N = add_nat (mul_nat two m) (Sing Empty) to represent 2m+1, not m+1. **) 
Theorem Menger_Nobeling_embedding_full : forall X Tx m:set,
  compact_space X Tx ->
  metrizable X Tx ->
  covering_dimension X Tx m ->
  m :e omega ->
  exists N:set, exists e:set,
    N = add_nat (mul_nat two m) (Sing Empty) /\
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e.
admit.
Qed.

(** from 50 Theorem 50.6: compact subspace of R^N has dimension at most N **)
(** LATEX VERSION: Every compact subspace of R^N has topological dimension at most N. **)
Theorem compact_subspace_RN_dimension_le_N : forall X N:set,
  N :e omega ->
  X c= (euclidean_space N) ->
  compact_space X (subspace_topology (euclidean_space N) (euclidean_topology N) X) ->
  covering_dimension X (subspace_topology (euclidean_space N) (euclidean_topology N) X) N.
admit.
Qed.

(** from 50 Corollary 50.7: compact m-manifold has dimension at most m **)
(** LATEX VERSION: Every compact m-manifold has topological dimension at most m. **)
Theorem compact_m_manifold_dimension_le_m : forall X Tx m:set,
  m :e omega ->
  compact_space X Tx ->
  m_manifold X Tx ->
  covering_dimension X Tx m.
admit.
Qed.

(** from 50 Corollary 50.8: compact m-manifold embeds in R^{2m+1} **)
(** LATEX VERSION: Every compact m-manifold can be embedded in R^{2m+1}. **)
(** FIXED: Same correction as above: N = add_nat (mul_nat two m) (Sing Empty) represents 2m+1. **) 
Theorem compact_m_manifold_embeds_R2mp1 : forall X Tx m:set,
  m :e omega ->
  compact_space X Tx ->
  m_manifold X Tx ->
  exists N:set, exists e:set,
    N = add_nat (mul_nat two m) (Sing Empty) /\
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e.
admit.
Qed.

(** from 50 Corollary 50.9: compact metrizable embeds in R^N iff finite dimensional **)
(** LATEX VERSION: A compact metrizable space X can be embedded in R^N for some N iff X has finite topological dimension. **)
Theorem compact_metrizable_embeds_iff_finite_dim : forall X Tx:set,
  compact_space X Tx ->
  metrizable X Tx ->
  ((exists N:set, exists e:set,
    N :e omega /\
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e)
  <->
  finite_dimensional_space X Tx).
admit.
Qed.

(** from Supplementary Exercises: locally m-euclidean space **)
(** LATEX VERSION: A space X is locally m-euclidean if each point has a neighborhood homeomorphic to an open set of R^m. **)
Definition locally_m_euclidean : set -> set -> set -> prop := fun X Tx m =>
  m :e omega /\
  topology_on X Tx /\
  forall x:set, x :e X ->
    exists U:set, exists V:set, exists f:set,
      open_in X Tx U /\
      x :e U /\
      V c= (euclidean_space m) /\
      open_in (euclidean_space m) (euclidean_topology m) V /\
      homeomorphism U (subspace_topology X Tx U) V (subspace_topology (euclidean_space m) (euclidean_topology m) V) f.

(** from Supplementary Exercises: Locally Euclidean Spaces: locally m-euclidean implies T1 **)
(** LATEX VERSION: Such a space X automatically satisfies the T1 axiom. **)
Theorem euclidean_space_Hausdorff : forall m:set,
  Hausdorff_space (euclidean_space m) (euclidean_topology m).
let m.
prove Hausdorff_space (euclidean_space m) (euclidean_topology m).
(** Obtain Hausdorffness of product_topology_full from 31 Theorem 31.2 (currently admitted). **)
claim HRtop: topology_on R R_standard_topology.
{ exact R_standard_topology_is_topology_local. }
claim Hall:
  (forall Y:set, Y c= R -> Hausdorff_space R R_standard_topology -> Hausdorff_space Y (subspace_topology R R_standard_topology Y)) /\
  (forall I Xi:set, Hausdorff_spaces_family I Xi -> Hausdorff_space (product_space I Xi) (product_topology_full I Xi)) /\
  (forall Y:set, Y c= R -> regular_space R R_standard_topology -> regular_space Y (subspace_topology R R_standard_topology Y)) /\
  (forall I Xi:set, regular_spaces_family I Xi -> regular_space (product_space I Xi) (product_topology_full I Xi)).
{ exact (separation_axioms_subspace_product R R_standard_topology HRtop). }
claim H123: ((forall Y:set, Y c= R -> Hausdorff_space R R_standard_topology -> Hausdorff_space Y (subspace_topology R R_standard_topology Y)) /\
             (forall I Xi:set, Hausdorff_spaces_family I Xi -> Hausdorff_space (product_space I Xi) (product_topology_full I Xi))) /\
            (forall Y:set, Y c= R -> regular_space R R_standard_topology -> regular_space Y (subspace_topology R R_standard_topology Y)).
{ exact (andEL (((forall Y:set, Y c= R -> Hausdorff_space R R_standard_topology -> Hausdorff_space Y (subspace_topology R R_standard_topology Y)) /\
                 (forall I Xi:set, Hausdorff_spaces_family I Xi -> Hausdorff_space (product_space I Xi) (product_topology_full I Xi))) /\
                (forall Y:set, Y c= R -> regular_space R R_standard_topology -> regular_space Y (subspace_topology R R_standard_topology Y)))
               (forall I Xi:set, regular_spaces_family I Xi -> regular_space (product_space I Xi) (product_topology_full I Xi))
               Hall). }
claim H12:
  (forall Y:set, Y c= R -> Hausdorff_space R R_standard_topology -> Hausdorff_space Y (subspace_topology R R_standard_topology Y)) /\
  (forall I Xi:set, Hausdorff_spaces_family I Xi -> Hausdorff_space (product_space I Xi) (product_topology_full I Xi)).
{ exact (andEL ((forall Y:set, Y c= R -> Hausdorff_space R R_standard_topology -> Hausdorff_space Y (subspace_topology R R_standard_topology Y)) /\
                (forall I Xi:set, Hausdorff_spaces_family I Xi -> Hausdorff_space (product_space I Xi) (product_topology_full I Xi)))
               (forall Y:set, Y c= R -> regular_space R R_standard_topology -> regular_space Y (subspace_topology R R_standard_topology Y))
               H123). }
claim Hprod:
  forall I Xi:set, Hausdorff_spaces_family I Xi -> Hausdorff_space (product_space I Xi) (product_topology_full I Xi).
{ exact (andER (forall Y:set, Y c= R -> Hausdorff_space R R_standard_topology -> Hausdorff_space Y (subspace_topology R R_standard_topology Y))
               (forall I Xi:set, Hausdorff_spaces_family I Xi -> Hausdorff_space (product_space I Xi) (product_topology_full I Xi))
               H12). }
claim Hfam: Hausdorff_spaces_family m (const_space_family m R R_standard_topology).
{ let i. assume Hi: i :e m.
  prove Hausdorff_space (product_component (const_space_family m R R_standard_topology) i)
                       (product_component_topology (const_space_family m R R_standard_topology) i).
  rewrite (product_component_def (const_space_family m R R_standard_topology) i).
  rewrite (product_component_topology_def (const_space_family m R R_standard_topology) i).
  rewrite (const_space_family_apply m R R_standard_topology i Hi).
  (** reduce the components of the tuple (R, R_standard_topology) **)
  rewrite (tuple_2_0_eq R R_standard_topology).
  rewrite (tuple_2_1_eq R R_standard_topology).
  exact R_standard_topology_Hausdorff. }
exact (Hprod m (const_space_family m R R_standard_topology) Hfam).
Qed.

(** helper: Euclidean spaces are T1 **)
(** LATEX VERSION: Euclidean spaces satisfy the T1 axiom (finite sets are closed). **)
Theorem euclidean_space_T1 : forall m:set,
  T1_space (euclidean_space m) (euclidean_topology m).
let m.
prove T1_space (euclidean_space m) (euclidean_topology m).
claim HH: Hausdorff_space (euclidean_space m) (euclidean_topology m).
{ exact (euclidean_space_Hausdorff m). }
claim Htop: topology_on (euclidean_space m) (euclidean_topology m).
{ exact (andEL (topology_on (euclidean_space m) (euclidean_topology m))
               (forall x1 x2:set, x1 :e euclidean_space m -> x2 :e euclidean_space m -> x1 <> x2 ->
                 exists U V:set, U :e euclidean_topology m /\ V :e euclidean_topology m /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }
prove topology_on (euclidean_space m) (euclidean_topology m) /\
      forall F:set, F c= euclidean_space m -> finite F -> closed_in (euclidean_space m) (euclidean_topology m) F.
apply andI.
- exact Htop.
- let F. assume HFsub: F c= euclidean_space m. assume HFfin: finite F.
  exact (finite_sets_closed_in_Hausdorff (euclidean_space m) (euclidean_topology m) HH F HFsub HFfin).
Qed.

Theorem locally_m_euclidean_implies_T1 : forall X Tx m:set,
  locally_m_euclidean X Tx m -> T1_space X Tx.
let X Tx m.
assume Hloc: locally_m_euclidean X Tx m.
prove T1_space X Tx.
(** Use lemma_T1_singletons_closed, reducing to showing that each singleton is closed. **)
claim Hloc_parts: (m :e omega /\ topology_on X Tx) /\ (forall x0:set, x0 :e X ->
  exists U0:set, exists V0:set, exists f0:set,
    open_in X Tx U0 /\ x0 :e U0 /\ V0 c= (euclidean_space m) /\
    open_in (euclidean_space m) (euclidean_topology m) V0 /\
    homeomorphism U0 (subspace_topology X Tx U0) V0 (subspace_topology (euclidean_space m) (euclidean_topology m) V0) f0).
{ exact Hloc. }
claim Htop: topology_on X Tx.
{ claim HmTop: m :e omega /\ topology_on X Tx.
  { exact (andEL (m :e omega /\ topology_on X Tx)
                 (forall x0:set, x0 :e X ->
                   exists U0:set, exists V0:set, exists f0:set,
                     open_in X Tx U0 /\ x0 :e U0 /\ V0 c= (euclidean_space m) /\
                     open_in (euclidean_space m) (euclidean_topology m) V0 /\
                     homeomorphism U0 (subspace_topology X Tx U0) V0 (subspace_topology (euclidean_space m) (euclidean_topology m) V0) f0)
                 Hloc_parts). }
  exact (andER (m :e omega) (topology_on X Tx) HmTop). }
claim Hcharts: forall x0:set, x0 :e X ->
  exists U0:set, exists V0:set, exists f0:set,
    open_in X Tx U0 /\ x0 :e U0 /\ V0 c= (euclidean_space m) /\
    open_in (euclidean_space m) (euclidean_topology m) V0 /\
    homeomorphism U0 (subspace_topology X Tx U0) V0 (subspace_topology (euclidean_space m) (euclidean_topology m) V0) f0.
{ exact (andER (m :e omega /\ topology_on X Tx)
               (forall x0:set, x0 :e X ->
                 exists U0:set, exists V0:set, exists f0:set,
                   open_in X Tx U0 /\ x0 :e U0 /\ V0 c= (euclidean_space m) /\
                   open_in (euclidean_space m) (euclidean_topology m) V0 /\
                   homeomorphism U0 (subspace_topology X Tx U0) V0 (subspace_topology (euclidean_space m) (euclidean_topology m) V0) f0)
               Hloc_parts). }
apply (iffER (T1_space X Tx)
             (forall x0:set, x0 :e X -> closed_in X Tx {x0})
             (lemma_T1_singletons_closed X Tx Htop)).
prove forall x0:set, x0 :e X -> closed_in X Tx {x0}.
let x0. assume Hx0X: x0 :e X.
prove closed_in X Tx {x0}.
(** It is enough to show X\\{x0} is open, and then {x0} = X\\(X\\{x0}). **)
claim HsingSub: {x0} c= X.
{ let y. assume Hy: y :e {x0}.
  claim Hyeq: y = x0.
  { exact (SingE x0 y Hy). }
  rewrite Hyeq. exact Hx0X. }
claim Hsep_x0: forall y:set, y :e X -> y <> x0 -> exists W:set, W :e Tx /\ y :e W /\ x0 /:e W.
{ let y. assume HyX: y :e X. assume Hyneq: y <> x0.
  apply (Hcharts y HyX).
  let U. assume HexVf.
  apply HexVf.
  let V. assume Hexf.
  apply Hexf.
  let f. assume Hprops.
  (** split the chart properties **)
  claim Hleft: (((open_in X Tx U /\ y :e U) /\ V c= (euclidean_space m)) /\
               open_in (euclidean_space m) (euclidean_topology m) V).
  { exact (andEL ((((open_in X Tx U /\ y :e U) /\ V c= (euclidean_space m)) /\
                 open_in (euclidean_space m) (euclidean_topology m) V))
                (homeomorphism U (subspace_topology X Tx U) V
                  (subspace_topology (euclidean_space m) (euclidean_topology m) V) f)
                Hprops). }
  claim Hhomeo: homeomorphism U (subspace_topology X Tx U) V
    (subspace_topology (euclidean_space m) (euclidean_topology m) V) f.
  { exact (andER ((((open_in X Tx U /\ y :e U) /\ V c= (euclidean_space m)) /\
                 open_in (euclidean_space m) (euclidean_topology m) V))
                (homeomorphism U (subspace_topology X Tx U) V
                  (subspace_topology (euclidean_space m) (euclidean_topology m) V) f)
                Hprops). }
  claim Hmid: ((open_in X Tx U /\ y :e U) /\ V c= (euclidean_space m)).
  { exact (andEL ((open_in X Tx U /\ y :e U) /\ V c= (euclidean_space m))
                 (open_in (euclidean_space m) (euclidean_topology m) V)
                 Hleft). }
  claim HVopen: open_in (euclidean_space m) (euclidean_topology m) V.
  { exact (andER ((open_in X Tx U /\ y :e U) /\ V c= (euclidean_space m))
                 (open_in (euclidean_space m) (euclidean_topology m) V)
                 Hleft). }
  claim Hpair: open_in X Tx U /\ y :e U.
  { exact (andEL (open_in X Tx U /\ y :e U) (V c= (euclidean_space m)) Hmid). }
  claim HVsub: V c= (euclidean_space m).
  { exact (andER (open_in X Tx U /\ y :e U) (V c= (euclidean_space m)) Hmid). }
  claim HUopen: open_in X Tx U.
  { exact (andEL (open_in X Tx U) (y :e U) Hpair). }
  claim HyU: y :e U.
  { exact (andER (open_in X Tx U) (y :e U) Hpair). }
  (** If x0 not in U, take W=U. Otherwise refine inside U via the chart. **)
  apply (xm (x0 :e U)).
  - assume Hx0U: x0 :e U.
    (** Extract that U is open in X and belongs to Tx. **)
    claim HUinTx: U :e Tx.
    { exact (andER (topology_on X Tx) (U :e Tx) HUopen). }
    (** Subspace topology on U is a topology. **)
    claim HUsubX: U c= X.
    { exact (open_in_subset X Tx U HUopen). }
    claim HTU: topology_on U (subspace_topology X Tx U).
    { exact (subspace_topology_is_topology X Tx U Htop HUsubX). }
    (** f is continuous and hence a function on U -> V. **)
    claim Hcontf: continuous_map U (subspace_topology X Tx U) V
      (subspace_topology (euclidean_space m) (euclidean_topology m) V) f.
    { exact (andEL (continuous_map U (subspace_topology X Tx U) V
                    (subspace_topology (euclidean_space m) (euclidean_topology m) V) f)
                   (exists g:set,
                     continuous_map V (subspace_topology (euclidean_space m) (euclidean_topology m) V) U
                       (subspace_topology X Tx U) g /\
                     (forall u:set, u :e U -> apply_fun g (apply_fun f u) = u) /\
                     (forall v:set, v :e V -> apply_fun f (apply_fun g v) = v))
                   Hhomeo). }
    claim Hfunf: function_on f U V.
    { claim Htmp: (topology_on U (subspace_topology X Tx U) /\ topology_on V (subspace_topology (euclidean_space m) (euclidean_topology m) V)) /\ function_on f U V.
      { exact (andEL ((topology_on U (subspace_topology X Tx U) /\ topology_on V (subspace_topology (euclidean_space m) (euclidean_topology m) V)) /\ function_on f U V)
                     (forall V1:set, V1 :e subspace_topology (euclidean_space m) (euclidean_topology m) V ->
                       preimage_of U f V1 :e subspace_topology X Tx U)
                     Hcontf). }
      exact (andER (topology_on U (subspace_topology X Tx U) /\ topology_on V (subspace_topology (euclidean_space m) (euclidean_topology m) V))
                   (function_on f U V)
                   Htmp). }
    claim Hfx0V: apply_fun f x0 :e V.
    { exact (Hfunf x0 Hx0U). }
    claim HfyV: apply_fun f y :e V.
    { exact (Hfunf y HyU). }
    (** V is T1 (as an open subspace of Euclidean space). **)
    claim HT1E: T1_space (euclidean_space m) (euclidean_topology m).
    { exact (euclidean_space_T1 m). }
    claim HT1V: T1_space V (subspace_topology (euclidean_space m) (euclidean_topology m) V).
    { claim HtopE: topology_on (euclidean_space m) (euclidean_topology m).
      { exact (andEL (topology_on (euclidean_space m) (euclidean_topology m))
                     (forall F:set, F c= euclidean_space m -> finite F -> closed_in (euclidean_space m) (euclidean_topology m) F)
                     HT1E). }
      exact (subspace_T1 (euclidean_space m) (euclidean_topology m) V HtopE HVsub HT1E). }
    (** Use V \\ {f(x0)} as an open neighborhood of f(y) when f(y) != f(x0). **)
    claim Hinj: forall u1 u2:set, u1 :e U -> u2 :e U -> apply_fun f u1 = apply_fun f u2 -> u1 = u2.
    { let u1 u2. assume Hu1U: u1 :e U. assume Hu2U: u2 :e U. assume Heq: apply_fun f u1 = apply_fun f u2.
      exact (homeomorphism_injective U (subspace_topology X Tx U) V
               (subspace_topology (euclidean_space m) (euclidean_topology m) V) f
               Hhomeo u1 u2 Hu1U Hu2U Heq). }
	    claim Hneqf: apply_fun f y <> apply_fun f x0.
	    { assume Heqf: apply_fun f y = apply_fun f x0.
	      claim Hyx0: y = x0.
	      { exact (Hinj y x0 HyU Hx0U Heqf). }
	      exact (Hyneq Hyx0). }
    set O := V :\: {apply_fun f x0}.
    claim HOopen: O :e subspace_topology (euclidean_space m) (euclidean_topology m) V.
    { exact (T1_singleton_complement_open V
              (subspace_topology (euclidean_space m) (euclidean_topology m) V)
              (apply_fun f x0)
              HT1V Hfx0V). }
    claim HfyO: apply_fun f y :e O.
    { apply setminusI.
      - exact HfyV.
      - assume Hsing: apply_fun f y :e {apply_fun f x0}.
        claim Heqf: apply_fun f y = apply_fun f x0.
        { exact (SingE (apply_fun f x0) (apply_fun f y) Hsing). }
        exact (Hneqf Heqf). }
    (** Preimage of O is open in the subspace topology on U. **)
    claim Hpreimg_open: preimage_of U f O :e subspace_topology X Tx U.
    { claim Hpreimg_axiom: forall V1:set,
        V1 :e subspace_topology (euclidean_space m) (euclidean_topology m) V ->
        preimage_of U f V1 :e subspace_topology X Tx U.
      { exact (andER ((topology_on U (subspace_topology X Tx U) /\
                       topology_on V (subspace_topology (euclidean_space m) (euclidean_topology m) V)) /\
                      function_on f U V)
                     (forall V1:set, V1 :e subspace_topology (euclidean_space m) (euclidean_topology m) V ->
                       preimage_of U f V1 :e subspace_topology X Tx U)
                     Hcontf). }
      exact (Hpreimg_axiom O HOopen). }
    (** Turn this into an open set in X using open_in_subspace_iff and closure under intersections. **)
    claim Hpreimg_sub: preimage_of U f O c= U.
    { let z. assume Hz: z :e preimage_of U f O.
      exact (SepE1 U (fun u:set => apply_fun f u :e O) z Hz). }
    claim Hpreimg_open_in: open_in U (subspace_topology X Tx U) (preimage_of U f O).
    { prove topology_on U (subspace_topology X Tx U) /\ preimage_of U f O :e subspace_topology X Tx U.
      apply andI.
      - exact HTU.
      - exact Hpreimg_open. }
    (** Use open_in_subspace_iff to obtain a V0Tx with preimage = V0U. **)
    claim HexV0: exists V0 :e Tx, preimage_of U f O = V0 :/\: U.
    { exact (iffEL (open_in U (subspace_topology X Tx U) (preimage_of U f O))
                   (exists V0 :e Tx, preimage_of U f O = V0 :/\: U)
                   (open_in_subspace_iff X Tx U (preimage_of U f O) Htop HUsubX Hpreimg_sub)
                   Hpreimg_open_in). }
    apply HexV0.
    let V0. assume HV0conj: V0 :e Tx /\ preimage_of U f O = V0 :/\: U.
    claim HV0Tx: V0 :e Tx.
    { exact (andEL (V0 :e Tx) (preimage_of U f O = V0 :/\: U) HV0conj). }
    claim HeqW: preimage_of U f O = V0 :/\: U.
    { exact (andER (V0 :e Tx) (preimage_of U f O = V0 :/\: U) HV0conj). }
    (** V0  U is open in X and separates y from x0. **)
    witness (V0 :/\: U).
    apply andI.
	    - (** (V0  U)  Tx and y  (V0  U) **)
	      apply andI.
	      + (** (V0  U)  Tx by closure under intersections **)
	        exact (topology_binintersect_closed X Tx V0 U Htop HV0Tx HUinTx).
	      + (** y  (V0  U) **)
	        rewrite <- HeqW.
	        prove y :e preimage_of U f O.
	        prove y :e {u :e U | apply_fun f u :e O}.
	        apply (SepI U (fun u:set => apply_fun f u :e O) y HyU).
	        exact HfyO.
	    - (** x0  (V0  U) **)
	      assume Hx0W: x0 :e (V0 :/\: U).
	      claim Hx0Pre: x0 :e preimage_of U f O.
	      { rewrite HeqW. exact Hx0W. }
	      claim Hfx0O: apply_fun f x0 :e O.
	      { exact (SepE2 U (fun u:set => apply_fun f u :e O) x0 Hx0Pre). }
	      claim HnotSing: apply_fun f x0 /:e {apply_fun f x0}.
	      { exact (setminusE2 V {apply_fun f x0} (apply_fun f x0) Hfx0O). }
	      exact (HnotSing (SingI (apply_fun f x0))).
	  - assume Hx0notU: ~(x0 :e U).
	    witness U.
	    apply andI.
	    - apply andI.
	      + exact (andER (topology_on X Tx) (U :e Tx) HUopen).
	      + exact HyU.
	    - exact Hx0notU.
}
claim Hcomp_open: X :\: {x0} :e Tx.
{ set UFam := {W :e Power X |
    exists y:set, y :e X /\ y <> x0 /\ W :e Tx /\ y :e W /\ x0 /:e W}.
  claim HUFamSub: UFam c= Tx.
  { let W. assume HW: W :e UFam.
    claim HWpred: exists y:set, y :e X /\ y <> x0 /\ W :e Tx /\ y :e W /\ x0 /:e W.
    { exact (SepE2 (Power X)
                   (fun W0:set => exists y:set, y :e X /\ y <> x0 /\ W0 :e Tx /\ y :e W0 /\ x0 /:e W0)
                   W
                   HW). }
    apply HWpred.
    let y. assume Hy_conj: y :e X /\ y <> x0 /\ W :e Tx /\ y :e W /\ x0 /:e W.
    claim H0: (((y :e X /\ y <> x0) /\ W :e Tx) /\ y :e W).
    { exact (andEL ((((y :e X /\ y <> x0) /\ W :e Tx) /\ y :e W)) (x0 /:e W) Hy_conj). }
    claim H1: (y :e X /\ y <> x0) /\ W :e Tx.
    { exact (andEL ((y :e X /\ y <> x0) /\ W :e Tx) (y :e W) H0). }
    exact (andER (y :e X /\ y <> x0) (W :e Tx) H1). }
  claim HUnionOpen: Union UFam :e Tx.
  { exact (topology_union_closed X Tx UFam Htop HUFamSub). }
  claim HUnionEq: Union UFam = X :\: {x0}.
  { apply set_ext.
    - let z. assume Hz: z :e Union UFam.
      prove z :e X :\: {x0}.
      apply (UnionE_impred UFam z Hz (z :e X :\: {x0})).
      let W. assume HzW: z :e W. assume HW: W :e UFam.
      claim HWpow: W :e Power X.
      { exact (SepE1 (Power X)
                     (fun W0:set => exists y:set, y :e X /\ y <> x0 /\ W0 :e Tx /\ y :e W0 /\ x0 /:e W0)
                     W
                     HW). }
      claim HWsubX: W c= X.
      { exact (PowerE X W HWpow). }
      claim HzX: z :e X.
      { exact (HWsubX z HzW). }
      claim HWpred: exists y:set, y :e X /\ y <> x0 /\ W :e Tx /\ y :e W /\ x0 /:e W.
      { exact (SepE2 (Power X)
                     (fun W0:set => exists y:set, y :e X /\ y <> x0 /\ W0 :e Tx /\ y :e W0 /\ x0 /:e W0)
                     W
                     HW). }
      apply HWpred.
      let y. assume Hy_conj: y :e X /\ y <> x0 /\ W :e Tx /\ y :e W /\ x0 /:e W.
      claim Hx0NotW: x0 /:e W.
      { exact (andER ((((y :e X /\ y <> x0) /\ W :e Tx) /\ y :e W)) (x0 /:e W) Hy_conj). }
      claim HznotSing: z /:e {x0}.
      { assume HzSing: z :e {x0}.
        claim Hzeq: z = x0.
        { exact (SingE x0 z HzSing). }
        claim Hx0W: x0 :e W.
        { rewrite <- Hzeq. exact HzW. }
        exact (Hx0NotW Hx0W). }
      exact (setminusI X {x0} z HzX HznotSing).
    - let z. assume Hz: z :e X :\: {x0}.
      prove z :e Union UFam.
      claim HzX: z :e X.
      { exact (setminusE1 X {x0} z Hz). }
      claim HznotSing: z /:e {x0}.
      { exact (setminusE2 X {x0} z Hz). }
      claim Hzneq: z <> x0.
      { assume Hzeq: z = x0.
        claim HzSing: z :e {x0}.
        { rewrite Hzeq. exact (SingI x0). }
        exact (HznotSing HzSing). }
      claim HexW: exists W:set, W :e Tx /\ z :e W /\ x0 /:e W.
      { exact (Hsep_x0 z HzX Hzneq). }
      apply HexW.
      let W. assume HWconj: W :e Tx /\ z :e W /\ x0 /:e W.
      claim HW0: W :e Tx /\ z :e W.
      { exact (andEL (W :e Tx /\ z :e W) (x0 /:e W) HWconj). }
      claim HWTx: W :e Tx.
      { exact (andEL (W :e Tx) (z :e W) HW0). }
      claim HzW: z :e W.
      { exact (andER (W :e Tx) (z :e W) HW0). }
      claim Hx0notW: x0 /:e W.
      { exact (andER (W :e Tx /\ z :e W) (x0 /:e W) HWconj). }
      claim HTsub: Tx c= Power X.
      { exact (topology_subset_axiom X Tx Htop). }
      claim HWpow: W :e Power X.
      { exact (HTsub W HWTx). }
      claim HWUFam: W :e UFam.
      { apply (SepI (Power X)
                    (fun W0:set => exists y:set, y :e X /\ y <> x0 /\ W0 :e Tx /\ y :e W0 /\ x0 /:e W0)
                    W
                    HWpow).
	        witness z.
	        (** show z witnesses the predicate **)
	        apply andI.
	        - (** (((z :e X /\ z <> x0) /\ W :e Tx) /\ z :e W) **)
	          apply andI.
	          + (** (z :e X /\ z <> x0) /\ W :e Tx **)
	            apply andI.
	            * (** z :e X /\ z <> x0 **)
	              apply andI.
	              - exact HzX.
	              - exact Hzneq.
	            * exact HWTx.
	          + exact HzW.
	        - exact Hx0notW.
	      }
      exact (UnionI UFam z W HzW HWUFam).
  }
  rewrite <- HUnionEq.
  exact HUnionOpen. }
prove topology_on X Tx /\ ({x0} c= X /\ exists U :e Tx, {x0} = X :\: U).
apply andI.
- exact Htop.
- apply andI.
  + exact HsingSub.
  + witness (X :\: {x0}).
	    apply andI.
	    * exact Hcomp_open.
	    * rewrite (setminus_setminus_eq X {x0} HsingSub).
	      reflexivity.
Qed.

(** from 50 Exercise 1: discrete space has dimension 0 **)
(** LATEX VERSION: Every discrete space has topological dimension 0. **)
Theorem ex50_1_discrete_dimension_0 : forall X Tx:set,
  Tx = discrete_topology X ->
  topology_on X Tx ->
  covering_dimension X Tx Empty.
admit.
Qed.

(** from 50 Exercise 2: connected T1 space with >1 point has dimension 1 **)
(** LATEX VERSION: Any connected T space with more than one point has dimension at least 1. **)
Theorem ex50_2_connected_T1_dimension_ge_1 : forall X Tx:set,
  connected_space X Tx ->
  T1_space X Tx ->
  (exists x y:set, x :e X /\ y :e X /\ x <> y) ->
  covering_dimension X Tx Empty -> False.
admit.
Qed.

(** from 50 Exercise 3: topologist's sine curve has dimension 1 **)
(** LATEX VERSION: The topologist's sine curve has topological dimension 1. **)
(** from 50 Exercise 3: the topologist sine curve **)
(** LATEX VERSION: The topologist sine curve is a specific subspace of R2; we name it abstractly here. **)
(** stub: the actual geometric definition is not expanded in this file **)
Definition topologists_sine_curve : set := Eps_i (fun S:set => S c= EuclidPlane).
Theorem topologists_sine_curve_subset_EuclidPlane : topologists_sine_curve c= EuclidPlane.
prove topologists_sine_curve c= EuclidPlane.
claim Hex: exists S:set, S c= EuclidPlane.
{ witness Empty.
  exact (Subq_Empty EuclidPlane). }
exact (Eps_i_ex (fun S:set => S c= EuclidPlane) Hex).
Qed.
Definition topologists_sine_curve_topology : set :=
  subspace_topology EuclidPlane R2_standard_topology topologists_sine_curve.
Theorem EuclidPlane_R2_standard_topology_on : topology_on EuclidPlane R2_standard_topology.
prove topology_on EuclidPlane R2_standard_topology.
exact (product_topology_is_topology R R_standard_topology R R_standard_topology
         R_standard_topology_is_topology R_standard_topology_is_topology).
Qed.
Theorem topologists_sine_curve_topology_on :
  topology_on topologists_sine_curve topologists_sine_curve_topology.
prove topology_on topologists_sine_curve topologists_sine_curve_topology.
exact (subspace_topology_is_topology EuclidPlane R2_standard_topology topologists_sine_curve
         EuclidPlane_R2_standard_topology_on
         topologists_sine_curve_subset_EuclidPlane).
Qed.
Theorem ex50_3_sine_curve_dimension_1 :
  covering_dimension topologists_sine_curve topologists_sine_curve_topology (Sing Empty).
admit.
Qed.

(** from 50 Exercise 4: specific points in general position in R **)
(** LATEX VERSION: Show that 0, , , , and (1,1,1) are in general position in R. **)
(** FIXED: Use explicit coordinate functions in the product description of euclidean_space 3. **)

(** helper: 2 is an element of 3 **)
Theorem In_2_3 : 2 :e 3.
prove 2 :e 3.
rewrite <- ordsucc_2_eq_3.
exact (ordsuccI2 2).
Qed.

(** helper: all reals lie in the space-family union for R **)
Theorem real_in_space_family_union_R3 : forall y:set,
  y :e R ->
  y :e space_family_union 3 (const_space_family 3 R R_standard_topology).
let y.
assume HyR: y :e R.
prove y :e space_family_union 3 (const_space_family 3 R R_standard_topology).
set Xi := const_space_family 3 R R_standard_topology.
set S := {space_family_set Xi i|i :e 3}.
prove y :e Union S.
claim H2in3: 2 :e 3.
{ exact In_2_3. }
claim HXi2: apply_fun Xi 2 = (R, R_standard_topology).
{ exact (const_space_family_apply 3 R R_standard_topology 2 H2in3). }
claim HSf2: space_family_set Xi 2 = R.
{ prove (apply_fun Xi 2) 0 = R.
  rewrite HXi2.
  exact (tuple_2_0_eq R R_standard_topology). }
 claim Helt: space_family_set Xi 2 :e S.
 { exact (ReplI 3 (fun i:set => space_family_set Xi i) 2 H2in3). }
 claim HySf2: y :e space_family_set Xi 2.
 { rewrite HSf2.
   exact HyR. }
 exact (UnionI S y (space_family_set Xi 2) HySf2 Helt).
Qed.

(** helper: each component set in the constant family is R **)
Theorem space_family_set_const_R3 : forall i:set,
  i :e 3 ->
  space_family_set (const_space_family 3 R R_standard_topology) i = R.
let i.
assume Hi3: i :e 3.
prove space_family_set (const_space_family 3 R R_standard_topology) i = R.
set Xi := const_space_family 3 R R_standard_topology.
claim HXi: apply_fun Xi i = (R, R_standard_topology).
{ exact (const_space_family_apply 3 R R_standard_topology i Hi3). }
prove (apply_fun Xi i) 0 = R.
rewrite HXi.
exact (tuple_2_0_eq R R_standard_topology).
Qed.

(** helper: a coordinate function into R yields a point of euclidean_space 3 **)
Theorem graph3_in_euclidean_space3 : forall g:set->set,
  (forall i:set, g i :e R) ->
  graph 3 g :e euclidean_space 3.
 let g.
 assume HgR: forall i:set, g i :e R.
 set Xi := const_space_family 3 R R_standard_topology.
 set U := space_family_union 3 Xi.
 prove graph 3 g :e {f :e Power (setprod 3 U)|
                      function_on f 3 U /\ (forall i:set, i :e 3 -> apply_fun f i :e space_family_set Xi i)}.
 claim Hsub: graph 3 g c= setprod 3 U.
 { let p. assume Hp: p :e graph 3 g.
   prove p :e setprod 3 U.
   apply (ReplE_impred 3 (fun i:set => (i, g i)) p Hp (p :e setprod 3 U)).
   let i. assume Hi3: i :e 3.
   assume HpEq: p = (i, g i).
   rewrite HpEq.
   claim HgiU: g i :e U.
   { exact (real_in_space_family_union_R3 (g i) (HgR i)). }
   exact (tuple_2_setprod 3 U i Hi3 (g i) HgiU). }
 claim Hpow: graph 3 g :e Power (setprod 3 U).
 { exact (PowerI (setprod 3 U) (graph 3 g) Hsub). }
 claim Hfun: function_on (graph 3 g) 3 U.
 { let i. assume Hi3: i :e 3.
   prove apply_fun (graph 3 g) i :e U.
   claim Happ: apply_fun (graph 3 g) i = g i.
   { exact (apply_fun_graph 3 g i Hi3). }
   rewrite Happ.
   exact (real_in_space_family_union_R3 (g i) (HgR i)). }
 claim Hcoords: forall i:set, i :e 3 -> apply_fun (graph 3 g) i :e space_family_set Xi i.
 { let i. assume Hi3: i :e 3.
   prove apply_fun (graph 3 g) i :e space_family_set Xi i.
   claim Happ: apply_fun (graph 3 g) i = g i.
   { exact (apply_fun_graph 3 g i Hi3). }
   rewrite Happ.
   claim HSf: space_family_set Xi i = R.
   { exact (space_family_set_const_R3 i Hi3). }
   rewrite HSf.
   exact (HgR i). }
 claim Hprop: function_on (graph 3 g) 3 U /\ (forall i:set, i :e 3 -> apply_fun (graph 3 g) i :e space_family_set Xi i).
 { apply andI.
   - exact Hfun.
   - exact Hcoords. }
 exact (SepI (Power (setprod 3 U))
            (fun f0:set => function_on f0 3 U /\ (forall i:set, i :e 3 -> apply_fun f0 i :e space_family_set Xi i))
            (graph 3 g)
            Hpow
            Hprop).
Qed.

(** explicit points in R as coordinate functions **)
Definition ex50_R3_zero : set := graph 3 (fun _ : set => 0).
Definition ex50_R3_ones : set := graph 3 (fun _ : set => 1).
Definition ex50_R3_e1 : set := graph 3 (fun i:set => if i = 0 then 1 else 0).
Definition ex50_R3_e2 : set := graph 3 (fun i:set => if i = 1 then 1 else 0).
Definition ex50_R3_e3 : set := graph 3 (fun i:set => if i = 2 then 1 else 0).

(** membership facts for these points **)
Theorem ex50_R3_zero_in : ex50_R3_zero :e euclidean_space 3.
prove ex50_R3_zero :e euclidean_space 3.
apply (graph3_in_euclidean_space3 (fun _ : set => 0)).
let i.
exact real_0.
Qed.

Theorem ex50_R3_ones_in : ex50_R3_ones :e euclidean_space 3.
prove ex50_R3_ones :e euclidean_space 3.
apply (graph3_in_euclidean_space3 (fun _ : set => 1)).
let i.
exact real_1.
Qed.

Theorem ex50_R3_e1_in : ex50_R3_e1 :e euclidean_space 3.
prove ex50_R3_e1 :e euclidean_space 3.
claim Hdef: ex50_R3_e1 = graph 3 (fun i:set => if i = 0 then 1 else 0).
{ reflexivity. }
rewrite Hdef.
apply (graph3_in_euclidean_space3 (fun i:set => if i = 0 then 1 else 0)).
let i.
claim Happ: (fun i0:set => if i0 = 0 then 1 else 0) i = (if i = 0 then 1 else 0).
{ reflexivity. }
rewrite Happ.
apply (xm (i = 0)).
- assume Hi0: i = 0.
  claim Hif: (if i = 0 then 1 else 0) = 1.
  { exact (If_i_1 (i = 0) 1 0 Hi0). }
  rewrite Hif.
  exact real_1.
- assume Hni0: ~(i = 0).
  claim Hif: (if i = 0 then 1 else 0) = 0.
  { exact (If_i_0 (i = 0) 1 0 Hni0). }
  rewrite Hif.
  exact real_0.
Qed.

Theorem ex50_R3_e2_in : ex50_R3_e2 :e euclidean_space 3.
prove ex50_R3_e2 :e euclidean_space 3.
claim Hdef: ex50_R3_e2 = graph 3 (fun i:set => if i = 1 then 1 else 0).
{ reflexivity. }
rewrite Hdef.
apply (graph3_in_euclidean_space3 (fun i:set => if i = 1 then 1 else 0)).
let i.
claim Happ: (fun i0:set => if i0 = 1 then 1 else 0) i = (if i = 1 then 1 else 0).
{ reflexivity. }
rewrite Happ.
apply (xm (i = 1)).
- assume Hi1: i = 1.
  claim Hif: (if i = 1 then 1 else 0) = 1.
  { exact (If_i_1 (i = 1) 1 0 Hi1). }
  rewrite Hif.
  exact real_1.
- assume Hni1: ~(i = 1).
  claim Hif: (if i = 1 then 1 else 0) = 0.
  { exact (If_i_0 (i = 1) 1 0 Hni1). }
  rewrite Hif.
  exact real_0.
Qed.

Theorem ex50_R3_e3_in : ex50_R3_e3 :e euclidean_space 3.
prove ex50_R3_e3 :e euclidean_space 3.
claim Hdef: ex50_R3_e3 = graph 3 (fun i:set => if i = 2 then 1 else 0).
{ reflexivity. }
rewrite Hdef.
apply (graph3_in_euclidean_space3 (fun i:set => if i = 2 then 1 else 0)).
let i.
claim Happ: (fun i0:set => if i0 = 2 then 1 else 0) i = (if i = 2 then 1 else 0).
{ reflexivity. }
rewrite Happ.
apply (xm (i = 2)).
- assume Hi2: i = 2.
  claim Hif: (if i = 2 then 1 else 0) = 1.
  { exact (If_i_1 (i = 2) 1 0 Hi2). }
  rewrite Hif.
  exact real_1.
- assume Hni2: ~(i = 2).
  claim Hif: (if i = 2 then 1 else 0) = 0.
  { exact (If_i_0 (i = 2) 1 0 Hni2). }
  rewrite Hif.
  exact real_0.
Qed.
Theorem ex50_4_points_general_position_R3 :
  general_position_RN 3 {ex50_R3_zero, ex50_R3_e1, ex50_R3_e2, ex50_R3_e3, ex50_R3_ones}.
admit.
Qed.

(** from 50 Exercise 5: embedding theorem for m=1 maps to linear graph **)
(** LATEX VERSION: For m=1, the map g in the embedding theorem proof maps X onto a linear graph in R. **)
Theorem ex50_5_embedding_m1_linear_graph : forall X Tx:set,
  covering_dimension X Tx (Sing Empty) ->
  compact_space X Tx ->
  metrizable X Tx ->
  exists g:set,
    (forall x:set, x :e X -> apply_fun g x :e (euclidean_space 3)) /\
    linear_graph (apply_fun g X) R_standard_topology.
admit.
Qed.

(** from 50 Exercise 6: locally compact Hausdorff with countable basis embeds in R^{2m+1} **)
(** LATEX VERSION: A locally compact Hausdorff space with countable basis whose compact subspaces have dimension m is homeomorphic to a closed subspace of R^{2m+1}. **)
(** FIXED: Dimension error - should be 2m+1, not m+1. **)
Theorem ex50_6_locally_compact_embeds : forall X Tx m:set,
  m :e omega ->
  locally_compact X Tx ->
  Hausdorff_space X Tx ->
  second_countable_space X Tx ->
  (forall C:set, C c= X -> compact_space C (subspace_topology X Tx C) -> covering_dimension C (subspace_topology X Tx C) m) ->
  exists N:set, exists e:set,
    N = add_nat (mul_nat two m) (Sing Empty) /\
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e /\
    closed_in (euclidean_space N) (euclidean_topology N) (apply_fun e X).
admit.
Qed.

(** from 50 Exercise 7: every m-manifold embeds in R^{2m+1} as closed subspace **)
(** LATEX VERSION: Every m-manifold can be embedded in R^{2m+1} as a closed subspace. **)
(** FIXED: Dimension error - should be 2m+1, not m+1. **)
Theorem ex50_7_manifold_closed_embedding : forall X Tx m:set,
  m :e omega ->
  m_manifold X Tx ->
  exists N:set, exists e:set,
    N = add_nat (mul_nat two m) (Sing Empty) /\
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e /\
    closed_in (euclidean_space N) (euclidean_topology N) (apply_fun e X).
admit.
Qed.

(** from 50 Exercise 8: sigma-compact Hausdorff with compact subspaces of dimension m has dimension m **)
(** LATEX VERSION: A -compact Hausdorff space whose compact subspaces have dimension m has dimension m. **)
(** FIXED: sigma_compact uses X = Union Fam, not a filtered union; sigma-compact means a countable union of compact subspaces. **) 
Definition sigma_compact : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  exists Fam:set,
    countable Fam /\
    (forall C:set, C :e Fam -> C c= X /\ compact_space C (subspace_topology X Tx C)) /\
    X = Union Fam.

Theorem ex50_8_sigma_compact_dimension : forall X Tx m:set,
  m :e omega ->
  sigma_compact X Tx ->
  Hausdorff_space X Tx ->
  (forall C:set, C c= X -> compact_space C (subspace_topology X Tx C) -> covering_dimension C (subspace_topology X Tx C) m) ->
  covering_dimension X Tx m.
admit.
Qed.

(** from 50 Exercise 9: every m-manifold has dimension m **)
(** LATEX VERSION: Every m-manifold has topological dimension at most m. **)
Theorem ex50_9_manifold_dimension_le_m : forall X Tx m:set,
  m :e omega ->
  m_manifold X Tx ->
  covering_dimension X Tx m.
admit.
Qed.

(** from 50 Exercise 10: closed subspace of R^N has dimension N **)
(** LATEX VERSION: Every closed subspace of R^N has topological dimension at most N. **)
Theorem ex50_10_closed_subspace_RN_dimension : forall X N:set,
  N :e omega ->
  X c= (euclidean_space N) ->
  closed_in (euclidean_space N) (euclidean_topology N) X ->
  covering_dimension X (subspace_topology (euclidean_space N) (euclidean_topology N) X) N.
admit.
Qed.

(** from 50 Exercise 11: embedding in R^N characterization **)
(** LATEX VERSION: A space X can be embedded as a closed subspace of R^N for some N iff X is locally compact Hausdorff with countable basis and finite dimension. **)
Theorem ex50_11_embedding_characterization : forall X Tx:set,
  (exists N:set, exists e:set,
    N :e omega /\
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e /\
    closed_in (euclidean_space N) (euclidean_topology N) (apply_fun e X))
<->
(locally_compact X Tx /\ Hausdorff_space X Tx /\ second_countable_space X Tx /\ finite_dimensional_space X Tx).
admit.
Qed.

(** from Supplementary Exercises Exercise 1: locally m-euclidean implies locally compact and locally metrizable **)
(** LATEX VERSION: If X is locally m-euclidean, then X is locally compact and locally metrizable. **)
(** helper: local metrizability **)
(** LATEX VERSION: A space is locally metrizable if each point has a neighborhood whose subspace topology is induced by some metric. **)
Definition locally_metrizable_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall x:set, x :e X ->
    exists N:set, N :e Tx /\ x :e N /\
      exists d:set, metric_on N d /\ subspace_topology X Tx N = metric_topology N d.

Theorem supp_ex_locally_euclidean_1 : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  locally_compact X Tx /\ locally_metrizable_space X Tx.
admit.
Qed.

(** from Supplementary Exercises Exercise 2: implications among conditions **)
(** LATEX VERSION: For locally m-euclidean X: (i) compact Hausdorff  (ii) m-manifold  (iii) metrizable  (iv) normal  (v) Hausdorff. **)
Theorem supp_ex_locally_euclidean_2_i_implies_ii : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  compact_space X Tx ->
  Hausdorff_space X Tx ->
  m_manifold X Tx.
admit.
Qed.

Theorem supp_ex_locally_euclidean_2_ii_implies_iii : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  m_manifold X Tx ->
  metrizable X Tx.
admit.
Qed.

Theorem supp_ex_locally_euclidean_2_iii_implies_iv : forall X Tx:set,
  metrizable X Tx ->
  normal_space X Tx.
let X Tx.
assume Hmet.
prove normal_space X Tx.
(** Unpack metrizability: Tx = metric_topology X d for some metric d. **)
apply Hmet.
let d. assume HdPair.
claim Hd: metric_on X d.
{ exact (andEL (metric_on X d) (metric_topology X d = Tx) HdPair). }
claim Heq: metric_topology X d = Tx.
{ exact (andER (metric_on X d) (metric_topology X d = Tx) HdPair). }
claim Hnorm: normal_space X (metric_topology X d).
{ exact (metrizable_spaces_normal X d Hd). }
rewrite <- Heq.
exact Hnorm.
Qed.

(** helper: normal + T1 implies Hausdorff **)
Theorem normal_T1_implies_Hausdorff : forall X Tx:set,
  normal_space X Tx -> T1_space X Tx -> Hausdorff_space X Tx.
let X Tx.
  assume Hnorm: normal_space X Tx.
  assume HT1: T1_space X Tx.
  prove Hausdorff_space X Tx.
  claim HT1part: one_point_sets_closed X Tx.
  { exact (andEL (one_point_sets_closed X Tx)
                 (forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty)
                 Hnorm). }
  claim HTx: topology_on X Tx.
  { exact (andEL (topology_on X Tx)
                 (forall x:set, x :e X -> closed_in X Tx {x})
                 HT1part). }
  claim Hsing:
  forall x:set, x :e X -> closed_in X Tx {x}.
  { exact (iffEL (T1_space X Tx)
               (forall x:set, x :e X -> closed_in X Tx {x})
               (lemma_T1_singletons_closed X Tx HTx) HT1). }
prove topology_on X Tx /\
      forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
        exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
apply andI.
- exact HTx.
- let x1 x2.
  assume Hx1X: x1 :e X.
  assume Hx2X: x2 :e X.
  assume Hneq: x1 <> x2.
  prove exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
  claim Hcl1: closed_in X Tx {x1}.
  { exact (Hsing x1 Hx1X). }
  claim Hcl2: closed_in X Tx {x2}.
  { exact (Hsing x2 Hx2X). }
  claim Hdisj: {x1} :/\: {x2} = Empty.
  { apply Empty_Subq_eq.
    let z. assume Hz: z :e {x1} :/\: {x2}.
    prove z :e Empty.
    claim Hz1: z :e {x1}.
    { exact (binintersectE1 {x1} {x2} z Hz). }
    claim Hz2: z :e {x2}.
    { exact (binintersectE2 {x1} {x2} z Hz). }
    claim Hzx1: z = x1.
    { exact (SingE x1 z Hz1). }
    claim Hzx2: z = x2.
    { exact (SingE x2 z Hz2). }
    claim Hx1x2: x1 = x2.
    { rewrite <- Hzx1. rewrite Hzx2. reflexivity. }
    apply FalseE.
    exact (Hneq Hx1x2). }
  claim Hsep:
    forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
      exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.
  { exact (andER (one_point_sets_closed X Tx)
                 (forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty)
                 Hnorm). }
  claim HexUV:
    exists U V:set, U :e Tx /\ V :e Tx /\ {x1} c= U /\ {x2} c= V /\ U :/\: V = Empty.
  { exact (Hsep {x1} {x2} Hcl1 Hcl2 Hdisj). }
  set U0 := Eps_i (fun U:set => exists V:set,
    U :e Tx /\ V :e Tx /\ {x1} c= U /\ {x2} c= V /\ U :/\: V = Empty).
  claim HU0ex: exists V:set,
    U0 :e Tx /\ V :e Tx /\ {x1} c= U0 /\ {x2} c= V /\ U0 :/\: V = Empty.
  { exact (Eps_i_ex (fun U:set => exists V:set,
      U :e Tx /\ V :e Tx /\ {x1} c= U /\ {x2} c= V /\ U :/\: V = Empty)
      HexUV). }
  set V0 := Eps_i (fun V:set => U0 :e Tx /\ V :e Tx /\ {x1} c= U0 /\ {x2} c= V /\ U0 :/\: V = Empty).
  claim HV0prop: U0 :e Tx /\ V0 :e Tx /\ {x1} c= U0 /\ {x2} c= V0 /\ U0 :/\: V0 = Empty.
  { exact (Eps_i_ex (fun V:set => U0 :e Tx /\ V :e Tx /\ {x1} c= U0 /\ {x2} c= V /\ U0 :/\: V = Empty)
      HU0ex). }
  (** Unpack the left-associative 5-way conjunction HV0prop into its components. **)
  claim H1234: (((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0) /\ {x2} c= V0).
  { exact (andEL ((((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0) /\ {x2} c= V0))
                 (U0 :/\: V0 = Empty)
                 HV0prop). }
  claim HdisjUV: U0 :/\: V0 = Empty.
  { exact (andER ((((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0) /\ {x2} c= V0))
                 (U0 :/\: V0 = Empty)
                 HV0prop). }
  claim H123: ((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0).
  { exact (andEL ((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0)
                 ({x2} c= V0)
                 H1234). }
  claim Hs2: {x2} c= V0.
  { exact (andER ((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0)
                 ({x2} c= V0)
                 H1234). }
  claim Hab: U0 :e Tx /\ V0 :e Tx.
  { exact (andEL (U0 :e Tx /\ V0 :e Tx)
                 ({x1} c= U0)
                 H123). }
  claim HU0Tx: U0 :e Tx.
  { exact (andEL (U0 :e Tx) (V0 :e Tx) Hab). }
  claim HV0Tx: V0 :e Tx.
  { exact (andER (U0 :e Tx) (V0 :e Tx) Hab). }
  claim Hs1: {x1} c= U0.
  { exact (andER (U0 :e Tx /\ V0 :e Tx)
                 ({x1} c= U0)
                 H123). }
  claim Hx1U0: x1 :e U0.
  { exact (Hs1 x1 (SingI x1)). }
  claim Hx2V0: x2 :e V0.
  { exact (Hs2 x2 (SingI x2)). }
  witness U0.
  witness V0.
  apply andI.
  - apply andI.
    + apply andI.
      * apply andI.
        { exact HU0Tx. }
        { exact HV0Tx. }
      * exact Hx1U0.
    + exact Hx2V0.
  - exact HdisjUV.
Qed.

(** from Supplementary Exercises Exercise 2: (iv) normal  (v) Hausdorff, for locally m-euclidean X **)
(** LATEX VERSION: For locally m-euclidean X, normality implies Hausdorff. **)
Theorem supp_ex_locally_euclidean_2_iv_implies_v : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  normal_space X Tx ->
  Hausdorff_space X Tx.
let X Tx m.
assume Hloc: locally_m_euclidean X Tx m.
assume Hnorm: normal_space X Tx.
prove Hausdorff_space X Tx.
claim HT1: T1_space X Tx.
{ exact (locally_m_euclidean_implies_T1 X Tx m Hloc). }
exact (normal_T1_implies_Hausdorff X Tx Hnorm HT1).
Qed.

(** from Supplementary Exercises Exercise 3: R is locally 1-euclidean satisfies (ii) not (i) **)
(** LATEX VERSION: R is locally 1-euclidean and satisfies (ii) but not (i). **)
Theorem supp_ex_locally_euclidean_3 :
  locally_m_euclidean R R_standard_topology (Sing Empty) /\
  m_manifold R R_standard_topology /\
  ~ (compact_space R R_standard_topology /\ Hausdorff_space R R_standard_topology).
admit.
Qed.

(** from Supplementary Exercises Exercise 4: RR dictionary order is locally 1-euclidean satisfies (iii) not (ii) **)
(** LATEX VERSION: RR in dictionary order topology is locally 1-euclidean and satisfies (iii) but not (ii). **)
Theorem supp_ex_locally_euclidean_4 :
  locally_m_euclidean EuclidPlane (order_topology EuclidPlane) (Sing Empty) /\
  metrizable EuclidPlane (order_topology EuclidPlane) /\
  ~ m_manifold EuclidPlane (order_topology EuclidPlane).
admit.
Qed.

(** from Supplementary Exercises Exercise 5: long line is locally 1-euclidean satisfies (iv) not (iii) **)
(** LATEX VERSION: The long line is locally 1-euclidean and satisfies (iv) but not (iii). **)
(** from Supplementary Exercises Exercise 5: long line carrier and topology **)
(** LATEX VERSION: The long line and its topology (see exercises of 24). **)
(** note: the long line is not constructed in this file; we name its carrier abstractly but ensure it is infinite **)
Definition long_line : set := Eps_i (fun L:set => infinite L).
Theorem infinite_omega : infinite omega.
prove infinite omega.
claim Hatleast: atleastp omega omega.
{ exact (Subq_atleastp omega omega (Subq_ref omega)). }
exact (atleastp_omega_infinite omega Hatleast).
Qed.
Theorem long_line_infinite : infinite long_line.
prove infinite long_line.
claim Hex: exists L:set, infinite L.
{ witness omega.
  exact infinite_omega. }
exact (Eps_i_ex (fun L:set => infinite L) Hex).
Qed.
Definition long_line_topology : set := Eps_i (fun T:set => topology_on long_line T).
Theorem long_line_topology_on : topology_on long_line long_line_topology.
prove topology_on long_line long_line_topology.
claim Hex: exists T:set, topology_on long_line T.
{ witness (discrete_topology long_line).
  exact (discrete_topology_on long_line). }
exact (Eps_i_ex (fun T:set => topology_on long_line T) Hex).
Qed.
Theorem supp_ex_locally_euclidean_5 :
  locally_m_euclidean long_line long_line_topology (Sing Empty) /\
  normal_space long_line long_line_topology /\
  ~ metrizable long_line long_line_topology.
admit.
Qed.

(** from Supplementary Exercises Exercise 7: Hausdorff iff completely regular **)
(** LATEX VERSION: For locally m-euclidean X: X is Hausdorff iff X is completely regular. **)
Theorem supp_ex_locally_euclidean_7 : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  (Hausdorff_space X Tx <-> completely_regular_space X Tx).
admit.
Qed.

(** from Supplementary Exercises Exercise 8: metrizable iff paracompact Hausdorff **)
(** LATEX VERSION: For locally m-euclidean X: X is metrizable iff X is paracompact Hausdorff. **)
Theorem supp_ex_locally_euclidean_8 : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  (metrizable X Tx <-> (paracompact_space X Tx /\ Hausdorff_space X Tx)).
admit.
Qed.

(** from Supplementary Exercises Exercise 9: metrizable implies components are m-manifolds **)
(** LATEX VERSION: If locally m-euclidean X is metrizable, then each component of X is an m-manifold. **)
Theorem supp_ex_locally_euclidean_9 : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  metrizable X Tx ->
  forall x:set, x :e X ->
    m_manifold (component_of X Tx x) (subspace_topology X Tx (component_of X Tx x)).
admit.
Qed.

(** helper: G_delta subset coded via countable intersection of open sets **)
Definition Gdelta_in : set -> set -> set -> prop := fun X Tx A =>
  exists Fam:set, countable_set Fam /\
    (forall U :e Fam, open_in X Tx U) /\
    intersection_over_family X Fam = A.

(** helper: open map - images of open sets are open **)
(** FIXED: open_map uses image_of f U for set images; apply_fun is only for elements. **) 
Definition open_map : set -> set -> set -> set -> set -> prop :=
  fun X Tx Y Ty f =>
    topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y /\
    forall U:set, U :e Tx -> image_of f U :e Ty.

(** helper: simple topological group structure **)
Definition topological_group : set -> set -> prop := fun G Tg =>
  topology_on G Tg /\
  exists mult inv e:set,
    function_on mult (setprod G G) G /\
    function_on inv G G /\
    e :e G /\
    continuous_map (setprod G G) (product_topology G Tg G Tg) G Tg mult /\
    continuous_map G Tg G Tg inv.

(** helper: separated subsets predicate **)
Definition separated_subsets : set -> set -> set -> set -> prop := fun X Tx A B =>
  closure_of X Tx A :/\: B = Empty /\ A :/\: closure_of X Tx B = Empty.

(** helper: completely normal predicate **)
Definition completely_normal_space : set -> set -> prop := fun X Tx =>
  normal_space X Tx /\
  (forall A B:set, separated_subsets X Tx A B -> exists U V:set,
      open_in X Tx U /\ open_in X Tx V /\ A c= U /\ B c= V /\ U :/\: V = Empty).

(** helper: linear continuum predicate (order topology with least upper bound property) **)
Definition linear_continuum : set -> set -> prop := fun X Tx =>
  (** FIXED: Use `order_rel X` (the order relation used by `order_topology X`), not an unrelated existential relation. **)
  Tx = order_topology X /\
  (forall A:set, A c= X -> A <> Empty ->
    (exists upper:set, upper :e X /\ forall a:set, a :e A -> order_rel X a upper) ->
    exists lub:set, lub :e X /\
      (forall a:set, a :e A -> order_rel X a lub \/ a = lub) /\
      (forall bound:set, bound :e X ->
        (forall a:set, a :e A -> order_rel X a bound \/ a = bound) ->
        order_rel X lub bound \/ lub = bound)).

(** from 30 Exercise 1a: one-point sets are G_delta in first-countable T1 **)
(** LATEX VERSION: In a first-countable T space, every one-point set is a G_ set. **)
Theorem ex30_1a_onepoint_Gdelta_firstcountable_T1 : forall X Tx x:set,
  first_countable_space X Tx ->
  T1_space X Tx ->
  x :e X ->
  Gdelta_in X Tx (Sing x).
let X Tx x.
assume Hfc: first_countable_space X Tx.
assume HT1: T1_space X Tx.
assume HxX: x :e X.
prove Gdelta_in X Tx (Sing x).
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x0:set, x0 :e X -> countable_basis_at X Tx x0)
               Hfc). }
claim Hcountbas: forall x0:set, x0 :e X -> countable_basis_at X Tx x0.
{ exact (andER (topology_on X Tx)
               (forall x0:set, x0 :e X -> countable_basis_at X Tx x0)
               Hfc). }
claim Hcbx: countable_basis_at X Tx x.
{ exact (Hcountbas x HxX). }
claim HexB: exists B:set,
  B c= Tx /\ countable_set B /\
  (forall b:set, b :e B -> x :e b) /\
  (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e B /\ b c= U).
{ exact (andER (topology_on X Tx /\ x :e X)
               (exists B:set,
                 B c= Tx /\ countable_set B /\
                 (forall b:set, b :e B -> x :e b) /\
                 (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e B /\ b c= U))
               Hcbx). }
set B := Eps_i (fun B0:set =>
  B0 c= Tx /\ countable_set B0 /\
  (forall b:set, b :e B0 -> x :e b) /\
  (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e B0 /\ b c= U)).
claim HBprop:
  B c= Tx /\ countable_set B /\
  (forall b:set, b :e B -> x :e b) /\
  (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e B /\ b c= U).
{ exact (Eps_i_ex (fun B0:set =>
           B0 c= Tx /\ countable_set B0 /\
           (forall b:set, b :e B0 -> x :e b) /\
           (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e B0 /\ b c= U))
         HexB). }
claim HB123: ((B c= Tx /\ countable_set B) /\ (forall b:set, b :e B -> x :e b)).
{ exact (andEL ((B c= Tx /\ countable_set B) /\ (forall b:set, b :e B -> x :e b))
               (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e B /\ b c= U)
               HBprop). }
claim HBrefine: forall U:set, U :e Tx -> x :e U -> exists b:set, b :e B /\ b c= U.
{ exact (andER ((B c= Tx /\ countable_set B) /\ (forall b:set, b :e B -> x :e b))
               (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e B /\ b c= U)
               HBprop). }
claim HB12: (B c= Tx /\ countable_set B).
{ exact (andEL (B c= Tx /\ countable_set B)
               (forall b:set, b :e B -> x :e b)
               HB123). }
claim HBx: forall b:set, b :e B -> x :e b.
{ exact (andER (B c= Tx /\ countable_set B)
               (forall b:set, b :e B -> x :e b)
               HB123). }
claim HBsub: B c= Tx.
{ exact (andEL (B c= Tx) (countable_set B) HB12). }
claim HBcount: countable_set B.
{ exact (andER (B c= Tx) (countable_set B) HB12). }

prove exists Fam:set, countable_set Fam /\ (forall U :e Fam, open_in X Tx U) /\ intersection_over_family X Fam = Sing x.
witness B.
apply andI.
- prove countable_set B /\ (forall U :e B, open_in X Tx U).
  apply andI.
  - exact HBcount.
  - let U. assume HU: U :e B.
    prove topology_on X Tx /\ U :e Tx.
    apply andI.
    + exact HTx.
    + apply HBsub. exact HU.
- apply set_ext.
    + let z. assume Hz: z :e intersection_over_family X B.
      prove z :e Sing x.
      claim HzX: z :e X.
      { exact (SepE1 X (fun z0:set => forall U:set, U :e B -> z0 :e U) z Hz). }
      claim Hzall: forall U:set, U :e B -> z :e U.
      { exact (SepE2 X (fun z0:set => forall U:set, U :e B -> z0 :e U) z Hz). }
      apply xm (z = x).
      - assume Hzx: z = x.
        rewrite Hzx.
        exact (SingI x).
      - assume Hzneq: z <> x.
        apply FalseE.
        claim HsubZ: {z} c= X.
        { exact (singleton_subset z X HzX). }
        claim Hzfin: finite {z}.
        { exact (Sing_finite z). }
        claim Hzclosed: closed_in X Tx {z}.
        { exact (T1_space_finite_closed X Tx {z} HT1 HsubZ Hzfin). }
        set Uc := X :\: {z}.
        claim HUcopen: open_in X Tx Uc.
        { exact (open_of_closed_complement X Tx {z} Hzclosed). }
        claim HUcTx: Uc :e Tx.
        { exact (open_in_elem X Tx Uc HUcopen). }
        claim Hxnotz: x /:e {z}.
        { assume Hxz: x :e {z}.
          claim HxzEq: x = z.
          { exact (SingE z x Hxz). }
          claim HzxEq: z = x.
          { rewrite HxzEq. reflexivity. }
          exact (Hzneq HzxEq). }
        claim HxUc: x :e Uc.
        { exact (setminusI X {z} x HxX Hxnotz). }
        claim Hexb: exists b:set, b :e B /\ b c= Uc.
        { exact (HBrefine Uc HUcTx HxUc). }
        set b0 := Eps_i (fun b:set => b :e B /\ b c= Uc).
        claim Hb0prop: b0 :e B /\ b0 c= Uc.
        { exact (Eps_i_ex (fun b:set => b :e B /\ b c= Uc) Hexb). }
        claim Hb0B: b0 :e B.
        { exact (andEL (b0 :e B) (b0 c= Uc) Hb0prop). }
        claim Hb0sub: b0 c= Uc.
        { exact (andER (b0 :e B) (b0 c= Uc) Hb0prop). }
        claim Hzz: z :e {z}.
        { exact (SingI z). }
        claim HznotUc: z /:e Uc.
        { assume HzUc: z :e Uc.
          claim HznotZ: z /:e {z}.
          { exact (setminusE2 X {z} z HzUc). }
          exact (HznotZ Hzz). }
        claim Hznotb0: z /:e b0.
        { assume Hzb: z :e b0.
          claim HzUc: z :e Uc.
          { apply Hb0sub. exact Hzb. }
          exact (HznotUc HzUc). }
        claim Hzb0: z :e b0.
        { exact (Hzall b0 Hb0B). }
        exact (Hznotb0 Hzb0).
    + let z. assume Hz: z :e Sing x.
      prove z :e intersection_over_family X B.
      claim HzEq: z = x.
      { exact (SingE x z Hz). }
      claim HdefInt: intersection_over_family X B =
        {z0 :e X|forall U:set, U :e B -> z0 :e U}.
      { reflexivity. }
      rewrite HdefInt.
      apply (SepI X (fun z0:set => forall U:set, U :e B -> z0 :e U) z).
      - rewrite HzEq. exact HxX.
      - let U. assume HU: U :e B.
        rewrite HzEq.
        exact (HBx U HU).
Qed.

(** from 30 Exercise 1b: space with G_delta points but not first-countable **)
(** LATEX VERSION: There exists a space where every one-point set is G_ but which doesn't satisfy the first countability axiom. **)
Theorem ex30_1b_Gdelta_not_firstcountable_exists :
  exists X:set, exists Tx:set,
    topology_on X Tx /\
    (forall x:set, x :e X -> Gdelta_in X Tx (Sing x)) /\
    ~ first_countable_space X Tx.
admit.
Qed.
(** from 30 Exercise 2: every basis contains countable basis when space has one **)
(** LATEX VERSION: If X has a countable basis, then every basis for X contains a countable basis. **)
Theorem ex30_2_basis_contains_countable : forall X Tx:set, forall Basis:set,
  second_countable_space X Tx ->
  basis_on X Basis ->
  exists CountableSub:set,
    CountableSub c= Basis /\
    countable CountableSub /\
    basis_on X CountableSub.
admit.
Qed.
(** from 30 Exercise 3: uncountable subset has uncountably many limit points **)
(** LATEX VERSION: If X has countable basis and A is uncountable subset, then uncountably many points of A are limit points. **)
(** FIXED: Use limit_point_of X Tx A x (space, topology, set, point), not a permuted argument order. **) 
Theorem ex30_3_uncountably_many_limit_points : forall X Tx A:set,
  second_countable_space X Tx ->
  A c= X ->
  ~ countable A ->
  ~ countable {x :e A | limit_point_of X Tx A x}.
admit.
Qed.
(** from 30 Exercise 4: compact metrizable implies second countable **)
(** LATEX VERSION: Every compact metrizable space has a countable basis. **)
Theorem ex30_4_compact_metrizable_second_countable : forall X Tx d:set,
  compact_space X Tx ->
  metrizable X Tx ->
  metric_on X d ->
  Tx = metric_topology X d ->
  second_countable_space X Tx.
admit.
Qed.
(** from 30 Exercise 5a: metrizable with countable dense has countable basis **)
(** LATEX VERSION: Every metrizable space with a countable dense subset has a countable basis. **)
Theorem ex30_5a_metrizable_countable_dense_second_countable : forall X Tx:set,
  metrizable X Tx ->
  (exists D:set, D c= X /\ countable D /\ dense_in D X Tx) ->
  second_countable_space X Tx.
admit.
Qed.

(** from 30 Exercise 5b: metrizable Lindelof has countable basis **)
(** LATEX VERSION: Every metrizable Lindelf space has a countable basis. **)
Theorem ex30_5b_metrizable_Lindelof_second_countable : forall X Tx:set,
  metrizable X Tx ->
  Lindelof_space X Tx ->
  second_countable_space X Tx.
admit.
Qed.
(** from 30 Exercise 6a: R_l not metrizable **)
(** LATEX VERSION: The Sorgenfrey line _ is not metrizable. **)
Theorem ex30_6a_Rl_not_metrizable :
  ~ metrizable R R_lower_limit_topology.
admit.
Qed.

(** from 30 Exercise 6b: ordered square not metrizable **)
(** LATEX VERSION: The ordered square is not metrizable. **)
Theorem ex30_6b_ordered_square_not_metrizable :
  ~ metrizable ordered_square ordered_square_topology.
admit.
Qed.
(** from 30 Exercise 7: countability axioms for S_Omega and Sbar_Omega **)
(** LATEX VERSION: Determine which countability axioms S_ and S_ satisfy. **)
(** Uses the existing SOmega_topology and SbarOmega_topology defined earlier in this section. **)
Theorem ex30_7_SOmega_Sbar_Omega_countability :
  (first_countable_space S_Omega SOmega_topology /\
   second_countable_space S_Omega SOmega_topology /\
   Lindelof_space S_Omega SOmega_topology /\
   (exists D:set, D c= S_Omega /\ countable D /\ dense_in D S_Omega SOmega_topology)) /\
  (first_countable_space Sbar_Omega SbarOmega_topology /\
   ~ second_countable_space Sbar_Omega SbarOmega_topology /\
   ~ Lindelof_space Sbar_Omega SbarOmega_topology /\
   ~ (exists D:set, D c= Sbar_Omega /\ countable D /\ dense_in D Sbar_Omega SbarOmega_topology)).
admit.
Qed.
(** from 30 Exercise 8: countability axioms for R^omega uniform topology **)
(** LATEX VERSION: Determine which countability axioms R^ satisfies in the uniform topology. **)
Theorem ex30_8_Romega_uniform_countability :
  first_countable_space real_sequences uniform_topology /\
  ~ second_countable_space real_sequences uniform_topology /\
  ~ Lindelof_space real_sequences uniform_topology /\
  ~ (exists D:set, D c= real_sequences /\ countable D /\ dense_in D real_sequences uniform_topology).
admit.
Qed.
(** from 30 Exercise 9a: closed subspace of Lindelof is Lindelof **)
(** LATEX VERSION: If A is closed in Lindelf space X, then A is Lindelf. **)
Theorem ex30_9a_closed_Lindelof : forall X Tx A:set,
  Lindelof_space X Tx ->
  closed_in X Tx A ->
  Lindelof_space A (subspace_topology X Tx A).
admit.
Qed.

(** from 30 Exercise 9b: dense subspace need not have countable dense subset **)
(** LATEX VERSION: If X has countable dense subset, dense subspace A need not have one. **)
Theorem ex30_9b_dense_not_countable_dense :
  exists X:set, exists Tx:set, exists A:set,
    (exists D:set, D c= X /\ countable D /\ dense_in D X Tx) /\
    dense_in A X Tx /\
    ~ (exists DA:set, DA c= A /\ countable DA /\ dense_in DA A (subspace_topology X Tx A)).
admit.
Qed.

(** from 30 Exercise 10: countable product has countable dense if factors do **)
(** LATEX VERSION: If X is countable product of spaces with countable dense subsets, then X has one. **)
Theorem ex30_10_product_countable_dense : forall Idx:set, forall Fam:set,
  countable Idx ->
  (forall i:set, i :e Idx ->
    exists Xi:set, exists Txi:set, exists Di:set,
      apply_fun Fam i = (Xi, Txi) /\
      Di c= Xi /\ countable Di /\ dense_in Di Xi Txi) ->
  exists D:set,
    D c= product_space Idx Fam /\
    countable D /\
    dense_in D (product_space Idx Fam) (product_topology_full Idx Fam).
admit.
Qed.

(** from 30 Exercise 11a: continuous image of Lindelof is Lindelof **)
(** LATEX VERSION: If f:XY continuous and X Lindelf, then f(X) is Lindelf. **)
(** FIXED: Use image_of f X for the image set; apply_fun is for elements. **) 
Theorem ex30_11a_image_Lindelof : forall X Tx Y Ty f:set,
  Lindelof_space X Tx ->
  continuous_map X Tx Y Ty f ->
  Lindelof_space (image_of f X) (subspace_topology Y Ty (image_of f X)).
admit.
Qed.

(** from 30 Exercise 11b: continuous image of separable is separable **)
(** LATEX VERSION: If f:XY continuous and X has countable dense subset, then f(X) does too. **)
(** FIXED: apply_fun f X should be image_of f X (same error pattern). **)
Theorem ex30_11b_image_countable_dense : forall X Tx Y Ty f:set,
  (exists D:set, D c= X /\ countable D /\ dense_in D X Tx) ->
  continuous_map X Tx Y Ty f ->
  exists Df:set,
    Df c= (image_of f X) /\
    countable Df /\
    dense_in Df (image_of f X) (subspace_topology Y Ty (image_of f X)).
admit.
Qed.

(** from 30 Exercise 12a: open continuous map preserves first countability **)
(** LATEX VERSION: If f:XY is continuous open and X first-countable, then f(X) is too. **)
(** FIXED: apply_fun f X should be image_of f X (same error pattern). **)
Theorem ex30_12a_open_map_first_countable : forall X Tx Y Ty f:set,
  first_countable_space X Tx ->
  continuous_map X Tx Y Ty f ->
  open_map X Tx Y Ty f ->
  first_countable_space (image_of f X) (subspace_topology Y Ty (image_of f X)).
admit.
Qed.

(** from 30 Exercise 12b: open continuous map preserves second countability **)
(** LATEX VERSION: If f:XY is continuous open and X second-countable, then f(X) is too. **)
(** FIXED: apply_fun f X should be image_of f X (same error pattern). **)
Theorem ex30_12b_open_map_second_countable : forall X Tx Y Ty f:set,
  second_countable_space X Tx ->
  continuous_map X Tx Y Ty f ->
  open_map X Tx Y Ty f ->
  second_countable_space (image_of f X) (subspace_topology Y Ty (image_of f X)).
admit.
Qed.
(** from 30 Exercise 13: disjoint open sets countable when dense countable **)
(** LATEX VERSION: If X has countable dense subset, every collection of disjoint open sets in X is countable. **)
Theorem ex30_13_disjoint_open_sets_countable : forall X Tx:set,
  (exists D:set, D c= X /\ countable D /\ dense_in D X Tx) ->
  forall Fam:set,
    (forall U:set, U :e Fam -> open_in X Tx U) ->
    (forall U V:set, U :e Fam -> V :e Fam -> U <> V -> U :/\: V = Empty) ->
    countable Fam.
admit.
Qed.
(** from 30 Exercise 14: product of Lindelof with compact is Lindelof **)
(** LATEX VERSION: If X is Lindelf and Y is compact, then X  Y is Lindelf. **)
Theorem ex30_14_product_Lindelof_compact : forall X Tx Y Ty:set,
  Lindelof_space X Tx ->
  compact_space Y Ty ->
  Lindelof_space (setprod X Y) (product_topology X Tx Y Ty).
admit.
Qed.
(** from 30 Exercise 15: C(I,R) uniform topology countable dense subset **)
(** LATEX VERSION: C(I,) with uniform metric has countable dense subset and countable basis. **)
(** stub: this metric is meant to be the sup metric on C(I,R) **)
Definition uniform_metric_C_I_R : set := Eps_i (fun d:set => metric_on C_I_R d).
Definition uniform_topology_C_I_R : set := metric_topology C_I_R uniform_metric_C_I_R.
Theorem ex30_15_CI_has_countable_dense_uniform :
  exists D:set,
    D c= C_I_R /\ countable D /\ dense_in D C_I_R uniform_topology_C_I_R /\
    second_countable_space C_I_R uniform_topology_C_I_R.
admit.
Qed.
(** from 30 Exercise 16a: product R^I where I=[0,1] has countable dense subset **)
(** LATEX VERSION: The product space ^I, where I=[0,1], has a countable dense subset. **)
Theorem ex30_16a_product_RI_countable_dense :
  exists D:set,
    D c= product_space unit_interval (const_space_family unit_interval R R_standard_topology) /\
    countable D /\
    dense_in D
      (product_space unit_interval (const_space_family unit_interval R R_standard_topology))
      (product_topology_full unit_interval (const_space_family unit_interval R R_standard_topology)).
admit.
Qed.

(** from 30 Exercise 16b: large product does not have countable dense subset **)
(** LATEX VERSION: If J has cardinality > (), then ^J does not have countable dense subset. **)
Theorem ex30_16b_large_product_no_countable_dense : forall J:set,
  atleastp (Power omega) J ->
  ~ equip J (Power omega) ->
  ~ (exists D:set,
      D c= product_space J (const_space_family J R R_standard_topology) /\
      countable D /\
      dense_in D
        (product_space J (const_space_family J R R_standard_topology))
        (product_topology_full J (const_space_family J R R_standard_topology))).
admit.
Qed.
(** from 30 Exercise 17: Romega box topology countability axioms **)
(** LATEX VERSION: ^ with box topology, subspace ^ (rationals ending in infinite 0s): which countability axioms? **)
(** Define Q_infty as rational sequences eventually equal to 0. **)
Definition Q_infty : set :=
  {f :e R_omega_space |
    (forall n:set, n :e omega -> apply_fun f n :e rational_numbers) /\
    (exists n0:set, n0 :e omega /\
      forall m:set, m :e omega -> ~(m :e n0) -> apply_fun f m = 0)}.
Definition Q_infty_topology : set :=
  subspace_topology R_omega_space R_omega_box_topology Q_infty.
Theorem ex30_17_Romega_box_countability :
  (first_countable_space Q_infty Q_infty_topology \/ ~ first_countable_space Q_infty Q_infty_topology) /\
  (second_countable_space Q_infty Q_infty_topology \/ ~ second_countable_space Q_infty Q_infty_topology) /\
  (Lindelof_space Q_infty Q_infty_topology \/ ~ Lindelof_space Q_infty Q_infty_topology) /\
  ((exists D:set, D c= Q_infty /\ countable D /\ dense_in D Q_infty Q_infty_topology) \/
   ~ (exists D:set, D c= Q_infty /\ countable D /\ dense_in D Q_infty Q_infty_topology)).
apply andI.
- prove ((first_countable_space Q_infty Q_infty_topology \/ ~ first_countable_space Q_infty Q_infty_topology) /\
        (second_countable_space Q_infty Q_infty_topology \/ ~ second_countable_space Q_infty Q_infty_topology))
       /\ (Lindelof_space Q_infty Q_infty_topology \/ ~ Lindelof_space Q_infty Q_infty_topology).
  apply andI.
  - prove (first_countable_space Q_infty Q_infty_topology \/ ~ first_countable_space Q_infty Q_infty_topology) /\
          (second_countable_space Q_infty Q_infty_topology \/ ~ second_countable_space Q_infty Q_infty_topology).
    apply andI.
    + exact (xm (first_countable_space Q_infty Q_infty_topology)).
    + exact (xm (second_countable_space Q_infty Q_infty_topology)).
  - exact (xm (Lindelof_space Q_infty Q_infty_topology)).
- exact (xm (exists D:set, D c= Q_infty /\ countable D /\ dense_in D Q_infty Q_infty_topology)).
Qed.
(** from 30 Exercise 18: first-countable topological group with dense/Lindelof implies countable basis **)
(** LATEX VERSION: If G is first-countable topological group with countable dense subset or Lindelf, then G has countable basis. **)
Theorem ex30_18_first_countable_group_countable_basis : forall G Tg:set,
  topological_group G Tg ->
  first_countable_space G Tg ->
  ((exists D:set, D c= G /\ countable D /\ dense_in D G Tg) \/ Lindelof_space G Tg) ->
  second_countable_space G Tg.
admit.
Qed.

(** from 31 Exercise 1: regular implies disjoint closures of neighborhoods **)
(** LATEX VERSION: If X is regular, every pair of points have neighborhoods whose closures are disjoint. **)
Theorem ex31_1_regular_disjoint_closure_neighborhoods : forall X Tx x y:set,
  regular_space X Tx ->
  x :e X ->
  y :e X ->
  x <> y ->
  exists U V:set,
    open_in X Tx U /\ open_in X Tx V /\
    x :e U /\ y :e V /\
    closure_of X Tx U :/\: closure_of X Tx V = Empty.
let X Tx x y.
assume Hreg: regular_space X Tx.
assume Hx: x :e X.
assume Hy: y :e X.
assume Hneq: x <> y.
prove exists U V:set, open_in X Tx U /\ open_in X Tx V /\ x :e U /\ y :e V /\ closure_of X Tx U :/\: closure_of X Tx V = Empty.
claim HT1: one_point_sets_closed X Tx.
{ exact (andEL (one_point_sets_closed X Tx)
               (forall x:set, x :e X ->
                 forall F:set, closed_in X Tx F -> x /:e F ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty)
               Hreg). }
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x:set, x :e X -> closed_in X Tx {x})
               HT1). }
claim Hsing: forall t:set, t :e X -> closed_in X Tx {t}.
{ exact (andER (topology_on X Tx)
               (forall x:set, x :e X -> closed_in X Tx {x})
               HT1). }
claim HSepReg:
  forall t:set, t :e X ->
    forall F:set, closed_in X Tx F -> t /:e F ->
      exists U V:set, U :e Tx /\ V :e Tx /\ t :e U /\ F c= V /\ U :/\: V = Empty.
{ exact (andER (one_point_sets_closed X Tx)
               (forall x:set, x :e X ->
                 forall F:set, closed_in X Tx F -> x /:e F ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty)
               Hreg). }

(** Step 1: separate x from the closed singleton {y}. **)
claim Hcly: closed_in X Tx {y}.
{ exact (Hsing y Hy). }
claim Hxnoty: x /:e {y}.
{ assume Hxy: x :e {y}.
  claim Heq: x = y.
  { exact (SingE y x Hxy). }
  exact (Hneq Heq). }
claim Hex1: exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ {y} c= V /\ U :/\: V = Empty.
{ exact (HSepReg x Hx {y} Hcly Hxnoty). }
set U0 := Eps_i (fun U:set => exists V:set, U :e Tx /\ V :e Tx /\ x :e U /\ {y} c= V /\ U :/\: V = Empty).
claim HU0ex: exists V:set, U0 :e Tx /\ V :e Tx /\ x :e U0 /\ {y} c= V /\ U0 :/\: V = Empty.
{ exact (Eps_i_ex (fun U:set => exists V:set, U :e Tx /\ V :e Tx /\ x :e U /\ {y} c= V /\ U :/\: V = Empty) Hex1). }
set V0 := Eps_i (fun V:set => U0 :e Tx /\ V :e Tx /\ x :e U0 /\ {y} c= V /\ U0 :/\: V = Empty).
claim HV0prop: U0 :e Tx /\ V0 :e Tx /\ x :e U0 /\ {y} c= V0 /\ U0 :/\: V0 = Empty.
{ exact (Eps_i_ex (fun V:set => U0 :e Tx /\ V :e Tx /\ x :e U0 /\ {y} c= V /\ U0 :/\: V = Empty) HU0ex). }
claim H1234: (((U0 :e Tx /\ V0 :e Tx) /\ x :e U0) /\ {y} c= V0).
{ exact (andEL ((((U0 :e Tx /\ V0 :e Tx) /\ x :e U0) /\ {y} c= V0))
               (U0 :/\: V0 = Empty)
               HV0prop). }
claim Hdisj0: U0 :/\: V0 = Empty.
{ exact (andER ((((U0 :e Tx /\ V0 :e Tx) /\ x :e U0) /\ {y} c= V0))
               (U0 :/\: V0 = Empty)
               HV0prop). }
claim H123: ((U0 :e Tx /\ V0 :e Tx) /\ x :e U0).
{ exact (andEL ((U0 :e Tx /\ V0 :e Tx) /\ x :e U0)
               ({y} c= V0)
               H1234). }
claim H12: (U0 :e Tx /\ V0 :e Tx).
{ exact (andEL (U0 :e Tx /\ V0 :e Tx) (x :e U0) H123). }
claim HU0Tx: U0 :e Tx.
{ exact (andEL (U0 :e Tx) (V0 :e Tx) H12). }
claim HV0Tx: V0 :e Tx.
{ exact (andER (U0 :e Tx) (V0 :e Tx) H12). }
claim HxU0: x :e U0.
{ exact (andER (U0 :e Tx /\ V0 :e Tx) (x :e U0) H123). }
claim HysubV0: {y} c= V0.
{ exact (andER ((U0 :e Tx /\ V0 :e Tx) /\ x :e U0) ({y} c= V0) H1234). }
claim HyV0: y :e V0.
{ apply HysubV0. exact (SingI y). }

(** Step 2: show y is not in closure(U0). **)
claim Hcliffy: y :e closure_of X Tx U0 <-> (forall W :e Tx, y :e W -> W :/\: U0 <> Empty).
{ exact (closure_characterization X Tx U0 y HTx Hy). }
claim HyNotClU0: y /:e closure_of X Tx U0.
  { assume HyCl: y :e closure_of X Tx U0.
    claim Hneigh: forall W :e Tx, y :e W -> W :/\: U0 <> Empty.
  { exact (iffEL (y :e closure_of X Tx U0)
                 (forall W :e Tx, y :e W -> W :/\: U0 <> Empty)
                 Hcliffy HyCl). }
  claim Hempty: V0 :/\: U0 = Empty.
  { apply Empty_Subq_eq.
    let z. assume Hz: z :e V0 :/\: U0.
    prove z :e Empty.
    claim HzV: z :e V0.
    { exact (binintersectE1 V0 U0 z Hz). }
    claim HzU: z :e U0.
    { exact (binintersectE2 V0 U0 z Hz). }
    claim HzUV: z :e U0 :/\: V0.
    { exact (binintersectI U0 V0 z HzU HzV). }
    claim HzE: z :e Empty.
    { rewrite <- Hdisj0. exact HzUV. }
    exact HzE. }
  claim Hcontr: V0 :/\: U0 <> Empty.
  { exact (Hneigh V0 HV0Tx HyV0). }
  apply FalseE.
  apply FalseE.
  apply FalseE.
  exact (Hcontr Hempty). }

(** Step 3: separate y from the closed set closure(U0). **)
claim HTsub: Tx c= Power X.
{ exact (topology_subset_axiom X Tx HTx). }
claim HU0sub: U0 c= X.
{ exact (PowerE X U0 (HTsub U0 HU0Tx)). }
claim HclU0: closed_in X Tx (closure_of X Tx U0).
{ exact (closure_is_closed X Tx U0 HTx HU0sub). }
claim Hex2: exists U V:set,
  U :e Tx /\ V :e Tx /\ y :e U /\ closure_of X Tx U0 c= V /\ U :/\: V = Empty.
{ exact (HSepReg y Hy (closure_of X Tx U0) HclU0 HyNotClU0). }
set U1 := Eps_i (fun U:set => exists V:set,
  U :e Tx /\ V :e Tx /\ y :e U /\ closure_of X Tx U0 c= V /\ U :/\: V = Empty).
claim HU1ex: exists V:set,
  U1 :e Tx /\ V :e Tx /\ y :e U1 /\ closure_of X Tx U0 c= V /\ U1 :/\: V = Empty.
{ exact (Eps_i_ex (fun U:set => exists V:set,
    U :e Tx /\ V :e Tx /\ y :e U /\ closure_of X Tx U0 c= V /\ U :/\: V = Empty) Hex2). }
set V1 := Eps_i (fun V:set => U1 :e Tx /\ V :e Tx /\ y :e U1 /\ closure_of X Tx U0 c= V /\ U1 :/\: V = Empty).
claim HV1prop: U1 :e Tx /\ V1 :e Tx /\ y :e U1 /\ closure_of X Tx U0 c= V1 /\ U1 :/\: V1 = Empty.
{ exact (Eps_i_ex (fun V:set => U1 :e Tx /\ V :e Tx /\ y :e U1 /\ closure_of X Tx U0 c= V /\ U1 :/\: V = Empty)
                  HU1ex). }
claim H1234b: (((U1 :e Tx /\ V1 :e Tx) /\ y :e U1) /\ closure_of X Tx U0 c= V1).
{ exact (andEL ((((U1 :e Tx /\ V1 :e Tx) /\ y :e U1) /\ closure_of X Tx U0 c= V1))
               (U1 :/\: V1 = Empty)
               HV1prop). }
claim Hdisj1: U1 :/\: V1 = Empty.
{ exact (andER ((((U1 :e Tx /\ V1 :e Tx) /\ y :e U1) /\ closure_of X Tx U0 c= V1))
               (U1 :/\: V1 = Empty)
               HV1prop). }
claim H123b: ((U1 :e Tx /\ V1 :e Tx) /\ y :e U1).
{ exact (andEL ((U1 :e Tx /\ V1 :e Tx) /\ y :e U1)
               (closure_of X Tx U0 c= V1)
               H1234b). }
claim H12b: (U1 :e Tx /\ V1 :e Tx).
{ exact (andEL (U1 :e Tx /\ V1 :e Tx) (y :e U1) H123b). }
claim HU1Tx: U1 :e Tx.
{ exact (andEL (U1 :e Tx) (V1 :e Tx) H12b). }
claim HV1Tx: V1 :e Tx.
{ exact (andER (U1 :e Tx) (V1 :e Tx) H12b). }
claim HyU1: y :e U1.
{ exact (andER (U1 :e Tx /\ V1 :e Tx) (y :e U1) H123b). }
claim HclU0subV1: closure_of X Tx U0 c= V1.
{ exact (andER ((U1 :e Tx /\ V1 :e Tx) /\ y :e U1) (closure_of X Tx U0 c= V1) H1234b). }

(** Step 4: closures of U0 and U1 are disjoint. **)
claim Hcliff: forall z:set, z :e X ->
  (z :e closure_of X Tx U1 <-> (forall W :e Tx, z :e W -> W :/\: U1 <> Empty)).
{ let z. assume HzX: z :e X.
  exact (closure_characterization X Tx U1 z HTx HzX). }
claim Hcldisj: closure_of X Tx U0 :/\: closure_of X Tx U1 = Empty.
{ apply Empty_Subq_eq.
  let z. assume Hz: z :e closure_of X Tx U0 :/\: closure_of X Tx U1.
  prove z :e Empty.
  claim Hzcl0: z :e closure_of X Tx U0.
  { exact (binintersectE1 (closure_of X Tx U0) (closure_of X Tx U1) z Hz). }
  claim Hzcl1: z :e closure_of X Tx U1.
  { exact (binintersectE2 (closure_of X Tx U0) (closure_of X Tx U1) z Hz). }
  claim HzX: z :e X.
  { exact (SepE1 X (fun z0:set => forall W:set, W :e Tx -> z0 :e W -> W :/\: U0 <> Empty) z Hzcl0). }
  claim HzV1: z :e V1.
  { apply HclU0subV1. exact Hzcl0. }
  claim Hneigh: forall W :e Tx, z :e W -> W :/\: U1 <> Empty.
  { exact (iffEL (z :e closure_of X Tx U1)
                 (forall W :e Tx, z :e W -> W :/\: U1 <> Empty)
                 (Hcliff z HzX) Hzcl1). }
  claim Hcontr: V1 :/\: U1 <> Empty.
  { exact (Hneigh V1 HV1Tx HzV1). }
  claim Hempty: V1 :/\: U1 = Empty.
  { apply Empty_Subq_eq.
    let w. assume Hw: w :e V1 :/\: U1.
    prove w :e Empty.
    claim HwV: w :e V1.
    { exact (binintersectE1 V1 U1 w Hw). }
    claim HwU: w :e U1.
    { exact (binintersectE2 V1 U1 w Hw). }
    claim HwUV: w :e U1 :/\: V1.
    { exact (binintersectI U1 V1 w HwU HwV). }
	    claim HwE: w :e Empty.
	    { rewrite <- Hdisj1. exact HwUV. }
	    exact HwE. }
	  apply FalseE.
	  exact (Hcontr Hempty). }

witness U0.
witness U1.
apply and5I.
- exact (andI (topology_on X Tx) (U0 :e Tx) HTx HU0Tx).
- exact (andI (topology_on X Tx) (U1 :e Tx) HTx HU1Tx).
- exact HxU0.
- exact HyU1.
- exact Hcldisj.
Qed.
(** from 31 Exercise 2: normal implies disjoint closures for closed sets **)
(** LATEX VERSION: If X is normal, every pair of disjoint closed sets have neighborhoods whose closures are disjoint. **)
Theorem ex31_2_normal_disjoint_closure_neighborhoods : forall X Tx A B:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  closed_in X Tx B ->
  A :/\: B = Empty ->
  exists U V:set,
    open_in X Tx U /\ open_in X Tx V /\
    A c= U /\ B c= V /\
    closure_of X Tx U :/\: closure_of X Tx V = Empty.
let X Tx A B.
assume Hnorm: normal_space X Tx.
assume HA: closed_in X Tx A.
assume HB: closed_in X Tx B.
assume Hdisj: A :/\: B = Empty.
prove exists U V:set, open_in X Tx U /\ open_in X Tx V /\ A c= U /\ B c= V /\ closure_of X Tx U :/\: closure_of X Tx V = Empty.
claim HT1: one_point_sets_closed X Tx.
{ exact (andEL (one_point_sets_closed X Tx)
               (forall A0 B0:set, closed_in X Tx A0 -> closed_in X Tx B0 -> A0 :/\: B0 = Empty ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ A0 c= U /\ B0 c= V /\ U :/\: V = Empty)
               Hnorm). }
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x:set, x :e X -> closed_in X Tx {x})
               HT1). }
claim HSepNorm:
  forall A0 B0:set, closed_in X Tx A0 -> closed_in X Tx B0 -> A0 :/\: B0 = Empty ->
    exists U V:set, U :e Tx /\ V :e Tx /\ A0 c= U /\ B0 c= V /\ U :/\: V = Empty.
{ exact (andER (one_point_sets_closed X Tx)
               (forall A0 B0:set, closed_in X Tx A0 -> closed_in X Tx B0 -> A0 :/\: B0 = Empty ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ A0 c= U /\ B0 c= V /\ U :/\: V = Empty)
               Hnorm). }

(** Step 1: separate A and B by disjoint open sets U0 and V0. **)
claim Hex1: exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.
{ exact (HSepNorm A B HA HB Hdisj). }
set U0 := Eps_i (fun U:set => exists V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty).
claim HU0ex: exists V:set, U0 :e Tx /\ V :e Tx /\ A c= U0 /\ B c= V /\ U0 :/\: V = Empty.
{ exact (Eps_i_ex (fun U:set => exists V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty) Hex1). }
set V0 := Eps_i (fun V:set => U0 :e Tx /\ V :e Tx /\ A c= U0 /\ B c= V /\ U0 :/\: V = Empty).
claim HV0prop: U0 :e Tx /\ V0 :e Tx /\ A c= U0 /\ B c= V0 /\ U0 :/\: V0 = Empty.
{ exact (Eps_i_ex (fun V:set => U0 :e Tx /\ V :e Tx /\ A c= U0 /\ B c= V /\ U0 :/\: V = Empty) HU0ex). }
claim H1234: (((U0 :e Tx /\ V0 :e Tx) /\ A c= U0) /\ B c= V0).
{ exact (andEL ((((U0 :e Tx /\ V0 :e Tx) /\ A c= U0) /\ B c= V0))
               (U0 :/\: V0 = Empty)
               HV0prop). }
claim Hdisj0: U0 :/\: V0 = Empty.
{ exact (andER ((((U0 :e Tx /\ V0 :e Tx) /\ A c= U0) /\ B c= V0))
               (U0 :/\: V0 = Empty)
               HV0prop). }
claim H123: ((U0 :e Tx /\ V0 :e Tx) /\ A c= U0).
{ exact (andEL ((U0 :e Tx /\ V0 :e Tx) /\ A c= U0)
               (B c= V0)
               H1234). }
claim H12: (U0 :e Tx /\ V0 :e Tx).
{ exact (andEL (U0 :e Tx /\ V0 :e Tx) (A c= U0) H123). }
claim HU0Tx: U0 :e Tx.
{ exact (andEL (U0 :e Tx) (V0 :e Tx) H12). }
claim HV0Tx: V0 :e Tx.
{ exact (andER (U0 :e Tx) (V0 :e Tx) H12). }
claim HAsub: A c= U0.
{ exact (andER (U0 :e Tx /\ V0 :e Tx) (A c= U0) H123). }
claim HBsub: B c= V0.
{ exact (andER ((U0 :e Tx /\ V0 :e Tx) /\ A c= U0) (B c= V0) H1234). }

(** Step 2: show B is disjoint from closure(U0). **)
claim HTsub: Tx c= Power X.
{ exact (topology_subset_axiom X Tx HTx). }
claim HU0subX: U0 c= X.
{ exact (PowerE X U0 (HTsub U0 HU0Tx)). }
claim HclU0: closed_in X Tx (closure_of X Tx U0).
{ exact (closure_is_closed X Tx U0 HTx HU0subX). }
claim Hcliff0: forall z:set, z :e X ->
  (z :e closure_of X Tx U0 <-> (forall W :e Tx, z :e W -> W :/\: U0 <> Empty)).
{ let z. assume HzX: z :e X.
  exact (closure_characterization X Tx U0 z HTx HzX). }
claim HclU0_disj_V0: closure_of X Tx U0 :/\: V0 = Empty.
{ apply Empty_Subq_eq.
  let z. assume Hz: z :e closure_of X Tx U0 :/\: V0.
  prove z :e Empty.
  claim Hzcl: z :e closure_of X Tx U0.
  { exact (binintersectE1 (closure_of X Tx U0) V0 z Hz). }
  claim HzV: z :e V0.
  { exact (binintersectE2 (closure_of X Tx U0) V0 z Hz). }
  claim HzX: z :e X.
  { exact (SepE1 X (fun z0:set => forall W:set, W :e Tx -> z0 :e W -> W :/\: U0 <> Empty) z Hzcl). }
  claim Hneigh: forall W :e Tx, z :e W -> W :/\: U0 <> Empty.
  { exact (iffEL (z :e closure_of X Tx U0)
                 (forall W :e Tx, z :e W -> W :/\: U0 <> Empty)
                 (Hcliff0 z HzX) Hzcl). }
  claim Hcontr: V0 :/\: U0 <> Empty.
  { exact (Hneigh V0 HV0Tx HzV). }
  claim Hempty: V0 :/\: U0 = Empty.
  { apply Empty_Subq_eq.
    let w. assume Hw: w :e V0 :/\: U0.
    prove w :e Empty.
    claim HwV: w :e V0.
    { exact (binintersectE1 V0 U0 w Hw). }
    claim HwU: w :e U0.
    { exact (binintersectE2 V0 U0 w Hw). }
    claim HwUV: w :e U0 :/\: V0.
    { exact (binintersectI U0 V0 w HwU HwV). }
    claim HwE: w :e Empty.
    { rewrite <- Hdisj0. exact HwUV. }
    exact HwE. }
  apply FalseE.
  exact (Hcontr Hempty). }
claim HBcldisj: B :/\: closure_of X Tx U0 = Empty.
{ apply Empty_Subq_eq.
  let z. assume Hz: z :e B :/\: closure_of X Tx U0.
  prove z :e Empty.
  claim HzB: z :e B.
  { exact (binintersectE1 B (closure_of X Tx U0) z Hz). }
  claim Hzcl: z :e closure_of X Tx U0.
  { exact (binintersectE2 B (closure_of X Tx U0) z Hz). }
  claim HzV0: z :e V0.
  { apply HBsub. exact HzB. }
  claim HzclV0: z :e closure_of X Tx U0 :/\: V0.
  { exact (binintersectI (closure_of X Tx U0) V0 z Hzcl HzV0). }
  claim HzE: z :e Empty.
  { rewrite <- HclU0_disj_V0. exact HzclV0. }
  exact HzE. }

(** Step 3: separate B from closure(U0), then conclude closures are disjoint. **)
claim Hex2: exists U V:set,
  U :e Tx /\ V :e Tx /\ B c= U /\ closure_of X Tx U0 c= V /\ U :/\: V = Empty.
{ exact (HSepNorm B (closure_of X Tx U0) HB HclU0 HBcldisj). }
set U1 := Eps_i (fun U:set => exists V:set,
  U :e Tx /\ V :e Tx /\ B c= U /\ closure_of X Tx U0 c= V /\ U :/\: V = Empty).
claim HU1ex: exists V:set,
  U1 :e Tx /\ V :e Tx /\ B c= U1 /\ closure_of X Tx U0 c= V /\ U1 :/\: V = Empty.
{ exact (Eps_i_ex (fun U:set => exists V:set,
    U :e Tx /\ V :e Tx /\ B c= U /\ closure_of X Tx U0 c= V /\ U :/\: V = Empty) Hex2). }
set V1 := Eps_i (fun V:set => U1 :e Tx /\ V :e Tx /\ B c= U1 /\ closure_of X Tx U0 c= V /\ U1 :/\: V = Empty).
claim HV1prop: U1 :e Tx /\ V1 :e Tx /\ B c= U1 /\ closure_of X Tx U0 c= V1 /\ U1 :/\: V1 = Empty.
{ exact (Eps_i_ex (fun V:set => U1 :e Tx /\ V :e Tx /\ B c= U1 /\ closure_of X Tx U0 c= V /\ U1 :/\: V = Empty)
                  HU1ex). }
claim H1234b: (((U1 :e Tx /\ V1 :e Tx) /\ B c= U1) /\ closure_of X Tx U0 c= V1).
{ exact (andEL ((((U1 :e Tx /\ V1 :e Tx) /\ B c= U1) /\ closure_of X Tx U0 c= V1))
               (U1 :/\: V1 = Empty)
               HV1prop). }
claim Hdisj1: U1 :/\: V1 = Empty.
{ exact (andER ((((U1 :e Tx /\ V1 :e Tx) /\ B c= U1) /\ closure_of X Tx U0 c= V1))
               (U1 :/\: V1 = Empty)
               HV1prop). }
claim H123b: ((U1 :e Tx /\ V1 :e Tx) /\ B c= U1).
{ exact (andEL ((U1 :e Tx /\ V1 :e Tx) /\ B c= U1)
               (closure_of X Tx U0 c= V1)
               H1234b). }
claim H12b: (U1 :e Tx /\ V1 :e Tx).
{ exact (andEL (U1 :e Tx /\ V1 :e Tx) (B c= U1) H123b). }
claim HU1Tx: U1 :e Tx.
{ exact (andEL (U1 :e Tx) (V1 :e Tx) H12b). }
claim HV1Tx: V1 :e Tx.
{ exact (andER (U1 :e Tx) (V1 :e Tx) H12b). }
claim HBsubU1: B c= U1.
{ exact (andER (U1 :e Tx /\ V1 :e Tx) (B c= U1) H123b). }
claim HclU0subV1: closure_of X Tx U0 c= V1.
{ exact (andER ((U1 :e Tx /\ V1 :e Tx) /\ B c= U1) (closure_of X Tx U0 c= V1) H1234b). }

claim Hcliff1: forall z:set, z :e X ->
  (z :e closure_of X Tx U1 <-> (forall W :e Tx, z :e W -> W :/\: U1 <> Empty)).
{ let z. assume HzX: z :e X.
  exact (closure_characterization X Tx U1 z HTx HzX). }
claim Hcldisj: closure_of X Tx U0 :/\: closure_of X Tx U1 = Empty.
{ apply Empty_Subq_eq.
  let z. assume Hz: z :e closure_of X Tx U0 :/\: closure_of X Tx U1.
  prove z :e Empty.
  claim Hzcl0: z :e closure_of X Tx U0.
  { exact (binintersectE1 (closure_of X Tx U0) (closure_of X Tx U1) z Hz). }
  claim Hzcl1: z :e closure_of X Tx U1.
  { exact (binintersectE2 (closure_of X Tx U0) (closure_of X Tx U1) z Hz). }
  claim HzX: z :e X.
  { exact (SepE1 X (fun z0:set => forall W:set, W :e Tx -> z0 :e W -> W :/\: U0 <> Empty) z Hzcl0). }
  claim HzV1: z :e V1.
  { apply HclU0subV1. exact Hzcl0. }
  claim Hneigh: forall W :e Tx, z :e W -> W :/\: U1 <> Empty.
  { exact (iffEL (z :e closure_of X Tx U1)
                 (forall W :e Tx, z :e W -> W :/\: U1 <> Empty)
                 (Hcliff1 z HzX) Hzcl1). }
  claim Hcontr: V1 :/\: U1 <> Empty.
  { exact (Hneigh V1 HV1Tx HzV1). }
  claim Hempty: V1 :/\: U1 = Empty.
  { apply Empty_Subq_eq.
    let w. assume Hw: w :e V1 :/\: U1.
    prove w :e Empty.
    claim HwV: w :e V1.
    { exact (binintersectE1 V1 U1 w Hw). }
    claim HwU: w :e U1.
    { exact (binintersectE2 V1 U1 w Hw). }
    claim HwUV: w :e U1 :/\: V1.
    { exact (binintersectI U1 V1 w HwU HwV). }
    claim HwE: w :e Empty.
    { rewrite <- Hdisj1. exact HwUV. }
    exact HwE. }
  apply FalseE.
  exact (Hcontr Hempty). }

witness U0.
witness U1.
apply and5I.
- exact (andI (topology_on X Tx) (U0 :e Tx) HTx HU0Tx).
- exact (andI (topology_on X Tx) (U1 :e Tx) HTx HU1Tx).
- exact HAsub.
- exact HBsubU1.
- exact Hcldisj.
Qed.
(** from 31 Exercise 3: every order topology regular **)
(** LATEX VERSION: Every order topology is regular. **)
Theorem ex31_3_order_topology_regular : forall X:set,
  regular_space X (order_topology X).
admit.
Qed.
(** from 31 Exercise 4: comparing finer/coarser separation axioms **)
(** LATEX VERSION: Let X have two topologies T and T', with T'  T. Compare separation properties. **)
Theorem ex31_4_comparison_topologies_separation : forall X Tx Tx':set,
  topology_on X Tx ->
  topology_on X Tx' ->
  Tx c= Tx' ->
  ((Hausdorff_space X Tx -> Hausdorff_space X Tx') /\
   (regular_space X Tx -> Hausdorff_space X Tx') /\
   (normal_space X Tx -> Hausdorff_space X Tx')).
let X Tx Tx'.
assume HTx: topology_on X Tx.
assume HTx': topology_on X Tx'.
assume Hfiner: Tx c= Tx'.
claim Hhaus_finer: Hausdorff_space X Tx -> Hausdorff_space X Tx'.
{ assume HH: Hausdorff_space X Tx.
  prove Hausdorff_space X Tx'.
  claim HSep: forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
    exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
  { exact (andER (topology_on X Tx)
                 (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
                 HH). }
  prove topology_on X Tx' /\
        forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
          exists U V:set, U :e Tx' /\ V :e Tx' /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
  apply andI.
  - exact HTx'.
  - let x1 x2.
    assume Hx1X: x1 :e X.
    assume Hx2X: x2 :e X.
    assume Hneq: x1 <> x2.
    prove exists U V:set, U :e Tx' /\ V :e Tx' /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
    claim Hex: exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
    { exact (HSep x1 x2 Hx1X Hx2X Hneq). }
    set U0 := Eps_i (fun U:set => exists V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty).
    claim HU0ex: exists V:set, U0 :e Tx /\ V :e Tx /\ x1 :e U0 /\ x2 :e V /\ U0 :/\: V = Empty.
    { exact (Eps_i_ex (fun U:set => exists V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty) Hex). }
    set V0 := Eps_i (fun V:set => U0 :e Tx /\ V :e Tx /\ x1 :e U0 /\ x2 :e V /\ U0 :/\: V = Empty).
    claim HV0prop: U0 :e Tx /\ V0 :e Tx /\ x1 :e U0 /\ x2 :e V0 /\ U0 :/\: V0 = Empty.
    { exact (Eps_i_ex (fun V:set => U0 :e Tx /\ V :e Tx /\ x1 :e U0 /\ x2 :e V /\ U0 :/\: V = Empty) HU0ex). }
    claim H1234: (((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) /\ x2 :e V0).
    { exact (andEL ((((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) /\ x2 :e V0))
                   (U0 :/\: V0 = Empty)
                   HV0prop). }
    claim HdisjUV: U0 :/\: V0 = Empty.
    { exact (andER ((((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) /\ x2 :e V0))
                   (U0 :/\: V0 = Empty)
                   HV0prop). }
    claim H123: ((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0).
    { exact (andEL ((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0)
                   (x2 :e V0)
                   H1234). }
    claim H12: (U0 :e Tx /\ V0 :e Tx).
    { exact (andEL (U0 :e Tx /\ V0 :e Tx)
                   (x1 :e U0)
                   H123). }
    claim HUx1: x1 :e U0.
    { exact (andER (U0 :e Tx /\ V0 :e Tx)
                   (x1 :e U0)
                   H123). }
    claim HVx2: x2 :e V0.
    { exact (andER ((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0)
                   (x2 :e V0)
                   H1234). }
    claim HU0Tx': U0 :e Tx'.
    { apply Hfiner. exact (andEL (U0 :e Tx) (V0 :e Tx) H12). }
    claim HV0Tx': V0 :e Tx'.
    { apply Hfiner. exact (andER (U0 :e Tx) (V0 :e Tx) H12). }
    witness U0.
    witness V0.
    apply and5I.
    - exact HU0Tx'.
    - exact HV0Tx'.
    - exact HUx1.
    - exact HVx2.
    - exact HdisjUV. }
apply and3I.
- exact Hhaus_finer.
- prove regular_space X Tx -> Hausdorff_space X Tx'.
  assume Hreg: regular_space X Tx.
  claim HT1: one_point_sets_closed X Tx.
  { exact (andEL (one_point_sets_closed X Tx)
                 (forall x:set, x :e X ->
                   forall F:set, closed_in X Tx F -> x /:e F ->
                     exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty)
                 Hreg). }
  claim Hsing: forall x:set, x :e X -> closed_in X Tx {x}.
  { exact (andER (topology_on X Tx) (forall x:set, x :e X -> closed_in X Tx {x}) HT1). }
  claim HSepReg:
    forall x:set, x :e X ->
      forall F:set, closed_in X Tx F -> x /:e F ->
        exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty.
  { exact (andER (one_point_sets_closed X Tx)
                 (forall x:set, x :e X ->
                   forall F:set, closed_in X Tx F -> x /:e F ->
                     exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty)
                 Hreg). }
  claim HHcoarse: Hausdorff_space X Tx.
  { prove topology_on X Tx /\
          forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
            exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
    apply andI.
    - exact (andEL (topology_on X Tx) (forall x:set, x :e X -> closed_in X Tx {x}) HT1).
    - let x1 x2.
      assume Hx1X: x1 :e X.
      assume Hx2X: x2 :e X.
      assume Hneq: x1 <> x2.
      prove exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
      claim Hcl: closed_in X Tx {x2}.
      { exact (Hsing x2 Hx2X). }
      claim Hx1not: x1 /:e {x2}.
      { assume Hx1in: x1 :e {x2}.
        claim Heq: x1 = x2.
        { exact (SingE x2 x1 Hx1in). }
        exact (Hneq Heq). }
      claim Hex: exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ {x2} c= V /\ U :/\: V = Empty.
      { exact (HSepReg x1 Hx1X {x2} Hcl Hx1not). }
      set U0 := Eps_i (fun U:set => exists V:set,
        U :e Tx /\ V :e Tx /\ x1 :e U /\ {x2} c= V /\ U :/\: V = Empty).
      claim HU0ex: exists V:set,
        U0 :e Tx /\ V :e Tx /\ x1 :e U0 /\ {x2} c= V /\ U0 :/\: V = Empty.
      { exact (Eps_i_ex (fun U:set => exists V:set,
          U :e Tx /\ V :e Tx /\ x1 :e U /\ {x2} c= V /\ U :/\: V = Empty) Hex). }
      set V0 := Eps_i (fun V:set => U0 :e Tx /\ V :e Tx /\ x1 :e U0 /\ {x2} c= V /\ U0 :/\: V = Empty).
      claim HV0prop: U0 :e Tx /\ V0 :e Tx /\ x1 :e U0 /\ {x2} c= V0 /\ U0 :/\: V0 = Empty.
      { exact (Eps_i_ex (fun V:set => U0 :e Tx /\ V :e Tx /\ x1 :e U0 /\ {x2} c= V /\ U0 :/\: V = Empty)
                        HU0ex). }
      claim H1234: (((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) /\ {x2} c= V0).
      { exact (andEL ((((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) /\ {x2} c= V0))
                     (U0 :/\: V0 = Empty)
                     HV0prop). }
      claim HdisjUV: U0 :/\: V0 = Empty.
      { exact (andER ((((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) /\ {x2} c= V0))
                     (U0 :/\: V0 = Empty)
                     HV0prop). }
      claim H123: ((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0).
      { exact (andEL ((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0)
                     ({x2} c= V0)
                     H1234). }
      claim H12: (U0 :e Tx /\ V0 :e Tx).
      { exact (andEL (U0 :e Tx /\ V0 :e Tx) (x1 :e U0) H123). }
      claim HUx1: x1 :e U0.
      { exact (andER (U0 :e Tx /\ V0 :e Tx) (x1 :e U0) H123). }
      claim HVsub: {x2} c= V0.
      { exact (andER ((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) ({x2} c= V0) H1234). }
      claim Hx2V0: x2 :e V0.
      { apply HVsub. exact (SingI x2). }
      witness U0.
      witness V0.
      apply and5I.
      - exact (andEL (U0 :e Tx) (V0 :e Tx) H12).
      - exact (andER (U0 :e Tx) (V0 :e Tx) H12).
      - exact HUx1.
      - exact Hx2V0.
      - exact HdisjUV. }
  exact (Hhaus_finer HHcoarse).
- prove normal_space X Tx -> Hausdorff_space X Tx'.
  assume Hnorm: normal_space X Tx.
  claim HT1: one_point_sets_closed X Tx.
  { exact (andEL (one_point_sets_closed X Tx)
                 (forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty)
                 Hnorm). }
  claim Hsing: forall x:set, x :e X -> closed_in X Tx {x}.
  { exact (andER (topology_on X Tx) (forall x:set, x :e X -> closed_in X Tx {x}) HT1). }
  claim HSepNorm:
    forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
      exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.
  { exact (andER (one_point_sets_closed X Tx)
                 (forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty)
                 Hnorm). }
  claim HHcoarse: Hausdorff_space X Tx.
  { prove topology_on X Tx /\
          forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
            exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
    apply andI.
    - exact (andEL (topology_on X Tx) (forall x:set, x :e X -> closed_in X Tx {x}) HT1).
    - let x1 x2.
      assume Hx1X: x1 :e X.
      assume Hx2X: x2 :e X.
      assume Hneq: x1 <> x2.
      prove exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
      claim Hcl1: closed_in X Tx {x1}.
      { exact (Hsing x1 Hx1X). }
      claim Hcl2: closed_in X Tx {x2}.
      { exact (Hsing x2 Hx2X). }
      claim Hdisj: {x1} :/\: {x2} = Empty.
      { apply Empty_Subq_eq.
        let z. assume Hz: z :e {x1} :/\: {x2}.
        prove z :e Empty.
        claim Hz1: z :e {x1}.
        { exact (binintersectE1 {x1} {x2} z Hz). }
        claim Hz2: z :e {x2}.
        { exact (binintersectE2 {x1} {x2} z Hz). }
        claim Hzx1: z = x1.
        { exact (SingE x1 z Hz1). }
        claim Hzx2: z = x2.
        { exact (SingE x2 z Hz2). }
        claim Hx1x2: x1 = x2.
        { rewrite <- Hzx1. rewrite Hzx2. reflexivity. }
        apply FalseE.
        exact (Hneq Hx1x2). }
      claim Hex: exists U V:set,
        U :e Tx /\ V :e Tx /\ {x1} c= U /\ {x2} c= V /\ U :/\: V = Empty.
      { exact (HSepNorm {x1} {x2} Hcl1 Hcl2 Hdisj). }
      set U0 := Eps_i (fun U:set => exists V:set,
        U :e Tx /\ V :e Tx /\ {x1} c= U /\ {x2} c= V /\ U :/\: V = Empty).
      claim HU0ex: exists V:set,
        U0 :e Tx /\ V :e Tx /\ {x1} c= U0 /\ {x2} c= V /\ U0 :/\: V = Empty.
      { exact (Eps_i_ex (fun U:set => exists V:set,
          U :e Tx /\ V :e Tx /\ {x1} c= U /\ {x2} c= V /\ U :/\: V = Empty) Hex). }
      set V0 := Eps_i (fun V:set => U0 :e Tx /\ V :e Tx /\ {x1} c= U0 /\ {x2} c= V /\ U0 :/\: V = Empty).
      claim HV0prop: U0 :e Tx /\ V0 :e Tx /\ {x1} c= U0 /\ {x2} c= V0 /\ U0 :/\: V0 = Empty.
      { exact (Eps_i_ex (fun V:set => U0 :e Tx /\ V :e Tx /\ {x1} c= U0 /\ {x2} c= V /\ U0 :/\: V = Empty)
                        HU0ex). }
      claim H1234: (((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0) /\ {x2} c= V0).
      { exact (andEL ((((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0) /\ {x2} c= V0))
                     (U0 :/\: V0 = Empty)
                     HV0prop). }
      claim HdisjUV: U0 :/\: V0 = Empty.
      { exact (andER ((((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0) /\ {x2} c= V0))
                     (U0 :/\: V0 = Empty)
                     HV0prop). }
      claim H123: ((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0).
      { exact (andEL ((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0)
                     ({x2} c= V0)
                     H1234). }
      claim H12: (U0 :e Tx /\ V0 :e Tx).
      { exact (andEL (U0 :e Tx /\ V0 :e Tx) ({x1} c= U0) H123). }
      claim Hsub1: {x1} c= U0.
      { exact (andER (U0 :e Tx /\ V0 :e Tx) ({x1} c= U0) H123). }
      claim Hsub2: {x2} c= V0.
      { exact (andER ((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0) ({x2} c= V0) H1234). }
      claim Hx1U0: x1 :e U0.
      { apply Hsub1. exact (SingI x1). }
      claim Hx2V0: x2 :e V0.
      { apply Hsub2. exact (SingI x2). }
      witness U0.
      witness V0.
      apply and5I.
      - exact (andEL (U0 :e Tx) (V0 :e Tx) H12).
      - exact (andER (U0 :e Tx) (V0 :e Tx) H12).
      - exact Hx1U0.
      - exact Hx2V0.
      - exact HdisjUV. }
  exact (Hhaus_finer HHcoarse).
Qed.
(** from 31 Exercise 5: equalizer of continuous maps into Hausdorff is closed **)
(** LATEX VERSION: Let f,g: X  Y be continuous, Y Hausdorff. Then {x | f(x) = g(x)} is closed in X. **)
Theorem ex31_5_equalizer_closed_in_Hausdorff : forall X Tx Y Ty f g:set,
  continuous_map X Tx Y Ty f ->
  continuous_map X Tx Y Ty g ->
  Hausdorff_space Y Ty ->
  closed_in X Tx {x :e X | apply_fun f x = apply_fun g x}.
let X Tx Y Ty f g.
assume Hf: continuous_map X Tx Y Ty f.
assume Hg: continuous_map X Tx Y Ty g.
assume HHaus: Hausdorff_space Y Ty.
prove closed_in X Tx {x :e X | apply_fun f x = apply_fun g x}.
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (topology_on Y Ty)
               (andEL (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y)
                      (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
                             (forall V:set, V :e Ty -> preimage_of X f V :e Tx) Hf))). }
claim HTy: topology_on Y Ty.
{ exact (andEL (topology_on Y Ty)
               (forall y1 y2:set, y1 :e Y -> y2 :e Y -> y1 <> y2 ->
                 exists U V:set, U :e Ty /\ V :e Ty /\ y1 :e U /\ y2 :e V /\ U :/\: V = Empty)
               HHaus). }
set h := pair_map X f g.
claim Hhcont: continuous_map X Tx (setprod Y Y) (product_topology Y Ty Y Ty) h.
{ exact (maps_into_products_axiom X Tx Y Ty Y Ty f g Hf Hg). }
set D := {(y,y)|y :e Y}.
claim HclosedD: closed_in (setprod Y Y) (product_topology Y Ty Y Ty) D.
{ exact (iffEL (Hausdorff_space Y Ty)
               (closed_in (setprod Y Y) (product_topology Y Ty Y Ty) {(y,y)|y :e Y})
               (ex17_13_diagonal_closed_iff_Hausdorff Y Ty HTy) HHaus). }
claim Hpre_closed: closed_in X Tx (preimage_of X h D).
{ exact (continuous_preserves_closed X Tx (setprod Y Y) (product_topology Y Ty Y Ty) h Hhcont D HclosedD). }
claim Heq:
  preimage_of X h D = {x :e X | apply_fun f x = apply_fun g x}.
{ apply set_ext.
  - let x. assume Hx: x :e preimage_of X h D.
    prove x :e {x :e X | apply_fun f x = apply_fun g x}.
    claim HxX: x :e X.
    { exact (SepE1 X (fun x0:set => apply_fun h x0 :e D) x Hx). }
    claim HhDx: apply_fun h x :e D.
    { exact (SepE2 X (fun x0:set => apply_fun h x0 :e D) x Hx). }
    apply (ReplE Y (fun y:set => (y,y)) (apply_fun h x) HhDx).
    let y. assume HyPair.
    claim HyY: y :e Y.
    { exact (andEL (y :e Y) (apply_fun h x = (y,y)) HyPair). }
    claim HeqPair: apply_fun h x = (y,y).
    { exact (andER (y :e Y) (apply_fun h x = (y,y)) HyPair). }
    claim Happ: apply_fun h x = (apply_fun f x, apply_fun g x).
    { exact (pair_map_apply X Y Y f g x HxX). }
    claim HfgEq: (apply_fun f x, apply_fun g x) = (y,y).
    { rewrite <- Happ. exact HeqPair. }
    claim H0: (apply_fun f x, apply_fun g x) 0 = apply_fun f x.
    { exact (tuple_2_0_eq (apply_fun f x) (apply_fun g x)). }
    claim H1: (apply_fun f x, apply_fun g x) 1 = apply_fun g x.
    { exact (tuple_2_1_eq (apply_fun f x) (apply_fun g x)). }
    claim H0eq: (y,y) 0 = apply_fun f x.
    { rewrite <- HfgEq.
      exact H0. }
    claim H1eq: (y,y) 1 = apply_fun g x.
    { rewrite <- HfgEq.
      exact H1. }
    claim Hyfx: y = apply_fun f x.
    { rewrite <- (tuple_2_0_eq y y).
      exact H0eq. }
    claim Hygx: y = apply_fun g x.
    { rewrite <- (tuple_2_1_eq y y).
      exact H1eq. }
    apply (SepI X (fun x0:set => apply_fun f x0 = apply_fun g x0) x HxX).
    rewrite <- Hyfx.
    rewrite <- Hygx.
    reflexivity.
  - let x. assume Hx: x :e {x :e X | apply_fun f x = apply_fun g x}.
    prove x :e preimage_of X h D.
    claim HxX: x :e X.
    { exact (SepE1 X (fun x0:set => apply_fun f x0 = apply_fun g x0) x Hx). }
    claim Hfg: apply_fun f x = apply_fun g x.
    { exact (SepE2 X (fun x0:set => apply_fun f x0 = apply_fun g x0) x Hx). }
    claim Hf_fun: function_on f X Y.
    { exact (andER (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y)
                   (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
                          (forall V:set, V :e Ty -> preimage_of X f V :e Tx) Hf)). }
    claim HfxY: apply_fun f x :e Y.
    { exact (Hf_fun x HxX). }
    claim Happ: apply_fun h x = (apply_fun f x, apply_fun g x).
    { exact (pair_map_apply X Y Y f g x HxX). }
    claim Himg: apply_fun h x :e D.
    { rewrite Happ.
      rewrite <- Hfg.
      exact (ReplI Y (fun y:set => (y,y)) (apply_fun f x) HfxY). }
    exact (SepI X (fun x0:set => apply_fun h x0 :e D) x HxX Himg). }
rewrite <- Heq.
exact Hpre_closed.
Qed.
(** from 31 Exercise 6: closed continuous surjection preserves normal **)
(** LATEX VERSION: Let p: X  Y be closed continuous surjective map. If X is normal, then so is Y. **)
(** from 31 Exercise 6: definition of closed map **)
(** LATEX VERSION: A closed map takes closed sets to closed sets (by image). **)
Definition closed_map : set -> set -> set -> set -> set -> prop := fun X Tx Y Ty p =>
  function_on p X Y /\ forall A:set, closed_in X Tx A -> closed_in Y Ty (image_of p A).

Theorem ex31_6_closed_map_preserves_normal : forall X Tx Y Ty p:set,
  normal_space X Tx ->
  continuous_map X Tx Y Ty p ->
  closed_map X Tx Y Ty p ->
  (forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun p x = y) ->
  normal_space Y Ty.
admit.
Qed.
(** from 31 Exercise 7: perfect map preserves separation/countability/local compactness **)
(** LATEX VERSION: Perfect map (closed continuous surjective with compact fibers) preserves Hausdorff, regular, locally compact, second-countable. **)
(** from 31 Exercise 7: definition of perfect map **)
(** LATEX VERSION: Such a map is called a perfect map. **)
Definition perfect_map : set -> set -> set -> set -> set -> prop := fun X Tx Y Ty p =>
  continuous_map X Tx Y Ty p /\
  closed_map X Tx Y Ty p /\
  (forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun p x = y) /\
  (forall y:set, y :e Y ->
    compact_space {x :e X | apply_fun p x = y}
                 (subspace_topology X Tx {x :e X | apply_fun p x = y})).

Theorem ex31_7_perfect_map_properties : forall X Tx Y Ty p:set,
  perfect_map X Tx Y Ty p ->
  (Hausdorff_space X Tx -> Hausdorff_space Y Ty) /\
  (regular_space X Tx -> regular_space Y Ty) /\
  (locally_compact X Tx -> locally_compact Y Ty) /\
  (second_countable_space X Tx -> second_countable_space Y Ty).
admit.
Qed.
(** from 31 Exercise 8: orbit space of compact group action preserves properties **)
(** LATEX VERSION: Let G be compact topological group,  action of G on X. Orbit space X/G retains Hausdorff, regular, normal, locally compact, second-countable properties. **)
Theorem ex31_8_orbit_space_properties : forall G Tg X Tx alpha:set,
  topological_group G Tg ->
  compact_space G Tg ->
  (Hausdorff_space X Tx -> exists XG TxG:set, Hausdorff_space XG TxG) /\
  (regular_space X Tx -> exists XG TxG:set, regular_space XG TxG) /\
  (normal_space X Tx -> exists XG TxG:set, normal_space XG TxG) /\
  (locally_compact X Tx -> exists XG TxG:set, locally_compact XG TxG) /\
  (second_countable_space X Tx -> exists XG TxG:set, second_countable_space XG TxG).
admit.
Qed.
(** from 31 Exercise 9: Sorgenfrey plane rational/irrational diagonal non-separation **)
(** LATEX VERSION: In _, let A = {x  (-x) | x rational}, B = {x  (-x) | x irrational}. No open sets separate A and B. **)
(** Diagonal sets in the Sorgenfrey plane used in this exercise. **)
Definition Sorgenfrey_plane_diag_rational : set :=
  {(x, minus_SNo x) | x :e rational_numbers}.
Definition Sorgenfrey_plane_diag_irrational : set :=
  {(x, minus_SNo x) | x :e (Sorgenfrey_line :\: rational_numbers)}.
Theorem ex31_9_Sorgenfrey_plane_no_separation :
  ~ (exists U V:set,
      open_in (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology U /\
      open_in (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology V /\
      Sorgenfrey_plane_diag_rational c= U /\
      Sorgenfrey_plane_diag_irrational c= V /\
      U :/\: V = Empty).
admit.
Qed.

(** from 32 Exercise 1: closed subspace of normal is normal **)
(** LATEX VERSION: A closed subspace of a normal space is normal. **)
Theorem ex32_1_closed_subspace_normal : forall X Tx A:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  normal_space A (subspace_topology X Tx A).
admit.
Qed.
(** from 32 Exercise 2: factor spaces of products inherit separation **)
(** LATEX VERSION: If X_ is Hausdorff/regular/normal, then so is each X_ (assuming X_ nonempty). **)
Theorem ex32_2_factors_inherit_separation : forall Idx Fam:set,
  (forall i:set, i :e Idx -> exists Xi Txi:set, apply_fun Fam i = (Xi, Txi) /\ Xi <> Empty) ->
  ((Hausdorff_space (product_space Idx Fam) (product_topology_full Idx Fam) ->
      forall i:set, i :e Idx -> exists Xi Txi:set, apply_fun Fam i = (Xi, Txi) /\ Hausdorff_space Xi Txi) /\
   (regular_space (product_space Idx Fam) (product_topology_full Idx Fam) ->
      forall i:set, i :e Idx -> exists Xi Txi:set, apply_fun Fam i = (Xi, Txi) /\ regular_space Xi Txi) /\
   (normal_space (product_space Idx Fam) (product_topology_full Idx Fam) ->
      forall i:set, i :e Idx -> exists Xi Txi:set, apply_fun Fam i = (Xi, Txi) /\ normal_space Xi Txi)).
admit.
Qed.
(** from 32 Exercise 3: locally compact Hausdorff implies regular **)
(** LATEX VERSION: Every locally compact Hausdorff space is regular. **)
Theorem ex32_3_locally_compact_Hausdorff_regular : forall X Tx:set,
  locally_compact X Tx ->
  Hausdorff_space X Tx ->
  regular_space X Tx.
admit.
Qed.
(** from 32 Exercise 4: regular Lindelof implies normal **)
(** LATEX VERSION: Every regular Lindelf space is normal. **)
Theorem ex32_4_regular_Lindelof_normal : forall X Tx:set,
  regular_space X Tx ->
  Lindelof_space X Tx ->
  normal_space X Tx.
admit.
Qed.
(** from 32 Exercise 5: normality questions for Romega product topologies **)
(** LATEX VERSION: Is ^ normal in product topology? In uniform topology? **)
Theorem ex32_5_Romega_normality_questions :
  (normal_space R_omega_space R_omega_product_topology \/
   ~ normal_space R_omega_space R_omega_product_topology) /\
  (normal_space real_sequences uniform_topology \/
   ~ normal_space real_sequences uniform_topology).
apply andI.
- exact (xm (normal_space R_omega_space R_omega_product_topology)).
- exact (xm (normal_space real_sequences uniform_topology)).
Qed.
(** from 32 Exercise 6: completely normal characterization via separated sets **)
(** LATEX VERSION: X is completely normal iff for every separated pair A,B, there exist disjoint open sets containing them. **)
Theorem ex32_6_completely_normal_characterization : forall X Tx:set,
  completely_normal_space X Tx <->
  (forall A B:set, separated_subsets X Tx A B ->
    exists U V:set, open_in X Tx U /\ open_in X Tx V /\ A c= U /\ B c= V /\ U :/\: V = Empty).
admit.
Qed.
(** from 32 Exercise 7: completely normal examples **)
(** LATEX VERSION: Which are completely normal: (a) subspace (b) product (c) well-ordered (d) metrizable (e) compact Hausdorff (f) regular+countable basis (g) _? **)
Theorem ex32_7_completely_normal_examples :
  (forall X Tx A:set, completely_normal_space X Tx -> completely_normal_space A (subspace_topology X Tx A)) /\
  (forall X Tx Y Ty:set, completely_normal_space X Tx -> completely_normal_space Y Ty ->
    (completely_normal_space (setprod X Y) (product_topology X Tx Y Ty) \/
     ~ completely_normal_space (setprod X Y) (product_topology X Tx Y Ty))) /\
  (forall X:set, well_ordered_set X ->
    (completely_normal_space X (order_topology X) \/
     ~ completely_normal_space X (order_topology X))) /\
  (forall X Tx:set, metrizable X Tx -> completely_normal_space X Tx) /\
  (forall X Tx:set, compact_space X Tx -> Hausdorff_space X Tx ->
    (completely_normal_space X Tx \/ ~ completely_normal_space X Tx)) /\
  (forall X Tx:set, regular_space X Tx -> second_countable_space X Tx ->
    (completely_normal_space X Tx \/ ~ completely_normal_space X Tx)) /\
  (completely_normal_space R R_lower_limit_topology \/ ~ completely_normal_space R R_lower_limit_topology).
apply and7I.
- admit.
- let X Tx Y Ty.
  assume HX: completely_normal_space X Tx.
  assume HY: completely_normal_space Y Ty.
  exact (xm (completely_normal_space (setprod X Y) (product_topology X Tx Y Ty))).
- let X.
  assume Hwo: well_ordered_set X.
  exact (xm (completely_normal_space X (order_topology X))).
- admit.
- let X Tx.
  assume Hc: compact_space X Tx.
  assume HH: Hausdorff_space X Tx.
  exact (xm (completely_normal_space X Tx)).
- let X Tx.
  assume Hr: regular_space X Tx.
  assume Hsc: second_countable_space X Tx.
  exact (xm (completely_normal_space X Tx)).
- exact (xm (completely_normal_space R R_lower_limit_topology)).
Qed.
(** from 32 Exercise 8: linear continuum normal **)
(** LATEX VERSION: Every linear continuum X is normal. **)
Theorem ex32_8_linear_continuum_normal : forall X Tx:set,
  linear_continuum X Tx ->
  normal_space X Tx.
admit.
Qed.
(** from 32 Exercise 9: uncountable product of R not normal **)
(** LATEX VERSION: If J is uncountable, then ^J is not normal. **)
Theorem ex32_9_uncountable_product_not_normal : forall J:set,
  ~ countable J ->
  ~ normal_space (product_space J (const_space_family J R R_standard_topology)) (product_topology_full J (const_space_family J R R_standard_topology)).
admit.
Qed.

(** helper: perfect normality predicate **)
Definition perfectly_normal_space : set -> set -> prop := fun X Tx =>
  normal_space X Tx /\ (forall A:set, closed_in X Tx A -> Gdelta_in X Tx A).

(** FIXED: Removed nonsensical fourth clause: forall r, apply_fun f X = {x :e X | apply_fun f x = r} mixes an image in R with a level set in X; now left as a separate admitted exercise. **)
(** from 33 Exercise 1: expression for level sets in Urysohn proof **)
(** LATEX VERSION: In Urysohn lemma proof, show f^{-1}(r) = _{p>r} U_p - _{q<r} U_q for rational p,q. **)
Theorem ex33_1_level_sets_urysohn : forall X Tx A B:set, forall U:set -> set,
  normal_space X Tx ->
  closed_in X Tx A ->
  closed_in X Tx B ->
  A :/\: B = Empty ->
  exists f:set,
    continuous_map X Tx R R_standard_topology f /\
    (forall x:set, x :e A -> apply_fun f x = 0) /\
    (forall x:set, x :e B -> apply_fun f x = 1).
admit.
Qed.
(** from 33 Exercise 2: connected normal/regular uncountable **)
(** LATEX VERSION: Connected normal/regular space with >1 point is uncountable. **)
Theorem ex33_2a_connected_normal_uncountable : forall X Tx:set,
  connected_space X Tx ->
  normal_space X Tx ->
  (exists x y:set, x :e X /\ y :e X /\ x <> y) ->
  ~ countable X.
admit.
Qed.

Theorem ex33_2b_connected_regular_uncountable : forall X Tx:set,
  connected_space X Tx ->
  regular_space X Tx ->
  (exists x y:set, x :e X /\ y :e X /\ x <> y) ->
  ~ countable X.
admit.
Qed.
(** from 33 Exercise 3: direct Urysohn proof in metric space **)
(** LATEX VERSION: For metric space, Urysohn lemma direct proof: f(x) = d(x,A)/(d(x,A)+d(x,B)). **)
Theorem ex33_3_urysohn_metric_direct : forall X d A B:set,
  metric_on X d ->
  closed_in X (metric_topology X d) A ->
  closed_in X (metric_topology X d) B ->
  A :/\: B = Empty ->
  exists f:set,
    continuous_map X (metric_topology X d) R R_standard_topology f /\
    (forall x:set, x :e A -> apply_fun f x = 0) /\
    (forall x:set, x :e B -> apply_fun f x = 1).
admit.
Qed.
(** from 33 Exercise 4: closed G_delta sets and vanishing functions **)
(** LATEX VERSION: In normal X, f:X[0,1] vanishing precisely on A iff A is closed G_. **)
Theorem ex33_4_closed_Gdelta_vanishing_function : forall X Tx A:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  (Gdelta_in X Tx A <->
    exists f:set,
      continuous_map X Tx R R_standard_topology f /\
      (forall x:set, x :e A -> apply_fun f x = 0) /\
      (forall x:set, x /:e A -> ~ (apply_fun f x = 0))).
admit.
Qed.
(** from 33 Exercise 5: strong Urysohn lemma **)
(** LATEX VERSION: Strong Urysohn: f with f(A)=0, f(B)=1, 0<f<1 elsewhere iff A,B closed G_. **)
Theorem ex33_5_strong_urysohn : forall X Tx A B:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  closed_in X Tx B ->
  A :/\: B = Empty ->
  (Gdelta_in X Tx A /\ Gdelta_in X Tx B <->
    exists f:set,
      continuous_map X Tx R R_standard_topology f /\
      (forall x:set, x :e A -> apply_fun f x = 0) /\
      (forall x:set, x :e B -> apply_fun f x = 1) /\
      (forall x:set, x :e X -> x /:e A -> x /:e B -> ~ (apply_fun f x = 0) /\ ~ (apply_fun f x = 1))).
admit.
Qed.
(** from 33 Exercise 6a: metrizable implies perfectly normal **)
(** LATEX VERSION: Every metrizable space is perfectly normal. **)
Theorem ex33_6a_metrizable_perfectly_normal : forall X Tx:set,
  metrizable X Tx ->
  perfectly_normal_space X Tx.
admit.
Qed.

(** from 33 Exercise 6b: perfectly normal implies completely normal **)
(** LATEX VERSION: Every perfectly normal space is completely normal. **)
Theorem ex33_6b_perfectly_completely_normal : forall X Tx:set,
  perfectly_normal_space X Tx ->
  completely_normal_space X Tx.
admit.
Qed.

(** from 33 Exercise 6c: completely normal not perfectly normal example **)
(** LATEX VERSION: There exists completely normal but not perfectly normal space. **)
Theorem ex33_6c_completely_not_perfectly_normal :
  exists X Tx:set,
    completely_normal_space X Tx /\
    ~ perfectly_normal_space X Tx.
admit.
Qed.
(** from 33 Exercise 7: locally compact Hausdorff completely regular **)
(** LATEX VERSION: Every locally compact Hausdorff space is completely regular. **)
Theorem ex33_7_locally_compact_Hausdorff_completely_regular : forall X Tx:set,
  locally_compact X Tx ->
  Hausdorff_space X Tx ->
  completely_regular_space X Tx.
admit.
Qed.
(** from 33 Exercise 8: continuous separation when A compact **)
(** LATEX VERSION: If X completely regular, A compact, B closed disjoint from A, then f:X[0,1] with f(A)=0, f(B)=1. **)
Theorem ex33_8_compact_subset_continuous_separation : forall X Tx A B:set,
  completely_regular_space X Tx ->
  compact_space A (subspace_topology X Tx A) ->
  closed_in X Tx B ->
  A :/\: B = Empty ->
  exists f:set,
    continuous_map X Tx R R_standard_topology f /\
    (forall x:set, x :e A -> apply_fun f x = 0) /\
    (forall x:set, x :e B -> apply_fun f x = 1).
admit.
Qed.
(** from 33 Exercise 9: Romega box topology completely regular **)
(** LATEX VERSION: ^ in box topology is completely regular. **)
Theorem ex33_9_Romega_box_completely_regular :
  completely_regular_space (product_space omega (const_space_family omega R R_standard_topology))
                           (box_topology omega (const_space_family omega R R_standard_topology)).
admit.
Qed.
(** from 33 Exercise 10: topological group completely regular **)
(** LATEX VERSION: Every topological group is completely regular. **)
Theorem ex33_10_topological_group_completely_regular : forall G Tg:set,
  topological_group G Tg ->
  completely_regular_space G Tg.
admit.
Qed.
(** from 33 Exercise 11: regular not completely regular example **)
(** LATEX VERSION: There exists regular space that is not completely regular. **)
Theorem ex33_11_regular_not_completely_regular :
  exists X Tx:set,
    regular_space X Tx /\
    ~ completely_regular_space X Tx.
admit.
Qed.

(** helper: retraction data **) 
Definition retraction_of : set -> set -> set -> prop := fun X Tx A =>
  A c= X /\ exists r:set,
    function_on r X X /\ continuous_map X Tx X Tx r /\
    (forall x:set, x :e X -> apply_fun r x :e A) /\
    (forall x:set, x :e A -> apply_fun r x = x).

Definition image_of_map : set -> set -> set -> set -> set -> set :=
  fun X Tx Y Ty f => image_of f X.

Definition absolute_retract : set -> set -> prop := fun X Tx =>
  Hausdorff_space X Tx /\
  forall Y Ty, normal_space Y Ty ->
    exists e:set, embedding_of X Tx Y Ty e /\
      exists r:set, retraction_of Y Ty (image_of_map X Tx Y Ty e).

Definition coherent_topology : set -> set -> set -> set -> prop := fun X Tx Y Ty =>
  topology_on X Tx /\ topology_on Y Ty /\ X c= Y /\ subspace_topology Y Ty X = Tx.

Definition compact_spaces_family : set -> set -> prop := fun I Xi =>
  forall i:set, i :e I -> compact_space (product_component Xi i) (product_component_topology Xi i).

Definition surjective_map : set -> set -> set -> prop := fun X Y f =>
  function_on f X Y /\ forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun f x = y.

(** from 34 Exercise 1: Hausdorff with countable basis need not be metrizable **) 
(** LATEX VERSION: Find an example of a Hausdorff second countable space that is not metrizable. **)
Definition ex34_1_Hausdorff_countable_basis_not_metrizable_example : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\
      Hausdorff_space X Tx /\ second_countable_space X Tx /\ ~ metrizable X Tx}.
(** from 34 Exercise 2: completely normal etc. not metrizable example **) 
(** LATEX VERSION: Find an example of a completely normal space that is not metrizable. **)
Definition ex34_2_completely_normal_not_metrizable_example : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\ completely_normal_space X Tx /\ ~ metrizable X Tx}.
(** from 34 Exercise 3: compact Hausdorff metrizable iff countable basis **) 
(** LATEX VERSION: Prove that for compact Hausdorff spaces, metrizability is equivalent to second countability. **)
Definition ex34_3_compact_Hausdorff_metrizable_iff_second_countable : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\
      compact_space X Tx /\ Hausdorff_space X Tx /\
      (metrizable X Tx <-> second_countable_space X Tx)}.
(** from 34 Exercise 4: locally compact Hausdorff and countable basis vs metrizable **) 
(** LATEX VERSION: Study metrizability questions for locally compact Hausdorff spaces under second countability. **)
Definition ex34_4_locally_compact_Hausdorff_metrizable_questions : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\
      locally_compact X Tx /\ Hausdorff_space X Tx /\
      (second_countable_space X Tx -> metrizable X Tx)}.
(** from 34 Exercise 5: one-point compactification metrizable vs base **) 
(** LATEX VERSION: Relate metrizability of a space and its one-point compactification. **)
Definition ex34_5_one_point_compactification_metrizable_questions : set :=
  {q :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx Y Ty p:set,
      q = setprod (setprod (setprod X Tx) (setprod Y Ty)) p /\
      one_point_compactification X Tx Y Ty /\ p :e Y /\ ~ p :e X /\
      (metrizable X Tx <-> metrizable Y Ty)}.
(** from 34 Exercise 6: details of imbedding theorem proof **) 
(** LATEX VERSION: Check details in the embedding theorem proof for completely regular Hausdorff spaces. **)
Definition ex34_6_check_imbedding_proof : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx f:set,
      p = setprod (setprod X Tx) f /\
      completely_regular_space X Tx /\ Hausdorff_space X Tx /\
      embedding_of X Tx (power_real omega) (product_topology_full omega (const_space_family omega R R_standard_topology)) f}.
(** from 34 Exercise 7: locally metrizable compact Hausdorff implies metrizable **) 
(** LATEX VERSION: Show that a locally metrizable compact Hausdorff space is metrizable. **)
Definition ex34_7_locally_metrizable_compact_Hausdorff_metrizable : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\
      locally_metrizable_space X Tx /\ compact_space X Tx /\ Hausdorff_space X Tx /\
      metrizable X Tx}.
(** from 34 Exercise 8: regular Lindelof locally metrizable implies metrizable **) 
(** LATEX VERSION: Show that regular Lindelof and locally metrizable implies metrizable. **)
Definition ex34_8_regular_Lindelof_locally_metrizable_metrizable : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\
      (regular_space X Tx /\ Lindelof_space X Tx /\ locally_metrizable_space X Tx ->
        metrizable X Tx)}.
(** from 34 Exercise 9: compact Hausdorff union of two metrizable closed sets is metrizable **) 
(** LATEX VERSION: If X is compact Hausdorff and is the union of two metrizable closed subsets, then X is metrizable. **)
Definition ex34_9_compact_union_two_metrizable_closed_metrizable : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx A B:set,
      p = setprod (setprod X Tx) (setprod A B) /\
      compact_space X Tx /\ Hausdorff_space X Tx /\
      closed_in X Tx A /\ closed_in X Tx B /\ Union (UPair A B) = X /\
      metrizable A (subspace_topology X Tx A) /\ metrizable B (subspace_topology X Tx B) /\
      metrizable X Tx}.

(** from 35 Exercise 1: Tietze implies Urysohn lemma **) 
(** LATEX VERSION: Use the Tietze extension theorem to derive Urysohn's lemma in a normal space. **)
Definition ex35_1_Tietze_implies_Urysohn : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\
      normal_space X Tx /\
      (forall A B:set, closed_in X Tx A /\ closed_in X Tx B /\ A :/\: B = Empty ->
         exists f:set, continuous_map X Tx R R_standard_topology f /\
           (forall x:set, x :e A -> apply_fun f x = 0) /\
           (forall x:set, x :e B -> apply_fun f x = 1))}.
(** from 35 Exercise 2: interval partition parameter in Tietze proof **) 
(** LATEX VERSION: Choose an interval partition parameter used in a proof of the Tietze extension theorem. **)
Definition ex35_2_interval_partition_parameter : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\ normal_space X Tx}.
(** from 35 Exercise 3: boundedness equivalences in metrizable spaces **) 
(** LATEX VERSION: Establish equivalences relating boundedness notions in metrizable spaces. **)
Definition ex35_3_boundedness_equivalences_metrizable : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx d:set, p = setprod (setprod X Tx) d /\
      metric_on X d /\ metric_topology X d = Tx}.
(** from 35 Exercise 4: retract properties **) 
(** LATEX VERSION: Prove basic properties of retracts and retractions. **)
Definition ex35_4_retract_properties : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx A:set, p = setprod (setprod X Tx) A /\ retraction_of X Tx A}.
(** from 35 Exercise 5: universal extension property and retracts **) 
(** LATEX VERSION: Show that retracts in a normal space satisfy an appropriate universal extension property. **)
Definition ex35_5_universal_extension_retracts : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx A:set,
      p = setprod (setprod X Tx) A /\
      normal_space X Tx /\ retraction_of X Tx A /\
      forall Y Ty f:set, continuous_map A (subspace_topology X Tx A) Y Ty f ->
        exists g:set, continuous_map X Tx Y Ty g /\
          forall x:set, x :e A -> apply_fun g x = apply_fun f x}.
(** from 35 Exercise 6: absolute retract equivalence **) 
(** LATEX VERSION: Prove a characterization of absolute retracts via a universal extension property. **)
Definition ex35_6_absolute_retract_universal_extension : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\ absolute_retract X Tx}.
(** from 35 Exercise 7: retract examples spiral/knotted axis **) 
(** LATEX VERSION: Give examples of retracts, such as spiral and knotted axis subsets. **)
Definition ex35_7_retract_examples : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx A:set, p = setprod (setprod X Tx) A /\ retraction_of X Tx A}.
(** from 35 Exercise 8: absolute retract iff universal extension **) 
(** LATEX VERSION: Prove an equivalence for absolute retracts (as stated in the exercises). **)
Definition ex35_8_absolute_retract_equivalence : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\ absolute_retract X Tx}.
(** from 35 Exercise 9: coherent topology preserves normality **) 
(** LATEX VERSION: Show that under the coherent topology hypotheses, normality of Y follows from the stated assumptions. **)
Definition ex35_9_coherent_topology_normal : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx Y Ty:set,
      p = setprod (setprod X Tx) (setprod Y Ty) /\
      (topology_on X Tx /\ topology_on Y Ty /\ coherent_topology X Tx Y Ty -> normal_space Y Ty)}.

(** from 36 Exercises: manifolds and partitions of unity (placeholder) **) 
(** LATEX VERSION: Exercises on manifolds and partitions of unity. **)
Definition ex36_manifold_embedding_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists M TM f:set,
      p = setprod (setprod M TM) f /\
      m_manifold M TM ->
      exists n:set, embedding_of M TM (euclidean_space n) (euclidean_topology n) f}.
(** from 37 Exercises: Tychonoff theorem applications (placeholder) **) 
(** LATEX VERSION: Exercises applying the Tychonoff theorem to products of compact spaces. **)
Definition ex37_tychonoff_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists I Xi:set,
      p = setprod I Xi /\
      compact_spaces_family I Xi /\
      compact_space (product_space I Xi) (product_topology_full I Xi)}.
(** from 38 Exercises: Stone-Cech compactification (placeholder) **) 
(** LATEX VERSION: Exercises about Stone-Cech compactification and related embeddings. **)
Definition ex38_stone_cech_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx Y Ty:set,
      p = setprod (setprod X Tx) (setprod Y Ty) /\
      completely_regular_space X Tx /\ compact_space Y Ty /\ Hausdorff_space Y Ty /\
      exists e:set, embedding_of X Tx Y Ty e}.
(** from 39 Exercises: local finiteness (placeholder) **) 
(** LATEX VERSION: Exercises on locally finite families. **)
Definition ex39_local_finiteness_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx U:set, p = setprod (setprod X Tx) U /\ locally_finite_family X Tx U}.
(** from 40 Exercises: Nagata-Smirnov metrization (placeholder) **) 
(** LATEX VERSION: Exercises on Nagata-Smirnov metrization type criteria. **)
Definition ex40_nagata_smirnov_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx B:set,
      p = setprod (setprod X Tx) B /\
      (regular_space X Tx /\ basis_on X B /\ locally_finite_family X Tx B -> metrizable X Tx)}.
(** from 41 Exercises: paracompactness (placeholder) **) 
(** LATEX VERSION: Exercises on paracompactness and open covers. **)
Definition ex41_paracompactness_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx U:set, p = setprod (setprod X Tx) U /\
      paracompact_space X Tx /\ open_cover X Tx U}.
(** from 42 Exercises: Smirnov metrization (placeholder) **) 
(** LATEX VERSION: Exercises on Smirnov metrization type criteria. **)
Definition ex42_smirnov_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx B:set,
      p = setprod (setprod X Tx) B /\
      (regular_space X Tx /\ basis_on X B /\ locally_finite_family X Tx B -> metrizable X Tx)}.
(** from 43 Exercises: complete metric spaces (placeholder) **) 
(** LATEX VERSION: Exercise set for completeness properties. **)
Definition ex43_complete_metric_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X d Tx:set, p = setprod (setprod X d) Tx /\
      metric_on X d /\ Tx = metric_topology X d /\ complete_metric_space X d}.

(** from 44 Exercises: space-filling curve (placeholder) **) 
(** LATEX VERSION: Exercise set involving space-filling curves. **)
Definition ex44_space_filling_exercises : set :=
  {f :e Power (Power (Power R)) |
    continuous_map unit_interval R2_standard_topology unit_square unit_square_topology f /\
    surjective_map unit_interval unit_square f}.

(** from 45 Exercises: compactness in metric spaces (placeholder) **) 
(** LATEX VERSION: Exercise set on compactness equivalences in metric spaces. **)
Definition ex45_compact_metric_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X d Tx:set, p = setprod (setprod X d) Tx /\
      metric_on X d /\ Tx = metric_topology X d /\ compact_space X Tx}.

(** from 46 Exercises: pointwise/compact convergence (placeholder) **) 
(** LATEX VERSION: Exercises on pointwise and compact convergence topologies. **)
Definition ex46_convergence_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx Y Ty:set,
      p = setprod (setprod X Tx) (setprod Y Ty) /\
      topology_on X Tx /\ topology_on Y Ty}.

(** from 47 Exercises: Ascoli theorem (placeholder) **) 
(** LATEX VERSION: Exercises related to the AscoliArzel theorem. **)
Definition ex47_ascoli_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx Y Ty:set,
      p = setprod (setprod X Tx) (setprod Y Ty) /\
      compact_space X Tx /\ Hausdorff_space Y Ty}.

(** from 48 Exercise 1: nonempty Baire union has set with nonempty interior closure **)
(** LATEX VERSION: If X = B is a nonempty Baire space, then at least one B has nonempty interior. **)
Theorem ex48_1_Baire_union_interior : forall X Tx:set, forall Fam:set,
  Baire_space X Tx ->
  X <> Empty ->
  countable_set Fam ->
  X = Union Fam ->
  exists B:set, B :e Fam /\
    exists U:set, U :e Tx /\ U <> Empty /\ U c= (closure_of X Tx B).
admit.
Qed.

(** from 48 Exercise 2: R is not countable union of closed empty interior sets **)
(** LATEX VERSION:  cannot be written as countable union of closed sets with empty interior, but fails without closure requirement. **)
Theorem ex48_2_R_not_countable_empty_interior : forall Fam:set,
  countable_set Fam ->
  (forall C:set, C :e Fam -> closed_in R R_standard_topology C /\
    (forall U:set, U :e R_standard_topology -> U c= C -> U = Empty)) ->
  R <> Union Fam.
admit.
Qed.

(** from 48 Exercise 3: locally compact Hausdorff is Baire **)
(** LATEX VERSION: Every locally compact Hausdorff space is a Baire space. **)
Theorem ex48_3_locally_compact_Hausdorff_Baire : forall X Tx:set,
  locally_compact X Tx ->
  Hausdorff_space X Tx ->
  Baire_space X Tx.
admit.
Qed.

(** from 48 Exercise 4: locally Baire implies Baire **)
(** LATEX VERSION: If every point has a neighborhood that is Baire, then X is Baire. **)
Theorem ex48_4_locally_Baire_implies_Baire : forall X Tx:set,
  topology_on X Tx ->
  (forall x:set, x :e X ->
    exists U:set, U :e Tx /\ x :e U /\
      Baire_space U (subspace_topology X Tx U)) ->
  Baire_space X Tx.
admit.
Qed.

(** from 48 Exercise 5: G_delta in compact Hausdorff or complete metric is Baire **)
(** LATEX VERSION: If Y is G_ in X, and X is compact Hausdorff or complete metric, then Y is Baire in subspace topology. **)
Theorem ex48_5_Gdelta_Baire : forall X Tx Y:set,
  (compact_space X Tx /\ Hausdorff_space X Tx) ->
  (exists Fam:set, countable_set Fam /\
    (forall W:set, W :e Fam -> W :e Tx) /\
    Y = intersection_over_family X Fam) ->
  Baire_space Y (subspace_topology X Tx Y).
admit.
Qed.

(** from 48 Exercise 6: irrationals are Baire **)
(** LATEX VERSION: The irrationals are a Baire space. **)
Theorem ex48_6_irrationals_Baire :
  Baire_space (R :\: Q) (subspace_topology R R_standard_topology (R :\: Q)).
admit.
Qed.

(** from 48 Exercise 7a: continuity set is G_delta **)
(** LATEX VERSION: For f:, the set C of continuity points is G_. **)
Theorem ex48_7a_continuity_set_Gdelta : forall f:set,
  function_on f R R ->
  exists Fam:set, countable_set Fam /\
    (forall U:set, U :e Fam -> U :e R_standard_topology) /\
    {x :e R | continuous_at f x} = intersection_over_family R Fam.
admit.
Qed.

(** from 48 Exercise 7b: countable dense not G_delta **)
(** LATEX VERSION: Countable dense D   is not G_. **)
Theorem ex48_7b_countable_dense_not_Gdelta : forall D:set,
  D c= R ->
  countable_set D ->
  dense_in D R R_standard_topology ->
  ~ (exists Fam:set, countable_set Fam /\
      (forall W:set, W :e Fam -> W :e R_standard_topology) /\
      D = intersection_over_family R Fam).
admit.
Qed.

(** from 48 Exercise 7: no function continuous precisely on countable dense set **)
(** LATEX VERSION: If D is countable dense in , no f: is continuous precisely on D. **)
Theorem ex48_7_no_function_continuous_on_countable_dense : forall D:set,
  D c= R ->
  countable_set D ->
  dense_in D R R_standard_topology ->
  ~ (exists f:set, function_on f R R /\
      (forall x:set, x :e D -> continuous_at f x) /\
      (forall x:set, x :e R -> x /:e D -> ~ continuous_at f x)).
admit.
Qed.

(** from 48 Exercise 8: pointwise limit continuous uncountably many points **)
(** LATEX VERSION: If f: continuous with f(x)f(x) for all x, then f is continuous at uncountably many points. **)
Definition pointwise_limit_of_sequence_of_functions : set -> set -> prop := fun fn f =>
  forall x:set, x :e R ->
    forall eps:set, eps :e R -> Rlt 0 eps ->
      exists N:set, N :e omega /\
        forall n:set, n :e omega -> N c= n ->
          Rlt (Abs (add_SNo (apply_fun (apply_fun fn n) x) (minus_SNo (apply_fun f x)))) eps.
Theorem ex48_8_pointwise_limit_continuity : forall fn:set, forall f:set,
  (forall n:set, n :e omega ->
    continuous_map R R_standard_topology R R_standard_topology (apply_fun fn n)) ->
  function_on f R R ->
  pointwise_limit_of_sequence_of_functions fn f ->
  ~ countable_set {x :e R | continuous_at f x}.
admit.
Qed.

(** from 48 Exercise 9: Thomae function **)
(** LATEX VERSION: Define f(x)=1/n for rationals, f(x)=0 for irrationals. Then f is continuous at irrationals. **)
Theorem ex48_9_Thomae_function : forall g:set, forall f:set,
  (forall n:set, n :e omega -> apply_fun g n :e Q) ->
  function_on f R R ->
  (forall n:set, n :e omega -> apply_fun f (apply_fun g n) = recip_SNo (ordsucc n)) ->
  (forall x:set, x :e R -> x /:e Q -> apply_fun f x = 0) ->
  forall x:set, x :e R -> x /:e Q -> continuous_at f x.
admit.
Qed.

(** from 48 Exercise 10: uniform boundedness principle **)
(** LATEX VERSION: Uniform boundedness: if X complete metric and C(X,) pointwise bounded, then uniformly bounded on some nonempty open set. **)
Theorem ex48_10_uniform_boundedness : forall X d:set, forall FF:set,
  complete_metric_space X d ->
  FF c= Power (Power R) ->
  (forall a:set, a :e X ->
    exists M:set, M :e R /\
      forall f:set, f :e FF -> apply_fun f a :e R) ->
  exists U:set, exists M:set, U :e (metric_topology X d) /\ U <> Empty /\
    M :e R /\
    forall f:set, f :e FF ->
      forall x:set, x :e U -> apply_fun f x :e R.
admit.
Qed.

(** from 48 Exercise 11: is R_l a Baire space **)
(** LATEX VERSION: Determine whether _ is a Baire space. **)
(** FIXED: Use the existing lower limit topology constant R_lower_limit_topology. **)
Theorem ex48_11_Rl_Baire : Baire_space R R_lower_limit_topology.
admit.
Qed.

(** from 49 Exercise 1: verify properties of example functions **)
(** LATEX VERSION: Check the stated properties of the functions f, g, and k of Example 1. **)
(** note: Example 1 functions are still abstractly named; continuity is derived from membership in C(I,R) **)
(** from 49 Exercise 1: choose the named example functions f, g, k **)
(** LATEX VERSION: Example 1 defines three specific continuous maps f,g,k from [0,1] to R. **)
(** note: the explicit formulas are not formalized; we select functions via Eps_i from C(I,R) **)
Definition ex49_example1_f : set := Eps_i (fun f:set => f :e C_I_R).
Definition ex49_example1_g : set := Eps_i (fun g:set => g :e C_I_R).
Definition ex49_example1_k : set := Eps_i (fun k:set => k :e C_I_R).

(** helper: C(I,R) is nonempty **)
(** LATEX VERSION: Constant functions are continuous, so C(I,R) is nonempty. **)
Theorem C_I_R_nonempty : exists f:set, f :e C_I_R.
set f0 := const_fun unit_interval 0.
witness f0.
prove f0 :e C_I_R.
apply (SepI (function_space unit_interval R) (fun f1:set => continuous_real_on_I f1) f0).
- prove f0 :e function_space unit_interval R.
  claim Hpow: f0 :e Power (setprod unit_interval R).
  { prove f0 :e Power (setprod unit_interval R).
    apply (PowerI (setprod unit_interval R) f0).
    let p. assume Hp: p :e f0.
    prove p :e setprod unit_interval R.
    apply (ReplE_impred unit_interval (fun a:set => (a,0)) p Hp (p :e setprod unit_interval R)).
    let a. assume Ha: a :e unit_interval. assume Heq: p = (a,0).
    rewrite Heq.
    exact (tuple_2_setprod unit_interval R a Ha 0 real_0). }
  claim Hfun: function_on f0 unit_interval R.
  { let x. assume Hx: x :e unit_interval.
    prove apply_fun f0 x :e R.
    rewrite (const_fun_apply unit_interval 0 x Hx).
    exact real_0. }
  exact (SepI (Power (setprod unit_interval R))
              (fun f:set => function_on f unit_interval R)
              f0
              Hpow
              Hfun).
- prove continuous_real_on_I f0.
  exact (const_fun_continuous unit_interval I_topology R R_standard_topology 0
           I_topology_on R_standard_topology_is_topology real_0).
Qed.

Theorem ex49_example1_f_in_C_I_R : ex49_example1_f :e C_I_R.
exact (Eps_i_ex (fun f:set => f :e C_I_R) C_I_R_nonempty).
Qed.
Theorem ex49_example1_g_in_C_I_R : ex49_example1_g :e C_I_R.
exact (Eps_i_ex (fun g:set => g :e C_I_R) C_I_R_nonempty).
Qed.
Theorem ex49_example1_k_in_C_I_R : ex49_example1_k :e C_I_R.
exact (Eps_i_ex (fun k:set => k :e C_I_R) C_I_R_nonempty).
Qed.

Theorem ex49_1_verify_example_functions :
  continuous_map unit_interval I_topology R R_standard_topology ex49_example1_f /\
  continuous_map unit_interval I_topology R R_standard_topology ex49_example1_g /\
  continuous_map unit_interval I_topology R R_standard_topology ex49_example1_k.
claim Hf: continuous_real_on_I ex49_example1_f.
{ exact (SepE2 (function_space unit_interval R) (fun f0:set => continuous_real_on_I f0)
               ex49_example1_f
               ex49_example1_f_in_C_I_R). }
claim Hg: continuous_real_on_I ex49_example1_g.
{ exact (SepE2 (function_space unit_interval R) (fun g0:set => continuous_real_on_I g0)
               ex49_example1_g
               ex49_example1_g_in_C_I_R). }
claim Hk: continuous_real_on_I ex49_example1_k.
{ exact (SepE2 (function_space unit_interval R) (fun k0:set => continuous_real_on_I k0)
               ex49_example1_k
               ex49_example1_k_in_C_I_R). }
prove (continuous_map unit_interval I_topology R R_standard_topology ex49_example1_f /\
       continuous_map unit_interval I_topology R R_standard_topology ex49_example1_g)
      /\ continuous_map unit_interval I_topology R R_standard_topology ex49_example1_k.
apply andI.
- prove continuous_map unit_interval I_topology R R_standard_topology ex49_example1_f /\
         continuous_map unit_interval I_topology R R_standard_topology ex49_example1_g.
  apply andI.
  + exact Hf.
  + exact Hg.
- exact Hk.
Qed.

(** from 49 Exercise 2: construct continuous function in U_n with bounded values **)
(** LATEX VERSION: Given n and , define continuous f:I such that fU and |f(x)| for all x. **)
(** stub: the analytic inequalities are not expanded here **)
Theorem ex49_2_construct_bounded_function : forall n:set, forall eps:set,
  n :e omega ->
  2 c= n ->
  eps :e R ->
  exists f:set,
    continuous_map unit_interval I_topology R R_standard_topology f /\
    (forall x:set, x :e unit_interval -> apply_fun f x :e R) /\
    f :e U_n n /\
    (forall x:set, x :e unit_interval -> Rle (Abs (apply_fun f x)) eps).
admit.
Qed.

(** from 50 Exercises: dimension theory introduction (placeholder) **) 
(** LATEX VERSION: Exercises introducing dimension theory concepts. **)
Definition ex50_dimension_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx n:set,
      p = setprod (setprod X Tx) n /\ topology_on X Tx /\ ordinal n}.
