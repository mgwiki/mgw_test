(* Parameter Eps_i "174b78e53fc239e8c2aab4ab5a996a27e3e5741e88070dad186e05fb13f275e5" *)
Parameter Eps_i : (set->prop)->set.
Axiom Eps_i_ax : forall P:set->prop, forall x:set, P x -> P (Eps_i P).
Definition True : prop := forall p:prop, p -> p.
Definition False : prop := forall p:prop, p.
Definition not : prop -> prop := fun A:prop => A -> False.
(* Unicode ~ "00ac" *)
Prefix ~ 700 := not.
Definition and : prop -> prop -> prop := fun A B:prop => forall p:prop, (A -> B -> p) -> p.
(* Unicode /\ "2227" *)
Infix /\ 780 left := and.
Definition or : prop -> prop -> prop := fun A B:prop => forall p:prop, (A -> p) -> (B -> p) -> p.
(* Unicode \/ "2228" *)
Infix \/ 785 left := or.
Definition iff : prop -> prop -> prop := fun A B:prop => and (A -> B) (B -> A).
(* Unicode <-> "2194" *)
Infix <-> 805 := iff.
Section Eq.
Variable A:SType.
Definition eq : A->A->prop := fun x y:A => forall Q:A->A->prop, Q x y -> Q y x.
Definition neq : A->A->prop := fun x y:A => ~ eq x y.
End Eq.
Infix = 502 := eq.
(* Unicode <> "2260" *)
Infix <> 502 := neq.
Section FE.
Variable A B : SType.
Axiom func_ext : forall f g : A -> B , (forall x : A , f x = g x) -> f = g.
End FE.
Section Ex.
Variable A:SType.
Definition ex : (A->prop)->prop := fun Q:A->prop => forall P:prop, (forall x:A, Q x -> P) -> P.
End Ex.
(* Unicode exists "2203" *)
Binder+ exists , := ex.
Axiom prop_ext : forall p q:prop, iff p q -> p = q.
Parameter In:set->set->prop.
Definition Subq : set -> set -> prop := fun A B => forall x :e A, x :e B.
Axiom set_ext : forall X Y:set, X c= Y -> Y c= X -> X = Y.
Axiom In_ind : forall P:set->prop, (forall X:set, (forall x :e X, P x) -> P X) -> forall X:set, P X.
Binder+ exists , := ex; and.
Parameter Empty : set.
Axiom EmptyAx : ~exists x:set, x :e Empty.
(* Unicode Union "22C3" *)
Parameter Union : set->set.
Axiom UnionEq : forall X x, x :e Union X <-> exists Y, x :e Y /\ Y :e X.
(* Unicode Power "1D4AB" *)
Parameter Power : set->set.
Axiom PowerEq : forall X Y:set, Y :e Power X <-> Y c= X.
Parameter Repl : set -> (set -> set) -> set.
Notation Repl Repl.
Axiom ReplEq : forall A:set, forall F:set->set, forall y:set, y :e {F x|x :e A} <-> exists x :e A, y = F x.
Definition TransSet : set->prop := fun U:set => forall x :e U, x c= U.
Definition Union_closed : set->prop := fun U:set => forall X:set, X :e U -> Union X :e U.
Definition Power_closed : set->prop := fun U:set => forall X:set, X :e U -> Power X :e U.
Definition Repl_closed : set->prop := fun U:set => forall X:set, X :e U -> forall F:set->set,
   (forall x:set, x :e X -> F x :e U) -> {F x|x :e X} :e U.
Definition ZF_closed : set->prop := fun U:set =>
   Union_closed U
/\ Power_closed U
/\ Repl_closed U.
Parameter UnivOf : set->set.
Axiom UnivOf_In : forall N:set, N :e UnivOf N.
Axiom UnivOf_TransSet : forall N:set, TransSet (UnivOf N).
Axiom UnivOf_ZF_closed : forall N:set, ZF_closed (UnivOf N).
Axiom UnivOf_Min : forall N U:set, N :e U
  -> TransSet U
  -> ZF_closed U
  -> UnivOf N c= U.

Theorem andI : forall (A B : prop), A -> B -> A /\ B.
exact (fun A B a b P H => H a b).
Qed.

Theorem orIL : forall (A B : prop), A -> A \/ B.
exact (fun A B a P H1 H2 => H1 a).
Qed.

Theorem orIR : forall (A B : prop), B -> A \/ B.
exact (fun A B b P H1 H2 => H2 b).
Qed.

Theorem iffI : forall A B:prop, (A -> B) -> (B -> A) -> (A <-> B).
exact (fun A B => andI (A -> B) (B -> A)).
Qed.

Theorem pred_ext : forall P Q:set -> prop, (forall x, P x <-> Q x) -> P = Q.
let P Q. assume H1. apply func_ext set prop.
let x. apply prop_ext.
prove P x <-> Q x. exact H1 x.
Qed.

Definition nIn : set->set->prop :=
fun x X => ~In x X.
(* Unicode /:e "2209" *)
Infix /:e 502 := nIn.

Theorem EmptyE : forall x:set, x /:e Empty.
let x. assume H.
apply EmptyAx.
witness x. exact H.
Qed.

Theorem PowerI : forall X Y:set, Y c= X -> Y :e Power X.
let X Y. apply PowerEq X Y. exact (fun _ H => H).
Qed.

Theorem Subq_Empty : forall X:set, Empty c= X.
exact (fun (X x : set) (H : x :e Empty) => EmptyE x H (x :e X)).
Qed.

Theorem Empty_In_Power : forall X:set, Empty :e Power X.
exact (fun X : set => PowerI X Empty (Subq_Empty X)).
Qed.


Theorem xm : forall P:prop, P \/ ~P.
let P:prop.
set p1 := fun x : set => x = Empty \/ P.
set p2 := fun x : set => x <> Empty \/ P.
claim L1:p1 Empty.
{ prove (Empty = Empty \/ P). apply orIL. exact (fun q H => H). }
claim L2: (Eps_i p1) = Empty \/ P.
{ exact (Eps_i_ax p1 Empty L1). }
claim L3:p2 (Power Empty).
{ prove ~(Power Empty = Empty) \/ P. apply orIL.
  assume H1: Power Empty = Empty.
  apply EmptyE Empty.
  prove Empty :e Empty.
  rewrite <- H1 at 2. apply Empty_In_Power.
}
claim L4: Eps_i p2 <> Empty \/ P.
{ exact (Eps_i_ax p2 (Power Empty) L3). }
apply L2.
- assume H1: Eps_i p1 = Empty.
  apply L4.
  + assume H2: Eps_i p2 <> Empty.
    prove P \/ ~ P.
    apply orIR.
    prove ~ P.
    assume H3 : P.
    claim L5:p1 = p2.
    { apply pred_ext. let x. apply iffI.
      - assume H4.
        prove (~(x = Empty) \/ P).
        apply orIR.
        prove P.
        exact H3.
      - assume H4.
        prove (x = Empty \/ P).
        apply orIR.
        prove P.
        exact H3.
    }
    apply H2. rewrite <- L5. exact H1.
  + assume H2:P.
    prove P \/ ~ P.
    apply orIL.
    prove P.
    exact H2.
- assume H1:P.
    prove P \/ ~ P.
    apply orIL.
    prove P.
    exact H1.
Qed.

Theorem FalseE : False -> forall p:prop, p.
exact (fun H => H).
Qed.

Theorem andEL : forall (A B : prop), A /\ B -> A.
exact (fun A B H => H A (fun a b => a)).
Qed.

Theorem andER : forall (A B : prop), A /\ B -> B.
exact (fun A B H => H B (fun a b => b)).
Qed.

Section PropN.
Variable P1 P2 P3:prop.

Theorem and3I : P1 -> P2 -> P3 -> P1 /\ P2 /\ P3.
exact (fun H1 H2 H3 => andI (P1 /\ P2) P3 (andI P1 P2 H1 H2) H3).
Qed.

Theorem and3E : P1 /\ P2 /\ P3 -> (forall p:prop, (P1 -> P2 -> P3 -> p) -> p).
exact (fun u p H => u p (fun u u3 => u p (fun u1 u2 => H u1 u2 u3))).
Qed.

Theorem or3I1 : P1 -> P1 \/ P2 \/ P3.
exact (fun u => orIL (P1 \/ P2) P3 (orIL P1 P2 u)).
Qed.

Theorem or3I2 : P2 -> P1 \/ P2 \/ P3.
exact (fun u => orIL (P1 \/ P2) P3 (orIR P1 P2 u)).
Qed.

Theorem or3I3 : P3 -> P1 \/ P2 \/ P3.
exact (orIR (P1 \/ P2) P3).
Qed.

Theorem or3E : P1 \/ P2 \/ P3 -> (forall p:prop, (P1 -> p) -> (P2 -> p) -> (P3 -> p) -> p).
exact (fun u p H1 H2 H3 => u p (fun u => u p H1 H2) H3).
Qed.

Variable P4:prop.

Theorem and4I : P1 -> P2 -> P3 -> P4 -> P1 /\ P2 /\ P3 /\ P4.
exact (fun H1 H2 H3 H4 => andI (P1 /\ P2 /\ P3) P4 (and3I H1 H2 H3) H4).
Qed.

Variable P5:prop.

Theorem and5I : P1 -> P2 -> P3 -> P4 -> P5 -> P1 /\ P2 /\ P3 /\ P4 /\ P5.
exact (fun H1 H2 H3 H4 H5 => andI (P1 /\ P2 /\ P3 /\ P4) P5 (and4I H1 H2 H3 H4) H5).
Qed.

Variable P6:prop.

Theorem and6I: P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6.
exact (fun H1 H2 H3 H4 H5 H6 => andI (P1 /\ P2 /\ P3 /\ P4 /\ P5) P6 (and5I H1 H2 H3 H4 H5) H6).
Qed.

Variable P7:prop.

Theorem and7I: P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P7 -> P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6 /\ P7.
exact (fun H1 H2 H3 H4 H5 H6 H7 => andI (P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6) P7 (and6I H1 H2 H3 H4 H5 H6) H7).
Qed.

End PropN.

Theorem not_or_and_demorgan : forall A B:prop, ~(A \/ B) -> ~A /\ ~B.
let A B.
assume u : ~(A \/ B).
apply andI.
- prove ~A. assume a:A. exact (u (orIL A B a)).
- prove ~B. assume b:B. exact (u (orIR A B b)).
Qed.

Theorem not_ex_all_demorgan_i : forall P:set->prop, (~exists x, P x) -> forall x, ~P x.
let P. assume H1. let x. assume H2. apply H1.
witness x.
exact H2.
Qed.

Theorem iffEL : forall A B:prop, (A <-> B) -> A -> B.
exact (fun A B => andEL (A -> B) (B -> A)).
Qed.

Theorem iffER : forall A B:prop, (A <-> B) -> B -> A.
exact (fun A B => andER (A -> B) (B -> A)).
Qed.

Theorem iff_refl : forall A:prop, A <-> A.
exact (fun A:prop => andI (A -> A) (A -> A) (fun H : A => H) (fun H : A => H)).
Qed.

Theorem iff_sym : forall A B:prop, (A <-> B) -> (B <-> A).
let A B.
assume H1: (A -> B) /\ (B -> A).
apply H1.
assume H2: A -> B.
assume H3: B -> A.
exact iffI B A H3 H2.
Qed.

Theorem iff_trans : forall A B C: prop, (A <-> B) -> (B <-> C) -> (A <-> C).
let A B C.
assume H1: A <-> B.
assume H2: B <-> C.
apply H1.
assume H3: A -> B.
assume H4: B -> A.
apply H2.
assume H5: B -> C.
assume H6: C -> B.
exact (iffI A C (fun H => H5 (H3 H)) (fun H => H4 (H6 H))).
Qed.

Theorem eq_i_tra : forall x y z, x = y -> y = z -> x = z.
let x y z. assume H1 H2. rewrite <- H2. exact H1.
Qed.

Theorem neq_i_sym: forall x y, x <> y -> y <> x.
let x y. assume H1 H2. apply H1. symmetry. exact H2.
Qed.

Theorem Eps_i_ex : forall P:set -> prop, (exists x, P x) -> P (Eps_i P).
let P. assume H1. apply H1.
let x. assume H2.
exact Eps_i_ax P x H2.
Qed.

Theorem prop_ext_2 : forall p q:prop, (p -> q) -> (q -> p) -> p = q.
let p q. assume H1 H2. apply prop_ext. apply iffI.
- exact H1.
- exact H2.
Qed.

Theorem Subq_ref : forall X:set, X c= X.
exact (fun (X x : set) (H : x :e X) => H).
Qed.

Theorem Subq_tra : forall X Y Z:set, X c= Y -> Y c= Z -> X c= Z.
exact (fun (X Y Z : set) (H1 : X c= Y) (H2 : Y c= Z) (x : set) (H : x :e X) => (H2 x (H1 x H))).
Qed.

Theorem Empty_Subq_eq : forall X:set, X c= Empty -> X = Empty.
let X.
assume H1: X c= Empty.
apply set_ext.
- exact H1.
- exact (Subq_Empty X).
Qed.

Theorem Empty_eq : forall X:set, (forall x, x /:e X) -> X = Empty.
let X.
assume H1: forall x, x /:e X.
apply Empty_Subq_eq.
let x.
assume H2: x :e X.
prove False.
exact (H1 x H2).
Qed.

Theorem UnionI : forall X x Y:set, x :e Y -> Y :e X -> x :e Union X.
let X x Y.
assume H1: x :e Y.
assume H2: Y :e X.
apply UnionEq X x.
assume _ H3. apply H3.
prove exists Y:set, x :e Y /\ Y :e X.
witness Y.
apply andI.
- exact H1.
- exact H2.
Qed.

Theorem UnionE : forall X x:set, x :e Union X -> exists Y:set, x :e Y /\ Y :e X.
exact (fun X x : set => iffEL (x :e Union X) (exists Y:set, x :e Y /\ Y :e X) (UnionEq X x)).
Qed.

Theorem UnionE_impred : forall X x:set, x :e Union X -> forall p:prop, (forall Y:set, x :e Y -> Y :e X -> p) -> p.
let X x. assume H1.
let p. assume Hp.
apply UnionE X x H1.
let x. assume H2. apply H2.
exact Hp x.
Qed.

Theorem PowerE : forall X Y:set, Y :e Power X -> Y c= X.
let X Y. apply PowerEq X Y. exact (fun H _ => H).
Qed.

Theorem Self_In_Power : forall X:set, X :e Power X.
exact (fun X : set => PowerI X X (Subq_ref X)).
Qed.

Theorem dneg : forall P:prop, ~~P -> P.
let P. assume H1.
apply xm P.
- exact (fun H => H).
- assume H2: ~P.
  prove False.
  exact H1 H2.
Qed.

Theorem not_all_ex_demorgan_i : forall P:set->prop, ~(forall x, P x) -> exists x, ~P x.
let P.
assume u:~forall x, P x.
apply dneg.
assume v:~exists x, ~P x.
apply u. let x. apply dneg.
assume w:~P x. 
exact (not_ex_all_demorgan_i (fun x => ~P x) v x w).
Qed.

Theorem eq_or_nand : or = (fun (x y:prop) => ~(~x /\ ~y)).
apply func_ext prop (prop -> prop).
let x. apply func_ext prop prop.
let y. apply prop_ext_2.
- assume H1: x \/ y.
  assume H2: ~x /\ ~y.
  apply H2. assume H3 H4. exact (H1 False H3 H4).
- assume H1:~(~x /\ ~y).
  apply (xm x).
  + assume H2: x. apply orIL. exact H2.
  + assume H2: ~x. apply (xm y).
    * assume H3: y. apply orIR. exact H3.
    * assume H3: ~y. apply H1. exact (andI (~x) (~y) H2 H3).
Qed.

(* Parameter exactly1of2 "3578b0d6a7b318714bc5ea889c6a38cf27f08eaccfab7edbde3cb7a350cf2d9b" "163602f90de012a7426ee39176523ca58bc964ccde619b652cb448bd678f7e21" *)
Definition exactly1of2 : prop->prop->prop := fun A B:prop =>
A /\ ~B \/ ~A /\ B.

Theorem exactly1of2_I1 : forall A B:prop, A -> ~B -> exactly1of2 A B.
let A B.
assume HA: A.
assume HB: ~B.
prove A /\ ~B \/ ~A /\ B.
apply orIL.
prove A /\ ~B.
exact (andI A (~B) HA HB).
Qed.

Theorem exactly1of2_I2 : forall A B:prop, ~A -> B -> exactly1of2 A B.
let A B.
assume HA: ~A.
assume HB: B.
prove A /\ ~B \/ ~A /\ B.
apply orIR.
prove ~A /\ B.
exact (andI (~A) B HA HB).
Qed.

Theorem exactly1of2_E : forall A B:prop, exactly1of2 A B ->
forall p:prop,
(A -> ~B -> p) ->
(~A -> B -> p) ->
p.
let A B.
assume H1: exactly1of2 A B.
let p.
assume H2 : A -> ~B -> p.
assume H3 : ~A -> B -> p.
apply (H1 p).
- exact (fun H4 : A /\ ~B => H4 p H2).
- exact (fun H4 : ~A /\ B => H4 p H3).
Qed.

Theorem exactly1of2_or : forall A B:prop, exactly1of2 A B -> A \/ B.
let A B.
assume H1: exactly1of2 A B.
apply (exactly1of2_E A B H1 (A \/ B)).
- exact (fun (HA : A) (_ : ~B) => orIL A B HA).
- exact (fun (_ : ~A) (HB : B) => orIR A B HB).
Qed.

Theorem ReplI : forall A:set, forall F:set->set, forall x:set, x :e A -> F x :e {F x|x :e A}.
let A F x. assume H1.
apply ReplEq A F (F x).
assume _ H2. apply H2.
prove exists x' :e A, F x = F x'.
witness x. apply andI.
- exact H1.
- exact (fun q H => H).
Qed.

Theorem ReplE : forall A:set, forall F:set->set, forall y:set, y :e {F x|x :e A} -> exists x :e A, y = F x.
let A F y. apply ReplEq A F y. exact (fun H _ => H).
Qed.

Theorem ReplE_impred : forall A:set, forall F:set->set, forall y:set, y :e {F x|x :e A} -> forall p:prop, (forall x:set, x :e A -> y = F x -> p) -> p.
let A F y. assume H1.
apply ReplE A F y H1.
let x. assume H2. apply H2.
assume H3 H4.
let p. assume Hp.
exact Hp x H3 H4.
Qed.

Theorem ReplE' : forall X, forall f:set -> set, forall p:set -> prop, (forall x :e X, p (f x)) -> forall y :e {f x|x :e X}, p y.
let X f p. assume H1. let y. assume Hy.
apply ReplE_impred X f y Hy.
let x. assume Hx: x :e X. assume Hx2: y = f x.
prove p y. rewrite Hx2. exact H1 x Hx.
Qed.

Theorem Repl_Empty : forall F:set -> set, {F x|x :e Empty} = Empty.
let F. apply (Empty_eq {F x|x :e Empty}).
let y.
assume H1: y :e {F x|x :e Empty}.
apply (ReplE_impred Empty F y H1).
let x.
assume H2: x :e Empty.
assume _.
exact (EmptyE x H2).
Qed.

Theorem ReplEq_ext_sub : forall X, forall F G:set -> set, (forall x :e X, F x = G x) -> {F x|x :e X} c= {G x|x :e X}.
let X F G.
assume H1: forall x :e X, F x = G x.
let y. assume Hy: y :e {F x|x :e X}.
apply ReplE_impred X F y Hy.
let x. assume Hx: x :e X.
assume H2: y = F x.
prove y :e {G x|x :e X}.
rewrite H2.
prove F x :e {G x|x :e X}.
rewrite H1 x Hx.
prove G x :e {G x|x :e X}.
apply ReplI. exact Hx.
Qed.

Theorem ReplEq_ext : forall X, forall F G:set -> set, (forall x :e X, F x = G x) -> {F x|x :e X} = {G x|x :e X}.
let X F G.
assume H1: forall x :e X, F x = G x.
apply set_ext.
- exact ReplEq_ext_sub X F G H1.
- apply ReplEq_ext_sub X G F.
  let x. assume Hx. symmetry. exact H1 x Hx.
Qed.

Theorem Repl_inv_eq : forall P:set -> prop, forall f g:set -> set,
    (forall x, P x -> g (f x) = x)
 -> forall X, (forall x :e X, P x) -> {g y|y :e {f x|x :e X}} = X.
let P f g. assume H1. let X. assume HX.
apply set_ext.
- let w. assume Hw: w :e {g y|y :e {f x|x :e X}}.
  apply ReplE_impred {f x|x :e X} g w Hw.
  let y. assume Hy: y :e {f x|x :e X}.
  assume Hwy: w = g y.
  apply ReplE_impred X f y Hy.
  let x. assume Hx: x :e X.
  assume Hyx: y = f x.
  prove w :e X. rewrite Hwy. rewrite Hyx.
  prove g (f x) :e X.
  rewrite H1 x (HX x Hx).
  exact Hx.
- let x. assume Hx: x :e X.
  rewrite <- H1 x (HX x Hx).
  prove g (f x) :e {g y|y :e {f x|x :e X}}.
  apply ReplI.
  prove f x :e {f x|x :e X}.
  apply ReplI. exact Hx.
Qed.

Theorem Repl_invol_eq : forall P:set -> prop, forall f:set -> set,
    (forall x, P x -> f (f x) = x)
 -> forall X, (forall x :e X, P x) -> {f y|y :e {f x|x :e X}} = X.
let P f. assume H1.
exact Repl_inv_eq P f f H1.
Qed.

(* Parameter If_i "8c8f550868df4fdc93407b979afa60092db4b1bb96087bc3c2f17fadf3f35cbf" "b8ff52f838d0ff97beb955ee0b26fad79602e1529f8a2854bda0ecd4193a8a3c" *)
Definition If_i : prop->set->set->set := (fun p x y => Eps_i (fun z:set => p /\ z = x \/ ~p /\ z = y)).
Notation IfThenElse If_i.

Theorem If_i_correct : forall p:prop, forall x y:set,
p /\ (if p then x else y) = x \/ ~p /\ (if p then x else y) = y.
let p x y.
apply (xm p).
- assume H1: p.
  claim L1: p /\ x = x \/ ~p /\ x = y.
  {
    apply orIL. apply andI.
    - exact H1.
    - reflexivity.
  }
  exact (Eps_i_ax (fun z : set => p /\ z = x \/ ~ p /\ z = y) x L1).
- assume H1: ~p.
  claim L1: p /\ y = x \/ ~p /\ y = y.
  {
    apply orIR. apply andI.
    - exact H1.
    - reflexivity.
  }
  exact (Eps_i_ax (fun z : set => p /\ z = x \/ ~ p /\ z = y) y L1).
Qed.

Theorem If_i_0 : forall p:prop, forall x y:set,
~ p -> (if p then x else y) = y.
let p x y.
assume H1: ~p.
apply (If_i_correct p x y).
- assume H2: p /\ (if p then x else y) = x.
  exact (H1 (andEL p ((if p then x else y) = x) H2) ((if p then x else y) = y)).
- assume H2: ~p /\ (if p then x else y) = y.
  exact (andER (~p) ((if p then x else y) = y) H2).
Qed.

Theorem If_i_1 : forall p:prop, forall x y:set,
p -> (if p then x else y) = x.
let p x y.
assume H1: p.
apply (If_i_correct p x y).
- assume H2: p /\ (if p then x else y) = x.
  exact (andER p ((if p then x else y) = x) H2).
- assume H2: ~p /\ (if p then x else y) = y.
  exact (andEL (~p) ((if p then x else y) = y) H2 H1 ((if p then x else y) = x)).
Qed.

Theorem If_i_or : forall p:prop, forall x y:set, (if p then x else y) = x \/ (if p then x else y) = y.
let p x y.
apply (xm p).
- assume H1: p. apply orIL. exact (If_i_1 p x y H1).
- assume H1: ~p. apply orIR. exact (If_i_0 p x y H1).
Qed.

(* Parameter UPair "80aea0a41bb8a47c7340fe8af33487887119c29240a470e920d3f6642b91990d" "74243828e4e6c9c0b467551f19c2ddaebf843f72e2437cc2dea41d079a31107f" *)
Definition UPair : set->set->set :=
fun y z => {if Empty :e X then y else z | X :e Power (Power Empty)}.
Notation SetEnum2 UPair.

Theorem UPairE :
forall x y z:set, x :e {y,z} -> x = y \/ x = z.
let x y z.
assume H1: x :e {y,z}.
apply (ReplE (Power (Power Empty)) (fun X => if Empty :e X then y else z) x H1).
let X.
assume H2: X :e Power (Power Empty) /\ x = if Empty :e X then y else z.
claim L1: x = if Empty :e X then y else z.
{ exact (andER (X :e Power (Power Empty)) (x = if Empty :e X then y else z) H2). }
apply (If_i_or (Empty :e X) y z).
- assume H3: (if Empty :e X then y else z) = y.
  apply orIL.
  prove x = y.
  rewrite <- H3. exact L1.
- assume H3: (if Empty :e X then y else z) = z.
  apply orIR.
  prove x = z.
  rewrite <- H3. exact L1.
Qed.

Theorem UPairI1 : forall y z:set, y :e {y,z}.
let y z.
prove y :e {y,z}.
rewrite <- (If_i_1 (Empty :e Power Empty) y z (Empty_In_Power Empty)) at 1.
prove (if Empty :e Power Empty then y else z) :e {y,z}.
prove (if Empty :e Power Empty then y else z) :e {if Empty :e X then y else z | X :e Power (Power Empty)}.
apply (ReplI (Power (Power Empty)) (fun X : set => if (Empty :e X) then y else z) (Power Empty)).
prove Power Empty :e Power (Power Empty).
exact (Self_In_Power (Power Empty)).
Qed.

Theorem UPairI2 : forall y z:set, z :e {y,z}.
let y z.
prove z :e {y,z}.
rewrite <- (If_i_0 (Empty :e Empty) y z (EmptyE Empty)) at 1.
prove (if Empty :e Empty then y else z) :e {y,z}.
prove (if Empty :e Empty then y else z) :e {if Empty :e X then y else z | X :e Power (Power Empty)}.
apply (ReplI (Power (Power Empty)) (fun X : set => if (Empty :e X) then y else z) Empty).
prove Empty :e Power (Power Empty).
exact (Empty_In_Power (Power Empty)).
Qed.

(* Parameter Sing "158bae29452f8cbf276df6f8db2be0a5d20290e15eca88ffe1e7b41d211d41d7" "bd01a809e97149be7e091bf7cbb44e0c2084c018911c24e159f585455d8e6bd0" *)
Definition Sing : set -> set := fun x => {x,x}.
Notation SetEnum1 Sing.

Theorem SingI : forall x:set, x :e {x}. 
exact (fun x : set => UPairI1 x x).
Qed.

Theorem SingE : forall x y:set, y :e {x} -> y = x. 
exact (fun x y H => UPairE y x x H (y = x) (fun H => H) (fun H => H)).
Qed.

(* Parameter binunion "0a445311c45f0eb3ba2217c35ecb47f122b2301b2b80124922fbf03a5c4d223e" "5e1ac4ac93257583d0e9e17d6d048ff7c0d6ccc1a69875b2a505a2d4da305784" *)
Definition binunion : set -> set -> set := fun X Y => Union {X,Y}.
(* Unicode :\/: "222a" *)
Infix :\/: 345 left := binunion.

Theorem binunionI1 : forall X Y z:set, z :e X -> z :e X :\/: Y.
let X Y z.
assume H1: z :e X.
prove z :e X :\/: Y.
prove z :e Union {X,Y}.
apply (UnionI {X,Y} z X).
- prove z :e X. exact H1.
- prove X :e {X,Y}. exact (UPairI1 X Y).
Qed.

Theorem binunionI2 : forall X Y z:set, z :e Y -> z :e X :\/: Y.
let X Y z.
assume H1: z :e Y.
prove z :e X :\/: Y.
prove z :e Union {X,Y}.
apply (UnionI {X,Y} z Y).
- prove z :e Y. exact H1.
- prove Y :e {X,Y}. exact (UPairI2 X Y).
Qed.

Theorem binunionE : forall X Y z:set, z :e X :\/: Y -> z :e X \/ z :e Y.
let X Y z.
assume H1: z :e X :\/: Y.
prove z :e X \/ z :e Y.
apply (UnionE_impred {X,Y} z H1).
let Z.
assume H2: z :e Z.
assume H3: Z :e {X,Y}.
apply (UPairE Z X Y H3).
- assume H4: Z = X.
  apply orIL.
  prove z :e X.
  rewrite <- H4.
  prove z :e Z.
  exact H2.
- assume H4: Z = Y.
  apply orIR.
  prove z :e Y.
  rewrite <- H4.
  prove z :e Z.
  exact H2.
Qed.

Theorem binunionE' : forall X Y z, forall p:prop, (z :e X -> p) -> (z :e Y -> p) -> (z :e X :\/: Y -> p).
let X Y z p. assume H1 H2 Hz.
apply binunionE X Y z Hz.
- assume H3: z :e X. exact H1 H3.
- assume H3: z :e Y. exact H2 H3.
Qed.

Theorem binunion_asso:forall X Y Z:set, X :\/: (Y :\/: Z) = (X :\/: Y) :\/: Z.
let X Y Z. apply set_ext.
- let w. assume H1: w :e X :\/: (Y :\/: Z).
  prove w :e (X :\/: Y) :\/: Z.
  apply (binunionE X (Y :\/: Z) w H1).
  + assume H2: w :e X.
    apply binunionI1. apply binunionI1. exact H2.
  + assume H2: w :e Y :\/: Z.
    apply (binunionE Y Z w H2).
    * assume H3: w :e Y.
      apply binunionI1. apply binunionI2. exact H3.
    * assume H3: w :e Z.
      apply binunionI2. exact H3.
- let w. assume H1: w :e (X :\/: Y) :\/: Z.
  prove w :e X :\/: (Y :\/: Z).
  apply (binunionE (X :\/: Y) Z w H1).
  + assume H2: w :e X :\/: Y.
    apply (binunionE X Y w H2).
    * assume H3: w :e X.
      apply binunionI1. exact H3.
    * assume H3: w :e Y.
      apply binunionI2. apply binunionI1. exact H3.
  + assume H2: w :e Z.
    apply binunionI2. apply binunionI2. exact H2.
Qed.

Theorem binunion_com_Subq:forall X Y:set, X :\/: Y c= Y :\/: X.
let X Y w. assume H1: w :e X :\/: Y.
prove w :e Y :\/: X.
apply (binunionE X Y w H1).
- assume H2: w :e X. apply binunionI2. exact H2.
- assume H2: w :e Y. apply binunionI1. exact H2.
Qed.

Theorem binunion_com:forall X Y:set, X :\/: Y = Y :\/: X.
let X Y. apply set_ext.
- exact (binunion_com_Subq X Y).
- exact (binunion_com_Subq Y X).
Qed.

Theorem binunion_idl:forall X:set, Empty :\/: X = X.
let X. apply set_ext.
- let x. assume H1: x :e Empty :\/: X.
  apply (binunionE Empty X x H1).
  + assume H2: x :e Empty. prove False. exact (EmptyE x H2).
  + assume H2: x :e X. exact H2.
- let x. assume H2: x :e X. prove x :e Empty :\/: X. apply binunionI2. exact H2.
Qed.

Theorem binunion_idr:forall X:set, X :\/: Empty = X.
let X.
rewrite (binunion_com X Empty).
exact (binunion_idl X).
Qed.

Theorem binunion_Subq_1: forall X Y:set, X c= X :\/: Y.
exact binunionI1.
Qed.

Theorem binunion_Subq_2: forall X Y:set, Y c= X :\/: Y.
exact binunionI2.
Qed.

Theorem binunion_Subq_min: forall X Y Z:set, X c= Z -> Y c= Z -> X :\/: Y c= Z.
let X Y Z.
assume H1: X c= Z.
assume H2: Y c= Z.
let w.
assume H3: w :e X :\/: Y.
apply (binunionE X Y w H3).
- assume H4: w :e X. exact (H1 w H4).
- assume H4: w :e Y. exact (H2 w H4).
Qed.

Theorem Subq_binunion_eq:forall X Y, (X c= Y) = (X :\/: Y = Y).
let X Y. apply prop_ext_2.
- assume H1: X c= Y.
  prove X :\/: Y = Y.
  apply set_ext.
  + prove X :\/: Y c= Y. apply (binunion_Subq_min X Y Y).
    * prove X c= Y. exact H1.
    * prove Y c= Y. exact (Subq_ref Y).
  + prove Y c= X :\/: Y. exact (binunion_Subq_2 X Y).
- assume H1: X :\/: Y = Y.
  prove X c= Y.
  rewrite <- H1.
  prove X c= X :\/: Y.
  exact (binunion_Subq_1 X Y).
Qed.

Definition SetAdjoin : set->set->set := fun X y => X :\/: {y}.
Notation SetEnum Empty Sing UPair SetAdjoin.
(* Parameter famunion "d772b0f5d472e1ef525c5f8bd11cf6a4faed2e76d4eacfa455f4d65cc24ec792" "b3e3bf86a58af5d468d398d3acad61ccc50261f43c856a68f8594967a06ec07a" *)
Definition famunion:set->(set->set)->set
:= fun X F => Union {F x|x :e X}.
(* Unicode \/_ "22C3" *)
(* Subscript \/_ *)
Binder \/_ , := famunion.

Theorem famunionI:forall X:set, forall F:(set->set), forall x y:set, x :e X -> y :e F x -> y :e \/_ x :e X, F x.
exact (fun X F x y H1 H2 => UnionI (Repl X F) y (F x) H2 (ReplI X F x H1)).
Qed.

Theorem famunionE:forall X:set, forall F:(set->set), forall y:set, y :e (\/_ x :e X, F x) -> exists x :e X, y :e F x.
let X F y.
assume H1: y :e (\/_ x :e X, F x).
prove exists x :e X, y :e F x.
apply (UnionE_impred {F x|x :e X} y H1).
let Y.
assume H2: y :e Y.
assume H3: Y :e {F x|x :e X}.
apply (ReplE_impred X F Y H3).
let x.
assume H4: x :e X.
assume H5: Y = F x.
witness x.
prove x :e X /\ y :e F x.
apply andI.
- exact H4.
- prove y :e F x.
  rewrite <- H5.
  exact H2.
Qed.

Theorem famunionE_impred : forall X : set , forall F : (set -> set) , forall y : set , y :e (\/_ x :e X , F x) -> forall p:prop, (forall x, x :e X -> y :e F x -> p) -> p.
let X F y. assume Hy.
let p. assume Hp.
apply famunionE X F y Hy.
let x. assume H1. apply H1.
exact Hp x.
Qed.

Theorem famunion_Empty: forall F:set -> set, (\/_ x :e Empty, F x) = Empty.
let F. apply Empty_Subq_eq.
let y. assume Hy: y :e \/_ x :e Empty, F x.
apply famunionE_impred Empty F y Hy.
let x. assume Hx: x :e Empty. prove False. exact EmptyE x Hx.
Qed.

Theorem famunion_Subq: forall X, forall f g:set -> set, (forall x :e X, f x c= g x) -> famunion X f c= famunion X g.
let X f g. assume Hfg.
let y. assume Hy. apply famunionE_impred X f y Hy.
let x. assume Hx.
assume H1: y :e f x.
apply famunionI X g x y Hx.
prove y :e g x.
exact Hfg x Hx y H1.
Qed.

Theorem famunion_ext: forall X, forall f g:set -> set, (forall x :e X, f x = g x) -> famunion X f = famunion X g.
let X f g. assume Hfg.
apply set_ext.
- apply famunion_Subq.
  let x. assume Hx. rewrite Hfg x Hx. apply Subq_ref.
- apply famunion_Subq.
  let x. assume Hx. rewrite Hfg x Hx. apply Subq_ref.
Qed.

Section SepSec.
Variable X:set.
Variable P:set->prop.
Let z : set := Eps_i (fun z => z :e X /\ P z).
Let F:set->set := fun x => if P x then x else z.
(* Parameter Sep "f7e63d81e8f98ac9bc7864e0b01f93952ef3b0cbf9777abab27bcbd743b6b079" "f336a4ec8d55185095e45a638507748bac5384e04e0c48d008e4f6a9653e9c44" *)
Definition Sep:set
:= if (exists z :e X, P z) then {F x|x :e X} else Empty.
End SepSec.
Notation Sep Sep.

Theorem SepI:forall X:set, forall P:(set->prop), forall x:set, x :e X -> P x -> x :e {x :e X|P x}.
let X P x.
set z : set := Eps_i (fun z => z :e X /\ P z).
set F : set->set := fun x => if P x then x else z.
assume H1: x :e X.
assume H2: P x.
claim L1: exists z :e X, P z.
{
  witness x. apply andI.
  - exact H1.
  - exact H2.
}
prove x :e {x :e X|P x}.
prove x :e if (exists z :e X, P z) then {F x|x :e X} else Empty.
(*** Note:
 Making L2 a claim and then rewriting with it succeeds, but rewrite (If_i_1 (exists z :e X, P z) {F x|x :e X} Empty L1) fails.
 The reason is that when the proposition proved by (If_i_1 (exists z :e X, P z) {F x|x :e X} Empty L1) is
 extracted by the code, the F x will be beta reduced to be if P x then x else z. After this beta reduction, the left hand side of the
 equation does not match the right hand side of the claim x :e if (exists z :e X, P z) then {F x|x :e X} else Empty.
 This is an example of how one must be careful using the apply and rewrite tactics and must sometimes give these
 kinds of explicit annotations, i.e., proving a beta-eta-delta equivalent claim.
 ***)
claim L2: (if (exists z :e X, P z) then {F x|x :e X} else Empty) = {F x|x :e X}.
{
  exact (If_i_1 (exists z :e X, P z) {F x|x :e X} Empty L1).
}
rewrite L2.
prove x :e {F x|x :e X}.
claim L3: F x = x.
{
  prove (if P x then x else z) = x.
  exact (If_i_1 (P x) x z H2).
}
rewrite <- L3.
prove F x :e {F x|x :e X}.
exact (ReplI X F x H1).
Qed.

Theorem SepE:forall X:set, forall P:(set->prop), forall x:set, x :e {x :e X|P x} -> x :e X /\ P x.
let X P x.
set z : set := Eps_i (fun z => z :e X /\ P z).
set F : set->set := fun x => if P x then x else z.
apply (xm (exists z :e X, P z)).
- assume H1: exists z :e X, P z.
  prove (x :e (if (exists z :e X, P z) then {F x|x :e X} else Empty) -> x :e X /\ P x).
  claim L1: (if (exists z :e X, P z) then {F x|x :e X} else Empty) = {F x|x :e X}.
  {
    exact (If_i_1 (exists z :e X, P z) {F x|x :e X} Empty H1).
  }
  rewrite L1.
  prove x :e {F x|x :e X} -> x :e X /\ P x.
  assume H2: x :e {F x|x :e X}.
  apply (ReplE_impred X F x H2).
  let y.
  assume H3: y :e X.
  assume H4: x = F y.
  prove x :e X /\ P x.
  apply (xm (P y)).
  + assume H5: P y.
    claim L2: x = y.
    {
      rewrite <- (If_i_1 (P y) y z H5).
      exact H4.
    }
    rewrite L2.
    prove y :e X /\ P y.
    apply andI.
    * exact H3.
    * exact H5.
  + assume H5: ~P y.
    claim L2: x = z.
    {
      rewrite <- (If_i_0 (P y) y z H5).
      exact H4.
    }
    rewrite L2.
    prove z :e X /\ P z.
    exact (Eps_i_ex (fun z => z :e X /\ P z) H1).
- assume H1: ~exists z :e X, P z.
  prove (x :e (if (exists z :e X, P z) then {F x|x :e X} else Empty) -> x :e X /\ P x).
  claim L1: (if (exists z :e X, P z) then {F x|x :e X} else Empty) = Empty.
  { exact (If_i_0 (exists z :e X, P z) {F x|x :e X} Empty H1). }
  rewrite L1.
  prove x :e Empty -> x :e X /\ P x.
  assume H2: x :e Empty.
  prove False.
  exact (EmptyE x H2).
Qed.

Theorem SepE1:forall X:set, forall P:(set->prop), forall x:set, x :e {x :e X|P x} -> x :e X.
exact (fun X P x H => SepE X P x H (x :e X) (fun H _ => H)).
Qed.

Theorem SepE2:forall X:set, forall P:(set->prop), forall x:set, x :e {x :e X|P x} -> P x.
exact (fun X P x H => SepE X P x H (P x) (fun _ H => H)).
Qed.

Theorem Sep_Empty: forall P:set -> prop, {x :e Empty|P x} = Empty.
let P. apply Empty_eq.
let x. assume Hx.
exact EmptyE x (SepE1 Empty P x Hx).
Qed.

Theorem Sep_Subq : forall X:set, forall P:set->prop, {x :e X|P x} c= X.
exact SepE1.
Qed.

Theorem Sep_In_Power : forall X:set, forall P:set->prop, {x :e X|P x} :e Power X.
exact (fun X P => PowerI X (Sep X P) (Sep_Subq X P)).
Qed.

(* Parameter ReplSep "f627d20f1b21063483a5b96e4e2704bac09415a75fed6806a2587ce257f1f2fd" "ec807b205da3293041239ff9552e2912636525180ddecb3a2b285b91b53f70d8" *)
Definition ReplSep : set->(set->prop)->(set->set)->set := fun X P F => {F x|x :e {z :e X|P z}}.
Notation ReplSep ReplSep.

Theorem ReplSepI: forall X:set, forall P:set->prop, forall F:set->set, forall x:set, x :e X -> P x -> F x :e {F x|x :e X, P x}.
exact (fun X P F x u v => ReplI (Sep X P) F x (SepI X P x u v)).
Qed.

Theorem ReplSepE:forall X:set, forall P:set->prop, forall F:set->set, forall y:set, y :e {F x|x :e X, P x} -> exists x:set, x :e X /\ P x /\ y = F x.
let X P F y.
assume H1: y :e {F x|x :e {z :e X|P z}}.
apply (ReplE {z :e X|P z} F y H1).
let x.
assume H2: x :e {z :e X|P z} /\ y = F x.
apply H2.
assume H3: x :e {z :e X|P z}.
assume H4: y = F x.
apply (SepE X P x H3).
assume H5: x :e X.
assume H6: P x.
witness x.
apply and3I.
- exact H5.
- exact H6.
- exact H4.
Qed.

Theorem ReplSepE_impred: forall X:set, forall P:set->prop, forall F:set->set, forall y:set, y :e {F x|x :e X, P x} -> forall p:prop, (forall x :e X, P x -> y = F x -> p) -> p.
let X P F y.
assume H1: y :e {F x|x :e X, P x}.
let p.
assume H2: forall x :e X, P x -> y = F x -> p.
prove p.
apply ReplSepE X P F y H1.
let x. assume H3. apply H3. assume H3. apply H3.
exact H2 x.
Qed.

(* Parameter binintersect "8cf6b1f490ef8eb37db39c526ab9d7c756e98b0eb12143156198f1956deb5036" "b2abd2e5215c0170efe42d2fa0fb8a62cdafe2c8fbd0d37ca14e3497e54ba729" *)
Definition binintersect:set->set->set
:= fun X Y => {x :e X |x :e Y}.
(* Unicode :/\: "2229" *)
Infix :/\: 340 left := binintersect.

Theorem binintersectI:forall X Y z, z :e X -> z :e Y -> z :e X :/\: Y.
exact (fun X Y z H1 H2 => SepI X (fun x:set => x :e Y) z H1 H2).
Qed.

Theorem binintersectE:forall X Y z, z :e X :/\: Y -> z :e X /\ z :e Y.
exact (fun X Y z H1 => SepE X (fun x:set => x :e Y) z H1).
Qed.

Theorem binintersectE1:forall X Y z, z :e X :/\: Y -> z :e X.
exact (fun X Y z H1 => SepE1 X (fun x:set => x :e Y) z H1).
Qed.

Theorem binintersectE2:forall X Y z, z :e X :/\: Y -> z :e Y.
exact (fun X Y z H1 => SepE2 X (fun x:set => x :e Y) z H1).
Qed.

Theorem binintersect_Subq_1:forall X Y:set, X :/\: Y c= X.
exact binintersectE1.
Qed.

Theorem binintersect_Subq_2:forall X Y:set, X :/\: Y c= Y.
exact binintersectE2.
Qed.

Theorem binintersect_Subq_eq_1 : forall X Y, X c= Y -> X :/\: Y = X.
let X Y.
assume H1: X c= Y.
apply set_ext.
- apply binintersect_Subq_1.
- let x. assume H2: x :e X.
  apply binintersectI.
  + exact H2.
  + apply H1. exact H2.
Qed.

Theorem binintersect_Subq_max:forall X Y Z:set, Z c= X -> Z c= Y -> Z c= X :/\: Y.
let X Y Z.
assume H1: Z c= X.
assume H2: Z c= Y.
let w.
assume H3: w :e Z.
apply (binintersectI X Y w).
- prove w :e X. exact (H1 w H3).
- prove w :e Y. exact (H2 w H3).
Qed.

Theorem binintersect_com_Subq: forall X Y:set, X :/\: Y c= Y :/\: X.
let X Y. apply (binintersect_Subq_max Y X (X :/\: Y)).
- prove X :/\: Y c= Y. apply binintersect_Subq_2.
- prove X :/\: Y c= X. apply binintersect_Subq_1.
Qed.

Theorem binintersect_com: forall X Y:set, X :/\: Y = Y :/\: X.
let X Y. apply set_ext.
- exact (binintersect_com_Subq X Y).
- exact (binintersect_com_Subq Y X).
Qed.

(* Parameter setminus "cc569397a7e47880ecd75c888fb7c5512aee4bcb1e7f6bd2c5f80cccd368c060" "c68e5a1f5f57bc5b6e12b423f8c24b51b48bcc32149a86fc2c30a969a15d8881" *)
Definition setminus:set->set->set
:= fun X Y => Sep X (fun x => x /:e Y).
(* Unicode :\: "2216" *)
Infix :\: 350 := setminus.

Theorem setminusI:forall X Y z, (z :e X) -> (z /:e Y) -> z :e X :\: Y.
exact (fun X Y z H1 H2 => SepI X (fun x:set => x /:e Y) z H1 H2).
Qed.

Theorem setminusE:forall X Y z, (z :e X :\: Y) -> z :e X /\ z /:e Y.
exact (fun X Y z H => SepE X (fun x:set => x /:e Y) z H).
Qed.

Theorem setminusE1:forall X Y z, (z :e X :\: Y) -> z :e X.
exact (fun X Y z H => SepE1 X (fun x:set => x /:e Y) z H).
Qed.

Theorem setminusE2:forall X Y z, (z :e X :\: Y) -> z /:e Y.
exact (fun X Y z H => SepE2 X (fun x:set => x /:e Y) z H).
Qed.

Theorem setminus_Subq:forall X Y:set, X :\: Y c= X.
exact setminusE1.
Qed.

Theorem setminus_In_Power : forall A U, A :\: U :e Power A.
let A U. apply PowerI. apply setminus_Subq.
Qed.

Theorem binunion_remove1_eq: forall X, forall x :e X, X = (X :\: {x}) :\/: {x}.
let X x.
assume Hx: x :e X.
apply set_ext.
- let y. assume Hy: y :e X.
  prove y :e (X :\: {x}) :\/: {x}.
  apply xm (y :e {x}).
  + assume H1: y :e {x}.
    apply binunionI2. exact H1.
  + assume H1: y /:e {x}.
    apply binunionI1. apply setminusI.
    * exact Hy.
    * exact H1.
- let y. assume Hy: y :e (X :\: {x}) :\/: {x}.
  apply binunionE (X :\: {x}) {x} y Hy.
  + assume H1: y :e X :\: {x}.
    prove y :e X.
    exact setminusE1 X {x} y H1.
  + assume H1: y :e {x}.
    prove y :e X.
    rewrite SingE x y H1.
    prove x :e X.
    exact Hx.
Qed.

Theorem In_irref : forall x, x /:e x.
apply In_ind.
prove (forall X:set, (forall x:set, x :e X -> x /:e x) -> X /:e X).
let X.
assume IH: forall x : set, x :e X -> x /:e x.
assume H: X :e X.
exact IH X H H.
Qed.

Theorem In_no2cycle : forall x y, x :e y -> y :e x -> False.
apply In_ind.
let x.
assume IH: forall z, z :e x -> forall y, z :e y -> y :e z -> False.
let y.
assume H1: x :e y.
assume H2: y :e x.
exact IH y H2 x H2 H1.
Qed.

(* Parameter ordsucc "9db634daee7fc36315ddda5f5f694934869921e9c5f55e8b25c91c0a07c5cbec" "65d8837d7b0172ae830bed36c8407fcd41b7d875033d2284eb2df245b42295a6" *)
Definition ordsucc : set->set := fun x:set => x :\/: {x}.

Theorem ordsuccI1 : forall x:set, x c= ordsucc x.
let x.
exact (fun (y : set) (H1 : y :e x) => binunionI1 x {x} y H1).
Qed.

Theorem ordsuccI2 : forall x:set, x :e ordsucc x.
exact (fun x : set => binunionI2 x {x} x (SingI x)).
Qed.

Theorem ordsuccE : forall x y:set, y :e ordsucc x -> y :e x \/ y = x.
let x y.
assume H1: y :e x :\/: {x}.
apply (binunionE x {x} y H1).
- assume H2: y :e x. apply orIL. exact H2.
- assume H2: y :e {x}. apply orIR. exact (SingE x y H2).
Qed.

Notation Nat Empty ordsucc.

Theorem neq_0_ordsucc : forall a:set, 0 <> ordsucc a.
let a. prove ~(0 = ordsucc a).
assume H1: 0 = ordsucc a.
claim L1: a :e ordsucc a -> False.
{ rewrite <- H1. exact (EmptyE a). }
exact (L1 (ordsuccI2 a)).
Qed.

Theorem neq_ordsucc_0 : forall a:set, ordsucc a <> 0.
let a. exact neq_i_sym 0 (ordsucc a) (neq_0_ordsucc a).
Qed.

Theorem ordsucc_inj : forall a b:set, ordsucc a = ordsucc b -> a = b.
let a b.
assume H1: ordsucc a = ordsucc b.
claim L1: a :e ordsucc b.
{
  rewrite <- H1.
  exact (ordsuccI2 a).
}
apply (ordsuccE b a L1).
- assume H2: a :e b.
  claim L2: b :e ordsucc a.
  {
    rewrite H1.
    exact (ordsuccI2 b).
  }
  apply (ordsuccE a b L2).
  + assume H3: b :e a. prove False. exact (In_no2cycle a b H2 H3).
  + assume H3: b = a. symmetry. exact H3.
- assume H2: a = b. exact H2.
Qed.

Theorem In_0_1 : 0 :e 1.
exact (ordsuccI2 0).
Qed.

Theorem In_0_2 : 0 :e 2.
exact (ordsuccI1 1 0 In_0_1).
Qed.

Theorem In_1_2 : 1 :e 2.
exact (ordsuccI2 1).
Qed.

Definition nat_p : set->prop := fun n:set => forall p:set->prop, p 0 -> (forall x:set, p x -> p (ordsucc x)) -> p n.

Theorem nat_0 : nat_p 0.
exact (fun p H _ => H).
Qed.

Theorem nat_ordsucc : forall n:set, nat_p n -> nat_p (ordsucc n).
exact (fun n H1 p H2 H3 => H3 n (H1 p H2 H3)).
Qed.

Theorem nat_1 : nat_p 1.
exact (nat_ordsucc 0 nat_0).
Qed.

Theorem nat_2 : nat_p 2.
exact (nat_ordsucc 1 nat_1).
Qed.

Theorem nat_0_in_ordsucc : forall n, nat_p n -> 0 :e ordsucc n.
let n.
assume H1.
apply H1 (fun n => 0 :e ordsucc n).
- prove 0 :e ordsucc 0.
  exact In_0_1.
- let n.
  assume IH: 0 :e ordsucc n.
  prove 0 :e ordsucc (ordsucc n).
  exact (ordsuccI1 (ordsucc n) 0 IH).
Qed.

Theorem nat_ordsucc_in_ordsucc : forall n, nat_p n -> forall m :e n, ordsucc m :e ordsucc n.
let n.
assume H1.
apply (H1 (fun n => forall m :e n, ordsucc m :e ordsucc n)).
- prove forall m :e 0, ordsucc m :e ordsucc 0.
  let m.
  assume Hm: m :e 0.
  prove False.
  exact (EmptyE m Hm).
- let n.
  assume IH: forall m :e n, ordsucc m :e ordsucc n.
  prove forall m :e ordsucc n, ordsucc m :e ordsucc (ordsucc n).
  let m.
  assume H2: m :e ordsucc n.
  prove ordsucc m :e ordsucc (ordsucc n).
  apply (ordsuccE n m H2).
  + assume H3: m :e n.
    claim L1: ordsucc m :e ordsucc n.
    { exact (IH m H3). }
    exact (ordsuccI1 (ordsucc n) (ordsucc m) L1).
  + assume H3: m = n.
    rewrite H3.
    prove ordsucc n :e ordsucc (ordsucc n).
    exact (ordsuccI2 (ordsucc n)).
Qed.

Theorem nat_ind : forall p:set->prop, p 0 -> (forall n, nat_p n -> p n -> p (ordsucc n)) -> forall n, nat_p n -> p n.
let p.
assume H1: p 0.
assume H2: forall n, nat_p n -> p n -> p (ordsucc n).
claim L1: nat_p 0 /\ p 0.
{ exact (andI (nat_p 0) (p 0) nat_0 H1). }
claim L2: forall n, nat_p n /\ p n -> nat_p (ordsucc n) /\ p (ordsucc n).
{ let n.
  assume H3: nat_p n /\ p n.
  apply H3.
  assume H4: nat_p n.
  assume H5: p n.
  apply andI.
  - prove nat_p (ordsucc n).
    exact (nat_ordsucc n H4).
  - prove p (ordsucc n).
    exact (H2 n H4 H5).
}
let n.
assume H3.
claim L3: nat_p n /\ p n.
{ exact (H3 (fun n => nat_p n /\ p n) L1 L2). }
exact (andER (nat_p n) (p n) L3).
Qed.

Theorem nat_complete_ind : forall p:set->prop, (forall n, nat_p n -> (forall m :e n, p m) -> p n) -> forall n, nat_p n -> p n.
let p.
assume H1: forall n, nat_p n -> (forall m :e n, p m) -> p n.
claim L1: forall n:set, nat_p n -> forall m :e n, p m.
{ apply nat_ind.
  - prove forall m :e 0, p m.
    let m.
    assume Hm: m :e 0.
    prove False.
    exact (EmptyE m Hm).
  - let n.
    assume Hn: nat_p n.
    assume IHn: forall m :e n, p m.
    prove forall m :e ordsucc n, p m.
    let m.
    assume Hm: m :e ordsucc n.
    prove p m.
    apply (ordsuccE n m Hm).
    + assume H2: m :e n.
      exact (IHn m H2).
    + assume H2: m = n.
      prove p m.
      rewrite H2.
      prove p n.
      exact (H1 n Hn IHn).
}
prove forall n, nat_p n -> p n.
exact (fun n Hn => H1 n Hn (L1 n Hn)).
Qed.

Theorem nat_inv_impred : forall p:set->prop, p 0 -> (forall n, nat_p n -> p (ordsucc n)) -> forall n, nat_p n -> p n.
let p. assume H1 H2. exact nat_ind p H1 (fun n H _ => H2 n H).
Qed.

Theorem nat_inv : forall n, nat_p n -> n = 0 \/ exists x, nat_p x /\ n = ordsucc x.
apply nat_inv_impred.
- apply orIL. reflexivity.
- let n. assume Hn. apply orIR. witness n. apply andI.
  + exact Hn.
  + reflexivity.
Qed.

Theorem nat_p_trans : forall n, nat_p n -> forall m :e n, nat_p m.
apply nat_ind.
- prove forall m :e 0, nat_p m.
  let m.
  assume Hm: m :e 0.
  prove False.
  exact (EmptyE m Hm).
- let n.
  assume Hn: nat_p n.
  assume IHn: forall m :e n, nat_p m.
  prove forall m :e ordsucc n, nat_p m.
  let m.
  assume Hm: m :e ordsucc n.
  apply (ordsuccE n m Hm).
  + assume H1: m :e n.
    exact (IHn m H1).
  + assume H1: m = n.
    rewrite H1.
    exact Hn.
Qed.

Theorem nat_trans : forall n, nat_p n -> forall m :e n, m c= n.
apply nat_ind.
- prove forall m :e 0, m c= 0.
  let m.
  assume Hm: m :e 0.
  prove False.
  exact (EmptyE m Hm).
- let n.
  assume Hn: nat_p n.
  assume IHn: forall m :e n, m c= n.
  prove forall m :e ordsucc n, m c= ordsucc n.
  let m.
  assume Hm: m :e ordsucc n.
  apply (ordsuccE n m Hm).
  + assume H1: m :e n.
    prove m c= ordsucc n.
    apply (Subq_tra m n (ordsucc n)).
    * exact (IHn m H1).
    * exact (ordsuccI1 n).
  + assume H1: m = n.
    prove m c= ordsucc n.
    rewrite H1.
    prove n c= ordsucc n.
    exact (ordsuccI1 n).
Qed.

Theorem nat_ordsucc_trans : forall n, nat_p n -> forall m :e ordsucc n, m c= n.
let n.
assume Hn: nat_p n.
let m.
assume Hm: m :e ordsucc n.
let k.
assume Hk: k :e m.
prove k :e n.
apply (ordsuccE n m Hm).
- assume H1: m :e n.
  exact nat_trans n Hn m H1 k Hk.
- assume H1: m = n.
  rewrite <- H1.
  exact Hk.
Qed.

Definition surj : set->set->(set->set)->prop :=
  fun X Y f =>
  (forall u :e X, f u :e Y)
  /\
  (forall w :e Y, exists u :e X, f u = w).

Theorem form100_63_surjCantor: forall A:set, forall f:set -> set, ~surj A (Power A) f.
let A f. assume H. apply H.
assume H1: forall u :e A, f u :e Power A.
assume H2: forall w :e Power A, exists u :e A, f u = w.
set D := {x :e A|x /:e f x}.
claim L1: D :e Power A.
{ exact Sep_In_Power A (fun x => x /:e f x). }
apply H2 D L1.
let d. assume H. apply H.
assume Hd: d :e A.
assume HfdD: f d = D.
claim L2: d /:e D.
{ assume H3: d :e D.
  apply SepE2 A (fun x => x /:e f x) d H3.
  prove d :e f d.
  rewrite HfdD.
  prove d :e D.
  exact H3.
}
apply L2.
prove d :e D.
apply SepI.
- prove d :e A. exact Hd.
- prove d /:e f d. rewrite HfdD. exact L2.
Qed.

Definition inj : set->set->(set->set)->prop :=
  fun X Y f =>
  (forall u :e X, f u :e Y)
  /\
  (forall u v :e X, f u = f v -> u = v).

Theorem form100_63_injCantor: forall A:set, forall f:set -> set, ~inj (Power A) A f.
let A f. assume H. apply H.
assume H1: forall X :e Power A, f X :e A.
assume H2: forall X Y :e Power A, f X = f Y -> X = Y.
set D := {f X | X :e Power A, f X /:e X}.
claim L1: D :e Power A.
{ apply PowerI.
  let n. assume H3: n :e D.
  apply ReplSepE_impred (Power A) (fun X => f X /:e X) f n H3.
  let X. assume HX: X :e Power A.
  assume H4: f X /:e X.
  assume H5: n = f X.
  prove n :e A. rewrite H5. apply H1. exact HX.
}
claim L2: f D /:e D.
{ assume H3: f D :e D.
  apply ReplSepE_impred (Power A) (fun X => f X /:e X) f (f D) H3.
  let X. assume HX: X :e Power A.
  assume H4: f X /:e X.
  assume H5: f D = f X.
  claim L2a: D = X.
  { exact H2 D L1 X HX H5. }
  apply H4. rewrite <- L2a. exact H3.
}
apply L2.
prove f D :e D.
apply ReplSepI.
- prove D :e Power A. exact L1.
- prove f D /:e D. exact L2.
Qed.

Theorem injI : forall X Y, forall f:set -> set, (forall x :e X, f x :e Y) -> (forall x z :e X, f x = f z -> x = z) -> inj X Y f.
let X Y f. assume H1 H2.
prove (forall x :e X, f x :e Y) /\ (forall x z :e X, f x = f z -> x = z).
apply andI.
- exact H1.
- exact H2.
Qed.

Theorem inj_comp : forall X Y Z:set, forall f g:set->set, inj X Y f -> inj Y Z g -> inj X Z (fun x => g (f x)).
let X Y Z f g.
assume Hf.
assume Hg.
apply Hf.
assume Hf1 Hf2.
apply Hg.
assume Hg1 Hg2.
apply injI.
- let u. assume Hu: u :e X. exact (Hg1 (f u) (Hf1 u Hu)).
- let u. assume Hu: u :e X. let v. assume Hv: v :e X.
  assume H1: g (f u) = g (f v).
  prove u = v.
  apply Hf2 u Hu v Hv.
  prove f u = f v.
  apply Hg2 (f u) (Hf1 u Hu) (f v) (Hf1 v Hv).
  prove g (f u) = g (f v).
  exact H1.
Qed.

Definition bij : set->set->(set->set)->prop :=
  fun X Y f =>
  (forall u :e X, f u :e Y)
  /\
  (forall u v :e X, f u = f v -> u = v)
  /\
  (forall w :e Y, exists u :e X, f u = w).

Theorem bijI : forall X Y, forall f:set -> set,
    (forall u :e X, f u :e Y)
 -> (forall u v :e X, f u = f v -> u = v)
 -> (forall w :e Y, exists u :e X, f u = w)
 -> bij X Y f.
let X Y f. assume Hf1 Hf2 Hf3.
prove (forall u :e X, f u :e Y)
   /\ (forall u v :e X, f u = f v -> u = v)
   /\ (forall w :e Y, exists u :e X, f u = w).
apply and3I.
- exact Hf1.
- exact Hf2.
- exact Hf3.
Qed.

Theorem bijE : forall X Y, forall f:set -> set,
    bij X Y f
 -> forall p:prop,
      ((forall u :e X, f u :e Y)
    -> (forall u v :e X, f u = f v -> u = v)
    -> (forall w :e Y, exists u :e X, f u = w)
    -> p)
   -> p.
let X Y f. assume Hf. let p. assume Hp.
apply Hf. assume Hf. apply Hf.
assume Hf1 Hf2 Hf3.
exact Hp Hf1 Hf2 Hf3.
Qed.

Theorem bij_inj : forall X Y, forall f:set -> set, bij X Y f -> inj X Y f.
let X Y f. assume H1. apply H1. assume H1 _. exact H1.
Qed.

Theorem bij_id : forall X, bij X X (fun x => x).
let X.
prove (forall u :e X, u :e X) /\ (forall u v :e X, u = v -> u = v) /\ (forall w :e X, exists u :e X, u = w).
apply and3I.
- exact (fun u Hu => Hu).
- exact (fun u Hu v Hv H1 => H1).
- let w. assume Hw. witness w. apply andI.
  + exact Hw.
  + reflexivity.
Qed.

Theorem bij_comp : forall X Y Z:set, forall f g:set->set, bij X Y f -> bij Y Z g -> bij X Z (fun x => g (f x)).
let X Y Z f g.
assume Hf. apply Hf. assume Hf12 Hf3. apply Hf12. assume Hf1 Hf2.
assume Hg. apply Hg. assume Hg12 Hg3. apply Hg12. assume Hg1 Hg2.
prove (forall u :e X, g (f u) :e Z)
  /\
  (forall u v :e X, g (f u) = g (f v) -> u = v)
  /\
  (forall w :e Z, exists u :e X, g (f u) = w).
apply and3I.
- let u. assume Hu: u :e X. exact (Hg1 (f u) (Hf1 u Hu)).
- let u. assume Hu: u :e X. let v. assume Hv: v :e X.
  assume H1: g (f u) = g (f v).
  prove u = v.
  apply Hf2 u Hu v Hv.
  prove f u = f v.
  apply Hg2 (f u) (Hf1 u Hu) (f v) (Hf1 v Hv).
  prove g (f u) = g (f v).
  exact H1.
- let w. assume Hw: w :e Z. apply Hg3 w Hw.
  let y. assume Hy12. apply Hy12.
  assume Hy1: y :e Y. assume Hy2: g y = w.
  apply Hf3 y Hy1.
  let u. assume Hu12. apply Hu12.
  assume Hu1: u :e X. assume Hu2: f u = y.
  prove exists u :e X, g (f u) = w.
  witness u.
  apply andI.
  + exact Hu1.
  + rewrite Hu2. exact Hy2.
Qed.

Theorem bij_surj : forall X Y, forall f:set -> set, bij X Y f -> surj X Y f.
let X Y f. assume H1. apply H1. assume H1. apply H1.
assume H1 _ H2.
prove (forall u :e X, f u :e Y)
   /\ (forall w :e Y, exists u :e X, f u = w).
apply andI.
- exact H1.
- exact H2.
Qed.

Definition inv : set -> (set -> set) -> set -> set := fun X f => fun y:set => Eps_i (fun x => x :e X /\ f x = y).

Theorem surj_rinv : forall X Y, forall f:set->set, (forall w :e Y, exists u :e X, f u = w) -> forall y :e Y, inv X f y :e X /\ f (inv X f y) = y.
let X Y f. assume H1.
let y. assume Hy: y :e Y.
apply H1 y Hy.
let x.
assume H2.
exact Eps_i_ax (fun x => x :e X /\ f x = y) x H2.
Qed.

Theorem inj_linv : forall X, forall f:set->set, (forall u v :e X, f u = f v -> u = v) -> forall x :e X, inv X f (f x) = x.
let X f.
assume H1.
let x. assume Hx.
claim L1: inv X f (f x) :e X /\ f (inv X f (f x)) = f x.
{ apply Eps_i_ax (fun x' => x' :e X /\ f x' = f x) x.
  apply andI.
  - exact Hx.
  - reflexivity.
}
apply L1.
assume H2 H3.
exact H1 (inv X f (f x)) H2 x Hx H3.
Qed.

Theorem bij_inv : forall X Y, forall f:set->set, bij X Y f -> bij Y X (inv X f).
let X Y f.
assume H1. apply H1.
assume H2. apply H2.
assume H3: forall u :e X, f u :e Y.
assume H4: forall u v :e X, f u = f v -> u = v.
assume H5: forall w :e Y, exists u :e X, f u = w.
set g : set->set := fun y => Eps_i (fun x => x :e X /\ f x = y).
claim L1: forall y :e Y, g y :e X /\ f (g y) = y.
{ exact surj_rinv X Y f H5. }
prove (forall u :e Y, g u :e X)
      /\
      (forall u v :e Y, g u = g v -> u = v)
      /\
      (forall w :e X, exists u :e Y, g u = w).
apply and3I.
- prove forall u :e Y, g u :e X.
  let u. assume Hu. apply L1 u Hu. assume H _. exact H.
- prove forall u v :e Y, g u = g v -> u = v.
  let u. assume Hu. let v. assume Hv H6.
  prove u = v.
  apply L1 u Hu.
  assume H7: g u :e X.
  assume H8: f (g u) = u.
  apply L1 v Hv.
  assume H9: g v :e X.
  assume H10: f (g v) = v.
  rewrite <- H8.
  rewrite <- H10.
  rewrite <- H6.
  reflexivity.
- prove forall w :e X, exists u :e Y, g u = w.
  let w. assume Hw.
  claim Lfw: f w :e Y.
  { exact H3 w Hw. }
  witness f w.
  apply andI.
  + exact Lfw.
  + exact inj_linv X f H4 w Hw.
Qed.

Definition atleastp : set -> set -> prop
 := fun X Y : set => exists f : set -> set, inj X Y f.

Theorem atleastp_tra: forall X Y Z, atleastp X Y -> atleastp Y Z -> atleastp X Z.
admit.
Qed.

Theorem Subq_atleastp : forall X Y, X c= Y -> atleastp X Y.
admit.
Qed.

Definition equip : set -> set -> prop
 := fun X Y : set => exists f : set -> set, bij X Y f.

Theorem equip_atleastp: forall X Y, equip X Y -> atleastp X Y.
admit.
Qed.

Theorem equip_ref : forall X, equip X X.
admit.
Qed.

Theorem equip_sym : forall X Y, equip X Y -> equip Y X.
admit.
Qed.

Theorem equip_tra : forall X Y Z, equip X Y -> equip Y Z -> equip X Z.
admit.
Qed.

Theorem equip_0_Empty : forall X, equip X 0 -> X = 0.
admit.
Qed.

Theorem equip_adjoin_ordsucc : forall N X y, y /:e X -> equip N X -> equip (ordsucc N) (X :\/: {y}).
admit.
Qed.

Theorem equip_ordsucc_remove1: forall X N, forall x :e X, equip X (ordsucc N) -> equip (X :\: {x}) N.
admit.
Qed.

Section SchroederBernstein.

Theorem KnasterTarski_set: forall A, forall F:set->set,
    (forall U :e Power A, F U :e Power A)
 -> (forall U V :e Power A, U c= V -> F U c= F V)
 -> exists Y :e Power A, F Y = Y.
admit.
Qed.

Theorem image_In_Power : forall A B, forall f:set -> set, (forall x :e A, f x :e B) -> forall U :e Power A, {f x|x :e U} :e Power B.
admit.
Qed.

Theorem image_monotone : forall f:set -> set, forall U V, U c= V -> {f x|x :e U} c= {f x|x :e V}.
admit.
Qed.

Theorem setminus_antimonotone : forall A U V, U c= V -> A :\: V c= A :\: U.
admit.
Qed.

Theorem SchroederBernstein: forall A B, forall f g:set -> set, inj A B f -> inj B A g -> equip A B.
admit.
Qed.

Theorem atleastp_antisym_equip: forall A B, atleastp A B -> atleastp B A -> equip A B.
admit.
Qed.

End SchroederBernstein.

Section PigeonHole.

Theorem PigeonHole_nat : forall n, nat_p n -> forall f:set -> set, (forall i :e ordsucc n, f i :e n) -> ~(forall i j :e ordsucc n, f i = f j -> i = j).
admit.
Qed.

Theorem Pigeonhole_not_atleastp_ordsucc : forall n, nat_p n -> ~atleastp (ordsucc n) n.
admit.
Qed.

End PigeonHole.

Theorem Union_ordsucc_eq : forall n, nat_p n -> Union (ordsucc n) = n.
admit.
Qed.

Theorem cases_1: forall i :e 1, forall p:set->prop, p 0 -> p i.
admit.
Qed.

Theorem cases_2: forall i :e 2, forall p:set->prop, p 0 -> p 1 -> p i.
admit.
Qed.

Theorem neq_0_1 : 0 <> 1.
admit.
Qed.

Theorem neq_1_0 : 1 <> 0.
admit.
Qed.

Theorem neq_0_2 : 0 <> 2.
admit.
Qed.

Theorem neq_2_0 : 2 <> 0.
admit.
Qed.

Definition ordinal : set->prop := fun (alpha:set) => TransSet alpha /\ forall beta :e alpha, TransSet beta.

Theorem ordinal_TransSet : forall alpha:set, ordinal alpha -> TransSet alpha.
admit.
Qed.

Theorem ordinal_Empty : ordinal Empty.
admit.
Qed.

Theorem ordinal_Hered : forall alpha:set, ordinal alpha -> forall beta :e alpha, ordinal beta.
admit.
Qed.

Theorem TransSet_ordsucc : forall X:set, TransSet X -> TransSet (ordsucc X).
admit.
Qed.

Theorem ordinal_ordsucc : forall alpha:set, ordinal alpha -> ordinal (ordsucc alpha).
admit.
Qed.

Theorem nat_p_ordinal : forall n:set, nat_p n -> ordinal n.
admit.
Qed.

Theorem ordinal_1 : ordinal 1.
admit.
Qed.

Theorem ordinal_2 : ordinal 2.
admit.
Qed.

Theorem TransSet_ordsucc_In_Subq : forall X:set, TransSet X -> forall x :e X, ordsucc x c= X.
admit.
Qed.

Theorem ordinal_ordsucc_In_Subq : forall alpha, ordinal alpha -> forall beta :e alpha, ordsucc beta c= alpha.
admit.
Qed.

Theorem ordinal_trichotomy_or : forall alpha beta:set, ordinal alpha -> ordinal beta -> alpha :e beta \/ alpha = beta \/ beta :e alpha.
admit.
Qed.    

Theorem ordinal_trichotomy_or_impred : forall alpha beta:set, ordinal alpha -> ordinal beta -> forall p:prop, (alpha :e beta -> p) -> (alpha = beta -> p) -> (beta :e alpha -> p) -> p.
admit.
Qed.

Theorem ordinal_In_Or_Subq : forall alpha beta, ordinal alpha -> ordinal beta -> alpha :e beta \/ beta c= alpha.
admit.
Qed.

Theorem ordinal_linear : forall alpha beta, ordinal alpha -> ordinal beta -> alpha c= beta \/ beta c= alpha.
admit.
Qed.

Theorem ordinal_ordsucc_In_eq : forall alpha beta, ordinal alpha -> beta :e alpha -> ordsucc beta :e alpha \/ alpha = ordsucc beta.
admit.
Qed.

Theorem ordinal_lim_or_succ : forall alpha, ordinal alpha -> (forall beta :e alpha, ordsucc beta :e alpha) \/ (exists beta :e alpha, alpha = ordsucc beta).
admit.
Qed.

Theorem ordinal_ordsucc_In : forall alpha, ordinal alpha -> forall beta :e alpha, ordsucc beta :e ordsucc alpha.
admit.
Qed.

Theorem ordinal_famunion : forall X, forall F:set -> set, (forall x :e X, ordinal (F x)) -> ordinal (\/_ x :e X, F x).
admit.
Qed.

Theorem ordinal_binintersect : forall alpha beta, ordinal alpha -> ordinal beta -> ordinal (alpha :/\: beta).
admit.
Qed.

Theorem ordinal_binunion : forall alpha beta, ordinal alpha -> ordinal beta -> ordinal (alpha :\/: beta).
admit.
Qed.

Theorem ordinal_ind : forall p:set->prop, 
(forall alpha, ordinal alpha -> (forall beta :e alpha, p beta) -> p alpha)
->
forall alpha, ordinal alpha -> p alpha.
admit.
Qed.

Theorem least_ordinal_ex : forall p:set -> prop, (exists alpha, ordinal alpha /\ p alpha) -> exists alpha, ordinal alpha /\ p alpha /\ forall beta :e alpha, ~p beta.
admit.
Qed.

Theorem equip_Sing_1 : forall x, equip {x} 1.
admit.
Qed.

Theorem TransSet_In_ordsucc_Subq : forall x y, TransSet y -> x :e ordsucc y -> x c= y.
admit.
Qed.

Theorem exandE_i : forall P Q:set -> prop, (exists x, P x /\ Q x) -> forall r:prop, (forall x, P x -> Q x -> r) -> r.
admit.
Qed.

Theorem exandE_ii : forall P Q:(set -> set) -> prop, (exists x:set -> set, P x /\ Q x) -> forall p:prop, (forall x:set -> set, P x -> Q x -> p) -> p.
admit.
Qed.

Theorem exandE_iii : forall P Q:(set -> set -> set) -> prop, (exists x:set -> set -> set, P x /\ Q x) -> forall p:prop, (forall x:set -> set -> set, P x -> Q x -> p) -> p.
admit.
Qed.

Theorem exandE_iiii : forall P Q:(set -> set -> set -> set) -> prop, (exists x:set -> set -> set -> set, P x /\ Q x) -> forall p:prop, (forall x:set -> set -> set -> set, P x -> Q x -> p) -> p.
admit.
Qed.

Section Descr_ii.
Variable P : (set -> set) -> prop.
(* Parameter Descr_ii "a6e81668bfd1db6e6eb6a13bf66094509af176d9d0daccda274aa6582f6dcd7c" "3bae39e9880bbf5d70538d82bbb05caf44c2c11484d80d06dee0589d6f75178c" *)
Definition Descr_ii : set -> set := fun x:set => Eps_i (fun y => forall h:set -> set, P h -> h x = y).
Hypothesis Pex: exists f:set -> set, P f.
Hypothesis Puniq: forall f g:set -> set, P f -> P g -> f = g.

Theorem Descr_ii_prop : P Descr_ii.
admit.
Qed.

End Descr_ii.
Section Descr_iii.
Variable P : (set -> set -> set) -> prop.
(* Parameter Descr_iii "dc42f3fe5d0c55512ef81fe5d2ad0ff27c1052a6814b1b27f5a5dcb6d86240bf" "ca5fc17a582fdd4350456951ccbb37275637ba6c06694213083ed9434fe3d545" *)
Definition Descr_iii : set -> set -> set := fun x y:set => Eps_i (fun z => forall h:set -> set -> set, P h -> h x y = z).
Hypothesis Pex: exists f:set -> set -> set, P f.
Hypothesis Puniq: forall f g:set -> set -> set, P f -> P g -> f = g.

Theorem Descr_iii_prop : P Descr_iii.
admit.
Qed.

End Descr_iii.
Section Descr_Vo1.
Variable P : Vo 1 -> prop.
(* Parameter Descr_Vo1 "322bf09a1711d51a4512e112e1767cb2616a7708dc89d7312c8064cfee6e3315" "615c0ac7fca2b62596ed34285f29a77b39225d1deed75d43b7ae87c33ba37083" *)
Definition Descr_Vo1 : Vo 1 := fun x:set => forall h:set -> prop, P h -> h x.
Hypothesis Pex: exists f:Vo 1, P f.
Hypothesis Puniq: forall f g:Vo 1, P f -> P g -> f = g.

Theorem Descr_Vo1_prop : P Descr_Vo1.
admit.
Qed.

End Descr_Vo1.
Section If_ii.
Variable p:prop.
Variable f g:set -> set.
(* Parameter If_ii "e76df3235104afd8b513a92c00d3cc56d71dd961510bf955a508d9c2713c3f29" "17057f3db7be61b4e6bd237e7b37125096af29c45cb784bb9cc29b1d52333779" *)
Definition If_ii : set -> set := fun x => if p then f x else g x.

Theorem If_ii_1 : p -> If_ii = f.
admit.
Qed.

Theorem If_ii_0 : ~p -> If_ii = g.
admit.
Qed.

End If_ii.
Section If_iii.
Variable p:prop.
Variable f g:set -> set -> set.
(* Parameter If_iii "53034f33cbed012c3c6db42812d3964f65a258627a765f5bede719198af1d1ca" "3314762dce5a2e94b7e9e468173b047dd4a9fac6ee2c5f553c6ea15e9c8b7542" *)
Definition If_iii : set -> set -> set := fun x y => if p then f x y else g x y.

Theorem If_iii_1 : p -> If_iii = f.
admit.
Qed.

Theorem If_iii_0 : ~p -> If_iii = g.
admit.
Qed.

End If_iii.
Section EpsilonRec_i.
Variable F:set -> (set -> set) -> set.
Definition In_rec_i_G : set -> set -> prop :=
fun X Y =>
forall R:set->set->prop,
(forall X:set, forall f:set->set, (forall x :e X, R x (f x)) -> R X (F X f)) ->
R X Y.
(* Parameter In_rec_i "f97da687c51f5a332ff57562bd465232bc70c9165b0afe0a54e6440fc4962a9f" "fac413e747a57408ad38b3855d3cde8673f86206e95ccdadff2b5babaf0c219e" *)
Definition In_rec_i : set -> set := fun X => Eps_i (In_rec_i_G X).

Theorem In_rec_i_G_c : forall X:set, forall f:set->set, (forall x :e X, In_rec_i_G x (f x)) -> In_rec_i_G X (F X f).
admit.
Qed.

Theorem In_rec_i_G_inv : forall X:set, forall Y:set, In_rec_i_G X Y -> exists f:set->set, (forall x :e X, In_rec_i_G x (f x)) /\ Y = F X f.
admit.
Qed.

Hypothesis Fr:forall X:set, forall g h:set -> set, (forall x :e X, g x = h x) -> F X g = F X h.

Theorem In_rec_i_G_f : forall X:set, forall Y Z:set, In_rec_i_G X Y -> In_rec_i_G X Z -> Y = Z.
admit.
Qed.

Theorem In_rec_i_G_In_rec_i : forall X:set, In_rec_i_G X (In_rec_i X).
admit.
Qed.

Theorem In_rec_i_G_In_rec_i_d : forall X:set, In_rec_i_G X (F X In_rec_i).
admit.
Qed.

Theorem In_rec_i_eq : forall X:set, In_rec_i X = F X In_rec_i.
admit.
Qed.

End EpsilonRec_i.
Section EpsilonRec_ii.
Variable F:set -> (set -> (set -> set)) -> (set -> set).
Definition In_rec_G_ii : set -> (set -> set) -> prop :=
fun X Y =>
forall R:set->(set -> set)->prop,
(forall X:set, forall f:set->(set -> set), (forall x :e X, R x (f x)) -> R X (F X f)) ->
R X Y.
(* Parameter In_rec_ii "4d137cad40b107eb0fc2c707372525f1279575e6cadb4ebc129108161af3cedb" "f3c9abbc5074c0d68e744893a170de526469426a5e95400ae7fc81f74f412f7e" *)
Definition In_rec_ii : set -> (set -> set) := fun X => Descr_ii (In_rec_G_ii X).

Theorem In_rec_G_ii_c : forall X:set, forall f:set->(set -> set), (forall x :e X, In_rec_G_ii x (f x)) -> In_rec_G_ii X (F X f).
admit.
Qed.

Theorem In_rec_G_ii_inv : forall X:set, forall Y:(set -> set), In_rec_G_ii X Y -> exists f:set->(set -> set), (forall x :e X, In_rec_G_ii x (f x)) /\ Y = F X f.
admit.
Qed.

Hypothesis Fr:forall X:set, forall g h:set -> (set -> set), (forall x :e X, g x = h x) -> F X g = F X h.

Theorem In_rec_G_ii_f : forall X:set, forall Y Z:(set -> set), In_rec_G_ii X Y -> In_rec_G_ii X Z -> Y = Z.
admit.
Qed.

Theorem In_rec_G_ii_In_rec_ii : forall X:set, In_rec_G_ii X (In_rec_ii X).
admit.
Qed.

Theorem In_rec_G_ii_In_rec_ii_d : forall X:set, In_rec_G_ii X (F X In_rec_ii).
admit.
Qed.

Theorem In_rec_ii_eq : forall X:set, In_rec_ii X = F X In_rec_ii.
admit.
Qed.

End EpsilonRec_ii.
Section EpsilonRec_iii.
Variable F:set -> (set -> (set -> set -> set)) -> (set -> set -> set).
Definition In_rec_G_iii : set -> (set -> set -> set) -> prop :=
fun X Y =>
forall R:set->(set -> set -> set)->prop,
(forall X:set, forall f:set->(set -> set -> set), (forall x :e X, R x (f x)) -> R X (F X f)) ->
R X Y.
(* Parameter In_rec_iii "222f1b8dcfb0d2e33cc4b232e87cbcdfe5c4a2bdc5326011eb70c6c9aeefa556" "9b3a85b85e8269209d0ca8bf18ef658e56f967161bf5b7da5e193d24d345dd06" *)
Definition In_rec_iii : set -> (set -> set -> set) := fun X => Descr_iii (In_rec_G_iii X).

Theorem In_rec_G_iii_c : forall X:set, forall f:set->(set -> set -> set), (forall x :e X, In_rec_G_iii x (f x)) -> In_rec_G_iii X (F X f).
admit.
Qed.

Theorem In_rec_G_iii_inv : forall X:set, forall Y:(set -> set -> set), In_rec_G_iii X Y -> exists f:set->(set -> set -> set), (forall x :e X, In_rec_G_iii x (f x)) /\ Y = F X f.
admit.
Qed.

Hypothesis Fr:forall X:set, forall g h:set -> (set -> set -> set), (forall x :e X, g x = h x) -> F X g = F X h.

Theorem In_rec_G_iii_f : forall X:set, forall Y Z:(set -> set -> set), In_rec_G_iii X Y -> In_rec_G_iii X Z -> Y = Z.
admit.
Qed.

Theorem In_rec_G_iii_In_rec_iii : forall X:set, In_rec_G_iii X (In_rec_iii X).
admit.
Qed.

Theorem In_rec_G_iii_In_rec_iii_d : forall X:set, In_rec_G_iii X (F X In_rec_iii).
admit.
Qed.

Theorem In_rec_iii_eq : forall X:set, In_rec_iii X = F X In_rec_iii.
admit.
Qed.

End EpsilonRec_iii.
Section NatRec.
Variable z:set.
Variable f:set->set->set.
Let F : set->(set->set)->set := fun n g => if Union n :e n then f (Union n) (g (Union n)) else z.
Definition nat_primrec : set->set := In_rec_i F.

Theorem nat_primrec_r : forall X:set, forall g h:set -> set, (forall x :e X, g x = h x) -> F X g = F X h.
admit.
Qed.

Theorem nat_primrec_0 : nat_primrec 0 = z.
admit.
Qed.

Theorem nat_primrec_S : forall n:set, nat_p n -> nat_primrec (ordsucc n) = f n (nat_primrec n).
admit.
Qed.

End NatRec.

Section NatAdd.

Definition add_nat : set->set->set := fun n m:set => nat_primrec n (fun _ r => ordsucc r) m.
Infix + 360 right := add_nat.

Theorem add_nat_0R : forall n:set, n + 0 = n.
admit.
Qed.

Theorem add_nat_SR : forall n m:set, nat_p m -> n + ordsucc m = ordsucc (n + m).
admit.
Qed.

Theorem add_nat_p : forall n:set, nat_p n -> forall m:set, nat_p m -> nat_p (n + m).
admit.
Qed.

Theorem add_nat_1_1_2 : 1 + 1 = 2.
admit.
Qed.

Theorem add_nat_asso : forall n:set, nat_p n -> forall m:set, nat_p m -> forall k:set, nat_p k -> (n+m)+k = n+(m+k).
admit.
Qed.

Theorem add_nat_0L : forall m:set, nat_p m -> 0+m = m.
admit.
Qed.

Theorem add_nat_SL : forall n:set, nat_p n -> forall m:set, nat_p m -> ordsucc n + m = ordsucc (n+m).
admit.
Qed.

Theorem add_nat_com : forall n:set, nat_p n -> forall m:set, nat_p m -> n + m = m + n.
admit.
Qed.

Theorem add_nat_In_R: forall m, nat_p m -> forall k :e m, forall n, nat_p n -> k + n :e m + n.
admit.
Qed.

Theorem add_nat_In_L: forall n, nat_p n -> forall m, nat_p m -> forall k :e m, n + k :e n + m.
admit.
Qed.

Theorem add_nat_Subq_R: forall k, nat_p k -> forall m, nat_p m -> k c= m -> forall n, nat_p n -> k + n c= m + n.
admit.
Qed.

Theorem add_nat_Subq_L: forall n, nat_p n -> forall k, nat_p k -> forall m, nat_p m -> k c= m -> n + k c= n + m.
admit.
Qed.

Theorem add_nat_Subq_R' : forall m, nat_p m -> forall n, nat_p n -> m c= m + n.
admit.
Qed.

Theorem nat_Subq_add_ex: forall n, nat_p n -> forall m, nat_p m -> n c= m -> exists k, nat_p k /\ m = k + n.
admit.
Qed.

Theorem add_nat_cancel_R : forall k, nat_p k -> forall m, nat_p m -> forall n, nat_p n -> k + n = m + n -> k = m.
admit.
Qed.

End NatAdd.

Section NatMul.

Infix + 360 right := add_nat.

Definition mul_nat : set->set->set := fun n m:set => nat_primrec 0 (fun _ r => n + r) m.
Infix * 355 right := mul_nat.

Theorem mul_nat_0R : forall n:set, n * 0 = 0.
admit.
Qed.

Theorem mul_nat_SR : forall n m, nat_p m -> n * ordsucc m = n + n * m.
admit.
Qed.

Theorem mul_nat_1R: forall n, n * 1 = n.
admit.
Qed.

Theorem mul_nat_p : forall n:set, nat_p n -> forall m:set, nat_p m -> nat_p (n * m).
admit.
Qed.

Theorem mul_nat_0L : forall m:set, nat_p m -> 0 * m = 0.
admit.
Qed.

Theorem mul_nat_SL : forall n:set, nat_p n -> forall m:set, nat_p m -> ordsucc n * m = n * m + m.
admit.
Qed.

Theorem mul_nat_com : forall n:set, nat_p n -> forall m:set, nat_p m -> n * m = m * n.
admit.
Qed.

Theorem mul_add_nat_distrL : forall n:set, nat_p n -> forall m:set, nat_p m -> forall k:set, nat_p k -> n * (m + k) = n * m + n * k.
admit.
Qed.

Theorem mul_nat_asso : forall n:set, nat_p n -> forall m:set, nat_p m -> forall k:set, nat_p k -> (n*m)*k = n*(m*k).
admit.
Qed.

Theorem mul_nat_Subq_R : forall m n, nat_p m -> nat_p n -> m c= n -> forall k, nat_p k -> m * k c= n * k.
admit.
Qed.

Theorem mul_nat_Subq_L : forall m n, nat_p m -> nat_p n -> m c= n -> forall k, nat_p k -> k * m c= k * n.
admit.
Qed.

Theorem mul_nat_0_or_Subq: forall m, nat_p m -> forall n, nat_p n -> n = 0 \/ m c= m * n.
admit.
Qed.

(** If m times n = 0 for naturals m and n, then one must be 0. **)
Theorem mul_nat_0_inv : forall m, nat_p m -> forall n, nat_p n -> m * n = 0 -> m = 0 \/ n = 0.
admit.
Qed.

Theorem mul_nat_0m_1n_In: forall m, nat_p m -> forall n, nat_p n -> 0 :e m -> 1 :e n -> m :e m * n.
admit.
Qed.

Theorem nat_le1_cases: forall m, nat_p m -> m c= 1 -> m = 0 \/ m = 1.
admit.
Qed.

Definition Pi_nat : (set -> set) -> set -> set := fun f n =>
  nat_primrec 1 (fun i r => r * f i) n.

Theorem Pi_nat_0: forall f:set -> set, Pi_nat f 0 = 1.
admit.
Qed.

Theorem Pi_nat_S: forall f:set -> set, forall n, nat_p n -> Pi_nat f (ordsucc n) = Pi_nat f n * f n.
admit.
Qed.

Theorem Pi_nat_p: forall f:set -> set,
 forall n, nat_p n ->
     (forall i :e n, nat_p (f i))
  -> nat_p (Pi_nat f n).
admit.
Qed.

Theorem Pi_nat_0_inv: forall f:set->set,
  forall n, nat_p n ->
      (forall i :e n, nat_p (f i))
   -> Pi_nat f n = 0
   -> (exists i :e n, f i = 0).
admit.
Qed.

Definition exp_nat : set->set->set := fun n m:set => nat_primrec 1 (fun _ r => n * r) m.

Infix ^ 342 right := exp_nat.

Theorem exp_nat_0 : forall n, n ^ 0 = 1.
admit.
Qed.

Theorem exp_nat_S : forall n m, nat_p m -> n ^ (ordsucc m) = n * n ^ m.
admit.
Qed.

Theorem exp_nat_p : forall n, nat_p n -> forall m, nat_p m -> nat_p (n ^ m).
admit.
Qed.

Theorem exp_nat_1 : forall n, n ^ 1 = n.
admit.
Qed.

End NatMul.

Section form100_52.

Infix + 360 right := add_nat.
Infix * 355 right := mul_nat.
Infix ^ 342 right := exp_nat.

Theorem Subq_Sing0_1 : {0} c= 1.
admit.
Qed.

Theorem Subq_1_Sing0 : 1 c= {0}.
admit.
Qed.

Theorem eq_1_Sing0 : 1 = {0}.
admit.
Qed.

Theorem Power_0_Sing_0 : Power 0 = {0}.
admit.
Qed.

Theorem equip_finite_Power: forall n, nat_p n -> forall X,
  equip X n -> equip (Power X) (2 ^ n).
admit.
Qed.

End form100_52.

Theorem ZF_closed_E : forall U, ZF_closed U ->
 forall p:prop,
 (Union_closed U ->
  Power_closed U ->
  Repl_closed U -> p)
 -> p.
admit.
Qed.

Theorem ZF_Union_closed : forall U, ZF_closed U ->
  forall X :e U, Union X :e U.
admit.
Qed.

Theorem ZF_Power_closed : forall U, ZF_closed U ->
  forall X :e U, Power X :e U.
admit.
Qed.

Theorem ZF_Repl_closed : forall U, ZF_closed U ->
  forall X :e U, forall F:set->set, (forall x :e X, F x :e U) -> {F x|x:eX} :e U.
admit.
Qed.

Theorem ZF_UPair_closed : forall U, ZF_closed U ->
  forall x y :e U, {x,y} :e U.
admit.
Qed.

Theorem ZF_Sing_closed : forall U, ZF_closed U ->
  forall x :e U, {x} :e U.
admit.
Qed.

Theorem ZF_binunion_closed : forall U, ZF_closed U ->
  forall X Y :e U, (X :\/: Y) :e U.
admit.
Qed.

Theorem ZF_ordsucc_closed : forall U, ZF_closed U ->
  forall x :e U, ordsucc x :e U.
admit.
Qed.

Theorem nat_p_UnivOf_Empty : forall n:set, nat_p n -> n :e UnivOf Empty.
admit.
Qed.

(* Unicode omega "3c9" *)
(* Parameter omega "39cdf86d83c7136517f803d29d0c748ea45a274ccbf9b8488f9cda3e21f4b47c" "6fc30ac8f2153537e397b9ff2d9c981f80c151a73f96cf9d56ae2ee27dfd1eb2" *)
Definition omega : set := {n :e UnivOf Empty|nat_p n}.

Theorem omega_nat_p : forall n :e omega, nat_p n.
admit.
Qed.

Theorem nat_p_omega : forall n:set, nat_p n -> n :e omega.
admit.
Qed.

Theorem omega_ordsucc : forall n :e omega, ordsucc n :e omega.
admit.
Qed.

Theorem form100_22_v2: forall f:set -> set, ~inj (Power omega) omega f.
admit.
Qed.

Theorem form100_22_v3: forall g:set -> set, ~surj omega (Power omega) g.
admit.
Qed.

Theorem form100_22_v1: ~equip omega (Power omega).
admit.
Qed.

Theorem omega_TransSet : TransSet omega.
admit.
Qed.

Theorem omega_ordinal : ordinal omega.
admit.
Qed.

Theorem ordsucc_omega_ordinal: ordinal (ordsucc omega).
admit.
Qed.

Definition finite : set -> prop := fun X => exists n :e omega, equip X n.

Theorem nat_finite: forall n, nat_p n -> finite n.
admit.
Qed.

Theorem finite_ind : forall p:set -> prop,
    p Empty
 -> (forall X y, finite X -> y /:e X -> p X -> p (X :\/: {y}))
 -> forall X, finite X -> p X.
admit.
Qed.

Theorem finite_Empty: finite 0.
admit.
Qed.

Theorem Sing_finite: forall x, finite {x}.
admit.
Qed.

Theorem adjoin_finite: forall X y, finite X -> finite (X :\/: {y}).
admit.
Qed.

Theorem binunion_finite: forall X, finite X -> forall Y, finite Y -> finite (X :\/: Y).
admit.
Qed.

Theorem famunion_nat_finite : forall X:set -> set, forall n, nat_p n -> (forall i :e n, finite (X i)) -> finite (\/_ i :e n, X i).
admit.
Qed.

Theorem Subq_finite : forall X, finite X -> forall Y, Y c= X -> finite Y.
admit.
Qed.

Definition infinite : set -> prop := fun A => ~finite A.

Section InfinitePrimes.

Infix + 360 right := add_nat.
Infix * 355 right := mul_nat.

Definition divides_nat : set -> set -> prop :=
  fun m n => m :e omega /\ n :e omega /\ exists k :e omega, m * k = n.

Theorem divides_nat_ref: forall n, nat_p n -> divides_nat n n.
admit.
Qed.

Theorem divides_nat_tra: forall k m n, divides_nat k m -> divides_nat m n -> divides_nat k n.
admit.
Qed.

Definition prime_nat : set -> prop :=
  fun n => n :e omega /\ 1 :e n /\ forall k :e omega, divides_nat k n -> k = 1 \/ k = n.

Theorem divides_nat_mulR: forall m n :e omega, divides_nat m (m * n).
admit.
Qed.

Theorem divides_nat_mulL: forall m n :e omega, divides_nat n (m * n).
admit.
Qed.

Theorem Pi_nat_divides: forall f:set->set,
  forall n, nat_p n ->
      (forall i :e n, nat_p (f i))
   -> (forall i :e n, divides_nat (f i) (Pi_nat f n)).
admit.
Qed.

Definition composite_nat : set -> prop :=
  fun n => n :e omega /\ exists k m :e omega, 1 :e k /\ 1 :e m /\ k * m = n.

Theorem prime_nat_or_composite_nat: forall n :e omega, 1 :e n -> prime_nat n \/ composite_nat n.
admit.
Qed.

Theorem prime_nat_divisor_ex: forall n, nat_p n -> 1 :e n -> exists p, prime_nat p /\ divides_nat p n.
admit.
Qed.

Theorem nat_1In_not_divides_ordsucc: forall m n, 1 :e m -> divides_nat m n -> ~divides_nat m (ordsucc n).
admit.
Qed.

Definition primes : set := {n :e omega|prime_nat n}.

Theorem form100_11_infinite_primes: infinite primes.
admit.
Qed.

End InfinitePrimes.

Section InfiniteRamsey.

Infix + 360 right := add_nat.

Theorem atleastp_omega_infinite: forall X, atleastp omega X -> infinite X.
admit.
Qed.

Theorem infinite_remove1: forall X, infinite X -> forall y, infinite (X :\: {y}).
admit.
Qed.

Theorem infinite_Finite_Subq_ex: forall X, infinite X ->
  forall n, nat_p n -> exists Y c= X, equip Y n.
admit.
Qed.

Theorem infiniteRamsey_lem: forall X, forall f g f':set -> set,
    infinite X
 -> (forall Z c= X, infinite Z -> f Z c= Z /\ infinite (f Z))
 -> (forall Z c= X, infinite Z -> g Z :e Z /\ g Z /:e f Z)
 -> f' 0 = f X
 -> (forall m, nat_p m -> f' (ordsucc m) = f (f' m))
 -> (forall m, nat_p m -> f' m c= X /\ infinite (f' m))
 /\ (forall m m' :e omega, m c= m' -> f' m' c= f' m)
 /\ (forall m m' :e omega, g (f' m) = g (f' m') -> m = m').
admit.
Qed.

Theorem infiniteRamsey: forall c, nat_p c -> forall n, nat_p n ->
  forall X, infinite X -> forall C:set -> set,
    (forall Y c= X, equip Y n -> C Y :e c)
 -> exists H c= X, exists i :e c, infinite H /\ forall Y c= H, equip Y n -> C Y = i.
admit.
Qed.

End InfiniteRamsey.

(*** Injection of set into itself that will correspond to x |-> (1,x) after pairing is defined. ***)
Definition Inj1 : set -> set := In_rec_i (fun X f => {0} :\/: {f x|x :e X}).

Theorem Inj1_eq : forall X:set, Inj1 X = {0} :\/: {Inj1 x|x :e X}.
admit.
Qed.

Theorem Inj1I1 : forall X:set, 0 :e Inj1 X.
admit.
Qed.

Theorem Inj1I2 : forall X x:set, x :e X -> Inj1 x :e Inj1 X.
admit.
Qed.

Theorem Inj1E : forall X y:set, y :e Inj1 X -> y = 0 \/ exists x :e X, y = Inj1 x.
admit.
Qed.

Theorem Inj1NE1 : forall x:set, Inj1 x <> 0.
admit.
Qed.

Theorem Inj1NE2 : forall x:set, Inj1 x /:e {0}.
admit.
Qed.

(*** Injection of set into itself that will correspond to x |-> (0,x) after pairing is defined. ***)
Definition Inj0 : set -> set := fun X => {Inj1 x|x :e X}.

Theorem Inj0I : forall X x:set, x :e X -> Inj1 x :e Inj0 X.
admit.
Qed.

Theorem Inj0E : forall X y:set, y :e Inj0 X -> exists x:set, x :e X /\ y = Inj1 x.
admit.
Qed.

(*** Unj : Left inverse of Inj1 and Inj0 ***)
Definition Unj : set -> set := In_rec_i (fun X f => {f x|x :e X :\: {0}}).

Theorem Unj_eq : forall X:set, Unj X = {Unj x|x :e X :\: {0}}.
admit.
Qed.

Theorem Unj_Inj1_eq : forall X:set, Unj (Inj1 X) = X.
admit.
Qed.

Theorem Inj1_inj : forall X Y:set, Inj1 X = Inj1 Y -> X = Y.
admit.
Qed.

Theorem Unj_Inj0_eq : forall X:set, Unj (Inj0 X) = X.
admit.
Qed.

Theorem Inj0_inj : forall X Y:set, Inj0 X = Inj0 Y -> X = Y.
admit.
Qed.

Theorem Inj0_0 : Inj0 0 = 0.
admit.
Qed.

Theorem Inj0_Inj1_neq : forall X Y:set, Inj0 X <> Inj1 Y.
admit.
Qed.

(*** setsum ***)
Definition setsum : set -> set -> set := fun X Y => {Inj0 x|x :e X} :\/: {Inj1 y|y :e Y}.
(* Unicode :+: "002b" *)
Infix :+: 450 left := setsum.

Theorem Inj0_setsum : forall X Y x:set, x :e X -> Inj0 x :e X :+: Y.
admit.
Qed.

Theorem Inj1_setsum : forall X Y y:set, y :e Y -> Inj1 y :e X :+: Y.
admit.
Qed.

Theorem setsum_Inj_inv : forall X Y z:set, z :e X :+: Y -> (exists x :e X, z = Inj0 x) \/ (exists y :e Y, z = Inj1 y).
admit.
Qed.

Theorem Inj0_setsum_0L : forall X:set, 0 :+: X = Inj0 X.
admit.
Qed.

Theorem Inj1_setsum_1L : forall X:set, 1 :+: X = Inj1 X.
admit.
Qed.

Section pair_setsum.
Let pair := setsum.
Definition proj0 : set -> set := fun Z => {Unj z|z :e Z, exists x:set, Inj0 x = z}.
Definition proj1 : set -> set := fun Z => {Unj z|z :e Z, exists y:set, Inj1 y = z}.

Theorem Inj0_pair_0_eq : Inj0 = pair 0.
admit.
Qed.

Theorem Inj1_pair_1_eq : Inj1 = pair 1.
admit.
Qed.

Theorem pairI0 : forall X Y x, x :e X -> pair 0 x :e pair X Y.
admit.
Qed.

Theorem pairI1 : forall X Y y, y :e Y -> pair 1 y :e pair X Y.
admit.
Qed.

Theorem pairE : forall X Y z, z :e pair X Y -> (exists x :e X, z = pair 0 x) \/ (exists y :e Y, z = pair 1 y).
admit.
Qed.

Theorem pairE0 : forall X Y x, pair 0 x :e pair X Y -> x :e X.
admit.
Qed.

Theorem pairE1 : forall X Y y, pair 1 y :e pair X Y -> y :e Y.
admit.
Qed.

Theorem proj0I : forall w u:set, pair 0 u :e w -> u :e proj0 w.
admit.
Qed.

Theorem proj0E : forall w u:set, u :e proj0 w -> pair 0 u :e w.
admit.
Qed.

Theorem proj1I : forall w u:set, pair 1 u :e w -> u :e proj1 w.
admit.
Qed.

Theorem proj1E : forall w u:set, u :e proj1 w -> pair 1 u :e w.
admit.
Qed.

Theorem proj0_pair_eq : forall X Y:set, proj0 (pair X Y) = X.
admit.
Qed.

Theorem proj1_pair_eq : forall X Y:set, proj1 (pair X Y) = Y.
admit.
Qed.

Opaque add_nat mul_nat omega ordsucc setminus binintersect ReplSep Sep famunion binunion Sing UPair exactly1of2 If_i If_ii If_iii Descr_Vo1 Descr_iii Descr_ii inv In_rec_i In_rec_ii In_rec_iii.

(*** Sigma X Y = {(x,y) | x in X, y in Y x} ***)
Definition Sigma : set -> (set -> set) -> set :=
fun X Y => \/_ x :e X, {pair x y|y :e Y x}.
(* Unicode Sigma_ "2211" *)
Binder+ Sigma_ , := Sigma.

Theorem Sigma_eta_proj0_proj1 : forall X:set, forall Y:set -> set, forall z :e (Sigma_ x :e X, Y x), pair (proj0 z) (proj1 z) = z /\ proj0 z :e X /\ proj1 z :e Y (proj0 z).
admit.
Qed.

Theorem proj0_Sigma : forall X:set, forall Y:set -> set, forall z:set, z :e (Sigma_ x :e X, Y x) -> proj0 z :e X.
admit.
Qed.

Theorem proj1_Sigma : forall X:set, forall Y:set -> set, forall z:set, z :e (Sigma_ x :e X, Y x) -> proj1 z :e Y (proj0 z).
admit.
Qed.

Theorem pair_Sigma : forall X:set, forall Y:set -> set, forall x :e X, forall y :e Y x, pair x y :e Sigma_ x :e X, Y x.
admit.
Qed.

Theorem pair_Sigma_E1 : forall X:set, forall Y:set->set, forall x y:set, pair x y :e (Sigma_ x :e X, Y x) -> y :e Y x.
admit.
Qed.

Theorem Sigma_E : forall X:set, forall Y:set->set, forall z:set, z :e (Sigma_ x :e X, Y x) -> exists x :e X, exists y :e Y x, z = pair x y.
admit.
Qed.

Definition setprod : set->set->set := fun X Y:set => Sigma_ x :e X, Y.
(* Unicode :*: "2a2f" *)
Infix :*: 440 left := setprod.
(*** lam X F = {(x,y) | x :e X, y :e F x} = \/_{x :e X} {(x,y) | y :e (F x)} = Sigma X F ***)
Let lam : set -> (set -> set) -> set := Sigma.
(***  ap f x = {proj1 z | z :e f,  exists y, z = pair x y}} ***)
Definition ap : set -> set -> set := fun f x => {proj1 z|z :e f, exists y:set, z = pair x y}.
Notation SetImplicitOp ap.
Notation SetLam Sigma.

Theorem lamI : forall X:set, forall F:set->set, forall x :e X, forall y :e F x, pair x y :e fun x :e X => F x.
admit.
Qed.

Theorem lamE : forall X:set, forall F:set->set, forall z:set, z :e (fun x :e X => F x) -> exists x :e X, exists y :e F x, z = pair x y.
admit.
Qed.

Theorem apI : forall f x y, pair x y :e f -> y :e f x.
admit.
Qed.

Theorem apE : forall f x y, y :e f x -> pair x y :e f.
admit.
Qed.

Theorem beta : forall X:set, forall F:set -> set, forall x:set, x :e X -> (fun x :e X => F x) x = F x.
admit.
Qed.

Theorem proj0_ap_0 : forall u, proj0 u = u 0.
admit.
Qed.

Theorem proj1_ap_1 : forall u, proj1 u = u 1.
admit.
Qed.

Theorem pair_ap_0 : forall x y:set, (pair x y) 0 = x.
admit.
Qed.

Theorem pair_ap_1 : forall x y:set, (pair x y) 1 = y.
admit.
Qed.

Theorem ap0_Sigma : forall X:set, forall Y:set -> set, forall z:set, z :e (Sigma_ x :e X, Y x) -> (z 0) :e X.
admit.
Qed.

Theorem ap1_Sigma : forall X:set, forall Y:set -> set, forall z:set, z :e (Sigma_ x :e X, Y x) -> (z 1) :e (Y (z 0)).
admit.
Qed.

Definition pair_p:set->prop
:= fun u:set => pair (u 0) (u 1) = u.

Theorem pair_p_I : forall x y, pair_p (pair x y).
admit.
Qed.

Theorem Subq_2_UPair01 : 2 c= {0,1}.
admit.
Qed.

Theorem tuple_pair : forall x y:set, pair x y = (x,y).
admit.
Qed.

Definition Pi : set -> (set -> set) -> set := fun X Y => {f :e Power (Sigma_ x :e X, Union (Y x)) | forall x :e X, f x :e Y x}.
(* Unicode Pi_ "220f" *)
Binder+ Pi_ , := Pi.

Theorem PiI : forall X:set, forall Y:set->set, forall f:set,
    (forall u :e f, pair_p u /\ u 0 :e X) -> (forall x :e X, f x :e Y x) -> f :e Pi_ x :e X, Y x.
admit.
Qed.

Theorem lam_Pi : forall X:set, forall Y:set -> set, forall F:set -> set,
 (forall x :e X, F x :e Y x) -> (fun x :e X => F x) :e (Pi_ x :e X, Y x).
admit.
Qed.

Theorem ap_Pi : forall X:set, forall Y:set -> set, forall f:set, forall x:set, f :e (Pi_ x :e X, Y x) -> x :e X -> f x :e Y x.
admit.
Qed.

Definition setexp : set->set->set := fun X Y:set => Pi_ y :e Y, X.
(* Superscript :^: *)
Infix :^: 430 left := setexp.

Theorem pair_tuple_fun : pair = (fun x y => (x,y)).
admit.
Qed.

Section Tuples.
Variable x0 x1: set.

Theorem tuple_2_0_eq: (x0,x1) 0 = x0.
admit.
Qed.

Theorem tuple_2_1_eq: (x0,x1) 1 = x1.
admit.
Qed.

End Tuples.

Theorem ReplEq_setprod_ext : forall X Y, forall F G:set -> set -> set, (forall x :e X, forall y :e Y, F x y = G x y) -> {F (w 0) (w 1)|w :e X :*: Y} = {G (w 0) (w 1)|w :e X :*: Y}.
admit.
Qed.

Theorem lamI2 : forall X, forall F:set->set, forall x :e X, forall y :e F x, (x,y) :e fun x :e X => F x.
admit.
Qed.

Theorem tuple_2_Sigma : forall X:set, forall Y:set -> set, forall x :e X, forall y :e Y x, (x,y) :e Sigma_ x :e X, Y x.
admit.
Qed.

Theorem tuple_2_setprod : forall X:set, forall Y:set, forall x :e X, forall y :e Y, (x,y) :e X :*: Y.
admit.
Qed.

End pair_setsum.
(* Unicode Sigma_ "2211" *)
Binder+ Sigma_ , := Sigma.
(* Unicode :*: "2a2f" *)
Infix :*: 440 left := setprod.
(* Unicode Pi_ "220f" *)
Binder+ Pi_ , := Pi.
(* Superscript :^: *)
Infix :^: 430 left := setexp.
(* Parameter DescrR_i_io_1 "1f005fdad5c6f98763a15a5e5539088f5d43b7d1be866b0b204fda1ce9ed9248" "1d3fd4a14ef05bd43f5c147d7966cf05fd2fed808eea94f56380454b9a6044b2" *)
Definition DescrR_i_io_1 : (set->(set->prop)->prop) -> set := fun R => Eps_i (fun x => (exists y:set -> prop, R x y) /\ (forall y z:set -> prop, R x y -> R x z -> y = z)).
(* Parameter DescrR_i_io_2 "28d8599686476258c12dcc5fc5f5974335febd7d5259e1a8e5918b7f9b91ca03" "768eb2ad186988375e6055394e36e90c81323954b8a44eb08816fb7a84db2272" *)
Definition DescrR_i_io_2 : (set->(set->prop)->prop) -> set->prop := fun R => Descr_Vo1 (fun y => R (DescrR_i_io_1 R) y).

Theorem DescrR_i_io_12 : forall R:set->(set->prop)->prop, (exists x, (exists y:set->prop, R x y) /\ (forall y z:set -> prop, R x y -> R x z -> y = z)) -> R (DescrR_i_io_1 R) (DescrR_i_io_2 R).
admit.
Qed.

(** Conway describes this way of formalizing in ZF in an appendix to Part Zero of his book,
    but rejects formalization in favor of "Mathematician's Liberation."
 **)
Definition PNoEq_ : set -> (set -> prop) -> (set -> prop) -> prop
 := fun alpha p q => forall beta :e alpha, p beta <-> q beta.

Theorem PNoEq_ref_ : forall alpha, forall p:set -> prop, PNoEq_ alpha p p.
admit.
Qed.

Theorem PNoEq_sym_ : forall alpha, forall p q:set -> prop, PNoEq_ alpha p q -> PNoEq_ alpha q p.
admit.
Qed.

Theorem PNoEq_tra_ : forall alpha, forall p q r:set -> prop, PNoEq_ alpha p q -> PNoEq_ alpha q r -> PNoEq_ alpha p r.
admit.
Qed.

Theorem PNoEq_antimon_ : forall p q:set -> prop, forall alpha, ordinal alpha -> forall beta :e alpha, PNoEq_ alpha p q -> PNoEq_ beta p q.
admit.
Qed.

Definition PNoLt_ : set -> (set -> prop) -> (set -> prop) -> prop
 := fun alpha p q => exists beta :e alpha, PNoEq_ beta p q /\ ~p beta /\ q beta.

Theorem PNoLt_E_ : forall alpha, forall p q:set -> prop, PNoLt_ alpha p q ->
  forall R:prop, (forall beta, beta :e alpha -> PNoEq_ beta p q -> ~p beta -> q beta -> R) -> R.
admit.
Qed.

Theorem PNoLt_irref_ : forall alpha, forall p:set -> prop, ~PNoLt_ alpha p p.
admit.
Qed.

Theorem PNoLt_mon_ : forall p q:set -> prop, forall alpha, ordinal alpha -> forall beta :e alpha, PNoLt_ beta p q -> PNoLt_ alpha p q.
admit.
Qed.

Theorem PNoLt_trichotomy_or_ : forall p q:set -> prop, forall alpha, ordinal alpha
  -> PNoLt_ alpha p q \/ PNoEq_ alpha p q \/ PNoLt_ alpha q p.
admit.
Qed.

(* Parameter PNoLt "2336eb45d48549dd8a6a128edc17a8761fd9043c180691483bcf16e1acc9f00a" "8f57a05ce4764eff8bc94b278352b6755f1a46566cd7220a5488a4a595a47189" *)
Definition PNoLt : set -> (set -> prop) -> set -> (set -> prop) -> prop
 := fun alpha p beta q =>
        PNoLt_ (alpha :/\: beta) p q
     \/ alpha :e beta /\ PNoEq_ alpha p q /\ q alpha
     \/ beta :e alpha /\ PNoEq_ beta p q /\ ~p beta.

Theorem PNoLtI1 : forall alpha beta, forall p q:set -> prop,
  PNoLt_ (alpha :/\: beta) p q -> PNoLt alpha p beta q.
admit.
Qed.

Theorem PNoLtI2 : forall alpha beta, forall p q:set -> prop,
  alpha :e beta -> PNoEq_ alpha p q -> q alpha -> PNoLt alpha p beta q.
admit.
Qed.

Theorem PNoLtI3 : forall alpha beta, forall p q:set -> prop,
  beta :e alpha -> PNoEq_ beta p q -> ~p beta -> PNoLt alpha p beta q.
admit.
Qed.

Theorem PNoLtE : forall alpha beta, forall p q:set -> prop,
  PNoLt alpha p beta q ->
  forall R:prop,
      (PNoLt_ (alpha :/\: beta) p q -> R)
   -> (alpha :e beta -> PNoEq_ alpha p q -> q alpha -> R)
   -> (beta :e alpha -> PNoEq_ beta p q -> ~p beta -> R)
   -> R.
admit.
Qed.

Theorem PNoLt_irref : forall alpha, forall p:set -> prop, ~PNoLt alpha p alpha p.
admit.
Qed.

Theorem PNoLt_trichotomy_or : forall alpha beta, forall p q:set -> prop,
 ordinal alpha -> ordinal beta ->
 PNoLt alpha p beta q \/ alpha = beta /\ PNoEq_ alpha p q \/ PNoLt beta q alpha p.
admit.
Qed.

Theorem PNoLtEq_tra : forall alpha beta, ordinal alpha -> ordinal beta -> forall p q r:set -> prop, PNoLt alpha p beta q -> PNoEq_ beta q r -> PNoLt alpha p beta r.
admit.
Qed.

Theorem PNoEqLt_tra : forall alpha beta, ordinal alpha -> ordinal beta -> forall p q r:set -> prop, PNoEq_ alpha p q -> PNoLt alpha q beta r -> PNoLt alpha p beta r.
admit.
Qed.

Theorem PNoLt_tra : forall alpha beta gamma, ordinal alpha -> ordinal beta -> ordinal gamma -> forall p q r:set -> prop, PNoLt alpha p beta q -> PNoLt beta q gamma r -> PNoLt alpha p gamma r.
admit.
Qed.

Definition PNoLe : set -> (set -> prop) -> set -> (set -> prop) -> prop
   := fun alpha p beta q => PNoLt alpha p beta q \/ alpha = beta /\ PNoEq_ alpha p q.

Theorem PNoLeI1 : forall alpha beta, forall p q:set -> prop,
   PNoLt alpha p beta q -> PNoLe alpha p beta q.
admit.
Qed.

Theorem PNoLeI2 : forall alpha, forall p q:set -> prop,
   PNoEq_ alpha p q -> PNoLe alpha p alpha q.
admit.
Qed.

Theorem PNoLe_ref : forall alpha, forall p:set -> prop, PNoLe alpha p alpha p.
admit.
Qed.

Theorem PNoLe_antisym : forall alpha beta, ordinal alpha -> ordinal beta ->
 forall p q:set -> prop,
 PNoLe alpha p beta q -> PNoLe beta q alpha p -> alpha = beta /\ PNoEq_ alpha p q.
admit.
Qed.

Theorem PNoLtLe_tra : forall alpha beta gamma, ordinal alpha -> ordinal beta -> ordinal gamma -> forall p q r:set -> prop, PNoLt alpha p beta q -> PNoLe beta q gamma r -> PNoLt alpha p gamma r.
admit.
Qed.

Theorem PNoLeLt_tra : forall alpha beta gamma, ordinal alpha -> ordinal beta -> ordinal gamma -> forall p q r:set -> prop, PNoLe alpha p beta q -> PNoLt beta q gamma r -> PNoLt alpha p gamma r.
admit.
Qed.

Theorem PNoEqLe_tra : forall alpha beta, ordinal alpha -> ordinal beta -> forall p q r:set -> prop, PNoEq_ alpha p q -> PNoLe alpha q beta r -> PNoLe alpha p beta r.
admit.
Qed.

Theorem PNoLe_tra : forall alpha beta gamma, ordinal alpha -> ordinal beta -> ordinal gamma -> forall p q r:set -> prop, PNoLe alpha p beta q -> PNoLe beta q gamma r -> PNoLe alpha p gamma r.
admit.
Qed.

Definition PNo_downc : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
 := fun L alpha p => exists beta, ordinal beta /\ exists q:set -> prop, L beta q /\ PNoLe alpha p beta q.
Definition PNo_upc : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
 := fun R alpha p => exists beta, ordinal beta /\ exists q:set -> prop, R beta q /\ PNoLe beta q alpha p.

Theorem PNoLe_downc : forall L:set -> (set -> prop) -> prop, forall alpha beta, forall p q:set -> prop,
  ordinal alpha -> ordinal beta ->
  PNo_downc L alpha p -> PNoLe beta q alpha p -> PNo_downc L beta q.
admit.
Qed.

Theorem PNo_downc_ref : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, L alpha p -> PNo_downc L alpha p.
admit.
Qed.

Theorem PNo_upc_ref : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, R alpha p -> PNo_upc R alpha p.
admit.
Qed.

Theorem PNoLe_upc : forall R:set -> (set -> prop) -> prop, forall alpha beta, forall p q:set -> prop,
  ordinal alpha -> ordinal beta ->
  PNo_upc R alpha p -> PNoLe alpha p beta q -> PNo_upc R beta q.
admit.
Qed.

Definition PNoLt_pwise : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> prop
  := fun L R => forall gamma, ordinal gamma -> forall p:set -> prop, L gamma p -> forall delta, ordinal delta -> forall q:set -> prop, R delta q -> PNoLt gamma p delta q.

Theorem PNoLt_pwise_downc_upc : forall L R:set -> (set -> prop) -> prop,
    PNoLt_pwise L R -> PNoLt_pwise (PNo_downc L) (PNo_upc R).
admit.
Qed.

Definition PNo_rel_strict_upperbd : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L alpha p =>
       forall beta :e alpha, forall q:set -> prop, PNo_downc L beta q -> PNoLt beta q alpha p.
Definition PNo_rel_strict_lowerbd : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun R alpha p =>
       forall beta :e alpha, forall q:set -> prop, PNo_upc R beta q -> PNoLt alpha p beta q.
Definition PNo_rel_strict_imv : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R alpha p => PNo_rel_strict_upperbd L alpha p /\ PNo_rel_strict_lowerbd R alpha p.

Theorem PNoEq_rel_strict_upperbd : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_rel_strict_upperbd L alpha p -> PNo_rel_strict_upperbd L alpha q.
admit.
Qed.

Theorem PNo_rel_strict_upperbd_antimon : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, forall beta :e alpha,
  PNo_rel_strict_upperbd L alpha p -> PNo_rel_strict_upperbd L beta p.
admit.
Qed.

Theorem PNoEq_rel_strict_lowerbd : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_rel_strict_lowerbd R alpha p -> PNo_rel_strict_lowerbd R alpha q.
admit.
Qed.

Theorem PNo_rel_strict_lowerbd_antimon : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, forall beta :e alpha,
  PNo_rel_strict_lowerbd R alpha p -> PNo_rel_strict_lowerbd R beta p.
admit.
Qed.

Theorem PNoEq_rel_strict_imv : forall L R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_imv L R alpha q.
admit.
Qed.

Theorem PNo_rel_strict_imv_antimon : forall L R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p:set -> prop, forall beta :e alpha,
  PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_imv L R beta p.
admit.
Qed.

Definition PNo_rel_strict_uniq_imv : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R alpha p => PNo_rel_strict_imv L R alpha p /\ forall q:set -> prop, PNo_rel_strict_imv L R alpha q -> PNoEq_ alpha p q.
Definition PNo_rel_strict_split_imv : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R alpha p =>
         PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta /\ delta <> alpha)
      /\ PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta \/ delta = alpha).

Theorem PNo_extend0_eq : forall alpha, forall p:set -> prop, PNoEq_ alpha p (fun delta => p delta /\ delta <> alpha).
admit.
Qed.

Theorem PNo_extend1_eq : forall alpha, forall p:set -> prop, PNoEq_ alpha p (fun delta => p delta \/ delta = alpha).
admit.
Qed.

Theorem PNo_rel_imv_ex : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha ->
      (exists p:set -> prop, PNo_rel_strict_uniq_imv L R alpha p)
   \/ (exists tau :e alpha, exists p:set -> prop, PNo_rel_strict_split_imv L R tau p).
admit.
Qed.

Definition PNo_lenbdd : set -> (set -> (set -> prop) -> prop) -> prop
  := fun alpha L => forall beta, forall p:set -> prop, L beta p -> beta :e alpha.

Theorem PNo_lenbdd_strict_imv_extend0 : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha -> PNo_lenbdd alpha L -> PNo_lenbdd alpha R ->
  forall p:set -> prop,
  PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta /\ delta <> alpha).
admit.
Qed.

Theorem PNo_lenbdd_strict_imv_extend1 : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha -> PNo_lenbdd alpha L -> PNo_lenbdd alpha R ->
  forall p:set -> prop,
  PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_imv L R (ordsucc alpha) (fun delta => p delta \/ delta = alpha).
admit.
Qed.

Theorem PNo_lenbdd_strict_imv_split : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha -> PNo_lenbdd alpha L -> PNo_lenbdd alpha R ->
  forall p:set -> prop,
  PNo_rel_strict_imv L R alpha p -> PNo_rel_strict_split_imv L R alpha p.
admit.
Qed.

Theorem PNo_rel_imv_bdd_ex : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> exists beta :e ordsucc alpha,
      exists p:set -> prop, PNo_rel_strict_split_imv L R beta p.
admit.
Qed.

Definition PNo_strict_upperbd : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L alpha p =>
       forall beta, ordinal beta -> forall q:set -> prop, L beta q -> PNoLt beta q alpha p.
Definition PNo_strict_lowerbd : (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun R alpha p =>
       forall beta, ordinal beta -> forall q:set -> prop, R beta q -> PNoLt alpha p beta q.
Definition PNo_strict_imv : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R alpha p => PNo_strict_upperbd L alpha p /\ PNo_strict_lowerbd R alpha p.

Theorem PNoEq_strict_upperbd : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_strict_upperbd L alpha p -> PNo_strict_upperbd L alpha q.
admit.
Qed.

Theorem PNoEq_strict_lowerbd : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_strict_lowerbd R alpha p -> PNo_strict_lowerbd R alpha q.
admit.
Qed.

Theorem PNoEq_strict_imv : forall L R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha -> forall p q:set -> prop,
  PNoEq_ alpha p q -> PNo_strict_imv L R alpha p -> PNo_strict_imv L R alpha q.
admit.
Qed.

Theorem PNo_strict_upperbd_imp_rel_strict_upperbd : forall L:set -> (set -> prop) -> prop, forall alpha, ordinal alpha ->
  forall beta :e ordsucc alpha, forall p:set -> prop,
   PNo_strict_upperbd L alpha p -> PNo_rel_strict_upperbd L beta p.
admit.
Qed.

Theorem PNo_strict_lowerbd_imp_rel_strict_lowerbd : forall R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha ->
  forall beta :e ordsucc alpha, forall p:set -> prop,
   PNo_strict_lowerbd R alpha p -> PNo_rel_strict_lowerbd R beta p.
admit.
Qed.

Theorem PNo_strict_imv_imp_rel_strict_imv : forall L R:set -> (set -> prop) -> prop, forall alpha, ordinal alpha ->
  forall beta :e ordsucc alpha, forall p:set -> prop,
   PNo_strict_imv L R alpha p -> PNo_rel_strict_imv L R beta p.
admit.
Qed.

Theorem PNo_rel_split_imv_imp_strict_imv : forall L R:set -> (set -> prop) -> prop,
  forall alpha, ordinal alpha -> forall p:set -> prop,
       PNo_rel_strict_split_imv L R alpha p
    -> PNo_strict_imv L R alpha p.
admit.
Qed.

Theorem PNo_lenbdd_strict_imv_ex : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> exists beta :e ordsucc alpha,
      exists p:set -> prop, PNo_strict_imv L R beta p.
admit.
Qed.

Definition PNo_least_rep : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R beta p => ordinal beta
       /\ PNo_strict_imv L R beta p
       /\ forall gamma :e beta,
           forall q:set -> prop, ~PNo_strict_imv L R gamma q.
Definition PNo_least_rep2 : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> (set -> prop) -> prop
  := fun L R beta p => PNo_least_rep L R beta p /\ forall x, x /:e beta -> ~p x.

Theorem PNo_strict_imv_pred_eq : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha -> forall p q:set -> prop,
     PNo_least_rep L R alpha p
  -> PNo_strict_imv L R alpha q
  -> forall beta :e alpha, p beta <-> q beta.
admit.
Qed.

Theorem PNo_lenbdd_least_rep2_exuniq2 : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> exists beta,
        (exists p:set -> prop, PNo_least_rep2 L R beta p)
     /\ (forall p q:set -> prop, PNo_least_rep2 L R beta p -> PNo_least_rep2 L R beta q -> p = q).
admit.
Qed.

(* Parameter PNo_bd "1b39e85278dd9e820e7b6258957386ac55934d784aa3702c57a28ec807453b01" "ed76e76de9b58e621daa601cca73b4159a437ba0e73114924cb92ec8044f2aa2" *)
Definition PNo_bd : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set
 := fun L R => DescrR_i_io_1 (PNo_least_rep2 L R).
(* Parameter PNo_pred "be07c39b18a3aa93f066f4c064fee3941ec27cfd07a4728b6209135c77ce5704" "b2d51dcfccb9527e9551b0d0c47d891c9031a1d4ee87bba5a9ae5215025d107a" *)
Definition PNo_pred : (set -> (set -> prop) -> prop) -> (set -> (set -> prop) -> prop) -> set -> prop
 := fun L R => DescrR_i_io_2 (PNo_least_rep2 L R).

Theorem PNo_bd_pred_lem : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> PNo_least_rep2 L R (PNo_bd L R) (PNo_pred L R).
admit.
Qed.

Theorem PNo_bd_pred : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> PNo_least_rep L R (PNo_bd L R) (PNo_pred L R).
admit.
Qed.

Theorem PNo_bd_In : forall L R:set -> (set -> prop) -> prop,
  PNoLt_pwise L R ->
  forall alpha, ordinal alpha
   -> PNo_lenbdd alpha L
   -> PNo_lenbdd alpha R
   -> PNo_bd L R :e ordsucc alpha.
admit.
Qed.

Opaque Sigma Pi ap PNo_pred PNo_bd PNoLt DescrR_i_io_1 DescrR_i_io_2.

Section TaggedSets.
Let tag : set -> set := fun alpha => SetAdjoin alpha {1}.
Postfix ' 100 := tag.

Theorem not_TransSet_Sing1 : ~TransSet {1}.
admit.
Qed.

Theorem not_ordinal_Sing1 : ~ordinal {1}.
admit.
Qed.

Theorem tagged_not_ordinal : forall y, ~ordinal (y ').
admit.
Qed.

Theorem tagged_notin_ordinal : forall alpha y, ordinal alpha -> (y ') /:e alpha.
admit.
Qed.

Theorem tagged_eqE_Subq : forall alpha beta, ordinal alpha -> alpha ' = beta ' -> alpha c= beta.
admit.
Qed.

Theorem tagged_eqE_eq : forall alpha beta, ordinal alpha -> ordinal beta -> alpha ' = beta ' -> alpha = beta.
admit.
Qed.

Theorem tagged_ReplE : forall alpha beta, ordinal alpha -> ordinal beta -> beta ' :e {gamma '|gamma :e alpha} -> beta :e alpha.
admit.
Qed.

Theorem ordinal_notin_tagged_Repl : forall alpha Y, ordinal alpha -> alpha /:e {y '|y :e Y}.
admit.
Qed.

Definition SNoElts_ : set -> set := fun alpha => alpha :\/: {beta '|beta :e alpha}.

Theorem SNoElts_mon : forall alpha beta, alpha c= beta -> SNoElts_ alpha c= SNoElts_ beta.
admit.
Qed.

Definition SNo_ : set -> set -> prop := fun alpha x =>
    x c= SNoElts_ alpha
 /\ forall beta :e alpha, exactly1of2 (beta ' :e x) (beta :e x).
Definition PSNo : set -> (set -> prop) -> set :=
  fun alpha p => {beta :e alpha|p beta} :\/: {beta '|beta :e alpha, ~p beta}.

Theorem PNoEq_PSNo : forall alpha, ordinal alpha -> forall p:set -> prop, PNoEq_ alpha (fun beta => beta :e PSNo alpha p) p.
admit.
Qed.

Theorem SNo_PSNo : forall alpha, ordinal alpha -> forall p:set -> prop, SNo_ alpha (PSNo alpha p).
admit.
Qed.

Theorem SNo_PSNo_eta_ : forall alpha x, ordinal alpha -> SNo_ alpha x -> x = PSNo alpha (fun beta => beta :e x).
admit.
Qed.

(* Parameter SNo "87d7604c7ea9a2ae0537066afb358a94e6ac0cd80ba277e6b064422035a620cf" "11faa7a742daf8e4f9aaf08e90b175467e22d0e6ad3ed089af1be90cfc17314b" *)
Definition SNo : set -> prop := fun x => exists alpha, ordinal alpha /\ SNo_ alpha x.

Theorem SNo_SNo : forall alpha, ordinal alpha -> forall z, SNo_ alpha z -> SNo z.
admit.
Qed.

(* Parameter SNoLev "bf1decfd8f4025a2271f2a64d1290eae65933d0f2f0f04b89520449195f1aeb8" "293b77d05dab711767d698fb4484aab2a884304256765be0733e6bd5348119e8" *)
Definition SNoLev : set -> set := fun x => Eps_i (fun alpha => ordinal alpha /\ SNo_ alpha x).

Theorem SNoLev_uniq_Subq : forall x alpha beta, ordinal alpha -> ordinal beta -> SNo_ alpha x -> SNo_ beta x -> alpha c= beta.
admit.
Qed.

Theorem SNoLev_uniq : forall x alpha beta, ordinal alpha -> ordinal beta -> SNo_ alpha x -> SNo_ beta x -> alpha = beta.
admit.
Qed.

Theorem SNoLev_prop : forall x, SNo x -> ordinal (SNoLev x) /\ SNo_ (SNoLev x) x.
admit.
Qed.

Theorem SNoLev_ordinal : forall x, SNo x -> ordinal (SNoLev x).
admit.
Qed.

Theorem SNoLev_ : forall x, SNo x -> SNo_ (SNoLev x) x.
admit.
Qed.

Theorem SNo_PSNo_eta : forall x, SNo x -> x = PSNo (SNoLev x) (fun beta => beta :e x).
admit.
Qed.

Theorem SNoLev_PSNo : forall alpha, ordinal alpha -> forall p:set -> prop, SNoLev (PSNo alpha p) = alpha.
admit.
Qed.

Theorem SNo_Subq : forall x y, SNo x -> SNo y -> SNoLev x c= SNoLev y -> (forall alpha :e SNoLev x, alpha :e x <-> alpha :e y) -> x c= y.
admit.
Qed.

Definition SNoEq_ : set -> set -> set -> prop
 := fun alpha x y => PNoEq_ alpha (fun beta => beta :e x) (fun beta => beta :e y).

Theorem SNoEq_I : forall alpha x y, (forall beta :e alpha, beta :e x <-> beta :e y) -> SNoEq_ alpha x y.
admit.
Qed.

Theorem SNo_eq : forall x y, SNo x -> SNo y -> SNoLev x = SNoLev y -> SNoEq_ (SNoLev x) x y -> x = y.
admit.
Qed.

End TaggedSets.
Definition SNoLt : set -> set -> prop :=
  fun x y => PNoLt (SNoLev x) (fun beta => beta :e x) (SNoLev y) (fun beta => beta :e y).
Infix < 490 := SNoLt.
Definition SNoLe : set -> set -> prop :=
  fun x y => PNoLe (SNoLev x) (fun beta => beta :e x) (SNoLev y) (fun beta => beta :e y).
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.

Theorem SNoLtLe : forall x y, x < y -> x <= y.
admit.
Qed.

Theorem SNoLeE : forall x y, SNo x -> SNo y -> x <= y -> x < y \/ x = y.
admit.
Qed.

Theorem SNoEq_sym_ : forall alpha x y, SNoEq_ alpha x y -> SNoEq_ alpha y x.
admit.
Qed.

Theorem SNoEq_tra_ : forall alpha x y z, SNoEq_ alpha x y -> SNoEq_ alpha y z -> SNoEq_ alpha x z.
admit.
Qed.

Theorem SNoLtE : forall x y, SNo x -> SNo y -> x < y ->
 forall p:prop,
    (forall z, SNo z -> SNoLev z :e SNoLev x :/\: SNoLev y -> SNoEq_ (SNoLev z) z x -> SNoEq_ (SNoLev z) z y -> x < z -> z < y -> SNoLev z /:e x -> SNoLev z :e y -> p)
 -> (SNoLev x :e SNoLev y -> SNoEq_ (SNoLev x) x y -> SNoLev x :e y -> p)
 -> (SNoLev y :e SNoLev x -> SNoEq_ (SNoLev y) x y -> SNoLev y /:e x -> p)
 -> p.
admit.
Qed.

(** The analogous thm to PNoLtI1 can be recovered by SNoLt_tra (transitivity) and SNoLtI2 and SNoLtI3. **)
Theorem SNoLtI2 : forall x y,
     SNoLev x :e SNoLev y
  -> SNoEq_ (SNoLev x) x y
  -> SNoLev x :e y
  -> x < y.
admit.
Qed.

Theorem SNoLtI3 : forall x y,
     SNoLev y :e SNoLev x
  -> SNoEq_ (SNoLev y) x y
  -> SNoLev y /:e x
  -> x < y.
admit.
Qed.

Theorem SNoLt_irref : forall x, ~SNoLt x x.
admit.
Qed.

Theorem SNoLt_trichotomy_or : forall x y, SNo x -> SNo y -> x < y \/ x = y \/ y < x.
admit.
Qed.

Theorem SNoLt_trichotomy_or_impred : forall x y, SNo x -> SNo y ->
  forall p:prop,
      (x < y -> p)
   -> (x = y -> p)
   -> (y < x -> p)
   -> p.
admit.
Qed.

Theorem SNoLt_tra : forall x y z, SNo x -> SNo y -> SNo z -> x < y -> y < z -> x < z.
admit.
Qed.

Theorem SNoLe_ref : forall x, SNoLe x x.
admit.
Qed.

Theorem SNoLe_antisym : forall x y, SNo x -> SNo y -> x <= y -> y <= x -> x = y.
admit.
Qed.

Theorem SNoLtLe_tra : forall x y z, SNo x -> SNo y -> SNo z -> x < y -> y <= z -> x < z.
admit.
Qed.

Theorem SNoLeLt_tra : forall x y z, SNo x -> SNo y -> SNo z -> x <= y -> y < z -> x < z.
admit.
Qed.

Theorem SNoLe_tra : forall x y z, SNo x -> SNo y -> SNo z -> x <= y -> y <= z -> x <= z.
admit.
Qed.

Theorem SNoLtLe_or : forall x y, SNo x -> SNo y -> x < y \/ y <= x.
admit.
Qed.

Theorem SNoLt_PSNo_PNoLt : forall alpha beta, forall p q:set -> prop,
 ordinal alpha -> ordinal beta ->
 PSNo alpha p < PSNo beta q -> PNoLt alpha p beta q.
admit.
Qed.

Theorem PNoLt_SNoLt_PSNo : forall alpha beta, forall p q:set -> prop,
 ordinal alpha -> ordinal beta ->
 PNoLt alpha p beta q -> PSNo alpha p < PSNo beta q.
admit.
Qed.

Definition SNoCut : set -> set -> set :=
  fun L R => PSNo (PNo_bd (fun alpha p => ordinal alpha /\ PSNo alpha p :e L) (fun alpha p => ordinal alpha /\ PSNo alpha p :e R)) (PNo_pred (fun alpha p => ordinal alpha /\ PSNo alpha p :e L) (fun alpha p => ordinal alpha /\ PSNo alpha p :e R)).
Definition SNoCutP : set -> set -> prop :=
 fun L R =>
      (forall x :e L, SNo x)
   /\ (forall y :e R, SNo y)
   /\ (forall x :e L, forall y :e R, x < y).

Theorem SNoCutP_SNoCut : forall L R, SNoCutP L R
 -> SNo (SNoCut L R)
 /\ SNoLev (SNoCut L R) :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y)))
 /\ (forall x :e L, x < SNoCut L R)
 /\ (forall y :e R, SNoCut L R < y)
 /\ (forall z, SNo z -> (forall x :e L, x < z) -> (forall y :e R, z < y) -> SNoLev (SNoCut L R) c= SNoLev z /\ SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) z).
admit.
Qed.

Theorem SNoCutP_SNoCut_impred : forall L R, SNoCutP L R
 -> forall p:prop,
      (SNo (SNoCut L R)
    -> SNoLev (SNoCut L R) :e ordsucc ((\/_ x :e L, ordsucc (SNoLev x)) :\/: (\/_ y :e R, ordsucc (SNoLev y)))
    -> (forall x :e L, x < SNoCut L R)
    -> (forall y :e R, SNoCut L R < y)
    -> (forall z, SNo z -> (forall x :e L, x < z) -> (forall y :e R, z < y) -> SNoLev (SNoCut L R) c= SNoLev z /\ SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) z)
    -> p)
   -> p.
admit.
Qed.

Theorem SNoCutP_L_0: forall L, (forall x :e L, SNo x) -> SNoCutP L 0.
admit.
Qed.

Theorem SNoCutP_0_0: SNoCutP 0 0.
admit.
Qed.

Definition SNoS_ : set -> set := fun alpha => {x :e Power (SNoElts_ alpha)|exists beta :e alpha, SNo_ beta x}.

Theorem SNoS_E : forall alpha, ordinal alpha -> forall x :e SNoS_ alpha, exists beta :e alpha, SNo_ beta x.
admit.
Qed.

Section TaggedSets2.
Let tag : set -> set := fun alpha => SetAdjoin alpha {1}.
Postfix ' 100 := tag.

Theorem SNoS_I : forall alpha, ordinal alpha -> forall x, forall beta :e alpha, SNo_ beta x -> x :e SNoS_ alpha.
admit.
Qed.

Theorem SNoS_I2 : forall x y, SNo x -> SNo y -> SNoLev x :e SNoLev y -> x :e SNoS_ (SNoLev y).
admit.
Qed.  

Theorem SNoS_Subq : forall alpha beta, ordinal alpha -> ordinal beta -> alpha c= beta -> SNoS_ alpha c= SNoS_ beta.
admit.
Qed.

Theorem SNoLev_uniq2 : forall alpha, ordinal alpha -> forall x, SNo_ alpha x -> SNoLev x = alpha.
admit.
Qed.

Theorem SNoS_E2 : forall alpha, ordinal alpha -> forall x :e SNoS_ alpha,
 forall p:prop,
     (SNoLev x :e alpha -> ordinal (SNoLev x) -> SNo x -> SNo_ (SNoLev x) x -> p)
  -> p.
admit.
Qed.

Theorem SNoS_In_neq : forall w, SNo w -> forall x :e SNoS_ (SNoLev w), x <> w.
admit.
Qed.

Theorem SNoS_SNoLev : forall z, SNo z -> z :e SNoS_ (ordsucc (SNoLev z)).
admit.
Qed.

Definition SNoL : set -> set := fun z => {x :e SNoS_ (SNoLev z) | x < z}.
Definition SNoR : set -> set := fun z => {y :e SNoS_ (SNoLev z) | z < y}.

Theorem SNoCutP_SNoL_SNoR: forall z, SNo z -> SNoCutP (SNoL z) (SNoR z).
admit.
Qed.

Theorem SNoL_E : forall x, SNo x -> forall w :e SNoL x,
  forall p:prop,
       (SNo w -> SNoLev w :e SNoLev x -> w < x -> p)
    -> p.
admit.
Qed.

Theorem SNoR_E : forall x, SNo x -> forall z :e SNoR x,
  forall p:prop,
       (SNo z -> SNoLev z :e SNoLev x -> x < z -> p)
    -> p.
admit.
Qed.

Theorem SNoL_SNoS_ : forall z, SNoL z c= SNoS_ (SNoLev z).
admit.
Qed.

Theorem SNoR_SNoS_ : forall z, SNoR z c= SNoS_ (SNoLev z).
admit.
Qed.

Theorem SNoL_SNoS : forall x, SNo x -> forall w :e SNoL x, w :e SNoS_ (SNoLev x).
admit.
Qed.

Theorem SNoR_SNoS : forall x, SNo x -> forall z :e SNoR x, z :e SNoS_ (SNoLev x).
admit.
Qed.

Theorem SNoL_I : forall z, SNo z -> forall x, SNo x -> SNoLev x :e SNoLev z -> x < z -> x :e SNoL z.
admit.
Qed.

Theorem SNoR_I : forall z, SNo z -> forall y, SNo y -> SNoLev y :e SNoLev z -> z < y -> y :e SNoR z.
admit.
Qed.

Theorem SNo_eta : forall z, SNo z -> z = SNoCut (SNoL z) (SNoR z).
admit.
Qed.

Theorem SNoCutP_SNo_SNoCut : forall L R, SNoCutP L R -> SNo (SNoCut L R).
admit.
Qed.

Theorem SNoCutP_SNoCut_L : forall L R, SNoCutP L R -> forall x :e L, x < SNoCut L R.
admit.
Qed.

Theorem SNoCutP_SNoCut_R : forall L R, SNoCutP L R -> forall y :e R, SNoCut L R < y.
admit.
Qed.

Theorem SNoCutP_SNoCut_fst : forall L R, SNoCutP L R ->
 forall z, SNo z
   -> (forall x :e L, x < z)
   -> (forall y :e R, z < y)
   -> SNoLev (SNoCut L R) c= SNoLev z
   /\ SNoEq_ (SNoLev (SNoCut L R)) (SNoCut L R) z.
admit.
Qed.

Theorem SNoCut_Le : forall L1 R1 L2 R2, SNoCutP L1 R1 -> SNoCutP L2 R2
  -> (forall w :e L1, w < SNoCut L2 R2)
  -> (forall z :e R2, SNoCut L1 R1 < z)
  -> SNoCut L1 R1 <= SNoCut L2 R2.
admit.
Qed.

Theorem SNoCut_ext : forall L1 R1 L2 R2, SNoCutP L1 R1 -> SNoCutP L2 R2
  -> (forall w :e L1, w < SNoCut L2 R2)
  -> (forall z :e R1, SNoCut L2 R2 < z)
  -> (forall w :e L2, w < SNoCut L1 R1)
  -> (forall z :e R2, SNoCut L1 R1 < z)
  -> SNoCut L1 R1 = SNoCut L2 R2.
admit.
Qed.

Theorem SNoLt_SNoL_or_SNoR_impred: forall x y, SNo x -> SNo y -> x < y ->
 forall p:prop,
    (forall z :e SNoL y, z :e SNoR x -> p)
 -> (x :e SNoL y -> p)
 -> (y :e SNoR x -> p)
 -> p.
admit.
Qed.

Theorem SNoL_or_SNoR_impred: forall x y, SNo x -> SNo y ->
 forall p:prop,
    (x = y -> p)
 -> (forall z :e SNoL y, z :e SNoR x -> p)
 -> (x :e SNoL y -> p)
 -> (y :e SNoR x -> p)
 -> (forall z :e SNoR y, z :e SNoL x -> p)
 -> (x :e SNoR y -> p)
 -> (y :e SNoL x -> p)
 -> p.
admit.
Qed.

Theorem SNoL_SNoCutP_ex: forall L R, SNoCutP L R -> forall w :e SNoL (SNoCut L R), exists w' :e L, w <= w'.
admit.
Qed.

Theorem SNoR_SNoCutP_ex: forall L R, SNoCutP L R -> forall z :e SNoR (SNoCut L R), exists z' :e R, z' <= z.
admit.
Qed.

Theorem ordinal_SNo_ : forall alpha, ordinal alpha -> SNo_ alpha alpha.
admit.
Qed.

Theorem ordinal_SNo : forall alpha, ordinal alpha -> SNo alpha.
admit.
Qed.

Theorem ordinal_SNoLev : forall alpha, ordinal alpha -> SNoLev alpha = alpha.
admit.
Qed.

Theorem ordinal_SNoLev_max : forall alpha, ordinal alpha -> forall z, SNo z -> SNoLev z :e alpha -> z < alpha.
admit.
Qed.

Theorem ordinal_SNoL : forall alpha, ordinal alpha -> SNoL alpha = SNoS_ alpha.
admit.
Qed.

Theorem ordinal_SNoR : forall alpha, ordinal alpha -> SNoR alpha = Empty.
admit.
Qed.

Theorem nat_p_SNo: forall n, nat_p n -> SNo n.
admit.
Qed.

Theorem omega_SNo: forall n :e omega, SNo n.
admit.
Qed.

Theorem omega_SNoS_omega : omega c= SNoS_ omega.
admit.
Qed.

Theorem ordinal_In_SNoLt : forall alpha, ordinal alpha -> forall beta :e alpha, beta < alpha.
admit.
Qed.

Theorem ordinal_SNoLev_max_2 : forall alpha, ordinal alpha -> forall z, SNo z -> SNoLev z :e ordsucc alpha -> z <= alpha.
admit.
Qed.

Theorem ordinal_Subq_SNoLe : forall alpha beta, ordinal alpha -> ordinal beta -> alpha c= beta -> alpha <= beta.
admit.
Qed.

Theorem ordinal_SNoLt_In : forall alpha beta, ordinal alpha -> ordinal beta -> alpha < beta -> alpha :e beta.
admit.
Qed.

Theorem omega_nonneg : forall m :e omega, 0 <= m.
admit.
Qed.

Theorem SNo_0 : SNo 0.
admit.
Qed.

Theorem SNo_1 : SNo 1.
admit.
Qed.

Theorem SNo_2 : SNo 2.
admit.
Qed.

Theorem SNoLev_0 : SNoLev 0 = 0.
admit.
Qed.

Theorem SNoCut_0_0: SNoCut 0 0 = 0.
admit.
Qed.

Theorem SNoL_0 : SNoL 0 = 0.
admit.
Qed.

Theorem SNoR_0 : SNoR 0 = 0.
admit.
Qed.

Theorem SNoL_1 : SNoL 1 = 1.
admit.
Qed.

Theorem SNoR_1 : SNoR 1 = 0.
admit.
Qed.

Theorem SNo_max_SNoLev : forall x, SNo x -> (forall y :e SNoS_ (SNoLev x), y < x) -> SNoLev x = x.
admit.
Qed.

Theorem SNo_max_ordinal : forall x, SNo x -> (forall y :e SNoS_ (SNoLev x), y < x) -> ordinal x.
admit.
Qed.

Theorem pos_low_eq_one : forall x, SNo x -> 0 < x -> SNoLev x c= 1 -> x = 1.
admit.
Qed.

Definition SNo_extend0 : set -> set := fun x => PSNo (ordsucc (SNoLev x)) (fun delta => delta :e x /\ delta <> SNoLev x).
Definition SNo_extend1 : set -> set := fun x => PSNo (ordsucc (SNoLev x)) (fun delta => delta :e x \/ delta = SNoLev x).

Theorem SNo_extend0_SNo_ : forall x, SNo x -> SNo_ (ordsucc (SNoLev x)) (SNo_extend0 x).
admit.
Qed.

Theorem SNo_extend1_SNo_ : forall x, SNo x -> SNo_ (ordsucc (SNoLev x)) (SNo_extend1 x).
admit.
Qed.

Theorem SNo_extend0_SNo : forall x, SNo x -> SNo (SNo_extend0 x).
admit.
Qed.

Theorem SNo_extend1_SNo : forall x, SNo x -> SNo (SNo_extend1 x).
admit.
Qed.

Theorem SNo_extend0_SNoLev : forall x, SNo x -> SNoLev (SNo_extend0 x) = ordsucc (SNoLev x).
admit.
Qed.

Theorem SNo_extend1_SNoLev : forall x, SNo x -> SNoLev (SNo_extend1 x) = ordsucc (SNoLev x).
admit.
Qed.

Theorem SNo_extend0_nIn : forall x, SNo x -> SNoLev x /:e SNo_extend0 x.
admit.
Qed.

Theorem SNo_extend1_In : forall x, SNo x -> SNoLev x :e SNo_extend1 x.
admit.
Qed.

Theorem SNo_extend0_SNoEq : forall x, SNo x -> SNoEq_ (SNoLev x) (SNo_extend0 x) x.
admit.
Qed.

Theorem SNo_extend1_SNoEq : forall x, SNo x -> SNoEq_ (SNoLev x) (SNo_extend1 x) x.
admit.
Qed.

Theorem SNoLev_0_eq_0 : forall x, SNo x -> SNoLev x = 0 -> x = 0.
admit.
Qed.

(** eps_ n is the Surreal Number 1/2^n, without needing to define division or exponents first **)
Definition eps_ : set -> set := fun n => {0} :\/: {(ordsucc m) ' | m :e n}.

Theorem eps_ordinal_In_eq_0 : forall n alpha, ordinal alpha -> alpha :e eps_ n -> alpha = 0.
admit.
Qed.

Theorem eps_0_1 : eps_ 0 = 1.
admit.
Qed.

Theorem SNo__eps_ : forall n :e omega, SNo_ (ordsucc n) (eps_ n).
admit.
Qed.

Theorem SNo_eps_ : forall n :e omega, SNo (eps_ n).
admit.
Qed.

Theorem SNo_eps_1 : SNo (eps_ 1).
admit.
Qed.

Theorem SNoLev_eps_ : forall n :e omega, SNoLev (eps_ n) = ordsucc n.
admit.
Qed.

Theorem SNo_eps_SNoS_omega : forall n :e omega, eps_ n :e SNoS_ omega.
admit.
Qed.

Theorem SNo_eps_decr : forall n :e omega, forall m :e n, eps_ n < eps_ m.
admit.
Qed.

Theorem SNo_eps_pos : forall n :e omega, 0 < eps_ n.
admit.
Qed.

Theorem SNo_pos_eps_Lt : forall n, nat_p n -> forall x :e SNoS_ (ordsucc n), 0 < x -> eps_ n < x.
admit.
Qed.

Theorem SNo_pos_eps_Le : forall n, nat_p n -> forall x :e SNoS_ (ordsucc (ordsucc n)), 0 < x -> eps_ n <= x.
admit.
Qed.

Theorem eps_SNo_eq : forall n, nat_p n -> forall x :e SNoS_ (ordsucc n), 0 < x -> SNoEq_ (SNoLev x) (eps_ n) x -> exists m :e n, x = eps_ m.
admit.
Qed.

Theorem eps_SNoCutP : forall n :e omega, SNoCutP {0} {eps_ m|m :e n}.
admit.
Qed.

Theorem eps_SNoCut : forall n :e omega, eps_ n = SNoCut {0} {eps_ m|m :e n}.
admit.
Qed.

End TaggedSets2.

Theorem SNo_etaE : forall z, SNo z ->
  forall p:prop,
     (forall L R, SNoCutP L R
       -> (forall x :e L, SNoLev x :e SNoLev z)
       -> (forall y :e R, SNoLev y :e SNoLev z)
       -> z = SNoCut L R
       -> p)
   -> p.
admit.
Qed.

(*** surreal induction ***)
Theorem SNo_ind : forall P:set -> prop,
  (forall L R, SNoCutP L R
   -> (forall x :e L, P x)
   -> (forall y :e R, P y)
   -> P (SNoCut L R))
 -> forall z, SNo z -> P z.
admit.
Qed.

(*** surreal recursion ***)
Section SurrealRecI.
Variable F:set -> (set -> set) -> set.
Let default : set := Eps_i (fun _ => True).
Let G : set -> (set -> set -> set) -> set -> set
  := fun alpha g =>
       If_ii
          (ordinal alpha)
          (fun z:set => if z :e SNoS_ (ordsucc alpha) then
                           F z (fun w => g (SNoLev w) w)
                        else
                           default)
          (fun z:set => default).
(* Parameter SNo_rec_i "352082c509ab97c1757375f37a2ac62ed806c7b39944c98161720a584364bfaf" "be45dfaed6c479503a967f3834400c4fd18a8a567c8887787251ed89579f7be3" *)
Definition SNo_rec_i : set -> set
 := fun z => In_rec_ii G (SNoLev z) z.
Hypothesis Fr: forall z, SNo z ->
   forall g h:set -> set, (forall w :e SNoS_ (SNoLev z), g w = h w)
     -> F z g = F z h.

Theorem SNo_rec_i_eq : forall z, SNo z -> SNo_rec_i z = F z SNo_rec_i.
admit.
Qed.

End SurrealRecI.
Section SurrealRecII.
Variable F:set -> (set -> (set -> set)) -> (set -> set).
Let default : (set -> set) := Descr_ii (fun _ => True).
Let G : set -> (set -> set -> (set -> set)) -> set -> (set -> set)
  := fun alpha g =>
       If_iii
          (ordinal alpha)
          (fun z:set => If_ii (z :e SNoS_ (ordsucc alpha))
                              (F z (fun w => g (SNoLev w) w))
                              default)
          (fun z:set => default).
(* Parameter SNo_rec_ii "030b1b3db48f720b8db18b1192717cad8f204fff5fff81201b9a2414f5036417" "e148e62186e718374accb69cda703e3440725cca8832aed55c0b32731f7401ab" *)
Definition SNo_rec_ii : set -> (set -> set)
 := fun z => In_rec_iii G (SNoLev z) z.
Hypothesis Fr: forall z, SNo z ->
   forall g h:set -> (set -> set), (forall w :e SNoS_ (SNoLev z), g w = h w)
     -> F z g = F z h.

Theorem SNo_rec_ii_eq : forall z, SNo z -> SNo_rec_ii z = F z SNo_rec_ii.
admit.
Qed.

End SurrealRecII.
Section SurrealRec2.
Variable F:set -> set -> (set -> set -> set) -> set.
Let G:set -> (set -> set -> set) -> set -> (set -> set) -> set
  := fun w f z g => F w z (fun x y => if x = w then g y else f x y).
Let H:set -> (set -> set -> set) -> set -> set
  := fun w f z => if SNo z then SNo_rec_i (G w f) z else Empty.
(* Parameter SNo_rec2 "9c6267051fa817eed39b404ea37e7913b3571fe071763da2ebc1baa56b4b77f5" "7d10ab58310ebefb7f8bf63883310aa10fc2535f53bb48db513a868bc02ec028" *)
Definition SNo_rec2 : set -> set -> set
  := SNo_rec_ii H.
Hypothesis Fr: forall w, SNo w -> forall z, SNo z ->
   forall g h:set -> set -> set,
        (forall x :e SNoS_ (SNoLev w), forall y, SNo y -> g x y = h x y)
     -> (forall y :e SNoS_ (SNoLev z), g w y = h w y)
     -> F w z g = F w z h.

Theorem SNo_rec2_G_prop : forall w, SNo w -> forall f k:set -> set -> set,
    (forall x :e SNoS_ (SNoLev w), f x = k x)
 -> forall z, SNo z ->
    forall g h:set -> set, (forall u :e SNoS_ (SNoLev z), g u = h u)
 -> G w f z g = G w k z h.
admit.
Qed.

Theorem SNo_rec2_eq_1 : forall w, SNo w -> forall f:set -> set -> set,
  forall z, SNo z ->
   SNo_rec_i (G w f) z = G w f z (SNo_rec_i (G w f)).
admit.
Qed.

Theorem SNo_rec2_eq : forall w, SNo w -> forall z, SNo z ->
   SNo_rec2 w z = F w z SNo_rec2.
admit.
Qed.

End SurrealRec2.

Theorem SNo_ordinal_ind : forall P:set -> prop,
  (forall alpha, ordinal alpha -> forall x :e SNoS_ alpha, P x)
  ->
  (forall x, SNo x -> P x).
admit.
Qed.

Theorem SNo_ordinal_ind2 : forall P:set -> set -> prop,
  (forall alpha, ordinal alpha ->
   forall beta, ordinal beta ->
   forall x :e SNoS_ alpha, forall y :e SNoS_ beta, P x y)
  ->
  (forall x y, SNo x -> SNo y -> P x y).
admit.
Qed.

Theorem SNo_ordinal_ind3 : forall P:set -> set -> set -> prop,
  (forall alpha, ordinal alpha ->
   forall beta, ordinal beta ->
   forall gamma, ordinal gamma ->
   forall x :e SNoS_ alpha, forall y :e SNoS_ beta, forall z :e SNoS_ gamma, P x y z)
  ->
  (forall x y z, SNo x -> SNo y -> SNo z -> P x y z).
admit.
Qed.

Theorem SNoLev_ind : forall P:set -> prop,
  (forall x, SNo x -> (forall w :e SNoS_ (SNoLev x), P w) -> P x)
  ->
  (forall x, SNo x -> P x).
admit.
Qed.

Theorem SNoLev_ind2 : forall P:set -> set -> prop,
  (forall x y, SNo x -> SNo y
    -> (forall w :e SNoS_ (SNoLev x), P w y)
    -> (forall z :e SNoS_ (SNoLev y), P x z)
    -> (forall w :e SNoS_ (SNoLev x), forall z :e SNoS_ (SNoLev y), P w z)
    -> P x y)
-> forall x y, SNo x -> SNo y -> P x y.
admit.
Qed.

Theorem SNoLev_ind3 : forall P:set -> set -> set -> prop,
  (forall x y z, SNo x -> SNo y -> SNo z
    -> (forall u :e SNoS_ (SNoLev x), P u y z)
    -> (forall v :e SNoS_ (SNoLev y), P x v z)
    -> (forall w :e SNoS_ (SNoLev z), P x y w)
    -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), P u v z)
    -> (forall u :e SNoS_ (SNoLev x), forall w :e SNoS_ (SNoLev z), P u y w)
    -> (forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), P x v w)
    -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), P u v w)
    -> P x y z)
 -> forall x y z, SNo x -> SNo y -> SNo z -> P x y z.
admit.
Qed.

Theorem SNo_omega : SNo omega.
admit.
Qed.

Theorem SNoLt_0_1 : 0 < 1.
admit.
Qed.

Theorem SNoLt_0_2 : 0 < 2.
admit.
Qed.

Theorem SNoLt_1_2 : 1 < 2.
admit.
Qed.

Theorem restr_SNo_ : forall x, SNo x -> forall alpha :e SNoLev x, SNo_ alpha (x :/\: SNoElts_ alpha).
admit.
Qed.

Theorem restr_SNo : forall x, SNo x -> forall alpha :e SNoLev x, SNo (x :/\: SNoElts_ alpha).
admit.
Qed.

Theorem restr_SNoLev : forall x, SNo x -> forall alpha :e SNoLev x, SNoLev (x :/\: SNoElts_ alpha) = alpha.
admit.
Qed.

Theorem restr_SNoEq : forall x, SNo x -> forall alpha :e SNoLev x, SNoEq_ alpha (x :/\: SNoElts_ alpha) x.
admit.
Qed.

Theorem SNo_extend0_restr_eq : forall x, SNo x -> x = SNo_extend0 x :/\: SNoElts_ (SNoLev x).
admit.
Qed.

Theorem SNo_extend1_restr_eq : forall x, SNo x -> x = SNo_extend1 x :/\: SNoElts_ (SNoLev x).
admit.
Qed.

Opaque eps_ SNo_rec2 SNo_rec_ii SNo_rec_i SNoLev SNo.

Section SurrealMinus.
(* Parameter minus_SNo "6d39c64862ac40c95c6f5e4ed5f02bb019279bfb0cda8c9bbe0e1b813b1e876c" "268a6c1da15b8fe97d37be85147bc7767b27098cdae193faac127195e8824808" *)
Definition minus_SNo : set -> set
  := SNo_rec_i (fun x m => SNoCut {m z|z :e SNoR x} {m w|w :e SNoL x}).
Prefix - 358 := minus_SNo.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.

Theorem minus_SNo_eq : forall x, SNo x -> - x = SNoCut {- z|z :e SNoR x} {- w|w :e SNoL x}.
admit.
Qed.

Theorem minus_SNo_prop1 : forall x, SNo x -> SNo (- x) /\ (forall u :e SNoL x, - x < - u) /\ (forall u :e SNoR x, - u < - x) /\ SNoCutP {- z|z :e SNoR x} {- w|w :e SNoL x}.
admit.
Qed.

Theorem SNo_minus_SNo : forall x, SNo x -> SNo (- x).
admit.
Qed.

Theorem minus_SNo_Lt_contra : forall x y, SNo x -> SNo y -> x < y -> - y < - x.
admit.
Qed.

Theorem minus_SNo_Le_contra : forall x y, SNo x -> SNo y -> x <= y -> - y <= - x.
admit.
Qed.

Theorem minus_SNo_SNoCutP : forall x, SNo x -> SNoCutP {- z|z :e SNoR x} {- w|w :e SNoL x}.
admit.
Qed.

Theorem minus_SNo_SNoCutP_gen : forall L R, SNoCutP L R -> SNoCutP {- z|z :e R} {- w|w :e L}.
admit.
Qed.

Theorem minus_SNo_Lev_lem1 : forall alpha, ordinal alpha -> forall x :e SNoS_ alpha, SNoLev (- x) c= SNoLev x.
admit.
Qed.

Theorem minus_SNo_Lev_lem2 : forall x, SNo x -> SNoLev (- x) c= SNoLev x.
admit.
Qed.

Theorem minus_SNo_invol : forall x, SNo x -> - - x = x.
admit.
Qed.

Theorem minus_SNo_Lev : forall x, SNo x -> SNoLev (- x) = SNoLev x.
admit.
Qed.

Theorem minus_SNo_SNo_ : forall alpha, ordinal alpha -> forall x, SNo_ alpha x -> SNo_ alpha (- x).
admit.
Qed.

Theorem minus_SNo_SNoS_ : forall alpha, ordinal alpha -> forall x, x :e SNoS_ alpha -> - x :e SNoS_ alpha.
admit.
Qed.

Theorem minus_SNoCut_eq_lem : forall v, SNo v -> forall L R, SNoCutP L R -> v = SNoCut L R -> - v = SNoCut {- z|z :e R} {- w|w :e L}.
admit.
Qed.

Theorem minus_SNoCut_eq : forall L R, SNoCutP L R -> - SNoCut L R = SNoCut {- z|z :e R} {- w|w :e L}.
admit.
Qed.

Theorem minus_SNo_Lt_contra1 : forall x y, SNo x -> SNo y -> -x < y -> - y < x.
admit.
Qed.

Theorem minus_SNo_Lt_contra2 : forall x y, SNo x -> SNo y -> x < -y -> y < - x.
admit.
Qed.

Theorem mordinal_SNoLev_min_2 : forall alpha, ordinal alpha -> forall z, SNo z -> SNoLev z :e ordsucc alpha -> - alpha <= z.
admit.
Qed.

Theorem minus_SNo_SNoS_omega : forall x :e SNoS_ omega, - x :e SNoS_ omega.
admit.
Qed.

Theorem SNoL_minus_SNoR: forall x, SNo x -> SNoL (- x) = {- w|w :e SNoR x}.
admit.
Qed.

End SurrealMinus.
Opaque minus_SNo.
Section SurrealAdd.
Prefix - 358 := minus_SNo.
(* Parameter add_SNo "29b9b279a7a5b776b777d842e678a4acaf3b85b17a0223605e4cc68025e9b2a7" "127d043261bd13d57aaeb99e7d2c02cae2bd0698c0d689b03e69f1ac89b3c2c6" *)
Definition add_SNo : set -> set -> set
  := SNo_rec2 (fun x y a => SNoCut ({a w y|w :e SNoL x} :\/: {a x w|w :e SNoL y}) ({a z y|z :e SNoR x} :\/: {a x z|z :e SNoR y})).
Infix + 360 right := add_SNo.

Theorem add_SNo_eq : forall x, SNo x -> forall y, SNo y ->
    x + y = SNoCut ({w + y|w :e SNoL x} :\/: {x + w|w :e SNoL y}) ({z + y|z :e SNoR x} :\/: {x + z|z :e SNoR y}).
admit.
Qed.

Theorem add_SNo_prop1 : forall x y, SNo x -> SNo y ->
    SNo (x + y)
 /\ (forall u :e SNoL x, u + y < x + y)
 /\ (forall u :e SNoR x, x + y < u + y)
 /\ (forall u :e SNoL y, x + u < x + y)
 /\ (forall u :e SNoR y, x + y < x + u)
 /\ SNoCutP ({w + y|w :e SNoL x} :\/: {x + w|w :e SNoL y}) ({z + y|z :e SNoR x} :\/: {x + z|z :e SNoR y}).
admit.
Qed.

Theorem SNo_add_SNo : forall x y, SNo x -> SNo y -> SNo (x + y).
admit.
Qed.

Theorem SNo_add_SNo_3 : forall x y z, SNo x -> SNo y -> SNo z -> SNo (x + y + z).
admit.
Qed.

Theorem SNo_add_SNo_3c : forall x y z, SNo x -> SNo y -> SNo z -> SNo (x + y + - z).
admit.
Qed.

Theorem SNo_add_SNo_4 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> SNo (x + y + z + w).
admit.
Qed.

Theorem add_SNo_Lt1 : forall x y z, SNo x -> SNo y -> SNo z -> x < z -> x + y < z + y.
admit.
Qed.

Theorem add_SNo_Le1 : forall x y z, SNo x -> SNo y -> SNo z -> x <= z -> x + y <= z + y.
admit.
Qed.

Theorem add_SNo_Lt2 : forall x y z, SNo x -> SNo y -> SNo z -> y < z -> x + y < x + z.
admit.
Qed.

Theorem add_SNo_Le2 : forall x y z, SNo x -> SNo y -> SNo z -> y <= z -> x + y <= x + z.
admit.
Qed.

Theorem add_SNo_Lt3a : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x < z -> y <= w -> x + y < z + w.
admit.
Qed.

Theorem add_SNo_Lt3b : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x <= z -> y < w -> x + y < z + w.
admit.
Qed.

Theorem add_SNo_Lt3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x < z -> y < w -> x + y < z + w.
admit.
Qed.

Theorem add_SNo_Le3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x <= z -> y <= w -> x + y <= z + w.
admit.
Qed.

Theorem add_SNo_SNoCutP : forall x y, SNo x -> SNo y -> SNoCutP ({w + y|w :e SNoL x} :\/: {x + w|w :e SNoL y}) ({z + y|z :e SNoR x} :\/: {x + z|z :e SNoR y}).
admit.
Qed.

Theorem add_SNo_com : forall x y, SNo x -> SNo y -> x + y = y + x.
admit.
Qed.

Theorem add_SNo_0L : forall x, SNo x -> 0 + x = x.
admit.
Qed.

Theorem add_SNo_0R : forall x, SNo x -> x + 0 = x.
admit.
Qed.

Theorem add_SNo_minus_SNo_linv : forall x, SNo x -> -x+x = 0.
admit.
Qed.

Theorem add_SNo_minus_SNo_rinv : forall x, SNo x -> x + -x = 0.
admit.
Qed.

Theorem add_SNo_ordinal_SNoCutP : forall alpha, ordinal alpha -> forall beta, ordinal beta -> SNoCutP ({x + beta | x :e SNoS_ alpha} :\/: {alpha + x | x :e SNoS_ beta}) Empty.
admit.
Qed.

Theorem add_SNo_ordinal_eq : forall alpha, ordinal alpha -> forall beta, ordinal beta -> alpha + beta = SNoCut ({x + beta | x :e SNoS_ alpha} :\/: {alpha + x | x :e SNoS_ beta}) Empty.
admit.
Qed.

Theorem add_SNo_ordinal_ordinal : forall alpha, ordinal alpha -> forall beta, ordinal beta -> ordinal (alpha + beta).
admit.
Qed.

Theorem add_SNo_ordinal_SL : forall alpha, ordinal alpha -> forall beta, ordinal beta -> ordsucc alpha + beta = ordsucc (alpha + beta).
admit.
Qed.

Theorem add_SNo_ordinal_SR : forall alpha, ordinal alpha -> forall beta, ordinal beta -> alpha + ordsucc beta = ordsucc (alpha + beta).
admit.
Qed.

Theorem add_SNo_ordinal_InL : forall alpha, ordinal alpha -> forall beta, ordinal beta -> forall gamma :e alpha, gamma + beta :e alpha + beta.
admit.
Qed.

Theorem add_SNo_ordinal_InR : forall alpha, ordinal alpha -> forall beta, ordinal beta -> forall gamma :e beta, alpha + gamma :e alpha + beta.
admit.
Qed.

Theorem add_nat_add_SNo : forall n m :e omega, add_nat n m = n + m.
admit.
Qed.

Theorem add_SNo_In_omega : forall n m :e omega, n + m :e omega.
admit.
Qed.

Theorem add_SNo_1_1_2 : 1 + 1 = 2.
admit.
Qed.

Theorem add_SNo_SNoL_interpolate : forall x y, SNo x -> SNo y -> forall u :e SNoL (x + y), (exists v :e SNoL x, u <= v + y) \/ (exists v :e SNoL y, u <= x + v).
admit.
Qed.

Theorem add_SNo_SNoR_interpolate : forall x y, SNo x -> SNo y -> forall u :e SNoR (x + y), (exists v :e SNoR x, v + y <= u) \/ (exists v :e SNoR y, x + v <= u).
admit.
Qed.

Theorem add_SNo_assoc : forall x y z, SNo x -> SNo y -> SNo z -> x + (y + z) = (x + y) + z.
admit.
Qed.

Theorem add_SNo_minus_R2 : forall x y, SNo x -> SNo y -> (x + y) + - y = x.
admit.
Qed.

Theorem add_SNo_minus_R2' : forall x y, SNo x -> SNo y -> (x + - y) + y = x.
admit.
Qed.

Theorem add_SNo_minus_L2 : forall x y, SNo x -> SNo y -> - x + (x + y) = y.
admit.
Qed.

Theorem add_SNo_minus_L2' : forall x y, SNo x -> SNo y -> x + (- x + y) = y.
admit.
Qed.

Theorem add_SNo_cancel_L : forall x y z, SNo x -> SNo y -> SNo z -> x + y = x + z -> y = z.
admit.
Qed.

Theorem add_SNo_cancel_R : forall x y z, SNo x -> SNo y -> SNo z -> x + y = z + y -> x = z.
admit.
Qed.

Theorem minus_SNo_0 : - 0 = 0.
admit.
Qed.

Theorem minus_add_SNo_distr : forall x y, SNo x -> SNo y -> -(x+y) = (-x) + (-y).
admit.
Qed.

Theorem minus_add_SNo_distr_3 : forall x y z, SNo x -> SNo y -> SNo z -> -(x + y + z) = -x + - y + -z.
admit.
Qed.

Theorem add_SNo_Lev_bd : forall x y, SNo x -> SNo y -> SNoLev (x + y) c= SNoLev x + SNoLev y.
admit.
Qed.

Theorem add_SNo_SNoS_omega : forall x y :e SNoS_ omega, x + y :e SNoS_ omega.
admit.
Qed.

Theorem add_SNo_Lt1_cancel : forall x y z, SNo x -> SNo y -> SNo z -> x + y < z + y -> x < z.
admit.
Qed.

Theorem add_SNo_Lt2_cancel : forall x y z, SNo x -> SNo y -> SNo z -> x + y < x + z -> y < z.
admit.
Qed.

Theorem add_SNo_Le1_cancel : forall x y z, SNo x -> SNo y -> SNo z -> x + y <= z + y -> x <= z.
admit.
Qed.

Theorem add_SNo_assoc_4 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w
  -> x + y + z + w = (x + y + z) + w.
admit.
Qed.

Theorem add_SNo_com_3_0_1 : forall x y z, SNo x -> SNo y -> SNo z
  -> x + y + z = y + x + z.
admit.
Qed.

Theorem add_SNo_com_3b_1_2 : forall x y z, SNo x -> SNo y -> SNo z
  -> (x + y) + z = (x + z) + y.
admit.
Qed.

Theorem add_SNo_com_4_inner_mid : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w
  -> (x + y) + (z + w) = (x + z) + (y + w).
admit.
Qed.

Theorem add_SNo_rotate_3_1 : forall x y z, SNo x -> SNo y -> SNo z ->
  x + y + z = z + x + y.
admit.
Qed.

Theorem add_SNo_rotate_4_1 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w ->
  x + y + z + w = w + x + y + z.
admit.
Qed.

Theorem add_SNo_rotate_5_1 : forall x y z w v, SNo x -> SNo y -> SNo z -> SNo w -> SNo v ->
  x + y + z + w + v = v + x + y + z + w.
admit.
Qed.

Theorem add_SNo_rotate_5_2 : forall x y z w v, SNo x -> SNo y -> SNo z -> SNo w -> SNo v ->
  x + y + z + w + v = w + v + x + y + z.
admit.
Qed.

Theorem add_SNo_minus_SNo_prop2 : forall x y, SNo x -> SNo y -> x + - x + y = y.
admit.
Qed.

Theorem add_SNo_minus_SNo_prop3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> (x + y + z) + (- z + w) = x + y + w.
admit.
Qed.

Theorem add_SNo_minus_SNo_prop5 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> (x + y + - z) + (z + w) = x + y + w.
admit.
Qed.

Theorem add_SNo_minus_Lt1 : forall x y z, SNo x -> SNo y -> SNo z -> x + - y < z -> x < z + y.
admit.
Qed.

Theorem add_SNo_minus_Lt2 : forall x y z, SNo x -> SNo y -> SNo z -> z < x + - y -> z + y < x.
admit.
Qed.

Theorem add_SNo_minus_Lt1b : forall x y z, SNo x -> SNo y -> SNo z -> x < z + y -> x + - y < z.
admit.
Qed.

Theorem add_SNo_minus_Lt2b : forall x y z, SNo x -> SNo y -> SNo z -> z + y < x -> z < x + - y.
admit.
Qed.

Theorem add_SNo_minus_Lt1b3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x + y < w + z -> x + y + - z < w.
admit.
Qed.

Theorem add_SNo_minus_Lt2b3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> w + z < x + y -> w < x + y + - z.
admit.
Qed.

Theorem add_SNo_minus_Lt_lem : forall x y z u v w, SNo x -> SNo y -> SNo z -> SNo u -> SNo v -> SNo w ->
  x + y + w < u + v + z ->
  x + y + - z < u + v + - w.
admit.
Qed.

Theorem add_SNo_minus_Le2 : forall x y z, SNo x -> SNo y -> SNo z -> z <= x + - y -> z + y <= x.
admit.
Qed.

Theorem add_SNo_minus_Le2b : forall x y z, SNo x -> SNo y -> SNo z -> z + y <= x -> z <= x + - y.
admit.
Qed.

Theorem add_SNo_Lt_subprop2 : forall x y z w u v, SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo v
  -> x + u < z + v
  -> y + v < w + u
  -> x + y < z + w.
admit.
Qed.

Theorem add_SNo_Lt_subprop3a : forall x y z w u a, SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo a
  -> x + z < w + a
  -> y + a < u
  -> x + y + z < w + u.
admit.
Qed.

Theorem add_SNo_Lt_subprop3b : forall x y w u v a, SNo x -> SNo y -> SNo w -> SNo u -> SNo v -> SNo a
  -> x + a < w + v
  -> y < a + u
  -> x + y < w + u + v.
admit.
Qed.

Theorem add_SNo_Lt_subprop3c : forall x y z w u a b c, SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo a -> SNo b -> SNo c
 -> x + a < b + c
 -> y + c < u
 -> b + z < w + a
 -> x + y + z < w + u.
admit.
Qed.

Theorem add_SNo_Lt_subprop3d : forall x y w u v a b c, SNo x -> SNo y -> SNo w -> SNo u -> SNo v -> SNo a -> SNo b -> SNo c
 -> x + a < b + v
 -> y < c + u
 -> b + c < w + a
 -> x + y < w + u + v.
admit.
Qed.

Theorem ordinal_ordsucc_SNo_eq : forall alpha, ordinal alpha -> ordsucc alpha = 1 + alpha.
admit.
Qed.

Theorem add_SNo_3a_2b: forall x y z w u, SNo x -> SNo y -> SNo z -> SNo w -> SNo u
 -> (x + y + z) + (w + u) = (u + y + z) + (w + x).
admit.
Qed.

Theorem add_SNo_1_ordsucc : forall n :e omega, n + 1 = ordsucc n.
admit.
Qed.

Theorem add_SNo_eps_Lt : forall x, SNo x -> forall n :e omega, x < x + eps_ n.
admit.
Qed.

Theorem add_SNo_eps_Lt' : forall x y, SNo x -> SNo y -> forall n :e omega, x < y -> x < y + eps_ n.
admit.
Qed.

Theorem SNoLt_minus_pos : forall x y, SNo x -> SNo y -> x < y -> 0 < y + - x.
admit.
Qed.

Theorem add_SNo_omega_In_cases: forall m, forall n :e omega, forall k, nat_p k -> m :e n + k -> m :e n \/ m + - n :e k.
admit.
Qed.

Theorem add_SNo_Lt4 : forall x y z w u v, SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo v -> x < w -> y < u -> z < v -> x + y + z < w + u + v.
admit.
Qed.

Theorem add_SNo_3_3_3_Lt1 : forall x y z w u, SNo x -> SNo y -> SNo z -> SNo w -> SNo u ->
  x + y < z + w -> x + y + u < z + w + u.
admit.
Qed.

Theorem add_SNo_3_2_3_Lt1 : forall x y z w u, SNo x -> SNo y -> SNo z -> SNo w -> SNo u ->
  y + x < z + w -> x + u + y < z + w + u.
admit.
Qed.

Theorem add_SNo_minus_Lt12b3: forall x y z w u v,
    SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo v
 -> x + y + v < w + u + z
 -> x + y + - z < w + u + - v.
admit.
Qed.

Theorem add_SNo_minus_Le1b : forall x y z, SNo x -> SNo y -> SNo z -> x <= z + y -> x + - y <= z.
admit.
Qed.

Theorem add_SNo_minus_Le1b3 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> x + y <= w + z -> x + y + - z <= w.
admit.
Qed.

Theorem add_SNo_minus_Le12b3: forall x y z w u v,
    SNo x -> SNo y -> SNo z -> SNo w -> SNo u -> SNo v
 -> x + y + v <= w + u + z
 -> x + y + - z <= w + u + - v.
admit.
Qed.

End SurrealAdd.

Opaque add_SNo.

Section SurrealAbs.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
(* Parameter abs_SNo "9f9389c36823b2e0124a7fe367eb786d080772b5171a5d059b10c47361cef0ef" "34f6dccfd6f62ca020248cdfbd473fcb15d8d9c5c55d1ec7c5ab6284006ff40f" *)
Definition abs_SNo : set -> set := fun x => if 0 <= x then x else - x.

Theorem nonneg_abs_SNo : forall x, 0 <= x -> abs_SNo x = x.
admit.
Qed.

Theorem not_nonneg_abs_SNo : forall x, ~(0 <= x) -> abs_SNo x = - x.
admit.
Qed.

Theorem pos_abs_SNo : forall x, 0 < x -> abs_SNo x = x.
admit.
Qed.

Theorem neg_abs_SNo : forall x, SNo x -> x < 0 -> abs_SNo x = - x.
admit.
Qed.

Theorem SNo_abs_SNo : forall x, SNo x -> SNo (abs_SNo x).
admit.
Qed.

Theorem abs_SNo_minus: forall x, SNo x -> abs_SNo (- x) = abs_SNo x.
admit.
Qed.

Theorem abs_SNo_dist_swap: forall x y, SNo x -> SNo y -> abs_SNo (x + - y) = abs_SNo (y + - x).
admit.
Qed.

End SurrealAbs.

Opaque abs_SNo.

Section SurrealMul.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
(* Parameter mul_SNo "f56bf39b8eea93d7f63da529dedb477ae1ab1255c645c47d8915623f364f2d6b" "48d05483e628cb37379dd5d279684d471d85c642fe63533c3ad520b84b18df9d" *)
Definition mul_SNo : set -> set -> set
  := SNo_rec2
      (fun x y m =>
        SNoCut ({m (w 0) y + m x (w 1) + - m (w 0) (w 1)|w :e SNoL x :*: SNoL y}
                  :\/:
                {m (z 0) y + m x (z 1) + - m (z 0) (z 1)|z :e SNoR x :*: SNoR y})
               ({m (w 0) y + m x (w 1) + - m (w 0) (w 1)|w :e SNoL x :*: SNoR y}
                  :\/:
                {m (z 0) y + m x (z 1) + - m (z 0) (z 1)|z :e SNoR x :*: SNoL y})).

Infix * 355 right := mul_SNo.

Theorem mul_SNo_eq : forall x, SNo x -> forall y, SNo y ->
   x * y
      = SNoCut ({(w 0) * y + x * (w 1) + - (w 0) * (w 1)|w :e SNoL x :*: SNoL y}
                  :\/:
                {(z 0) * y + x * (z 1) + - (z 0) * (z 1)|z :e SNoR x :*: SNoR y})
               ({(w 0) * y + x * (w 1) + - (w 0) * (w 1)|w :e SNoL x :*: SNoR y}
                  :\/:
                {(z 0) * y + x * (z 1) + - (z 0) * (z 1)|z :e SNoR x :*: SNoL y}).
admit.
Qed.

Theorem mul_SNo_eq_2 : forall x y, SNo x -> SNo y ->
  forall p:prop,
    (forall L R,
         (forall u, u :e L ->
           (forall q:prop,
                (forall w0 :e SNoL x, forall w1 :e SNoL y, u = w0 * y + x * w1 + - w0 * w1 -> q)
             -> (forall z0 :e SNoR x, forall z1 :e SNoR y, u = z0 * y + x * z1 + - z0 * z1 -> q)
             -> q))
      -> (forall w0 :e SNoL x, forall w1 :e SNoL y, w0 * y + x * w1 + - w0 * w1 :e L)
      -> (forall z0 :e SNoR x, forall z1 :e SNoR y, z0 * y + x * z1 + - z0 * z1 :e L)
      -> (forall u, u :e R ->
           (forall q:prop,
                (forall w0 :e SNoL x, forall z1 :e SNoR y, u = w0 * y + x * z1 + - w0 * z1 -> q)
             -> (forall z0 :e SNoR x, forall w1 :e SNoL y, u = z0 * y + x * w1 + - z0 * w1 -> q)
             -> q))
      -> (forall w0 :e SNoL x, forall z1 :e SNoR y, w0 * y + x * z1 + - w0 * z1 :e R)
      -> (forall z0 :e SNoR x, forall w1 :e SNoL y, z0 * y + x * w1 + - z0 * w1 :e R)
      -> x * y = SNoCut L R
      -> p)
   -> p.
admit.
Qed.

Theorem mul_SNo_prop_1 : forall x, SNo x -> forall y, SNo y ->
 forall p:prop,
    (SNo (x * y)
  -> (forall u :e SNoL x, forall v :e SNoL y, u * y + x * v < x * y + u * v)
  -> (forall u :e SNoR x, forall v :e SNoR y, u * y + x * v < x * y + u * v)
  -> (forall u :e SNoL x, forall v :e SNoR y, x * y + u * v < u * y + x * v)
  -> (forall u :e SNoR x, forall v :e SNoL y, x * y + u * v < u * y + x * v)
  -> p)
 -> p.
admit.
Qed.

Theorem SNo_mul_SNo : forall x y, SNo x -> SNo y -> SNo (x * y).
admit.
Qed.

Theorem SNo_mul_SNo_lem : forall x y u v, SNo x -> SNo y -> SNo u -> SNo v -> SNo (u * y + x * v + - (u * v)).
admit.
Qed.

Theorem SNo_mul_SNo_3 : forall x y z, SNo x -> SNo y -> SNo z -> SNo (x * y * z).
admit.
Qed.

Theorem mul_SNo_eq_3 : forall x y, SNo x -> SNo y ->
  forall p:prop,
    (forall L R, SNoCutP L R
       -> (forall u, u :e L ->
           (forall q:prop,
                (forall w0 :e SNoL x, forall w1 :e SNoL y, u = w0 * y + x * w1 + - w0 * w1 -> q)
             -> (forall z0 :e SNoR x, forall z1 :e SNoR y, u = z0 * y + x * z1 + - z0 * z1 -> q)
             -> q))
      -> (forall w0 :e SNoL x, forall w1 :e SNoL y, w0 * y + x * w1 + - w0 * w1 :e L)
      -> (forall z0 :e SNoR x, forall z1 :e SNoR y, z0 * y + x * z1 + - z0 * z1 :e L)
      -> (forall u, u :e R ->
           (forall q:prop,
                (forall w0 :e SNoL x, forall z1 :e SNoR y, u = w0 * y + x * z1 + - w0 * z1 -> q)
             -> (forall z0 :e SNoR x, forall w1 :e SNoL y, u = z0 * y + x * w1 + - z0 * w1 -> q)
             -> q))
      -> (forall w0 :e SNoL x, forall z1 :e SNoR y, w0 * y + x * z1 + - w0 * z1 :e R)
      -> (forall z0 :e SNoR x, forall w1 :e SNoL y, z0 * y + x * w1 + - z0 * w1 :e R)
      -> x * y = SNoCut L R
      -> p)
   -> p.
admit.
Qed.

Theorem mul_SNo_Lt : forall x y u v, SNo x -> SNo y -> SNo u -> SNo v
 -> u < x -> v < y -> u * y + x * v < x * y + u * v.
admit.
Qed.

Theorem mul_SNo_Le : forall x y u v, SNo x -> SNo y -> SNo u -> SNo v
 -> u <= x -> v <= y -> u * y + x * v <= x * y + u * v.
admit.
Qed.

Theorem mul_SNo_SNoL_interpolate : forall x y, SNo x -> SNo y -> forall u :e SNoL (x * y),
 (exists v :e SNoL x, exists w :e SNoL y, u + v * w <= v * y + x * w)
 \/
 (exists v :e SNoR x, exists w :e SNoR y, u + v * w <= v * y + x * w).
admit.
Qed.

Theorem mul_SNo_SNoL_interpolate_impred : forall x y, SNo x -> SNo y -> forall u :e SNoL (x * y),
 forall p:prop,
      (forall v :e SNoL x, forall w :e SNoL y, u + v * w <= v * y + x * w -> p)
   -> (forall v :e SNoR x, forall w :e SNoR y, u + v * w <= v * y + x * w -> p)
   -> p.
admit.
Qed.  

Theorem mul_SNo_SNoR_interpolate : forall x y, SNo x -> SNo y -> forall u :e SNoR (x * y),
 (exists v :e SNoL x, exists w :e SNoR y, v * y + x * w <= u + v * w)
 \/
 (exists v :e SNoR x, exists w :e SNoL y, v * y + x * w <= u + v * w).
admit.
Qed.

Theorem mul_SNo_SNoR_interpolate_impred : forall x y, SNo x -> SNo y -> forall u :e SNoR (x * y),
 forall p:prop,
     (forall v :e SNoL x, forall w :e SNoR y, v * y + x * w <= u + v * w -> p)
  -> (forall v :e SNoR x, forall w :e SNoL y, v * y + x * w <= u + v * w -> p)
  -> p.
admit.
Qed.

(** This could be useful for proving L c= L', L = L', R c= R' or R = R'
    when corresponding conditions hold. **)
Theorem mul_SNo_Subq_lem : forall x y X Y Z W,
  forall U U',
      (forall u, u :e U ->
         (forall q:prop,
                (forall w0 :e X, forall w1 :e Y, u = w0 * y + x * w1 + - w0 * w1 -> q)
             -> (forall z0 :e Z, forall z1 :e W, u = z0 * y + x * z1 + - z0 * z1 -> q)
             -> q))
   -> (forall w0 :e X, forall w1 :e Y, w0 * y + x * w1 + - w0 * w1 :e U')
   -> (forall w0 :e Z, forall w1 :e W, w0 * y + x * w1 + - w0 * w1 :e U')
   -> U c= U'.
admit.
Qed.

(** Part of Conway Chapter 2 Theorem 7 **)
Theorem mul_SNo_zeroR : forall x, SNo x -> x * 0 = 0.
admit.
Qed.

Theorem mul_SNo_oneR : forall x, SNo x -> x * 1 = x.
admit.
Qed.

Theorem mul_SNo_com : forall x y, SNo x -> SNo y -> x * y = y * x.
admit.
Qed.

Theorem mul_SNo_minus_distrL : forall x y, SNo x -> SNo y -> (- x) * y = - x * y.
admit.
Qed.

Theorem mul_SNo_minus_distrR: forall x y, SNo x -> SNo y -> x * (- y) = - (x * y).
admit.
Qed.

Theorem mul_SNo_distrR : forall x y z, SNo x -> SNo y -> SNo z
  -> (x + y) * z = x * z + y * z.
admit.
Qed.

Theorem mul_SNo_distrL : forall x y z, SNo x -> SNo y -> SNo z
  -> x * (y + z) = x * y + x * z.
admit.
Qed.

Section mul_SNo_assoc_lems.
Variable M:set -> set -> set.
Infix * 355 right := M.
Hypothesis SNo_M : forall x y, SNo x -> SNo y -> SNo (x * y).
Hypothesis DL: forall x y z, SNo x -> SNo y -> SNo z -> x * (y + z) = x * y + x * z.
Hypothesis DR: forall x y z, SNo x -> SNo y -> SNo z -> (x + y) * z = x * z + y * z.
Hypothesis IL: forall x y, SNo x -> SNo y -> forall u :e SNoL (x * y),
 forall p:prop,
      (forall v :e SNoL x, forall w :e SNoL y, u + v * w <= v * y + x * w -> p)
   -> (forall v :e SNoR x, forall w :e SNoR y, u + v * w <= v * y + x * w -> p)
   -> p.
Hypothesis IR: forall x y, SNo x -> SNo y -> forall u :e SNoR (x * y),
 forall p:prop,
     (forall v :e SNoL x, forall w :e SNoR y, v * y + x * w <= u + v * w -> p)
  -> (forall v :e SNoR x, forall w :e SNoL y, v * y + x * w <= u + v * w -> p)
  -> p.
Hypothesis M_Lt: forall x y u v, SNo x -> SNo y -> SNo u -> SNo v
 -> u < x -> v < y -> u * y + x * v < x * y + u * v.
Hypothesis M_Le: forall x y u v, SNo x -> SNo y -> SNo u -> SNo v
 -> u <= x -> v <= y -> u * y + x * v <= x * y + u * v.

Theorem mul_SNo_assoc_lem1 : forall x y z, SNo x -> SNo y -> SNo z
 -> (forall u :e SNoS_ (SNoLev x), u * (y * z) = (u * y) * z)
 -> (forall v :e SNoS_ (SNoLev y), x * (v * z) = (x * v) * z)
 -> (forall w :e SNoS_ (SNoLev z), x * (y * w) = (x * y) * w)
 -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), u * (v * z) = (u * v) * z)
 -> (forall u :e SNoS_ (SNoLev x), forall w :e SNoS_ (SNoLev z), u * (y * w) = (u * y) * w)
 -> (forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), x * (v * w) = (x * v) * w)
 -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), u * (v * w) = (u * v) * w)
 -> forall L,
    (forall u :e L,
     forall q:prop,
         (forall v :e SNoL x, forall w :e SNoL (y * z), u = v * (y * z) + x * w + - v * w -> q)
      -> (forall v :e SNoR x, forall w :e SNoR (y * z), u = v * (y * z) + x * w + - v * w -> q)
      -> q)
 -> forall u :e L, u < (x * y) * z.
admit.
Qed.

Theorem mul_SNo_assoc_lem2 : forall x y z, SNo x -> SNo y -> SNo z
 -> (forall u :e SNoS_ (SNoLev x), u * (y * z) = (u * y) * z)
 -> (forall v :e SNoS_ (SNoLev y), x * (v * z) = (x * v) * z)
 -> (forall w :e SNoS_ (SNoLev z), x * (y * w) = (x * y) * w)
 -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), u * (v * z) = (u * v) * z)
 -> (forall u :e SNoS_ (SNoLev x), forall w :e SNoS_ (SNoLev z), u * (y * w) = (u * y) * w)
 -> (forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), x * (v * w) = (x * v) * w)
 -> (forall u :e SNoS_ (SNoLev x), forall v :e SNoS_ (SNoLev y), forall w :e SNoS_ (SNoLev z), u * (v * w) = (u * v) * w)
 -> forall R,
    (forall u :e R,
     forall q:prop,
         (forall v :e SNoL x, forall w :e SNoR (y * z), u = v * (y * z) + x * w + - v * w -> q)
      -> (forall v :e SNoR x, forall w :e SNoL (y * z), u = v * (y * z) + x * w + - v * w -> q)
      -> q)
 -> forall u :e R, (x * y) * z < u.
admit.
Qed.

End mul_SNo_assoc_lems.

Theorem mul_SNo_assoc : forall x y z, SNo x -> SNo y -> SNo z
  -> x * (y * z) = (x * y) * z.
admit.
Qed.

Theorem mul_nat_mul_SNo : forall n m :e omega, mul_nat n m = n * m.
admit.
Qed.

Theorem mul_SNo_In_omega : forall n m :e omega, n * m :e omega.
admit.
Qed.

Theorem mul_SNo_zeroL : forall x, SNo x -> 0 * x = 0.
admit.
Qed.

Theorem mul_SNo_oneL : forall x, SNo x -> 1 * x = x.
admit.
Qed.

Theorem mul_SNo_rotate_3_1 : forall x y z, SNo x -> SNo y -> SNo z ->
  x * y * z = z * x * y.
admit.
Qed.

Theorem pos_mul_SNo_Lt : forall x y z, SNo x -> 0 < x -> SNo y -> SNo z -> y < z -> x * y < x * z.
admit.
Qed.

Theorem nonneg_mul_SNo_Le : forall x y z, SNo x -> 0 <= x -> SNo y -> SNo z -> y <= z -> x * y <= x * z.
admit.
Qed.

Theorem neg_mul_SNo_Lt : forall x y z, SNo x -> x < 0 -> SNo y -> SNo z -> z < y -> x * y < x * z.
admit.
Qed.

Theorem pos_mul_SNo_Lt' : forall x y z, SNo x -> SNo y -> SNo z -> 0 < z -> x < y -> x * z < y * z.
admit.
Qed.

Theorem mul_SNo_Lt1_pos_Lt : forall x y, SNo x -> SNo y -> x < 1 -> 0 < y -> x * y < y.
admit.
Qed.

Theorem nonneg_mul_SNo_Le' : forall x y z, SNo x -> SNo y -> SNo z -> 0 <= z -> x <= y -> x * z <= y * z.
admit.
Qed.

Theorem mul_SNo_Le1_nonneg_Le : forall x y, SNo x -> SNo y -> x <= 1 -> 0 <= y -> x * y <= y.
admit.
Qed.

Theorem pos_mul_SNo_Lt2 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> 0 < x -> 0 < y -> x < z -> y < w -> x * y < z * w.
admit.
Qed.

Theorem nonneg_mul_SNo_Le2 : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> 0 <= x -> 0 <= y -> x <= z -> y <= w -> x * y <= z * w.
admit.
Qed.

Theorem mul_SNo_pos_pos: forall x y, SNo x -> SNo y -> 0 < x -> 0 < y -> 0 < x * y.
admit.
Qed.

Theorem mul_SNo_pos_neg: forall x y, SNo x -> SNo y -> 0 < x -> y < 0 -> x * y < 0.
admit.
Qed.

Theorem mul_SNo_neg_pos: forall x y, SNo x -> SNo y -> x < 0 -> 0 < y -> x * y < 0.
admit.
Qed.

Theorem mul_SNo_neg_neg: forall x y, SNo x -> SNo y -> x < 0 -> y < 0 -> 0 < x * y.
admit.
Qed.

Theorem mul_SNo_nonneg_nonneg: forall x y, SNo x -> SNo y -> 0 <= x -> 0 <= y -> 0 <= x * y.
admit.
Qed.

Theorem mul_SNo_nonpos_pos: forall x y, SNo x -> SNo y -> x <= 0 -> 0 < y -> x * y <= 0.
admit.
Qed.

Theorem mul_SNo_nonpos_neg: forall x y, SNo x -> SNo y -> x <= 0 -> y < 0 -> 0 <= x * y.
admit.
Qed.

Theorem nonpos_mul_SNo_Le : forall x y z, SNo x -> x <= 0 -> SNo y -> SNo z -> z <= y -> x * y <= x * z.
admit.
Qed.

Theorem SNo_zero_or_sqr_pos : forall x, SNo x -> x = 0 \/ 0 < x * x.
admit.
Qed.

Theorem SNo_pos_sqr_uniq: forall x y, SNo x -> SNo y -> 0 < x -> 0 < y -> x * x = y * y -> x = y.
admit.
Qed.

Theorem SNo_nonneg_sqr_uniq: forall x y, SNo x -> SNo y -> 0 <= x -> 0 <= y -> x * x = y * y -> x = y.
admit.
Qed.

Theorem SNo_foil: forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> (x + y) * (z + w) = x * z + x * w + y * z + y * w.
admit.
Qed.

Theorem mul_SNo_minus_minus: forall x y, SNo x -> SNo y -> (- x) * (- y) = x * y.
admit.
Qed.

Theorem mul_SNo_com_3_0_1 : forall x y z, SNo x -> SNo y -> SNo z
  -> x * y * z = y * x * z.
admit.
Qed.

Theorem mul_SNo_com_3b_1_2 : forall x y z, SNo x -> SNo y -> SNo z
  -> (x * y) * z = (x * z) * y.
admit.
Qed.

Theorem mul_SNo_com_4_inner_mid : forall x y z w, SNo x -> SNo y -> SNo z -> SNo w
  -> (x * y) * (z * w) = (x * z) * (y * w).
admit.
Qed.

Theorem SNo_foil_mm: forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> (x + - y) * (z + - w) = x * z + - x * w + - y * z + y * w.
admit.
Qed.

Theorem mul_SNo_nonzero_cancel: forall x y z, SNo x -> x <> 0 -> SNo y -> SNo z -> x * y = x * z -> y = z.
admit.
Qed.

Theorem mul_SNoCutP_lem : forall Lx Rx Ly Ry x y,
    SNoCutP Lx Rx
 -> SNoCutP Ly Ry
 -> x = SNoCut Lx Rx
 -> y = SNoCut Ly Ry
 -> SNoCutP ({w 0 * y + x * w 1 + - w 0 * w 1|w :e Lx :*: Ly}
              :\/:
             {z 0 * y + x * z 1 + - z 0 * z 1|z :e Rx :*: Ry})
            ({w 0 * y + x * w 1 + - w 0 * w 1|w :e Lx :*: Ry}
              :\/:
             {z 0 * y + x * z 1 + - z 0 * z 1|z :e Rx :*: Ly})
 /\ x * y
  = SNoCut ({w 0 * y + x * w 1 + - w 0 * w 1|w :e Lx :*: Ly}
             :\/:
            {z 0 * y + x * z 1 + - z 0 * z 1|z :e Rx :*: Ry})
           ({w 0 * y + x * w 1 + - w 0 * w 1|w :e Lx :*: Ry}
             :\/:
            {z 0 * y + x * z 1 + - z 0 * z 1|z :e Rx :*: Ly})
 /\ forall q:prop,
     (forall LxLy' RxRy' LxRy' RxLy',
         (forall u :e LxLy', forall p:prop, (forall w :e Lx, forall w' :e Ly, SNo w -> SNo w' -> w < x -> w' < y -> u = w * y + x * w' + - w * w' -> p) -> p)
      -> (forall w :e Lx, forall w' :e Ly, w * y + x * w' + - w * w' :e LxLy')
      -> (forall u :e RxRy', forall p:prop, (forall z :e Rx, forall z' :e Ry, SNo z -> SNo z' -> x < z -> y < z' -> u = z * y + x * z' + - z * z' -> p) -> p)
      -> (forall z :e Rx, forall z' :e Ry, z * y + x * z' + - z * z' :e RxRy')
      -> (forall u :e LxRy', forall p:prop, (forall w :e Lx, forall z :e Ry, SNo w -> SNo z -> w < x -> y < z -> u = w * y + x * z + - w * z -> p) -> p)
      -> (forall w :e Lx, forall z :e Ry, w * y + x * z + - w * z :e LxRy')
      -> (forall u :e RxLy', forall p:prop, (forall z :e Rx, forall w :e Ly, SNo z -> SNo w -> x < z -> w < y -> u = z * y + x * w + - z * w -> p) -> p)
      -> (forall z :e Rx, forall w :e Ly, z * y + x * w + - z * w :e RxLy')
      -> SNoCutP (LxLy' :\/: RxRy') (LxRy' :\/: RxLy')
      -> x * y = SNoCut (LxLy' :\/: RxRy') (LxRy' :\/: RxLy')
      -> q)
    -> q.
admit.
Qed.

Theorem mul_SNoCut_abs : forall Lx Rx Ly Ry x y,
    SNoCutP Lx Rx
 -> SNoCutP Ly Ry
 -> x = SNoCut Lx Rx
 -> y = SNoCut Ly Ry
 -> forall q:prop,
     (forall LxLy' RxRy' LxRy' RxLy',
         (forall u :e LxLy', forall p:prop, (forall w :e Lx, forall w' :e Ly, SNo w -> SNo w' -> w < x -> w' < y -> u = w * y + x * w' + - w * w' -> p) -> p)
      -> (forall w :e Lx, forall w' :e Ly, w * y + x * w' + - w * w' :e LxLy')
      -> (forall u :e RxRy', forall p:prop, (forall z :e Rx, forall z' :e Ry, SNo z -> SNo z' -> x < z -> y < z' -> u = z * y + x * z' + - z * z' -> p) -> p)
      -> (forall z :e Rx, forall z' :e Ry, z * y + x * z' + - z * z' :e RxRy')
      -> (forall u :e LxRy', forall p:prop, (forall w :e Lx, forall z :e Ry, SNo w -> SNo z -> w < x -> y < z -> u = w * y + x * z + - w * z -> p) -> p)
      -> (forall w :e Lx, forall z :e Ry, w * y + x * z + - w * z :e LxRy')
      -> (forall u :e RxLy', forall p:prop, (forall z :e Rx, forall w :e Ly, SNo z -> SNo w -> x < z -> w < y -> u = z * y + x * w + - z * w -> p) -> p)
      -> (forall z :e Rx, forall w :e Ly, z * y + x * w + - z * w :e RxLy')
      -> SNoCutP (LxLy' :\/: RxRy') (LxRy' :\/: RxLy')
      -> x * y = SNoCut (LxLy' :\/: RxRy') (LxRy' :\/: RxLy')
      -> q)
    -> q.
admit.
Qed.

Theorem mul_SNo_SNoCut_SNoL_interpolate : forall Lx Rx Ly Ry,
    SNoCutP Lx Rx -> SNoCutP Ly Ry
 -> forall x y, x = SNoCut Lx Rx -> y = SNoCut Ly Ry
 -> forall u :e SNoL (x * y),
 (exists v :e Lx, exists w :e Ly, u + v * w <= v * y + x * w)
 \/
 (exists v :e Rx, exists w :e Ry, u + v * w <= v * y + x * w).
admit.
Qed.

Theorem mul_SNo_SNoCut_SNoL_interpolate_impred : forall Lx Rx Ly Ry,
    SNoCutP Lx Rx -> SNoCutP Ly Ry
 -> forall x y, x = SNoCut Lx Rx -> y = SNoCut Ly Ry
 -> forall u :e SNoL (x * y),
    forall p:prop,
        (forall v :e Lx, forall w :e Ly, u + v * w <= v * y + x * w -> p)
     -> (forall v :e Rx, forall w :e Ry, u + v * w <= v * y + x * w -> p)
     -> p.
admit.
Qed.

Theorem mul_SNo_SNoCut_SNoR_interpolate : forall Lx Rx Ly Ry,
    SNoCutP Lx Rx -> SNoCutP Ly Ry
 -> forall x y, x = SNoCut Lx Rx -> y = SNoCut Ly Ry
 -> forall u :e SNoR (x * y),
 (exists v :e Lx, exists w :e Ry, v * y + x * w <= u + v * w)
 \/
 (exists v :e Rx, exists w :e Ly, v * y + x * w <= u + v * w).
admit.
Qed.

Theorem mul_SNo_SNoCut_SNoR_interpolate_impred : forall Lx Rx Ly Ry,
    SNoCutP Lx Rx -> SNoCutP Ly Ry
 -> forall x y, x = SNoCut Lx Rx -> y = SNoCut Ly Ry
 -> forall u :e SNoR (x * y),
    forall p:prop,
        (forall v :e Lx, forall w :e Ry, v * y + x * w <= u + v * w -> p)
     -> (forall v :e Rx, forall w :e Ly, v * y + x * w <= u + v * w -> p)
     -> p.
admit.
Qed.

Theorem nonpos_nonneg_0 : forall m n :e omega, m = - n -> m = 0 /\ n = 0.
admit.
Qed.

Theorem mul_minus_SNo_distrR: forall x y, SNo x -> SNo y -> x * (- y) = - (x * y).
admit.
Qed.

End SurrealMul.

Opaque mul_SNo.

Section Int.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.

Definition int : set := omega :\/: {- n|n :e omega}.

Theorem int_SNo_cases : forall p:set -> prop,
    (forall n :e omega, p n)
 -> (forall n :e omega, p (- n))
 -> forall x :e int, p x.
admit.
Qed.

Theorem int_3_cases: forall n :e int, forall p:prop,
    (forall m :e omega, n = - ordsucc m -> p)
 -> (n = 0 -> p)
 -> (forall m :e omega, n = ordsucc m -> p)
 -> p.
admit.
Qed.

Theorem int_SNo : forall x :e int, SNo x.
admit.
Qed.

Theorem Subq_omega_int : omega c= int.
admit.
Qed.

Theorem int_minus_SNo_omega : forall n :e omega, - n :e int.
admit.
Qed.

Theorem int_add_SNo_lem: forall n :e omega, forall m, nat_p m -> - n + m :e int.
admit.
Qed.

Theorem int_add_SNo: forall x y :e int, x + y :e int.
admit.
Qed.

Theorem int_minus_SNo: forall x :e int, - x :e int.
admit.
Qed.

Theorem int_mul_SNo: forall x y :e int, x * y :e int.
admit.
Qed.

Theorem nonneg_int_nat_p: forall n :e int, 0 <= n -> nat_p n.
admit.
Qed.

End Int.

Section BezoutAndGCD.

Infix + 360 right := add_nat.
Infix * 355 right := mul_nat.

Theorem quotient_remainder_nat: forall n :e omega :\: {0}, forall m, nat_p m -> exists q :e omega, exists r :e n, m = q * n + r.
admit.
Qed.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix ^ 342 right := exp_SNo_nat.
Infix < 490 := SNoLt.
Infix <= 490 := SNoLe.

Theorem mul_SNo_nonpos_nonneg: forall x y, SNo x -> SNo y -> x <= 0 -> 0 <= y -> x * y <= 0.
admit.
Qed.

Theorem ordinal_0_In_ordsucc: forall alpha, ordinal alpha -> 0 :e ordsucc alpha.
admit.
Qed.

Theorem ordinal_ordsucc_pos: forall alpha, ordinal alpha -> 0 < ordsucc alpha.
admit.
Qed.

Theorem quotient_remainder_int: forall n :e omega :\: {0}, forall m :e int, exists q :e int, exists r :e n, m = q * n + r.
admit.
Qed.

Definition divides_int : set -> set -> prop := fun m n => m :e int /\ n :e int /\ exists k :e int, m * k = n.

Theorem divides_int_ref: forall n :e int, divides_int n n.
admit.
Qed.

Theorem divides_int_0: forall n :e int, divides_int n 0.
admit.
Qed.

Theorem divides_int_add_SNo: forall m n k, divides_int m n -> divides_int m k -> divides_int m (n + k).
admit.
Qed.

Theorem divides_int_mul_SNo: forall m n m' n', divides_int m m' -> divides_int n n' -> divides_int (m * n) (m' * n').
admit.
Qed.

Theorem divides_nat_divides_int: forall m n, divides_nat m n -> divides_int m n.
admit.
Qed.

Theorem divides_int_divides_nat: forall m n :e omega, divides_int m n -> divides_nat m n.
admit.
Qed.

Theorem divides_int_minus_SNo: forall m n, divides_int m n -> divides_int m (- n).
admit.
Qed.

Theorem divides_int_mul_SNo_L: forall m n, forall k :e int, divides_int m n -> divides_int m (n * k).
admit.
Qed.

Theorem divides_int_mul_SNo_R: forall m n, forall k :e int, divides_int m n -> divides_int m (k * n).
admit.
Qed.

Theorem divides_int_1: forall n :e int, divides_int 1 n.
admit.
Qed.

Theorem divides_int_pos_Le: forall m n, divides_int m n -> 0 < n -> m <= n.
admit.
Qed.

Definition gcd_reln : set -> set -> set -> prop := fun m n d => divides_int d m /\ divides_int d n /\ forall d', divides_int d' m -> divides_int d' n -> d' <= d.

Theorem gcd_reln_uniq: forall a b c d, gcd_reln a b c -> gcd_reln a b d -> c = d.
admit.
Qed.

Definition int_lin_comb : set -> set -> set -> prop := fun a b c => a :e int /\ b :e int /\ c :e int /\ exists m n :e int, m * a + n * b = c.

Theorem int_lin_comb_I: forall a b c :e int, (exists m n :e int, m * a + n * b = c) -> int_lin_comb a b c.
admit.
Qed.

Theorem int_lin_comb_E: forall a b c, int_lin_comb a b c ->
  forall p:prop,
       (a :e int -> b :e int -> c :e int -> forall m n :e int, m * a + n * b = c -> p)
    -> p.
admit.
Qed.

Theorem int_lin_comb_E1: forall a b c, int_lin_comb a b c -> a :e int.
admit.
Qed.

Theorem int_lin_comb_E2: forall a b c, int_lin_comb a b c -> b :e int.
admit.
Qed.

Theorem int_lin_comb_E3: forall a b c, int_lin_comb a b c -> c :e int.
admit.
Qed.

Theorem int_lin_comb_E4: forall a b c, int_lin_comb a b c ->
  forall p:prop,
       (forall m n :e int, m * a + n * b = c -> p)
    -> p.
admit.
Qed.

Theorem least_pos_int_lin_comb_ex: forall a b :e int, ~(a = 0 /\ b = 0) -> exists c, int_lin_comb a b c /\ 0 < c /\ forall c', int_lin_comb a b c' -> 0 < c' -> c <= c'.
admit.
Qed.

Theorem int_lin_comb_sym: forall a b d,
     int_lin_comb a b d
  -> int_lin_comb b a d.
admit.
Qed.
  
Theorem least_pos_int_lin_comb_divides_int: forall a b d,
     int_lin_comb a b d
  -> 0 < d
  -> (forall c, int_lin_comb a b c -> 0 < c -> d <= c)
  -> divides_int d a.
admit.
Qed.

Theorem least_pos_int_lin_comb_gcd: forall a b d,
     int_lin_comb a b d
  -> 0 < d
  -> (forall c, int_lin_comb a b c -> 0 < c -> d <= c)
  -> gcd_reln a b d.
admit.
Qed.

Theorem BezoutThm: forall a b :e int, ~(a = 0 /\ b = 0) ->
  forall d, gcd_reln a b d <-> int_lin_comb a b d /\ 0 < d /\ forall d', int_lin_comb a b d' -> 0 < d' -> d <= d'.
admit.
Qed.

Theorem gcd_id: forall m :e omega :\: {0}, gcd_reln m m m.
admit.
Qed.

Theorem gcd_0: forall m :e omega :\: {0}, gcd_reln 0 m m.
admit.
Qed.

Theorem gcd_sym: forall m n d, gcd_reln m n d -> gcd_reln n m d.
admit.
Qed.

Theorem gcd_minus: forall m n d, gcd_reln m n d -> gcd_reln m (- n) d.
admit.
Qed.

Theorem euclidean_algorithm_prop_1: forall m n d, n :e int -> gcd_reln m (n + - m) d -> gcd_reln m n d.
admit.
Qed.

Theorem euclidean_algorithm:
     (forall m :e omega :\: {0}, gcd_reln m m m)
  /\ (forall m :e omega :\: {0}, gcd_reln 0 m m)
  /\ (forall m :e omega :\: {0}, gcd_reln m 0 m)
  /\ (forall m n :e omega, m < n
          -> forall d, gcd_reln m (n + - m) d
                    -> gcd_reln m n d)
  /\ (forall m n :e omega, n < m
          -> forall d, gcd_reln n m d
                    -> gcd_reln m n d)
  /\ (forall m :e omega, forall n :e int, n < 0
          -> forall d, gcd_reln m (- n) d
                    -> gcd_reln m n d)
  /\ (forall m n :e int, m < 0
          -> forall d, gcd_reln (- m) n d
                    -> gcd_reln m n d).
admit.
Qed.

Theorem Euclid_lemma: forall p, prime_nat p -> forall a b :e int, divides_int p (a * b) -> divides_int p a \/ divides_int p b.
admit.
Qed.

End BezoutAndGCD.

Section PrimeFactorization.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix ^ 342 right := exp_SNo_nat.
Infix < 490 := SNoLt.
Infix <= 490 := SNoLe.

Theorem prime_not_divides_int_1: forall p, prime_nat p -> ~divides_int p 1.
admit.
Qed.

Definition Pi_SNo : (set -> set) -> set -> set := fun f n =>
  nat_primrec 1 (fun i r => r * f i) n.

Theorem Pi_SNo_0: forall f:set -> set, Pi_SNo f 0 = 1.
admit.
Qed.

Theorem Pi_SNo_S: forall f:set -> set, forall n, nat_p n -> Pi_SNo f (ordsucc n) = Pi_SNo f n * f n.
admit.
Qed.

Theorem Pi_SNo_In_omega: forall f:set -> set,
 forall n, nat_p n ->
     (forall i :e n, f i :e omega)
  -> Pi_SNo f n :e omega.
admit.
Qed.

Theorem Pi_SNo_In_int: forall f:set -> set,
 forall n, nat_p n ->
     (forall i :e n, f i :e int)
  -> Pi_SNo f n :e int.
admit.
Qed.

Theorem divides_int_prime_nat_eq: forall p q, prime_nat p -> prime_nat q -> divides_int p q -> p = q.
admit.
Qed.

Theorem Euclid_lemma_Pi_SNo: forall f:set->set,
  forall p, prime_nat p ->
  forall n, nat_p n ->
      (forall i :e n, f i :e int)
   -> divides_int p (Pi_SNo f n)
   -> exists i :e n, divides_int p (f i).
admit.
Qed.

Theorem divides_nat_mul_SNo_R: forall m n :e omega, divides_nat m (m * n).
admit.
Qed.

Theorem divides_nat_mul_SNo_L: forall m n :e omega, divides_nat n (m * n).
admit.
Qed.

Theorem Pi_SNo_divides: forall f:set->set,
  forall n, nat_p n ->
      (forall i :e n, f i :e omega)
   -> (forall i :e n, divides_nat (f i) (Pi_SNo f n)).
admit.
Qed.

Definition nonincrfinseq : (set -> prop) -> set -> (set -> set) -> prop := fun A n f => forall i :e n, A (f i) /\ forall j :e i, f i <= f j.

Theorem Pi_SNo_eq: forall f g:set->set,
  forall m, nat_p m
   -> (forall i :e m, f i = g i)
   -> Pi_SNo f m = Pi_SNo g m.
admit.
Qed.

Theorem prime_factorization_ex_uniq: forall n, nat_p n -> 0 :e n ->
  exists k :e omega, exists f:set -> set, nonincrfinseq prime_nat k f /\ Pi_SNo f k = n
    /\ forall k' :e omega, forall f':set -> set, nonincrfinseq prime_nat k' f' -> Pi_SNo f' k' = n
         -> k' = k /\ forall i :e k, f' i = f i.
admit.
Qed.

End PrimeFactorization.

Section SurrealExp.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Definition exp_SNo_nat : set->set->set := fun n m:set => nat_primrec 1 (fun _ r => n * r) m.
Infix ^ 342 right := exp_SNo_nat.

Theorem exp_SNo_nat_0 : forall x, SNo x -> x ^ 0 = 1.
admit.
Qed.

Theorem exp_SNo_nat_S : forall x, SNo x -> forall n, nat_p n -> x ^ (ordsucc n) = x * x ^ n.
admit.
Qed.

Theorem exp_SNo_nat_1: forall x, SNo x -> x ^ 1 = x.
admit.
Qed.

Theorem SNo_exp_SNo_nat : forall x, SNo x -> forall n, nat_p n -> SNo (x ^ n).
admit.
Qed.

Theorem nat_exp_SNo_nat : forall x, nat_p x -> forall n, nat_p n -> nat_p (x ^ n).
admit.
Qed.

Theorem eps_ordsucc_half_add : forall n, nat_p n -> eps_ (ordsucc n) + eps_ (ordsucc n) = eps_ n.
admit.
Qed.

Theorem eps_1_half_eq1 : eps_ 1 + eps_ 1 = 1.
admit.
Qed.

Theorem eps_1_half_eq2 : 2 * eps_ 1 = 1.
admit.
Qed.

Theorem double_eps_1 : forall x y z, SNo x -> SNo y -> SNo z -> x + x = y + z -> x = eps_ 1 * (y + z).
admit.
Qed.

Theorem exp_SNo_1_bd: forall x, SNo x -> 1 <= x -> forall n, nat_p n -> 1 <= x ^ n.
admit.
Qed.

Theorem exp_SNo_2_bd: forall n, nat_p n -> n < 2 ^ n.
admit.
Qed.

Theorem mul_SNo_eps_power_2: forall n, nat_p n -> eps_ n * 2 ^ n = 1.
admit.
Qed.

Theorem eps_bd_1 : forall n :e omega, eps_ n <= 1.
admit.
Qed.

Theorem mul_SNo_eps_power_2': forall n, nat_p n -> 2 ^ n * eps_ n = 1.
admit.
Qed.

Theorem exp_SNo_nat_mul_add : forall x, SNo x -> forall m, nat_p m -> forall n, nat_p n -> x ^ m * x ^ n = x ^ (m + n).
admit.
Qed.

Theorem exp_SNo_nat_mul_add' : forall x, SNo x -> forall m n :e omega, x ^ m * x ^ n = x ^ (m + n).
admit.
Qed.

Theorem exp_SNo_nat_pos : forall x, SNo x -> 0 < x -> forall n, nat_p n -> 0 < x ^ n.
admit.
Qed.

Theorem mul_SNo_eps_eps_add_SNo: forall m n :e omega, eps_ m * eps_ n = eps_ (m + n).
admit.
Qed.

Theorem SNoS_omega_Lev_equip : forall n, nat_p n -> equip {x :e SNoS_ omega|SNoLev x = n} (2 ^ n).
admit.
Qed.

Theorem SNoS_finite : forall n :e omega, finite (SNoS_ n).
admit.
Qed.

Theorem SNoS_omega_SNoL_finite : forall x :e SNoS_ omega, finite (SNoL x).
admit.
Qed.

Theorem SNoS_omega_SNoR_finite : forall x :e SNoS_ omega, finite (SNoR x).
admit.
Qed.

End SurrealExp.

Opaque exp_SNo_nat.

Section SNoMaxMin.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix ^ 342 right := exp_SNo_nat.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.
Definition SNo_max_of : set -> set -> prop := fun X x => x :e X /\ SNo x /\ forall y :e X, SNo y -> y <= x.
Definition SNo_min_of : set -> set -> prop := fun X x => x :e X /\ SNo x /\ forall y :e X, SNo y -> x <= y.

Theorem minus_SNo_max_min : forall X y, (forall x :e X, SNo x) -> SNo_max_of X y -> SNo_min_of {- x|x :e X} (- y).
admit.
Qed.

Theorem minus_SNo_max_min' : forall X y, (forall x :e X, SNo x) -> SNo_max_of {- x|x :e X} y -> SNo_min_of X (- y).
admit.
Qed.

Theorem minus_SNo_min_max : forall X y, (forall x :e X, SNo x) -> SNo_min_of X y -> SNo_max_of {- x|x :e X} (- y).
admit.
Qed.

Theorem double_SNo_max_1 : forall x y, SNo x -> SNo_max_of (SNoL x) y -> forall z, SNo z -> x < z -> y + z < x + x -> exists w :e SNoR z, y + w = x + x.
admit.
Qed.

Theorem double_SNo_min_1 : forall x y, SNo x -> SNo_min_of (SNoR x) y -> forall z, SNo z -> z < x -> x + x < y + z -> exists w :e SNoL z, y + w = x + x.
admit.
Qed.

Theorem finite_max_exists : forall X, (forall x :e X, SNo x) -> finite X -> X <> 0 -> exists x, SNo_max_of X x.
admit.
Qed.

Theorem finite_min_exists : forall X, (forall x :e X, SNo x) -> finite X -> X <> 0 -> exists x, SNo_min_of X x.
admit.
Qed.

Theorem SNoS_omega_SNoL_max_exists : forall x :e SNoS_ omega, SNoL x = 0 \/ exists y, SNo_max_of (SNoL x) y.
admit.
Qed.

Theorem SNoS_omega_SNoR_min_exists : forall x :e SNoS_ omega, SNoR x = 0 \/ exists y, SNo_min_of (SNoR x) y.
admit.
Qed.

End SNoMaxMin.

Section DiadicRationals.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.
Infix ^ 342 right := exp_SNo_nat.

Theorem nonneg_diadic_rational_p_SNoS_omega: forall k :e omega, forall n, nat_p n -> eps_ k * n :e SNoS_ omega.
admit.
Qed.

Definition diadic_rational_p : set -> prop := fun x => exists k :e omega, exists m :e int, x = eps_ k * m.

Theorem diadic_rational_p_SNoS_omega: forall x, diadic_rational_p x -> x :e SNoS_ omega.
admit.
Qed.

Theorem int_diadic_rational_p : forall m :e int, diadic_rational_p m.
admit.
Qed.

Theorem omega_diadic_rational_p : forall m :e omega, diadic_rational_p m.
admit.
Qed.

Theorem eps_diadic_rational_p : forall k :e omega, diadic_rational_p (eps_ k).
admit.
Qed.

Theorem minus_SNo_diadic_rational_p : forall x, diadic_rational_p x -> diadic_rational_p (- x).
admit.
Qed.

Theorem mul_SNo_diadic_rational_p : forall x y, diadic_rational_p x -> diadic_rational_p y -> diadic_rational_p (x * y).
admit.
Qed.

Theorem add_SNo_diadic_rational_p : forall x y, diadic_rational_p x -> diadic_rational_p y -> diadic_rational_p (x + y).
admit.
Qed.

Theorem SNoS_omega_diadic_rational_p_lem: forall n, nat_p n -> forall x, SNo x -> SNoLev x = n -> diadic_rational_p x.
admit.
Qed.

Theorem SNoS_omega_diadic_rational_p: forall x :e SNoS_ omega, diadic_rational_p x.
admit.
Qed.

Theorem mul_SNo_SNoS_omega : forall x y :e SNoS_ omega, x * y :e SNoS_ omega.
admit.
Qed.

End DiadicRationals.

Opaque int.

Section SurrealDiv.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.
Infix ^ 342 right := exp_SNo_nat.
Definition SNoL_pos : set -> set := fun x => {w :e SNoL x|0 < w}.

Theorem SNo_recip_pos_pos: forall x xi, SNo x -> SNo xi -> 0 < x -> x * xi = 1 -> 0 < xi.
admit.
Qed.

Theorem SNo_recip_lem1: forall x x' x'i y y', SNo x -> 0 < x -> x' :e SNoL_pos x -> SNo x'i -> x' * x'i = 1 -> SNo y -> x * y < 1 -> SNo y' -> 1 + - x * y' = (1 + - x * y) * (x' + - x) * x'i -> 1 < x * y'.
admit.
Qed.

Theorem SNo_recip_lem2: forall x x' x'i y y', SNo x -> 0 < x -> x' :e SNoL_pos x -> SNo x'i -> x' * x'i = 1 -> SNo y -> 1 < x * y -> SNo y' -> 1 + - x * y' = (1 + - x * y) * (x' + - x) * x'i -> x * y' < 1.
admit.
Qed.

Theorem SNo_recip_lem3: forall x x' x'i y y', SNo x -> 0 < x -> x' :e SNoR x -> SNo x'i -> x' * x'i = 1 -> SNo y -> x * y < 1 -> SNo y' -> 1 + - x * y' = (1 + - x * y) * (x' + - x) * x'i -> x * y' < 1.
admit.
Qed.

Theorem SNo_recip_lem4: forall x x' x'i y y', SNo x -> 0 < x -> x' :e SNoR x -> SNo x'i -> x' * x'i = 1 -> SNo y -> 1 < x * y -> SNo y' -> 1 + - x * y' = (1 + - x * y) * (x' + - x) * x'i -> 1 < x * y'.
admit.
Qed.

Definition SNo_recipauxset : set -> set -> set -> (set -> set) -> set := fun Y x X g => \/_ y :e Y, {(1 + (x' + - x) * y) * g x'|x' :e X}.

Theorem SNo_recipauxset_I: forall Y x X, forall g:set -> set,
 forall y :e Y, forall x' :e X, (1 + (x' + - x) * y) * g x' :e SNo_recipauxset Y x X g.
admit.
Qed.

Theorem SNo_recipauxset_E : forall Y x X, forall g:set -> set, forall z :e SNo_recipauxset Y x X g, forall p:prop, (forall y :e Y, forall x' :e X, z = (1 + (x' + - x) * y) * g x' -> p) -> p.
admit.
Qed.

Theorem SNo_recipauxset_ext: forall Y x X, forall g h:set -> set, (forall x' :e X, g x' = h x') -> SNo_recipauxset Y x X g = SNo_recipauxset Y x X h.
admit.
Qed.

Definition SNo_recipaux : set -> (set -> set) -> set -> set :=
 fun x g =>
  nat_primrec ({0},0)
   (fun k p => (p 0 :\/: SNo_recipauxset (p 0) x (SNoR x) g
                    :\/: SNo_recipauxset (p 1) x (SNoL_pos x) g,
                p 1 :\/: SNo_recipauxset (p 0) x (SNoL_pos x) g
                    :\/: SNo_recipauxset (p 1) x (SNoR x) g)).

Theorem SNo_recipaux_0: forall x, forall g:set -> set, SNo_recipaux x g 0 = ({0},0).
admit.
Qed.

Theorem SNo_recipaux_S: forall x, forall g:set -> set, forall n, nat_p n ->
   SNo_recipaux x g (ordsucc n)
 = (SNo_recipaux x g n 0 :\/: SNo_recipauxset (SNo_recipaux x g n 0) x (SNoR x) g
        :\/: SNo_recipauxset (SNo_recipaux x g n 1) x (SNoL_pos x) g,
    SNo_recipaux x g n 1 :\/: SNo_recipauxset (SNo_recipaux x g n 0) x (SNoL_pos x) g
        :\/: SNo_recipauxset (SNo_recipaux x g n 1) x (SNoR x) g).
admit.
Qed.

Theorem SNo_recipaux_lem1: forall x, SNo x -> 0 < x ->
 forall g:set -> set,
    (forall x' :e SNoS_ (SNoLev x), 0 < x' -> SNo (g x') /\ x' * g x' = 1)
 -> forall k, nat_p k ->
         (forall y :e SNo_recipaux x g k 0, SNo y /\ x * y < 1)
      /\ (forall y :e SNo_recipaux x g k 1, SNo y /\ 1 < x * y).
admit.
Qed.

Theorem SNo_recipaux_lem2: forall x, SNo x -> 0 < x ->
 forall g:set -> set,
    (forall x' :e SNoS_ (SNoLev x), 0 < x' -> SNo (g x') /\ x' * g x' = 1)
 -> SNoCutP (\/_ k :e omega, SNo_recipaux x g k 0) (\/_ k :e omega, SNo_recipaux x g k 1).
admit.
Qed.

Theorem SNo_recipaux_ext: forall x, SNo x -> forall g h:set -> set, (forall x' :e SNoS_ (SNoLev x), g x' = h x') -> forall k, nat_p k -> SNo_recipaux x g k = SNo_recipaux x h k.
admit.
Qed.

Section recip_SNo_pos.
Let G : set -> (set -> set) -> set := fun x g => SNoCut (\/_ k :e omega, SNo_recipaux x g k 0) (\/_ k :e omega, SNo_recipaux x g k 1).
Definition recip_SNo_pos : set -> set := SNo_rec_i G.

Theorem recip_SNo_pos_eq: forall x, SNo x -> recip_SNo_pos x = G x recip_SNo_pos.
admit.
Qed.

Theorem recip_SNo_pos_prop1: forall x, SNo x -> 0 < x -> SNo (recip_SNo_pos x) /\ x * recip_SNo_pos x = 1.
admit.
Qed.

Theorem SNo_recip_SNo_pos: forall x, SNo x -> 0 < x -> SNo (recip_SNo_pos x).
admit.
Qed.

Theorem recip_SNo_pos_invR: forall x, SNo x -> 0 < x -> x * recip_SNo_pos x = 1.
admit.
Qed.

Theorem recip_SNo_pos_is_pos: forall x, SNo x -> 0 < x -> 0 < recip_SNo_pos x.
admit.
Qed.

Theorem recip_SNo_pos_invol: forall x, SNo x -> 0 < x -> recip_SNo_pos (recip_SNo_pos x) = x.
admit.
Qed.

Theorem recip_SNo_pos_eps_: forall n, nat_p n -> recip_SNo_pos (eps_ n) = 2 ^ n.
admit.
Qed.

Theorem recip_SNo_pos_pow_2: forall n, nat_p n -> recip_SNo_pos (2 ^ n) = eps_ n.
admit.
Qed.

Theorem recip_SNo_pos_2: recip_SNo_pos 2 = eps_ 1.
admit.
Qed.

End recip_SNo_pos.
Definition recip_SNo : set -> set := fun x => if 0 < x then recip_SNo_pos x else if x < 0 then - recip_SNo_pos (- x) else 0.

Theorem recip_SNo_poscase: forall x, 0 < x -> recip_SNo x = recip_SNo_pos x.
admit.
Qed.

Theorem recip_SNo_negcase: forall x, SNo x -> x < 0 -> recip_SNo x = - recip_SNo_pos (- x).
admit.
Qed.

Theorem recip_SNo_0: recip_SNo 0 = 0.
admit.
Qed.

Theorem SNo_recip_SNo: forall x, SNo x -> SNo (recip_SNo x).
admit.
Qed.

Theorem recip_SNo_invR: forall x, SNo x -> x <> 0 -> x * recip_SNo x = 1.
admit.
Qed.

Theorem recip_SNo_invL: forall x, SNo x -> x <> 0 -> recip_SNo x * x = 1.
admit.
Qed.

Theorem mul_SNo_nonzero_cancel_L: forall x y z, SNo x -> x <> 0 -> SNo y -> SNo z -> x * y = x * z -> y = z.
admit.
Qed.

Theorem recip_SNo_pow_2 : forall n, nat_p n -> recip_SNo (2 ^ n) = eps_ n.
admit.
Qed.

Theorem recip_SNo_of_pos_is_pos: forall x, SNo x -> 0 < x -> 0 < recip_SNo x.
admit.
Qed.

Definition div_SNo : set -> set -> set := fun x y => x * recip_SNo y.

Infix :/: 353 := div_SNo.

Theorem SNo_div_SNo: forall x y, SNo x -> SNo y -> SNo (x :/: y).
admit.
Qed.

Theorem div_SNo_0_num: forall x, SNo x -> 0 :/: x = 0.
admit.
Qed.

Theorem div_SNo_0_denum: forall x, SNo x -> x :/: 0 = 0.
admit.
Qed.

Theorem mul_div_SNo_invL: forall x y, SNo x -> SNo y -> y <> 0 -> (x :/: y) * y = x.
admit.
Qed.

Theorem mul_div_SNo_invR: forall x y, SNo x -> SNo y -> y <> 0 -> y * (x :/: y) = x.
admit.
Qed.

Theorem mul_div_SNo_R: forall x y z, SNo x -> SNo y -> SNo z -> (x :/: y) * z = (x * z) :/: y.
admit.
Qed.

Theorem mul_div_SNo_L: forall x y z, SNo x -> SNo y -> SNo z -> z * (x :/: y) = (z * x) :/: y.
admit.
Qed.

Theorem div_mul_SNo_invL: forall x y, SNo x -> SNo y -> y <> 0 -> (x * y) :/: y = x.
admit.
Qed.

Theorem div_div_SNo: forall x y z, SNo x -> SNo y -> SNo z -> (x :/: y) :/: z = x :/: (y * z).
admit.
Qed.

Theorem mul_div_SNo_both: forall x y z w, SNo x -> SNo y -> SNo z -> SNo w -> (x :/: y) * (z :/: w) = (x * z) :/: (y * w).
admit.
Qed.

Theorem recip_SNo_pos_pos: forall x, SNo x -> 0 < x -> 0 < recip_SNo_pos x.
admit.
Qed.

Theorem div_SNo_pos_pos: forall x y, SNo x -> SNo y -> 0 < x -> 0 < y -> 0 < x :/: y.
admit.
Qed.

Theorem div_SNo_neg_pos: forall x y, SNo x -> SNo y -> x < 0 -> 0 < y -> x :/: y < 0.
admit.
Qed.

Theorem div_SNo_pos_LtL : forall x y z, SNo x -> SNo y -> SNo z -> 0 < y -> x < z * y -> x :/: y < z.
admit.
Qed.

Theorem div_SNo_pos_LtR : forall x y z, SNo x -> SNo y -> SNo z -> 0 < y -> z * y < x -> z < x :/: y.
admit.
Qed.

Theorem div_SNo_pos_LtL' : forall x y z, SNo x -> SNo y -> SNo z -> 0 < y -> x :/: y < z -> x < z * y.
admit.
Qed.

Theorem div_SNo_pos_LtR' : forall x y z, SNo x -> SNo y -> SNo z -> 0 < y -> z < x :/: y -> z * y < x.
admit.
Qed.

Theorem mul_div_SNo_nonzero_eq: forall x y z, SNo x -> SNo y -> SNo z -> y <> 0 -> x = y * z -> x :/: y = z.
admit.
Qed.

End SurrealDiv.

Opaque recip_SNo_pos recip_SNo.

Section Reals.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix :/: 353 := div_SNo.
Infix ^ 342 right := exp_SNo_nat.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.

Theorem SNoS_omega_drat_intvl : forall x :e SNoS_ omega,
  forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k.
admit.
Qed.

Theorem SNoS_ordsucc_omega_bdd_above : forall x :e SNoS_ (ordsucc omega), x < omega -> exists N :e omega, x < N.
admit.
Qed.

Theorem SNoS_ordsucc_omega_bdd_below : forall x :e SNoS_ (ordsucc omega), - omega < x -> exists N :e omega, - N < x.
admit.
Qed.

Theorem SNoS_ordsucc_omega_bdd_drat_intvl : forall x :e SNoS_ (ordsucc omega),
    - omega < x -> x < omega
 -> forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k.
admit.
Qed.

Definition real : set := {x :e SNoS_ (ordsucc omega)| x <> omega /\ x <> - omega /\ (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)}.

Theorem real_I : forall x :e SNoS_ (ordsucc omega),
    x <> omega
 -> x <> - omega
 -> (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
 -> x :e real.
admit.
Qed.

Theorem real_E : forall x :e real,
 forall p:prop,
      (SNo x
    -> SNoLev x :e ordsucc omega
    -> x :e SNoS_ (ordsucc omega)
    -> - omega < x
    -> x < omega
    -> (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
    -> (forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k)
    -> p)
   -> p.
admit.
Qed.

Theorem real_SNo : forall x :e real, SNo x.
admit.
Qed.

Theorem real_SNoS_omega_prop : forall x :e real, forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x.
admit.
Qed.

Theorem SNoS_omega_real : SNoS_ omega c= real.
admit.
Qed.

Theorem real_0 : 0 :e real.
admit.
Qed.

Theorem real_1 : 1 :e real.
admit.
Qed.

Theorem SNoLev_In_real_SNoS_omega : forall x :e real, forall w, SNo w -> SNoLev w :e SNoLev x -> w :e SNoS_ omega.
admit.
Qed.

Theorem real_SNoCut_SNoS_omega: forall L R c= SNoS_ omega, SNoCutP L R
 -> L <> 0
 -> R <> 0
 -> (forall w :e L, exists w' :e L, w < w')
 -> (forall z :e R, exists z' :e R, z' < z)
 -> SNoCut L R :e real.
admit.
Qed.

Theorem real_SNoCut: forall L R c= real, SNoCutP L R
 -> L <> 0
 -> R <> 0
 -> (forall w :e L, exists w' :e L, w < w')
 -> (forall z :e R, exists z' :e R, z' < z)
 -> SNoCut L R :e real.
admit.
Qed.

Theorem minus_SNo_prereal_1 : forall x, SNo x ->
    (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
 -> (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - - x) < eps_ k) -> q = - x).
admit.
Qed.

Theorem minus_SNo_prereal_2 : forall x, SNo x ->
    (forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k)
 -> (forall k :e omega, exists q :e SNoS_ omega, q < - x /\ - x < q + eps_ k).
admit.
Qed.

Theorem SNo_prereal_incr_lower_pos: forall x, SNo x -> 0 < x
 -> (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
 -> (forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k)
 -> forall k :e omega,
     forall p:prop,
         (forall q :e SNoS_ omega, 0 < q -> q < x -> x < q + eps_ k -> p)
      -> p.
admit.
Qed.

Theorem real_minus_SNo : forall x :e real, - x :e real.
admit.
Qed.

Theorem SNo_prereal_incr_lower_approx: forall x, SNo x ->
    (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
 -> (forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k)
 -> exists f :e SNoS_ omega :^: omega,
       forall n :e omega, f n < x /\ x < f n + eps_ n
                       /\ forall i :e n, f i < f n.
admit.
Qed.

Theorem SNo_prereal_decr_upper_approx: forall x, SNo x ->
    (forall q :e SNoS_ omega, (forall k :e omega, abs_SNo (q + - x) < eps_ k) -> q = x)
 -> (forall k :e omega, exists q :e SNoS_ omega, q < x /\ x < q + eps_ k)
 -> exists g :e SNoS_ omega :^: omega,
       forall n :e omega, g n + - eps_ n < x /\ x < g n
                       /\ forall i :e n, g n < g i.
admit.
Qed.

Theorem SNoCutP_SNoCut_lim : forall lambda, ordinal lambda
 -> (forall alpha :e lambda, ordsucc alpha :e lambda)
 -> forall L R c= SNoS_ lambda, SNoCutP L R
 -> SNoLev (SNoCut L R) :e ordsucc lambda.
admit.
Qed.

Theorem SNoCutP_SNoCut_omega : forall L R c= SNoS_ omega, SNoCutP L R
 -> SNoLev (SNoCut L R) :e ordsucc omega.
admit.
Qed.

Theorem SNo_approx_real_lem:
  forall f g :e SNoS_ omega :^: omega,
     (forall n m :e omega, f n < g m)
  -> forall p:prop,
         (SNoCutP {f n|n :e omega} {g n|n :e omega}
       -> SNo (SNoCut {f n|n :e omega} {g n|n :e omega})
       -> SNoLev (SNoCut {f n|n :e omega} {g n|n :e omega}) :e ordsucc omega
       -> SNoCut {f n|n :e omega} {g n|n :e omega} :e SNoS_ (ordsucc omega)
       -> (forall n :e omega, f n < SNoCut {f n|n :e omega} {g n|n :e omega})
       -> (forall n :e omega, SNoCut {f n|n :e omega} {g n|n :e omega} < g n)
       -> p)
      -> p.
admit.
Qed.

Theorem SNo_approx_real: forall x, SNo x ->
 forall f g :e SNoS_ omega :^: omega,
     (forall n :e omega, f n < x)
  -> (forall n :e omega, x < f n + eps_ n)
  -> (forall n :e omega, forall i :e n, f i < f n)
  -> (forall n :e omega, x < g n)
  -> (forall n :e omega, forall i :e n, g n < g i)
  -> x = SNoCut {f n|n :e omega} {g n|n :e omega}
  -> x :e real.
admit.
Qed.

Theorem SNo_approx_real_rep : forall x :e real,
 forall p:prop,
     (forall f g :e SNoS_ omega :^: omega,
           (forall n :e omega, f n < x)
        -> (forall n :e omega, x < f n + eps_ n)
        -> (forall n :e omega, forall i :e n, f i < f n)
        -> (forall n :e omega, g n + - eps_ n < x)
        -> (forall n :e omega, x < g n)
        -> (forall n :e omega, forall i :e n, g n < g i)
        -> SNoCutP {f n|n :e omega} {g n|n :e omega}
        -> x = SNoCut {f n|n :e omega} {g n|n :e omega}
        -> p)
  -> p.
admit.
Qed.

Theorem real_add_SNo : forall x y :e real, x + y :e real.
admit.
Qed.

Theorem SNoS_ordsucc_omega_bdd_eps_pos : forall x :e SNoS_ (ordsucc omega), 0 < x -> x < omega -> exists N :e omega, eps_ N * x < 1.
admit.
Qed.

Theorem real_mul_SNo_pos : forall x y :e real, 0 < x -> 0 < y -> x * y :e real.
admit.
Qed.

Theorem real_mul_SNo : forall x y :e real, x * y :e real.
admit.
Qed.

Theorem nonneg_real_nat_interval: forall x :e real, 0 <= x -> exists n :e omega, n <= x /\ x < ordsucc n.
admit.
Qed.

Theorem pos_real_left_approx_double: forall x :e real, 0 < x
 -> x <> 2 -> (forall m :e omega, x <> eps_ m)
 -> exists w :e SNoL_pos x, x < 2 * w.
admit.
Qed.

Theorem real_recip_SNo_lem1: forall x, SNo x -> x :e real -> 0 < x ->
    recip_SNo_pos x :e real
 /\ forall k, nat_p k ->
         (SNo_recipaux x recip_SNo_pos k 0 c= real)
      /\ (SNo_recipaux x recip_SNo_pos k 1 c= real).
admit.
Qed.

Theorem real_recip_SNo_pos: forall x :e real, 0 < x -> recip_SNo_pos x :e real.
admit.
Qed.

Theorem real_recip_SNo: forall x :e real, recip_SNo x :e real.
admit.
Qed.

Theorem real_div_SNo: forall x y :e real, x :/: y :e real.
admit.
Qed.

End Reals.

Opaque real.

Section even_odd.

Infix + 360 right := add_nat.
Infix * 355 right := mul_nat.

Theorem nat_le2_cases: forall m, nat_p m -> m c= 2 -> m = 0 \/ m = 1 \/ m = 2.
admit.
Qed.

Theorem prime_nat_2_lem: forall m, nat_p m -> forall n, nat_p n -> m * n = 2 -> m = 1 \/ m = 2.
admit.
Qed.

Theorem prime_nat_2: prime_nat 2.
admit.
Qed.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.

Theorem not_eq_2m_2n1: forall m n :e int, 2 * m <> 2 * n + 1.
admit.
Qed.

End even_odd.

Section form100_22b.

Let tag : set -> set := fun alpha => SetAdjoin alpha {1}.
Postfix ' 100 := tag.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.

Theorem atleastp_SNoS_ordsucc_omega_Power_omega: atleastp (SNoS_ (ordsucc omega)) (Power omega).
admit.
Qed.

Theorem Repl_finite: forall f:set -> set, forall X, finite X -> finite {f x|x :e X}.
admit.
Qed.

Theorem infinite_bigger: forall X c= omega, infinite X -> forall m :e omega, exists n :e X, m :e n.
admit.
Qed.

Theorem equip_real_Power_omega: equip real (Power omega).
admit.
Qed.

Theorem form100_22_real_uncountable_atleastp: ~atleastp real omega.
admit.
Qed.

Theorem form100_22_real_uncountable_equip: ~equip real omega.
admit.
Qed.

Theorem form100_22_real_uncountable: atleastp omega real /\ ~equip real omega.
admit.
Qed.

End form100_22b.

Section rational.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix ^ 342 right := exp_SNo_nat.
Infix :/: 353 := div_SNo.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.

Definition rational : set := {x :e real | exists m :e int, exists n :e omega :\: {0}, x = m :/: n}.

End rational.

Section form100_3.

(** The Denumerability of the Rational Numbers **)

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix :/: 353 := div_SNo.
Infix ^ 342 right := exp_SNo_nat.

Theorem Subq_int_SNoS_omega: int c= SNoS_ omega.
admit.
Qed.

Theorem Subq_SNoS_omega_rational: SNoS_ omega c= rational.
admit.
Qed.

Theorem Subq_rational_real: rational c= real.
admit.
Qed.

Theorem rational_minus_SNo: forall q :e rational, - q :e rational.
admit.
Qed.

Definition nat_pair : set -> set -> set := fun m n => 2 ^ m * (2 * n + 1).

Theorem nat_pair_In_omega: forall m n :e omega, nat_pair m n :e omega.
admit.
Qed.

Theorem nat_pair_0: forall m n m' n' :e omega, nat_pair m n = nat_pair m' n' -> m = m'.
admit.
Qed.

Theorem nat_pair_1: forall m n m' n' :e omega, nat_pair m n = nat_pair m' n' -> n = n'.
admit.
Qed.

Theorem form100_3: equip omega rational.
admit.
Qed.

End form100_3.

Section SurrealSqrt.
Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix :/: 353 := div_SNo.
Infix < 490 := SNoLt.
(* Unicode <= "2264" *)
Infix <= 490 := SNoLe.
Infix ^ 342 right := exp_SNo_nat.
Definition SNoL_nonneg : set -> set := fun x => {w :e SNoL x|0 <= w}.

Theorem SNoL_nonneg_0: SNoL_nonneg 0 = 0.
admit.
Qed.

Theorem SNoL_nonneg_1: SNoL_nonneg 1 = 1.
admit.
Qed.

Definition SNo_sqrtauxset : set -> set -> set -> set := fun Y Z x => \/_ y :e Y, {(x + y * z) :/: (y + z)|z :e Z, 0 < y + z}.

Theorem SNo_sqrtauxset_I : forall Y Z x,
 forall y :e Y, forall z :e Z, 0 < y + z -> (x + y * z) :/: (y + z) :e SNo_sqrtauxset Y Z x.
admit.
Qed.

Theorem SNo_sqrtauxset_E : forall Y Z x,
 forall u :e SNo_sqrtauxset Y Z x, forall p:prop,
     (forall y :e Y, forall z :e Z, 0 < y + z -> u = (x + y * z) :/: (y + z) -> p)
  -> p.
admit.
Qed.

Theorem SNo_sqrtauxset_0: forall Z x, SNo_sqrtauxset 0 Z x = 0.
admit.
Qed.

Theorem SNo_sqrtauxset_0': forall Y x, SNo_sqrtauxset Y 0 x = 0.
admit.
Qed.

Definition SNo_sqrtaux : set -> (set -> set) -> set -> set :=
 fun x g =>
  nat_primrec ({g w|w :e SNoL_nonneg x},{g z|z :e SNoR x})
   (fun k p => (p 0 :\/: SNo_sqrtauxset (p 0) (p 1) x,
                p 1 :\/: SNo_sqrtauxset (p 0) (p 0) x
                    :\/: SNo_sqrtauxset (p 1) (p 1) x)).

Theorem SNo_sqrtaux_0: forall x, forall g:set -> set, SNo_sqrtaux x g 0 = ({g w|w :e SNoL_nonneg x},{g z|z :e SNoR x}).
admit.
Qed.

Theorem SNo_sqrtaux_S: forall x, forall g:set -> set, forall n, nat_p n
 -> SNo_sqrtaux x g (ordsucc n)
  = (SNo_sqrtaux x g n 0
       :\/: SNo_sqrtauxset (SNo_sqrtaux x g n 0) (SNo_sqrtaux x g n 1) x,
     SNo_sqrtaux x g n 1
       :\/: SNo_sqrtauxset (SNo_sqrtaux x g n 0) (SNo_sqrtaux x g n 0) x
       :\/: SNo_sqrtauxset (SNo_sqrtaux x g n 1) (SNo_sqrtaux x g n 1) x).
admit.
Qed.

Theorem SNo_sqrtaux_mon_lem: forall x, forall g:set -> set,
  forall m, nat_p m -> forall n, nat_p n
   -> SNo_sqrtaux x g m 0 c= SNo_sqrtaux x g (add_nat m n) 0
   /\ SNo_sqrtaux x g m 1 c= SNo_sqrtaux x g (add_nat m n) 1.
admit.
Qed.

Theorem SNo_sqrtaux_mon: forall x, forall g:set -> set,
  forall m, nat_p m -> forall n, nat_p n -> m c= n
   -> SNo_sqrtaux x g m 0 c= SNo_sqrtaux x g n 0
   /\ SNo_sqrtaux x g m 1 c= SNo_sqrtaux x g n 1.
admit.
Qed.

Theorem SNo_sqrtaux_ext: forall x, SNo x -> forall g h:set -> set, (forall x' :e SNoS_ (SNoLev x), g x' = h x') -> forall k, nat_p k -> SNo_sqrtaux x g k = SNo_sqrtaux x h k.
admit.
Qed.

Section sqrt_SNo_nonneg.
Let G : set -> (set -> set) -> set := fun x g => SNoCut (\/_ k :e omega, SNo_sqrtaux x g k 0) (\/_ k :e omega, SNo_sqrtaux x g k 1).
Definition sqrt_SNo_nonneg : set -> set := SNo_rec_i G.

Theorem sqrt_SNo_nonneg_eq: forall x, SNo x -> sqrt_SNo_nonneg x = G x sqrt_SNo_nonneg.
admit.
Qed.

Theorem sqrt_SNo_nonneg_prop1a: forall x, SNo x -> 0 <= x ->
    (forall w :e SNoS_ (SNoLev x), 0 <= w -> SNo (sqrt_SNo_nonneg w) /\ 0 <= sqrt_SNo_nonneg w /\ sqrt_SNo_nonneg w * sqrt_SNo_nonneg w = w)
 -> forall k, nat_p k ->
              (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 0, SNo y /\ 0 <= y /\ y * y < x)
           /\ (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 1, SNo y /\ 0 <= y /\ x < y * y).
admit.
Qed.

Theorem sqrt_SNo_nonneg_prop1b: forall x, SNo x -> 0 <= x
 -> (forall k, nat_p k ->
              (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 0, SNo y /\ 0 <= y /\ y * y < x)
           /\ (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 1, SNo y /\ 0 <= y /\ x < y * y))
 -> SNoCutP (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0) (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1).
admit.
Qed.

Theorem sqrt_SNo_nonneg_prop1c: forall x, SNo x -> 0 <= x ->
    SNoCutP (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0) (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1)
 -> (forall z :e (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1), forall p:prop, (SNo z -> 0 <= z -> x < z * z -> p) -> p)
 -> 0 <= G x sqrt_SNo_nonneg.
admit.
Qed.

Theorem sqrt_SNo_nonneg_prop1d: forall x, SNo x -> 0 <= x
  -> (forall w :e SNoS_ (SNoLev x), 0 <= w -> SNo (sqrt_SNo_nonneg w) /\ 0 <= sqrt_SNo_nonneg w /\ sqrt_SNo_nonneg w * sqrt_SNo_nonneg w = w)
  -> SNoCutP (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0) (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1)
  -> 0 <= G x sqrt_SNo_nonneg
  -> G x sqrt_SNo_nonneg * G x sqrt_SNo_nonneg < x
  -> False.
admit.
Qed.

Theorem sqrt_SNo_nonneg_prop1e: forall x, SNo x -> 0 <= x
  -> (forall w :e SNoS_ (SNoLev x), 0 <= w -> SNo (sqrt_SNo_nonneg w) /\ 0 <= sqrt_SNo_nonneg w /\ sqrt_SNo_nonneg w * sqrt_SNo_nonneg w = w)
  -> SNoCutP (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0) (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1)
  -> 0 <= G x sqrt_SNo_nonneg
  -> x < G x sqrt_SNo_nonneg * G x sqrt_SNo_nonneg
  -> False.
admit.
Qed.

Theorem sqrt_SNo_nonneg_prop1: forall x, SNo x -> 0 <= x -> SNo (sqrt_SNo_nonneg x) /\ 0 <= sqrt_SNo_nonneg x /\ sqrt_SNo_nonneg x * sqrt_SNo_nonneg x = x.
admit.
Qed.

End sqrt_SNo_nonneg.

Theorem SNo_sqrtaux_0_1_prop: forall x, SNo x -> 0 <= x ->
  forall k, nat_p k ->
      (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 0, SNo y /\ 0 <= y /\ y * y < x)
   /\ (forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 1, SNo y /\ 0 <= y /\ x < y * y).
admit.
Qed.

Theorem SNo_sqrtaux_0_prop: forall x, SNo x -> 0 <= x ->
  forall k, nat_p k ->
  forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 0, SNo y /\ 0 <= y /\ y * y < x.
admit.
Qed.

Theorem SNo_sqrtaux_1_prop: forall x, SNo x -> 0 <= x ->
  forall k, nat_p k ->
  forall y :e SNo_sqrtaux x sqrt_SNo_nonneg k 1, SNo y /\ 0 <= y /\ x < y * y.
admit.
Qed.

Theorem SNo_sqrt_SNo_SNoCutP: forall x, SNo x -> 0 <= x ->
  SNoCutP (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0)
          (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1).
admit.
Qed.

Theorem SNo_sqrt_SNo_nonneg: forall x, SNo x -> 0 <= x -> SNo (sqrt_SNo_nonneg x).
admit.
Qed.

Theorem sqrt_SNo_nonneg_nonneg: forall x, SNo x -> 0 <= x -> 0 <= sqrt_SNo_nonneg x.
admit.
Qed.

Theorem sqrt_SNo_nonneg_sqr: forall x, SNo x -> 0 <= x -> sqrt_SNo_nonneg x * sqrt_SNo_nonneg x = x.
admit.
Qed.

Theorem sqrt_SNo_nonneg_0 : sqrt_SNo_nonneg 0 = 0.
admit.
Qed.

Theorem sqrt_SNo_nonneg_1 : sqrt_SNo_nonneg 1 = 1.
admit.
Qed.

Theorem sqrt_SNo_nonneg_0inL0: forall x, SNo x -> 0 <= x -> 0 :e SNoLev x -> 0 :e SNo_sqrtaux x sqrt_SNo_nonneg 0 0.
admit.
Qed.

Theorem sqrt_SNo_nonneg_Lnonempty: forall x, SNo x -> 0 <= x -> 0 :e SNoLev x -> (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 0) <> 0.
admit.
Qed.

Theorem sqrt_SNo_nonneg_Rnonempty: forall x, SNo x -> 0 <= x -> 1 :e SNoLev x -> (\/_ k :e omega, SNo_sqrtaux x sqrt_SNo_nonneg k 1) <> 0.
admit.
Qed.

Theorem SNo_sqrtauxset_real: forall Y Z x, Y c= real -> Z c= real -> x :e real -> SNo_sqrtauxset Y Z x c= real.
admit.
Qed.

Theorem SNo_sqrtauxset_real_nonneg: forall Y Z x, Y c= {w :e real|0 <= w} -> Z c= {z :e real|0 <= z} -> x :e real -> 0 <= x -> SNo_sqrtauxset Y Z x c= {w :e real|0 <= w}.
admit.
Qed.

Theorem sqrt_SNo_nonneg_SNoS_omega: forall x :e SNoS_ omega, 0 <= x -> sqrt_SNo_nonneg x :e real.
admit.
Qed.

Theorem sqrt_SNo_nonneg_real: forall x :e real, 0 <= x -> sqrt_SNo_nonneg x :e real.
admit.
Qed.

End SurrealSqrt.
Opaque sqrt_SNo_nonneg.

Section form100_1.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix :/: 353 := div_SNo.

Theorem divides_int_div_SNo_int: forall m n, divides_int m n -> n :/: m :e int.
admit.
Qed.

(** If m times m = 2 times n times n for naturals m and n, then n = 0. **)
Theorem form100_1_lem1 : forall m, nat_p m -> forall n, nat_p n -> m * m = 2 * n * n -> n = 0.
admit.
Qed.

(** There are no nonzero naturals m and n such that m times m = 2 times n times n. **)
Theorem form100_1_lem2 : forall m :e omega, forall n :e omega :\: 1, m * m <> 2 * n * n.
admit.
Qed.

Prefix - 358 := minus_SNo.
Infix + 360 right := add_SNo.
Infix * 355 right := mul_SNo.
Infix :/: 353 := div_SNo.

Theorem sqrt_2_irrational: sqrt_SNo_nonneg 2 :e real :\: rational.
admit.
Qed.

End form100_1.

Section Topology.

(** from 12 Topological Spaces: definition of topology on X **)
(** LATEX VERSION: A topology on a set X is a collection T of subsets of X such that  and X are in T, arbitrary unions of subcollections of T lie in T, and finite intersections of elements of T lie in T. **)
Definition topology_on : set -> set -> prop := fun X T =>
  T c= Power X
/\ Empty :e T
/\ X :e T
/\ (forall UFam :e Power T, Union UFam :e T)
/\ (forall U :e T, forall V :e T, U :/\: V :e T).

(** from 12: definition of open sets in a topology **)
(** LATEX VERSION: If X has topology T, a subset U of X is open exactly when U is an element of T. **)
Definition open_in : set -> set -> set -> prop := fun X T U =>
  topology_on X T /\ U :e T.

(** Helper: Open set is a subset of X **)
Theorem open_in_subset : forall X T U:set,
  open_in X T U -> U c= X.
let X T U.
assume HU: open_in X T U.
prove U c= X.
(** open_in X T U = topology_on X T /\ U :e T **)
claim HTx: topology_on X T.
{ exact (andEL (topology_on X T) (U :e T) HU). }
claim HUT: U :e T.
{ exact (andER (topology_on X T) (U :e T) HU). }
(** Extract T c= Power X from topology_on and apply PowerE **)
claim H1: (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) /\ (forall U0 :e T, forall V :e T, U0 :/\: V :e T).
{ exact HTx. }
claim H2: ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T).
{ exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) (forall U0 :e T, forall V :e T, U0 :/\: V :e T) H1). }
claim H3: (T c= Power X /\ Empty :e T) /\ X :e T.
{ exact (andEL ((T c= Power X /\ Empty :e T) /\ X :e T) (forall UFam :e Power T, Union UFam :e T) H2). }
claim H4: T c= Power X /\ Empty :e T.
{ exact (andEL (T c= Power X /\ Empty :e T) (X :e T) H3). }
claim HTsub: T c= Power X.
{ exact (andEL (T c= Power X) (Empty :e T) H4). }
claim HUPower: U :e Power X.
{ exact (HTsub U HUT). }
exact (PowerE X U HUPower).
Qed.

(** Helper: Elements of topology are subsets of X **)
Theorem topology_elem_subset : forall X T U:set,
  topology_on X T -> U :e T -> U c= X.
let X T U.
assume HTx: topology_on X T.
assume HU: U :e T.
prove U c= X.
(** Extract T c= Power X from topology_on **)
claim H1: (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) /\ (forall U0 :e T, forall V :e T, U0 :/\: V :e T).
{ exact HTx. }
claim H2: ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T).
{ exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) (forall U0 :e T, forall V :e T, U0 :/\: V :e T) H1). }
claim H3: (T c= Power X /\ Empty :e T) /\ X :e T.
{ exact (andEL ((T c= Power X /\ Empty :e T) /\ X :e T) (forall UFam :e Power T, Union UFam :e T) H2). }
claim H4: T c= Power X /\ Empty :e T.
{ exact (andEL (T c= Power X /\ Empty :e T) (X :e T) H3). }
claim HTsub: T c= Power X.
{ exact (andEL (T c= Power X) (Empty :e T) H4). }
claim HUPower: U :e Power X.
{ exact (HTsub U HU). }
exact (PowerE X U HUPower).
Qed.

(** Helper: Empty is in every topology **)
Theorem topology_has_empty : forall X T:set,
  topology_on X T -> Empty :e T.
let X T.
assume HTx: topology_on X T.
prove Empty :e T.
(** topology_on X T = ((((T c= Power X /\ Empty :e T) /\ X :e T) /\ Union axiom) /\ Intersection axiom) **)
claim H1: (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) /\ (forall U :e T, forall V :e T, U :/\: V :e T).
{ exact HTx. }
claim H2: ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T).
{ exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) (forall U :e T, forall V :e T, U :/\: V :e T) H1). }
claim H3: (T c= Power X /\ Empty :e T) /\ X :e T.
{ exact (andEL ((T c= Power X /\ Empty :e T) /\ X :e T) (forall UFam :e Power T, Union UFam :e T) H2). }
claim H4: T c= Power X /\ Empty :e T.
{ exact (andEL (T c= Power X /\ Empty :e T) (X :e T) H3). }
exact (andER (T c= Power X) (Empty :e T) H4).
Qed.

(** Helper: X is in every topology on X **)
Theorem topology_has_X : forall X T:set,
  topology_on X T -> X :e T.
let X T.
assume HTx: topology_on X T.
prove X :e T.
(** topology_on X T = ((((T c= Power X /\ Empty :e T) /\ X :e T) /\ Union axiom) /\ Intersection axiom) **)
claim H1: (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) /\ (forall U :e T, forall V :e T, U :/\: V :e T).
{ exact HTx. }
claim H2: ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T).
{ exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) (forall U :e T, forall V :e T, U :/\: V :e T) H1). }
claim H3: (T c= Power X /\ Empty :e T) /\ X :e T.
{ exact (andEL ((T c= Power X /\ Empty :e T) /\ X :e T) (forall UFam :e Power T, Union UFam :e T) H2). }
exact (andER (T c= Power X /\ Empty :e T) (X :e T) H3).
Qed.

(** Helper: topology is a family of subsets **)
Theorem topology_subset_axiom : forall X T:set,
  topology_on X T -> T c= Power X.
let X T.
assume HTx: topology_on X T.
prove T c= Power X.
claim H0: ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T).
{ exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) (forall U :e T, forall V :e T, U :/\: V :e T) HTx). }
claim H1: (T c= Power X /\ Empty :e T) /\ X :e T.
{ exact (andEL ((T c= Power X /\ Empty :e T) /\ X :e T) (forall UFam :e Power T, Union UFam :e T) H0). }
claim H2: T c= Power X /\ Empty :e T.
{ exact (andEL (T c= Power X /\ Empty :e T) (X :e T) H1). }
exact (andEL (T c= Power X) (Empty :e T) H2).
Qed.

(** Helper: Union of family in topology stays in topology **)
Theorem topology_union_closed : forall X T UFam:set,
  topology_on X T -> UFam c= T -> Union UFam :e T.
let X T UFam.
assume HTx: topology_on X T.
assume HUFam: UFam c= T.
prove Union UFam :e T.
(** Extract union axiom from topology_on **)
claim H1: (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam0 :e Power T, Union UFam0 :e T)) /\ (forall U :e T, forall V :e T, U :/\: V :e T).
{ exact HTx. }
claim H2: ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam0 :e Power T, Union UFam0 :e T).
{ exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam0 :e Power T, Union UFam0 :e T)) (forall U :e T, forall V :e T, U :/\: V :e T) H1). }
claim HUnionAxiom: forall UFam0 :e Power T, Union UFam0 :e T.
{ exact (andER (((T c= Power X /\ Empty :e T) /\ X :e T)) (forall UFam0 :e Power T, Union UFam0 :e T) H2). }
claim HUFamPower: UFam :e Power T.
{ exact (PowerI T UFam HUFam). }
exact (HUnionAxiom UFam HUFamPower).
Qed.

(** Helper: Union axiom using Power membership **)
Theorem topology_union_closed_pow : forall X T UFam:set,
  topology_on X T -> UFam :e Power T -> Union UFam :e T.
let X T UFam.
assume HTx: topology_on X T.
assume HUFamPow: UFam :e Power T.
prove Union UFam :e T.
claim HUFamSub: UFam c= T.
{ exact (PowerE T UFam HUFamPow). }
exact (topology_union_closed X T UFam HTx HUFamSub).
Qed.

(** Helper: union axiom extracted **)
Theorem topology_union_axiom : forall X T:set,
  topology_on X T ->
  forall UFam :e Power T, Union UFam :e T.
let X T.
assume HTx: topology_on X T.
prove forall UFam :e Power T, Union UFam :e T.
let UFam. assume HUFamPow: UFam :e Power T.
exact (topology_union_closed_pow X T UFam HTx HUFamPow).
Qed.

(** Helper: Binary intersection in topology stays in topology **)
Theorem topology_binintersect_closed : forall X T U V:set,
  topology_on X T -> U :e T -> V :e T -> U :/\: V :e T.
let X T U V.
assume HTx: topology_on X T.
assume HU: U :e T.
assume HV: V :e T.
prove U :/\: V :e T.
(** Extract intersection axiom from topology_on **)
claim HIntersectAxiom: forall U0 :e T, forall V0 :e T, U0 :/\: V0 :e T.
{ exact (andER ((((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T))) (forall U0 :e T, forall V0 :e T, U0 :/\: V0 :e T) HTx). }
exact (HIntersectAxiom U HU V HV).
Qed.

(** Helper: intersection axiom extracted **)
Theorem topology_binintersect_axiom : forall X T:set,
  topology_on X T ->
  forall U :e T, forall V :e T, U :/\: V :e T.
let X T.
assume HTx: topology_on X T.
prove forall U :e T, forall V :e T, U :/\: V :e T.
let U. assume HU: U :e T.
let V. assume HV: V :e T.
exact (topology_binintersect_closed X T U V HTx HU HV).
Qed.

(** Helper: Empty set is open in any topology **)
Theorem Empty_is_open : forall X T:set,
  topology_on X T -> open_in X T Empty.
let X T.
assume HTx: topology_on X T.
prove open_in X T Empty.
prove topology_on X T /\ Empty :e T.
apply andI.
- exact HTx.
- exact (topology_has_empty X T HTx).
Qed.

(** Helper: X is open in its own topology **)
Theorem X_is_open : forall X T:set,
  topology_on X T -> open_in X T X.
let X T.
assume HTx: topology_on X T.
prove open_in X T X.
prove topology_on X T /\ X :e T.
apply andI.
- exact HTx.
- exact (topology_has_X X T HTx).
Qed.

(** Helper: Union of open sets is open **)
Theorem union_open : forall X T UFam:set,
  topology_on X T ->
  (forall U :e UFam, open_in X T U) ->
  open_in X T (Union UFam).
let X T UFam.
assume HTx: topology_on X T.
assume HUFam: forall U :e UFam, open_in X T U.
prove open_in X T (Union UFam).
prove topology_on X T /\ Union UFam :e T.
apply andI.
- exact HTx.
- prove Union UFam :e T.
  claim HUFamsub: UFam c= T.
  { let U. assume HUin: U :e UFam.
    claim HUopen: open_in X T U.
    { exact (HUFam U HUin). }
    exact (andER (topology_on X T) (U :e T) HUopen).
  }
  exact (topology_union_closed X T UFam HTx HUFamsub).
Qed.

(** Helper: Binary intersection of open sets is open **)
Theorem binintersect_open : forall X T U V:set,
  open_in X T U ->
  open_in X T V ->
  open_in X T (U :/\: V).
let X T U V.
assume HU: open_in X T U.
assume HV: open_in X T V.
prove open_in X T (U :/\: V).
claim HTx: topology_on X T.
{ exact (andEL (topology_on X T) (U :e T) HU). }
claim HUinT: U :e T.
{ exact (andER (topology_on X T) (U :e T) HU). }
claim HVinT: V :e T.
{ exact (andER (topology_on X T) (V :e T) HV). }
prove topology_on X T /\ U :/\: V :e T.
apply andI.
- exact HTx.
- exact (topology_binintersect_closed X T U V HTx HUinT HVinT).
  Qed.

(** from 12: closed set as complement of open set **)
(** LATEX VERSION: A set C is closed in X (with topology T) if there exists an open set UT whose complement in X equals C. **)
Definition closed_in : set -> set -> set -> prop := fun X T C =>
  topology_on X T /\ (C c= X /\ exists U :e T, C = X :\: U).

(** Helper: Closed set is a subset of X **)
Theorem closed_in_subset : forall X T C:set,
  closed_in X T C -> C c= X.
let X T C.
assume HC: closed_in X T C.
prove C c= X.
claim HCparts: C c= X /\ exists U :e T, C = X :\: U.
{ exact (andER (topology_on X T) (C c= X /\ exists U :e T, C = X :\: U) HC). }
exact (andEL (C c= X) (exists U :e T, C = X :\: U) HCparts).
Qed.

(** from 12: complement of open set is closed **)
(** LATEX VERSION: If U is open in topology T on X, then X\\U is closed in that topology. **)
Theorem closed_of_open_complement : forall X T U:set, topology_on X T -> U :e T -> closed_in X T (X :\: U).
let X. let T. let U.
assume Htop HU.
prove topology_on X T /\ (X :\: U c= X /\ exists V :e T, X :\: U = X :\: V).
apply andI.
- exact Htop.
- apply andI.
  + apply setminus_Subq.
  + witness U.
    apply andI.
    * exact HU.
    * reflexivity.
Qed.

(** Helper: X is closed in any topology **)
Theorem X_is_closed : forall X T:set,
  topology_on X T -> closed_in X T X.
let X T.
assume HTx: topology_on X T.
prove topology_on X T /\ (X c= X /\ exists U :e T, X = X :\: U).
apply andI.
- exact HTx.
- apply andI.
  + exact (Subq_ref X).
  + witness Empty.
    apply andI.
    * exact (topology_has_empty X T HTx).
    * prove X = X :\: Empty.
      apply set_ext.
      { let x. assume Hx: x :e X.
        prove x :e X :\: Empty.
        apply setminusI.
        - exact Hx.
        - assume H: x :e Empty.
          apply (EmptyE x H).
      }
      { let x. assume Hx: x :e X :\: Empty.
        exact (setminusE1 X Empty x Hx).
      }
Qed.

(** Helper: Empty is closed in any topology **)
Theorem Empty_is_closed : forall X T:set,
  topology_on X T -> closed_in X T Empty.
let X T.
assume HTx: topology_on X T.
prove topology_on X T /\ (Empty c= X /\ exists U :e T, Empty = X :\: U).
apply andI.
- exact HTx.
- apply andI.
  + exact (Subq_Empty X).
  + witness X.
    apply andI.
    * exact (topology_has_X X T HTx).
    * prove Empty = X :\: X.
      apply set_ext.
      { exact (Subq_Empty (X :\: X)). }
      { let x. assume Hx: x :e X :\: X.
        claim HxX: x :e X.
        { exact (setminusE1 X X x Hx). }
        claim HxnotX: x /:e X.
        { exact (setminusE2 X X x Hx). }
        apply FalseE.
        exact (HxnotX HxX).
      }
Qed.

(** Helper: Complement of closed set is open **)
Theorem open_of_closed_complement : forall X T C:set,
  closed_in X T C -> open_in X T (X :\: C).
let X T C.
assume HC: closed_in X T C.
prove open_in X T (X :\: C).
prove topology_on X T /\ X :\: C :e T.
claim HTx: topology_on X T.
{ exact (andEL (topology_on X T) (C c= X /\ exists U :e T, C = X :\: U) HC). }
claim HCsub: C c= X.
{ exact (andEL (C c= X) (exists U :e T, C = X :\: U) (andER (topology_on X T) (C c= X /\ exists U :e T, C = X :\: U) HC)). }
claim HCex: exists U :e T, C = X :\: U.
{ exact (andER (C c= X) (exists U :e T, C = X :\: U) (andER (topology_on X T) (C c= X /\ exists U :e T, C = X :\: U) HC)). }
apply andI.
- exact HTx.
- prove X :\: C :e T.
  apply HCex.
  let U. assume HU: U :e T /\ C = X :\: U.
  claim HUinT: U :e T.
  { exact (andEL (U :e T) (C = X :\: U) HU). }
  claim HCeq: C = X :\: U.
  { exact (andER (U :e T) (C = X :\: U) HU). }
  claim HXCeq: X :\: C = X :\: (X :\: U).
  { rewrite <- HCeq. reflexivity. }
  rewrite HXCeq.
  (** Now prove X :\: (X :\: U) = U for U c= X **)
  claim HUsub: U c= X.
  { claim H1: (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) /\ (forall U0 :e T, forall V :e T, U0 :/\: V :e T).
    { exact HTx. }
    claim H2: ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T).
    { exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) (forall U0 :e T, forall V :e T, U0 :/\: V :e T) H1). }
    claim H3: (T c= Power X /\ Empty :e T) /\ X :e T.
    { exact (andEL ((T c= Power X /\ Empty :e T) /\ X :e T) (forall UFam :e Power T, Union UFam :e T) H2). }
    claim H4: T c= Power X /\ Empty :e T.
    { exact (andEL (T c= Power X /\ Empty :e T) (X :e T) H3). }
    claim HTsubPower: T c= Power X.
    { exact (andEL (T c= Power X) (Empty :e T) H4). }
    claim HUPower: U :e Power X.
    { exact (HTsubPower U HUinT). }
    exact (PowerE X U HUPower).
  }
  claim Heq: X :\: (X :\: U) = U.
  { apply set_ext.
    - let x. assume Hx: x :e X :\: (X :\: U).
      prove x :e U.
      claim HxX: x :e X.
      { exact (setminusE1 X (X :\: U) x Hx). }
      claim HxnotXU: x /:e X :\: U.
      { exact (setminusE2 X (X :\: U) x Hx). }
      apply (xm (x :e U)).
      + assume HxU: x :e U.
        exact HxU.
      + assume HxnotU: x /:e U.
        claim HxXU: x :e X :\: U.
        { apply setminusI.
          - exact HxX.
          - exact HxnotU.
        }
        apply FalseE.
        exact (HxnotXU HxXU).
    - let x. assume Hx: x :e U.
      prove x :e X :\: (X :\: U).
      claim HxX: x :e X.
      { exact (HUsub x Hx). }
      apply setminusI.
      + exact HxX.
      + assume HxXU: x :e X :\: U.
        claim HxnotU: x /:e U.
        { exact (setminusE2 X U x HxXU). }
        exact (HxnotU Hx).
  }
  rewrite Heq.
  exact HUinT.
Qed.

(** Helper: binary union is union of a pair **)
Theorem binunion_eq_Union_pair : forall X Y:set, X :\/: Y = Union {X,Y}.
let X Y.
apply set_ext.
- let z. assume Hz: z :e X :\/: Y.
  prove z :e Union {X,Y}.
  apply (binunionE X Y z Hz).
  - assume HzX: z :e X.
    apply (UnionI {X,Y} z X).
    + exact HzX.
    + exact (UPairI1 X Y).
  - assume HzY: z :e Y.
    apply (UnionI {X,Y} z Y).
    + exact HzY.
    + exact (UPairI2 X Y).
- let z. assume Hz: z :e Union {X,Y}.
  prove z :e X :\/: Y.
  apply (UnionE_impred {X,Y} z Hz).
  let Z.
  assume HzZ: z :e Z.
  assume HZ: Z :e {X,Y}.
  claim Hor: Z = X \/ Z = Y.
  { exact (UPairE Z X Y HZ). }
  apply Hor.
  - assume HZX: Z = X.
    claim HzX: z :e X.
    { rewrite <- HZX. exact HzZ. }
    exact (binunionI1 X Y z HzX).
  - assume HZY: Z = Y.
    claim HzY: z :e Y.
    { rewrite <- HZY. exact HzZ. }
    exact (binunionI2 X Y z HzY).
Qed.

(** Helper: binary union of members of a topology is in the topology **)
(** LATEX VERSION: Since U  V is the union of the pair {U,V}, any topology is closed under binary unions. **)
Theorem topology_binunion_closed : forall X T U V:set,
  topology_on X T -> U :e T -> V :e T -> U :\/: V :e T.
let X T U V.
assume HTx: topology_on X T.
assume HU: U :e T.
assume HV: V :e T.
prove U :\/: V :e T.
claim Hpairsub: {U,V} c= T.
{ let W. assume HW: W :e {U,V}.
  claim Hor: W = U \/ W = V.
  { exact (UPairE W U V HW). }
  apply Hor.
  - assume HWU: W = U.
    rewrite HWU. exact HU.
  - assume HWV: W = V.
    rewrite HWV. exact HV.
}
claim HUnionPair: Union {U,V} :e T.
{ exact (topology_union_closed X T {U,V} HTx Hpairsub). }
rewrite (binunion_eq_Union_pair U V).
exact HUnionPair.
Qed.

(** Helper: binary union of open sets is open **)
(** LATEX VERSION: The union of two open sets is open. **)
Theorem binunion_open : forall X T U V:set,
  open_in X T U ->
  open_in X T V ->
  open_in X T (U :\/: V).
let X T U V.
assume HU: open_in X T U.
assume HV: open_in X T V.
prove open_in X T (U :\/: V).
claim HTx: topology_on X T.
{ exact (andEL (topology_on X T) (U :e T) HU). }
claim HUinT: U :e T.
{ exact (andER (topology_on X T) (U :e T) HU). }
claim HVinT: V :e T.
{ exact (andER (topology_on X T) (V :e T) HV). }
prove topology_on X T /\ (U :\/: V) :e T.
apply andI.
- exact HTx.
- exact (topology_binunion_closed X T U V HTx HUinT HVinT).
Qed.

(** from 12: "finer than" / "coarser than" topologies **)
(** LATEX VERSION: Given topologies T and T' on X, T' is finer than T if T'  T; T is coarser than T'; the topologies are comparable if one contains the other. **)
Definition finer_than : set -> set -> prop := fun T' T => T c= T'.

(** LATEX VERSION: Coarser is the reverse inclusion: T' is coarser than T when T'  T. **)
Definition coarser_than : set -> set -> prop := fun T' T => T' c= T.


(** from 12 Example 2: discrete topology **)
(** LATEX VERSION: Example 2 defines the discrete topology on X as the collection of all subsets of X. **)
Definition discrete_topology : set -> set := fun X => Power X.

(** from 12: indiscrete/trivial topology **)
(** LATEX VERSION: The indiscrete (trivial) topology on X consists only of X and . **)
Definition indiscrete_topology : set -> set := fun X => {Empty, X}.

(** from 12 Example 3: finite complement topology **)
(** LATEX VERSION: Example 3 defines T_f = { U  X | X\\U is finite or U =  }, the finite complement topology. **)
Definition finite_complement_topology : set -> set :=
  fun X => {U :e Power X | finite (X :\: U) \/ U = Empty}.

(** helper: countable set: admits an injection into omega (at most countable) **)
(** LATEX VERSION: A set is countable if it admits an injection into  (at most countable). **)
(** NOTE: `atleastp X omega` is used here in the sense there exists an injection from X into omega (cardinality at most omega). **)
Definition countable : set -> prop := fun X => atleastp X omega.

(** LATEX VERSION: Every finite set is countable. **)
Theorem finite_countable : forall X:set, finite X -> countable X.
let X. assume Hfin.
apply Hfin.
let n. assume Hpair: n :e omega /\ equip X n.
claim Hn : n :e omega.
{ exact (andEL (n :e omega) (equip X n) Hpair). }
claim Heq : equip X n.
{ exact (andER (n :e omega) (equip X n) Hpair). }
claim Hn_sub : n c= omega.
{ exact (omega_TransSet n Hn). }
claim Hcount_n : atleastp n omega.
{ exact (Subq_atleastp n omega Hn_sub). }
claim Hcount_X : atleastp X n.
{ exact (equip_atleastp X n Heq). }
exact (atleastp_tra X n omega Hcount_X Hcount_n).
Qed.

(** Helper: Empty is countable **)
Theorem countable_Empty : countable Empty.
exact (Subq_atleastp Empty omega (Subq_Empty omega)).
Qed.

(** Helper: Subset of countable set is countable **)
Theorem Subq_countable : forall X Y:set, countable Y -> X c= Y -> countable X.
let X Y. assume HcountY HsubXY.
prove atleastp X omega.
apply atleastp_tra X Y omega.
- exact (Subq_atleastp X Y HsubXY).
- exact HcountY.
Qed.

(** Helper: Union of two countable sets is countable **)
(** NOTE: This requires some form of choice or construction **)
Theorem binunion_countable : forall X Y:set, countable X -> countable Y -> countable (X :\/: Y).
let X Y.
assume HcountX: countable X.
assume HcountY: countable Y.
prove countable (X :\/: Y).
prove exists h : set -> set, inj (X :\/: Y) omega h.
apply HcountX.
let f : set -> set.
assume Hf: inj X omega f.
apply HcountY.
let g : set -> set.
assume Hg: inj Y omega g.
set h : set -> set := (fun u:set => if u :e X then nat_pair 0 (f u) else nat_pair 1 (g u)).
witness h.
prove inj (X :\/: Y) omega h.
apply (injI (X :\/: Y) omega h).
- (** h maps union into omega **)
  let u. assume Hu: u :e X :\/: Y.
  prove h u :e omega.
  claim HuXY: u :e X \/ u :e Y.
  { exact (binunionE X Y u Hu). }
  apply (xm (u :e X)).
  * assume HuX: u :e X.
    claim Hfmap: forall a :e X, f a :e omega.
    { exact (andEL (forall a :e X, f a :e omega)
                   (forall a b :e X, f a = f b -> a = b)
                   Hf). }
    claim Hu0: 0 :e omega.
    { exact (nat_p_omega 0 nat_0). }
    claim Hfu: f u :e omega.
    { exact (Hfmap u HuX). }
    claim Hp: nat_pair 0 (f u) :e omega.
    { exact (nat_pair_In_omega 0 Hu0 (f u) Hfu). }
	    claim Hhu_def: h u = if u :e X then nat_pair 0 (f u) else nat_pair 1 (g u).
	    { reflexivity. }
	    rewrite Hhu_def.
	    rewrite (If_i_1 (u :e X) (nat_pair 0 (f u)) (nat_pair 1 (g u)) HuX).
	    exact Hp.
  * assume HnotuX: ~(u :e X).
    claim Hug: u :e Y.
    { apply (HuXY (u :e Y)).
      - assume HuX: u :e X.
        apply FalseE.
        exact (HnotuX HuX).
      - assume HuY: u :e Y.
        exact HuY. }
    claim Hgmap: forall a :e Y, g a :e omega.
    { exact (andEL (forall a :e Y, g a :e omega)
                   (forall a b :e Y, g a = g b -> a = b)
                   Hg). }
    claim Hu1: 1 :e omega.
    { exact (nat_p_omega 1 nat_1). }
    claim Hgu: g u :e omega.
    { exact (Hgmap u Hug). }
    claim Hp: nat_pair 1 (g u) :e omega.
    { exact (nat_pair_In_omega 1 Hu1 (g u) Hgu). }
	    claim Hhu_def: h u = if u :e X then nat_pair 0 (f u) else nat_pair 1 (g u).
	    { reflexivity. }
	    rewrite Hhu_def.
	    rewrite (If_i_0 (u :e X) (nat_pair 0 (f u)) (nat_pair 1 (g u)) HnotuX).
	    exact Hp.
- (** h is injective on union **)
  let u. assume Hu: u :e X :\/: Y.
  let v. assume Hv: v :e X :\/: Y.
  assume Heq: h u = h v.
  prove u = v.
  claim HuXY: u :e X \/ u :e Y.
  { exact (binunionE X Y u Hu). }
  claim HvXY: v :e X \/ v :e Y.
  { exact (binunionE X Y v Hv). }
  claim Hfmap: forall a :e X, f a :e omega.
  { exact (andEL (forall a :e X, f a :e omega)
                 (forall a b :e X, f a = f b -> a = b)
                 Hf). }
  claim Hfinj: forall a b :e X, f a = f b -> a = b.
  { exact (andER (forall a :e X, f a :e omega)
                 (forall a b :e X, f a = f b -> a = b)
                 Hf). }
  claim Hgmap: forall a :e Y, g a :e omega.
  { exact (andEL (forall a :e Y, g a :e omega)
                 (forall a b :e Y, g a = g b -> a = b)
                 Hg). }
  claim Hginj: forall a b :e Y, g a = g b -> a = b.
  { exact (andER (forall a :e Y, g a :e omega)
                 (forall a b :e Y, g a = g b -> a = b)
                 Hg). }
  apply (xm (u :e X)).
  * assume HuX: u :e X.
    apply (xm (v :e X)).
    + assume HvX: v :e X.
      claim Hu0: 0 :e omega.
      { exact (nat_p_omega 0 nat_0). }
      claim Hfu: f u :e omega.
      { exact (Hfmap u HuX). }
      claim Hfv: f v :e omega.
      { exact (Hfmap v HvX). }
      claim Hhueq: h u = nat_pair 0 (f u).
      { claim Hhu_def: h u = if u :e X then nat_pair 0 (f u) else nat_pair 1 (g u).
        { reflexivity. }
        rewrite Hhu_def.
        rewrite (If_i_1 (u :e X) (nat_pair 0 (f u)) (nat_pair 1 (g u)) HuX).
        reflexivity. }
      claim Hhveq: h v = nat_pair 0 (f v).
      { claim Hhv_def: h v = if v :e X then nat_pair 0 (f v) else nat_pair 1 (g v).
        { reflexivity. }
        rewrite Hhv_def.
        rewrite (If_i_1 (v :e X) (nat_pair 0 (f v)) (nat_pair 1 (g v)) HvX).
        reflexivity. }
      claim Hpair: nat_pair 0 (f u) = nat_pair 0 (f v).
      { rewrite <- Hhueq.
        rewrite <- Hhveq.
        exact Heq. }
      claim HfuEq: f u = f v.
      { exact (nat_pair_1 0 Hu0 (f u) Hfu 0 Hu0 (f v) Hfv Hpair). }
      exact (Hfinj u HuX v HvX HfuEq).
    + assume HnotvX: ~(v :e X).
      claim HvY: v :e Y.
      { apply (HvXY (v :e Y)).
        - assume HvX: v :e X.
          apply FalseE.
          exact (HnotvX HvX).
        - assume HvY: v :e Y.
          exact HvY. }
      claim Hu0: 0 :e omega.
      { exact (nat_p_omega 0 nat_0). }
      claim Hu1: 1 :e omega.
      { exact (nat_p_omega 1 nat_1). }
      claim Hfu: f u :e omega.
      { exact (Hfmap u HuX). }
      claim Hgv: g v :e omega.
      { exact (Hgmap v HvY). }
      claim Hhueq: h u = nat_pair 0 (f u).
      { claim Hhu_def: h u = if u :e X then nat_pair 0 (f u) else nat_pair 1 (g u).
        { reflexivity. }
        rewrite Hhu_def.
        rewrite (If_i_1 (u :e X) (nat_pair 0 (f u)) (nat_pair 1 (g u)) HuX).
        reflexivity. }
      claim Hhveq: h v = nat_pair 1 (g v).
      { claim Hhv_def: h v = if v :e X then nat_pair 0 (f v) else nat_pair 1 (g v).
        { reflexivity. }
        rewrite Hhv_def.
        rewrite (If_i_0 (v :e X) (nat_pair 0 (f v)) (nat_pair 1 (g v)) HnotvX).
        reflexivity. }
      claim Hpair: nat_pair 0 (f u) = nat_pair 1 (g v).
      { rewrite <- Hhueq.
        rewrite <- Hhveq.
        exact Heq. }
      claim H01: 0 = 1.
      { exact (nat_pair_0 0 Hu0 (f u) Hfu 1 Hu1 (g v) Hgv Hpair). }
      apply FalseE.
      exact (neq_0_1 H01).
  * assume HnotuX: ~(u :e X).
    claim HuY: u :e Y.
    { apply (HuXY (u :e Y)).
      - assume HuX: u :e X.
        apply FalseE.
        exact (HnotuX HuX).
      - assume HuY: u :e Y.
        exact HuY. }
    apply (xm (v :e X)).
    + assume HvX: v :e X.
      claim Hu0: 0 :e omega.
      { exact (nat_p_omega 0 nat_0). }
      claim Hu1: 1 :e omega.
      { exact (nat_p_omega 1 nat_1). }
      claim Hfv: f v :e omega.
      { exact (Hfmap v HvX). }
      claim Hgu: g u :e omega.
      { exact (Hgmap u HuY). }
      claim Hhueq: h u = nat_pair 1 (g u).
      { claim Hhu_def: h u = if u :e X then nat_pair 0 (f u) else nat_pair 1 (g u).
        { reflexivity. }
        rewrite Hhu_def.
        rewrite (If_i_0 (u :e X) (nat_pair 0 (f u)) (nat_pair 1 (g u)) HnotuX).
        reflexivity. }
      claim Hhveq: h v = nat_pair 0 (f v).
      { claim Hhv_def: h v = if v :e X then nat_pair 0 (f v) else nat_pair 1 (g v).
        { reflexivity. }
        rewrite Hhv_def.
        rewrite (If_i_1 (v :e X) (nat_pair 0 (f v)) (nat_pair 1 (g v)) HvX).
        reflexivity. }
      claim Hpair: nat_pair 1 (g u) = nat_pair 0 (f v).
      { rewrite <- Hhueq.
        rewrite <- Hhveq.
        exact Heq. }
      claim H10: 1 = 0.
      { exact (nat_pair_0 1 Hu1 (g u) Hgu 0 Hu0 (f v) Hfv Hpair). }
      claim H01: 0 = 1.
      { symmetry. exact H10. }
      apply FalseE.
      exact (neq_0_1 H01).
    + assume HnotvX: ~(v :e X).
      claim HvY: v :e Y.
      { apply (HvXY (v :e Y)).
        - assume HvX: v :e X.
          apply FalseE.
          exact (HnotvX HvX).
        - assume HvY: v :e Y.
          exact HvY. }
      claim Hu1: 1 :e omega.
      { exact (nat_p_omega 1 nat_1). }
      claim Hgu: g u :e omega.
      { exact (Hgmap u HuY). }
      claim Hgv: g v :e omega.
      { exact (Hgmap v HvY). }
      claim Hhueq: h u = nat_pair 1 (g u).
      { claim Hhu_def: h u = if u :e X then nat_pair 0 (f u) else nat_pair 1 (g u).
        { reflexivity. }
        rewrite Hhu_def.
        rewrite (If_i_0 (u :e X) (nat_pair 0 (f u)) (nat_pair 1 (g u)) HnotuX).
        reflexivity. }
      claim Hhveq: h v = nat_pair 1 (g v).
      { claim Hhv_def: h v = if v :e X then nat_pair 0 (f v) else nat_pair 1 (g v).
        { reflexivity. }
        rewrite Hhv_def.
        rewrite (If_i_0 (v :e X) (nat_pair 0 (f v)) (nat_pair 1 (g v)) HnotvX).
        reflexivity. }
      claim Hpair: nat_pair 1 (g u) = nat_pair 1 (g v).
      { rewrite <- Hhueq.
        rewrite <- Hhveq.
        exact Heq. }
      claim HguEq: g u = g v.
      { exact (nat_pair_1 1 Hu1 (g u) Hgu 1 Hu1 (g v) Hgv Hpair). }
      exact (Hginj u HuY v HvY HguEq).
Qed.

(** Helper: dependent sum of countables is countable **)
(** LATEX VERSION: A countable union of countable sets is countable, encoded as a dependent sum with nat-pairing. **)
Theorem Sigma_countable : forall X:set, countable X ->
  forall Y:set->set, (forall x:set, x :e X -> countable (Y x)) ->
  countable (Sigma_ x :e X, Y x).
let X.
assume HX: countable X.
let Y.
assume HY: forall x:set, x :e X -> countable (Y x).
prove countable (Sigma_ x :e X, Y x).
prove exists h : set -> set, inj (Sigma_ x :e X, Y x) omega h.
apply HX.
let f : set -> set.
assume Hf: inj X omega f.
set graph : set -> (set -> set) -> set := fun A g => {(a, g a) | a :e A}.
set app : set -> set -> set := fun g a => Eps_i (fun n => (a,n) :e g).
set G : set -> set := fun x =>
  Eps_i (fun g => exists hx : set->set, inj (Y x) omega hx /\ g = graph (Y x) hx).
set h : set -> set := fun z =>
  nat_pair (f (proj0 z)) (app (G (proj0 z)) (proj1 z)).
witness h.

(** Helper: evaluating a graph built by Repl gives the original value **)
claim graph_app : forall A:set, forall g:set->set, forall a:set,
  a :e A -> app (graph A g) a = g a.
{ let A g a.
  assume Ha: a :e A.
  prove app (graph A g) a = g a.
  prove Eps_i (fun n => (a,n) :e graph A g) = g a.
  claim H1: (a, g a) :e graph A g.
  { exact (ReplI A (fun a0:set => (a0, g a0)) a Ha). }
  claim H2: (a, Eps_i (fun n => (a,n) :e graph A g)) :e graph A g.
  { exact (Eps_i_ax (fun n => (a,n) :e graph A g) (g a) H1). }
  apply (ReplE_impred A (fun a0:set => (a0, g a0)) (a, Eps_i (fun n => (a,n) :e graph A g)) H2).
  let a0.
  assume Ha0: a0 :e A.
  assume Heq: (a, Eps_i (fun n => (a,n) :e graph A g)) = (a0, g a0).
  claim Ha_eq: a = a0.
  { rewrite <- (tuple_2_0_eq a (Eps_i (fun n => (a,n) :e graph A g))).
    rewrite <- (tuple_2_0_eq a0 (g a0)).
    rewrite Heq.
    reflexivity. }
  claim Hn_eq: Eps_i (fun n => (a,n) :e graph A g) = g a0.
  { rewrite <- (tuple_2_1_eq a (Eps_i (fun n => (a,n) :e graph A g))) at 1.
    rewrite <- (tuple_2_1_eq a0 (g a0)) at 1.
    rewrite Heq.
    reflexivity. }
  rewrite Hn_eq.
  rewrite <- Ha_eq.
  reflexivity. }

(** Helper: graph evaluation under set equality **)
claim graph_app_eq : forall A:set, forall g:set->set, forall G0 a:set,
  a :e A -> G0 = graph A g -> app G0 a = g a.
{ let A g G0 a.
  assume Ha: a :e A.
  assume Heq: G0 = graph A g.
  prove app G0 a = g a.
  prove Eps_i (fun n => (a,n) :e G0) = g a.
  claim H1: (a, g a) :e G0.
  { rewrite Heq.
    exact (ReplI A (fun a0:set => (a0, g a0)) a Ha). }
  claim H2: (a, Eps_i (fun n => (a,n) :e G0)) :e G0.
  { exact (Eps_i_ax (fun n => (a,n) :e G0) (g a) H1). }
  claim H2g: (a, Eps_i (fun n => (a,n) :e G0)) :e graph A g.
  { rewrite <- Heq.
    exact H2. }
  apply (ReplE_impred A (fun a0:set => (a0, g a0)) (a, Eps_i (fun n => (a,n) :e G0)) H2g).
  let a0.
  assume Ha0: a0 :e A.
  assume Heq2: (a, Eps_i (fun n => (a,n) :e G0)) = (a0, g a0).
  claim Ha_eq: a = a0.
  { rewrite <- (tuple_2_0_eq a (Eps_i (fun n => (a,n) :e G0))).
    rewrite <- (tuple_2_0_eq a0 (g a0)).
    rewrite Heq2.
    reflexivity. }
  claim Hn_eq: Eps_i (fun n => (a,n) :e G0) = g a0.
  { rewrite <- (tuple_2_1_eq a (Eps_i (fun n => (a,n) :e G0))) at 1.
    rewrite <- (tuple_2_1_eq a0 (g a0)) at 1.
    rewrite Heq2.
    reflexivity. }
  rewrite Hn_eq.
  rewrite <- Ha_eq.
  reflexivity. }

apply (injI (Sigma_ x :e X, Y x) omega h).
- let z.
  assume Hz: z :e Sigma_ x :e X, Y x.
  prove h z :e omega.
  claim Hz0: proj0 z :e X.
  { exact (proj0_Sigma X Y z Hz). }
  claim Hz1: proj1 z :e Y (proj0 z).
  { exact (proj1_Sigma X Y z Hz). }
  claim Hfmap: forall a :e X, f a :e omega.
  { exact (andEL (forall a :e X, f a :e omega)
                 (forall a b :e X, f a = f b -> a = b)
                 Hf). }
  claim Hfz: f (proj0 z) :e omega.
  { exact (Hfmap (proj0 z) Hz0). }
  set x0 := proj0 z.
  claim HcountY: countable (Y x0).
  { exact (HY x0 Hz0). }
  apply HcountY.
  let hx : set->set.
  assume Hhx: inj (Y x0) omega hx.
  claim HPw: exists hx0 : set->set, inj (Y x0) omega hx0 /\ graph (Y x0) hx = graph (Y x0) hx0.
  { witness hx.
    apply andI.
    - exact Hhx.
    - reflexivity. }
  claim HGdef: G x0 = Eps_i (fun g => exists hx0 : set->set, inj (Y x0) omega hx0 /\ g = graph (Y x0) hx0).
  { reflexivity. }
  claim HQG: exists hx0 : set->set, inj (Y x0) omega hx0 /\ G x0 = graph (Y x0) hx0.
  { rewrite HGdef.
    exact (Eps_i_ax (fun g => exists hx0 : set->set, inj (Y x0) omega hx0 /\ g = graph (Y x0) hx0)
                    (graph (Y x0) hx)
                    HPw). }
  apply HQG.
  let hx0 : set->set.
  assume Hhx0pair.
  apply Hhx0pair.
  assume Hhx0 HGeq.
  claim Hhx0map: forall u :e Y x0, hx0 u :e omega.
  { exact (andEL (forall u :e Y x0, hx0 u :e omega)
                 (forall u v :e Y x0, hx0 u = hx0 v -> u = v)
                 Hhx0). }
  claim Hhy: hx0 (proj1 z) :e omega.
  { exact (Hhx0map (proj1 z) Hz1). }
  claim Happ: app (G x0) (proj1 z) = hx0 (proj1 z).
  { exact (graph_app_eq (Y x0) hx0 (G x0) (proj1 z) Hz1 HGeq). }
  claim Hhdef: h z = nat_pair (f (proj0 z)) (app (G (proj0 z)) (proj1 z)).
  { reflexivity. }
  rewrite Hhdef.
  rewrite Happ.
  exact (nat_pair_In_omega (f (proj0 z)) Hfz (hx0 (proj1 z)) Hhy).
- let z1.
  assume Hz1: z1 :e Sigma_ x :e X, Y x.
  let z2.
  assume Hz2: z2 :e Sigma_ x :e X, Y x.
  assume Heq: h z1 = h z2.
  prove z1 = z2.
  claim Hz10: proj0 z1 :e X.
  { exact (proj0_Sigma X Y z1 Hz1). }
  claim Hz20: proj0 z2 :e X.
  { exact (proj0_Sigma X Y z2 Hz2). }
  claim Hz11: proj1 z1 :e Y (proj0 z1).
  { exact (proj1_Sigma X Y z1 Hz1). }
  claim Hz21: proj1 z2 :e Y (proj0 z2).
  { exact (proj1_Sigma X Y z2 Hz2). }
  claim Hfmap: forall a :e X, f a :e omega.
  { exact (andEL (forall a :e X, f a :e omega)
                 (forall a b :e X, f a = f b -> a = b)
                 Hf). }
  claim Hfinj: forall a b :e X, f a = f b -> a = b.
  { exact (andER (forall a :e X, f a :e omega)
                 (forall a b :e X, f a = f b -> a = b)
                 Hf). }
  claim Hfz1: f (proj0 z1) :e omega.
  { exact (Hfmap (proj0 z1) Hz10). }
  claim Hfz2: f (proj0 z2) :e omega.
  { exact (Hfmap (proj0 z2) Hz20). }
  claim Hhy1: app (G (proj0 z1)) (proj1 z1) :e omega.
  { set x1 := proj0 z1.
    claim HcountY: countable (Y x1).
    { exact (HY x1 Hz10). }
    apply HcountY.
    let hx : set->set.
    assume Hhx: inj (Y x1) omega hx.
    claim HPw: exists hx0 : set->set, inj (Y x1) omega hx0 /\ graph (Y x1) hx = graph (Y x1) hx0.
    { witness hx.
      apply andI.
      - exact Hhx.
      - reflexivity. }
    claim HGdef: G x1 = Eps_i (fun g => exists hx0 : set->set, inj (Y x1) omega hx0 /\ g = graph (Y x1) hx0).
    { reflexivity. }
    claim HQG: exists hx0 : set->set, inj (Y x1) omega hx0 /\ G x1 = graph (Y x1) hx0.
	    { rewrite HGdef.
	      exact (Eps_i_ax (fun g => exists hx0 : set->set, inj (Y x1) omega hx0 /\ g = graph (Y x1) hx0)
	                      (graph (Y x1) hx)
	                      HPw). }
	    apply HQG.
	    let hx0 : set->set.
	    assume Hhx0pair.
	    apply Hhx0pair.
	    assume Hhx0 HGeq.
	    claim Hhx0map: forall u :e Y x1, hx0 u :e omega.
	    { exact (andEL (forall u :e Y x1, hx0 u :e omega)
	                   (forall u v :e Y x1, hx0 u = hx0 v -> u = v)
	                   Hhx0). }
	    claim Hhy: hx0 (proj1 z1) :e omega.
	    { exact (Hhx0map (proj1 z1) Hz11). }
	    claim Happ: app (G x1) (proj1 z1) = hx0 (proj1 z1).
	    { exact (graph_app_eq (Y x1) hx0 (G x1) (proj1 z1) Hz11 HGeq). }
	    rewrite Happ.
	    exact Hhy. }
  claim Hhy2: app (G (proj0 z2)) (proj1 z2) :e omega.
  { set x2 := proj0 z2.
    claim HcountY: countable (Y x2).
    { exact (HY x2 Hz20). }
	    apply HcountY.
	    let hx : set->set.
	    assume Hhx: inj (Y x2) omega hx.
	    claim HPw: exists hx0 : set->set, inj (Y x2) omega hx0 /\ graph (Y x2) hx = graph (Y x2) hx0.
	    { witness hx.
	      apply andI.
	      - exact Hhx.
	      - reflexivity. }
	    claim HGdef: G x2 = Eps_i (fun g => exists hx0 : set->set, inj (Y x2) omega hx0 /\ g = graph (Y x2) hx0).
	    { reflexivity. }
	    claim HQG: exists hx0 : set->set, inj (Y x2) omega hx0 /\ G x2 = graph (Y x2) hx0.
		    { rewrite HGdef.
		      exact (Eps_i_ax (fun g => exists hx0 : set->set, inj (Y x2) omega hx0 /\ g = graph (Y x2) hx0)
		                      (graph (Y x2) hx)
		                      HPw). }
		    apply HQG.
		    let hx0 : set->set.
		    assume Hhx0pair.
		    apply Hhx0pair.
		    assume Hhx0 HGeq.
	    claim Hhx0map: forall u :e Y x2, hx0 u :e omega.
	    { exact (andEL (forall u :e Y x2, hx0 u :e omega)
	                   (forall u v :e Y x2, hx0 u = hx0 v -> u = v)
	                   Hhx0). }
	    claim Hhy: hx0 (proj1 z2) :e omega.
	    { exact (Hhx0map (proj1 z2) Hz21). }
	    claim Happ: app (G x2) (proj1 z2) = hx0 (proj1 z2).
	    { exact (graph_app_eq (Y x2) hx0 (G x2) (proj1 z2) Hz21 HGeq). }
	    rewrite Happ.
	    exact Hhy. }
  claim Hhdef1: h z1 = nat_pair (f (proj0 z1)) (app (G (proj0 z1)) (proj1 z1)).
  { reflexivity. }
  claim Hhdef2: h z2 = nat_pair (f (proj0 z2)) (app (G (proj0 z2)) (proj1 z2)).
  { reflexivity. }
  claim Hpair: nat_pair (f (proj0 z1)) (app (G (proj0 z1)) (proj1 z1))
              = nat_pair (f (proj0 z2)) (app (G (proj0 z2)) (proj1 z2)).
  { rewrite <- Hhdef1.
    rewrite <- Hhdef2.
    exact Heq. }
  claim Hxeq: proj0 z1 = proj0 z2.
  { claim Hf0: f (proj0 z1) = f (proj0 z2).
    { exact (nat_pair_0 (f (proj0 z1)) Hfz1 (app (G (proj0 z1)) (proj1 z1)) Hhy1
                        (f (proj0 z2)) Hfz2 (app (G (proj0 z2)) (proj1 z2)) Hhy2
                        Hpair). }
    exact (Hfinj (proj0 z1) Hz10 (proj0 z2) Hz20 Hf0). }
  set x := proj0 z1.
  claim HxX: x :e X.
  { exact Hz10. }
  claim Hz2x: proj0 z2 = x.
  { symmetry. exact Hxeq. }
  claim Hy21': proj1 z2 :e Y x.
  { rewrite <- Hz2x.
    exact Hz21. }
  claim Hy11': proj1 z1 :e Y x.
  { claim Hxdef: x = proj0 z1.
    { reflexivity. }
    rewrite Hxdef.
    exact Hz11. }
  claim HcountY: countable (Y x).
  { exact (HY x HxX). }
  apply HcountY.
  let hx : set->set.
  assume Hhx: inj (Y x) omega hx.
  claim HPw: exists hx0 : set->set, inj (Y x) omega hx0 /\ graph (Y x) hx = graph (Y x) hx0.
  { witness hx.
    apply andI.
    - exact Hhx.
    - reflexivity. }
  claim HGdef: G x = Eps_i (fun g => exists hx0 : set->set, inj (Y x) omega hx0 /\ g = graph (Y x) hx0).
  { reflexivity. }
  claim HQG: exists hx0 : set->set, inj (Y x) omega hx0 /\ G x = graph (Y x) hx0.
  { rewrite HGdef.
    exact (Eps_i_ax (fun g => exists hx0 : set->set, inj (Y x) omega hx0 /\ g = graph (Y x) hx0)
                    (graph (Y x) hx)
                    HPw). }
  apply HQG.
  let hx0 : set->set.
  assume Hhx0pair.
  apply Hhx0pair.
  assume Hhx0 HGeq.
  claim Hhx0inj: forall u v :e Y x, hx0 u = hx0 v -> u = v.
  { exact (andER (forall u :e Y x, hx0 u :e omega)
                 (forall u v :e Y x, hx0 u = hx0 v -> u = v)
                 Hhx0). }
  claim Happ1: app (G x) (proj1 z1) = hx0 (proj1 z1).
  { exact (graph_app_eq (Y x) hx0 (G x) (proj1 z1) Hy11' HGeq). }
  claim Happ2: app (G x) (proj1 z2) = hx0 (proj1 z2).
  { exact (graph_app_eq (Y x) hx0 (G x) (proj1 z2) Hy21' HGeq). }
  claim Hn_eq: app (G x) (proj1 z1) = app (G x) (proj1 z2).
  { claim Hn0: app (G (proj0 z1)) (proj1 z1) = app (G (proj0 z2)) (proj1 z2).
    { exact (nat_pair_1 (f (proj0 z1)) Hfz1 (app (G (proj0 z1)) (proj1 z1)) Hhy1
                        (f (proj0 z2)) Hfz2 (app (G (proj0 z2)) (proj1 z2)) Hhy2
                        Hpair). }
    claim Hxdef: x = proj0 z1.
    { reflexivity. }
    rewrite Hxdef.
    rewrite Hxeq at 2.
    exact Hn0. }
  claim Hhx0eq: hx0 (proj1 z1) = hx0 (proj1 z2).
  { rewrite <- Happ1.
    rewrite <- Happ2.
    exact Hn_eq. }
  claim Hyeq: proj1 z1 = proj1 z2.
  { exact (Hhx0inj (proj1 z1) Hy11' (proj1 z2) Hy21' Hhx0eq). }
  apply (Sigma_eta_proj0_proj1 X Y z1 Hz1).
  assume Heta1core Heta1Y.
  apply Heta1core.
  assume Heta1 Heta1X.
  apply (Sigma_eta_proj0_proj1 X Y z2 Hz2).
  assume Heta2core Heta2Y.
  apply Heta2core.
  assume Heta2 Heta2X.
  rewrite <- Heta1.
  rewrite <- Heta2.
  rewrite Hxeq.
  rewrite Hyeq.
  reflexivity.
Qed.

(** Helper: product of two countable sets is countable **)
(** LATEX VERSION: If X and Y are countable then XY is countable via nat-pairing of injections. **)
Theorem setprod_countable : forall X Y:set, countable X -> countable Y -> countable (X :*: Y).
let X Y.
assume HX: countable X.
assume HY: countable Y.
prove countable (X :*: Y).
prove exists h : set -> set, inj (X :*: Y) omega h.
apply HX.
let f : set -> set.
assume Hf: inj X omega f.
apply HY.
let g : set -> set.
assume Hg: inj Y omega g.
set Yc : set -> set := fun _ => Y.
set h : set -> set := fun z => nat_pair (f (proj0 z)) (g (proj1 z)).
witness h.
apply (injI (X :*: Y) omega h).
- let z. assume Hz: z :e X :*: Y.
  prove h z :e omega.
  claim Hz0: proj0 z :e X.
  { exact (proj0_Sigma X Yc z Hz). }
  claim Hz1: proj1 z :e Y.
  { exact (proj1_Sigma X Yc z Hz). }
  claim Hfmap: forall a :e X, f a :e omega.
  { exact (andEL (forall a :e X, f a :e omega)
                 (forall a b :e X, f a = f b -> a = b)
                 Hf). }
  claim Hgmap: forall b :e Y, g b :e omega.
  { exact (andEL (forall b :e Y, g b :e omega)
                 (forall b1 b2 :e Y, g b1 = g b2 -> b1 = b2)
                 Hg). }
  claim Hfz: f (proj0 z) :e omega.
  { exact (Hfmap (proj0 z) Hz0). }
  claim Hgz: g (proj1 z) :e omega.
  { exact (Hgmap (proj1 z) Hz1). }
  claim Hhdef: h z = nat_pair (f (proj0 z)) (g (proj1 z)).
  { reflexivity. }
  rewrite Hhdef.
  exact (nat_pair_In_omega (f (proj0 z)) Hfz (g (proj1 z)) Hgz).
- let z1. assume Hz1: z1 :e X :*: Y.
  let z2. assume Hz2: z2 :e X :*: Y.
  assume Hhz: h z1 = h z2.
  prove z1 = z2.
  apply (Sigma_E X Yc z1 Hz1).
  let x1. assume Hx1pair.
  apply Hx1pair.
  assume Hx1X Hexy1.
  apply Hexy1.
  let y1. assume Hy1pair.
  apply Hy1pair.
  assume Hy1Y Hz1eq.
  apply (Sigma_E X Yc z2 Hz2).
  let x2. assume Hx2pair.
  apply Hx2pair.
  assume Hx2X Hexy2.
  apply Hexy2.
  let y2. assume Hy2pair.
  apply Hy2pair.
  assume Hy2Y Hz2eq.
  claim Hfmap: forall a :e X, f a :e omega.
  { exact (andEL (forall a :e X, f a :e omega)
                 (forall a b :e X, f a = f b -> a = b)
                 Hf). }
  claim Hgmap: forall b :e Y, g b :e omega.
  { exact (andEL (forall b :e Y, g b :e omega)
                 (forall b1 b2 :e Y, g b1 = g b2 -> b1 = b2)
                 Hg). }
  claim Hfinj: forall a b :e X, f a = f b -> a = b.
  { exact (andER (forall a :e X, f a :e omega)
                 (forall a b :e X, f a = f b -> a = b)
                 Hf). }
  claim Hginj: forall b1 b2 :e Y, g b1 = g b2 -> b1 = b2.
  { exact (andER (forall b :e Y, g b :e omega)
                 (forall b1 b2 :e Y, g b1 = g b2 -> b1 = b2)
                 Hg). }
	  claim Hproj01: proj0 z1 = x1.
	  { rewrite (proj0_ap_0 z1).
	    rewrite Hz1eq.
	    exact (pair_ap_0 x1 y1). }
	  claim Hproj11: proj1 z1 = y1.
	  { rewrite (proj1_ap_1 z1).
	    rewrite Hz1eq.
	    exact (pair_ap_1 x1 y1). }
	  claim Hproj02: proj0 z2 = x2.
	  { rewrite (proj0_ap_0 z2).
	    rewrite Hz2eq.
	    exact (pair_ap_0 x2 y2). }
	  claim Hproj12: proj1 z2 = y2.
	  { rewrite (proj1_ap_1 z2).
	    rewrite Hz2eq.
	    exact (pair_ap_1 x2 y2). }
  claim Hh1: h z1 = nat_pair (f x1) (g y1).
  { claim Hhdef: h z1 = nat_pair (f (proj0 z1)) (g (proj1 z1)).
    { reflexivity. }
    rewrite Hhdef.
    rewrite Hproj01.
    rewrite Hproj11.
    reflexivity. }
  claim Hh2: h z2 = nat_pair (f x2) (g y2).
  { claim Hhdef: h z2 = nat_pair (f (proj0 z2)) (g (proj1 z2)).
    { reflexivity. }
    rewrite Hhdef.
    rewrite Hproj02.
    rewrite Hproj12.
    reflexivity. }
  claim Hpair: nat_pair (f x1) (g y1) = nat_pair (f x2) (g y2).
  { rewrite <- Hh1. rewrite <- Hh2. exact Hhz. }
  claim Hf1: f x1 :e omega.
  { exact (Hfmap x1 Hx1X). }
  claim Hf2: f x2 :e omega.
  { exact (Hfmap x2 Hx2X). }
  claim Hg1: g y1 :e omega.
  { exact (Hgmap y1 Hy1Y). }
  claim Hg2: g y2 :e omega.
  { exact (Hgmap y2 Hy2Y). }
  claim Heqf: f x1 = f x2.
  { exact (nat_pair_0 (f x1) Hf1 (g y1) Hg1
                      (f x2) Hf2 (g y2) Hg2
                      Hpair). }
  claim Heqx: x1 = x2.
  { exact (Hfinj x1 Hx1X x2 Hx2X Heqf). }
  claim Heqg: g y1 = g y2.
  { exact (nat_pair_1 (f x1) Hf1 (g y1) Hg1
                      (f x2) Hf2 (g y2) Hg2
                      Hpair). }
	  claim Heqy: y1 = y2.
	  { exact (Hginj y1 Hy1Y y2 Hy2Y Heqg). }
  rewrite Hz1eq.
  rewrite Hz2eq.
  rewrite Heqx.
  rewrite Heqy.
  reflexivity.
Qed.

(** Helper: Union of a family preserves Power set membership **)
Theorem Union_Power : forall X Fam:set,
  Fam c= Power X -> Union Fam c= X.
let X Fam.
assume HFam: Fam c= Power X.
prove Union Fam c= X.
let x. assume Hx: x :e Union Fam.
prove x :e X.
apply (UnionE_impred Fam x Hx).
let U. assume HxU: x :e U. assume HU: U :e Fam.
claim HUPower: U :e Power X.
{ exact (HFam U HU). }
claim HUsub: U c= X.
{ exact (PowerE X U HUPower). }
exact (HUsub x HxU).
Qed.

(** Helper: Binary intersection of Power set members is in Power set **)
Theorem binintersect_Power : forall X U V:set,
  U :e Power X -> V :e Power X -> U :/\: V :e Power X.
let X U V.
assume HU: U :e Power X.
assume HV: V :e Power X.
prove U :/\: V :e Power X.
apply PowerI.
let x. assume Hx: x :e U :/\: V.
prove x :e X.
claim HxU: x :e U.
{ exact (binintersectE1 U V x Hx). }
claim HUsub: U c= X.
{ exact (PowerE X U HU). }
exact (HUsub x HxU).
Qed.

(** Helper: Setminus with subset is in Power set **)
Theorem setminus_Power : forall X U:set,
  U :e Power X -> X :\: U :e Power X.
let X U.
assume HU: U :e Power X.
prove X :\: U :e Power X.
apply PowerI.
let x. assume Hx: x :e X :\: U.
prove x :e X.
exact (setminusE1 X U x Hx).
Qed.

(** from 12 Example 4: countable complement topology **)
(** LATEX VERSION: Example 4 defines T_c = { U  X | X\\U is countable or U =  }, the countable complement topology. **)
Definition countable_complement_topology : set -> set :=
  fun X => {U :e Power X | countable (X :\: U) \/ U = Empty}.

(** from 12 Example 4: countable complement topology is a topology **)
(** LATEX VERSION: The countable complement collection T_c on X is a topology: , X are open; arbitrary unions and finite intersections remain in T_c. **)
Theorem countable_complement_topology_on : forall X, topology_on X (countable_complement_topology X).
let X.
claim HEmptyOpen : Empty :e countable_complement_topology X.
{ exact (SepI (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty)
              Empty (Empty_In_Power X)
              (orIR (countable (X :\: Empty)) (Empty = Empty) (fun P H => H))). }
prove countable_complement_topology X c= Power X
/\ Empty :e countable_complement_topology X
/\ X :e countable_complement_topology X
/\ (forall UFam :e Power (countable_complement_topology X), Union UFam :e countable_complement_topology X)
/\ (forall U :e countable_complement_topology X, forall V :e countable_complement_topology X, U :/\: V :e countable_complement_topology X).
apply andI.
- prove (countable_complement_topology X c= Power X /\ Empty :e countable_complement_topology X) /\ X :e countable_complement_topology X /\ (forall UFam :e Power (countable_complement_topology X), Union UFam :e countable_complement_topology X).
  apply andI.
  * prove countable_complement_topology X c= Power X /\ Empty :e countable_complement_topology X /\ X :e countable_complement_topology X.
    apply andI.
    { prove countable_complement_topology X c= Power X /\ Empty :e countable_complement_topology X.
      apply andI.
      - let U. assume HU: U :e countable_complement_topology X.
        exact (SepE1 (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty) U HU).
      - exact HEmptyOpen.
    }
    { claim Hdiff_empty : X :\: X = Empty.
      { apply Empty_Subq_eq.
        let x. assume Hx.
        claim HxX : x :e X.
        { exact (setminusE1 X X x Hx). }
        claim Hxnot : x /:e X.
        { exact (setminusE2 X X x Hx). }
        apply FalseE.
        exact (Hxnot HxX).
      }
      claim HcountDiff : countable (X :\: X).
      { rewrite Hdiff_empty. exact countable_Empty. }
      exact (SepI (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty)
                  X (Self_In_Power X)
                  (orIL (countable (X :\: X)) (X = Empty) HcountDiff)).
    }
  * prove forall UFam :e Power (countable_complement_topology X), Union UFam :e countable_complement_topology X.
    let UFam. assume Hfam: UFam :e Power (countable_complement_topology X).
    claim Hsub : UFam c= countable_complement_topology X.
    { exact (PowerE (countable_complement_topology X) UFam Hfam). }
    apply xm (exists U:set, U :e UFam /\ countable (X :\: U)).
    - assume Hex: exists U:set, U :e UFam /\ countable (X :\: U).
      claim HUnionInPower : Union UFam :e Power X.
      { apply PowerI X (Union UFam).
        let x. assume HxUnion.
        apply UnionE_impred UFam x HxUnion.
        let U. assume HxU HUin.
        claim HUinPow : U :e Power X.
        { exact (SepE1 (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty) U (Hsub U HUin)). }
        claim HUsubX : U c= X.
        { exact (PowerE X U HUinPow). }
        exact (HUsubX x HxU).
      }
      claim HUnionPred : countable (X :\: Union UFam) \/ Union UFam = Empty.
      { apply orIL.
        apply Hex.
        let U. assume HUdata. apply HUdata.
        assume HUin.
        assume HUcount.
        prove countable (X :\: Union UFam).
        claim Hsubset : X :\: Union UFam c= X :\: U.
        { let x. assume Hx.
          claim HxX : x :e X.
          { exact (setminusE1 X (Union UFam) x Hx). }
          claim HnotUnion : x /:e Union UFam.
          { exact (setminusE2 X (Union UFam) x Hx). }
          claim HnotU : x /:e U.
          { assume HxU.
            apply HnotUnion.
            exact (UnionI UFam x U HxU HUin).
          }
          apply setminusI.
          - exact HxX.
          - exact HnotU.
        }
        exact (Subq_countable (X :\: Union UFam) (X :\: U) HUcount Hsubset).
      }
      exact (SepI (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty)
                  (Union UFam) HUnionInPower HUnionPred).
    - assume Hnone: ~exists U:set, U :e UFam /\ countable (X :\: U).
      claim HUnionEmpty : Union UFam = Empty.
      { apply Empty_Subq_eq.
        let x. assume HxUnion.
        apply UnionE_impred UFam x HxUnion.
        let U. assume HxU HUin.
        claim HUdata : countable (X :\: U) \/ U = Empty.
        { exact (SepE2 (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty) U (Hsub U HUin)). }
        apply HUdata (x :e Empty).
        - assume HUcount.
          apply FalseE.
          apply Hnone.
          witness U.
          apply andI.
          + exact HUin.
          + exact HUcount.
        - assume HUempty : U = Empty.
          rewrite <- HUempty.
          exact HxU.
      }
      rewrite HUnionEmpty.
      exact HEmptyOpen.
- prove forall U :e countable_complement_topology X, forall V :e countable_complement_topology X, U :/\: V :e countable_complement_topology X.
  let U. assume HU: U :e countable_complement_topology X.
  let V. assume HV: V :e countable_complement_topology X.
  claim HUdata : countable (X :\: U) \/ U = Empty.
  { exact (SepE2 (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty) U HU). }
  claim HVdata : countable (X :\: V) \/ V = Empty.
  { exact (SepE2 (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty) V HV). }
  apply HUdata (U :/\: V :e countable_complement_topology X).
  * assume HUcount.
    apply HVdata (U :/\: V :e countable_complement_topology X).
    { assume HVcount.
      claim HcapInPower : U :/\: V :e Power X.
      { claim HUsub : U c= X.
        { exact (PowerE X U (SepE1 (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty) U HU)). }
        apply PowerI X (U :/\: V).
        let x. assume HxCap.
        apply binintersectE U V x HxCap.
        assume HxU HxV.
        exact (HUsub x HxU).
      }
      claim HcapPred : countable (X :\: (U :/\: V)) \/ U :/\: V = Empty.
      { apply orIL.
        claim HcountUnion : countable ((X :\: U) :\/: (X :\: V)).
        { exact (binunion_countable (X :\: U) (X :\: V) HUcount HVcount). }
        claim Hsubset : X :\: (U :/\: V) c= (X :\: U) :\/: (X :\: V).
        { let x. assume Hx.
          claim HxX : x :e X.
          { exact (setminusE1 X (U :/\: V) x Hx). }
          claim HnotCap : x /:e U :/\: V.
          { exact (setminusE2 X (U :/\: V) x Hx). }
          apply xm (x :e U).
          - assume HxU.
            claim HnotV : x /:e V.
            { assume HxV.
              apply HnotCap.
              exact (binintersectI U V x HxU HxV).
            }
            apply binunionI2 (X :\: U) (X :\: V).
            apply setminusI X V x HxX HnotV.
          - assume HnotU.
            apply binunionI1 (X :\: U) (X :\: V).
            apply setminusI X U x HxX HnotU.
        }
        exact (Subq_countable (X :\: (U :/\: V)) ((X :\: U) :\/: (X :\: V)) HcountUnion Hsubset).
      }
      exact (SepI (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty)
                  (U :/\: V) HcapInPower HcapPred).
    }
    { assume HVempty : V = Empty.
      claim Hcap_empty : U :/\: V = Empty.
      { rewrite HVempty.
        apply Empty_Subq_eq.
        exact (binintersect_Subq_2 U Empty).
      }
      rewrite Hcap_empty.
      exact HEmptyOpen.
    }
  * assume HUempty : U = Empty.
    claim Hcap_empty : U :/\: V = Empty.
    { rewrite HUempty.
      apply Empty_Subq_eq.
      exact (binintersect_Subq_1 Empty V).
    }
    rewrite Hcap_empty.
    exact HEmptyOpen.
Qed.

(** from 12: discrete topology is a topology **)
(** LATEX VERSION: The discrete topology on any set X satisfies the axioms of a topology. **)
Theorem discrete_topology_on : forall X, topology_on X (discrete_topology X).
let X.
prove Power X c= Power X
/\ Empty :e Power X
/\ X :e Power X
/\ (forall UFam :e Power (Power X), Union UFam :e Power X)
/\ (forall U :e Power X, forall V :e Power X, U :/\: V :e Power X).
apply andI.
- prove ((Power X c= Power X /\ Empty :e Power X) /\ X :e Power X /\ (forall UFam :e Power (Power X), Union UFam :e Power X)).
  apply andI.
  * prove Power X c= Power X /\ Empty :e Power X /\ X :e Power X.
    apply andI.
    { prove Power X c= Power X /\ Empty :e Power X.
      apply andI.
      - exact (Subq_ref (Power X)).
      - apply Empty_In_Power.
    }
    { apply PowerI. exact (Subq_ref X). }
  * prove forall UFam :e Power (Power X), Union UFam :e Power X.
    let UFam. assume Hfam: UFam :e Power (Power X).
    apply PowerI X (Union UFam).
    let x. assume HxUnion: x :e Union UFam.
    apply UnionE_impred UFam x HxUnion.
    let U. assume HUinx: x :e U. assume HUinFam: U :e UFam.
    claim HFamSub: UFam c= Power X.
    { exact (iffEL (UFam :e Power (Power X)) (UFam c= Power X) (PowerEq (Power X) UFam) Hfam). }
    claim HUinPower: U :e Power X.
    { exact HFamSub U HUinFam. }
    claim HUsub : U c= X.
    { exact (iffEL (U :e Power X) (U c= X) (PowerEq X U) HUinPower). }
    exact (HUsub x HUinx).
- prove forall U :e Power X, forall V :e Power X, U :/\: V :e Power X.
  let U. assume HU: U :e Power X.
  let V. assume HV: V :e Power X.
  apply PowerI X (U :/\: V).
  let x. assume Hxcap: x :e U :/\: V.
  apply binintersectE U V x Hxcap.
  assume HxU HxV.
  claim HUsub: U c= X.
  { exact (iffEL (U :e Power X) (U c= X) (PowerEq X U) HU). }
  exact (HUsub x HxU).
Qed.

(** from 12: indiscrete topology is a topology **)
(** LATEX VERSION: The trivial/indiscrete topology {, X} on any set X satisfies the topology axioms. **)
Theorem indiscrete_topology_on : forall X, topology_on X (indiscrete_topology X).
let X.
prove indiscrete_topology X c= Power X
/\ Empty :e indiscrete_topology X
/\ X :e indiscrete_topology X
/\ (forall UFam :e Power (indiscrete_topology X), Union UFam :e indiscrete_topology X)
/\ (forall U :e indiscrete_topology X, forall V :e indiscrete_topology X, U :/\: V :e indiscrete_topology X).
apply andI.
- prove (indiscrete_topology X c= Power X /\ Empty :e indiscrete_topology X) /\ X :e indiscrete_topology X /\ (forall UFam :e Power (indiscrete_topology X), Union UFam :e indiscrete_topology X).
  apply andI.
  * prove indiscrete_topology X c= Power X /\ Empty :e indiscrete_topology X /\ X :e indiscrete_topology X.
    apply andI.
    { prove indiscrete_topology X c= Power X /\ Empty :e indiscrete_topology X.
      apply andI.
      - let U. assume HU: U :e indiscrete_topology X.
        apply UPairE U Empty X HU.
        + assume HUe: U = Empty. rewrite HUe. exact (Empty_In_Power X).
        + assume HUX: U = X. rewrite HUX. exact (Self_In_Power X).
      - exact (UPairI1 Empty X).
    }
    { exact (UPairI2 Empty X). }
  * prove forall UFam :e Power (indiscrete_topology X), Union UFam :e indiscrete_topology X.
    let UFam. assume Hfam: UFam :e Power (indiscrete_topology X).
    claim Hsub : UFam c= indiscrete_topology X.
    { exact (PowerE (indiscrete_topology X) UFam Hfam). }
    apply xm (exists U:set, U :e UFam /\ U = X).
    - assume Hex: exists U:set, U :e UFam /\ U = X.
      claim HUnion_sub : Union UFam c= X.
      { let x. assume HxUnion.
        apply UnionE_impred UFam x HxUnion.
        let U. assume HxU HUin.
        claim HUtop : U :e indiscrete_topology X.
        { exact (Hsub U HUin). }
        apply UPairE U Empty X HUtop.
        - assume HUe: U = Empty.
          claim HxEmpty : x :e Empty.
          { rewrite <- HUe. exact HxU. }
          exact (EmptyE x HxEmpty (x :e X)).
        - assume HUX: U = X.
          rewrite <- HUX.
          exact HxU.
      }
      claim HX_sub : X c= Union UFam.
      { let x. assume HxX.
        apply Hex.
        let U. assume HUinpair : U :e UFam /\ U = X.
        claim HUin : U :e UFam.
        { exact (andEL (U :e UFam) (U = X) HUinpair). }
        claim HUeq : U = X.
        { exact (andER (U :e UFam) (U = X) HUinpair). }
        claim HxU : x :e U.
        { rewrite HUeq. exact HxX. }
        apply UnionI UFam x U HxU HUin.
      }
      claim HUnion_eq : Union UFam = X.
      { apply set_ext.
        - exact HUnion_sub.
        - exact HX_sub.
      }
      rewrite HUnion_eq.
      exact (UPairI2 Empty X).
    - assume Hnone: ~exists U:set, U :e UFam /\ U = X.
      claim HUnion_empty : Union UFam = Empty.
      { apply Empty_Subq_eq.
        let x. assume HxUnion.
        apply UnionE_impred UFam x HxUnion.
        let U. assume HxU HUin.
        claim HUtop : U :e indiscrete_topology X.
        { exact (Hsub U HUin). }
        apply UPairE U Empty X HUtop.
        - assume HUe: U = Empty.
          claim HxEmpty : x :e Empty.
          { rewrite <- HUe. exact HxU. }
          exact HxEmpty.
        - assume HUX: U = X.
          apply FalseE.
          apply Hnone.
          witness U.
          apply andI.
          + exact HUin.
          + exact HUX.
      }
      rewrite HUnion_empty. exact (UPairI1 Empty X).
- prove forall U :e indiscrete_topology X, forall V :e indiscrete_topology X, U :/\: V :e indiscrete_topology X.
  let U. assume HU: U :e indiscrete_topology X.
  let V. assume HV: V :e indiscrete_topology X.
  apply UPairE U Empty X HU.
  * assume HUe: U = Empty.
    claim Hcap : U :/\: V = Empty.
    { rewrite HUe.
      apply Empty_Subq_eq.
      exact (binintersect_Subq_1 Empty V).
    }
    rewrite Hcap. exact (UPairI1 Empty X).
  * assume HUX: U = X.
    apply UPairE V Empty X HV.
    { assume HVe: V = Empty.
      claim Hcap : U :/\: V = Empty.
      { rewrite HVe.
        apply Empty_Subq_eq.
        exact (binintersect_Subq_2 U Empty).
      }
      rewrite Hcap. exact (UPairI1 Empty X).
    }
    { assume HVX: V = X.
      claim Hcap : U :/\: V = X.
      { apply set_ext.
        - rewrite HUX. rewrite HVX. exact (binintersect_Subq_1 X X).
        - let x. assume HxX.
          rewrite HUX. rewrite HVX.
          exact (binintersectI X X x HxX HxX).
      }
      rewrite Hcap. exact (UPairI2 Empty X).
    }
Qed.

(** from 12 Example 3: finite complement topology is a topology **)
(** LATEX VERSION: The finite complement collection T_f on X is a topology: , X are open; arbitrary unions and finite intersections remain in T_f. **)
Theorem finite_complement_topology_on : forall X, topology_on X (finite_complement_topology X).
let X.
claim HEmptyOpen : Empty :e finite_complement_topology X.
{ exact (SepI (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) Empty (Empty_In_Power X) (orIR (finite (X :\: Empty)) (Empty = Empty) (fun P H => H))). }
prove finite_complement_topology X c= Power X
/\ Empty :e finite_complement_topology X
/\ X :e finite_complement_topology X
/\ (forall UFam :e Power (finite_complement_topology X), Union UFam :e finite_complement_topology X)
/\ (forall U :e finite_complement_topology X, forall V :e finite_complement_topology X, U :/\: V :e finite_complement_topology X).
apply andI.
- prove (finite_complement_topology X c= Power X /\ Empty :e finite_complement_topology X) /\ X :e finite_complement_topology X /\ (forall UFam :e Power (finite_complement_topology X), Union UFam :e finite_complement_topology X).
  apply andI.
  * prove finite_complement_topology X c= Power X /\ Empty :e finite_complement_topology X /\ X :e finite_complement_topology X.
    apply andI.
    { prove finite_complement_topology X c= Power X /\ Empty :e finite_complement_topology X.
      apply andI.
      - let U. assume HU: U :e finite_complement_topology X.
        exact (SepE1 (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) U HU).
      - exact (SepI (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) Empty (Empty_In_Power X) (orIR (finite (X :\: Empty)) (Empty = Empty) (fun P H => H))).
    }
    { claim Hdiff_empty : X :\: X = Empty.
      { apply Empty_Subq_eq.
        let x. assume Hx.
        claim HxX : x :e X.
        { exact (setminusE1 X X x Hx). }
        claim Hxnot : x /:e X.
        { exact (setminusE2 X X x Hx). }
        apply FalseE.
        exact (Hxnot HxX).
      }
      claim HfinDiff : finite (X :\: X).
      { rewrite Hdiff_empty. exact finite_Empty. }
      exact (SepI (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) X (Self_In_Power X) (orIL (finite (X :\: X)) (X = Empty) HfinDiff)).
    }
  * prove forall UFam :e Power (finite_complement_topology X), Union UFam :e finite_complement_topology X.
    let UFam. assume Hfam: UFam :e Power (finite_complement_topology X).
    claim Hsub : UFam c= finite_complement_topology X.
    { exact (PowerE (finite_complement_topology X) UFam Hfam). }
    apply xm (exists U:set, U :e UFam /\ finite (X :\: U)).
    - assume Hex: exists U:set, U :e UFam /\ finite (X :\: U).
      claim HUnionInPower : Union UFam :e Power X.
      { apply PowerI X (Union UFam).
        let x. assume HxUnion.
        apply UnionE_impred UFam x HxUnion.
        let U. assume HxU HUin.
        claim HUinPow : U :e Power X.
        { exact (SepE1 (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) U (Hsub U HUin)). }
        claim HUsub : U c= X.
        { exact (PowerE X U HUinPow). }
        exact (HUsub x HxU).
      }
      claim HUnionPred : finite (X :\: Union UFam) \/ Union UFam = Empty.
      { apply orIL.
        apply Hex.
        let U. assume Hpair : U :e UFam /\ finite (X :\: U).
        claim HUin : U :e UFam.
        { exact (andEL (U :e UFam) (finite (X :\: U)) Hpair). }
        claim HUfin : finite (X :\: U).
        { exact (andER (U :e UFam) (finite (X :\: U)) Hpair). }
        claim Hsubset : X :\: Union UFam c= X :\: U.
        { let x. assume Hx.
          claim HxX : x :e X.
          { exact (setminusE1 X (Union UFam) x Hx). }
          claim HnotUnion : x /:e Union UFam.
          { exact (setminusE2 X (Union UFam) x Hx). }
          claim HnotU : x /:e U.
          { assume HxU.
            apply HnotUnion.
            apply UnionI UFam x U HxU HUin.
          }
          apply setminusI X U x HxX HnotU.
        }
        exact (Subq_finite (X :\: U) HUfin (X :\: Union UFam) Hsubset).
      }
      exact (SepI (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) (Union UFam) HUnionInPower HUnionPred).
    - assume Hnone: ~exists U:set, U :e UFam /\ finite (X :\: U).
      claim HUnionEmpty : Union UFam = Empty.
      { apply Empty_Subq_eq.
        let x. assume HxUnion.
        apply UnionE_impred UFam x HxUnion.
        let U. assume HxU HUin.
        claim HUdata : finite (X :\: U) \/ U = Empty.
        { exact (SepE2 (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) U (Hsub U HUin)). }
        apply HUdata (x :e Empty).
        - assume HUfin.
          apply FalseE.
          apply Hnone.
          witness U.
          apply andI.
          + exact HUin.
          + exact HUfin.
        - assume HUempty : U = Empty.
          rewrite <- HUempty.
          exact HxU.
      }
      rewrite HUnionEmpty.
      exact HEmptyOpen.
- prove forall U :e finite_complement_topology X, forall V :e finite_complement_topology X, U :/\: V :e finite_complement_topology X.
  let U. assume HU: U :e finite_complement_topology X.
  let V. assume HV: V :e finite_complement_topology X.
  claim HUdata : finite (X :\: U) \/ U = Empty.
  { exact (SepE2 (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) U HU). }
  claim HVdata : finite (X :\: V) \/ V = Empty.
  { exact (SepE2 (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) V HV). }
  apply HUdata (U :/\: V :e finite_complement_topology X).
  * assume HUfin.
    apply HVdata (U :/\: V :e finite_complement_topology X).
    { assume HVfin.
      claim HcapInPower : U :/\: V :e Power X.
      { claim HUsub : U c= X.
        { exact (PowerE X U (SepE1 (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) U HU)). }
        apply PowerI X (U :/\: V).
        let x. assume HxCap.
        apply binintersectE U V x HxCap.
        assume HxU HxV.
        exact (HUsub x HxU).
      }
      claim HcapPred : finite (X :\: (U :/\: V)) \/ U :/\: V = Empty.
      { apply orIL.
        claim HfinUnion : finite ((X :\: U) :\/: (X :\: V)).
        { exact (binunion_finite (X :\: U) HUfin (X :\: V) HVfin). }
        claim Hsubset : X :\: (U :/\: V) c= (X :\: U) :\/: (X :\: V).
        { let x. assume Hx.
          claim HxX : x :e X.
          { exact (setminusE1 X (U :/\: V) x Hx). }
          claim HnotCap : x /:e U :/\: V.
          { exact (setminusE2 X (U :/\: V) x Hx). }
          apply xm (x :e U).
          - assume HxU.
            claim HnotV : x /:e V.
            { assume HxV.
              apply HnotCap.
              exact (binintersectI U V x HxU HxV).
            }
            apply binunionI2 (X :\: U) (X :\: V).
            apply setminusI X V x HxX HnotV.
          - assume HnotU.
            apply binunionI1 (X :\: U) (X :\: V).
            apply setminusI X U x HxX HnotU.
        }
        exact (Subq_finite ((X :\: U) :\/: (X :\: V)) HfinUnion (X :\: (U :/\: V)) Hsubset).
      }
      exact (SepI (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) (U :/\: V) HcapInPower HcapPred).
    }
    { assume HVempty : V = Empty.
      claim Hcap_empty : U :/\: V = Empty.
      { rewrite HVempty.
        apply Empty_Subq_eq.
        exact (binintersect_Subq_2 U Empty).
      }
      rewrite Hcap_empty.
      exact HEmptyOpen.
    }
  * assume HUempty : U = Empty.
    claim Hcap_empty : U :/\: V = Empty.
    { rewrite HUempty.
      apply Empty_Subq_eq.
      exact (binintersect_Subq_1 Empty V).
    }
    rewrite Hcap_empty.
    exact HEmptyOpen.
Qed.

(** from 12: finer_than reflexive **)
(** LATEX VERSION: Any topology is finer than itself. **)
Theorem finer_than_refl : forall T:set, finer_than T T.
let T.
exact (Subq_ref T).
Qed.

(** from 12: finer_than transitive **)
(** LATEX VERSION: Finer-than is transitive: if T'' finer than T' and T' finer than T, then T'' finer than T. **)
Theorem finer_than_trans : forall A B C:set, finer_than B A -> finer_than C B -> finer_than C A.
let A B C.
assume H1: finer_than B A.
assume H2: finer_than C B.
exact (Subq_tra A B C H1 H2).
Qed.

(** from 12: equivalence of finer/coarser phrasing **)
(** LATEX VERSION: Saying T' is finer than T is equivalent to saying T is coarser than T'. **)
Theorem finer_coarser_dual : forall T T':set, finer_than T' T -> coarser_than T T'.
let T T'.
assume H.
exact H.
Qed.

(** from 12: comparability of topologies **)
(** LATEX VERSION: Two topologies are comparable if one contains the other. **)
Definition comparable_topologies : set -> set -> prop := fun T1 T2 =>
  finer_than T1 T2 \/ finer_than T2 T1.

(** from 12: equality of topologies **)
(** LATEX VERSION: Topology equality on X means both are topologies on X and have identical collections of opens. **)
Definition topology_eq : set -> set -> set -> prop := fun X T1 T2 =>
  topology_on X T1 /\ topology_on X T2 /\ T1 = T2.

(** from 12: symmetry of topology equality **)
(** LATEX VERSION: Equality of topologies is symmetric. **)
Theorem topology_eq_sym : forall X T1 T2:set, topology_eq X T1 T2 -> topology_eq X T2 T1.
let X T1 T2. assume H.
claim Hpair: topology_on X T1 /\ topology_on X T2.
{ exact (andEL (topology_on X T1 /\ topology_on X T2) (T1 = T2) H). }
claim Heq: T1 = T2.
{ exact (andER (topology_on X T1 /\ topology_on X T2) (T1 = T2) H). }
claim HT1: topology_on X T1.
{ exact (andEL (topology_on X T1) (topology_on X T2) Hpair). }
claim HT2: topology_on X T2.
{ exact (andER (topology_on X T1) (topology_on X T2) Hpair). }
prove topology_on X T2 /\ topology_on X T1 /\ T2 = T1.
apply andI.
- apply andI.
  + exact HT2.
  + exact HT1.
- rewrite <- Heq. reflexivity.
Qed.

(** from 12: transitivity of topology equality **)
(** LATEX VERSION: Equality of topologies is transitive. **)
Theorem topology_eq_trans : forall X T1 T2 T3:set, topology_eq X T1 T2 -> topology_eq X T2 T3 -> topology_eq X T1 T3.
let X T1 T2 T3.
assume H12 H23.
claim H12pair: topology_on X T1 /\ topology_on X T2.
{ exact (andEL (topology_on X T1 /\ topology_on X T2) (T1 = T2) H12). }
claim H12eq: T1 = T2.
{ exact (andER (topology_on X T1 /\ topology_on X T2) (T1 = T2) H12). }
claim HT1: topology_on X T1.
{ exact (andEL (topology_on X T1) (topology_on X T2) H12pair). }
claim HT2: topology_on X T2.
{ exact (andER (topology_on X T1) (topology_on X T2) H12pair). }
claim H23pair: topology_on X T2 /\ topology_on X T3.
{ exact (andEL (topology_on X T2 /\ topology_on X T3) (T2 = T3) H23). }
claim H23eq: T2 = T3.
{ exact (andER (topology_on X T2 /\ topology_on X T3) (T2 = T3) H23). }
claim HT3: topology_on X T3.
{ exact (andER (topology_on X T2) (topology_on X T3) H23pair). }
prove topology_on X T1 /\ topology_on X T3 /\ T1 = T3.
apply andI.
- apply andI.
  + exact HT1.
  + exact HT3.
- rewrite H12eq. rewrite H23eq. reflexivity.
Qed.

(** from 12: reflexivity of topology equality **)
(** LATEX VERSION: Any topology equals itself (with the requisite topology_on hypotheses). **)
Theorem topology_eq_refl : forall X T:set, topology_on X T -> topology_eq X T T.
let X T. assume HT.
prove topology_on X T /\ topology_on X T /\ T = T.
apply andI.
- apply andI.
  + exact HT.
  + exact HT.
- reflexivity.
Qed.

(** from 12: strict fineness/coarseness **)
(** LATEX VERSION: T' is strictly finer than T if T'T and not conversely; strictly coarser is the dual. **)
Definition strictly_finer_than : set -> set -> prop := fun T' T => finer_than T' T /\ ~finer_than T T'.

Definition strictly_coarser_than : set -> set -> prop := fun T' T => coarser_than T' T /\ ~coarser_than T T'.

(** from 12 examples: auxiliary aliases **)
(** LATEX VERSION: Alternate notation: discrete topology and trivial (indiscrete) topology. **)
Definition discrete_topology_alt : set -> set := discrete_topology.
Definition trivial_topology : set -> set := indiscrete_topology.

(** from 12: finer_than between topologies on same X **)
(** LATEX VERSION: A notion of T' finer than T together with both being topologies on X. **)
Definition finer_than_topology : set -> set -> set -> prop := fun X T' T =>
  topology_on X T' /\ topology_on X T /\ finer_than T' T.

(** from 12: finer/coarser equivalence **)
(** LATEX VERSION: Finer-than and coarser-than are logically equivalent statements with reversed arguments. **)
Theorem finer_than_def : forall T T':set, finer_than T' T <-> coarser_than T T'.
let T T'.
apply iffI.
- assume H. exact H.
- assume H. exact H.
Qed.

(** from 12: discrete topology is the finest **)
(** LATEX VERSION: The discrete topology on X is finer than any other topology on X. **)
Theorem discrete_topology_finest : forall X T:set,
  topology_on X T -> finer_than (discrete_topology X) T.
let X T. assume HT.
claim H1 : ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T).
{ exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) (forall U :e T, forall V :e T, U :/\: V :e T) HT). }
claim H2 : (T c= Power X /\ Empty :e T) /\ X :e T.
{ exact (andEL ((T c= Power X /\ Empty :e T) /\ X :e T) (forall UFam :e Power T, Union UFam :e T) H1). }
claim H3 : T c= Power X /\ Empty :e T.
{ exact (andEL (T c= Power X /\ Empty :e T) (X :e T) H2). }
claim HTsub : T c= Power X.
{ exact (andEL (T c= Power X) (Empty :e T) H3). }
exact HTsub.
Qed.

(** from 12: indiscrete topology is the coarsest **)
(** LATEX VERSION: The indiscrete topology on X is coarser than any other topology on X. **)
Theorem indiscrete_topology_coarsest : forall X T:set,
  topology_on X T -> coarser_than (indiscrete_topology X) T.
let X T. assume HT.
claim Hchunk1 : ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T).
{ exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) (forall U :e T, forall V :e T, U :/\: V :e T) HT). }
claim Hchunk2 : (T c= Power X /\ Empty :e T) /\ X :e T.
{ exact (andEL ((T c= Power X /\ Empty :e T) /\ X :e T) (forall UFam :e Power T, Union UFam :e T) Hchunk1). }
claim Hchunk3 : T c= Power X /\ Empty :e T.
{ exact (andEL (T c= Power X /\ Empty :e T) (X :e T) Hchunk2). }
claim Hempty : Empty :e T.
{ exact (andER (T c= Power X) (Empty :e T) Hchunk3). }
claim HX : X :e T.
{ exact (andER ((T c= Power X) /\ Empty :e T) (X :e T) Hchunk2). }
let U. assume HU : U :e indiscrete_topology X.
apply UPairE U Empty X HU.
- assume HUempty : U = Empty. rewrite HUempty. exact Hempty.
- assume HUX : U = X. rewrite HUX. exact HX.
Qed.

(** from 12: every subset is open in discrete topology **)
(** LATEX VERSION: In the discrete topology on X, every subset UX is open. **)
Theorem discrete_open_all : forall X U:set, U c= X -> U :e discrete_topology X.
let X U. assume HUsub.
apply PowerI X U HUsub.
Qed.

(** from 12: opens in indiscrete topology are Empty or X **)
(** LATEX VERSION: In the indiscrete topology, the only open sets are  and X. **)
Theorem indiscrete_open_iff : forall X U:set,
  U :e indiscrete_topology X <-> (U = Empty \/ U = X).
let X U.
apply iffI.
- assume HU. exact (UPairE U Empty X HU).
- assume Hcases : U = Empty \/ U = X.
  claim HUempty_branch : U = Empty -> U :e indiscrete_topology X.
  { assume HUE : U = Empty. rewrite HUE. exact (UPairI1 Empty X). }
  claim HUx_branch : U = X -> U :e indiscrete_topology X.
  { assume HUX : U = X. rewrite HUX. exact (UPairI2 Empty X). }
  exact (Hcases (U :e indiscrete_topology X) HUempty_branch HUx_branch).
Qed.

(** from 12 Example 3: finite complement openness criterion **)
(** LATEX VERSION: In the finite complement topology, an open set U satisfies that X\\U is finite or U=. **)
Theorem finite_complement_topology_open_criterion : forall X U:set,
  open_in X (finite_complement_topology X) U ->
  finite (X :\: U) \/ U = Empty.
let X U. assume Hopen.
claim HUin : U :e finite_complement_topology X.
{ exact (andER (topology_on X (finite_complement_topology X)) (U :e finite_complement_topology X) Hopen). }
exact (SepE2 (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) U HUin).
Qed.

(** from 12 Example 3: Empty is open in finite complement topology **)
(** LATEX VERSION:  is an open set in the finite complement topology. **)
Theorem finite_complement_topology_contains_empty : forall X:set,
  Empty :e finite_complement_topology X.
let X.
exact (SepI (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) Empty (Empty_In_Power X) (orIR (finite (X :\: Empty)) (Empty = Empty) (fun P H => H))).
Qed.

(** from 12 Example 3: X is open in finite complement topology **)
(** LATEX VERSION: X itself is open in the finite complement topology. **)
Theorem finite_complement_topology_contains_full : forall X:set,
  X :e finite_complement_topology X.
let X.
claim Hdiff_empty : X :\: X = Empty.
{ apply Empty_Subq_eq.
  let x. assume Hx.
  claim Hxin : x :e X.
  { exact (setminusE1 X X x Hx). }
  claim Hxnot : x /:e X.
  { exact (setminusE2 X X x Hx). }
  apply FalseE.
  exact (Hxnot Hxin).
}
claim HfinDiff : finite (X :\: X).
{ rewrite Hdiff_empty. exact finite_Empty. }
exact (SepI (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) X (Self_In_Power X) (orIL (finite (X :\: X)) (X = Empty) HfinDiff)).
Qed.

(** from 12 Example 4: openness via countable complement **) 
(** LATEX VERSION: In the countable complement topology, an open set U has X\\U countable or U=. **)
Theorem countable_complement_topology_open_iff : forall X U:set,
  open_in X (countable_complement_topology X) U ->
  countable (X :\: U) \/ U = Empty.
let X U. assume Hopen.
claim HUin : U :e countable_complement_topology X.
{ exact (andER (topology_on X (countable_complement_topology X)) (U :e countable_complement_topology X) Hopen). }
exact (SepE2 (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty) U HUin).
Qed.

(** from 12 Example 4: Empty is open in countable complement topology **)
(** LATEX VERSION:  is open in the countable complement topology. **)
Theorem countable_complement_topology_contains_empty : forall X:set,
  Empty :e countable_complement_topology X.
let X.
exact (SepI (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty) Empty (Empty_In_Power X) (orIR (countable (X :\: Empty)) (Empty = Empty) (fun P H => H))).
Qed.

(** from 12 Example 4: X is open in countable complement topology **) 
(** LATEX VERSION: X is open in the countable complement topology. **)
Theorem countable_complement_topology_contains_full : forall X:set,
  X :e countable_complement_topology X.
let X.
claim Hdiff_empty : X :\: X = Empty.
{ apply Empty_Subq_eq.
  let x. assume Hx.
  claim HxX : x :e X.
  { exact (setminusE1 X X x Hx). }
  claim Hxnot : x /:e X.
  { exact (setminusE2 X X x Hx). }
  apply FalseE.
  exact (Hxnot HxX).
}
claim HcountDiff : countable (X :\: X).
{ rewrite Hdiff_empty. exact (Subq_atleastp Empty omega (Subq_Empty omega)). }
exact (SepI (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty) X (Self_In_Power X) (orIL (countable (X :\: X)) (X = Empty) HcountDiff)).
Qed.

(** from 12 Example comparison: countable vs finite complement **)
(** LATEX VERSION: The countable complement topology is finer than the finite complement topology. **)
Theorem countable_complement_finer_than_finite_complement : forall X:set,
  finer_than (countable_complement_topology X) (finite_complement_topology X).
let X.
prove finite_complement_topology X c= countable_complement_topology X.
let U. assume HU: U :e finite_complement_topology X.
claim HUinPow : U :e Power X.
{ exact (SepE1 (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) U HU). }
claim HUdata : finite (X :\: U) \/ U = Empty.
{ exact (SepE2 (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) U HU). }
claim HUpred : countable (X :\: U) \/ U = Empty.
{ apply HUdata (countable (X :\: U) \/ U = Empty).
  - assume HUfin : finite (X :\: U).
    apply orIL.
    exact (finite_countable (X :\: U) HUfin).
  - assume HUemp : U = Empty.
    apply orIR.
    exact HUemp.
}
exact (SepI (Power X) (fun U0 : set => countable (X :\: U0) \/ U0 = Empty) U HUinPow HUpred).
Qed.

(** from 12 examples: finite complement coarser than discrete **)
(** LATEX VERSION: The finite complement topology is coarser than the discrete topology. **)
Theorem finite_complement_coarser_than_discrete : forall X:set,
  coarser_than (finite_complement_topology X) (discrete_topology X).
let X.
prove finite_complement_topology X c= discrete_topology X.
let U. assume HU.
exact (SepE1 (Power X) (fun U0 : set => finite (X :\: U0) \/ U0 = Empty) U HU).
Qed.

(** from 12 examples: indiscrete coarser than countable complement **) 
(** LATEX VERSION: The indiscrete topology is coarser than the countable complement topology. **)
Theorem indiscrete_coarser_than_countable_complement : forall X:set,
  coarser_than (indiscrete_topology X) (countable_complement_topology X).
let X.
prove indiscrete_topology X c= countable_complement_topology X.
let U. assume HU: U :e indiscrete_topology X.
apply UPairE U Empty X HU.
- assume HUempty: U = Empty. rewrite HUempty. exact (countable_complement_topology_contains_empty X).
- assume HUX: U = X. rewrite HUX. exact (countable_complement_topology_contains_full X).
Qed.

(** from 12: fineness via set inclusion of topologies **)
(** LATEX VERSION: A restatement of fineness between topologies on X as inclusion of their open sets. **)
Definition finer_than_topology_by_inclusion : set -> set -> set -> prop := fun X T' T =>
  topology_on X T' /\ topology_on X T /\ T c= T'.

(** from 12: fineness via inclusion characterization **)
(** LATEX VERSION: The earlier fineness notion between topologies on X is equivalent to plain inclusion of their open sets. **)
Theorem finer_than_topology_by_inclusion_eq : forall X T' T:set,
  finer_than_topology X T' T <-> finer_than_topology_by_inclusion X T' T.
let X T' T.
apply iffI.
- assume H. exact H.
- assume H. exact H.
Qed.

(** from 12 axiom: arbitrary unions of opens are open **)
(** LATEX VERSION: In any topology, the union of any subfamily of open sets is open. **)
Theorem lemma_union_of_topology_family_open : forall X T UFam:set,
  topology_on X T ->
  UFam :e Power T ->
  Union UFam :e T.
let X T UFam. assume HT Hfam.
claim Hchunk1 : ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam' :e Power T, Union UFam' :e T).
{ exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam' :e Power T, Union UFam' :e T)) (forall U :e T, forall V :e T, U :/\: V :e T) HT). }
claim Hunion_axiom : forall UFam' :e Power T, Union UFam' :e T.
{ exact (andER ((T c= Power X /\ Empty :e T) /\ X :e T) (forall UFam' :e Power T, Union UFam' :e T) Hchunk1). }
exact (Hunion_axiom UFam Hfam).
Qed.

(** from 12 axiom: finite intersections of opens are open **)
(** LATEX VERSION: In any topology, the intersection of two open sets is open (and hence any finite intersection). **)
Theorem lemma_intersection_two_open : forall X T U V:set,
  topology_on X T ->
  U :e T -> V :e T ->
  U :/\: V :e T.
let X T U V. assume HT HU HV.
exact (topology_binintersect_closed X T U V HT HU HV).
Qed.

(** from 12: alternative naming for topological space **)
(** LATEX VERSION: Using notation topological_space X T for topology_on X T and open_set_family/open_set for opens. **)
Definition topological_space : set -> set -> prop := topology_on.

Definition open_set_family : set -> set -> set := fun _ T => T.

Definition open_set : set -> set -> set -> prop := fun X T U => topology_on X T /\ U :e T.

(** from 13 Definition: basis for a topology **) 
(** LATEX VERSION: A basis on X is a collection BP(X) such that every xX lies in some bB and intersections around a point refine to another basis element. **)
Definition basis_on : set -> set -> prop := fun X B =>
  B c= Power X
  /\ (forall x :e X, exists b :e B, x :e b)
  /\ (forall b1 :e B, forall b2 :e B, forall x:set,
        x :e b1 -> x :e b2 ->
        exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2).

(** from 13 Definition: topology generated by a basis **)
(** LATEX VERSION: The topology generated by basis B on X consists of all UX such that every xU lies in some bB with bU. **)
Definition generated_topology : set -> set -> set := fun X B =>
  {U :e Power X | forall x :e U, exists b :e B, x :e b /\ b c= U}.

(** Helper: Basis elements are subsets of X **)
Theorem basis_elem_subset : forall X B b:set,
  basis_on X B -> b :e B -> b c= X.
let X B b.
assume HB: basis_on X B.
assume Hb: b :e B.
prove b c= X.
(** basis_on X B = (B c= Power X) /\ (coverage /\ intersection property) **)
(** Left-associative: ((B c= Power X) /\ coverage) /\ intersection **)
claim H1: (B c= Power X /\ (forall x :e X, exists b0 :e B, x :e b0)) /\ (forall b1 :e B, forall b2 :e B, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2).
{ exact HB. }
claim H2: B c= Power X /\ (forall x :e X, exists b0 :e B, x :e b0).
{ exact (andEL (B c= Power X /\ (forall x :e X, exists b0 :e B, x :e b0)) (forall b1 :e B, forall b2 :e B, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2) H1). }
claim HBPower: B c= Power X.
{ exact (andEL (B c= Power X) (forall x :e X, exists b0 :e B, x :e b0) H2). }
claim HbPower: b :e Power X.
{ exact (HBPower b Hb). }
exact (PowerE X b HbPower).
Qed.

(** Helper: Basis elements are in generated topology **)
Theorem basis_in_generated : forall X B b:set,
  basis_on X B -> b :e B -> b :e generated_topology X B.
let X B b.
assume HB: basis_on X B.
assume Hb: b :e B.
prove b :e generated_topology X B.
(** generated_topology X B = {U :e Power X | forall x :e U, exists b0 :e B, x :e b0 /\ b0 c= U} **)
(** Need: b :e Power X and forall x :e b, exists b0 :e B, x :e b0 /\ b0 c= b **)
claim HbPower: b :e Power X.
{ claim HbsubX: b c= X.
  { exact (basis_elem_subset X B b HB Hb). }
  exact (PowerI X b HbsubX). }
claim HbCond: forall x :e b, exists b0 :e B, x :e b0 /\ b0 c= b.
{ let x. assume Hx: x :e b.
  (** Use b itself as the witness **)
  witness b.
  apply andI.
  - exact Hb.
  - apply andI.
    + exact Hx.
    + apply Subq_ref. }
exact (SepI (Power X) (fun U => forall x :e U, exists b0 :e B, x :e b0 /\ b0 c= U) b HbPower HbCond).
Qed.

(** Helper: Elements of generated topology are subsets of X **)
Theorem generated_topology_subset : forall X B U:set,
  U :e generated_topology X B -> U c= X.
let X B U.
assume HU: U :e generated_topology X B.
prove U c= X.
(** generated_topology X B = {U :e Power X | ...} **)
claim HUPower: U :e Power X.
{ exact (SepE1 (Power X) (fun U0 => forall x :e U0, exists b :e B, x :e b /\ b c= U0) U HU). }
exact (PowerE X U HUPower).
Qed.

(** from 13: generated family is a topology **) 
(** LATEX VERSION: The collection generated by a basis indeed satisfies the topology axioms. **)
Theorem lemma_topology_from_basis : forall X B:set,
  basis_on X B ->
  topology_on X (generated_topology X B).
let X B. assume HBasis.
claim HBleft : B c= Power X /\ (forall x :e X, exists b :e B, x :e b).
{ exact (andEL (B c= Power X /\ (forall x :e X, exists b :e B, x :e b))
               (forall b1 :e B, forall b2 :e B, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2)
               HBasis). }
claim HBint : forall b1 :e B, forall b2 :e B, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2.
{ exact (andER (B c= Power X /\ (forall x :e X, exists b :e B, x :e b))
               (forall b1 :e B, forall b2 :e B, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2)
               HBasis). }
claim HBsub : B c= Power X.
{ exact (andEL (B c= Power X) (forall x :e X, exists b :e B, x :e b) HBleft). }
claim HBcov : forall x :e X, exists b :e B, x :e b.
{ exact (andER (B c= Power X) (forall x :e X, exists b :e B, x :e b) HBleft). }
claim proofA : generated_topology X B c= Power X.
{ let U. assume HU: U :e generated_topology X B.
  exact (SepE1 (Power X) (fun U0 : set => forall x :e U0, exists b :e B, x :e b /\ b c= U0) U HU). }
claim proofB : Empty :e generated_topology X B.
{ exact (SepI (Power X) (fun U0 : set => forall x :e U0, exists b :e B, x :e b /\ b c= U0) Empty (Empty_In_Power X) (fun x HxEmpty => EmptyE x HxEmpty (exists b :e B, x :e b /\ b c= Empty))). }
claim proofC : X :e generated_topology X B.
  { claim HXprop : forall x :e X, exists b :e B, x :e b /\ b c= X.
    { let x. assume HxX.
      claim Hexb : exists b :e B, x :e b.
      { exact (HBcov x HxX). }
      apply Hexb.
      let b. assume Hbpair.
      claim HbB : b :e B.
      { exact (andEL (b :e B) (x :e b) Hbpair). }
      claim Hxb : x :e b.
      { exact (andER (b :e B) (x :e b) Hbpair). }
      claim HbsubX : b c= X.
      { exact (PowerE X b (HBsub b HbB)). }
      witness b.
      apply andI.
      - exact HbB.
      - apply andI.
        * exact Hxb.
        * exact HbsubX. }
  exact (SepI (Power X) (fun U0 : set => forall x :e U0, exists b :e B, x :e b /\ b c= U0) X (Self_In_Power X) HXprop). }
claim proofD : forall UFam :e Power (generated_topology X B), Union UFam :e generated_topology X B.
{ let UFam. assume Hfam: UFam :e Power (generated_topology X B).
  claim HsubFam : UFam c= generated_topology X B.
  { exact (PowerE (generated_topology X B) UFam Hfam). }
  claim HPowUnion : Union UFam :e Power X.
  { apply PowerI X (Union UFam).
    let x. assume HxUnion.
    apply UnionE_impred UFam x HxUnion.
    let U. assume HxU HUin.
    claim HUtop : U :e generated_topology X B.
    { exact (HsubFam U HUin). }
    claim HUsubX : U c= X.
    { exact (PowerE X U (SepE1 (Power X) (fun U0 : set => forall x0 :e U0, exists b :e B, x0 :e b /\ b c= U0) U HUtop)). }
    exact (HUsubX x HxU). }
  claim HUnionProp : forall x :e Union UFam, exists b :e B, x :e b /\ b c= Union UFam.
  { let x. assume HxUnion.
    apply UnionE_impred UFam x HxUnion.
    let U. assume HxU HUin.
    claim HUtop : U :e generated_topology X B.
    { exact (HsubFam U HUin). }
    claim HUprop : forall x0 :e U, exists b :e B, x0 :e b /\ b c= U.
    { exact (SepE2 (Power X) (fun U0 : set => forall x0 :e U0, exists b :e B, x0 :e b /\ b c= U0) U HUtop). }
    claim Hexb : exists b :e B, x :e b /\ b c= U.
    { exact (HUprop x HxU). }
    apply Hexb.
    let b. assume Hbpair.
    claim HbB : b :e B.
    { exact (andEL (b :e B) (x :e b /\ b c= U) Hbpair). }
    claim Hbprop : x :e b /\ b c= U.
    { exact (andER (b :e B) (x :e b /\ b c= U) Hbpair). }
    claim Hxb : x :e b.
    { exact (andEL (x :e b) (b c= U) Hbprop). }
    claim HbSubU : b c= U.
    { exact (andER (x :e b) (b c= U) Hbprop). }
    witness b.
    apply andI.
    - exact HbB.
    - apply andI.
      * exact Hxb.
      * let y. assume Hyb.
        apply UnionI UFam y U (HbSubU y Hyb) HUin. }
  exact (SepI (Power X) (fun U0 : set => forall x :e U0, exists b :e B, x :e b /\ b c= U0) (Union UFam) HPowUnion HUnionProp). }
claim proofE : forall U :e generated_topology X B, forall V :e generated_topology X B, U :/\: V :e generated_topology X B.
{ let U. assume HUtop.
  let V. assume HVtop.
  claim HUprop : forall x0 :e U, exists b :e B, x0 :e b /\ b c= U.
  { exact (SepE2 (Power X) (fun U0 : set => forall x0 :e U0, exists b :e B, x0 :e b /\ b c= U0) U HUtop). }
  claim HVprop : forall x0 :e V, exists b :e B, x0 :e b /\ b c= V.
  { exact (SepE2 (Power X) (fun U0 : set => forall x0 :e U0, exists b :e B, x0 :e b /\ b c= U0) V HVtop). }
  claim HUsubX : U c= X.
  { exact (PowerE X U (SepE1 (Power X) (fun U0 : set => forall x0 :e U0, exists b :e B, x0 :e b /\ b c= U0) U HUtop)). }
  claim HPowCap : U :/\: V :e Power X.
  { apply PowerI X (U :/\: V).
    let x. assume HxCap.
    apply binintersectE U V x HxCap.
    assume HxU HxV.
    exact (HUsubX x HxU). }
  claim HCapProp : forall x :e U :/\: V, exists b :e B, x :e b /\ b c= U :/\: V.
  { let x. assume HxCap.
    apply binintersectE U V x HxCap.
    assume HxU HxV.
    claim Hexb1 : exists b1 :e B, x :e b1 /\ b1 c= U.
    { exact (HUprop x HxU). }
    claim Hexb2 : exists b2 :e B, x :e b2 /\ b2 c= V.
    { exact (HVprop x HxV). }
    apply Hexb1.
    let b1. assume Hbpair1.
    claim Hb1 : b1 :e B.
    { exact (andEL (b1 :e B) (x :e b1 /\ b1 c= U) Hbpair1). }
    claim Hb1prop : x :e b1 /\ b1 c= U.
    { exact (andER (b1 :e B) (x :e b1 /\ b1 c= U) Hbpair1). }
    claim Hb1x : x :e b1.
    { exact (andEL (x :e b1) (b1 c= U) Hb1prop). }
    claim Hb1Sub : b1 c= U.
    { exact (andER (x :e b1) (b1 c= U) Hb1prop). }
    apply Hexb2.
    let b2. assume Hbpair2.
    claim Hb2 : b2 :e B.
    { exact (andEL (b2 :e B) (x :e b2 /\ b2 c= V) Hbpair2). }
    claim Hb2prop : x :e b2 /\ b2 c= V.
    { exact (andER (b2 :e B) (x :e b2 /\ b2 c= V) Hbpair2). }
    claim Hb2x : x :e b2.
    { exact (andEL (x :e b2) (b2 c= V) Hb2prop). }
    claim Hb2Sub : b2 c= V.
    { exact (andER (x :e b2) (b2 c= V) Hb2prop). }
    claim Hexb3 : exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2.
    { exact (HBint b1 Hb1 b2 Hb2 x Hb1x Hb2x). }
    apply Hexb3.
    let b3. assume Hbpair3.
    claim Hb3 : b3 :e B.
    { exact (andEL (b3 :e B) (x :e b3 /\ b3 c= b1 :/\: b2) Hbpair3). }
    claim Hb3prop : x :e b3 /\ b3 c= b1 :/\: b2.
    { exact (andER (b3 :e B) (x :e b3 /\ b3 c= b1 :/\: b2) Hbpair3). }
    claim HxB3 : x :e b3.
    { exact (andEL (x :e b3) (b3 c= b1 :/\: b2) Hb3prop). }
    claim Hb3Sub : b3 c= b1 :/\: b2.
  { exact (andER (x :e b3) (b3 c= b1 :/\: b2) Hb3prop). }
    witness b3.
    apply andI.
    - exact Hb3.
    - apply andI.
      * exact HxB3.
      * let y. assume Hyb3.
        claim Hy_in_b1b2 : y :e b1 :/\: b2.
        { exact (Hb3Sub y Hyb3). }
        apply binintersectE b1 b2 y Hy_in_b1b2.
        assume Hyb1 Hyb2.
        apply binintersectI U V y (Hb1Sub y Hyb1) (Hb2Sub y Hyb2). }
  exact (SepI (Power X) (fun U0 : set => forall x0 :e U0, exists b :e B, x0 :e b /\ b c= U0) (U :/\: V) HPowCap HCapProp). }
prove generated_topology X B c= Power X
/\ Empty :e generated_topology X B
/\ X :e generated_topology X B
/\ (forall UFam :e Power (generated_topology X B), Union UFam :e generated_topology X B)
/\ (forall U :e generated_topology X B, forall V :e generated_topology X B, U :/\: V :e generated_topology X B).
  apply andI.
- apply andI.
  * apply andI.
    { apply andI.
      - exact proofA.
      - exact proofB. }
    { exact proofC. }
  * exact proofD.
- exact proofE.
Qed.

(** from 13: basis elements belong to generated topology **) 
(** LATEX VERSION: Every basis element bB is itself open in the topology generated by B. **)
Theorem generated_topology_contains_basis : forall X B:set,
  basis_on X B -> forall b:set, b :e B -> b :e generated_topology X B.
let X B. assume HBasis.
claim HBsub : B c= Power X.
{ exact (andEL (B c= Power X) (forall x :e X, exists b :e B, x :e b) (andEL (B c= Power X /\ (forall x :e X, exists b :e B, x :e b))
               (forall b1 :e B, forall b2 :e B, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2)
               HBasis)). }
claim HBint : forall b1 :e B, forall b2 :e B, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2.
{ exact (andER (B c= Power X /\ (forall x :e X, exists b :e B, x :e b))
               (forall b1 :e B, forall b2 :e B, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2)
               HBasis). }
let b0. assume Hb0.
claim Hb0_subX : b0 c= X.
{ exact (PowerE X b0 (HBsub b0 Hb0)). }
claim Hb0prop : forall x :e b0, exists b :e B, x :e b /\ b c= b0.
{ let x. assume Hxb0.
  claim Hexb3 : exists b3 :e B, x :e b3 /\ b3 c= b0 :/\: b0.
  { exact (HBint b0 Hb0 b0 Hb0 x Hxb0 Hxb0). }
  apply Hexb3.
  let b3. assume Hb3pair.
  claim Hb3 : b3 :e B.
  { exact (andEL (b3 :e B) (x :e b3 /\ b3 c= b0 :/\: b0) Hb3pair). }
  claim Hb3prop : x :e b3 /\ b3 c= b0 :/\: b0.
  { exact (andER (b3 :e B) (x :e b3 /\ b3 c= b0 :/\: b0) Hb3pair). }
  claim Hxb3 : x :e b3.
  { exact (andEL (x :e b3) (b3 c= b0 :/\: b0) Hb3prop). }
  claim Hb3sub_inter : b3 c= b0 :/\: b0.
  { exact (andER (x :e b3) (b3 c= b0 :/\: b0) Hb3prop). }
  claim Hb3subb0 : b3 c= b0.
  { let y. assume Hyb3.
    claim Hycap : y :e b0 :/\: b0.
    { exact (Hb3sub_inter y Hyb3). }
    apply binintersectE b0 b0 y Hycap.
    assume Hy1 Hy2.
    exact Hy1. }
  witness b3.
  apply andI.
  - exact Hb3.
  - apply andI.
    * exact Hxb3.
    * exact Hb3subb0. }
exact (SepI (Power X) (fun U0 : set => forall x :e U0, exists b :e B, x :e b /\ b c= U0) b0 (PowerI X b0 Hb0_subX) Hb0prop).
Qed.

(** from 13: shorthand for basis generating topology **) 
(** LATEX VERSION: basis_generates X B T abbreviates B is a basis on X and the generated topology equals T. **)
Definition basis_generates : set -> set -> set -> prop := fun X B T =>
  basis_on X B /\ generated_topology X B = T.

(** from 13: shorthand that a family refines all opens **) 
(** LATEX VERSION: basis_refines X B T means T is a topology on X and every x in any UT lies in some bB with bU. **)
Definition basis_refines : set -> set -> set -> prop := fun X B T =>
  topology_on X T /\ (forall U :e T, forall x :e U, exists b :e B, x :e b /\ b c= U).

(** from 13: generated topology characterization **) 
(** LATEX VERSION: Characterization of generated_topology as the comprehension of subsets UX with the basis neighborhood property. **)
Theorem lemma_generated_topology_characterization : forall X B:set,
  basis_on X B ->
  generated_topology X B
  = {U :e Power X | forall x :e U, exists b :e B, x :e b /\ b c= U}.
let X B. assume HBasis.
reflexivity.
Qed.

(** from 13 Lemma 13.1: open sets are unions of basis elements **) 
(** LATEX VERSION: Lemma 13.1: For a basis B on X, every open set is a union of elements of B. **)
Theorem open_sets_as_unions_of_basis : forall X B:set,
  basis_on X B ->
  forall U:set, open_in X (generated_topology X B) U ->
    exists Fam :e Power B, Union Fam = U.
let X B. assume HBasis.
claim HBsub : B c= Power X.
{ exact (andEL (B c= Power X) (forall x :e X, exists b :e B, x :e b)
               (andEL (B c= Power X /\ (forall x :e X, exists b :e B, x :e b))
                     (forall b1 :e B, forall b2 :e B, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2)
                     HBasis)). }
let U. assume HUopen.
claim HUtop : U :e generated_topology X B.
{ exact (andER (topology_on X (generated_topology X B)) (U :e generated_topology X B) HUopen). }
claim HUprop : forall x :e U, exists b :e B, x :e b /\ b c= U.
{ exact (SepE2 (Power X) (fun U0 : set => forall x0 :e U0, exists b :e B, x0 :e b /\ b c= U0) U HUtop). }
set Fam : set := {b :e B|b c= U}.
claim HFamPow : Fam :e Power B.
{ apply PowerI B Fam.
  let b. assume HbFam.
  exact (SepE1 B (fun b0 : set => b0 c= U) b HbFam). }
claim HUnion_eq : Union Fam = U.
{ apply set_ext.
  - let x. assume HxUnion.
    apply UnionE_impred Fam x HxUnion.
    let b. assume Hxb HbFam.
    claim HbsubU : b c= U.
    { exact (SepE2 B (fun b0 : set => b0 c= U) b HbFam). }
    exact (HbsubU x Hxb).
  - let x. assume HxU.
    claim Hexb : exists b :e B, x :e b /\ b c= U.
    { exact (HUprop x HxU). }
    apply Hexb.
    let b. assume Hbpair.
    claim HbB : b :e B.
    { exact (andEL (b :e B) (x :e b /\ b c= U) Hbpair). }
    claim Hbprop : x :e b /\ b c= U.
    { exact (andER (b :e B) (x :e b /\ b c= U) Hbpair). }
    claim Hxb : x :e b.
    { exact (andEL (x :e b) (b c= U) Hbprop). }
    claim HbsubU : b c= U.
    { exact (andER (x :e b) (b c= U) Hbprop). }
    claim HbFam : b :e Fam.
    { exact (SepI B (fun b0 : set => b0 c= U) b HbB HbsubU). }
    exact (UnionI Fam x b Hxb HbFam). }
witness Fam.
apply andI.
- exact HFamPow.
- exact HUnion_eq.
Qed.

(** from 13 Lemma 13.1 converse direction **) 
(** LATEX VERSION: Conversely, any union of basis elements is open in the topology generated by the basis. **)
Theorem basis_generates_open_sets : forall X B:set,
  basis_on X B ->
  forall U:set, (exists Fam :e Power B, Union Fam = U) ->
    open_in X (generated_topology X B) U.
let X B. assume HBasis.
claim HBsub : B c= Power X.
{ exact (andEL (B c= Power X) (forall x :e X, exists b :e B, x :e b)
               (andEL (B c= Power X /\ (forall x :e X, exists b :e B, x :e b))
                     (forall b1 :e B, forall b2 :e B, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e B, x :e b3 /\ b3 c= b1 :/\: b2)
                     HBasis)). }
let U. assume Hex.
claim HUGen : U :e generated_topology X B.
{ apply Hex.
  let Fam. assume HFampair.
  claim HFamPow : Fam :e Power B.
  { exact (andEL (Fam :e Power B) (Union Fam = U) HFampair). }
  claim HUnionEq : Union Fam = U.
  { exact (andER (Fam :e Power B) (Union Fam = U) HFampair). }
  claim HFamSubB : Fam c= B.
  { exact (PowerE B Fam HFamPow). }
  claim HFamSubX : Fam c= Power X.
  { let b. assume HbFam.
    claim HbB : b :e B.
    { exact (HFamSubB b HbFam). }
    exact (HBsub b HbB). }
  claim HUnionSubX : Union Fam c= X.
  { let x. assume HxUnion.
    apply UnionE_impred Fam x HxUnion.
    let b. assume Hxb HbFam.
    claim HbSubX : b c= X.
    { exact (PowerE X b (HFamSubX b HbFam)). }
    exact (HbSubX x Hxb). }
  claim HUnionSubU : Union Fam c= U.
  { rewrite HUnionEq.
    exact (Subq_ref U). }
  claim HUsubUnion : U c= Union Fam.
  { rewrite <- HUnionEq.
    exact (Subq_ref (Union Fam)). }
  claim HUsubX : U c= X.
  { exact (Subq_tra U (Union Fam) X HUsubUnion HUnionSubX). }
  claim HUpropU : forall x :e U, exists b :e B, x :e b /\ b c= U.
  { let x. assume HxU.
    claim HxUnion : x :e Union Fam.
    { exact (HUsubUnion x HxU). }
    apply UnionE_impred Fam x HxUnion.
    let b. assume Hxb HbFam.
    claim HbB : b :e B.
    { exact (HFamSubB b HbFam). }
    claim HbSubUnion : b c= Union Fam.
    { let y. assume Hyb.
      exact (UnionI Fam y b Hyb HbFam). }
    claim HbSubU : b c= U.
    { exact (Subq_tra b (Union Fam) U HbSubUnion HUnionSubU). }
    witness b.
    apply andI.
    - exact HbB.
    - apply andI.
      * exact Hxb.
      * exact HbSubU. }
  exact (SepI (Power X) (fun U0 : set => forall x0 :e U0, exists b0 :e B, x0 :e b0 /\ b0 c= U0) U (PowerI X U HUsubX) HUpropU). }
exact (andI (topology_on X (generated_topology X B)) (U :e generated_topology X B) (lemma_topology_from_basis X B HBasis) HUGen).
Qed.

(** from 13 Lemma 13.1 corollary **) 
(** LATEX VERSION: Corollary: For U open in topology generated by B, U equals the union of all basis elements contained in U. **)
Theorem open_as_union_of_basis_elements : forall X B:set,
  basis_on X B ->
  forall U:set, open_in X (generated_topology X B) U ->
    U = Union {b :e B|b c= U}.
let X B. assume HBasis.
let U. assume HUopen.
claim HUtop : U :e generated_topology X B.
{ exact (andER (topology_on X (generated_topology X B)) (U :e generated_topology X B) HUopen). }
claim HUprop : forall x :e U, exists b :e B, x :e b /\ b c= U.
{ exact (SepE2 (Power X) (fun U0 : set => forall x0 :e U0, exists b :e B, x0 :e b /\ b c= U0) U HUtop). }
set Fam : set := {b :e B|b c= U}.
apply set_ext.
- let x. assume HxU.
  claim Hexb : exists b :e B, x :e b /\ b c= U.
  { exact (HUprop x HxU). }
  apply Hexb.
  let b. assume Hbpair.
  claim HbB : b :e B.
  { exact (andEL (b :e B) (x :e b /\ b c= U) Hbpair). }
  claim Hbprop : x :e b /\ b c= U.
  { exact (andER (b :e B) (x :e b /\ b c= U) Hbpair). }
  claim Hxb : x :e b.
  { exact (andEL (x :e b) (b c= U) Hbprop). }
  claim HbsubU : b c= U.
  { exact (andER (x :e b) (b c= U) Hbprop). }
  claim HbFam : b :e Fam.
  { exact (SepI B (fun b0 : set => b0 c= U) b HbB HbsubU). }
  exact (UnionI Fam x b Hxb HbFam).
- let x. assume HxUnion.
  apply UnionE_impred Fam x HxUnion.
  let b. assume Hxb HbFam.
  claim HbsubU : b c= U.
  { exact (SepE2 B (fun b0 : set => b0 c= U) b HbFam). }
  exact (HbsubU x Hxb).
Qed.

(** from 13 Lemma 13.2: extracting a basis from an open refinement condition **) 
(** LATEX VERSION: Lemma 13.2: If every open set of topology T on X is locally contained in some element of CT, then C is a basis and generates T. **)
Theorem basis_refines_topology : forall X T C:set,
  topology_on X T ->
  (forall c :e C, c :e T) ->
  (forall U :e T, forall x :e U, exists Cx :e C, x :e Cx /\ Cx c= U) ->
  basis_on X C /\ generated_topology X C = T.
let X T C. assume Htop HCsub Href.
claim Hleft : ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T).
{ exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T))
               (forall U :e T, forall V :e T, U :/\: V :e T)
               Htop). }
claim Hcore : (T c= Power X /\ Empty :e T) /\ X :e T.
{ exact (andEL ((T c= Power X /\ Empty :e T) /\ X :e T)
               (forall UFam :e Power T, Union UFam :e T)
               Hleft). }
claim HTPowEmpty : T c= Power X /\ Empty :e T.
{ exact (andEL (T c= Power X /\ Empty :e T) (X :e T) Hcore). }
claim HTsubPow : T c= Power X.
{ exact (andEL (T c= Power X) (Empty :e T) HTPowEmpty). }
claim HXT : X :e T.
{ exact (andER (T c= Power X /\ Empty :e T) (X :e T) Hcore). }
claim HUnionClosed : forall UFam :e Power T, Union UFam :e T.
{ exact (andER ((T c= Power X /\ Empty :e T) /\ X :e T) (forall UFam :e Power T, Union UFam :e T) Hleft). }
claim HInterClosed : forall U :e T, forall V :e T, U :/\: V :e T.
{ exact (andER (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T))
               (forall U :e T, forall V :e T, U :/\: V :e T)
               Htop). }
claim HBasis : basis_on X C.
{ prove (C c= Power X
         /\ (forall x :e X, exists c :e C, x :e c)
         /\ (forall b1 :e C, forall b2 :e C, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e C, x :e b3 /\ b3 c= b1 :/\: b2)).
  apply andI.
  - apply andI.
    * let c. assume HcC.
      exact (HTsubPow c (HCsub c HcC)).
    * let x. assume HxX.
      claim Hex : exists c :e C, x :e c /\ c c= X.
      { exact (Href X HXT x HxX). }
      apply Hex.
      let c. assume Hpair.
      claim HcC : c :e C.
      { exact (andEL (c :e C) (x :e c /\ c c= X) Hpair). }
      claim Hcprop : x :e c /\ c c= X.
      { exact (andER (c :e C) (x :e c /\ c c= X) Hpair). }
      claim Hxc : x :e c.
      { exact (andEL (x :e c) (c c= X) Hcprop). }
      witness c.
      apply andI.
      - exact HcC.
      - exact Hxc.
  - let c1. assume Hc1C.
    let c2. assume Hc2C.
    let x. assume Hxc1 Hxc2.
    claim Hc1T : c1 :e T.
    { exact (HCsub c1 Hc1C). }
    claim Hc2T : c2 :e T.
    { exact (HCsub c2 Hc2C). }
    claim HcapT : c1 :/\: c2 :e T.
    { exact (HInterClosed c1 Hc1T c2 Hc2T). }
    claim HxCap : x :e c1 :/\: c2.
    { exact (binintersectI c1 c2 x Hxc1 Hxc2). }
    claim Hex : exists c3 :e C, x :e c3 /\ c3 c= c1 :/\: c2.
    { exact (Href (c1 :/\: c2) HcapT x HxCap). }
    exact Hex. }
claim Hgen_sub_T : generated_topology X C c= T.
{ let U. assume HUgen : U :e generated_topology X C.
  claim HUsubX : U c= X.
  { exact (PowerE X U (SepE1 (Power X)
                            (fun U0 : set => forall x0 :e U0, exists b0 :e C, x0 :e b0 /\ b0 c= U0)
                            U HUgen)). }
  claim HUprop : forall x :e U, exists c :e C, x :e c /\ c c= U.
  { exact (SepE2 (Power X)
                 (fun U0 : set => forall x0 :e U0, exists b0 :e C, x0 :e b0 /\ b0 c= U0)
                 U HUgen). }
  set Fam : set := {c :e C|c c= U}.
  claim HFamSubC : Fam c= C.
  { let c. assume HcFam.
    exact (SepE1 C (fun c0 : set => c0 c= U) c HcFam). }
  claim HFamSubT : Fam c= T.
  { let c. assume HcFam.
    claim HcC : c :e C.
    { exact (HFamSubC c HcFam). }
    exact (HCsub c HcC). }
  claim HFamPowT : Fam :e Power T.
  { exact (PowerI T Fam HFamSubT). }
  claim HUnionSubU : Union Fam c= U.
  { let x. assume HxUnion.
    apply UnionE_impred Fam x HxUnion.
    let c. assume Hxc HcFam.
    claim Hcprop : c c= U.
    { exact (SepE2 C (fun c0 : set => c0 c= U) c HcFam). }
    exact (Hcprop x Hxc). }
  claim HUsubUnion : U c= Union Fam.
  { let x. assume HxU.
    claim Hex : exists c :e C, x :e c /\ c c= U.
    { exact (HUprop x HxU). }
    apply Hex.
    let c. assume Hcpair.
    claim HcC : c :e C.
    { exact (andEL (c :e C) (x :e c /\ c c= U) Hcpair). }
    claim Hcprop : x :e c /\ c c= U.
    { exact (andER (c :e C) (x :e c /\ c c= U) Hcpair). }
    claim Hxc : x :e c.
    { exact (andEL (x :e c) (c c= U) Hcprop). }
    claim HcsubU : c c= U.
    { exact (andER (x :e c) (c c= U) Hcprop). }
    claim HcFam : c :e Fam.
    { exact (SepI C (fun c0 : set => c0 c= U) c HcC HcsubU). }
    exact (UnionI Fam x c Hxc HcFam). }
  claim HUnionEqU : Union Fam = U.
  { apply set_ext.
    - let x. assume HxUnion.
      exact (HUnionSubU x HxUnion).
    - let x. assume HxU.
      exact (HUsubUnion x HxU). }
  claim HUnionInT : Union Fam :e T.
  { exact (HUnionClosed Fam HFamPowT). }
  rewrite <- HUnionEqU.
  exact HUnionInT. }
claim HT_sub_gen : T c= generated_topology X C.
{ let U. assume HU : U :e T.
  claim HUsubX : U c= X.
  { exact (PowerE X U (HTsubPow U HU)). }
  claim HUprop : forall x :e U, exists c :e C, x :e c /\ c c= U.
  { let x. assume HxU.
    exact (Href U HU x HxU). }
  exact (SepI (Power X)
              (fun U0 : set => forall x0 :e U0, exists b0 :e C, x0 :e b0 /\ b0 c= U0)
              U
              (PowerI X U HUsubX)
              HUprop). }
claim HEqual : generated_topology X C = T.
{ apply set_ext.
  - let U. assume HUgen.
    exact (Hgen_sub_T U HUgen).
  - let U. assume HU.
    exact (HT_sub_gen U HU). }
apply andI.
- exact HBasis.
- exact HEqual.
Qed.

(** from 13 Lemma 13.2 (alias): open refinement family yields a basis **) 
(** LATEX VERSION: Rephrasing Lemma 13.2: a subcollection C of opens that locally refines every open is a basis generating T. **)
Theorem lemma13_2_basis_from_open_subcollection : forall X T C:set,
  topology_on X T ->
  (forall c :e C, c :e T) ->
  (forall U :e T, forall x :e U, exists c :e C, x :e c /\ c c= U) ->
  basis_on X C /\ generated_topology X C = T.
let X T C. assume Htop HCsub Href.
exact (basis_refines_topology X T C Htop HCsub Href).
Qed.

(** from 13: criterion for fineness via bases **) 
(** LATEX VERSION: Lemma 13.3 ( direction): If every basis element of B around x contains a basis element of B at x, then the topology from B is finer than that from B. **)
Theorem finer_via_basis : forall X B B':set,
  basis_on X B -> basis_on X B' ->
  (forall x :e X, forall b:set, b :e B -> x :e b ->
      exists b' :e B', x :e b' /\ b' c= b) ->
  finer_than (generated_topology X B') (generated_topology X B).
let X B B'. assume HB HB' Hcond.
claim HT : topology_on X (generated_topology X B).
{ exact (lemma_topology_from_basis X B HB). }
claim HRefProp : forall U :e generated_topology X B, forall x :e U, exists b' :e B', x :e b' /\ b' c= U.
{ let U. assume HU : U :e generated_topology X B.
  let x. assume HxU.
  claim HUsubX : U c= X.
  { exact (PowerE X U (SepE1 (Power X)
                             (fun U0 : set => forall x0 :e U0, exists b :e B, x0 :e b /\ b c= U0)
                             U HU)). }
  claim HxX : x :e X.
  { exact (HUsubX x HxU). }
  claim HUprop : forall x0 :e U, exists b :e B, x0 :e b /\ b c= U.
  { exact (SepE2 (Power X)
                 (fun U0 : set => forall x0 :e U0, exists b :e B, x0 :e b /\ b c= U0)
                 U HU). }
  claim Hexb : exists b :e B, x :e b /\ b c= U.
  { exact (HUprop x HxU). }
  apply Hexb.
  let b. assume Hbpair.
  claim HbB : b :e B.
  { exact (andEL (b :e B) (x :e b /\ b c= U) Hbpair). }
  claim Hbprop : x :e b /\ b c= U.
  { exact (andER (b :e B) (x :e b /\ b c= U) Hbpair). }
  claim Hxb : x :e b.
  { exact (andEL (x :e b) (b c= U) Hbprop). }
  claim HbsubU : b c= U.
  { exact (andER (x :e b) (b c= U) Hbprop). }
  claim Hexb' : exists b' :e B', x :e b' /\ b' c= b.
  { exact (Hcond x HxX b HbB Hxb). }
  apply Hexb'.
  let b'. assume Hb'pair.
  claim Hb'B : b' :e B'.
  { exact (andEL (b' :e B') (x :e b' /\ b' c= b) Hb'pair). }
  claim Hb'prop : x :e b' /\ b' c= b.
  { exact (andER (b' :e B') (x :e b' /\ b' c= b) Hb'pair). }
  claim Hxb' : x :e b'.
  { exact (andEL (x :e b') (b' c= b) Hb'prop). }
  claim Hb'subb : b' c= b.
  { exact (andER (x :e b') (b' c= b) Hb'prop). }
  witness b'.
  apply andI.
  - exact Hb'B.
  - apply andI.
    * exact Hxb'.
    * exact (Subq_tra b' b U Hb'subb HbsubU). }
prove generated_topology X B c= generated_topology X B'.
  let U. assume HU.
  claim HUsubX : U c= X.
  { exact (PowerE X U (SepE1 (Power X)
                             (fun U0 : set => forall x0 :e U0, exists b0 :e B, x0 :e b0 /\ b0 c= U0)
                             U HU)). }
  claim HUprop : forall x :e U, exists b' :e B', x :e b' /\ b' c= U.
  { exact (HRefProp U HU). }
  exact (SepI (Power X)
              (fun U0 : set => forall x0 :e U0, exists b0 :e B', x0 :e b0 /\ b0 c= U0)
              U
              (PowerI X U HUsubX)
              HUprop).
Qed.

(** from 13 Lemma 13.3: basis inclusion criterion for fineness **) 
(** LATEX VERSION: Lemma 13.3: T(B) finer than T(B) iff each basis element of B has for every xb some bB with xbb. **)
Theorem basis_finer_equiv_condition : forall X B B':set,
  basis_on X B -> basis_on X B' ->
  ((forall x :e X, forall b :e B, x :e b -> exists b' :e B', x :e b' /\ b' c= b) <->
  finer_than (generated_topology X B') (generated_topology X B)).
let X B B'. assume HB HB'.
apply iffI.
- assume Hcond.
  exact (finer_via_basis X B B' HB HB' Hcond).
- assume Hfiner.
  let x. assume HxX. let b. assume HbB Hxb.
  claim HbGen : b :e generated_topology X B.
  { exact (generated_topology_contains_basis X B HB b HbB). }
  claim HbGen' : b :e generated_topology X B'.
  { exact (Hfiner b HbGen). }
  claim Hbprop : forall x0 :e b, exists b' :e B', x0 :e b' /\ b' c= b.
  { exact (SepE2 (Power X)
                 (fun U0 : set => forall x0 :e U0, exists b0 :e B', x0 :e b0 /\ b0 c= U0)
                 b HbGen'). }
  exact (Hbprop x Hxb).
Qed.

(** from 13 Lemma 13.3 (direction): generated topology is minimal containing basis **) 
(** LATEX VERSION: If T is a topology on X containing every basis element of B, then T is finer than the topology generated by B. **)
Theorem generated_topology_finer : forall X B T:set,
  basis_on X B -> topology_on X T ->
  (forall b :e B, b :e T) ->
  finer_than T (generated_topology X B).
let X B T. assume HBasis HT HBsub.
claim HUnionClosed : forall Fam :e Power T, Union Fam :e T.
{ exact (andER ((T c= Power X /\ Empty :e T) /\ X :e T) (forall Fam :e Power T, Union Fam :e T)
               (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall Fam :e Power T, Union Fam :e T))
                      (forall U :e T, forall V :e T, U :/\: V :e T)
                      HT)). }
prove generated_topology X B c= T.
  let U. assume HU.
  claim HUsubX : U c= X.
  { exact (PowerE X U (SepE1 (Power X)
                             (fun U0 : set => forall x0 :e U0, exists b0 :e B, x0 :e b0 /\ b0 c= U0)
                             U HU)). }
  claim HUprop : forall x :e U, exists b :e B, x :e b /\ b c= U.
  { exact (SepE2 (Power X)
                 (fun U0 : set => forall x0 :e U0, exists b0 :e B, x0 :e b0 /\ b0 c= U0)
                 U HU). }
  set Fam : set := {b :e B|b c= U}.
  claim HFamPowB : Fam :e Power B.
  { apply PowerI B Fam.
    let b. assume HbFam.
    exact (SepE1 B (fun b0 : set => b0 c= U) b HbFam). }
  claim HUnionEq : Union Fam = U.
  { apply set_ext.
    - let x. assume HxUnion.
      apply UnionE_impred Fam x HxUnion.
      let b. assume Hxb HbFam.
      claim HbsubU : b c= U.
      { exact (SepE2 B (fun b0 : set => b0 c= U) b HbFam). }
      exact (HbsubU x Hxb).
    - let x. assume HxU.
      claim Hexb : exists b :e B, x :e b /\ b c= U.
      { exact (HUprop x HxU). }
      apply Hexb.
      let b. assume Hbpair.
      claim HbB : b :e B.
      { exact (andEL (b :e B) (x :e b /\ b c= U) Hbpair). }
      claim Hbprop : x :e b /\ b c= U.
      { exact (andER (b :e B) (x :e b /\ b c= U) Hbpair). }
      claim Hxb : x :e b.
      { exact (andEL (x :e b) (b c= U) Hbprop). }
      claim HbsubU : b c= U.
      { exact (andER (x :e b) (b c= U) Hbprop). }
      claim HbT : b :e T.
      { exact (HBsub b HbB). }
      claim HbFam : b :e Fam.
      { exact (SepI B (fun b0 : set => b0 c= U) b HbB HbsubU). }
      exact (UnionI Fam x b Hxb HbFam). }
  claim HFamPowT : Fam :e Power T.
  { apply PowerI T Fam.
    let b. assume HbFam.
    claim HbB : b :e B.
    { exact (SepE1 B (fun b0 : set => b0 c= U) b HbFam). }
    exact (HBsub b HbB). }
  claim HUnionT : Union Fam :e T.
  { exact (HUnionClosed Fam HFamPowT). }
  rewrite <- HUnionEq.
  exact HUnionT.
Qed.

(** from 13 Lemma 13.3 (direction): generated topology is smallest with given basis **) 
(** LATEX VERSION: Restates previous direction: the topology generated by B is the smallest topology containing B. **)
Theorem topology_generated_by_basis_is_smallest : forall X B T:set,
  basis_on X B -> topology_on X T ->
  (forall b :e B, b :e T) ->
  finer_than T (generated_topology X B).
let X B T. assume HBasis HT HBsub.
exact (generated_topology_finer X B T HBasis HT HBsub).
Qed.

(** from 13 Lemma 13.4: generated topology equals unions of basis elements **) 
(** LATEX VERSION: Lemma 13.4: The topology generated by B consists exactly of unions of subfamilies of B. **)
Theorem union_of_basis_equals_open :
  forall X B:set, basis_on X B ->
  generated_topology X B = {Union Fam | Fam :e Power B}.
let X B. assume HBasis.
apply set_ext.
- let U. assume HU.
  claim HUopen : open_in X (generated_topology X B) U.
  { exact (andI (topology_on X (generated_topology X B))
                 (U :e generated_topology X B)
                 (lemma_topology_from_basis X B HBasis)
                 HU). }
  claim HexFam : exists Fam :e Power B, Union Fam = U.
  { exact (open_sets_as_unions_of_basis X B HBasis U HUopen). }
  apply HexFam.
  let Fam. assume HFampair.
  claim HFamPow : Fam :e Power B.
  { exact (andEL (Fam :e Power B) (Union Fam = U) HFampair). }
  claim HUnion : Union Fam = U.
  { exact (andER (Fam :e Power B) (Union Fam = U) HFampair). }
  claim HUnionFam : Union Fam :e {Union Fam0 | Fam0 :e Power B}.
  { exact (ReplI (Power B) (fun Fam0 : set => Union Fam0) Fam HFamPow). }
  rewrite <- HUnion.
  exact HUnionFam.
- let U. assume HUUnion.
  claim HexFamPowRaw : exists Fam :e Power B, U = Union Fam.
  { exact (ReplE (Power B) (fun Fam0 : set => Union Fam0) U HUUnion). }
  claim HexFamPow : exists Fam :e Power B, Union Fam = U.
  { apply HexFamPowRaw.
    let Fam. assume HFamPair.
    claim HFamPow : Fam :e Power B.
    { exact (andEL (Fam :e Power B) (U = Union Fam) HFamPair). }
    claim HUnion : U = Union Fam.
    { exact (andER (Fam :e Power B) (U = Union Fam) HFamPair). }
    witness Fam.
    apply andI.
    - exact HFamPow.
    - rewrite <- HUnion.
      reflexivity. }
  claim HUopen : open_in X (generated_topology X B) U.
  { exact (basis_generates_open_sets X B HBasis U HexFamPow). }
  exact (andER (topology_on X (generated_topology X B))
               (U :e generated_topology X B)
               HUopen).
Qed.

(** from 13 Example 3: singleton basis **) 
(** LATEX VERSION: Example 3: the collection of all one-point subsets of X forms a basis. **)
Definition singleton_basis : set -> set := fun X => {{x,x}|x :e X}.

(** from 13 Example 3: singleton collection forms a basis **) 
(** LATEX VERSION: The collection of singletons on X satisfies the two basis axioms. **)
Theorem singleton_basis_is_basis : forall X:set, basis_on X (singleton_basis X).
let X.
prove ((singleton_basis X c= Power X
        /\ (forall x :e X, exists b :e singleton_basis X, x :e b))
       /\ (forall b1 :e singleton_basis X, forall b2 :e singleton_basis X, forall x:set,
              x :e b1 -> x :e b2 ->
              exists b3 :e singleton_basis X, x :e b3 /\ b3 c= b1 :/\: b2)).
apply andI.
- apply andI.
  * prove singleton_basis X c= Power X.
    let s. assume Hs.
    apply (ReplE_impred X (fun x0 : set => {x0,x0}) s Hs).
    let x. assume HxX Hseq.
    rewrite Hseq.
    apply PowerI.
    let y. assume Hy.
    apply (UPairE y x x Hy (y :e X)).
    - assume Hyx. rewrite Hyx. exact HxX.
    - assume Hyx. rewrite Hyx. exact HxX.
  * prove forall x :e X, exists b :e singleton_basis X, x :e b.
    let x. assume HxX.
    witness {x,x}.
    apply andI.
    * exact (ReplI X (fun x0 : set => {x0,x0}) x HxX).
    * apply UPairI1.
 - prove forall b1 :e singleton_basis X, forall b2 :e singleton_basis X, forall x:set,
            x :e b1 -> x :e b2 ->
            exists b3 :e singleton_basis X, x :e b3 /\ b3 c= b1 :/\: b2.
   let b1. assume Hb1.
   let b2. assume Hb2.
   let x. assume Hx1 Hx2.
   apply (ReplE_impred X (fun x0 : set => {x0,x0}) b1 Hb1).
   let x1. assume Hx1X Hb1eq.
   apply (ReplE_impred X (fun x0 : set => {x0,x0}) b2 Hb2).
   let x2. assume Hx2X Hb2eq.
   claim Hx1in : x :e {x1,x1}.
   { rewrite <- Hb1eq. exact Hx1. }
   claim Hx2in : x :e {x2,x2}.
   { rewrite <- Hb2eq. exact Hx2. }
   claim Hx_eq_x1 : x = x1.
   { apply (UPairE x x1 x1 Hx1in (x = x1)).
     - assume Hxx1. exact Hxx1.
     - assume Hxx1. exact Hxx1. }
   claim Hx_eq_x2 : x = x2.
   { apply (UPairE x x2 x2 Hx2in (x = x2)).
     - assume Hxx2. exact Hxx2.
     - assume Hxx2. exact Hxx2. }
   claim HxX : x :e X.
   { rewrite Hx_eq_x1. exact Hx1X. }
   witness {x,x}.
   apply andI.
   - exact (ReplI X (fun x0 : set => {x0,x0}) x HxX).
    - apply andI.
      + apply UPairI1.
      + prove {x,x} c= b1 :/\: b2.
       let y. assume Hy.
       apply (UPairE y x x Hy (y :e b1 :/\: b2)).
       - assume Hyx. rewrite Hyx.
         apply binintersectI.
         { exact Hx1. }
         { exact Hx2. }
       - assume Hyx. rewrite Hyx.
         apply binintersectI.
         { exact Hx1. }
         { exact Hx2. }
Qed.

(** from 13 Example 3: topology generated by singletons is discrete **) 
(** LATEX VERSION: The topology generated by the singleton basis is the discrete topology on X. **)
Theorem generated_topology_singletons_discrete : forall X:set,
  generated_topology X (singleton_basis X) = discrete_topology X.
let X.
apply set_ext.
- let U. assume HUgen.
  exact (SepE1 (Power X)
               (fun U0 : set => forall x0 :e U0, exists b :e singleton_basis X, x0 :e b /\ b c= U0)
               U HUgen).
- let U. assume HUinPow : U :e Power X.
  claim HUsubX : U c= X.
  { exact (PowerE X U HUinPow). }
  claim HUprop : forall x :e U, exists b :e singleton_basis X, x :e b /\ b c= U.
{ let x. assume HxU.
  witness {x,x}.
  apply andI.
  - exact (ReplI X (fun x0 : set => {x0,x0}) x (HUsubX x HxU)).
  - apply andI.
    * exact (UPairI1 x x).
    * let y. assume Hy.
      apply (UPairE y x x Hy (y :e U)).
      { assume Hyx. rewrite Hyx. exact HxU. }
      { assume Hyx. rewrite Hyx. exact HxU. } }
  exact (SepI (Power X)
              (fun U0 : set => forall x0 :e U0, exists b :e singleton_basis X, x0 :e b /\ b c= U0)
              U
              HUinPow
              HUprop).
Qed.

(** Misleading "OrderedPair" definition eliminated. Cartesian products use
    setprod (defined at line 2717). Individual ordered pairs use tuple notation (x,y). **)

(** ambient real line **) 
Definition R : set := real.

(** rational numbers as subset of reals **)
(** LATEX VERSION: The rationals  as a subset of . **)
(** FIXED: Now uses proper rational definition from line 6202.
    rational = {x :e real | exists m :e int, exists n :e omega\{0}, x = m/n} **)
Definition Q : set := rational.

(** ordering relation on the reals **) 
Definition Rlt : set -> set -> prop := fun a b =>
  a :e R /\ b :e R /\ a < b.

(** helper: non-strict order on the reals by negating strict order **)
(** LATEX VERSION: Write a  b for not(b < a) in the ambient strict order on . **)
Definition Rle : set -> set -> prop := fun a b =>
  a :e R /\ b :e R /\ ~(Rlt b a).

(** helper introduction rule for Rle **)
Theorem RleI : forall a b:set, a :e R -> b :e R -> ~(Rlt b a) -> Rle a b.
let a b. assume Ha Hb Hnlt.
prove a :e R /\ b :e R /\ ~(Rlt b a).
apply andI.
- apply andI.
  + exact Ha.
  + exact Hb.
- exact Hnlt.
Qed.

(** helper elimination rules for Rle **)
Theorem RleE_left : forall a b:set, Rle a b -> a :e R.
let a b. assume H.
exact (andEL (a :e R) (b :e R) (andEL (a :e R /\ b :e R) (~(Rlt b a)) H)).
Qed.

(** helper elimination rules for Rle **)
Theorem RleE_right : forall a b:set, Rle a b -> b :e R.
let a b. assume H.
exact (andER (a :e R) (b :e R) (andEL (a :e R /\ b :e R) (~(Rlt b a)) H)).
Qed.

(** helper elimination rules for Rle **)
Theorem RleE_nlt : forall a b:set, Rle a b -> ~(Rlt b a).
let a b. assume H.
exact (andER (a :e R /\ b :e R) (~(Rlt b a)) H).
Qed.

(** from 13 Example 4: helper introduction rule for Rlt **)
(** LATEX VERSION: We use the usual convention a<b implies a and b are reals and a<b. **)
Theorem RltI : forall a b:set, a :e R -> b :e R -> a < b -> Rlt a b.
let a b. assume Ha Hb Hab.
prove a :e R /\ b :e R /\ a < b.
apply andI.
- apply andI.
  + exact Ha.
  + exact Hb.
- exact Hab.
Qed.

(** from 13 Example 4: helper elimination rules for Rlt **)
(** LATEX VERSION: If Rlt a b then a and b are reals and a<b. **)
Theorem RltE_left : forall a b:set, Rlt a b -> a :e R.
let a b. assume H.
exact (andEL (a :e R) (b :e R) (andEL (a :e R /\ b :e R) (a < b) H)).
Qed.

(** from 13 Example 4: helper elimination rules for Rlt **)
(** LATEX VERSION: If Rlt a b then a and b are reals and a<b. **)
Theorem RltE_right : forall a b:set, Rlt a b -> b :e R.
let a b. assume H.
exact (andER (a :e R) (b :e R) (andEL (a :e R /\ b :e R) (a < b) H)).
Qed.

(** from 13 Example 4: helper elimination rules for Rlt **)
(** LATEX VERSION: If Rlt a b then a and b are reals and a<b. **)
Theorem RltE_lt : forall a b:set, Rlt a b -> a < b.
let a b. assume H.
exact (andER (a :e R /\ b :e R) (a < b) H).
Qed.

(** helper: transitivity of Rlt **)
(** LATEX VERSION: If a<b and b<c then a<c. **)
Theorem Rlt_tra : forall a b c:set, Rlt a b -> Rlt b c -> Rlt a c.
let a b c. assume Hab Hbc.
claim HaR : a :e R.
{ exact (RltE_left a b Hab). }
claim HbR : b :e R.
{ exact (RltE_right a b Hab). }
claim HcR : c :e R.
{ exact (RltE_right b c Hbc). }
claim Hablt : a < b.
{ exact (RltE_lt a b Hab). }
claim Hbclt : b < c.
{ exact (RltE_lt b c Hbc). }
claim HaS : SNo a.
{ exact (real_SNo a HaR). }
claim HbS : SNo b.
{ exact (real_SNo b HbR). }
claim HcS : SNo c.
{ exact (real_SNo c HcR). }
claim Haclt : a < c.
{ exact (SNoLt_tra a b c HaS HbS HcS Hablt Hbclt). }
exact (RltI a c HaR HcR Haclt).
Qed.

(** from 13 Example 4: Rlt is irreflexive **)
(** LATEX VERSION: We use that a<a is impossible. **)
Theorem not_Rlt_refl : forall a:set, a :e R -> ~(Rlt a a).
let a. assume Ha.
assume Haa.
claim Hlt : a < a.
{ exact (RltE_lt a a Haa). }
exact ((SNoLt_irref a) Hlt).
Qed.

(** helper: asymmetry of Rlt **)
(** LATEX VERSION: If a<b then not(b<a). **)
Theorem not_Rlt_sym : forall a b:set, Rlt a b -> ~(Rlt b a).
let a b. assume Hab.
assume Hba.
claim Haa: Rlt a a.
{ exact (Rlt_tra a b a Hab Hba). }
exact (not_Rlt_refl a (RltE_left a b Hab) Haa).
Qed.

(** helper: strict order implies non-strict order **)
Theorem Rlt_implies_Rle : forall a b:set, Rlt a b -> Rle a b.
let a b. assume Hab.
apply (RleI a b (RltE_left a b Hab) (RltE_right a b Hab)).
exact (not_Rlt_sym a b Hab).
Qed.

(** helper: reflexivity of Rle **)
(** LATEX VERSION: a  a. **)
Theorem Rle_refl : forall a:set, a :e R -> Rle a a.
let a. assume Ha.
apply (RleI a a Ha Ha).
exact (not_Rlt_refl a Ha).
Qed.

(** helper for 13 Example 4: 0 < 1 in Rlt form **)
(** LATEX VERSION: We use 0<1 in the usual order on R. **)
Theorem Rlt_0_1 : Rlt 0 1.
exact (RltI 0 1 real_0 real_1 SNoLt_0_1).
Qed.

(** from 13 Example 4: -1 is less than 0 in  **)
(** LATEX VERSION: We use that -1 < 0. **)
Theorem minus_1_lt_0 : minus_SNo 1 < 0.
claim H01 : 0 < 1.
{ exact SNoLt_0_1. }
claim Hm1ltm0 : minus_SNo 1 < minus_SNo 0.
{ exact (minus_SNo_Lt_contra 0 1 SNo_0 SNo_1 H01). }
rewrite <- (minus_SNo_0) at 2.
exact Hm1ltm0.
Qed.

(** from 13 Example 4: circular vs rectangular region bases **)
(** LATEX VERSION: Example 4: circular regions and axis-parallel rectangular regions in  both form bases generating the same topology. **)
(** FIXED: EuclidPlane is now correctly RR (Cartesian product) since setprod = setprod. **)
Definition EuclidPlane : set := setprod R R.
(** Coordinate selectors for points in EuclidPlane. **)
Definition R2_xcoord : set -> set := fun p => p 0.
Definition R2_ycoord : set -> set := fun p => p 1.

(** from 13 Example 4: coordinates of a point in RR are real **)
(** LATEX VERSION: If p   then its coordinates lie in . **)
Theorem EuclidPlane_xcoord_in_R : forall p:set, p :e EuclidPlane -> R2_xcoord p :e R.
let p. assume Hp.
prove p 0 :e R.
exact (ap0_Sigma R (fun _ : set => R) p Hp).
Qed.

(** from 13 Example 4: coordinates of a point in RR are real **)
(** LATEX VERSION: If p   then its coordinates lie in . **)
Theorem EuclidPlane_ycoord_in_R : forall p:set, p :e EuclidPlane -> R2_ycoord p :e R.
let p. assume Hp.
prove p 1 :e R.
claim Hp1 : p 1 :e (fun _ : set => R) (p 0).
{ exact (ap1_Sigma R (fun _ : set => R) p Hp). }
exact Hp1.
Qed.

(** from 13 Example 4: coordinate selectors on tuples **)
(** LATEX VERSION: For a point (x,y), the coordinate maps return x and y. **)
Theorem R2_xcoord_tuple : forall x y:set, R2_xcoord (x,y) = x.
let x y.
prove (x,y) 0 = x.
rewrite <- (tuple_pair x y).
exact (pair_ap_0 x y).
Qed.

(** from 13 Example 4: coordinate selectors on tuples **)
(** LATEX VERSION: For a point (x,y), the coordinate maps return x and y. **)
Theorem R2_ycoord_tuple : forall x y:set, R2_ycoord (x,y) = y.
let x y.
prove (x,y) 1 = y.
rewrite <- (tuple_pair x y).
exact (pair_ap_1 x y).
Qed.

(** from 13 Example 4: equality of points in RR is coordinatewise **)
(** LATEX VERSION: If (x1,y1) = (x2,y2) then x1=x2 and y1=y2. **)
Theorem tuple_eq_coords_R2 : forall x1 y1 x2 y2:set,
  (x1,y1) = (x2,y2) -> x1 = x2 /\ y1 = y2.
let x1 y1 x2 y2. assume Heq.
apply andI.
- prove x1 = x2.
  rewrite <- (R2_xcoord_tuple x1 y1).
  rewrite <- (R2_xcoord_tuple x2 y2).
  rewrite Heq.
  reflexivity.
- prove y1 = y2.
  rewrite <- (R2_ycoord_tuple x1 y1).
  rewrite <- (R2_ycoord_tuple x2 y2).
  rewrite Heq.
  reflexivity.
Qed.

(** Euclidean distance in : sqrt((x1-x2)^2 + (y1-y2)^2),
    implemented using pre-topology surreal/real operations. **)
Definition distance_R2 : set -> set -> set := fun p c =>
  sqrt_SNo_nonneg
    (add_SNo
      (mul_SNo (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c)))
              (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c))))
      (mul_SNo (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c)))
              (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c))))).

(** from 13 Example 4: distance is real-valued **)
(** LATEX VERSION: For points p,c in RR, the distance d(p,c) is a real number. **)
Theorem distance_R2_in_R : forall p c:set, p :e EuclidPlane -> c :e EuclidPlane -> distance_R2 p c :e R.
let p c. assume Hp Hc.
(** coordinates are real **)
claim Hp0R : R2_xcoord p :e R.
{ exact (EuclidPlane_xcoord_in_R p Hp). }
claim Hp1R : R2_ycoord p :e R.
{ exact (EuclidPlane_ycoord_in_R p Hp). }
claim Hc0R : R2_xcoord c :e R.
{ exact (EuclidPlane_xcoord_in_R c Hc). }
claim Hc1R : R2_ycoord c :e R.
{ exact (EuclidPlane_ycoord_in_R c Hc). }
(** differences in R **)
set dx := add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c)).
set dy := add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c)).
claim Hmx : minus_SNo (R2_xcoord c) :e R.
{ exact (real_minus_SNo (R2_xcoord c) Hc0R). }
claim Hmy : minus_SNo (R2_ycoord c) :e R.
{ exact (real_minus_SNo (R2_ycoord c) Hc1R). }
claim HdxR : dx :e R.
{ exact (real_add_SNo (R2_xcoord p) Hp0R (minus_SNo (R2_xcoord c)) Hmx). }
claim HdyR : dy :e R.
{ exact (real_add_SNo (R2_ycoord p) Hp1R (minus_SNo (R2_ycoord c)) Hmy). }
(** squares and sum in R **)
set dx2 := mul_SNo dx dx.
set dy2 := mul_SNo dy dy.
claim Hdx2def : dx2 = mul_SNo dx dx.
{ reflexivity. }
claim Hdy2def : dy2 = mul_SNo dy dy.
{ reflexivity. }
claim Hdx2R : dx2 :e R.
{ exact (real_mul_SNo dx HdxR dx HdxR). }
claim Hdy2R : dy2 :e R.
{ exact (real_mul_SNo dy HdyR dy HdyR). }
set sum := add_SNo dx2 dy2.
claim Hsumdef : sum = add_SNo dx2 dy2.
{ reflexivity. }
claim HsumR : sum :e R.
{ exact (real_add_SNo dx2 Hdx2R dy2 Hdy2R). }
(** nonnegativity of squares and of the sum **)
claim HdxS : SNo dx.
{ exact (real_SNo dx HdxR). }
claim HdyS : SNo dy.
{ exact (real_SNo dy HdyR). }
claim Hdx2S : SNo dx2.
{ exact (real_SNo dx2 Hdx2R). }
claim Hdy2S : SNo dy2.
{ exact (real_SNo dy2 Hdy2R). }
claim Hdx2nonneg : 0 <= dx2.
{ claim H0or : dx = 0 \/ 0 < (mul_SNo dx dx).
  { exact (SNo_zero_or_sqr_pos dx HdxS). }
  apply H0or.
  - assume Hdx0 : dx = 0.
    rewrite Hdx2def.
    rewrite Hdx0.
    rewrite (mul_SNo_zeroL 0 SNo_0).
    exact (SNoLe_ref 0).
  - assume Hpos : 0 < (mul_SNo dx dx).
    rewrite Hdx2def.
    exact (SNoLtLe 0 (mul_SNo dx dx) Hpos).
}
claim Hdy2nonneg : 0 <= dy2.
{ claim H0or : dy = 0 \/ 0 < (mul_SNo dy dy).
  { exact (SNo_zero_or_sqr_pos dy HdyS). }
  apply H0or.
  - assume Hdy0 : dy = 0.
    rewrite Hdy2def.
    rewrite Hdy0.
    rewrite (mul_SNo_zeroL 0 SNo_0).
    exact (SNoLe_ref 0).
  - assume Hpos : 0 < (mul_SNo dy dy).
    rewrite Hdy2def.
    exact (SNoLtLe 0 (mul_SNo dy dy) Hpos).
}
claim HsumNonneg : 0 <= sum.
{ rewrite Hsumdef.
  rewrite <- (add_SNo_0L 0 SNo_0) at 1.
  exact (add_SNo_Le3 0 0 dx2 dy2 SNo_0 SNo_0 Hdx2S Hdy2S Hdx2nonneg Hdy2nonneg).
}
(** unfold distance_R2 and apply sqrt real lemma **)
claim Hdef : distance_R2 p c = sqrt_SNo_nonneg sum.
{ reflexivity. }
rewrite Hdef.
exact (sqrt_SNo_nonneg_real sum HsumR HsumNonneg).
Qed.

(** from 13 Example 4: distance is nonnegative **)
(** LATEX VERSION: The distance function takes nonnegative values. **)
Theorem distance_R2_nonneg : forall p c:set, p :e EuclidPlane -> c :e EuclidPlane -> 0 <= distance_R2 p c.
let p c. assume Hp Hc.
(** coordinates are real **)
claim Hp0R : R2_xcoord p :e R.
{ exact (EuclidPlane_xcoord_in_R p Hp). }
claim Hp1R : R2_ycoord p :e R.
{ exact (EuclidPlane_ycoord_in_R p Hp). }
claim Hc0R : R2_xcoord c :e R.
{ exact (EuclidPlane_xcoord_in_R c Hc). }
claim Hc1R : R2_ycoord c :e R.
{ exact (EuclidPlane_ycoord_in_R c Hc). }
(** differences **)
set dx := add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c)).
set dy := add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c)).
claim Hmx : minus_SNo (R2_xcoord c) :e R.
{ exact (real_minus_SNo (R2_xcoord c) Hc0R). }
claim Hmy : minus_SNo (R2_ycoord c) :e R.
{ exact (real_minus_SNo (R2_ycoord c) Hc1R). }
claim HdxR : dx :e R.
{ exact (real_add_SNo (R2_xcoord p) Hp0R (minus_SNo (R2_xcoord c)) Hmx). }
claim HdyR : dy :e R.
{ exact (real_add_SNo (R2_ycoord p) Hp1R (minus_SNo (R2_ycoord c)) Hmy). }
(** squares and sum **)
set dx2 := mul_SNo dx dx.
set dy2 := mul_SNo dy dy.
claim Hdx2R : dx2 :e R.
{ exact (real_mul_SNo dx HdxR dx HdxR). }
claim Hdy2R : dy2 :e R.
{ exact (real_mul_SNo dy HdyR dy HdyR). }
set sum := add_SNo dx2 dy2.
claim HsumR : sum :e R.
{ exact (real_add_SNo dx2 Hdx2R dy2 Hdy2R). }
claim HdxS : SNo dx.
{ exact (real_SNo dx HdxR). }
claim HdyS : SNo dy.
{ exact (real_SNo dy HdyR). }
claim Hdx2S : SNo dx2.
{ exact (real_SNo dx2 Hdx2R). }
claim Hdy2S : SNo dy2.
{ exact (real_SNo dy2 Hdy2R). }
claim HsumS : SNo sum.
{ exact (real_SNo sum HsumR). }
(** nonnegativity of squares and of the sum **)
claim Hdx2nonneg : 0 <= dx2.
{ claim H0or : dx = 0 \/ 0 < (mul_SNo dx dx).
  { exact (SNo_zero_or_sqr_pos dx HdxS). }
  apply H0or.
  - assume Hdx0 : dx = 0.
    rewrite Hdx0.
    rewrite (mul_SNo_zeroL 0 SNo_0).
    exact (SNoLe_ref 0).
  - assume Hpos : 0 < (mul_SNo dx dx).
    exact (SNoLtLe 0 (mul_SNo dx dx) Hpos).
}
claim Hdy2nonneg : 0 <= dy2.
{ claim H0or : dy = 0 \/ 0 < (mul_SNo dy dy).
  { exact (SNo_zero_or_sqr_pos dy HdyS). }
  apply H0or.
  - assume Hdy0 : dy = 0.
    rewrite Hdy0.
    rewrite (mul_SNo_zeroL 0 SNo_0).
    exact (SNoLe_ref 0).
  - assume Hpos : 0 < (mul_SNo dy dy).
    exact (SNoLtLe 0 (mul_SNo dy dy) Hpos).
}
claim HsumNonneg : 0 <= sum.
{ rewrite <- (add_SNo_0L 0 SNo_0) at 1.
  exact (add_SNo_Le3 0 0 dx2 dy2 SNo_0 SNo_0 Hdx2S Hdy2S Hdx2nonneg Hdy2nonneg).
}
(** conclude using sqrt nonnegativity **)
claim Hdef : distance_R2 p c = sqrt_SNo_nonneg sum.
{ reflexivity. }
rewrite Hdef.
exact (sqrt_SNo_nonneg_nonneg sum HsumS HsumNonneg).
Qed.

(** from 13 Example 4: squared distance formula **)
(** LATEX VERSION: d(p,c) squared equals (xp-xc) squared plus (yp-yc) squared. **)
Theorem distance_R2_sqr : forall p c:set, p :e EuclidPlane -> c :e EuclidPlane ->
  mul_SNo (distance_R2 p c) (distance_R2 p c)
  = add_SNo
      (mul_SNo (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c)))
              (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c))))
      (mul_SNo (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c)))
              (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c)))).
let p c. assume Hp Hc.
(** establish that the sum under the square root is surreal and nonnegative **)
claim Hp0R : R2_xcoord p :e R.
{ exact (EuclidPlane_xcoord_in_R p Hp). }
claim Hp1R : R2_ycoord p :e R.
{ exact (EuclidPlane_ycoord_in_R p Hp). }
claim Hc0R : R2_xcoord c :e R.
{ exact (EuclidPlane_xcoord_in_R c Hc). }
claim Hc1R : R2_ycoord c :e R.
{ exact (EuclidPlane_ycoord_in_R c Hc). }
set dx := add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c)).
set dy := add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c)).
claim Hmx : minus_SNo (R2_xcoord c) :e R.
{ exact (real_minus_SNo (R2_xcoord c) Hc0R). }
claim Hmy : minus_SNo (R2_ycoord c) :e R.
{ exact (real_minus_SNo (R2_ycoord c) Hc1R). }
claim HdxR : dx :e R.
{ exact (real_add_SNo (R2_xcoord p) Hp0R (minus_SNo (R2_xcoord c)) Hmx). }
claim HdyR : dy :e R.
{ exact (real_add_SNo (R2_ycoord p) Hp1R (minus_SNo (R2_ycoord c)) Hmy). }
set dx2 := mul_SNo dx dx.
set dy2 := mul_SNo dy dy.
claim Hdx2R : dx2 :e R.
{ exact (real_mul_SNo dx HdxR dx HdxR). }
claim Hdy2R : dy2 :e R.
{ exact (real_mul_SNo dy HdyR dy HdyR). }
set sum := add_SNo dx2 dy2.
claim HsumR : sum :e R.
{ exact (real_add_SNo dx2 Hdx2R dy2 Hdy2R). }
claim HsumS : SNo sum.
{ exact (real_SNo sum HsumR). }
claim HdxS : SNo dx.
{ exact (real_SNo dx HdxR). }
claim HdyS : SNo dy.
{ exact (real_SNo dy HdyR). }
claim Hdx2S : SNo dx2.
{ exact (real_SNo dx2 Hdx2R). }
claim Hdy2S : SNo dy2.
{ exact (real_SNo dy2 Hdy2R). }
claim Hdx2nonneg : 0 <= dx2.
{ claim H0or : dx = 0 \/ 0 < (mul_SNo dx dx).
  { exact (SNo_zero_or_sqr_pos dx HdxS). }
  apply H0or.
  - assume Hdx0 : dx = 0.
    rewrite Hdx0.
    rewrite (mul_SNo_zeroL 0 SNo_0).
    exact (SNoLe_ref 0).
  - assume Hpos : 0 < (mul_SNo dx dx).
    exact (SNoLtLe 0 (mul_SNo dx dx) Hpos).
}
claim Hdy2nonneg : 0 <= dy2.
{ claim H0or : dy = 0 \/ 0 < (mul_SNo dy dy).
  { exact (SNo_zero_or_sqr_pos dy HdyS). }
  apply H0or.
  - assume Hdy0 : dy = 0.
    rewrite Hdy0.
    rewrite (mul_SNo_zeroL 0 SNo_0).
    exact (SNoLe_ref 0).
  - assume Hpos : 0 < (mul_SNo dy dy).
    exact (SNoLtLe 0 (mul_SNo dy dy) Hpos).
}
claim HsumNonneg : 0 <= sum.
{ rewrite <- (add_SNo_0L 0 SNo_0) at 1.
  exact (add_SNo_Le3 0 0 dx2 dy2 SNo_0 SNo_0 Hdx2S Hdy2S Hdx2nonneg Hdy2nonneg).
}
(** unfold distance_R2 and use the square root squaring lemma **)
claim Hdef : distance_R2 p c = sqrt_SNo_nonneg sum.
{ reflexivity. }
rewrite Hdef.
rewrite (sqrt_SNo_nonneg_sqr sum HsumS HsumNonneg).
(** unfold sum, dx2, dy2 **)
reflexivity.
Qed.

(** from 13 Example 4: distance from a point to itself is 0 **)
(** LATEX VERSION: d(p,p) = 0. **)
Theorem distance_R2_refl_0 : forall p:set, p :e EuclidPlane -> distance_R2 p p = 0.
let p. assume Hp.
claim Hp0R : R2_xcoord p :e R.
{ exact (EuclidPlane_xcoord_in_R p Hp). }
claim Hp1R : R2_ycoord p :e R.
{ exact (EuclidPlane_ycoord_in_R p Hp). }
claim Hp0S : SNo (R2_xcoord p).
{ exact (real_SNo (R2_xcoord p) Hp0R). }
claim Hp1S : SNo (R2_ycoord p).
{ exact (real_SNo (R2_ycoord p) Hp1R). }
claim Hdx : add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord p)) = 0.
{ exact (add_SNo_minus_SNo_rinv (R2_xcoord p) Hp0S). }
claim Hdy : add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord p)) = 0.
{ exact (add_SNo_minus_SNo_rinv (R2_ycoord p) Hp1S). }
claim Hdx2 : mul_SNo (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord p)))
                     (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord p))) = 0.
{ rewrite Hdx.
  exact (mul_SNo_zeroR 0 SNo_0). }
claim Hdy2 : mul_SNo (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord p)))
                     (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord p))) = 0.
{ rewrite Hdy.
  exact (mul_SNo_zeroR 0 SNo_0). }
claim Hsum : add_SNo (mul_SNo (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord p)))
                              (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord p))))
                     (mul_SNo (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord p)))
                              (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord p)))) = 0.
{ rewrite Hdx2.
  rewrite Hdy2.
  exact (add_SNo_0L 0 SNo_0). }
claim Hdef : distance_R2 p p =
  sqrt_SNo_nonneg
    (add_SNo
      (mul_SNo (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord p)))
              (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord p))))
      (mul_SNo (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord p)))
              (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord p))))).
{ reflexivity. }
rewrite Hdef.
rewrite Hsum.
rewrite sqrt_SNo_nonneg_0.
reflexivity.
Qed.

(** from 13 Example 4: symmetry of Euclidean distance in R^2 **)
(** LATEX VERSION: The distance function satisfies d(p,c)=d(c,p). **)
Theorem distance_R2_sym : forall p c:set, p :e EuclidPlane -> c :e EuclidPlane -> distance_R2 p c = distance_R2 c p.
let p c. assume Hp Hc.
(** Coordinate realness and SNo-ness **)
set xp := R2_xcoord p.
set yp := R2_ycoord p.
set xc := R2_xcoord c.
set yc := R2_ycoord c.
claim HxpR : xp :e R.
{ exact (EuclidPlane_xcoord_in_R p Hp). }
claim HypR : yp :e R.
{ exact (EuclidPlane_ycoord_in_R p Hp). }
claim HxcR : xc :e R.
{ exact (EuclidPlane_xcoord_in_R c Hc). }
claim HycR : yc :e R.
{ exact (EuclidPlane_ycoord_in_R c Hc). }
claim HxpS : SNo xp.
{ exact (real_SNo xp HxpR). }
claim HypS : SNo yp.
{ exact (real_SNo yp HypR). }
claim HxcS : SNo xc.
{ exact (real_SNo xc HxcR). }
claim HycS : SNo yc.
{ exact (real_SNo yc HycR). }
claim HmxpR : minus_SNo xp :e R.
{ exact (real_minus_SNo xp HxpR). }
claim HmypR : minus_SNo yp :e R.
{ exact (real_minus_SNo yp HypR). }
claim HmxcR : minus_SNo xc :e R.
{ exact (real_minus_SNo xc HxcR). }
claim HmycR : minus_SNo yc :e R.
{ exact (real_minus_SNo yc HycR). }
claim HmxpS : SNo (minus_SNo xp).
{ exact (real_SNo (minus_SNo xp) HmxpR). }
claim HmypS : SNo (minus_SNo yp).
{ exact (real_SNo (minus_SNo yp) HmypR). }
claim HmxcS : SNo (minus_SNo xc).
{ exact (real_SNo (minus_SNo xc) HmxcR). }
claim HmycS : SNo (minus_SNo yc).
{ exact (real_SNo (minus_SNo yc) HmycR). }

(** Show the swapped coordinate differences are negatives of the original ones **)
claim Hswapx : add_SNo xc (minus_SNo xp) = minus_SNo (add_SNo xp (minus_SNo xc)).
{ claim Hneg : minus_SNo (add_SNo xp (minus_SNo xc)) = add_SNo (minus_SNo xp) (minus_SNo (minus_SNo xc)).
  { exact (minus_add_SNo_distr xp (minus_SNo xc) HxpS HmxcS). }
  claim Hinv : minus_SNo (minus_SNo xc) = xc.
  { exact (minus_SNo_invol xc HxcS). }
  claim Hneg2 : minus_SNo (add_SNo xp (minus_SNo xc)) = add_SNo (minus_SNo xp) xc.
  { rewrite <- Hinv at 2.
    exact Hneg. }
  claim Hcom : add_SNo (minus_SNo xp) xc = add_SNo xc (minus_SNo xp).
  { exact (add_SNo_com (minus_SNo xp) xc HmxpS HxcS). }
  prove add_SNo xc (minus_SNo xp) = minus_SNo (add_SNo xp (minus_SNo xc)).
  rewrite <- Hcom.
  rewrite <- Hneg2.
  reflexivity. }

claim Hswapy : add_SNo yc (minus_SNo yp) = minus_SNo (add_SNo yp (minus_SNo yc)).
{ claim Hneg : minus_SNo (add_SNo yp (minus_SNo yc)) = add_SNo (minus_SNo yp) (minus_SNo (minus_SNo yc)).
  { exact (minus_add_SNo_distr yp (minus_SNo yc) HypS HmycS). }
  claim Hinv : minus_SNo (minus_SNo yc) = yc.
  { exact (minus_SNo_invol yc HycS). }
  claim Hneg2 : minus_SNo (add_SNo yp (minus_SNo yc)) = add_SNo (minus_SNo yp) yc.
  { rewrite <- Hinv at 2.
    exact Hneg. }
  claim Hcom : add_SNo (minus_SNo yp) yc = add_SNo yc (minus_SNo yp).
  { exact (add_SNo_com (minus_SNo yp) yc HmypS HycS). }
  prove add_SNo yc (minus_SNo yp) = minus_SNo (add_SNo yp (minus_SNo yc)).
  rewrite <- Hcom.
  rewrite <- Hneg2.
  reflexivity. }

(** SNo-ness of the original differences **)
claim HdxR : add_SNo xp (minus_SNo xc) :e R.
{ exact (real_add_SNo xp HxpR (minus_SNo xc) HmxcR). }
claim HdyR : add_SNo yp (minus_SNo yc) :e R.
{ exact (real_add_SNo yp HypR (minus_SNo yc) HmycR). }
claim HdxS : SNo (add_SNo xp (minus_SNo xc)).
{ exact (real_SNo (add_SNo xp (minus_SNo xc)) HdxR). }
claim HdyS : SNo (add_SNo yp (minus_SNo yc)).
{ exact (real_SNo (add_SNo yp (minus_SNo yc)) HdyR). }

(** Square terms are equal after swapping p and c **)
claim Hsqx :
  mul_SNo (add_SNo xc (minus_SNo xp)) (add_SNo xc (minus_SNo xp))
  = mul_SNo (add_SNo xp (minus_SNo xc)) (add_SNo xp (minus_SNo xc)).
{ rewrite Hswapx.
  rewrite (mul_SNo_minus_minus (add_SNo xp (minus_SNo xc)) (add_SNo xp (minus_SNo xc)) HdxS HdxS).
  reflexivity. }
claim Hsqy :
  mul_SNo (add_SNo yc (minus_SNo yp)) (add_SNo yc (minus_SNo yp))
  = mul_SNo (add_SNo yp (minus_SNo yc)) (add_SNo yp (minus_SNo yc)).
{ rewrite Hswapy.
  rewrite (mul_SNo_minus_minus (add_SNo yp (minus_SNo yc)) (add_SNo yp (minus_SNo yc)) HdyS HdyS).
  reflexivity. }

(** Expand both sides to the same sqrt expression **)
claim Hdefpc : distance_R2 p c =
  sqrt_SNo_nonneg
    (add_SNo
      (mul_SNo (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c)))
              (add_SNo (R2_xcoord p) (minus_SNo (R2_xcoord c))))
      (mul_SNo (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c)))
              (add_SNo (R2_ycoord p) (minus_SNo (R2_ycoord c))))).
{ reflexivity. }
claim Hdefcp : distance_R2 c p =
  sqrt_SNo_nonneg
    (add_SNo
      (mul_SNo (add_SNo (R2_xcoord c) (minus_SNo (R2_xcoord p)))
              (add_SNo (R2_xcoord c) (minus_SNo (R2_xcoord p))))
      (mul_SNo (add_SNo (R2_ycoord c) (minus_SNo (R2_ycoord p)))
              (add_SNo (R2_ycoord c) (minus_SNo (R2_ycoord p))))).
{ reflexivity. }
rewrite Hdefpc.
rewrite Hdefcp.
rewrite Hsqx.
rewrite Hsqy.
reflexivity.
Qed.

(** from 13 Example 4: circular region basis elements in EuclidPlane **)
(** LATEX VERSION: Circular regions: sets of the form {p in R^2 | d(p,c) < r} with c in R^2 and 0<r. **)
Definition circular_regions : set :=
  {U :e Power EuclidPlane |
     exists c:set, exists r:set,
       c :e EuclidPlane /\ Rlt 0 r /\
       U = {p :e EuclidPlane|Rlt (distance_R2 p c) r}}.

(** helper for 13 Example 4: introduce a circular region from center and radius **)
(** LATEX VERSION: If cR^2 and 0<r then {pR^2|d(p,c)<r} is a circular region. **)
Theorem circular_regionI : forall c r:set,
  c :e EuclidPlane ->
  Rlt 0 r ->
  {p :e EuclidPlane|Rlt (distance_R2 p c) r} :e circular_regions.
let c r. assume Hc Hr.
prove {p :e EuclidPlane|Rlt (distance_R2 p c) r} :e circular_regions.
claim HPow : {p :e EuclidPlane|Rlt (distance_R2 p c) r} :e Power EuclidPlane.
{ apply PowerI EuclidPlane {p :e EuclidPlane|Rlt (distance_R2 p c) r}.
  let p. assume Hp.
  exact (SepE1 EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 c) r) p Hp). }
claim HPred :
  exists c0:set, exists r0:set,
    c0 :e EuclidPlane /\ Rlt 0 r0 /\
    {p :e EuclidPlane|Rlt (distance_R2 p c) r} = {p :e EuclidPlane|Rlt (distance_R2 p c0) r0}.
{ witness c. witness r.
  apply andI.
  - apply andI.
    + exact Hc.
    + exact Hr.
  - reflexivity. }
exact (SepI (Power EuclidPlane)
            (fun U0 : set =>
              exists c0:set, exists r0:set,
                c0 :e EuclidPlane /\ Rlt 0 r0 /\
                U0 = {p :e EuclidPlane|Rlt (distance_R2 p c0) r0})
            {p :e EuclidPlane|Rlt (distance_R2 p c) r}
            HPow
            HPred).
Qed.

(** from 13 Example 4: rectangular region basis elements in EuclidPlane **)
(** LATEX VERSION: Rectangular regions: axis-parallel rectangles (a,b)x(c,d) in R^2 described by inequalities on coordinates. **)
Definition rectangular_regions : set :=
  {U :e Power EuclidPlane |
     exists a b c d:set, a :e R /\ b :e R /\ c :e R /\ d :e R /\ Rlt a b /\ Rlt c d /\
       U = {p :e EuclidPlane|
              exists x y:set, p = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d}}.

(** helper for 13 Example 4: introduce a rectangular region from endpoints **)
(** LATEX VERSION: If a<b and c<d then {(x,y)R^2|a<x<b and c<y<d} is a rectangular region. **)
Theorem rectangular_regionI : forall a b c d:set,
  a :e R -> b :e R -> c :e R -> d :e R ->
  Rlt a b -> Rlt c d ->
  {p :e EuclidPlane|exists x y:set, p = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d}
    :e rectangular_regions.
let a b c d. assume Ha Hb Hc Hd Hab Hcd.
prove {p :e EuclidPlane|exists x y:set, p = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d} :e rectangular_regions.
claim HPow :
  {p :e EuclidPlane|exists x y:set, p = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d}
    :e Power EuclidPlane.
{ apply PowerI EuclidPlane {p :e EuclidPlane|exists x y:set, p = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d}.
  let p. assume Hp.
  exact (SepE1 EuclidPlane
              (fun p0 : set => exists x y:set, p0 = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d)
              p
              Hp). }
claim HPred :
  exists a0 b0 c0 d0:set,
    a0 :e R /\ b0 :e R /\ c0 :e R /\ d0 :e R /\ Rlt a0 b0 /\ Rlt c0 d0 /\
      {p :e EuclidPlane|exists x y:set, p = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d}
        = {p :e EuclidPlane|exists x y:set, p = (x,y) /\ Rlt a0 x /\ Rlt x b0 /\ Rlt c0 y /\ Rlt y d0}.
{ witness a. witness b. witness c. witness d.
  apply andI.
  - (** a:eR /\ b:eR /\ c:eR /\ d:eR /\ Rlt a b /\ Rlt c d **)
    apply andI.
    + (** a:eR /\ b:eR /\ c:eR /\ d:eR /\ Rlt a b **)
      apply andI.
      * (** a:eR /\ b:eR /\ c:eR /\ d:eR **)
        apply andI.
        { (** a:eR /\ b:eR /\ c:eR **)
          apply andI.
          - (** a:eR /\ b:eR **)
            apply andI.
            + exact Ha.
            + exact Hb.
          - exact Hc.
        }
        { exact Hd. }
      * exact Hab.
    + exact Hcd.
  - reflexivity. }
exact (SepI (Power EuclidPlane)
            (fun U0 : set =>
              exists a0 b0 c0 d0:set, a0 :e R /\ b0 :e R /\ c0 :e R /\ d0 :e R /\ Rlt a0 b0 /\ Rlt c0 d0 /\
                U0 = {p :e EuclidPlane|exists x y:set, p = (x,y) /\ Rlt a0 x /\ Rlt x b0 /\ Rlt c0 y /\ Rlt y d0})
            {p :e EuclidPlane|exists x y:set, p = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d}
            HPow
            HPred).
Qed.

(** helper for 13 Example 4: two-ball refinement around a point **)
(** LATEX VERSION: If x lies in two open balls B(c1,r1) and B(c2,r2), then there is a smaller ball B(x,r3) contained in their intersection. **)
Axiom ball_refine_two_balls_axiom :
  forall x c1 c2 r1 r2:set,
    x :e EuclidPlane ->
    c1 :e EuclidPlane ->
    c2 :e EuclidPlane ->
    Rlt 0 r1 ->
    Rlt 0 r2 ->
    Rlt (distance_R2 x c1) r1 ->
    Rlt (distance_R2 x c2) r2 ->
    exists r3:set,
      Rlt 0 r3 /\
      (forall p:set,
        p :e EuclidPlane ->
        Rlt (distance_R2 p x) r3 ->
        Rlt (distance_R2 p c1) r1 /\ Rlt (distance_R2 p c2) r2).
Theorem ball_refine_two_balls :
  forall x c1 c2 r1 r2:set,
    x :e EuclidPlane ->
    c1 :e EuclidPlane ->
    c2 :e EuclidPlane ->
    Rlt 0 r1 ->
    Rlt 0 r2 ->
    Rlt (distance_R2 x c1) r1 ->
    Rlt (distance_R2 x c2) r2 ->
    exists r3:set,
      Rlt 0 r3 /\
      (forall p:set,
        p :e EuclidPlane ->
        Rlt (distance_R2 p x) r3 ->
        Rlt (distance_R2 p c1) r1 /\ Rlt (distance_R2 p c2) r2).
let x c1 c2 r1 r2.
assume Hx: x :e EuclidPlane.
assume Hc1: c1 :e EuclidPlane.
assume Hc2: c2 :e EuclidPlane.
assume Hr1: Rlt 0 r1.
assume Hr2: Rlt 0 r2.
assume Hx1: Rlt (distance_R2 x c1) r1.
assume Hx2: Rlt (distance_R2 x c2) r2.
exact (ball_refine_two_balls_axiom x c1 c2 r1 r2 Hx Hc1 Hc2 Hr1 Hr2 Hx1 Hx2).
Qed.

(** helper for 13 Example 4: rectangle inside a ball around a center **)
(** LATEX VERSION: Every point x in a ball B(c,r0) has a rectangular neighborhood contained in B(c,r0). **)
Axiom rectangle_inside_ball_axiom :
  forall x c r0:set,
    x :e EuclidPlane ->
    c :e EuclidPlane ->
    Rlt 0 r0 ->
    Rlt (distance_R2 x c) r0 ->
    exists r :e rectangular_regions,
      x :e r /\ r c= {p :e EuclidPlane|Rlt (distance_R2 p c) r0}.
Theorem rectangle_inside_ball :
  forall x c r0:set,
    x :e EuclidPlane ->
    c :e EuclidPlane ->
    Rlt 0 r0 ->
    Rlt (distance_R2 x c) r0 ->
    exists r :e rectangular_regions,
      x :e r /\ r c= {p :e EuclidPlane|Rlt (distance_R2 p c) r0}.
let x c r0.
assume Hx: x :e EuclidPlane.
assume Hc: c :e EuclidPlane.
assume Hr0: Rlt 0 r0.
assume Hxc: Rlt (distance_R2 x c) r0.
exact (rectangle_inside_ball_axiom x c r0 Hx Hc Hr0 Hxc).
Qed.

(** helper for 13 Example 4: ball inside a rectangle around a point **)
(** LATEX VERSION: Every point x in a rectangle has a circular neighborhood contained in it. **)
Axiom ball_inside_rectangle_axiom :
  forall b x:set,
    b :e rectangular_regions ->
    x :e EuclidPlane ->
    x :e b ->
    exists r3:set,
      Rlt 0 r3 /\
      (forall p:set, p :e EuclidPlane -> Rlt (distance_R2 p x) r3 -> p :e b).
Theorem ball_inside_rectangle :
  forall b x:set,
    b :e rectangular_regions ->
    x :e EuclidPlane ->
    x :e b ->
    exists r3:set,
      Rlt 0 r3 /\
      (forall p:set, p :e EuclidPlane -> Rlt (distance_R2 p x) r3 -> p :e b).
let b x.
assume Hb: b :e rectangular_regions.
assume HxE: x :e EuclidPlane.
assume Hxb: x :e b.
exact (ball_inside_rectangle_axiom b x Hb HxE Hxb).
Qed.

(** from 13 Example 4: circular regions form a basis on EuclidPlane **)
(** LATEX VERSION: The family of circular regions is a basis for a topology on R^2. **)
Theorem circular_regions_basis_plane : basis_on EuclidPlane circular_regions.
prove basis_on EuclidPlane circular_regions.
(** basis_on has three clauses: subset, cover, intersection refinement **)
prove circular_regions c= Power EuclidPlane
  /\ (forall x :e EuclidPlane, exists b :e circular_regions, x :e b)
  /\ (forall b1 :e circular_regions, forall b2 :e circular_regions, forall x:set,
        x :e b1 -> x :e b2 ->
        exists b3 :e circular_regions, x :e b3 /\ b3 c= b1 :/\: b2).
apply andI.
- apply andI.
  + let U. assume HU: U :e circular_regions.
    prove U :e Power EuclidPlane.
    exact (SepE1 (Power EuclidPlane)
                 (fun U0 : set => exists c:set, exists r:set,
                   c :e EuclidPlane /\ Rlt 0 r /\
                   U0 = {p :e EuclidPlane|Rlt (distance_R2 p c) r})
                 U
                 HU).
  + prove forall x :e EuclidPlane, exists b :e circular_regions, x :e b.
    let x. assume Hx.
    witness {p :e EuclidPlane|Rlt (distance_R2 p x) 1}.
    apply andI.
    * prove {p :e EuclidPlane|Rlt (distance_R2 p x) 1} :e circular_regions.
      exact (circular_regionI x 1 Hx Rlt_0_1).
    * claim Hlt : Rlt (distance_R2 x x) 1.
      { rewrite (distance_R2_refl_0 x Hx).
        claim HR : 0 :e R /\ 1 :e R /\ 0 < 1.
        { apply andI.
          - apply andI.
            + exact real_0.
            + exact real_1.
          - exact SNoLt_0_1. }
        exact HR. }
      exact (SepI EuclidPlane
                  (fun p0 : set => Rlt (distance_R2 p0 x) 1)
                  x
                  Hx
                  Hlt).
	- (** intersection refinement for circular regions **)
	  let b1. assume Hb1 : b1 :e circular_regions.
	  let b2. assume Hb2 : b2 :e circular_regions.
	  let x. assume Hx1 : x :e b1. assume Hx2 : x :e b2.
	  prove exists b3 :e circular_regions, x :e b3 /\ b3 c= b1 :/\: b2.
	  claim Hb1prop :
	    exists c1:set, exists r1:set,
	      c1 :e EuclidPlane /\ Rlt 0 r1 /\
	      b1 = {p :e EuclidPlane|Rlt (distance_R2 p c1) r1}.
	  { exact (SepE2 (Power EuclidPlane)
	                 (fun U0 : set => exists c:set, exists r:set,
	                   c :e EuclidPlane /\ Rlt 0 r /\
	                   U0 = {p :e EuclidPlane|Rlt (distance_R2 p c) r})
	                 b1
	                 Hb1). }
	  claim Hb2prop :
	    exists c2:set, exists r2:set,
	      c2 :e EuclidPlane /\ Rlt 0 r2 /\
	      b2 = {p :e EuclidPlane|Rlt (distance_R2 p c2) r2}.
	  { exact (SepE2 (Power EuclidPlane)
	                 (fun U0 : set => exists c:set, exists r:set,
	                   c :e EuclidPlane /\ Rlt 0 r /\
	                   U0 = {p :e EuclidPlane|Rlt (distance_R2 p c) r})
	                 b2
	                 Hb2). }
	  apply Hb1prop.
	  let c1. assume Hb1prop2.
	  apply Hb1prop2.
	  let r1. assume Hb1core.
	  apply Hb2prop.
	  let c2. assume Hb2prop2.
		  apply Hb2prop2.
		  let r2. assume Hb2core.
		  claim Hc1r1 : c1 :e EuclidPlane /\ Rlt 0 r1.
		  { exact (andEL (c1 :e EuclidPlane /\ Rlt 0 r1)
		                (b1 = {p :e EuclidPlane|Rlt (distance_R2 p c1) r1})
		                Hb1core). }
		  claim Hc1 : c1 :e EuclidPlane.
		  { exact (andEL (c1 :e EuclidPlane) (Rlt 0 r1) Hc1r1). }
		  claim Hr1 : Rlt 0 r1.
		  { exact (andER (c1 :e EuclidPlane) (Rlt 0 r1) Hc1r1). }
		  claim Hb1eq : b1 = {p :e EuclidPlane|Rlt (distance_R2 p c1) r1}.
		  { exact (andER (c1 :e EuclidPlane /\ Rlt 0 r1)
		                (b1 = {p :e EuclidPlane|Rlt (distance_R2 p c1) r1})
		                Hb1core). }
		  claim Hc2r2 : c2 :e EuclidPlane /\ Rlt 0 r2.
		  { exact (andEL (c2 :e EuclidPlane /\ Rlt 0 r2)
		                (b2 = {p :e EuclidPlane|Rlt (distance_R2 p c2) r2})
		                Hb2core). }
		  claim Hc2 : c2 :e EuclidPlane.
		  { exact (andEL (c2 :e EuclidPlane) (Rlt 0 r2) Hc2r2). }
		  claim Hr2 : Rlt 0 r2.
		  { exact (andER (c2 :e EuclidPlane) (Rlt 0 r2) Hc2r2). }
		  claim Hb2eq : b2 = {p :e EuclidPlane|Rlt (distance_R2 p c2) r2}.
		  { exact (andER (c2 :e EuclidPlane /\ Rlt 0 r2)
		                (b2 = {p :e EuclidPlane|Rlt (distance_R2 p c2) r2})
		                Hb2core). }
	  claim Hx1' : x :e {p :e EuclidPlane|Rlt (distance_R2 p c1) r1}.
	  { rewrite <- Hb1eq. exact Hx1. }
	  claim Hx2' : x :e {p :e EuclidPlane|Rlt (distance_R2 p c2) r2}.
	  { rewrite <- Hb2eq. exact Hx2. }
	  claim HxEuclid : x :e EuclidPlane.
	  { exact (SepE1 EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 c1) r1) x Hx1'). }
	  claim Hxball1 : Rlt (distance_R2 x c1) r1.
	  { exact (SepE2 EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 c1) r1) x Hx1'). }
	  claim Hxball2 : Rlt (distance_R2 x c2) r2.
	  { exact (SepE2 EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 c2) r2) x Hx2'). }

		  (** Metric refinement lemma for EuclidPlane balls around x **)
			  apply (ball_refine_two_balls x c1 c2 r1 r2 HxEuclid Hc1 Hc2 Hr1 Hr2 Hxball1 Hxball2).
			  let r3. assume Hrefine2.
	  claim Hr3 : Rlt 0 r3.
	  { exact (andEL (Rlt 0 r3)
	                (forall p:set, p :e EuclidPlane -> Rlt (distance_R2 p x) r3 -> Rlt (distance_R2 p c1) r1 /\ Rlt (distance_R2 p c2) r2)
	                Hrefine2). }
	  claim HrefineP :
	    forall p:set, p :e EuclidPlane -> Rlt (distance_R2 p x) r3 -> Rlt (distance_R2 p c1) r1 /\ Rlt (distance_R2 p c2) r2.
	  { exact (andER (Rlt 0 r3)
	                (forall p:set, p :e EuclidPlane -> Rlt (distance_R2 p x) r3 -> Rlt (distance_R2 p c1) r1 /\ Rlt (distance_R2 p c2) r2)
	                Hrefine2). }

		  set b3 := {p :e EuclidPlane|Rlt (distance_R2 p x) r3}.
		  witness b3.
		  apply andI.
		  - prove b3 :e circular_regions.
		    claim Hb3def : b3 = {p :e EuclidPlane|Rlt (distance_R2 p x) r3}.
		    { reflexivity. }
		    rewrite Hb3def.
		    exact (circular_regionI x r3 HxEuclid Hr3).
		  - apply andI.
	    + prove x :e b3.
	      claim Hdx : Rlt (distance_R2 x x) r3.
	      { rewrite (distance_R2_refl_0 x HxEuclid).
	        exact Hr3. }
	      exact (SepI EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 x) r3) x HxEuclid Hdx).
	    + prove b3 c= b1 :/\: b2.
	      let p. assume Hp3 : p :e b3.
	      prove p :e b1 :/\: b2.
	      claim HpE : p :e EuclidPlane.
	      { exact (SepE1 EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 x) r3) p Hp3). }
	      claim Hpball : Rlt (distance_R2 p x) r3.
	      { exact (SepE2 EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 x) r3) p Hp3). }
	      claim Hboth : Rlt (distance_R2 p c1) r1 /\ Rlt (distance_R2 p c2) r2.
	      { exact (HrefineP p HpE Hpball). }
	      claim Hpball1 : Rlt (distance_R2 p c1) r1.
	      { exact (andEL (Rlt (distance_R2 p c1) r1) (Rlt (distance_R2 p c2) r2) Hboth). }
	      claim Hpball2 : Rlt (distance_R2 p c2) r2.
	      { exact (andER (Rlt (distance_R2 p c1) r1) (Rlt (distance_R2 p c2) r2) Hboth). }
	      claim Hpb1 : p :e b1.
	      { rewrite Hb1eq.
	        exact (SepI EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 c1) r1) p HpE Hpball1). }
	      claim Hpb2 : p :e b2.
	      { rewrite Hb2eq.
	        exact (SepI EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 c2) r2) p HpE Hpball2). }
	      exact (binintersectI b1 b2 p Hpb1 Hpb2).
Qed.

(** from 13 Example 4: rectangular regions form a basis on EuclidPlane **)
(** LATEX VERSION: The family of axis-parallel open rectangles is a basis for a topology on R^2. **)
Theorem rectangular_regions_basis_plane : basis_on EuclidPlane rectangular_regions.
prove basis_on EuclidPlane rectangular_regions.
prove rectangular_regions c= Power EuclidPlane
  /\ (forall x :e EuclidPlane, exists b :e rectangular_regions, x :e b)
  /\ (forall b1 :e rectangular_regions, forall b2 :e rectangular_regions, forall x:set,
        x :e b1 -> x :e b2 ->
        exists b3 :e rectangular_regions, x :e b3 /\ b3 c= b1 :/\: b2).
apply andI.
- apply andI.
  + let U. assume HU: U :e rectangular_regions.
    prove U :e Power EuclidPlane.
    exact (SepE1 (Power EuclidPlane)
                 (fun U0 : set =>
                   exists a b c d:set, a :e R /\ b :e R /\ c :e R /\ d :e R /\ Rlt a b /\ Rlt c d /\
                     U0 = {p :e EuclidPlane|
                            exists x y:set, p = (x,y) /\ Rlt a x /\ Rlt x b /\ Rlt c y /\ Rlt y d})
	                 U
	                 HU).
	  + prove forall p :e EuclidPlane, exists b :e rectangular_regions, p :e b.
	    let p. assume Hp : p :e EuclidPlane.
	    apply (Sigma_E R (fun _ : set => R) p Hp).
	    let x. assume Hx_pair.
	    apply Hx_pair.
	    assume HxR Hexy.
	    apply Hexy.
	    let y. assume Hy_pair.
	    apply Hy_pair.
	    assume HyR Hpeq.
	    set a := add_SNo x (minus_SNo 1).
	    set b := add_SNo x 1.
	    set c := add_SNo y (minus_SNo 1).
	    set d := add_SNo y 1.
	    set U := {p0 :e EuclidPlane|
	                exists x0:set, exists y0:set,
	                  p0 = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b /\ Rlt c y0 /\ Rlt y0 d}.
	    witness U.
		    apply andI.
		    - prove U :e rectangular_regions.
		      claim HxS : SNo x.
		      { exact (real_SNo x HxR). }
		      claim HyS : SNo y.
		      { exact (real_SNo y HyR). }
	      claim Hm1R : minus_SNo 1 :e R.
	      { exact (real_minus_SNo 1 real_1). }
	      claim Hm1S : SNo (minus_SNo 1).
	      { exact (real_SNo (minus_SNo 1) Hm1R). }
	      claim HaR : a :e R.
	      { exact (real_add_SNo x HxR (minus_SNo 1) Hm1R). }
	      claim HbR : b :e R.
	      { exact (real_add_SNo x HxR 1 real_1). }
	      claim HcR : c :e R.
	      { exact (real_add_SNo y HyR (minus_SNo 1) Hm1R). }
	      claim HdR : d :e R.
	      { exact (real_add_SNo y HyR 1 real_1). }
	      claim Hm1lt1 : minus_SNo 1 < 1.
	      { exact (SNoLt_tra (minus_SNo 1) 0 1 Hm1S SNo_0 SNo_1 minus_1_lt_0 SNoLt_0_1). }
	      claim Hablt : a < b.
	      { exact (add_SNo_Lt2 x (minus_SNo 1) 1 HxS Hm1S SNo_1 Hm1lt1). }
	      claim Hcdlt : c < d.
	      { exact (add_SNo_Lt2 y (minus_SNo 1) 1 HyS Hm1S SNo_1 Hm1lt1). }
		      claim HabRlt : Rlt a b.
		      { exact (RltI a b HaR HbR Hablt). }
		      claim HcdRlt : Rlt c d.
		      { exact (RltI c d HcR HdR Hcdlt). }
		      claim HUdef :
		        U = {p0 :e EuclidPlane|
		               exists x0:set, exists y0:set,
		                 p0 = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b /\ Rlt c y0 /\ Rlt y0 d}.
		      { reflexivity. }
		      rewrite HUdef.
		      exact (rectangular_regionI a b c d HaR HbR HcR HdR HabRlt HcdRlt).
	    - prove p :e U.
	      claim Hptup : p = (x,y).
	      { rewrite Hpeq. exact (tuple_pair x y). }
	      claim HaR : a :e R.
	      { exact (real_add_SNo x HxR (minus_SNo 1) (real_minus_SNo 1 real_1)). }
	      claim HbR : b :e R.
	      { exact (real_add_SNo x HxR 1 real_1). }
	      claim HcR : c :e R.
	      { exact (real_add_SNo y HyR (minus_SNo 1) (real_minus_SNo 1 real_1)). }
	      claim HdR : d :e R.
	      { exact (real_add_SNo y HyR 1 real_1). }
	      claim HxS : SNo x.
	      { exact (real_SNo x HxR). }
	      claim HyS : SNo y.
	      { exact (real_SNo y HyR). }
	      claim Hm1S : SNo (minus_SNo 1).
	      { exact (real_SNo (minus_SNo 1) (real_minus_SNo 1 real_1)). }
	      claim Hx0eq : add_SNo x 0 = x.
	      { exact (add_SNo_0R x HxS). }
	      claim Hy0eq : add_SNo y 0 = y.
	      { exact (add_SNo_0R y HyS). }
      claim Haxlt0 : add_SNo x (minus_SNo 1) < add_SNo x 0.
      { exact (add_SNo_Lt2 x (minus_SNo 1) 0 HxS Hm1S SNo_0 minus_1_lt_0). }
      claim Haxlt : a < x.
      { rewrite <- Hx0eq at 2. exact Haxlt0. }
      claim Hxltb0 : add_SNo x 0 < add_SNo x 1.
      { exact (add_SNo_Lt2 x 0 1 HxS SNo_0 SNo_1 SNoLt_0_1). }
      claim Hxltb : x < b.
      { rewrite <- Hx0eq at 1. exact Hxltb0. }
      claim Hcylt0 : add_SNo y (minus_SNo 1) < add_SNo y 0.
      { exact (add_SNo_Lt2 y (minus_SNo 1) 0 HyS Hm1S SNo_0 minus_1_lt_0). }
      claim Hcylt : c < y.
      { rewrite <- Hy0eq at 2. exact Hcylt0. }
      claim HyLtd0 : add_SNo y 0 < add_SNo y 1.
      { exact (add_SNo_Lt2 y 0 1 HyS SNo_0 SNo_1 SNoLt_0_1). }
      claim HyLtd : y < d.
      { rewrite <- Hy0eq at 1. exact HyLtd0. }
	      claim HaRltx : Rlt a x.
	      { exact (RltI a x HaR HxR Haxlt). }
	      claim HxRltb : Rlt x b.
	      { exact (RltI x b HxR HbR Hxltb). }
	      claim HcRlty : Rlt c y.
	      { exact (RltI c y HcR HyR Hcylt). }
	      claim HyRltd : Rlt y d.
	      { exact (RltI y d HyR HdR HyLtd). }
	      claim Hpred :
	        exists x0:set, exists y0:set,
	          p = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b /\ Rlt c y0 /\ Rlt y0 d.
	      { witness x. witness y.
	        claim H1 : p = (x,y) /\ Rlt a x.
	        { exact (andI (p = (x,y)) (Rlt a x) Hptup HaRltx). }
	        claim H12 : (p = (x,y) /\ Rlt a x) /\ Rlt x b.
	        { exact (andI (p = (x,y) /\ Rlt a x) (Rlt x b) H1 HxRltb). }
	        claim H123 : ((p = (x,y) /\ Rlt a x) /\ Rlt x b) /\ Rlt c y.
	        { exact (andI ((p = (x,y) /\ Rlt a x) /\ Rlt x b) (Rlt c y) H12 HcRlty). }
	        exact (andI (((p = (x,y) /\ Rlt a x) /\ Rlt x b) /\ Rlt c y)
	                   (Rlt y d)
	                   H123
	                   HyRltd). }
	      exact (SepI EuclidPlane
	                  (fun p1 : set =>
	                    exists x0:set, exists y0:set,
	                      p1 = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b /\ Rlt c y0 /\ Rlt y0 d)
	                  p
	                  Hp
	                  Hpred).
  - let b1. assume Hb1 : b1 :e rectangular_regions.
    let b2. assume Hb2 : b2 :e rectangular_regions.
    let p. assume Hp1 : p :e b1. assume Hp2 : p :e b2.
    prove exists b3 :e rectangular_regions, p :e b3 /\ b3 c= b1 :/\: b2.
    (** Unpack b1 as a rectangle with parameters a1,b1x,c1,d1 **)
    claim Hb1prop :
      exists a1:set, exists b1x:set, exists c1:set, exists d1:set,
        a1 :e R /\ b1x :e R /\ c1 :e R /\ d1 :e R /\ Rlt a1 b1x /\ Rlt c1 d1 /\
          b1 = {q :e EuclidPlane|
                  exists x0:set, exists y0:set,
                    q = (x0,y0) /\ Rlt a1 x0 /\ Rlt x0 b1x /\ Rlt c1 y0 /\ Rlt y0 d1}.
    { exact (SepE2 (Power EuclidPlane)
                   (fun U0 : set =>
                     exists a b c d:set, a :e R /\ b :e R /\ c :e R /\ d :e R /\ Rlt a b /\ Rlt c d /\
                       U0 = {p1 :e EuclidPlane|
                              exists x0:set, exists y0:set,
                                p1 = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b /\ Rlt c y0 /\ Rlt y0 d})
                   b1
                   Hb1). }
    apply Hb1prop.
    let a1. assume Hb1prop2.
    apply Hb1prop2.
    let b1x. assume Hb1prop3.
    apply Hb1prop3.
    let c1. assume Hb1prop4.
    apply Hb1prop4.
    let d1. assume Hb1core.
    (** Unpack b2 similarly **)
    claim Hb2prop :
      exists a2:set, exists b2x:set, exists c2:set, exists d2:set,
        a2 :e R /\ b2x :e R /\ c2 :e R /\ d2 :e R /\ Rlt a2 b2x /\ Rlt c2 d2 /\
          b2 = {q :e EuclidPlane|
                  exists x0:set, exists y0:set,
                    q = (x0,y0) /\ Rlt a2 x0 /\ Rlt x0 b2x /\ Rlt c2 y0 /\ Rlt y0 d2}.
    { exact (SepE2 (Power EuclidPlane)
                   (fun U0 : set =>
                     exists a b c d:set, a :e R /\ b :e R /\ c :e R /\ d :e R /\ Rlt a b /\ Rlt c d /\
                       U0 = {p1 :e EuclidPlane|
                              exists x0:set, exists y0:set,
                                p1 = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b /\ Rlt c y0 /\ Rlt y0 d})
                   b2
                   Hb2). }
    apply Hb2prop.
    let a2. assume Hb2prop2.
    apply Hb2prop2.
    let b2x. assume Hb2prop3.
    apply Hb2prop3.
    let c2. assume Hb2prop4.
    apply Hb2prop4.
    let d2. assume Hb2core.
    (** Extract equations and point coordinates from membership hypotheses Hp1 and Hp2 **)
    claim Hb1eq :
      b1 = {q :e EuclidPlane|
              exists x0:set, exists y0:set,
                q = (x0,y0) /\ Rlt a1 x0 /\ Rlt x0 b1x /\ Rlt c1 y0 /\ Rlt y0 d1}.
    { exact (andER (a1 :e R /\ b1x :e R /\ c1 :e R /\ d1 :e R /\ Rlt a1 b1x /\ Rlt c1 d1)
                  (b1 = {q :e EuclidPlane|
                          exists x0:set, exists y0:set,
                            q = (x0,y0) /\ Rlt a1 x0 /\ Rlt x0 b1x /\ Rlt c1 y0 /\ Rlt y0 d1})
                  Hb1core). }
    claim Hb2eq :
      b2 = {q :e EuclidPlane|
              exists x0:set, exists y0:set,
                q = (x0,y0) /\ Rlt a2 x0 /\ Rlt x0 b2x /\ Rlt c2 y0 /\ Rlt y0 d2}.
    { exact (andER (a2 :e R /\ b2x :e R /\ c2 :e R /\ d2 :e R /\ Rlt a2 b2x /\ Rlt c2 d2)
                  (b2 = {q :e EuclidPlane|
                          exists x0:set, exists y0:set,
                            q = (x0,y0) /\ Rlt a2 x0 /\ Rlt x0 b2x /\ Rlt c2 y0 /\ Rlt y0 d2})
                  Hb2core). }
    claim Hp1' : p :e {q :e EuclidPlane|
                        exists x0:set, exists y0:set,
                          q = (x0,y0) /\ Rlt a1 x0 /\ Rlt x0 b1x /\ Rlt c1 y0 /\ Rlt y0 d1}.
    { rewrite <- Hb1eq. exact Hp1. }
    claim Hp2' : p :e {q :e EuclidPlane|
                        exists x0:set, exists y0:set,
                          q = (x0,y0) /\ Rlt a2 x0 /\ Rlt x0 b2x /\ Rlt c2 y0 /\ Rlt y0 d2}.
    { rewrite <- Hb2eq. exact Hp2. }
    claim Hp1coords :
      exists x1:set, exists y1:set,
        p = (x1,y1) /\ Rlt a1 x1 /\ Rlt x1 b1x /\ Rlt c1 y1 /\ Rlt y1 d1.
    { exact (SepE2 EuclidPlane
                   (fun q : set =>
                     exists x0:set, exists y0:set,
                       q = (x0,y0) /\ Rlt a1 x0 /\ Rlt x0 b1x /\ Rlt c1 y0 /\ Rlt y0 d1)
                   p
                   Hp1'). }
    claim Hp2coords :
      exists x2:set, exists y2:set,
        p = (x2,y2) /\ Rlt a2 x2 /\ Rlt x2 b2x /\ Rlt c2 y2 /\ Rlt y2 d2.
    { exact (SepE2 EuclidPlane
                   (fun q : set =>
                     exists x0:set, exists y0:set,
                       q = (x0,y0) /\ Rlt a2 x0 /\ Rlt x0 b2x /\ Rlt c2 y0 /\ Rlt y0 d2)
                   p
                   Hp2'). }
    (** Reduce to the usual coordinate inequalities at p **)
    apply Hp1coords.
    let x1. assume Hp1coords2.
    apply Hp1coords2.
    let y1. assume Hp1ineq.
    apply Hp2coords.
    let x2. assume Hp2coords2.
    apply Hp2coords2.
    let y2. assume Hp2ineq.
    (** Identify x1=x2 and y1=y2 via tuple equality **)
    claim Hp_tup1 : p = (x1,y1).
    { claim H1 : (((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x) /\ Rlt c1 y1).
      { exact (andEL (((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x) /\ Rlt c1 y1)
                    (Rlt y1 d1)
                    Hp1ineq). }
      claim H2 : ((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x).
      { exact (andEL ((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x)
                    (Rlt c1 y1)
                    H1). }
      claim H3 : (p = (x1,y1) /\ Rlt a1 x1).
      { exact (andEL (p = (x1,y1) /\ Rlt a1 x1)
                    (Rlt x1 b1x)
                    H2). }
      exact (andEL (p = (x1,y1)) (Rlt a1 x1) H3). }
    claim Hp_tup2 : p = (x2,y2).
    { claim H1 : (((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x) /\ Rlt c2 y2).
      { exact (andEL (((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x) /\ Rlt c2 y2)
                    (Rlt y2 d2)
                    Hp2ineq). }
      claim H2 : ((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x).
      { exact (andEL ((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x)
                    (Rlt c2 y2)
                    H1). }
      claim H3 : (p = (x2,y2) /\ Rlt a2 x2).
      { exact (andEL (p = (x2,y2) /\ Rlt a2 x2)
                    (Rlt x2 b2x)
                    H2). }
      exact (andEL (p = (x2,y2)) (Rlt a2 x2) H3). }
    claim Heq12 : (x1,y1) = (x2,y2).
    { rewrite <- Hp_tup1. rewrite <- Hp_tup2. reflexivity. }
    claim Hcoords : x1 = x2 /\ y1 = y2.
    { exact (tuple_eq_coords_R2 x1 y1 x2 y2 Heq12). }
    (** At this point we have x1,y1 and inequalities from both rectangles.
        The remaining task is to pick new endpoints a3,b3,c3,d3 giving a rectangle around (x1,y1)
        that is contained in the intersection. **)
    claim Hx1eq : x1 = x2.
    { exact (andEL (x1 = x2) (y1 = y2) Hcoords). }
    claim Hy1eq : y1 = y2.
    { exact (andER (x1 = x2) (y1 = y2) Hcoords). }

    (** Extract coordinate inequalities for p from Hp1ineq and Hp2ineq **)
    claim Ha1x1 : Rlt a1 x1.
    { claim H1 : (((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x) /\ Rlt c1 y1).
      { exact (andEL (((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x) /\ Rlt c1 y1)
                    (Rlt y1 d1)
                    Hp1ineq). }
      claim H2 : ((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x).
      { exact (andEL ((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x)
                    (Rlt c1 y1)
                    H1). }
      claim H3 : (p = (x1,y1) /\ Rlt a1 x1).
      { exact (andEL (p = (x1,y1) /\ Rlt a1 x1)
                    (Rlt x1 b1x)
                    H2). }
      exact (andER (p = (x1,y1)) (Rlt a1 x1) H3). }
    claim Hx1b1 : Rlt x1 b1x.
    { claim H1 : (((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x) /\ Rlt c1 y1).
      { exact (andEL (((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x) /\ Rlt c1 y1)
                    (Rlt y1 d1)
                    Hp1ineq). }
      claim H2 : ((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x).
      { exact (andEL ((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x)
                    (Rlt c1 y1)
                    H1). }
      exact (andER (p = (x1,y1) /\ Rlt a1 x1) (Rlt x1 b1x) H2). }
    claim Hc1y1 : Rlt c1 y1.
    { claim H1 : (((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x) /\ Rlt c1 y1).
      { exact (andEL (((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x) /\ Rlt c1 y1)
                    (Rlt y1 d1)
                    Hp1ineq). }
      exact (andER ((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x) (Rlt c1 y1) H1). }
    claim Hy1d1 : Rlt y1 d1.
    { exact (andER (((p = (x1,y1) /\ Rlt a1 x1) /\ Rlt x1 b1x) /\ Rlt c1 y1) (Rlt y1 d1) Hp1ineq). }

    claim Ha2x2 : Rlt a2 x2.
    { claim H1 : (((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x) /\ Rlt c2 y2).
      { exact (andEL (((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x) /\ Rlt c2 y2)
                    (Rlt y2 d2)
                    Hp2ineq). }
      claim H2 : ((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x).
      { exact (andEL ((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x)
                    (Rlt c2 y2)
                    H1). }
      claim H3 : (p = (x2,y2) /\ Rlt a2 x2).
      { exact (andEL (p = (x2,y2) /\ Rlt a2 x2)
                    (Rlt x2 b2x)
                    H2). }
      exact (andER (p = (x2,y2)) (Rlt a2 x2) H3). }
    claim Hx2b2 : Rlt x2 b2x.
    { claim H1 : (((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x) /\ Rlt c2 y2).
      { exact (andEL (((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x) /\ Rlt c2 y2)
                    (Rlt y2 d2)
                    Hp2ineq). }
      claim H2 : ((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x).
      { exact (andEL ((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x)
                    (Rlt c2 y2)
                    H1). }
      exact (andER (p = (x2,y2) /\ Rlt a2 x2) (Rlt x2 b2x) H2). }
    claim Hc2y2 : Rlt c2 y2.
    { claim H1 : (((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x) /\ Rlt c2 y2).
      { exact (andEL (((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x) /\ Rlt c2 y2)
                    (Rlt y2 d2)
                    Hp2ineq). }
      exact (andER ((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x) (Rlt c2 y2) H1). }
    claim Hy2d2 : Rlt y2 d2.
    { exact (andER (((p = (x2,y2) /\ Rlt a2 x2) /\ Rlt x2 b2x) /\ Rlt c2 y2) (Rlt y2 d2) Hp2ineq). }

    (** Rewrite the second rectangle inequalities to x1,y1 **)
    claim Ha2x1 : Rlt a2 x1.
    { rewrite Hx1eq. exact Ha2x2. }
    claim Hx1b2 : Rlt x1 b2x.
    { rewrite Hx1eq at 1. exact Hx2b2. }
    claim Hc2y1 : Rlt c2 y1.
    { rewrite Hy1eq. exact Hc2y2. }
    claim Hy1d2 : Rlt y1 d2.
    { rewrite Hy1eq at 1. exact Hy2d2. }

    (** Define endpoints as max/min choices using if-then-else **)
    set a3 := if a1 < a2 then a2 else a1.
    set b3x := if b1x < b2x then b1x else b2x.
    set c3 := if c1 < c2 then c2 else c1.
    set d3 := if d1 < d2 then d1 else d2.

    claim Ha3def : a3 = if a1 < a2 then a2 else a1.
    { reflexivity. }
    claim Hb3def : b3x = if b1x < b2x then b1x else b2x.
    { reflexivity. }
    claim Hc3def : c3 = if c1 < c2 then c2 else c1.
    { reflexivity. }
    claim Hd3def : d3 = if d1 < d2 then d1 else d2.
    { reflexivity. }

    (** Extract endpoint realness once from Hb1core and Hb2core **)
    claim Hb1params :
      a1 :e R /\ b1x :e R /\ c1 :e R /\ d1 :e R /\ Rlt a1 b1x /\ Rlt c1 d1.
    { exact (andEL (a1 :e R /\ b1x :e R /\ c1 :e R /\ d1 :e R /\ Rlt a1 b1x /\ Rlt c1 d1)
                  (b1 = {q :e EuclidPlane|
                          exists x0:set, exists y0:set,
                            q = (x0,y0) /\ Rlt a1 x0 /\ Rlt x0 b1x /\ Rlt c1 y0 /\ Rlt y0 d1})
                  Hb1core). }
    claim Hb2params :
      a2 :e R /\ b2x :e R /\ c2 :e R /\ d2 :e R /\ Rlt a2 b2x /\ Rlt c2 d2.
    { exact (andEL (a2 :e R /\ b2x :e R /\ c2 :e R /\ d2 :e R /\ Rlt a2 b2x /\ Rlt c2 d2)
                  (b2 = {q :e EuclidPlane|
                          exists x0:set, exists y0:set,
                            q = (x0,y0) /\ Rlt a2 x0 /\ Rlt x0 b2x /\ Rlt c2 y0 /\ Rlt y0 d2})
                  Hb2core). }

    claim Hb1left : ((((a1 :e R /\ b1x :e R) /\ c1 :e R) /\ d1 :e R) /\ Rlt a1 b1x).
    { exact (andEL ((((a1 :e R /\ b1x :e R) /\ c1 :e R) /\ d1 :e R) /\ Rlt a1 b1x)
                  (Rlt c1 d1)
                  Hb1params). }
    claim Hb2left : ((((a2 :e R /\ b2x :e R) /\ c2 :e R) /\ d2 :e R) /\ Rlt a2 b2x).
    { exact (andEL ((((a2 :e R /\ b2x :e R) /\ c2 :e R) /\ d2 :e R) /\ Rlt a2 b2x)
                  (Rlt c2 d2)
                  Hb2params). }

    claim Ha1b1x_c1_d1 : (((a1 :e R /\ b1x :e R) /\ c1 :e R) /\ d1 :e R).
    { exact (andEL (((a1 :e R /\ b1x :e R) /\ c1 :e R) /\ d1 :e R)
                  (Rlt a1 b1x)
                  Hb1left). }
    claim Ha2b2x_c2_d2 : (((a2 :e R /\ b2x :e R) /\ c2 :e R) /\ d2 :e R).
    { exact (andEL (((a2 :e R /\ b2x :e R) /\ c2 :e R) /\ d2 :e R)
                  (Rlt a2 b2x)
                  Hb2left). }

    claim Ha1b1x_c1 : ((a1 :e R /\ b1x :e R) /\ c1 :e R).
    { exact (andEL ((a1 :e R /\ b1x :e R) /\ c1 :e R)
                  (d1 :e R)
                  Ha1b1x_c1_d1). }
    claim Ha2b2x_c2 : ((a2 :e R /\ b2x :e R) /\ c2 :e R).
    { exact (andEL ((a2 :e R /\ b2x :e R) /\ c2 :e R)
                  (d2 :e R)
                  Ha2b2x_c2_d2). }

    claim Ha1b1x : a1 :e R /\ b1x :e R.
    { exact (andEL (a1 :e R /\ b1x :e R) (c1 :e R) Ha1b1x_c1). }
    claim Ha2b2x : a2 :e R /\ b2x :e R.
    { exact (andEL (a2 :e R /\ b2x :e R) (c2 :e R) Ha2b2x_c2). }

    claim Ha1R : a1 :e R.
    { exact (andEL (a1 :e R) (b1x :e R) Ha1b1x). }
    claim Hb1xR : b1x :e R.
    { exact (andER (a1 :e R) (b1x :e R) Ha1b1x). }
    claim Hc1R : c1 :e R.
    { exact (andER (a1 :e R /\ b1x :e R) (c1 :e R) Ha1b1x_c1). }
    claim Hd1R : d1 :e R.
    { exact (andER ((a1 :e R /\ b1x :e R) /\ c1 :e R) (d1 :e R) Ha1b1x_c1_d1). }

    claim Ha2R : a2 :e R.
    { exact (andEL (a2 :e R) (b2x :e R) Ha2b2x). }
    claim Hb2xR : b2x :e R.
    { exact (andER (a2 :e R) (b2x :e R) Ha2b2x). }
    claim Hc2R : c2 :e R.
    { exact (andER (a2 :e R /\ b2x :e R) (c2 :e R) Ha2b2x_c2). }
    claim Hd2R : d2 :e R.
    { exact (andER ((a2 :e R /\ b2x :e R) /\ c2 :e R) (d2 :e R) Ha2b2x_c2_d2). }

    (** Show the chosen endpoints are real numbers **)
    claim Ha3R : a3 :e R.
    { rewrite Ha3def.
      apply (xm (a1 < a2)).
      - assume Hlt. rewrite (If_i_1 (a1 < a2) a2 a1 Hlt). exact Ha2R.
      - assume Hnlt. rewrite (If_i_0 (a1 < a2) a2 a1 Hnlt). exact Ha1R. }
    claim Hb3xR : b3x :e R.
    { rewrite Hb3def.
      apply (xm (b1x < b2x)).
      - assume Hlt. rewrite (If_i_1 (b1x < b2x) b1x b2x Hlt). exact Hb1xR.
      - assume Hnlt. rewrite (If_i_0 (b1x < b2x) b1x b2x Hnlt). exact Hb2xR. }
    claim Hc3R : c3 :e R.
    { rewrite Hc3def.
      apply (xm (c1 < c2)).
      - assume Hlt. rewrite (If_i_1 (c1 < c2) c2 c1 Hlt). exact Hc2R.
      - assume Hnlt. rewrite (If_i_0 (c1 < c2) c2 c1 Hnlt). exact Hc1R. }
    claim Hd3R : d3 :e R.
    { rewrite Hd3def.
      apply (xm (d1 < d2)).
      - assume Hlt. rewrite (If_i_1 (d1 < d2) d1 d2 Hlt). exact Hd1R.
      - assume Hnlt. rewrite (If_i_0 (d1 < d2) d1 d2 Hnlt). exact Hd2R. }

    (** Show x1,y1 are between the chosen endpoints **)
    claim Hax3 : Rlt a3 x1.
    { rewrite Ha3def.
      apply (xm (a1 < a2)).
      - assume Hlt. rewrite (If_i_1 (a1 < a2) a2 a1 Hlt). exact Ha2x1.
      - assume Hnlt. rewrite (If_i_0 (a1 < a2) a2 a1 Hnlt). exact Ha1x1. }
    claim Hxb3 : Rlt x1 b3x.
    { rewrite Hb3def.
      apply (xm (b1x < b2x)).
      - assume Hlt. rewrite (If_i_1 (b1x < b2x) b1x b2x Hlt). exact Hx1b1.
      - assume Hnlt. rewrite (If_i_0 (b1x < b2x) b1x b2x Hnlt). exact Hx1b2. }
    claim Hcy3 : Rlt c3 y1.
    { rewrite Hc3def.
      apply (xm (c1 < c2)).
      - assume Hlt. rewrite (If_i_1 (c1 < c2) c2 c1 Hlt). exact Hc2y1.
      - assume Hnlt. rewrite (If_i_0 (c1 < c2) c2 c1 Hnlt). exact Hc1y1. }
    claim Hyd3 : Rlt y1 d3.
    { rewrite Hd3def.
      apply (xm (d1 < d2)).
      - assume Hlt. rewrite (If_i_1 (d1 < d2) d1 d2 Hlt). exact Hy1d1.
      - assume Hnlt. rewrite (If_i_0 (d1 < d2) d1 d2 Hnlt). exact Hy1d2. }

    (** Define the rectangle b3rect with these endpoints **)
    set b3rect := {q :e EuclidPlane|
                     exists x0:set, exists y0:set,
                       q = (x0,y0) /\ Rlt a3 x0 /\ Rlt x0 b3x /\ Rlt c3 y0 /\ Rlt y0 d3}.

    witness b3rect.
    apply andI.
    - (** b3rect in rectangular_regions **)
      claim Hb3pow : b3rect :e Power EuclidPlane.
      { apply PowerI EuclidPlane b3rect.
        let q. assume Hq : q :e b3rect.
        exact (SepE1 EuclidPlane
                     (fun q0 : set =>
                       exists x0:set, exists y0:set,
                         q0 = (x0,y0) /\ Rlt a3 x0 /\ Rlt x0 b3x /\ Rlt c3 y0 /\ Rlt y0 d3)
                     q
                     Hq). }
      claim Hab3 : Rlt a3 b3x.
      { exact (Rlt_tra a3 x1 b3x Hax3 Hxb3). }
      claim Hcd3 : Rlt c3 d3.
      { exact (Rlt_tra c3 y1 d3 Hcy3 Hyd3). }
      claim Hprop :
        exists a0:set, exists b0:set, exists c0:set, exists d0:set,
          a0 :e R /\ b0 :e R /\ c0 :e R /\ d0 :e R /\ Rlt a0 b0 /\ Rlt c0 d0 /\
            b3rect = {p1 :e EuclidPlane|
                       exists x0:set, exists y0:set,
                         p1 = (x0,y0) /\ Rlt a0 x0 /\ Rlt x0 b0 /\ Rlt c0 y0 /\ Rlt y0 d0}.
      { witness a3. witness b3x. witness c3. witness d3.
        claim H1 : a3 :e R /\ b3x :e R.
        { apply andI.
          - exact Ha3R.
          - exact Hb3xR. }
        claim H12 : (a3 :e R /\ b3x :e R) /\ c3 :e R.
        { exact (andI (a3 :e R /\ b3x :e R) (c3 :e R) H1 Hc3R). }
        claim H123 : ((a3 :e R /\ b3x :e R) /\ c3 :e R) /\ d3 :e R.
        { exact (andI ((a3 :e R /\ b3x :e R) /\ c3 :e R) (d3 :e R) H12 Hd3R). }
        claim H1234 : (((a3 :e R /\ b3x :e R) /\ c3 :e R) /\ d3 :e R) /\ Rlt a3 b3x.
        { exact (andI (((a3 :e R /\ b3x :e R) /\ c3 :e R) /\ d3 :e R) (Rlt a3 b3x) H123 Hab3). }
        claim H12345 : ((((a3 :e R /\ b3x :e R) /\ c3 :e R) /\ d3 :e R) /\ Rlt a3 b3x) /\ Rlt c3 d3.
        { exact (andI ((((a3 :e R /\ b3x :e R) /\ c3 :e R) /\ d3 :e R) /\ Rlt a3 b3x) (Rlt c3 d3) H1234 Hcd3). }
        apply andI.
        - exact H12345.
        - reflexivity. }
      exact (SepI (Power EuclidPlane)
                  (fun U0 : set =>
                    exists a b c d:set, a :e R /\ b :e R /\ c :e R /\ d :e R /\ Rlt a b /\ Rlt c d /\
                      U0 = {p1 :e EuclidPlane|
                             exists x0:set, exists y0:set,
                               p1 = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b /\ Rlt c y0 /\ Rlt y0 d})
                  b3rect
                  Hb3pow
                  Hprop).
    - apply andI.
      + (** p is in b3rect **)
        claim HpEuclid : p :e EuclidPlane.
        { exact (SepE1 EuclidPlane
                     (fun q : set =>
                       exists x0:set, exists y0:set,
                         q = (x0,y0) /\ Rlt a1 x0 /\ Rlt x0 b1x /\ Rlt c1 y0 /\ Rlt y0 d1)
                     p
                     Hp1'). }
        claim Hpred :
          exists x0:set, exists y0:set,
            p = (x0,y0) /\ Rlt a3 x0 /\ Rlt x0 b3x /\ Rlt c3 y0 /\ Rlt y0 d3.
        { witness x1. witness y1.
          claim H1 : p = (x1,y1) /\ Rlt a3 x1.
          { exact (andI (p = (x1,y1)) (Rlt a3 x1) Hp_tup1 Hax3). }
          claim H12 : (p = (x1,y1) /\ Rlt a3 x1) /\ Rlt x1 b3x.
          { exact (andI (p = (x1,y1) /\ Rlt a3 x1) (Rlt x1 b3x) H1 Hxb3). }
          claim H123 : ((p = (x1,y1) /\ Rlt a3 x1) /\ Rlt x1 b3x) /\ Rlt c3 y1.
          { exact (andI ((p = (x1,y1) /\ Rlt a3 x1) /\ Rlt x1 b3x) (Rlt c3 y1) H12 Hcy3). }
          exact (andI (((p = (x1,y1) /\ Rlt a3 x1) /\ Rlt x1 b3x) /\ Rlt c3 y1) (Rlt y1 d3) H123 Hyd3). }
        exact (SepI EuclidPlane
                    (fun q : set =>
                      exists x0:set, exists y0:set,
                        q = (x0,y0) /\ Rlt a3 x0 /\ Rlt x0 b3x /\ Rlt c3 y0 /\ Rlt y0 d3)
                    p
                    HpEuclid
                    Hpred).
      + (** b3rect is contained in b1  b2 **)
        let q. assume Hq : q :e b3rect.
        prove q :e b1 :/\: b2.
        claim HqEuclid : q :e EuclidPlane.
        { exact (SepE1 EuclidPlane
                     (fun q0 : set =>
                       exists x0:set, exists y0:set,
                         q0 = (x0,y0) /\ Rlt a3 x0 /\ Rlt x0 b3x /\ Rlt c3 y0 /\ Rlt y0 d3)
                     q
                     Hq). }
        claim Hqcoords :
          exists xq:set, exists yq:set,
            q = (xq,yq) /\ Rlt a3 xq /\ Rlt xq b3x /\ Rlt c3 yq /\ Rlt yq d3.
        { exact (SepE2 EuclidPlane
                       (fun q0 : set =>
                         exists x0:set, exists y0:set,
                           q0 = (x0,y0) /\ Rlt a3 x0 /\ Rlt x0 b3x /\ Rlt c3 y0 /\ Rlt y0 d3)
                       q
                       Hq). }
        apply Hqcoords.
        let xq. assume Hqcoords2.
        apply Hqcoords2.
        let yq. assume Hqineq.
        claim Hqtup : q = (xq,yq).
        { claim H1 : (((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x) /\ Rlt c3 yq).
          { exact (andEL (((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x) /\ Rlt c3 yq)
                        (Rlt yq d3)
                        Hqineq). }
          claim H2 : ((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x).
          { exact (andEL ((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x)
                        (Rlt c3 yq)
                        H1). }
          claim H3 : (q = (xq,yq) /\ Rlt a3 xq).
          { exact (andEL (q = (xq,yq) /\ Rlt a3 xq)
                        (Rlt xq b3x)
                        H2). }
          exact (andEL (q = (xq,yq)) (Rlt a3 xq) H3). }
        claim Ha3xq : Rlt a3 xq.
        { claim H1 : (((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x) /\ Rlt c3 yq).
          { exact (andEL (((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x) /\ Rlt c3 yq)
                        (Rlt yq d3)
                        Hqineq). }
          claim H2 : ((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x).
          { exact (andEL ((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x)
                        (Rlt c3 yq)
                        H1). }
          claim H3 : (q = (xq,yq) /\ Rlt a3 xq).
          { exact (andEL (q = (xq,yq) /\ Rlt a3 xq)
                        (Rlt xq b3x)
                        H2). }
          exact (andER (q = (xq,yq)) (Rlt a3 xq) H3). }
        claim Hxqb3 : Rlt xq b3x.
        { claim H1 : (((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x) /\ Rlt c3 yq).
          { exact (andEL (((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x) /\ Rlt c3 yq)
                        (Rlt yq d3)
                        Hqineq). }
          claim H2 : ((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x).
          { exact (andEL ((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x)
                        (Rlt c3 yq)
                        H1). }
          exact (andER (q = (xq,yq) /\ Rlt a3 xq) (Rlt xq b3x) H2). }
        claim Hc3yq : Rlt c3 yq.
        { claim H1 : (((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x) /\ Rlt c3 yq).
          { exact (andEL (((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x) /\ Rlt c3 yq)
                        (Rlt yq d3)
                        Hqineq). }
          exact (andER ((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x) (Rlt c3 yq) H1). }
        claim Hyqd3 : Rlt yq d3.
        { exact (andER (((q = (xq,yq) /\ Rlt a3 xq) /\ Rlt xq b3x) /\ Rlt c3 yq) (Rlt yq d3) Hqineq). }

        (** Derive inequalities needed for membership in b1 and b2 **)
        claim Haxq : Rlt a1 xq /\ Rlt a2 xq.
        { claim HxqR : xq :e R.
          { exact (RltE_right a3 xq Ha3xq). }
          claim Ha1S : SNo a1.
          { exact (real_SNo a1 Ha1R). }
          claim Ha2S : SNo a2.
          { exact (real_SNo a2 Ha2R). }
          claim Ha3xq_if : Rlt (if a1 < a2 then a2 else a1) xq.
          { rewrite <- Ha3def. exact Ha3xq. }
          apply (SNoLt_trichotomy_or_impred a1 a2 Ha1S Ha2S (Rlt a1 xq /\ Rlt a2 xq)).
          - assume Ha1lt : a1 < a2.
            claim Ha1a2 : Rlt a1 a2.
            { exact (RltI a1 a2 Ha1R Ha2R Ha1lt). }
            claim Ha2xq : Rlt a2 xq.
            { rewrite <- (If_i_1 (a1 < a2) a2 a1 Ha1lt). exact Ha3xq_if. }
            claim Ha1xq : Rlt a1 xq.
            { exact (Rlt_tra a1 a2 xq Ha1a2 Ha2xq). }
            apply andI.
            - exact Ha1xq.
            - exact Ha2xq.
          - assume Haeq : a1 = a2.
            claim Hnlt : ~(a1 < a2).
            { assume Hlt.
              claim Hlt' : a1 < a1.
              { rewrite Haeq at 2. exact Hlt. }
              exact ((SNoLt_irref a1) Hlt'). }
            claim Ha1xq : Rlt a1 xq.
            { rewrite <- (If_i_0 (a1 < a2) a2 a1 Hnlt). exact Ha3xq_if. }
            claim Ha2xq : Rlt a2 xq.
            { rewrite <- Haeq. exact Ha1xq. }
            apply andI.
            - exact Ha1xq.
            - exact Ha2xq.
          - assume Ha2lt : a2 < a1.
            claim Hnlt : ~(a1 < a2).
            { assume Hlt.
              claim Ha2S' : SNo a2.
              { exact Ha2S. }
              claim Ha1S' : SNo a1.
              { exact Ha1S. }
              claim Ha2lt2 : a2 < a2.
              { exact (SNoLt_tra a2 a1 a2 Ha2S' Ha1S' Ha2S' Ha2lt Hlt). }
              exact ((SNoLt_irref a2) Ha2lt2). }
            claim Ha2a1 : Rlt a2 a1.
            { exact (RltI a2 a1 Ha2R Ha1R Ha2lt). }
            claim Ha1xq : Rlt a1 xq.
            { rewrite <- (If_i_0 (a1 < a2) a2 a1 Hnlt). exact Ha3xq_if. }
            claim Ha2xq : Rlt a2 xq.
            { exact (Rlt_tra a2 a1 xq Ha2a1 Ha1xq). }
            apply andI.
            - exact Ha1xq.
            - exact Ha2xq. }

        claim Hxbq : Rlt xq b1x /\ Rlt xq b2x.
        { claim HxqR : xq :e R.
          { exact (RltE_left xq b3x Hxqb3). }
          claim Hb1S : SNo b1x.
          { exact (real_SNo b1x Hb1xR). }
          claim Hb2S : SNo b2x.
          { exact (real_SNo b2x Hb2xR). }
          claim HxqS : SNo xq.
          { exact (real_SNo xq HxqR). }
          claim Hxqb3_if : Rlt xq (if b1x < b2x then b1x else b2x).
          { rewrite <- Hb3def. exact Hxqb3. }
          apply (SNoLt_trichotomy_or_impred b1x b2x Hb1S Hb2S (Rlt xq b1x /\ Rlt xq b2x)).
          - assume Hb1lt : b1x < b2x.
            claim Hb1b2 : Rlt b1x b2x.
            { exact (RltI b1x b2x Hb1xR Hb2xR Hb1lt). }
            claim Hxqb1 : Rlt xq b1x.
            { rewrite <- (If_i_1 (b1x < b2x) b1x b2x Hb1lt). exact Hxqb3_if. }
            claim Hxqb2 : Rlt xq b2x.
            { exact (Rlt_tra xq b1x b2x Hxqb1 Hb1b2). }
            apply andI.
            - exact Hxqb1.
            - exact Hxqb2.
          - assume Hbeq : b1x = b2x.
            claim Hnlt : ~(b1x < b2x).
            { assume Hlt.
              claim Hlt' : b1x < b1x.
              { rewrite Hbeq at 2. exact Hlt. }
              exact ((SNoLt_irref b1x) Hlt'). }
            claim Hxqb2 : Rlt xq b2x.
            { rewrite <- (If_i_0 (b1x < b2x) b1x b2x Hnlt). exact Hxqb3_if. }
            claim Hxqb1 : Rlt xq b1x.
            { rewrite Hbeq. exact Hxqb2. }
            apply andI.
            - exact Hxqb1.
            - exact Hxqb2.
          - assume Hb2lt : b2x < b1x.
            claim Hnlt : ~(b1x < b2x).
            { assume Hlt.
              claim Hb2lt2 : b2x < b2x.
              { exact (SNoLt_tra b2x b1x b2x Hb2S Hb1S Hb2S Hb2lt Hlt). }
              exact ((SNoLt_irref b2x) Hb2lt2). }
            claim Hb2b1 : Rlt b2x b1x.
            { exact (RltI b2x b1x Hb2xR Hb1xR Hb2lt). }
            claim Hxqb2 : Rlt xq b2x.
            { rewrite <- (If_i_0 (b1x < b2x) b1x b2x Hnlt). exact Hxqb3_if. }
            claim Hxqb1 : Rlt xq b1x.
            { exact (Rlt_tra xq b2x b1x Hxqb2 Hb2b1). }
            apply andI.
            - exact Hxqb1.
            - exact Hxqb2. }

        claim Hcyq : Rlt c1 yq /\ Rlt c2 yq.
        { claim HyqR : yq :e R.
          { exact (RltE_right c3 yq Hc3yq). }
          claim Hc1S : SNo c1.
          { exact (real_SNo c1 Hc1R). }
          claim Hc2S : SNo c2.
          { exact (real_SNo c2 Hc2R). }
          claim Hc3yq_if : Rlt (if c1 < c2 then c2 else c1) yq.
          { rewrite <- Hc3def. exact Hc3yq. }
          apply (SNoLt_trichotomy_or_impred c1 c2 Hc1S Hc2S (Rlt c1 yq /\ Rlt c2 yq)).
          - assume Hc1lt : c1 < c2.
            claim Hc1c2 : Rlt c1 c2.
            { exact (RltI c1 c2 Hc1R Hc2R Hc1lt). }
            claim Hc2yq : Rlt c2 yq.
            { rewrite <- (If_i_1 (c1 < c2) c2 c1 Hc1lt). exact Hc3yq_if. }
            claim Hc1yq : Rlt c1 yq.
            { exact (Rlt_tra c1 c2 yq Hc1c2 Hc2yq). }
            apply andI.
            - exact Hc1yq.
            - exact Hc2yq.
          - assume Hceq : c1 = c2.
            claim Hnlt : ~(c1 < c2).
            { assume Hlt.
              claim Hlt' : c1 < c1.
              { rewrite Hceq at 2. exact Hlt. }
              exact ((SNoLt_irref c1) Hlt'). }
            claim Hc1yq : Rlt c1 yq.
            { rewrite <- (If_i_0 (c1 < c2) c2 c1 Hnlt). exact Hc3yq_if. }
            claim Hc2yq : Rlt c2 yq.
            { rewrite <- Hceq. exact Hc1yq. }
            apply andI.
            - exact Hc1yq.
            - exact Hc2yq.
          - assume Hc2lt : c2 < c1.
            claim Hnlt : ~(c1 < c2).
            { assume Hlt.
              claim Hc2lt2 : c2 < c2.
              { exact (SNoLt_tra c2 c1 c2 Hc2S Hc1S Hc2S Hc2lt Hlt). }
              exact ((SNoLt_irref c2) Hc2lt2). }
            claim Hc2c1 : Rlt c2 c1.
            { exact (RltI c2 c1 Hc2R Hc1R Hc2lt). }
            claim Hc1yq : Rlt c1 yq.
            { rewrite <- (If_i_0 (c1 < c2) c2 c1 Hnlt). exact Hc3yq_if. }
            claim Hc2yq : Rlt c2 yq.
            { exact (Rlt_tra c2 c1 yq Hc2c1 Hc1yq). }
            apply andI.
            - exact Hc1yq.
            - exact Hc2yq. }

        claim Hydq : Rlt yq d1 /\ Rlt yq d2.
        { claim HyqR : yq :e R.
          { exact (RltE_left yq d3 Hyqd3). }
          claim Hd1S : SNo d1.
          { exact (real_SNo d1 Hd1R). }
          claim Hd2S : SNo d2.
          { exact (real_SNo d2 Hd2R). }
          claim HyqS : SNo yq.
          { exact (real_SNo yq HyqR). }
          claim Hyqd3_if : Rlt yq (if d1 < d2 then d1 else d2).
          { rewrite <- Hd3def. exact Hyqd3. }
          apply (SNoLt_trichotomy_or_impred d1 d2 Hd1S Hd2S (Rlt yq d1 /\ Rlt yq d2)).
          - assume Hd1lt : d1 < d2.
            claim Hd1d2 : Rlt d1 d2.
            { exact (RltI d1 d2 Hd1R Hd2R Hd1lt). }
            claim Hyqd1 : Rlt yq d1.
            { rewrite <- (If_i_1 (d1 < d2) d1 d2 Hd1lt). exact Hyqd3_if. }
            claim Hyqd2 : Rlt yq d2.
            { exact (Rlt_tra yq d1 d2 Hyqd1 Hd1d2). }
            apply andI.
            - exact Hyqd1.
            - exact Hyqd2.
          - assume Hdeq : d1 = d2.
            claim Hnlt : ~(d1 < d2).
            { assume Hlt.
              claim Hlt' : d1 < d1.
              { rewrite Hdeq at 2. exact Hlt. }
              exact ((SNoLt_irref d1) Hlt'). }
            claim Hyqd2 : Rlt yq d2.
            { rewrite <- (If_i_0 (d1 < d2) d1 d2 Hnlt). exact Hyqd3_if. }
            claim Hyqd1 : Rlt yq d1.
            { rewrite Hdeq. exact Hyqd2. }
            apply andI.
            - exact Hyqd1.
            - exact Hyqd2.
          - assume Hd2lt : d2 < d1.
            claim Hnlt : ~(d1 < d2).
            { assume Hlt.
              claim Hd2lt2 : d2 < d2.
              { exact (SNoLt_tra d2 d1 d2 Hd2S Hd1S Hd2S Hd2lt Hlt). }
              exact ((SNoLt_irref d2) Hd2lt2). }
            claim Hd2d1 : Rlt d2 d1.
            { exact (RltI d2 d1 Hd2R Hd1R Hd2lt). }
            claim Hyqd2 : Rlt yq d2.
            { rewrite <- (If_i_0 (d1 < d2) d1 d2 Hnlt). exact Hyqd3_if. }
            claim Hyqd1 : Rlt yq d1.
            { exact (Rlt_tra yq d2 d1 Hyqd2 Hd2d1). }
            apply andI.
            - exact Hyqd1.
            - exact Hyqd2. }

        (** Build membership in b1 and b2 using Hb1eq and Hb2eq **)
        claim Ha1xq : Rlt a1 xq.
        { exact (andEL (Rlt a1 xq) (Rlt a2 xq) Haxq). }
        claim Ha2xq : Rlt a2 xq.
        { exact (andER (Rlt a1 xq) (Rlt a2 xq) Haxq). }
        claim Hxqb1 : Rlt xq b1x.
        { exact (andEL (Rlt xq b1x) (Rlt xq b2x) Hxbq). }
        claim Hxqb2 : Rlt xq b2x.
        { exact (andER (Rlt xq b1x) (Rlt xq b2x) Hxbq). }
        claim Hc1yq : Rlt c1 yq.
        { exact (andEL (Rlt c1 yq) (Rlt c2 yq) Hcyq). }
        claim Hc2yq : Rlt c2 yq.
        { exact (andER (Rlt c1 yq) (Rlt c2 yq) Hcyq). }
        claim Hyqd1 : Rlt yq d1.
        { exact (andEL (Rlt yq d1) (Rlt yq d2) Hydq). }
        claim Hyqd2 : Rlt yq d2.
        { exact (andER (Rlt yq d1) (Rlt yq d2) Hydq). }

        claim Hpred1 :
          exists x0:set, exists y0:set,
            q = (x0,y0) /\ Rlt a1 x0 /\ Rlt x0 b1x /\ Rlt c1 y0 /\ Rlt y0 d1.
        { witness xq. witness yq.
          claim H1 : q = (xq,yq) /\ Rlt a1 xq.
          { exact (andI (q = (xq,yq)) (Rlt a1 xq) Hqtup Ha1xq). }
          claim H12 : (q = (xq,yq) /\ Rlt a1 xq) /\ Rlt xq b1x.
          { exact (andI (q = (xq,yq) /\ Rlt a1 xq) (Rlt xq b1x) H1 Hxqb1). }
          claim H123 : ((q = (xq,yq) /\ Rlt a1 xq) /\ Rlt xq b1x) /\ Rlt c1 yq.
          { exact (andI ((q = (xq,yq) /\ Rlt a1 xq) /\ Rlt xq b1x) (Rlt c1 yq) H12 Hc1yq). }
          exact (andI (((q = (xq,yq) /\ Rlt a1 xq) /\ Rlt xq b1x) /\ Rlt c1 yq) (Rlt yq d1) H123 Hyqd1). }
        claim Hpred2 :
          exists x0:set, exists y0:set,
            q = (x0,y0) /\ Rlt a2 x0 /\ Rlt x0 b2x /\ Rlt c2 y0 /\ Rlt y0 d2.
        { witness xq. witness yq.
          claim H1 : q = (xq,yq) /\ Rlt a2 xq.
          { exact (andI (q = (xq,yq)) (Rlt a2 xq) Hqtup Ha2xq). }
          claim H12 : (q = (xq,yq) /\ Rlt a2 xq) /\ Rlt xq b2x.
          { exact (andI (q = (xq,yq) /\ Rlt a2 xq) (Rlt xq b2x) H1 Hxqb2). }
          claim H123 : ((q = (xq,yq) /\ Rlt a2 xq) /\ Rlt xq b2x) /\ Rlt c2 yq.
          { exact (andI ((q = (xq,yq) /\ Rlt a2 xq) /\ Rlt xq b2x) (Rlt c2 yq) H12 Hc2yq). }
          exact (andI (((q = (xq,yq) /\ Rlt a2 xq) /\ Rlt xq b2x) /\ Rlt c2 yq) (Rlt yq d2) H123 Hyqd2). }

        claim Hqb1 : q :e b1.
        { rewrite Hb1eq.
          exact (SepI EuclidPlane
                      (fun q0 : set =>
                        exists x0:set, exists y0:set,
                          q0 = (x0,y0) /\ Rlt a1 x0 /\ Rlt x0 b1x /\ Rlt c1 y0 /\ Rlt y0 d1)
                      q
                      HqEuclid
                      Hpred1). }
        claim Hqb2 : q :e b2.
        { rewrite Hb2eq.
          exact (SepI EuclidPlane
                      (fun q0 : set =>
                        exists x0:set, exists y0:set,
                          q0 = (x0,y0) /\ Rlt a2 x0 /\ Rlt x0 b2x /\ Rlt c2 y0 /\ Rlt y0 d2)
                      q
                      HqEuclid
                      Hpred2). }
        exact (binintersectI b1 b2 q Hqb1 Hqb2).
Qed.

(** from 13 Example 4: circular and rectangular bases generate the same topology **)
(** LATEX VERSION: The topology generated by circular regions equals the topology generated by rectangular regions in R^2. **)
(** LATEX VERSION: This is shown by local refinement in both directions: each circular neighborhood contains a rectangular one, and each rectangular neighborhood contains a circular one. **)

(** from 13 Example 4: rectangular neighborhoods inside circular neighborhoods **)
(** LATEX VERSION: For any point x in a circular region, there is an open rectangle containing x and contained in that circular region. **)
Theorem rectangular_refines_circular_plane :
  forall b :e circular_regions, forall x:set,
    x :e b -> exists r :e rectangular_regions, x :e r /\ r c= b.
let b. assume Hb.
let x. assume Hxb.
prove exists r :e rectangular_regions, x :e r /\ r c= b.
(** Unpack b as a circular region around some center c with radius r0 **)
claim Hbprop :
  exists c:set, exists r0:set,
    c :e EuclidPlane /\ Rlt 0 r0 /\
    b = {p :e EuclidPlane|Rlt (distance_R2 p c) r0}.
{ exact (SepE2 (Power EuclidPlane)
               (fun U0 : set => exists c:set, exists r:set,
                 c :e EuclidPlane /\ Rlt 0 r /\
                 U0 = {p :e EuclidPlane|Rlt (distance_R2 p c) r})
               b
               Hb). }
apply Hbprop.
let c. assume Hbprop2.
apply Hbprop2.
let r0. assume Hbcore.
claim Hcr0 : c :e EuclidPlane /\ Rlt 0 r0.
{ exact (andEL (c :e EuclidPlane /\ Rlt 0 r0)
              (b = {p :e EuclidPlane|Rlt (distance_R2 p c) r0})
              Hbcore). }
claim Hc : c :e EuclidPlane.
{ exact (andEL (c :e EuclidPlane) (Rlt 0 r0) Hcr0). }
claim Hr0 : Rlt 0 r0.
{ exact (andER (c :e EuclidPlane) (Rlt 0 r0) Hcr0). }
claim HbEq : b = {p :e EuclidPlane|Rlt (distance_R2 p c) r0}.
{ exact (andER (c :e EuclidPlane /\ Rlt 0 r0)
              (b = {p :e EuclidPlane|Rlt (distance_R2 p c) r0})
              Hbcore). }
claim Hxb' : x :e {p :e EuclidPlane|Rlt (distance_R2 p c) r0}.
{ rewrite <- HbEq. exact Hxb. }
claim HxE : x :e EuclidPlane.
{ exact (SepE1 EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 c) r0) x Hxb'). }
claim Hxball : Rlt (distance_R2 x c) r0.
{ exact (SepE2 EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 c) r0) x Hxb'). }

(** Core refinement: build a rectangle around x inside the ball around c **)
apply (rectangle_inside_ball x c r0 HxE Hc Hr0 Hxball).
let r. assume Hrpair.
witness r.
claim Hr : r :e rectangular_regions.
{ exact (andEL (r :e rectangular_regions) (x :e r /\ r c= {p :e EuclidPlane|Rlt (distance_R2 p c) r0}) Hrpair). }
claim Hrprop : x :e r /\ r c= {p :e EuclidPlane|Rlt (distance_R2 p c) r0}.
{ exact (andER (r :e rectangular_regions) (x :e r /\ r c= {p :e EuclidPlane|Rlt (distance_R2 p c) r0}) Hrpair). }
claim Hxr : x :e r.
{ exact (andEL (x :e r) (r c= {p :e EuclidPlane|Rlt (distance_R2 p c) r0}) Hrprop). }
claim Hrsub : r c= {p :e EuclidPlane|Rlt (distance_R2 p c) r0}.
{ exact (andER (x :e r) (r c= {p :e EuclidPlane|Rlt (distance_R2 p c) r0}) Hrprop). }
claim Hrsubb : r c= b.
{ rewrite HbEq. exact Hrsub. }
apply andI.
- exact Hr.
- apply andI.
  + exact Hxr.
  + exact Hrsubb.
Qed.

(** from 13 Example 4: circular neighborhoods inside rectangular neighborhoods **)
(** LATEX VERSION: For any point x in an open rectangle, there is a circular region containing x and contained in that rectangle. **)
Theorem circular_refines_rectangular_plane :
  forall b :e rectangular_regions, forall x:set,
    x :e b -> exists u :e circular_regions, x :e u /\ u c= b.
let b. assume Hb.
let x. assume Hxb.
prove exists u :e circular_regions, x :e u /\ u c= b.
(** Unpack b as a rectangle with endpoints a,b0,c,d0 **)
claim Hbprop :
  exists a:set, exists b0:set, exists c:set, exists d0:set,
    a :e R /\ b0 :e R /\ c :e R /\ d0 :e R /\ Rlt a b0 /\ Rlt c d0 /\
      b = {p :e EuclidPlane|
             exists x0:set, exists y0:set,
               p = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b0 /\ Rlt c y0 /\ Rlt y0 d0}.
{ exact (SepE2 (Power EuclidPlane)
               (fun U0 : set =>
                 exists a b c d:set, a :e R /\ b :e R /\ c :e R /\ d :e R /\ Rlt a b /\ Rlt c d /\
                   U0 = {p1 :e EuclidPlane|
                          exists x0:set, exists y0:set,
                            p1 = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b /\ Rlt c y0 /\ Rlt y0 d})
               b
               Hb). }
apply Hbprop.
let a. assume Hbprop2.
apply Hbprop2.
let b0. assume Hbprop3.
apply Hbprop3.
let c. assume Hbprop4.
apply Hbprop4.
let d0. assume Hbcore.
claim HbEq :
  b = {p :e EuclidPlane|
         exists x0:set, exists y0:set,
           p = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b0 /\ Rlt c y0 /\ Rlt y0 d0}.
{ exact (andER (a :e R /\ b0 :e R /\ c :e R /\ d0 :e R /\ Rlt a b0 /\ Rlt c d0)
              (b = {p :e EuclidPlane|
                     exists x0:set, exists y0:set,
                       p = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b0 /\ Rlt c y0 /\ Rlt y0 d0})
              Hbcore). }
claim Hxb' : x :e {p :e EuclidPlane|
                    exists x0:set, exists y0:set,
                      p = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b0 /\ Rlt c y0 /\ Rlt y0 d0}.
{ rewrite <- HbEq. exact Hxb. }
claim HxE : x :e EuclidPlane.
{ exact (SepE1 EuclidPlane
             (fun p1 : set =>
               exists x0:set, exists y0:set,
                 p1 = (x0,y0) /\ Rlt a x0 /\ Rlt x0 b0 /\ Rlt c y0 /\ Rlt y0 d0)
             x
             Hxb'). }

(** Core refinement: build a small circular region around x contained in the rectangle **)
apply (ball_inside_rectangle b x Hb HxE Hxb).
let r3. assume Hrad2.
claim Hr3 : Rlt 0 r3.
{ exact (andEL (Rlt 0 r3)
              (forall p:set, p :e EuclidPlane -> Rlt (distance_R2 p x) r3 -> p :e b)
              Hrad2). }
claim HradP : forall p:set, p :e EuclidPlane -> Rlt (distance_R2 p x) r3 -> p :e b.
{ exact (andER (Rlt 0 r3)
              (forall p:set, p :e EuclidPlane -> Rlt (distance_R2 p x) r3 -> p :e b)
              Hrad2). }
set u := {p :e EuclidPlane|Rlt (distance_R2 p x) r3}.
witness u.
apply andI.
- prove u :e circular_regions.
  claim HuDef : u = {p :e EuclidPlane|Rlt (distance_R2 p x) r3}.
  { reflexivity. }
  rewrite HuDef.
  exact (circular_regionI x r3 HxE Hr3).
- apply andI.
  + prove x :e u.
    claim HxBall : Rlt (distance_R2 x x) r3.
    { rewrite (distance_R2_refl_0 x HxE).
      exact Hr3. }
    exact (SepI EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 x) r3) x HxE HxBall).
  + prove u c= b.
    let p. assume Hp : p :e u.
    claim HpE : p :e EuclidPlane.
    { exact (SepE1 EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 x) r3) p Hp). }
    claim HpBall : Rlt (distance_R2 p x) r3.
    { exact (SepE2 EuclidPlane (fun p0 : set => Rlt (distance_R2 p0 x) r3) p Hp). }
    exact (HradP p HpE HpBall).
Qed.

Theorem circular_rectangular_same_topology_plane :
  generated_topology EuclidPlane circular_regions = generated_topology EuclidPlane rectangular_regions.
prove generated_topology EuclidPlane circular_regions = generated_topology EuclidPlane rectangular_regions.
apply set_ext.
- (** inclusion: generated_topology EuclidPlane circular_regions c= generated_topology EuclidPlane rectangular_regions **)
  let U. assume HU : U :e generated_topology EuclidPlane circular_regions.
  prove U :e generated_topology EuclidPlane rectangular_regions.
  claim HUPow : U :e Power EuclidPlane.
  { exact (SepE1 (Power EuclidPlane)
                 (fun U0 : set =>
                   forall x0 :e U0, exists b :e circular_regions, x0 :e b /\ b c= U0)
                 U
                 HU). }
  claim HUprop : forall x0 :e U, exists b :e circular_regions, x0 :e b /\ b c= U.
  { exact (SepE2 (Power EuclidPlane)
                 (fun U0 : set =>
                   forall x0 :e U0, exists b :e circular_regions, x0 :e b /\ b c= U0)
                 U
                 HU). }
  claim HUsub : U c= EuclidPlane.
  { exact (PowerE EuclidPlane U HUPow). }
  claim HUrect : forall x0 :e U, exists r :e rectangular_regions, x0 :e r /\ r c= U.
  { let x0. assume Hx0U.
    claim Hexb : exists b :e circular_regions, x0 :e b /\ b c= U.
    { exact (HUprop x0 Hx0U). }
    apply Hexb.
    let b. assume Hbpair.
    claim Hb : b :e circular_regions.
    { exact (andEL (b :e circular_regions) (x0 :e b /\ b c= U) Hbpair). }
    claim Hbprop : x0 :e b /\ b c= U.
    { exact (andER (b :e circular_regions) (x0 :e b /\ b c= U) Hbpair). }
    claim Hx0b : x0 :e b.
    { exact (andEL (x0 :e b) (b c= U) Hbprop). }
    claim HbsubU : b c= U.
    { exact (andER (x0 :e b) (b c= U) Hbprop). }
    claim Hexr : exists r :e rectangular_regions, x0 :e r /\ r c= b.
    { exact (rectangular_refines_circular_plane b Hb x0 Hx0b). }
    apply Hexr.
    let r. assume Hrpair.
    claim Hr : r :e rectangular_regions.
    { exact (andEL (r :e rectangular_regions) (x0 :e r /\ r c= b) Hrpair). }
    claim Hrprop : x0 :e r /\ r c= b.
    { exact (andER (r :e rectangular_regions) (x0 :e r /\ r c= b) Hrpair). }
    claim Hx0r : x0 :e r.
    { exact (andEL (x0 :e r) (r c= b) Hrprop). }
    claim Hrsubb : r c= b.
    { exact (andER (x0 :e r) (r c= b) Hrprop). }
    claim HrsubU : r c= U.
    { exact (Subq_tra r b U Hrsubb HbsubU). }
    witness r.
    apply andI.
    - exact Hr.
    - apply andI.
      + exact Hx0r.
      + exact HrsubU. }
  exact (SepI (Power EuclidPlane)
              (fun U0 : set =>
                forall x0 :e U0, exists r :e rectangular_regions, x0 :e r /\ r c= U0)
              U
              HUPow
              HUrect).
- (** inclusion: generated_topology EuclidPlane rectangular_regions c= generated_topology EuclidPlane circular_regions **)
  let U. assume HU : U :e generated_topology EuclidPlane rectangular_regions.
  prove U :e generated_topology EuclidPlane circular_regions.
  claim HUPow : U :e Power EuclidPlane.
  { exact (SepE1 (Power EuclidPlane)
                 (fun U0 : set =>
                   forall x0 :e U0, exists b :e rectangular_regions, x0 :e b /\ b c= U0)
                 U
                 HU). }
  claim HUprop : forall x0 :e U, exists b :e rectangular_regions, x0 :e b /\ b c= U.
  { exact (SepE2 (Power EuclidPlane)
                 (fun U0 : set =>
                   forall x0 :e U0, exists b :e rectangular_regions, x0 :e b /\ b c= U0)
                 U
                 HU). }
  claim HUcirc : forall x0 :e U, exists u :e circular_regions, x0 :e u /\ u c= U.
  { let x0. assume Hx0U.
    claim Hexb : exists b :e rectangular_regions, x0 :e b /\ b c= U.
    { exact (HUprop x0 Hx0U). }
    apply Hexb.
    let b. assume Hbpair.
    claim Hb : b :e rectangular_regions.
    { exact (andEL (b :e rectangular_regions) (x0 :e b /\ b c= U) Hbpair). }
    claim Hbprop : x0 :e b /\ b c= U.
    { exact (andER (b :e rectangular_regions) (x0 :e b /\ b c= U) Hbpair). }
    claim Hx0b : x0 :e b.
    { exact (andEL (x0 :e b) (b c= U) Hbprop). }
    claim HbsubU : b c= U.
    { exact (andER (x0 :e b) (b c= U) Hbprop). }
    claim Hexu : exists u :e circular_regions, x0 :e u /\ u c= b.
    { exact (circular_refines_rectangular_plane b Hb x0 Hx0b). }
    apply Hexu.
    let u. assume Hupair.
    claim Hu : u :e circular_regions.
    { exact (andEL (u :e circular_regions) (x0 :e u /\ u c= b) Hupair). }
    claim Huprop : x0 :e u /\ u c= b.
    { exact (andER (u :e circular_regions) (x0 :e u /\ u c= b) Hupair). }
    claim Hx0u : x0 :e u.
    { exact (andEL (x0 :e u) (u c= b) Huprop). }
    claim Husubb : u c= b.
    { exact (andER (x0 :e u) (u c= b) Huprop). }
    claim HusubU : u c= U.
    { exact (Subq_tra u b U Husubb HbsubU). }
    witness u.
    apply andI.
    - exact Hu.
    - apply andI.
      + exact Hx0u.
      + exact HusubU. }
  exact (SepI (Power EuclidPlane)
              (fun U0 : set =>
                forall x0 :e U0, exists b :e circular_regions, x0 :e b /\ b c= U0)
              U
              HUPow
              HUcirc).
Qed.

(** from 13: refinement of basis yields finer topology **) 
(** LATEX VERSION: If B refines every open set of the topology generated by B, then T(B) is finer than T(B). **)
Theorem lemma_finer_if_basis_refines : forall X B B':set,
  basis_on X B -> basis_refines X B' (generated_topology X B) ->
  finer_than (generated_topology X B') (generated_topology X B).
let X B B'. assume HBasis Href.
claim Hprop : forall U :e generated_topology X B, forall x :e U, exists b' :e B', x :e b' /\ b' c= U.
{ exact (andER (topology_on X (generated_topology X B))
               (forall U :e generated_topology X B, forall x :e U, exists b' :e B', x :e b' /\ b' c= U)
               Href). }
prove generated_topology X B c= generated_topology X B'.
  let U. assume HU.
  claim HUsubX : U c= X.
  { exact (PowerE X U (SepE1 (Power X)
                             (fun U0 : set => forall x0 :e U0, exists b0 :e B, x0 :e b0 /\ b0 c= U0)
                             U HU)). }
  claim HUprop : forall x :e U, exists b' :e B', x :e b' /\ b' c= U.
  { exact (Hprop U HU). }
  exact (SepI (Power X)
              (fun U0 : set => forall x0 :e U0, exists b0 :e B', x0 :e b0 /\ b0 c= U0)
              U
              (PowerI X U HUsubX)
              HUprop).
Qed.

(** from 13 Definition: subbasis and its generated topology **) 
(** LATEX VERSION: A subbasis S for a topology on X is a collection of subsets of X whose union equals X. **)
Definition subbasis_on : set -> set -> prop := fun X S =>
  S c= Power X /\ Union S = X.

(** from 13: finite intersections of subbasis elements **)
(** LATEX VERSION: intersection_of_family collects common points of all sets in a family; finite_subcollections picks finite families; finite_intersections_of X S takes intersections of finite subfamilies of S. **)
(** FIXED: Now takes ambient set X as first parameter. Empty family correctly gives X.
    For empty Fam: all x in X vacuously satisfy "forall U :e Empty, x :e U", so result is X.
    For nonempty Fam: standard intersection of all sets in family, within X. **)
Definition intersection_of_family : set -> set -> set :=
  fun X Fam => {x :e X|forall U:set, U :e Fam -> x :e U}.

(** helper: intersection of a family stays in the ambient union **) 
(** LATEX VERSION: Placeholder lemma: each member of an intersection lies in the union of the family (to be proved properly). **)
Definition finite_subcollections : set -> set :=
  fun S => {F :e Power S|finite F}.

(** FIXED: Now takes X to pass to intersection_of_family. **)
Definition finite_intersections_of : set -> set -> set := fun X S =>
  {intersection_of_family X F|F :e finite_subcollections S}.

(** from 13: basis obtained from a subbasis by finite intersections **)
(** LATEX VERSION: basis_of_subbasis X S is the set of nonempty finite intersections of elements of S. **)
(** FIXED: Now properly uses X parameter. Empty intersection gives X.
    Filter keeps only nonempty intersections (so X included only if X nonempty). **)
Definition basis_of_subbasis : set -> set -> set := fun X S =>
  {b :e finite_intersections_of X S | b <> Empty}.

(** Helper: Finite intersection of a family is in the basis_of_subbasis **)
Theorem finite_intersection_in_basis : forall X S F:set,
  F :e finite_subcollections S ->
  intersection_of_family X F <> Empty ->
  intersection_of_family X F :e basis_of_subbasis X S.
let X S F. assume HF Hnon.
prove intersection_of_family X F :e basis_of_subbasis X S.
(** basis_of_subbasis X S = {b :e finite_intersections_of X S | b <> Empty} **)
exact (SepI (finite_intersections_of X S) (fun b:set => b <> Empty) (intersection_of_family X F)
            (ReplI (finite_subcollections S) (fun F0 : set => intersection_of_family X F0) F HF)
            Hnon).
 
Qed.

(** Helper: empty family intersection equals X **)
Theorem intersection_of_family_empty_eq : forall X:set,
  intersection_of_family X Empty = X.
let X.
apply set_ext.
- let x. assume Hx: x :e intersection_of_family X Empty.
  prove x :e X.
  exact (SepE1 X (fun x0 : set => forall U:set, U :e Empty -> x0 :e U) x Hx).
- let x. assume HxX: x :e X.
  prove x :e intersection_of_family X Empty.
  exact (SepI X (fun x0 : set => forall U:set, U :e Empty -> x0 :e U) x
              HxX
              (fun U HU => EmptyE U HU (x :e U))).
Qed.

(** Helper: singleton family intersection equals the set when it is a subset of X **)
Theorem intersection_of_family_singleton_eq : forall X s:set,
  s c= X ->
  intersection_of_family X {s} = s.
let X s. assume HsSubX.
apply set_ext.
- let x. assume Hx: x :e intersection_of_family X {s}.
  prove x :e s.
  claim Hall: forall U:set, U :e {s} -> x :e U.
  { exact (SepE2 X (fun x0 : set => forall U:set, U :e {s} -> x0 :e U) x Hx). }
  exact (Hall s (SingI s)).
- let x. assume Hx: x :e s.
  prove x :e intersection_of_family X {s}.
  claim HxX: x :e X.
  { exact (HsSubX x Hx). }
  claim Hprop: forall U:set, U :e {s} -> x :e U.
  { let U. assume HU: U :e {s}.
    prove x :e U.
    claim HUeq: U = s.
    { exact (SingE s U HU). }
    rewrite HUeq.
    exact Hx.
  }
  exact (SepI X (fun x0 : set => forall U:set, U :e {s} -> x0 :e U) x HxX Hprop).
Qed.

(** Helper: Elements of subbasis are in the generated basis **)
Theorem subbasis_elem_in_basis : forall X S s:set,
  subbasis_on X S ->
  s :e S ->
  s <> Empty ->
  s :e basis_of_subbasis X S.
let X S s. assume HSsub HsS HsNonempty.
prove s :e basis_of_subbasis X S.
claim HS: S c= Power X.
{ exact (andEL (S c= Power X) (Union S = X) HSsub). }
claim HsPow: s :e Power X.
{ exact (HS s HsS). }
claim HsSubX: s c= X.
{ exact (PowerE X s HsPow). }
set F := {s}.
claim HFPower: F :e Power S.
{ apply PowerI S F.
  let t. assume Ht: t :e F.
  prove t :e S.
  claim HtEq: t = s.
  { exact (SingE s t Ht). }
  rewrite HtEq.
  exact HsS.
}
claim HFinF: finite F.
{ exact (Sing_finite s). }
claim HFsubcol: F :e finite_subcollections S.
{ exact (SepI (Power S) (fun F0 : set => finite F0) F HFPower HFinF). }
claim HinterEq: intersection_of_family X F = s.
{ exact (intersection_of_family_singleton_eq X s HsSubX). }
claim HinterNonempty: intersection_of_family X F <> Empty.
{ rewrite HinterEq. exact HsNonempty. }
claim HinterInBasis: intersection_of_family X F :e basis_of_subbasis X S.
{ exact (finite_intersection_in_basis X S F HFsubcol HinterNonempty). }
rewrite <- HinterEq at 1.
exact HinterInBasis.
Qed.

(** Helper: X itself (empty intersection) is in the basis when nonempty **)
Theorem X_in_basis_of_subbasis : forall X S:set,
  X <> Empty ->
  X :e basis_of_subbasis X S.
let X S. assume HXnonempty.
prove X :e basis_of_subbasis X S.
set F := Empty.
claim HFPower: F :e Power S.
{ exact (Empty_In_Power S). }
claim HFinF: finite F.
{ exact finite_Empty. }
claim HFsubcol: F :e finite_subcollections S.
{ exact (SepI (Power S) (fun F0 : set => finite F0) F HFPower HFinF). }
claim HinterEq: intersection_of_family X F = X.
{ exact (intersection_of_family_empty_eq X). }
claim HinterNonempty: intersection_of_family X F <> Empty.
{ rewrite HinterEq. exact HXnonempty. }
claim HinterInBasis: intersection_of_family X F :e basis_of_subbasis X S.
{ exact (finite_intersection_in_basis X S F HFsubcol HinterNonempty). }
rewrite <- HinterEq at 1.
exact HinterInBasis.
Qed.

(** Helper: Finite intersection of topology elements is in the topology **)
Theorem intersection_of_family_adjoin : forall X F U:set,
  intersection_of_family X (F :\/: {U}) = (intersection_of_family X F) :/\: U.
let X F U.
apply set_ext.
- let x. assume Hx: x :e intersection_of_family X (F :\/: {U}).
  prove x :e (intersection_of_family X F) :/\: U.
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0 : set => forall T:set, T :e (F :\/: {U}) -> x0 :e T) x Hx). }
  claim Hall: forall T:set, T :e (F :\/: {U}) -> x :e T.
  { exact (SepE2 X (fun x0 : set => forall T:set, T :e (F :\/: {U}) -> x0 :e T) x Hx). }
  claim HxInF: x :e intersection_of_family X F.
  { exact (SepI X (fun x0 : set => forall T:set, T :e F -> x0 :e T) x
                HxX
                (fun T HT => Hall T (binunionI1 F {U} T HT))). }
  claim HxU: x :e U.
  { exact (Hall U (binunionI2 F {U} U (SingI U))). }
  exact (binintersectI (intersection_of_family X F) U x HxInF HxU).
- let x. assume Hx: x :e (intersection_of_family X F) :/\: U.
  prove x :e intersection_of_family X (F :\/: {U}).
  claim HxInF: x :e intersection_of_family X F.
  { exact (binintersectE1 (intersection_of_family X F) U x Hx). }
  claim HxU: x :e U.
  { exact (binintersectE2 (intersection_of_family X F) U x Hx). }
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0 : set => forall T:set, T :e F -> x0 :e T) x HxInF). }
  claim HallF: forall T:set, T :e F -> x :e T.
  { exact (SepE2 X (fun x0 : set => forall T:set, T :e F -> x0 :e T) x HxInF). }
  claim Hall: forall T:set, T :e (F :\/: {U}) -> x :e T.
  { let T. assume HT.
    prove x :e T.
    apply (binunionE' F {U} T (x :e T)).
    - assume HTF: T :e F.
      exact (HallF T HTF).
    - assume HTU: T :e {U}.
      claim HUeq: T = U.
      { exact (SingE U T HTU). }
      rewrite HUeq.
      exact HxU.
    - exact HT.
  }
  exact (SepI X (fun x0 : set => forall T:set, T :e (F :\/: {U}) -> x0 :e T) x
              HxX
              Hall).
Qed.

Theorem finite_intersection_in_topology : forall X T F:set,
  topology_on X T ->
  F :e Power T ->
  finite F ->
  intersection_of_family X F :e T.
let X T F.
assume HTtop: topology_on X T.
assume HFpow: F :e Power T.
assume HFin: finite F.
prove intersection_of_family X F :e T.
(** Use finite induction on F with property: if F c= T then intersection is open **)
claim HpEmpty: Empty :e Power T -> intersection_of_family X Empty :e T.
{ assume HpowEmpty.
  rewrite (intersection_of_family_empty_eq X).
  exact (topology_has_X X T HTtop).
}
claim HpStep: forall F0 y:set,
  finite F0 ->
  y /:e F0 ->
  (F0 :e Power T -> intersection_of_family X F0 :e T) ->
  ((F0 :\/: {y}) :e Power T -> intersection_of_family X (F0 :\/: {y}) :e T).
{ let F0 y.
  assume HFin0 HyNotin IH.
  assume HpowUnion: (F0 :\/: {y}) :e Power T.
  claim HsubUnion: F0 :\/: {y} c= T.
  { exact (PowerE T (F0 :\/: {y}) HpowUnion). }
  claim HsubF0: F0 c= T.
  { let U. assume HU: U :e F0.
    exact (HsubUnion U (binunionI1 F0 {y} U HU)). }
  claim HF0pow: F0 :e Power T.
  { exact (PowerI T F0 HsubF0). }
  claim HinterF0: intersection_of_family X F0 :e T.
  { exact (IH HF0pow). }
  claim HyT: y :e T.
  { exact (HsubUnion y (binunionI2 F0 {y} y (SingI y))). }
  rewrite (intersection_of_family_adjoin X F0 y).
  exact (topology_binintersect_closed X T (intersection_of_family X F0) y HTtop HinterF0 HyT).
}
claim Hall: forall F0:set, finite F0 -> (F0 :e Power T -> intersection_of_family X F0 :e T).
{ exact (finite_ind (fun F0:set => F0 :e Power T -> intersection_of_family X F0 :e T) HpEmpty HpStep). }
claim Hspec: F :e Power T -> intersection_of_family X F :e T.
{ exact (Hall F HFin). }
exact (Hspec HFpow).
Qed.

(** from 13: topology generated by a subbasis **) 
(** LATEX VERSION: generated_topology_from_subbasis X S is the topology generated by the basis arising from S. **)
Definition generated_topology_from_subbasis : set -> set -> set :=
  fun X S => generated_topology X (basis_of_subbasis X S).

(** from 13: finite intersections of a subbasis form a basis **) 
(** LATEX VERSION: The set of nonempty finite intersections of subbasis elements forms a basis. **)
Theorem finite_intersections_basis_of_subbasis : forall X S:set,
  subbasis_on X S -> basis_on X (basis_of_subbasis X S).
let X S.
assume HS.
prove basis_on X (basis_of_subbasis X S).
(** basis_on X B requires: B c= Power X, covering, and intersection property **)
prove basis_of_subbasis X S c= Power X
  /\ (forall x :e X, exists b :e basis_of_subbasis X S, x :e b)
  /\ (forall b1 :e basis_of_subbasis X S, forall b2 :e basis_of_subbasis X S, forall x:set,
        x :e b1 -> x :e b2 -> exists b3 :e basis_of_subbasis X S, x :e b3 /\ b3 c= b1 :/\: b2).
apply andI.
- (** Build left-associative conjunction **)
  apply andI.
  + (** Axiom 1: basis_of_subbasis X S c= Power X **)
    let b. assume Hb: b :e basis_of_subbasis X S.
    prove b :e Power X.
    (** b is a nonempty finite intersection of subbasis elements **)
    (** basis_of_subbasis X S = {b :e finite_intersections_of X S | b <> Empty} **)
    claim Hb_in_finite: b :e finite_intersections_of X S.
    { exact (SepE1 (finite_intersections_of X S) (fun b0 => b0 <> Empty) b Hb). }
    (** finite_intersections_of X S = {intersection_of_family F | F :e finite_subcollections S} **)
    (** So b = intersection_of_family F for some finite F c= S **)
    claim Hex: exists F :e finite_subcollections S, b = intersection_of_family X F.
    { exact (ReplE (finite_subcollections S) (fun F => intersection_of_family X F) b Hb_in_finite). }
    apply Hex.
    let F. assume HF_and_eq. apply HF_and_eq.
    assume HF: F :e finite_subcollections S.
    assume Hbeq: b = intersection_of_family X F.
    prove b :e Power X.
    apply PowerI.
    (** Need to show b c= X **)
    let x. assume Hx: x :e b.
    prove x :e X.
    (** With new definition: intersection_of_family X F = {x :e X | forall U :e F, x :e U}
        So x :e intersection_of_family X F directly gives x :e X **)
    claim Hx_intersect: x :e intersection_of_family X F.
    { rewrite <- Hbeq. exact Hx. }
    exact (SepE1 X (fun x0 => forall U:set, U :e F -> x0 :e U) x Hx_intersect).
  + (** Axiom 2: covering property - forall x :e X, exists b :e basis_of_subbasis X S, x :e b **)
    let x. assume Hx: x :e X.
    prove exists b :e basis_of_subbasis X S, x :e b.
    (** Use Union S = X from subbasis_on: pick s :e S with x :e s, then s is a nonempty finite intersection **)
    claim HSsub: S c= Power X.
    { exact (andEL (S c= Power X) (Union S = X) HS). }
    claim HUnionS: Union S = X.
    { exact (andER (S c= Power X) (Union S = X) HS). }
    claim HxUnionS: x :e Union S.
    { rewrite HUnionS. exact Hx. }
    apply (UnionE_impred S x HxUnionS).
    let s. assume Hxs: x :e s. assume HsS: s :e S.
    claim HsNe: s <> Empty.
    { assume Hseq: s = Empty.
      claim HxEmpty: x :e Empty.
      { rewrite <- Hseq. exact Hxs. }
      exact (EmptyE x HxEmpty).
    }
    claim HsInBasis: s :e basis_of_subbasis X S.
    { exact (subbasis_elem_in_basis X S s HS HsS HsNe). }
    witness s.
    apply andI.
    * exact HsInBasis.
    * exact Hxs.
- (** Axiom 3: intersection property **)
  let b1. assume Hb1: b1 :e basis_of_subbasis X S.
  let b2. assume Hb2: b2 :e basis_of_subbasis X S.
  let x. assume Hxb1: x :e b1. assume Hxb2: x :e b2.
  prove exists b3 :e basis_of_subbasis X S, x :e b3 /\ b3 c= b1 :/\: b2.
  (** b1 and b2 are finite intersections; their intersection is also a finite intersection **)
  (** Take b3 = b1 :/\: b2 if nonempty **)
  set b3 := b1 :/\: b2.
  claim Hxb3: x :e b3.
  { apply binintersectI. exact Hxb1. exact Hxb2. }
  claim Hb3_ne: b3 <> Empty.
  { assume Hempty: b3 = Empty.
    claim Hx_in_empty: x :e Empty.
    { rewrite <- Hempty. exact Hxb3. }
    exact (EmptyE x Hx_in_empty).
  }
  (** Need to show b3 :e basis_of_subbasis X S **)
  (** b3 = b1 :/\: b2 where b1, b2 are finite intersections **)
  witness b3.
  apply andI.
  + (** b3 :e basis_of_subbasis X S **)
    prove b3 :e basis_of_subbasis X S.
    (** Extract that b1, b2 are finite intersections **)
    claim Hb1_finite: b1 :e finite_intersections_of X S.
    { exact (SepE1 (finite_intersections_of X S) (fun b0 => b0 <> Empty) b1 Hb1). }
    claim Hb2_finite: b2 :e finite_intersections_of X S.
    { exact (SepE1 (finite_intersections_of X S) (fun b0 => b0 <> Empty) b2 Hb2). }
    (** Get witnesses F1, F2 **)
    claim Hex1: exists F1 :e finite_subcollections S, b1 = intersection_of_family X F1.
    { exact (ReplE (finite_subcollections S) (fun F => intersection_of_family X F) b1 Hb1_finite). }
    apply Hex1.
    let F1. assume HF1_and_eq1. apply HF1_and_eq1.
    assume HF1: F1 :e finite_subcollections S.
    assume Hb1eq: b1 = intersection_of_family X F1.
    claim Hex2: exists F2 :e finite_subcollections S, b2 = intersection_of_family X F2.
    { exact (ReplE (finite_subcollections S) (fun F => intersection_of_family X F) b2 Hb2_finite). }
    apply Hex2.
    let F2. assume HF2_and_eq2. apply HF2_and_eq2.
    assume HF2: F2 :e finite_subcollections S.
    assume Hb2eq: b2 = intersection_of_family X F2.
    (** With new definition: intersection_of_family X Empty = X.
        So F1 and F2 can be empty - if empty, they give X as intersection.
        No longer need to prove F1, F2 nonempty. **)
    (** Now b3 = b1 :/\: b2 = intersection_of_family X (F1 :\/: F2) **)
    set F12 := F1 :\/: F2.
    (** Show F12 :e finite_subcollections S **)
    claim HF12_finite: F12 :e finite_subcollections S.
    { prove F12 :e {F :e Power S | finite F}.
      claim HF12_sub: F12 c= S.
      { claim HF1_sub: F1 c= S.
        { claim HF1_power: F1 :e Power S.
          { exact (SepE1 (Power S) (fun F0 => finite F0) F1 HF1). }
          exact (PowerE S F1 HF1_power).
        }
        claim HF2_sub: F2 c= S.
        { claim HF2_power: F2 :e Power S.
          { exact (SepE1 (Power S) (fun F0 => finite F0) F2 HF2). }
          exact (PowerE S F2 HF2_power).
        }
        exact (binunion_Subq_min F1 F2 S HF1_sub HF2_sub).
      }
      claim HF12_power: F12 :e Power S.
      { apply PowerI. exact HF12_sub. }
      claim HF12_is_finite: finite F12.
      { claim HF1_is_finite: finite F1.
        { exact (SepE2 (Power S) (fun F0 => finite F0) F1 HF1). }
        claim HF2_is_finite: finite F2.
        { exact (SepE2 (Power S) (fun F0 => finite F0) F2 HF2). }
        exact (binunion_finite F1 HF1_is_finite F2 HF2_is_finite).
      }
      exact (SepI (Power S) (fun F => finite F) F12 HF12_power HF12_is_finite).
    }
    (** Show b3 = intersection_of_family F12 **)
    claim Hb3_eq: b3 = intersection_of_family X F12.
    { (** b3 = b1 :/\: b2 = (intersection_of_family F1) :/\: (intersection_of_family F2)                        = intersection_of_family (F1 :\/: F2) = intersection_of_family F12 **)
      apply set_ext.
      - (** b3 c= intersection_of_family F12 **)
        let z. assume Hz: z :e b3.
        prove z :e intersection_of_family X F12.
        claim Hzb1: z :e b1.
        { exact (binintersectE1 b1 b2 z Hz). }
        claim Hzb2: z :e b2.
        { exact (binintersectE2 b1 b2 z Hz). }
        (** z :e intersection_of_family F1 **)
        claim Hz_intersect1: z :e intersection_of_family X F1.
        { rewrite <- Hb1eq. exact Hzb1. }
        (** z :e intersection_of_family F2 **)
        claim Hz_intersect2: z :e intersection_of_family X F2.
        { rewrite <- Hb2eq. exact Hzb2. }
        (** Show z :e intersection_of_family X F12 **)
        prove z :e intersection_of_family X F12.
        (** New definition: intersection_of_family X F = {x :e X | forall U :e F, x :e U} **)
        claim Hz_in_X: z :e X.
        { exact (SepE1 X (fun x => forall U:set, U :e F1 -> x :e U) z Hz_intersect1). }
        claim Hz_all1: forall U:set, U :e F1 -> z :e U.
        { exact (SepE2 X (fun x => forall U:set, U :e F1 -> x :e U) z Hz_intersect1). }
        claim Hz_all2: forall U:set, U :e F2 -> z :e U.
        { exact (SepE2 X (fun x => forall U:set, U :e F2 -> x :e U) z Hz_intersect2). }
        claim Hz_all12: forall U:set, U :e F12 -> z :e U.
        { let U. assume HU: U :e F12.
          prove z :e U.
          apply (binunionE F1 F2 U HU).
          - assume HUF1: U :e F1. exact (Hz_all1 U HUF1).
          - assume HUF2: U :e F2. exact (Hz_all2 U HUF2).
        }
        exact (SepI X (fun x => forall U:set, U :e F12 -> x :e U) z Hz_in_X Hz_all12).
      - (** intersection_of_family X F12 c= b3 **)
        let z. assume Hz: z :e intersection_of_family X F12.
        prove z :e b3.
        (** New definition gives us z :e X and forall U :e F12, z :e U **)
        claim Hz_in_X: z :e X.
        { exact (SepE1 X (fun x => forall U:set, U :e F12 -> x :e U) z Hz). }
        claim Hz_all12: forall U:set, U :e F12 -> z :e U.
        { exact (SepE2 X (fun x => forall U:set, U :e F12 -> x :e U) z Hz). }
        claim Hz_all1: forall U:set, U :e F1 -> z :e U.
        { let U. assume HU: U :e F1.
          prove z :e U.
          exact (Hz_all12 U (binunionI1 F1 F2 U HU)).
        }
        claim Hz_all2: forall U:set, U :e F2 -> z :e U.
        { let U. assume HU: U :e F2.
          prove z :e U.
          exact (Hz_all12 U (binunionI2 F1 F2 U HU)).
        }
        (** Use Hz_all1 and Hz_all2 to show z :e b1 and z :e b2 **)
        (** New definition: intersection_of_family X F = {x :e X | forall U :e F, x :e U} **)
        claim Hz_intersect1: z :e intersection_of_family X F1.
        { exact (SepI X (fun x => forall U:set, U :e F1 -> x :e U) z Hz_in_X Hz_all1). }
        claim Hz_intersect2: z :e intersection_of_family X F2.
        { exact (SepI X (fun x => forall U:set, U :e F2 -> x :e U) z Hz_in_X Hz_all2). }
        claim Hzb1: z :e b1.
        { rewrite Hb1eq. exact Hz_intersect1. }
        claim Hzb2: z :e b2.
        { rewrite Hb2eq. exact Hz_intersect2. }
        exact (binintersectI b1 b2 z Hzb1 Hzb2).
    }
    (** Now show b3 :e basis_of_subbasis X S using finite_intersection_in_basis **)
    claim H_intersect_ne: intersection_of_family X F12 <> Empty.
    { assume Hempty_intersect: intersection_of_family X F12 = Empty.
      claim Hb3_empty: b3 = Empty.
      { rewrite Hb3_eq. exact Hempty_intersect. }
      exact (Hb3_ne Hb3_empty).
    }
    claim H_intersect_in_basis: intersection_of_family X F12 :e basis_of_subbasis X S.
    { exact (finite_intersection_in_basis X S F12 HF12_finite H_intersect_ne). }
    claim Hb3_in_basis: b3 :e basis_of_subbasis X S.
    { rewrite Hb3_eq. exact H_intersect_in_basis. }
    exact Hb3_in_basis.
  + (** x :e b3 /\ b3 c= b1 :/\: b2 **)
    apply andI.
    * exact Hxb3.
    * exact (Subq_ref (b1 :/\: b2)).
Qed.

(** from 13: topology generated by a subbasis is a topology **) 
(** LATEX VERSION: The topology generated from a subbasis S on X satisfies the topology axioms. **)
Theorem topology_from_subbasis_is_topology : forall X S:set,
  subbasis_on X S -> topology_on X (generated_topology_from_subbasis X S).
let X S.
assume HS.
prove topology_on X (generated_topology_from_subbasis X S).
(** Strategy: Show basis_of_subbasis X S is a basis, then apply lemma_topology_from_basis **)
claim HBasis: basis_on X (basis_of_subbasis X S).
{ exact (finite_intersections_basis_of_subbasis X S HS). }
claim HTopo: topology_on X (generated_topology X (basis_of_subbasis X S)).
{ exact (lemma_topology_from_basis X (basis_of_subbasis X S) HBasis). }
(** generated_topology_from_subbasis X S = generated_topology X (basis_of_subbasis X S) by definition **)
exact HTopo.
Qed.

(** from 13: generated topology from subbasis is minimal among topologies containing S **) 
(** LATEX VERSION: Among all topologies containing a subbasis S, the generated one is the smallest/finer-than criterion. **)
Theorem topology_generated_by_basis_is_minimal : forall X S T:set,
  subbasis_on X S -> topology_on X T -> S c= T ->
  finer_than T (generated_topology_from_subbasis X S).
let X S T.
assume HS HT HST.
prove finer_than T (generated_topology_from_subbasis X S).
(** finer_than T (generated_topology_from_subbasis X S) = generated_topology_from_subbasis X S c= T **)
prove generated_topology_from_subbasis X S c= T.
(** generated_topology_from_subbasis X S = generated_topology X (basis_of_subbasis X S) **)
prove generated_topology X (basis_of_subbasis X S) c= T.
(** Strategy: show every basis element is in T, then every generated open set is in T **)
let U. assume HU: U :e generated_topology X (basis_of_subbasis X S).
prove U :e T.
(** U :e generated_topology X B means U c= X and forall x :e U, exists b :e B with x :e b, b c= U **)
claim HU_def: U c= X /\ (forall x :e U, exists b :e basis_of_subbasis X S, x :e b /\ b c= U).
{ (** generated_topology X B = {U :e Power X | forall x :e U, exists b :e B, x :e b /\ b c= U} **)
  claim HU_power: U :e Power X.
  { exact (SepE1 (Power X) (fun U0 => forall x :e U0, exists b :e basis_of_subbasis X S, x :e b /\ b c= U0) U HU). }
  claim HUsub_X: U c= X.
  { exact (PowerE X U HU_power). }
  claim HU_local: forall x :e U, exists b :e basis_of_subbasis X S, x :e b /\ b c= U.
  { exact (SepE2 (Power X) (fun U0 => forall x :e U0, exists b :e basis_of_subbasis X S, x :e b /\ b c= U0) U HU). }
  exact (andI (U c= X) (forall x :e U, exists b :e basis_of_subbasis X S, x :e b /\ b c= U) HUsub_X HU_local).
}
claim HUsub: U c= X.
{ exact (andEL (U c= X) (forall x :e U, exists b :e basis_of_subbasis X S, x :e b /\ b c= U) HU_def). }
claim HUlocal: forall x :e U, exists b :e basis_of_subbasis X S, x :e b /\ b c= U.
{ exact (andER (U c= X) (forall x :e U, exists b :e basis_of_subbasis X S, x :e b /\ b c= U) HU_def). }
(** Show: every basis element is in T **)
claim Hbasis_in_T: forall b :e basis_of_subbasis X S, b :e T.
{ let b. assume Hb: b :e basis_of_subbasis X S.
  prove b :e T.
  (** b is either X itself or a nonempty finite intersection of elements from S **)
  (** Case 1: if b = X, then X :e T since T is a topology **)
  (** Case 2: if b is a finite intersection of S elements, use that T is closed under finite intersections **)
  apply (xm (b = X)).
  - assume Hb_eq_X: b = X.
    (** X :e T since T is a topology on X **)
    claim HX_in_T: X :e T.
    { (** Extract from topology_on X T **)
      claim H1: ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T).
      { exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) (forall U :e T, forall V :e T, U :/\: V :e T) HT). }
      claim H2: (T c= Power X /\ Empty :e T) /\ X :e T.
      { exact (andEL ((T c= Power X /\ Empty :e T) /\ X :e T) (forall UFam :e Power T, Union UFam :e T) H1). }
      exact (andER (T c= Power X /\ Empty :e T) (X :e T) H2).
    }
    claim Hb_in_T_case1: b :e T.
    { rewrite Hb_eq_X. exact HX_in_T. }
    exact Hb_in_T_case1.
  - assume Hb_ne_X: b <> X.
    (** b is a nonempty finite intersection of S elements **)
    (** b :e basis_of_subbasis X S = {b :e finite_intersections_of X S | b <> Empty} **)
    claim Hb_finite_inter: b :e finite_intersections_of X S.
    { exact (SepE1 (finite_intersections_of X S) (fun b0 => b0 <> Empty) b Hb). }
    (** finite_intersections_of X S = {intersection_of_family F | F :e finite_subcollections S} **)
    claim Hex_F: exists F :e finite_subcollections S, b = intersection_of_family X F.
    { exact (ReplE (finite_subcollections S) (fun F => intersection_of_family X F) b Hb_finite_inter). }
    apply Hex_F.
    let F. assume HF_and_eq. apply HF_and_eq.
    assume HF: F :e finite_subcollections S.
    assume Hb_eq: b = intersection_of_family X F.
    (** F is a finite subcollection of S, so F c= S and finite F **)
    claim HF_sub_S: F c= S.
    { claim HF_power: F :e Power S.
      { exact (SepE1 (Power S) (fun F0 => finite F0) F HF). }
      exact (PowerE S F HF_power).
    }
    claim HF_finite: finite F.
    { exact (SepE2 (Power S) (fun F0 => finite F0) F HF). }
    (** Now b = intersection_of_family F where each element of F is in S, hence in T **)
    (** All elements of F are in T since F c= S c= T **)
    claim HF_sub_T: F c= T.
    { let s. assume Hs: s :e F.
      claim Hs_in_S: s :e S.
      { exact (HF_sub_S s Hs). }
      exact (HST s Hs_in_S).
    }
    claim HF_in_PowerT: F :e Power T.
    { apply PowerI. exact HF_sub_T. }
    (** Apply finite_intersection_in_topology **)
    claim Hb_inter_in_T: intersection_of_family X F :e T.
    { exact (finite_intersection_in_topology X T F HT HF_in_PowerT HF_finite). }
    claim Hb_in_T_case2: b :e T.
    { rewrite Hb_eq. exact Hb_inter_in_T. }
    exact Hb_in_T_case2.
}
(** Now show U is union of basis elements, hence in T **)
(** Strategy: U = Union {b :e basis_of_subbasis X S | b c= U}, and this is a union of T elements **)
set Fam := {b :e basis_of_subbasis X S | b c= U}.
claim HU_eq_union: U = Union Fam.
{ apply set_ext.
  - (** U c= Union Fam **)
    let x. assume Hx: x :e U.
    (** By HUlocal, exists b :e basis_of_subbasis X S with x :e b /\ b c= U **)
    claim Hex_b: exists b :e basis_of_subbasis X S, x :e b /\ b c= U.
    { exact (HUlocal x Hx). }
    apply Hex_b.
    let b. assume Hb_and_props. apply Hb_and_props.
    assume Hb_basis: b :e basis_of_subbasis X S.
    assume Hxb_and_sub. apply Hxb_and_sub.
    assume Hxb: x :e b.
    assume Hb_sub_U: b c= U.
    claim Hb_in_Fam: b :e Fam.
    { exact (SepI (basis_of_subbasis X S) (fun b0 => b0 c= U) b Hb_basis Hb_sub_U). }
    exact (UnionI Fam x b Hxb Hb_in_Fam).
  - (** Union Fam c= U **)
    let x. assume Hx: x :e Union Fam.
    apply UnionE_impred Fam x Hx.
    let b. assume Hxb: x :e b. assume Hb_Fam: b :e Fam.
    claim Hb_sub_U: b c= U.
    { exact (SepE2 (basis_of_subbasis X S) (fun b0 => b0 c= U) b Hb_Fam). }
    exact (Hb_sub_U x Hxb).
}
(** Now show U :e T using that U = Union Fam and Fam c= T **)
claim HFam_sub_T: Fam c= T.
{ let b. assume Hb: b :e Fam.
  claim Hb_basis: b :e basis_of_subbasis X S.
  { exact (SepE1 (basis_of_subbasis X S) (fun b0 => b0 c= U) b Hb). }
  exact (Hbasis_in_T b Hb_basis).
}
claim HFam_in_PowerT: Fam :e Power T.
{ apply PowerI. exact HFam_sub_T. }
(** T is closed under unions, so Union Fam :e T **)
claim HUnion_Fam_in_T: Union Fam :e T.
{ (** Extract union closure from topology_on X T **)
  claim H1: ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T).
  { exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) (forall U :e T, forall V :e T, U :/\: V :e T) HT). }
  claim H_union_closure: forall UFam :e Power T, Union UFam :e T.
  { exact (andER (((T c= Power X /\ Empty :e T) /\ X :e T)) (forall UFam :e Power T, Union UFam :e T) H1). }
  exact (H_union_closure Fam HFam_in_PowerT).
}
claim HU_in_T: U :e T.
{ rewrite HU_eq_union. exact HUnion_Fam_in_T. }
exact HU_in_T.
Qed.

(** from 13 Exercise 1: local openness implies set is open **)
(** LATEX VERSION: Exercise 1: If every xA lies in some open UA, then A is open. **)
Theorem ex13_1_local_open_subset : forall X T A:set,
  topology_on X T ->
  (forall x :e A, exists U :e T, x :e U /\ U c= A) ->
  open_in X T A.
let X T A.
assume HT Hlocal.
prove open_in X T A.
(** Strategy: show A = Union of family of open sets, then A is open **)
set Fam : set := {U :e T | U c= A}.
claim HFam_sub : Fam c= T.
{ let U. assume HU. exact (SepE1 T (fun U0 => U0 c= A) U HU). }
claim HUnion_eq : Union Fam = A.
{ apply set_ext.
  - (** Union Fam c= A **)
    let x. assume Hx.
    apply UnionE_impred Fam x Hx.
    let U. assume HxU HUFam.
    claim HUsub : U c= A.
    { exact (SepE2 T (fun U0 => U0 c= A) U HUFam). }
    exact (HUsub x HxU).
  - (** A c= Union Fam **)
    let x. assume HxA.
    claim Hex : exists U :e T, x :e U /\ U c= A.
    { exact (Hlocal x HxA). }
    apply Hex.
    let U. assume HU.
    claim HUT : U :e T.
    { exact (andEL (U :e T) (x :e U /\ U c= A) HU). }
    claim Hrest : x :e U /\ U c= A.
    { exact (andER (U :e T) (x :e U /\ U c= A) HU). }
    claim HxU : x :e U.
    { exact (andEL (x :e U) (U c= A) Hrest). }
    claim HUsub : U c= A.
    { exact (andER (x :e U) (U c= A) Hrest). }
    claim HUFam : U :e Fam.
    { exact (SepI T (fun U0 => U0 c= A) U HUT HUsub). }
    exact (UnionI Fam x U HxU HUFam).
}
claim HUnionT : Union Fam :e T.
{ exact (topology_union_closed X T Fam HT HFam_sub). }
claim HAT : A :e T.
{ rewrite <- HUnion_eq. exact HUnionT. }
prove topology_on X T /\ A :e T.
apply andI.
- exact HT.
- exact HAT.
Qed.

(** from 13 Exercise 2: comparison of nine topologies on {a,b,c} **) 
(** LATEX VERSION: Exercise 2 constructs nine topologies on {a,b,c} and compares which are topologies and their fineness relations. **)
Definition a_elt : set := Empty.
Definition b_elt : set := {Empty}.
Definition c_elt : set := {{Empty}}.
(** FIXED: Use binunion to create proper 3-element set {a,b,c}.
    Old: UPair a_elt (UPair b_elt c_elt) gave {a, {b,c}}, a 2-element set.
    New: UPair a_elt b_elt :\/: {c_elt} gives {a, b}  {c} = {a, b, c}. **)
Definition abc_set : set := UPair a_elt b_elt :\/: {c_elt}.

Definition top_abc_1 : set := UPair Empty abc_set.
Definition top_abc_2 : set := Power abc_set.
(** FIXED: Nested `UPair` does not create a 3- or 4-element family; use unions with singletons. **)
Definition top_abc_3 : set := UPair Empty {a_elt} :\/: {abc_set}.
Definition top_abc_4 : set := UPair Empty {b_elt} :\/: {abc_set}.
Definition top_abc_5 : set := UPair Empty {c_elt} :\/: {abc_set}.
Definition top_abc_6 : set := UPair Empty (UPair a_elt b_elt) :\/: {abc_set}.
Definition top_abc_7 : set := UPair Empty (UPair a_elt c_elt) :\/: {abc_set}.
Definition top_abc_8 : set := UPair Empty (UPair b_elt c_elt) :\/: {abc_set}.
Definition top_abc_9 : set := (UPair Empty {a_elt} :\/: {UPair a_elt b_elt}) :\/: {abc_set}.

(** Helper: topology of the form {Empty, A, X} **)
Theorem topology_three_sets : forall X A:set,
  A c= X ->
  topology_on X (UPair Empty A :\/: {X}).
let X A. assume HA.
set T := UPair Empty A :\/: {X}.
claim HTPow: T c= Power X.
{ let U. assume HU: U :e T.
  prove U :e Power X.
  apply (binunionE' (UPair Empty A) {X} U (U :e Power X)).
  - assume HU0: U :e UPair Empty A.
    apply (UPairE U Empty A HU0).
    + assume HUeq: U = Empty. rewrite HUeq. exact (Empty_In_Power X).
    + assume HUeq: U = A. rewrite HUeq. exact (PowerI X A HA).
  - assume HU0: U :e {X}.
    claim HUeq: U = X.
    { exact (SingE X U HU0). }
    rewrite HUeq.
    exact (Self_In_Power X).
  - exact HU.
}
claim HEmptyIn: Empty :e T.
{ exact (binunionI1 (UPair Empty A) {X} Empty (UPairI1 Empty A)). }
claim HXIn: X :e T.
{ exact (binunionI2 (UPair Empty A) {X} X (SingI X)). }
prove topology_on X T.
prove (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T))
  /\ (forall U :e T, forall V :e T, U :/\: V :e T).
apply andI.
- apply andI.
  + apply andI.
    * apply andI.
      - exact HTPow.
      - exact HEmptyIn.
    * exact HXIn.
  + let UFam. assume HUFam: UFam :e Power T.
    prove Union UFam :e T.
    claim HUFsub: UFam c= T.
    { exact (PowerE T UFam HUFam). }
    apply (xm (X :e UFam)).
    * assume HXUF: X :e UFam.
      claim HUnionSub: Union UFam c= X.
      { claim HUFpowX: UFam c= Power X.
        { let U. assume HU: U :e UFam.
          exact (HTPow U (HUFsub U HU)).
        }
        exact (Union_Power X UFam HUFpowX).
      }
      claim HUnionEq: Union UFam = X.
      { apply set_ext.
        - exact HUnionSub.
        - let x. assume HxX: x :e X.
          exact (UnionI UFam x X HxX HXUF).
      }
      rewrite HUnionEq.
      exact HXIn.
    * assume HXnot: X /:e UFam.
      apply (xm (A :e UFam)).
	      - assume HAUF: A :e UFam.
         claim HUnionSub: Union UFam c= A.
         { let x. assume Hx: x :e Union UFam.
           prove x :e A.
           apply UnionE_impred UFam x Hx.
           let U. assume HxU: x :e U. assume HUUF: U :e UFam.
           claim HUinT: U :e T.
           { exact (HUFsub U HUUF). }
           apply (binunionE' (UPair Empty A) {X} U (x :e A)).
           - assume HU0: U :e UPair Empty A.
	             apply (UPairE U Empty A HU0).
	             + assume HUeq: U = Empty.
	               claim HxEmpty: x :e Empty.
	               { rewrite <- HUeq. exact HxU. }
	               exact (EmptyE x HxEmpty (x :e A)).
	             + assume HUeq: U = A.
	               rewrite <- HUeq.
	               exact HxU.
           - assume HU0: U :e {X}.
	             claim HUeq: U = X.
	             { exact (SingE X U HU0). }
	             apply FalseE.
	             claim HXUF2: X :e UFam.
	             { rewrite <- HUeq. exact HUUF. }
	             exact (HXnot HXUF2).
           - exact HUinT.
         }
         claim HUnionEq: Union UFam = A.
         { apply set_ext.
           - exact HUnionSub.
           - let x. assume HxA: x :e A.
             exact (UnionI UFam x A HxA HAUF).
         }
         rewrite HUnionEq.
         exact (binunionI1 (UPair Empty A) {X} A (UPairI2 Empty A)).
	      - assume HAnot: A /:e UFam.
         claim HUnionEq: Union UFam = Empty.
         { apply set_ext.
           - let x. assume Hx: x :e Union UFam.
             prove x :e Empty.
             apply UnionE_impred UFam x Hx.
             let U. assume HxU: x :e U. assume HUUF: U :e UFam.
             claim HUinT: U :e T.
             { exact (HUFsub U HUUF). }
             apply (binunionE' (UPair Empty A) {X} U (x :e Empty)).
             + assume HU0: U :e UPair Empty A.
	               apply (UPairE U Empty A HU0).
	               * assume HUeq: U = Empty.
	                 rewrite <- HUeq.
	                 exact HxU.
	               * assume HUeq: U = A.
	                 apply FalseE.
	                 claim HAUF2: A :e UFam.
	                 { rewrite <- HUeq. exact HUUF. }
	                 exact (HAnot HAUF2).
             + assume HU0: U :e {X}.
	               claim HUeq: U = X.
	               { exact (SingE X U HU0). }
	               apply FalseE.
	               claim HXUF2: X :e UFam.
	               { rewrite <- HUeq. exact HUUF. }
	               exact (HXnot HXUF2).
             + exact HUinT.
           - let x. assume Hx: x :e Empty.
             exact (EmptyE x Hx (x :e Union UFam)).
         }
         rewrite HUnionEq.
         exact HEmptyIn.
- let U. assume HU: U :e T.
  let V. assume HV: V :e T.
  prove U :/\: V :e T.
  apply (binunionE' (UPair Empty A) {X} U (U :/\: V :e T)).
  - assume HU0: U :e UPair Empty A.
    apply (UPairE U Empty A HU0).
    + assume HUeq: U = Empty.
      rewrite HUeq.
      claim HcapEq: Empty :/\: V = Empty.
      { apply set_ext.
        - let x. assume Hx: x :e Empty :/\: V.
          exact (binintersectE1 Empty V x Hx).
        - let x. assume Hx: x :e Empty.
          exact (binintersectI Empty V x Hx (EmptyE x Hx (x :e V))).
      }
      rewrite HcapEq.
      exact HEmptyIn.
    + assume HUeq: U = A.
      rewrite HUeq.
      apply (binunionE' (UPair Empty A) {X} V (A :/\: V :e T)).
      * assume HV0: V :e UPair Empty A.
        apply (UPairE V Empty A HV0).
        - assume HVeq: V = Empty.
           rewrite HVeq.
           claim HcapEq: A :/\: Empty = Empty.
           { rewrite (binintersect_com A Empty). exact (binintersect_Subq_eq_1 Empty A (Subq_Empty A)). }
           rewrite HcapEq.
           exact HEmptyIn.
        - assume HVeq: V = A.
           rewrite HVeq.
           claim HcapEq: A :/\: A = A.
           { exact (binintersect_Subq_eq_1 A A (Subq_ref A)). }
           rewrite HcapEq.
           exact (binunionI1 (UPair Empty A) {X} A (UPairI2 Empty A)).
      * assume HV0: V :e {X}.
        claim HVeq: V = X.
        { exact (SingE X V HV0). }
        rewrite HVeq.
        claim HcapEq: A :/\: X = A.
        { exact (binintersect_Subq_eq_1 A X HA). }
        rewrite HcapEq.
        exact (binunionI1 (UPair Empty A) {X} A (UPairI2 Empty A)).
      * exact HV.
  - assume HU0: U :e {X}.
    claim HUeq: U = X.
    { exact (SingE X U HU0). }
    rewrite HUeq.
    claim HVpow: V :e Power X.
    { exact (HTPow V HV). }
    claim HVsub: V c= X.
    { exact (PowerE X V HVpow). }
    claim HcapEq: X :/\: V = V.
    { rewrite (binintersect_com X V). exact (binintersect_Subq_eq_1 V X HVsub). }
    rewrite HcapEq.
    exact HV.
  - exact HU.
Qed.

(** Helper: topology of the form {Empty, A, B, X} with A c= B c= X **)
Theorem topology_chain_four_sets : forall X A B:set,
  A c= B ->
  B c= X ->
  topology_on X ((UPair Empty A :\/: {B}) :\/: {X}).
let X A B. assume HAB HBX.
set T0 := UPair Empty A :\/: {B}.
set T := T0 :\/: {X}.
claim HA_X: A c= X.
{ exact (Subq_tra A B X HAB HBX). }
claim HTPow: T c= Power X.
{ let U. assume HU: U :e T.
  prove U :e Power X.
  apply (binunionE' T0 {X} U (U :e Power X)).
  - assume HU0: U :e T0.
    apply (binunionE' (UPair Empty A) {B} U (U :e Power X)).
    + assume HU1: U :e UPair Empty A.
      apply (UPairE U Empty A HU1).
      * assume HUeq: U = Empty. rewrite HUeq. exact (Empty_In_Power X).
      * assume HUeq: U = A. rewrite HUeq. exact (PowerI X A HA_X).
    + assume HU1: U :e {B}.
      claim HUeq: U = B.
      { exact (SingE B U HU1). }
      rewrite HUeq.
      exact (PowerI X B HBX).
    + exact HU0.
  - assume HU0: U :e {X}.
    claim HUeq: U = X.
    { exact (SingE X U HU0). }
    rewrite HUeq.
    exact (Self_In_Power X).
  - exact HU.
}
claim HEmptyIn: Empty :e T.
{ exact (binunionI1 T0 {X} Empty (binunionI1 (UPair Empty A) {B} Empty (UPairI1 Empty A))). }
claim HXIn: X :e T.
{ exact (binunionI2 T0 {X} X (SingI X)). }
prove topology_on X T.
prove (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T))
  /\ (forall U :e T, forall V :e T, U :/\: V :e T).
apply andI.
- apply andI.
  + apply andI.
    * apply andI.
      - exact HTPow.
      - exact HEmptyIn.
    * exact HXIn.
  + let UFam. assume HUFam: UFam :e Power T.
    prove Union UFam :e T.
    claim HUFsub: UFam c= T.
    { exact (PowerE T UFam HUFam). }
    apply (xm (X :e UFam)).
    * assume HXUF: X :e UFam.
      claim HUnionSub: Union UFam c= X.
      { claim HUFpowX: UFam c= Power X.
        { let U. assume HU: U :e UFam.
          exact (HTPow U (HUFsub U HU)).
        }
        exact (Union_Power X UFam HUFpowX).
      }
      claim HUnionEq: Union UFam = X.
      { apply set_ext.
        - exact HUnionSub.
        - let x. assume HxX: x :e X.
          exact (UnionI UFam x X HxX HXUF).
      }
      rewrite HUnionEq.
      exact HXIn.
    * assume HXnot: X /:e UFam.
      apply (xm (B :e UFam)).
      - assume HBUF: B :e UFam.
         claim HUnionSub: Union UFam c= B.
         { let x. assume Hx: x :e Union UFam.
           prove x :e B.
           apply UnionE_impred UFam x Hx.
           let U. assume HxU: x :e U. assume HUUF: U :e UFam.
           claim HUinT: U :e T.
           { exact (HUFsub U HUUF). }
           apply (binunionE' T0 {X} U (x :e B)).
           - assume HU0: U :e T0.
             apply (binunionE' (UPair Empty A) {B} U (x :e B)).
             + assume HU1: U :e UPair Empty A.
	               apply (UPairE U Empty A HU1).
	               * assume HUeq: U = Empty.
		                 claim HxEmpty: x :e Empty.
		                 { rewrite <- HUeq. exact HxU. }
		                 exact (EmptyE x HxEmpty (x :e B)).
	               * assume HUeq: U = A.
	                 claim HxA: x :e A.
	                 { rewrite <- HUeq. exact HxU. }
	                 exact (HAB x HxA).
             + assume HU1: U :e {B}.
	               claim HUeq: U = B.
	               { exact (SingE B U HU1). }
	               rewrite <- HUeq.
	               exact HxU.
             + exact HU0.
           - assume HU0: U :e {X}.
	             claim HUeq: U = X.
	             { exact (SingE X U HU0). }
	             apply FalseE.
	             claim HXUF2: X :e UFam.
	             { rewrite <- HUeq. exact HUUF. }
	             exact (HXnot HXUF2).
           - exact HUinT.
         }
         claim HUnionEq: Union UFam = B.
         { apply set_ext.
           - exact HUnionSub.
           - let x. assume HxB: x :e B.
             exact (UnionI UFam x B HxB HBUF).
         }
         rewrite HUnionEq.
         exact (binunionI1 T0 {X} B (binunionI2 (UPair Empty A) {B} B (SingI B))).
      - assume HBnot: B /:e UFam.
         apply (xm (A :e UFam)).
         - assume HAUF: A :e UFam.
             claim HUnionSub: Union UFam c= A.
             { let x. assume Hx: x :e Union UFam.
               prove x :e A.
               apply UnionE_impred UFam x Hx.
               let U. assume HxU: x :e U. assume HUUF: U :e UFam.
               claim HUinT: U :e T.
               { exact (HUFsub U HUUF). }
               apply (binunionE' T0 {X} U (x :e A)).
               * assume HU0: U :e T0.
                 apply (binunionE' (UPair Empty A) {B} U (x :e A)).
                 + assume HU1: U :e UPair Empty A.
	                   apply (UPairE U Empty A HU1).
	                   - assume HUeq: U = Empty.
	                      claim HxEmpty: x :e Empty.
	                      { rewrite <- HUeq. exact HxU. }
	                      exact (EmptyE x HxEmpty (x :e A)).
	                   - assume HUeq: U = A.
	                      rewrite <- HUeq.
	                      exact HxU.
                 + assume HU1: U :e {B}.
	                   claim HUeq: U = B.
	                   { exact (SingE B U HU1). }
	                   apply FalseE.
	                   claim HBUF2: B :e UFam.
	                   { rewrite <- HUeq. exact HUUF. }
	                   exact (HBnot HBUF2).
                 + exact HU0.
               * assume HU0: U :e {X}.
	                 claim HUeq: U = X.
	                 { exact (SingE X U HU0). }
	                 apply FalseE.
	                 claim HXUF2: X :e UFam.
	                 { rewrite <- HUeq. exact HUUF. }
	                 exact (HXnot HXUF2).
               * exact HUinT.
             }
             claim HUnionEq: Union UFam = A.
             { apply set_ext.
               - exact HUnionSub.
               - let x. assume HxA: x :e A.
                 exact (UnionI UFam x A HxA HAUF).
             }
             rewrite HUnionEq.
             exact (binunionI1 T0 {X} A (binunionI1 (UPair Empty A) {B} A (UPairI2 Empty A))).
         - assume HAnot: A /:e UFam.
             claim HUnionEq: Union UFam = Empty.
             { apply set_ext.
               - let x. assume Hx: x :e Union UFam.
                 prove x :e Empty.
                 apply UnionE_impred UFam x Hx.
                 let U. assume HxU: x :e U. assume HUUF: U :e UFam.
                 claim HUinT: U :e T.
                 { exact (HUFsub U HUUF). }
                 apply (binunionE' T0 {X} U (x :e Empty)).
                 + assume HU0: U :e T0.
                   apply (binunionE' (UPair Empty A) {B} U (x :e Empty)).
                   * assume HU1: U :e UPair Empty A.
	                     apply (UPairE U Empty A HU1).
	                     - assume HUeq: U = Empty.
	                        rewrite <- HUeq.
	                        exact HxU.
	                     - assume HUeq: U = A.
	                        apply FalseE.
	                        claim HAUF2: A :e UFam.
	                        { rewrite <- HUeq. exact HUUF. }
	                        exact (HAnot HAUF2).
                   * assume HU1: U :e {B}.
	                     claim HUeq: U = B.
	                     { exact (SingE B U HU1). }
	                     apply FalseE.
	                     claim HBUF2: B :e UFam.
	                     { rewrite <- HUeq. exact HUUF. }
	                     exact (HBnot HBUF2).
                   * exact HU0.
                 + assume HU0: U :e {X}.
	                   claim HUeq: U = X.
	                   { exact (SingE X U HU0). }
	                   apply FalseE.
	                   claim HXUF2: X :e UFam.
	                   { rewrite <- HUeq. exact HUUF. }
	                   exact (HXnot HXUF2).
                 + exact HUinT.
               - let x. assume Hx: x :e Empty.
                 exact (EmptyE x Hx (x :e Union UFam)).
             }
             rewrite HUnionEq.
             exact HEmptyIn.
- let U. assume HU: U :e T.
  let V. assume HV: V :e T.
  prove U :/\: V :e T.
  apply (binunionE' T0 {X} U (U :/\: V :e T)).
  - assume HU0: U :e T0.
    apply (binunionE' (UPair Empty A) {B} U (U :/\: V :e T)).
    + assume HU1: U :e UPair Empty A.
      apply (UPairE U Empty A HU1).
      * assume HUeq: U = Empty.
        rewrite HUeq.
        claim HcapEq: Empty :/\: V = Empty.
        { apply set_ext.
          - let x. assume Hx: x :e Empty :/\: V.
            exact (binintersectE1 Empty V x Hx).
          - let x. assume Hx: x :e Empty.
            exact (binintersectI Empty V x Hx (EmptyE x Hx (x :e V))).
        }
        rewrite HcapEq.
        exact HEmptyIn.
      * assume HUeq: U = A.
        rewrite HUeq.
        apply (binunionE' T0 {X} V (A :/\: V :e T)).
        - assume HV0: V :e T0.
           apply (binunionE' (UPair Empty A) {B} V (A :/\: V :e T)).
           - assume HV1: V :e UPair Empty A.
               apply (UPairE V Empty A HV1).
               * assume HVeq: V = Empty.
                 rewrite HVeq.
                 claim HcapEq: A :/\: Empty = Empty.
                 { rewrite (binintersect_com A Empty). exact (binintersect_Subq_eq_1 Empty A (Subq_Empty A)). }
                 rewrite HcapEq.
                 exact HEmptyIn.
               * assume HVeq: V = A.
                 rewrite HVeq.
                 claim HcapEq: A :/\: A = A.
                 { exact (binintersect_Subq_eq_1 A A (Subq_ref A)). }
                 rewrite HcapEq.
                 exact (binunionI1 T0 {X} A (binunionI1 (UPair Empty A) {B} A (UPairI2 Empty A))).
           - assume HV1: V :e {B}.
               claim HVeq: V = B.
               { exact (SingE B V HV1). }
               rewrite HVeq.
               claim HcapEq: A :/\: B = A.
               { exact (binintersect_Subq_eq_1 A B HAB). }
               rewrite HcapEq.
               exact (binunionI1 T0 {X} A (binunionI1 (UPair Empty A) {B} A (UPairI2 Empty A))).
           - exact HV0.
        - assume HV0: V :e {X}.
           claim HVeq: V = X.
           { exact (SingE X V HV0). }
           rewrite HVeq.
           claim HcapEq: A :/\: X = A.
           { exact (binintersect_Subq_eq_1 A X HA_X). }
           rewrite HcapEq.
           exact (binunionI1 T0 {X} A (binunionI1 (UPair Empty A) {B} A (UPairI2 Empty A))).
        - exact HV.
    + assume HU1: U :e {B}.
      claim HUeq: U = B.
      { exact (SingE B U HU1). }
      rewrite HUeq.
      apply (binunionE' T0 {X} V (B :/\: V :e T)).
      * assume HV0: V :e T0.
        apply (binunionE' (UPair Empty A) {B} V (B :/\: V :e T)).
        - assume HV1: V :e UPair Empty A.
           apply (UPairE V Empty A HV1).
           - assume HVeq: V = Empty.
               rewrite HVeq.
               claim HcapEq: B :/\: Empty = Empty.
               { rewrite (binintersect_com B Empty). exact (binintersect_Subq_eq_1 Empty B (Subq_Empty B)). }
               rewrite HcapEq.
               exact HEmptyIn.
           - assume HVeq: V = A.
               rewrite HVeq.
               claim HcapEq: B :/\: A = A.
               { rewrite (binintersect_com B A). exact (binintersect_Subq_eq_1 A B HAB). }
               rewrite HcapEq.
               exact (binunionI1 T0 {X} A (binunionI1 (UPair Empty A) {B} A (UPairI2 Empty A))).
        - assume HV1: V :e {B}.
           claim HVeq: V = B.
           { exact (SingE B V HV1). }
           rewrite HVeq.
           claim HcapEq: B :/\: B = B.
           { exact (binintersect_Subq_eq_1 B B (Subq_ref B)). }
           rewrite HcapEq.
           exact (binunionI1 T0 {X} B (binunionI2 (UPair Empty A) {B} B (SingI B))).
        - exact HV0.
      * assume HV0: V :e {X}.
        claim HVeq: V = X.
        { exact (SingE X V HV0). }
        rewrite HVeq.
        claim HcapEq: B :/\: X = B.
        { exact (binintersect_Subq_eq_1 B X HBX). }
        rewrite HcapEq.
        exact (binunionI1 T0 {X} B (binunionI2 (UPair Empty A) {B} B (SingI B))).
      * exact HV.
    + exact HU0.
  - assume HU0: U :e {X}.
    claim HUeq: U = X.
    { exact (SingE X U HU0). }
    rewrite HUeq.
    claim HVpow: V :e Power X.
    { exact (HTPow V HV). }
    claim HVsub: V c= X.
    { exact (PowerE X V HVpow). }
    claim HcapEq: X :/\: V = V.
    { rewrite (binintersect_com X V). exact (binintersect_Subq_eq_1 V X HVsub). }
    rewrite HcapEq.
    exact HV.
  - exact HU.
Qed.

Theorem ex13_2_compare_nine_topologies :
  topology_on abc_set top_abc_1 /\ topology_on abc_set top_abc_2 /\
  topology_on abc_set top_abc_3 /\ topology_on abc_set top_abc_4 /\
  topology_on abc_set top_abc_5 /\ topology_on abc_set top_abc_6 /\
  topology_on abc_set top_abc_7 /\ topology_on abc_set top_abc_8 /\
  topology_on abc_set top_abc_9 /\
  exists finer_pairs:set,
    finer_pairs =
      {p :e Power (Power (Power abc_set))|
         exists T1 T2:set, p = setprod T1 T2 /\
           (T1 = top_abc_1 \/ T1 = top_abc_2 \/ T1 = top_abc_3 \/
            T1 = top_abc_4 \/ T1 = top_abc_5 \/ T1 = top_abc_6 \/
            T1 = top_abc_7 \/ T1 = top_abc_8 \/ T1 = top_abc_9) /\
           (T2 = top_abc_1 \/ T2 = top_abc_2 \/ T2 = top_abc_3 \/
            T2 = top_abc_4 \/ T2 = top_abc_5 \/ T2 = top_abc_6 \/
           T2 = top_abc_7 \/ T2 = top_abc_8 \/ T2 = top_abc_9) /\
           T1 c= T2}.
prove topology_on abc_set top_abc_1 /\ topology_on abc_set top_abc_2 /\
  topology_on abc_set top_abc_3 /\ topology_on abc_set top_abc_4 /\
  topology_on abc_set top_abc_5 /\ topology_on abc_set top_abc_6 /\
  topology_on abc_set top_abc_7 /\ topology_on abc_set top_abc_8 /\
  topology_on abc_set top_abc_9 /\
  exists finer_pairs:set,
    finer_pairs =
      {p :e Power (Power (Power abc_set))|
         exists T1 T2:set, p = setprod T1 T2 /\
           (T1 = top_abc_1 \/ T1 = top_abc_2 \/ T1 = top_abc_3 \/
            T1 = top_abc_4 \/ T1 = top_abc_5 \/ T1 = top_abc_6 \/
            T1 = top_abc_7 \/ T1 = top_abc_8 \/ T1 = top_abc_9) /\
           (T2 = top_abc_1 \/ T2 = top_abc_2 \/ T2 = top_abc_3 \/
            T2 = top_abc_4 \/ T2 = top_abc_5 \/ T2 = top_abc_6 \/
           T2 = top_abc_7 \/ T2 = top_abc_8 \/ T2 = top_abc_9) /\
           T1 c= T2}.
apply andI.
- (** nine topology axioms **)
  apply andI.
  - apply andI.
    - apply andI.
      - apply andI.
        - apply andI.
          - apply andI.
            - apply andI.
	              - apply andI.
	                - (** topology_on abc_set top_abc_1 **)
	                  claim Ht1: top_abc_1 = indiscrete_topology abc_set.
	                  { reflexivity. }
	                  rewrite Ht1.
	                  exact (indiscrete_topology_on abc_set).
	                - (** topology_on abc_set top_abc_2 **)
                  claim Ht2: top_abc_2 = discrete_topology abc_set.
                  { reflexivity. }
                  rewrite Ht2.
                  exact (discrete_topology_on abc_set).
              - (** topology_on abc_set top_abc_3 **)
                claim HA: {a_elt} c= abc_set.
                { let x. assume Hx: x :e {a_elt}.
                  prove x :e abc_set.
                  claim Hxeq: x = a_elt.
                  { exact (SingE a_elt x Hx). }
                  rewrite Hxeq.
                  exact (binunionI1 (UPair a_elt b_elt) {c_elt} a_elt (UPairI1 a_elt b_elt)).
                }
                exact (topology_three_sets abc_set {a_elt} HA).
            - (** topology_on abc_set top_abc_4 **)
              claim HB: {b_elt} c= abc_set.
              { let x. assume Hx: x :e {b_elt}.
                prove x :e abc_set.
                claim Hxeq: x = b_elt.
                { exact (SingE b_elt x Hx). }
                rewrite Hxeq.
                exact (binunionI1 (UPair a_elt b_elt) {c_elt} b_elt (UPairI2 a_elt b_elt)).
              }
              exact (topology_three_sets abc_set {b_elt} HB).
          - (** topology_on abc_set top_abc_5 **)
            claim HC: {c_elt} c= abc_set.
            { let x. assume Hx: x :e {c_elt}.
              prove x :e abc_set.
              claim Hxeq: x = c_elt.
              { exact (SingE c_elt x Hx). }
              rewrite Hxeq.
              exact (binunionI2 (UPair a_elt b_elt) {c_elt} c_elt (SingI c_elt)).
            }
            exact (topology_three_sets abc_set {c_elt} HC).
        - (** topology_on abc_set top_abc_6 **)
          claim HAB: (UPair a_elt b_elt) c= abc_set.
          { let x. assume Hx: x :e UPair a_elt b_elt.
            prove x :e abc_set.
            apply (UPairE x a_elt b_elt Hx).
            - assume Hxeq: x = a_elt.
              rewrite Hxeq.
              exact (binunionI1 (UPair a_elt b_elt) {c_elt} a_elt (UPairI1 a_elt b_elt)).
            - assume Hxeq: x = b_elt.
              rewrite Hxeq.
              exact (binunionI1 (UPair a_elt b_elt) {c_elt} b_elt (UPairI2 a_elt b_elt)).
          }
          exact (topology_three_sets abc_set (UPair a_elt b_elt) HAB).
      - (** topology_on abc_set top_abc_7 **)
        claim HAC: (UPair a_elt c_elt) c= abc_set.
        { let x. assume Hx: x :e UPair a_elt c_elt.
          prove x :e abc_set.
          apply (UPairE x a_elt c_elt Hx).
          - assume Hxeq: x = a_elt.
            rewrite Hxeq.
            exact (binunionI1 (UPair a_elt b_elt) {c_elt} a_elt (UPairI1 a_elt b_elt)).
          - assume Hxeq: x = c_elt.
            rewrite Hxeq.
            exact (binunionI2 (UPair a_elt b_elt) {c_elt} c_elt (SingI c_elt)).
        }
        exact (topology_three_sets abc_set (UPair a_elt c_elt) HAC).
    - (** topology_on abc_set top_abc_8 **)
      claim HBC: (UPair b_elt c_elt) c= abc_set.
      { let x. assume Hx: x :e UPair b_elt c_elt.
        prove x :e abc_set.
        apply (UPairE x b_elt c_elt Hx).
        - assume Hxeq: x = b_elt.
          rewrite Hxeq.
          exact (binunionI1 (UPair a_elt b_elt) {c_elt} b_elt (UPairI2 a_elt b_elt)).
        - assume Hxeq: x = c_elt.
          rewrite Hxeq.
          exact (binunionI2 (UPair a_elt b_elt) {c_elt} c_elt (SingI c_elt)).
      }
      exact (topology_three_sets abc_set (UPair b_elt c_elt) HBC).
  - (** topology_on abc_set top_abc_9 **)
    claim HAinAB: {a_elt} c= UPair a_elt b_elt.
    { let x. assume Hx: x :e {a_elt}.
      prove x :e UPair a_elt b_elt.
      claim Hxeq: x = a_elt.
      { exact (SingE a_elt x Hx). }
      rewrite Hxeq.
      exact (UPairI1 a_elt b_elt).
    }
    claim HABsubX: UPair a_elt b_elt c= abc_set.
    { let x. assume Hx: x :e UPair a_elt b_elt.
      prove x :e abc_set.
      exact (binunionI1 (UPair a_elt b_elt) {c_elt} x Hx).
    }
    exact (topology_chain_four_sets abc_set {a_elt} (UPair a_elt b_elt) HAinAB HABsubX).
- (** finer_pairs set of refinement pairs **)
  witness
    {p :e Power (Power (Power abc_set))|
       exists T1 T2:set, p = setprod T1 T2 /\
         (T1 = top_abc_1 \/ T1 = top_abc_2 \/ T1 = top_abc_3 \/
          T1 = top_abc_4 \/ T1 = top_abc_5 \/ T1 = top_abc_6 \/
          T1 = top_abc_7 \/ T1 = top_abc_8 \/ T1 = top_abc_9) /\
         (T2 = top_abc_1 \/ T2 = top_abc_2 \/ T2 = top_abc_3 \/
          T2 = top_abc_4 \/ T2 = top_abc_5 \/ T2 = top_abc_6 \/
          T2 = top_abc_7 \/ T2 = top_abc_8 \/ T2 = top_abc_9) /\
         T1 c= T2}.
  reflexivity.
Qed.

(** from 13 Exercise 2: some basic fineness relations between the nine examples **)
(** LATEX VERSION: Exercise 2 asks to compare the nine topologies by inclusion (finer/coarser). **)
Theorem top_abc_3_finer_than_top_abc_1 : finer_than top_abc_3 top_abc_1.
let U. assume HU: U :e top_abc_1.
prove U :e top_abc_3.
apply (UPairE U Empty abc_set HU).
- assume HUeq: U = Empty.
  rewrite HUeq.
  exact (binunionI1 (UPair Empty {a_elt}) {abc_set} Empty (UPairI1 Empty {a_elt})).
- assume HUeq: U = abc_set.
  rewrite HUeq.
  exact (binunionI2 (UPair Empty {a_elt}) {abc_set} abc_set (SingI abc_set)).
Qed.

Theorem top_abc_2_finer_than_top_abc_3 : finer_than top_abc_2 top_abc_3.
let U. assume HU: U :e top_abc_3.
prove U :e top_abc_2.
(** top_abc_2 = Power abc_set; show U c= abc_set **)
claim Ht2: top_abc_2 = Power abc_set.
{ reflexivity. }
rewrite Ht2.
apply PowerI.
let x. assume Hx: x :e U.
prove x :e abc_set.
apply (binunionE' (UPair Empty {a_elt}) {abc_set} U (x :e abc_set)).
- assume HU0: U :e UPair Empty {a_elt}.
  apply (UPairE U Empty {a_elt} HU0).
  + assume HUeq: U = Empty.
    claim HxEmpty: x :e Empty.
    { rewrite <- HUeq. exact Hx. }
    exact (EmptyE x HxEmpty (x :e abc_set)).
  + assume HUeq: U = {a_elt}.
    claim HxSing: x :e {a_elt}.
    { rewrite <- HUeq. exact Hx. }
    claim Hxeq: x = a_elt.
    { exact (SingE a_elt x HxSing). }
    rewrite Hxeq.
    exact (binunionI1 (UPair a_elt b_elt) {c_elt} a_elt (UPairI1 a_elt b_elt)).
- assume HU0: U :e {abc_set}.
  claim HUeq: U = abc_set.
  { exact (SingE abc_set U HU0). }
  rewrite <- HUeq.
  exact Hx.
- exact HU.
Qed.

Theorem top_abc_9_finer_than_top_abc_3 : finer_than top_abc_9 top_abc_3.
let U. assume HU: U :e top_abc_3.
prove U :e top_abc_9.
apply (binunionE' (UPair Empty {a_elt}) {abc_set} U (U :e top_abc_9)).
- assume HU0: U :e UPair Empty {a_elt}.
  exact (binunionI1 (UPair Empty {a_elt} :\/: {UPair a_elt b_elt}) {abc_set} U
          (binunionI1 (UPair Empty {a_elt}) {UPair a_elt b_elt} U HU0)).
- assume HU0: U :e {abc_set}.
  claim HUeq: U = abc_set.
  { exact (SingE abc_set U HU0). }
  rewrite HUeq.
  exact (binunionI2 (UPair Empty {a_elt} :\/: {UPair a_elt b_elt}) {abc_set} abc_set (SingI abc_set)).
- exact HU.
Qed.

Theorem top_abc_9_finer_than_top_abc_6 : finer_than top_abc_9 top_abc_6.
let U. assume HU: U :e top_abc_6.
prove U :e top_abc_9.
apply (binunionE' (UPair Empty (UPair a_elt b_elt)) {abc_set} U (U :e top_abc_9)).
- assume HU0: U :e UPair Empty (UPair a_elt b_elt).
  apply (UPairE U Empty (UPair a_elt b_elt) HU0).
  + assume HUeq: U = Empty.
    rewrite HUeq.
    exact (binunionI1 (UPair Empty {a_elt} :\/: {UPair a_elt b_elt}) {abc_set} Empty
            (binunionI1 (UPair Empty {a_elt}) {UPair a_elt b_elt} Empty (UPairI1 Empty {a_elt}))).
  + assume HUeq: U = UPair a_elt b_elt.
    rewrite HUeq.
    exact (binunionI1 (UPair Empty {a_elt} :\/: {UPair a_elt b_elt}) {abc_set} (UPair a_elt b_elt)
            (binunionI2 (UPair Empty {a_elt}) {UPair a_elt b_elt} (UPair a_elt b_elt) (SingI (UPair a_elt b_elt)))).
- assume HU0: U :e {abc_set}.
  claim HUeq: U = abc_set.
  { exact (SingE abc_set U HU0). }
  rewrite HUeq.
  exact (binunionI2 (UPair Empty {a_elt} :\/: {UPair a_elt b_elt}) {abc_set} abc_set (SingI abc_set)).
- exact HU.
Qed.

(** helper for 13 exercises: intersection of a family of topologies (placeholder) **)
(** LATEX VERSION: Intersection_Fam X Fam denotes the intersection (common opens) of all topologies in Fam. **)
(** FIXED: `Intersection_Fam X Fam` is the collection of common open sets, as subsets of the given ambient set `X`.
    This makes the empty-family case correct: if `Fam = Empty`, then `Intersection_Fam X Fam = Power X`. **)
Definition Intersection_Fam : set -> set -> set :=
  fun X Fam => {U :e Power X|forall T:set, T :e Fam -> U :e T}.

(** helper: empty family gives discrete topology **)
Theorem Intersection_Fam_empty_eq : forall X Fam:set,
  ~(exists T:set, T :e Fam) ->
  Intersection_Fam X Fam = Power X.
let X Fam.
assume HFamEmpty: ~(exists T:set, T :e Fam).
apply set_ext.
- let U. assume HU: U :e Intersection_Fam X Fam.
  exact (SepE1 (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) U HU).
- let U. assume HU: U :e Power X.
  claim HAllT: forall T:set, T :e Fam -> U :e T.
  { let T. assume HT: T :e Fam.
    apply FalseE.
    apply HFamEmpty.
    witness T. exact HT.
  }
  exact (SepI (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) U HU HAllT).
Qed.

(** helper: intersection of a family stays within X (updated for new signature) **)
Theorem intersection_of_family_sub_X : forall X Fam:set,
  intersection_of_family X Fam c= X.
let X Fam.
let x. assume Hx.
exact (SepE1 X (fun x0 => forall U:set, U :e Fam -> x0 :e U) x Hx).
Qed.

(** helper: empty set is in intersection family when all members contain Empty **)
Theorem intersection_of_family_empty : forall Fam:set,
  (forall T:set, T :e Fam -> Empty :e T) ->
  forall X:set, Empty :e Intersection_Fam X Fam.
let Fam.
assume HFamEmpty: forall T:set, T :e Fam -> Empty :e T.
let X.
prove Empty :e Intersection_Fam X Fam.
(** Intersection_Fam X Fam = {U :e Power X | forall T :e Fam, U :e T} **)
claim HEmptyPower: Empty :e Power X.
{ apply PowerI. apply Subq_Empty. }
exact (SepI (Power X) (fun U => forall T:set, T :e Fam -> U :e T) Empty HEmptyPower HFamEmpty).
Qed.

(** from 13 Exercise 3: infinite-complement collection **) 
(** LATEX VERSION: Exercise 3 examines countable-complement topology vs. infinite-complement family on X. **)
Definition infinite_complement_family : set -> set :=
  fun X => {U :e Power X | infinite (X :\: U) \/ U = Empty \/ U = X}.

(** LATEX VERSION: Exercise 3(a): The countable-complement topology T_c on X is a topology. **)
Theorem ex13_3a_Tc_topology : forall X:set, topology_on X (countable_complement_topology X).
let X.
exact (countable_complement_topology_on X).
Qed.

(** helper: nonempty open sets in T_c have countable complement (placeholder) **) 
Theorem ex13_3a_countable_complement_open : forall X:set, forall U :e countable_complement_topology X,
  U <> Empty -> countable (X :\: U).
let X U.
assume HU: U :e countable_complement_topology X.
assume Hnemp: U <> Empty.
prove countable (X :\: U).
(** By definition, U  countable_complement_topology X means countable(X\U)  U = Empty.
    Since U  Empty, we get countable(X\U). **)
claim Hprop: countable (X :\: U) \/ U = Empty.
{ exact (SepE2 (Power X) (fun V:set => countable (X :\: V) \/ V = Empty) U HU). }
claim Hcount_branch: countable (X :\: U) -> countable (X :\: U).
{ assume Hcount. exact Hcount. }
claim Hempty_branch: U = Empty -> countable (X :\: U).
{ assume HUeq.
  apply FalseE.
  exact (Hnemp HUeq). }
exact (Hprop (countable (X :\: U)) Hcount_branch Hempty_branch).
Qed.

(** helper: unions of Tc open families remain Tc-open (placeholder) **) 
Theorem ex13_3a_union_helper : forall X:set, forall UFam :e Power (countable_complement_topology X),
  Union UFam :e countable_complement_topology X.
let X UFam.
assume HUFam: UFam :e Power (countable_complement_topology X).
prove Union UFam :e countable_complement_topology X.
(** This follows from countable_complement_topology_on plus the union axiom of topology_on **)
claim Htop : topology_on X (countable_complement_topology X).
{ exact (countable_complement_topology_on X). }
exact (topology_union_axiom X (countable_complement_topology X) Htop UFam HUFam).
Qed.

(** helper: witness sets for infinite-complement failure, for infinite ambient sets **) 
Axiom ex13_3b_witness_sets_axiom : forall X:set,
  infinite X ->
  exists U V:set,
    U :e infinite_complement_family X /\ V :e infinite_complement_family X /\
    ~(Union (UPair U V) :e infinite_complement_family X).

Theorem ex13_3b_witness_sets : forall X:set,
  infinite X ->
  exists U V:set,
    U :e infinite_complement_family X /\ V :e infinite_complement_family X /\
    ~(Union (UPair U V) :e infinite_complement_family X).
let X.
assume HinfX: infinite X.
prove exists U V:set,
  U :e infinite_complement_family X /\ V :e infinite_complement_family X /\
  ~(Union (UPair U V) :e infinite_complement_family X).
exact (ex13_3b_witness_sets_axiom X HinfX).
Qed.

(** LATEX VERSION: Exercise 3(b): For infinite X, the infinite-complement family is not a topology (fails union closure). **)
Theorem ex13_3b_Tinfty_not_topology : forall X:set,
  infinite X ->
  ~topology_on X (infinite_complement_family X).
let X.
assume HinfX: infinite X.
assume Htop: topology_on X (infinite_complement_family X).
prove False.
(** Extract union-closure axiom from topology_on **)
claim H1:
  ((infinite_complement_family X c= Power X /\ Empty :e infinite_complement_family X) /\ X :e infinite_complement_family X) /\
  (forall UFam :e Power (infinite_complement_family X), Union UFam :e infinite_complement_family X).
{ exact (andEL (((infinite_complement_family X c= Power X /\ Empty :e infinite_complement_family X) /\ X :e infinite_complement_family X) /\
               (forall UFam :e Power (infinite_complement_family X), Union UFam :e infinite_complement_family X))
              (forall U :e infinite_complement_family X,
                 forall V :e infinite_complement_family X,
                   U :/\: V :e infinite_complement_family X)
              Htop). }
claim HUnionClosure: forall UFam :e Power (infinite_complement_family X),
  Union UFam :e infinite_complement_family X.
{ exact (andER ((infinite_complement_family X c= Power X /\ Empty :e infinite_complement_family X) /\ X :e infinite_complement_family X)
              (forall UFam :e Power (infinite_complement_family X), Union UFam :e infinite_complement_family X)
              H1). }
(** Use the (admitted) witness sets showing union failure **)
apply (ex13_3b_witness_sets X HinfX).
let U.
assume HexV.
apply HexV.
let V.
assume HUV.
claim Hcore: U :e infinite_complement_family X /\ V :e infinite_complement_family X.
{ exact (andEL (U :e infinite_complement_family X /\ V :e infinite_complement_family X)
              (~(Union (UPair U V) :e infinite_complement_family X))
              HUV). }
claim Hnot: ~(Union (UPair U V) :e infinite_complement_family X).
{ exact (andER (U :e infinite_complement_family X /\ V :e infinite_complement_family X)
              (~(Union (UPair U V) :e infinite_complement_family X))
              HUV). }
claim HU: U :e infinite_complement_family X.
{ exact (andEL (U :e infinite_complement_family X) (V :e infinite_complement_family X) Hcore). }
claim HV: V :e infinite_complement_family X.
{ exact (andER (U :e infinite_complement_family X) (V :e infinite_complement_family X) Hcore). }
claim HUVsub: UPair U V c= infinite_complement_family X.
{ let W. assume HW: W :e UPair U V.
  apply (UPairE W U V HW (W :e infinite_complement_family X)).
  - assume HWU: W = U. rewrite HWU. exact HU.
  - assume HWV: W = V. rewrite HWV. exact HV.
}
claim HUVinPower: UPair U V :e Power (infinite_complement_family X).
{ apply PowerI. exact HUVsub. }
claim HUnionIn: Union (UPair U V) :e infinite_complement_family X.
{ exact (HUnionClosure (UPair U V) HUVinPower). }
exact (Hnot HUnionIn).
Qed.

(** helper: structured witness outline for Tinfty failure, for infinite ambient sets **) 
Theorem ex13_3b_witness_outline : forall X:set,
  infinite X -> exists U V:set, U :e infinite_complement_family X /\ V :e infinite_complement_family X.
let X.
assume HinfX: infinite X.
prove exists U V:set, U :e infinite_complement_family X /\ V :e infinite_complement_family X.
witness Empty.
witness X.
apply andI.
- (** Empty is in the family by the defining disjunction **)
  prove Empty :e infinite_complement_family X.
  claim Hdisj : infinite (X :\: Empty) \/ Empty = Empty \/ Empty = X.
  { apply orIL.
    apply orIR.
    reflexivity. }
  exact (SepI (Power X)
              (fun U0 : set => infinite (X :\: U0) \/ U0 = Empty \/ U0 = X)
              Empty
              (Empty_In_Power X)
              Hdisj).
- (** X is in the family by the defining disjunction **)
  prove X :e infinite_complement_family X.
  claim Hdisj : infinite (X :\: X) \/ X = Empty \/ X = X.
  { apply orIR.
    reflexivity. }
  exact (SepI (Power X)
              (fun U0 : set => infinite (X :\: U0) \/ U0 = Empty \/ U0 = X)
              X
              (Self_In_Power X)
              Hdisj).
Qed.

(** from 13 Exercise 4(a): intersection of topologies **)
(** LATEX VERSION: Exercise 4(a): The intersection of a nonempty family of topologies on X is a topology. **)
Theorem ex13_4a_intersection_topology : forall X Fam:set,
  (exists T:set, T :e Fam) ->
  (forall T :e Fam, topology_on X T) ->
  topology_on X (Intersection_Fam X Fam).
let X Fam.
assume HFamNonempty: exists T:set, T :e Fam.
assume HfamTop: forall T :e Fam, topology_on X T.
prove topology_on X (Intersection_Fam X Fam).
prove Intersection_Fam X Fam c= Power X
  /\ Empty :e Intersection_Fam X Fam
  /\ X :e Intersection_Fam X Fam
  /\ (forall UFam :e Power (Intersection_Fam X Fam), Union UFam :e Intersection_Fam X Fam)
  /\ (forall U :e Intersection_Fam X Fam, forall V :e Intersection_Fam X Fam, U :/\: V :e Intersection_Fam X Fam).
apply andI.
- (** Left part: subset, empty, X, union **)
  apply andI.
  + (** Left part: subset, empty, X **)
    apply andI.
    * (** Left part: subset and empty **)
      apply andI.
      { (** Axiom 1: Intersection_Fam X Fam c= Power X **)
        let U. assume HU: U :e Intersection_Fam X Fam.
        prove U :e Power X.
        exact (SepE1 (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) U HU).
      }
      { (** Axiom 2: Empty :e Intersection_Fam X Fam **)
        prove Empty :e Intersection_Fam X Fam.
        claim HEmptyPower: Empty :e Power X.
        { exact (Empty_In_Power X). }
        claim HEmptyAllT: forall T:set, T :e Fam -> Empty :e T.
        { let T. assume HT: T :e Fam.
          exact (topology_has_empty X T (HfamTop T HT)).
        }
        exact (SepI (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) Empty HEmptyPower HEmptyAllT).
      }
    * (** Axiom 3: X :e Intersection_Fam X Fam **)
      prove X :e Intersection_Fam X Fam.
      claim HXPower: X :e Power X.
      { exact (Self_In_Power X). }
      claim HXAllT: forall T:set, T :e Fam -> X :e T.
      { let T. assume HT: T :e Fam.
        exact (topology_has_X X T (HfamTop T HT)).
      }
      exact (SepI (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) X HXPower HXAllT).
  + (** Axiom 4: unions preserved **)
    let UFam. assume HUFamPow: UFam :e Power (Intersection_Fam X Fam).
    prove Union UFam :e Intersection_Fam X Fam.
    claim HUFamSubInter: UFam c= Intersection_Fam X Fam.
    { exact (PowerE (Intersection_Fam X Fam) UFam HUFamPow). }
    claim HUFamSubPowX: UFam c= Power X.
    { let U. assume HUinUFam: U :e UFam.
      claim HUinInter: U :e Intersection_Fam X Fam.
      { exact (HUFamSubInter U HUinUFam). }
      exact (SepE1 (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) U HUinInter).
    }
    claim HUnionPower: Union UFam :e Power X.
    { apply PowerI.
      exact (Union_Power X UFam HUFamSubPowX).
    }
    claim HUnionAllT: forall T:set, T :e Fam -> Union UFam :e T.
    { let T. assume HT: T :e Fam.
      claim HTtop: topology_on X T.
      { exact (HfamTop T HT). }
      claim HUFamSubT: UFam c= T.
      { let U. assume HUinUFam: U :e UFam.
        claim HUinInter: U :e Intersection_Fam X Fam.
        { exact (HUFamSubInter U HUinUFam). }
        claim HUinAllT: forall T0:set, T0 :e Fam -> U :e T0.
        { exact (SepE2 (Power X) (fun U0 => forall T0:set, T0 :e Fam -> U0 :e T0) U HUinInter). }
        exact (HUinAllT T HT).
      }
      claim HUFamPowT: UFam :e Power T.
      { apply PowerI. exact HUFamSubT. }
      exact (topology_union_axiom X T HTtop UFam HUFamPowT).
    }
    exact (SepI (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) (Union UFam) HUnionPower HUnionAllT).
- (** Axiom 5: binary intersections preserved **)
  let U. assume HU: U :e Intersection_Fam X Fam.
  let V. assume HV: V :e Intersection_Fam X Fam.
  prove U :/\: V :e Intersection_Fam X Fam.
  claim HUinPower: U :e Power X.
  { exact (SepE1 (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) U HU). }
  claim HVinPower: V :e Power X.
  { exact (SepE1 (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) V HV). }
  claim HUVPower: U :/\: V :e Power X.
  { exact (binintersect_Power X U V HUinPower HVinPower). }
  claim HUVinAllT: forall T:set, T :e Fam -> U :/\: V :e T.
  { let T. assume HT: T :e Fam.
    claim HTtop: topology_on X T.
    { exact (HfamTop T HT). }
    claim HUT: U :e T.
    { exact ((SepE2 (Power X) (fun U0 => forall T0:set, T0 :e Fam -> U0 :e T0) U HU) T HT). }
    claim HVT: V :e T.
    { exact ((SepE2 (Power X) (fun U0 => forall T0:set, T0 :e Fam -> U0 :e T0) V HV) T HT). }
    exact (topology_binintersect_axiom X T HTtop U HUT V HVT).
  }
  exact (SepI (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) (U :/\: V) HUVPower HUVinAllT).
Qed.

(** from 13 Exercise 4(b): smallest/largest topology containing a family **) 
(** LATEX VERSION: Exercise 4(b): There exist smallest and largest topologies containing a given family of topologies on X. **)
Theorem ex13_4b_smallest_largest : forall X Fam:set,
  (forall T :e Fam, topology_on X T) ->
  exists Tmin, topology_on X Tmin /\ (forall T :e Fam, T c= Tmin) /\
    (forall T', topology_on X T' /\ (forall T :e Fam, T c= T') -> Tmin c= T') /\
  exists Tmax, topology_on X Tmax /\ (forall T :e Fam, Tmax c= T) /\
    (forall T', topology_on X T' /\ (forall T :e Fam, T' c= T) -> T' c= Tmax).
let X Fam.
assume HfamTop: forall T :e Fam, topology_on X T.
prove exists Tmin, topology_on X Tmin /\ (forall T :e Fam, T c= Tmin) /\ (forall T', topology_on X T' /\ (forall T :e Fam, T c= T') -> Tmin c= T') /\ exists Tmax, topology_on X Tmax /\ (forall T :e Fam, Tmax c= T) /\ (forall T', topology_on X T' /\ (forall T :e Fam, T' c= T) -> T' c= Tmax).
	(** Strategy: Tmax = Intersection_Fam X Fam (by ex13_4a_intersection_topology);
	    Tmin = generated_topology_from_subbasis X (Union Fam :\/: {X}) (add X so subbasis union equals X even if Fam is empty). **)
set Tmax := Intersection_Fam X Fam.
set Tmin := generated_topology_from_subbasis X (Union Fam :\/: {X}).
(** First prove Tmax properties **)
claim HTmax_topology: topology_on X Tmax.
{ apply (xm (exists T:set, T :e Fam)).
  - assume HFamNonempty: exists T:set, T :e Fam.
    exact (ex13_4a_intersection_topology X Fam HFamNonempty HfamTop).
  - assume HFamEmpty: ~(exists T:set, T :e Fam).
    (** If `Fam` is empty then `Intersection_Fam X Fam = Power X`, i.e. the discrete topology. **)
    rewrite (Intersection_Fam_empty_eq X Fam HFamEmpty).
    exact (discrete_topology_on X).
}
claim HTmax_subset_all: forall T :e Fam, Tmax c= T.
{ let T. assume HT: T :e Fam.
  (** Tmax = Intersection_Fam X Fam = {U :e Power X | forall T :e Fam, U :e T} **)
  (** So every U in Tmax is in every T in Fam, hence Tmax c= T **)
  let U. assume HU: U :e Tmax.
  claim HUinT: U :e T.
  { claim HUinAllT: forall T0:set, T0 :e Fam -> U :e T0.
    { exact (SepE2 (Power X) (fun U0 => forall T0:set, T0 :e Fam -> U0 :e T0) U HU). }
    exact (HUinAllT T HT).
  }
  exact HUinT.
}
claim HTmax_maximal: forall T', topology_on X T' /\ (forall T :e Fam, T' c= T) -> T' c= Tmax.
{ let T'. assume HT'_cond.
  claim HT'_top: topology_on X T'.
  { exact (andEL (topology_on X T') (forall T :e Fam, T' c= T) HT'_cond). }
  claim HT'_sub_all: forall T :e Fam, T' c= T.
  { exact (andER (topology_on X T') (forall T :e Fam, T' c= T) HT'_cond). }
  (** Need to show T' c= Tmax, i.e., every U in T' is in Tmax **)
  (** U :e Tmax iff U :e Power X and forall T :e Fam, U :e T **)
  let U. assume HU: U :e T'.
  (** Show U :e Tmax = Intersection_Fam X Fam **)
  claim HUinPower: U :e Power X.
  { claim HT'_sub_PowerX: T' c= Power X.
    { claim H1: ((T' c= Power X /\ Empty :e T') /\ X :e T') /\ (forall UFam :e Power T', Union UFam :e T').
      { exact (andEL (((T' c= Power X /\ Empty :e T') /\ X :e T') /\ (forall UFam :e Power T', Union UFam :e T')) (forall U0 :e T', forall V :e T', U0 :/\: V :e T') HT'_top). }
      claim H2: (T' c= Power X /\ Empty :e T') /\ X :e T'.
      { exact (andEL ((T' c= Power X /\ Empty :e T') /\ X :e T') (forall UFam :e Power T', Union UFam :e T') H1). }
      claim H3: T' c= Power X /\ Empty :e T'.
      { exact (andEL (T' c= Power X /\ Empty :e T') (X :e T') H2). }
      exact (andEL (T' c= Power X) (Empty :e T') H3).
    }
    exact (HT'_sub_PowerX U HU).
  }
  claim HUinAllT: forall T :e Fam, U :e T.
  { let T. assume HT: T :e Fam.
    claim HT'subT: T' c= T.
    { exact (HT'_sub_all T HT). }
    exact (HT'subT U HU).
  }
  exact (SepI (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) U HUinPower HUinAllT).
}
(** Now prove Tmin properties **)
(** First show Union Fam is a subbasis **)
claim HUnionFam_subbasis: subbasis_on X (Union Fam :\/: {X}).
{ (** subbasis_on X S := (S c= Power X) /\ Union S = X **)
  prove (Union Fam :\/: {X}) c= Power X /\ Union (Union Fam :\/: {X}) = X.
  apply andI.
  - (** Union Fam :\/: {X} c= Power X **)
    let U. assume HU: U :e Union Fam :\/: {X}.
    prove U :e Power X.
    apply (binunionE' (Union Fam) {X} U (U :e Power X)).
    + assume HUinUnion: U :e Union Fam.
      apply UnionE_impred Fam U HUinUnion.
      let T. assume HUT: U :e T. assume HT: T :e Fam.
      claim HTtop: topology_on X T.
      { exact (HfamTop T HT). }
      claim H1: ((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T).
      { exact (andEL (((T c= Power X /\ Empty :e T) /\ X :e T) /\ (forall UFam :e Power T, Union UFam :e T)) (forall U0 :e T, forall V :e T, U0 :/\: V :e T) HTtop). }
      claim H2: (T c= Power X /\ Empty :e T) /\ X :e T.
      { exact (andEL ((T c= Power X /\ Empty :e T) /\ X :e T) (forall UFam :e Power T, Union UFam :e T) H1). }
      claim H3: T c= Power X /\ Empty :e T.
      { exact (andEL (T c= Power X /\ Empty :e T) (X :e T) H2). }
      claim HTsub: T c= Power X.
      { exact (andEL (T c= Power X) (Empty :e T) H3). }
      exact (HTsub U HUT).
    + assume HUinSing: U :e {X}.
      claim HUeq: U = X.
      { exact (SingE X U HUinSing). }
      rewrite HUeq.
      exact (PowerI X X (Subq_ref X)).
    + exact HU.
  - (** Union (Union Fam :\/: {X}) = X **)
    apply set_ext.
    + (** Union (Union Fam :\/: {X}) c= X **)
      let x. assume Hx: x :e Union (Union Fam :\/: {X}).
      prove x :e X.
      apply UnionE_impred (Union Fam :\/: {X}) x Hx.
      let U. assume HxU: x :e U. assume HU: U :e Union Fam :\/: {X}.
      apply (binunionE' (Union Fam) {X} U (x :e X)).
      - assume HUinUnion: U :e Union Fam.
        apply UnionE_impred Fam U HUinUnion.
        let T. assume HUT: U :e T. assume HT: T :e Fam.
        claim HTtop: topology_on X T.
        { exact (HfamTop T HT). }
        claim HUsubX: U c= X.
        { exact (topology_elem_subset X T U HTtop HUT). }
        exact (HUsubX x HxU).
      - assume HUinSing: U :e {X}.
        claim HUeq: U = X.
        { exact (SingE X U HUinSing). }
        rewrite <- HUeq.
        exact HxU.
      - exact HU.
    + (** X c= Union (Union Fam :\/: {X}) **)
      let x. assume HxX: x :e X.
      prove x :e Union (Union Fam :\/: {X}).
      claim HX_in_subbasis: X :e Union Fam :\/: {X}.
      { exact (binunionI2 (Union Fam) {X} X (SingI X)). }
      exact (UnionI (Union Fam :\/: {X}) x X HxX HX_in_subbasis).
}
claim HTmin_topology: topology_on X Tmin.
{ exact (topology_from_subbasis_is_topology X (Union Fam :\/: {X}) HUnionFam_subbasis). }
claim HTmin_contains_all: forall T :e Fam, T c= Tmin.
{ let T. assume HT: T :e Fam.
  (** Need to show every open set in T is in Tmin = generated_topology_from_subbasis X (Union Fam) **)
  let U. assume HU: U :e T.
  (** Show U :e generated_topology_from_subbasis X (Union Fam :\/: {X}) **)
  (** = generated_topology X (basis_of_subbasis X (Union Fam :\/: {X})) **)
  (** = {V :e Power X | forall x :e V, exists b :e basis_of_subbasis X (Union Fam :\/: {X}), x :e b /\ b c= V} **)
  (** Since U :e T and T :e Fam, we have U :e Union Fam and hence U :e Union Fam :\/: {X} **)
  claim HUinUnionFam: U :e Union Fam.
  { exact (UnionI Fam U T HU HT). }
  (** U is in the subbasis, so by subbasis_elem_in_basis, it's in the basis **)
  apply (xm (U = Empty)).
  - assume HUempty: U = Empty.
    (** Empty is in every topology **)
    claim HEmptyinTmin: Empty :e Tmin.
    { claim H1: ((Tmin c= Power X /\ Empty :e Tmin) /\ X :e Tmin) /\ (forall UFam :e Power Tmin, Union UFam :e Tmin).
      { exact (andEL (((Tmin c= Power X /\ Empty :e Tmin) /\ X :e Tmin) /\ (forall UFam :e Power Tmin, Union UFam :e Tmin)) (forall U0 :e Tmin, forall V :e Tmin, U0 :/\: V :e Tmin) HTmin_topology). }
      claim H2: (Tmin c= Power X /\ Empty :e Tmin) /\ X :e Tmin.
      { exact (andEL ((Tmin c= Power X /\ Empty :e Tmin) /\ X :e Tmin) (forall UFam :e Power Tmin, Union UFam :e Tmin) H1). }
      claim H3: Tmin c= Power X /\ Empty :e Tmin.
      { exact (andEL (Tmin c= Power X /\ Empty :e Tmin) (X :e Tmin) H2). }
      exact (andER (Tmin c= Power X) (Empty :e Tmin) H3).
    }
    rewrite HUempty.
    exact HEmptyinTmin.
  - assume HUnonempty: U <> Empty.
    claim HUinSubbasis: U :e Union Fam :\/: {X}.
    { exact (binunionI1 (Union Fam) {X} U HUinUnionFam). }
    claim HUinBasis: U :e basis_of_subbasis X (Union Fam :\/: {X}).
    { exact (subbasis_elem_in_basis X (Union Fam :\/: {X}) U HUnionFam_subbasis HUinSubbasis HUnonempty). }
    (** Now use basis_in_generated **)
    claim HBasis: basis_on X (basis_of_subbasis X (Union Fam :\/: {X})).
    { exact (finite_intersections_basis_of_subbasis X (Union Fam :\/: {X}) HUnionFam_subbasis). }
    exact (basis_in_generated X (basis_of_subbasis X (Union Fam :\/: {X})) U HBasis HUinBasis).
}
claim HTmin_minimal: forall T', topology_on X T' /\ (forall T :e Fam, T c= T') -> Tmin c= T'.
{ let T'. assume HT'_cond.
  claim HT'_top: topology_on X T'.
  { exact (andEL (topology_on X T') (forall T :e Fam, T c= T') HT'_cond). }
  claim HT'_contains_all: forall T :e Fam, T c= T'.
  { exact (andER (topology_on X T') (forall T :e Fam, T c= T') HT'_cond). }
  (** Show Union Fam :\/: {X} c= T' **)
  claim HSubbasis_sub_T': Union Fam :\/: {X} c= T'.
  { let U. assume HU: U :e Union Fam :\/: {X}.
    apply (binunionE' (Union Fam) {X} U (U :e T')).
    - assume HUinUnion: U :e Union Fam.
      apply UnionE_impred Fam U HUinUnion.
      let T. assume HUT: U :e T. assume HT: T :e Fam.
      claim HTsubT': T c= T'.
      { exact (HT'_contains_all T HT). }
      exact (HTsubT' U HUT).
    - assume HUinSing: U :e {X}.
      claim HUeq: U = X.
      { exact (SingE X U HUinSing). }
      rewrite HUeq.
      exact (topology_has_X X T' HT'_top).
    - exact HU.
  }
  (** Apply topology_generated_by_basis_is_minimal **)
  exact (topology_generated_by_basis_is_minimal X (Union Fam :\/: {X}) T' HUnionFam_subbasis HT'_top HSubbasis_sub_T').
}
(** Combine all parts with existential introductions **)
witness Tmin.
apply andI.
- apply andI.
  + (** topology_on X Tmin /\ (forall T :e Fam, T c= Tmin) **)
    apply andI.
    * exact HTmin_topology.
    * exact HTmin_contains_all.
  + exact HTmin_minimal.
- (** exists Tmax... **)
  witness Tmax.
  apply andI.
  + (** topology_on X Tmax /\ (forall T :e Fam, Tmax c= T) **)
    apply andI.
    * exact HTmax_topology.
    * exact HTmax_subset_all.
  + exact HTmax_maximal.
Qed.

(** from 13 Exercise 4(c): specific smallest/largest topology on {a,b,c} **) 
(** LATEX VERSION: Exercise 4(c): Determine the smallest and largest topologies on {a,b,c} containing given families (continuation of Exercise 4). **)
Theorem ex13_4c_specific_topologies :
  exists Tsmall Tall:set, topology_on abc_set Tsmall /\ topology_on abc_set Tall.
prove exists Tsmall Tall:set, topology_on abc_set Tsmall /\ topology_on abc_set Tall.
witness (indiscrete_topology abc_set).
witness (discrete_topology abc_set).
apply andI.
- exact (indiscrete_topology_on abc_set).
- exact (discrete_topology_on abc_set).
Qed.

(** from 13 Exercise 5: topology generated by a basis is intersection of topologies containing it **) 
(** LATEX VERSION: Exercise 5: The topology generated by a basis A equals the intersection of all topologies on X containing A. **)
Theorem ex13_5_basis_intersection : forall X A:set,
  basis_on X A ->
  generated_topology X A =
    Intersection_Fam X {T :e Power (Power X)|topology_on X T /\ A c= T}.
let X A.
assume HA: basis_on X A.
prove generated_topology X A = Intersection_Fam X {T :e Power (Power X)|topology_on X T /\ A c= T}.
set Fam := {T :e Power (Power X)|topology_on X T /\ A c= T}.
apply set_ext.
- (** generated_topology X A c= Intersection_Fam X Fam **)
  let U. assume HU: U :e generated_topology X A.
  (** Show U :e Intersection_Fam X Fam, i.e., U :e every T in Fam **)
  claim HUinPower: U :e Power X.
  { claim HUsub: U c= X.
    { exact (generated_topology_subset X A U HU). }
    exact (PowerI X U HUsub).
  }
  claim HUinAllT: forall T :e Fam, U :e T.
  { let T. assume HT: T :e Fam.
    (** Extract topology_on X T and A c= T from HT **)
    claim HTinPowerPower: T :e Power (Power X).
    { exact (SepE1 (Power (Power X)) (fun T0 => topology_on X T0 /\ A c= T0) T HT). }
    claim HTcond: topology_on X T /\ A c= T.
    { exact (SepE2 (Power (Power X)) (fun T0 => topology_on X T0 /\ A c= T0) T HT). }
    claim HTtop: topology_on X T.
    { exact (andEL (topology_on X T) (A c= T) HTcond). }
    claim HAinT: A c= T.
    { exact (andER (topology_on X T) (A c= T) HTcond). }
    (** Apply generated_topology_finer: if T contains all basis elements, generated_topology X A c= T **)
    claim HGenSubT: generated_topology X A c= T.
    { claim HAllAinT: forall a :e A, a :e T.
      { let a. assume Ha: a :e A.
        exact (HAinT a Ha).
      }
      exact (generated_topology_finer X A T HA HTtop HAllAinT).
    }
    exact (HGenSubT U HU).
  }
  exact (SepI (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) U HUinPower HUinAllT).
- (** Intersection_Fam X Fam c= generated_topology X A **)
  let U. assume HU: U :e Intersection_Fam X Fam.
  (** U is in every topology containing A, in particular in generated_topology X A **)
  claim HGenTop: topology_on X (generated_topology X A).
  { exact (lemma_topology_from_basis X A HA). }
  claim HAinGen: A c= generated_topology X A.
  { let a. assume Ha: a :e A.
    exact (basis_in_generated X A a HA Ha).
  }
  claim HGenInFam: generated_topology X A :e Fam.
  { (** Need to show generated_topology X A :e Power (Power X) and satisfies the condition **)
    claim HGenInPowerPower: generated_topology X A :e Power (Power X).
    { apply PowerI.
      let V. assume HV: V :e generated_topology X A.
      claim HVsub: V c= X.
      { exact (generated_topology_subset X A V HV). }
      exact (PowerI X V HVsub).
    }
    exact (SepI (Power (Power X)) (fun T => topology_on X T /\ A c= T) (generated_topology X A) HGenInPowerPower (andI (topology_on X (generated_topology X A)) (A c= generated_topology X A) HGenTop HAinGen)).
  }
  (** Now U :e Intersection_Fam X Fam means U :e every T in Fam **)
  claim HUinAllT: forall T :e Fam, U :e T.
  { exact (SepE2 (Power X) (fun U0 => forall T:set, T :e Fam -> U0 :e T) U HU). }
  exact (HUinAllT (generated_topology X A) HGenInFam).
Qed.

(** from 13 Exercise 6: incomparability of two real line topologies **)
(** LATEX VERSION: Exercise 6: Compare the standard, lower limit, and K-topologies on ; standard vs lower-limit and standard vs K are incomparable. **)
(** FIXED: Now uses proper rational definition (same as Q).
    rational = {x :e real | exists m :e int, exists n :e omega\{0}, x = m/n} from line 6202. **)
Definition rational_numbers : set := rational.

(** from 13: rationals are reals **)
(** LATEX VERSION: Q is a subset of R. **)
Theorem rational_numbers_Subq_R : rational_numbers c= R.
exact (Subq_rational_real).
Qed.

(** from 13: elements of Q are in R **)
(** LATEX VERSION: If q is rational then q is real. **)
Theorem rational_numbers_in_R : forall q :e rational_numbers, q :e R.
let q. assume Hq.
exact (rational_numbers_Subq_R q Hq).
Qed.

Definition open_interval : set -> set -> set := fun a b => {x :e R|Rlt a x /\ Rlt x b}.
(** from 13 Exercise 6: lower limit basis element **)
(** LATEX VERSION: Lower limit topology uses half open intervals [a,b). **)
Definition halfopen_interval_left : set -> set -> set := fun a b => {x :e R|~(Rlt x a) /\ Rlt x b}.

(** from 13 Exercise 7: upper limit basis element **)
(** LATEX VERSION: Upper limit topology uses half open intervals (a,b]. **)
Definition halfopen_interval_right : set -> set -> set := fun a b => {x :e R|Rlt a x /\ ~(Rlt b x)}.

(** from 13 Exercise 7: upper limit interval is a subset of R **)
(** LATEX VERSION: (a,b] is a subset of R. **)
Theorem halfopen_interval_right_Subq_R : forall a b:set, halfopen_interval_right a b c= R.
let a b.
let x. assume Hx.
exact (SepE1 R (fun x0 : set => Rlt a x0 /\ ~(Rlt b x0)) x Hx).
Qed.

(** from 13 Exercise 7: right endpoint belongs to (a,b] when a<b **)
(** LATEX VERSION: If a<b then b is in (a,b]. **)
Theorem halfopen_interval_right_rightmem : forall a b:set, Rlt a b -> b :e halfopen_interval_right a b.
let a b. assume Hab.
claim HbR : b :e R.
{ exact (RltE_right a b Hab). }
claim Hprop : Rlt a b /\ ~(Rlt b b).
{ apply andI.
  - exact Hab.
  - exact (not_Rlt_refl b HbR). }
exact (SepI R (fun x0 : set => Rlt a x0 /\ ~(Rlt b x0)) b HbR Hprop).
Qed.

(** from 13 Exercise 6: open interval is a subset of  **)
(** LATEX VERSION: (a,b) is a subset of . **)
Theorem open_interval_Subq_R : forall a b:set, open_interval a b c= R.
let a b.
let x. assume Hx.
exact (SepE1 R (fun x0 : set => Rlt a x0 /\ Rlt x0 b) x Hx).
Qed.

(** from 13: every real lies in some standard open interval **)
(** LATEX VERSION: For any x in R, x is contained in (x-1,x+1). **)
Theorem real_in_open_interval_minus1_plus1 : forall x:set,
  x :e R ->
  x :e open_interval (add_SNo x (minus_SNo 1)) (add_SNo x 1).
let x. assume HxR.
set a0 := add_SNo x (minus_SNo 1).
set b0 := add_SNo x 1.
claim Hm1R : minus_SNo 1 :e R.
{ exact (real_minus_SNo 1 real_1). }
claim Ha0R : a0 :e R.
{ exact (real_add_SNo x HxR (minus_SNo 1) Hm1R). }
claim Hb0R : b0 :e R.
{ exact (real_add_SNo x HxR 1 real_1). }
claim HxS : SNo x.
{ exact (real_SNo x HxR). }
claim Hm1S : SNo (minus_SNo 1).
{ exact (real_SNo (minus_SNo 1) Hm1R). }
claim H1S : SNo 1.
{ exact (real_SNo 1 real_1). }
claim Ha0ltx : a0 < x.
{ claim Hlt : a0 < add_SNo x 0.
  { exact (add_SNo_Lt2 x (minus_SNo 1) 0 HxS Hm1S SNo_0 minus_1_lt_0). }
  rewrite <- (add_SNo_0R x HxS) at 2.
  exact Hlt. }
claim Hxltb0 : x < b0.
{ claim Hlt : add_SNo x 0 < b0.
  { exact (add_SNo_Lt2 x 0 1 HxS SNo_0 H1S SNoLt_0_1). }
  rewrite <- (add_SNo_0R x HxS) at 1.
  exact Hlt. }
claim Ha0x : Rlt a0 x.
{ exact (RltI a0 x Ha0R HxR Ha0ltx). }
claim Hxb0 : Rlt x b0.
{ exact (RltI x b0 HxR Hb0R Hxltb0). }
claim Hconj : Rlt a0 x /\ Rlt x b0.
{ apply andI.
  - exact Ha0x.
  - exact Hxb0. }
exact (SepI R (fun x0 : set => Rlt a0 x0 /\ Rlt x0 b0) x HxR Hconj).
Qed.

(** from 13 Exercise 6: half open interval is a subset of  **)
(** LATEX VERSION: [a,b) is a subset of . **)
Theorem halfopen_interval_left_Subq_R : forall a b:set, halfopen_interval_left a b c= R.
let a b.
let x. assume Hx.
exact (SepE1 R (fun x0 : set => ~(Rlt x0 a) /\ Rlt x0 b) x Hx).
Qed.

(** from 13 Exercise 6: left endpoint belongs to [a,b) when a<b **)
(** LATEX VERSION: If a<b then a[a,b). **)
Theorem halfopen_interval_left_leftmem : forall a b:set, Rlt a b -> a :e halfopen_interval_left a b.
let a b. assume Hab.
claim HaR : a :e R.
{ exact (RltE_left a b Hab). }
claim Hb : ~(Rlt a a) /\ Rlt a b.
{ apply andI.
  - exact (not_Rlt_refl a HaR).
  - exact Hab. }
exact (SepI R (fun x0 : set => ~(Rlt x0 a) /\ Rlt x0 b) a HaR Hb).
Qed.

Definition R_standard_basis : set :=
  \/_ a :e R, {open_interval a b|b :e R}.

Definition R_standard_topology : set :=
  generated_topology R R_standard_basis.

(** from 13: standard open intervals form a basis on R **)
(** LATEX VERSION: The collection of open intervals (a,b) is a basis for the standard topology on R. **)
Theorem R_standard_basis_is_basis_local : basis_on R R_standard_basis.
prove basis_on R R_standard_basis.
prove R_standard_basis c= Power R
  /\ (forall x :e R, exists b :e R_standard_basis, x :e b)
  /\ (forall b1 :e R_standard_basis, forall b2 :e R_standard_basis, forall x:set,
        x :e b1 -> x :e b2 ->
        exists b3 :e R_standard_basis, x :e b3 /\ b3 c= b1 :/\: b2).
apply andI.
- apply andI.
  + (** basis elements are subsets of R **)
    let U. assume HU : U :e R_standard_basis.
    prove U :e Power R.
    (** destruct U  _{aR} {open_interval a b | bR} **)
    claim Hexa : exists a :e R, U :e {open_interval a b|b :e R}.
    { exact (famunionE R (fun a0 : set => {open_interval a0 b|b :e R}) U HU). }
    apply Hexa.
    let a. assume Hapair.
    claim HaR : a :e R.
    { exact (andEL (a :e R) (U :e {open_interval a b|b :e R}) Hapair). }
    claim HUfam : U :e {open_interval a b|b :e R}.
    { exact (andER (a :e R) (U :e {open_interval a b|b :e R}) Hapair). }
    claim Hexb : exists b :e R, U = open_interval a b.
    { exact (ReplE R (fun b0 : set => open_interval a b0) U HUfam). }
    apply Hexb.
    let b. assume Hbpair.
    claim HbR : b :e R.
    { exact (andEL (b :e R) (U = open_interval a b) Hbpair). }
    claim HUeq : U = open_interval a b.
    { exact (andER (b :e R) (U = open_interval a b) Hbpair). }
    rewrite HUeq.
    exact (PowerI R (open_interval a b) (open_interval_Subq_R a b)).
  + (** coverage: every x has a basis neighborhood **)
    let x. assume HxR.
    (** choose (x-1, x+1) **)
    claim Hm1R : minus_SNo 1 :e R.
    { exact (real_minus_SNo 1 real_1). }
    set a0 := add_SNo x (minus_SNo 1).
    set b0 := add_SNo x 1.
    claim Ha0R : a0 :e R.
    { exact (real_add_SNo x HxR (minus_SNo 1) Hm1R). }
    claim Hb0R : b0 :e R.
    { exact (real_add_SNo x HxR 1 real_1). }
    set I := open_interval a0 b0.
    witness I.
    apply andI.
    * (** I is in the standard basis **)
      claim HIa : I :e {open_interval a0 bb|bb :e R}.
      { exact (ReplI R (fun bb : set => open_interval a0 bb) b0 Hb0R). }
      exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a0 I Ha0R HIa).
    * (** x is in I **)
      claim HxS : SNo x.
      { exact (real_SNo x HxR). }
      claim Hm1S : SNo (minus_SNo 1).
      { exact (SNo_minus_SNo 1 SNo_1). }
      claim Hxltb0 : x < b0.
      { claim Hx0lt : 0 < 1.
        { exact SNoLt_0_1. }
	      claim Hx0eq : add_SNo x 0 = x.
	      { exact (add_SNo_0R x HxS). }
	      claim Hlt : add_SNo x 0 < add_SNo x 1.
	      { exact (add_SNo_Lt2 x 0 1 HxS SNo_0 SNo_1 Hx0lt). }
	      rewrite <- Hx0eq at 1.
	      exact Hlt. }
      claim Ha0ltx : a0 < x.
      { claim Hlt : add_SNo x (minus_SNo 1) < add_SNo x 0.
        { exact (add_SNo_Lt2 x (minus_SNo 1) 0 HxS Hm1S SNo_0 minus_1_lt_0). }
        rewrite <- (add_SNo_0R x HxS) at 2.
        exact Hlt. }
      claim Ha0x : Rlt a0 x.
      { exact (RltI a0 x Ha0R HxR Ha0ltx). }
      claim Hxb0 : Rlt x b0.
      { exact (RltI x b0 HxR Hb0R Hxltb0). }
      claim Hconj : Rlt a0 x /\ Rlt x b0.
      { apply andI.
        - exact Ha0x.
        - exact Hxb0. }
      exact (SepI R (fun x0 : set => Rlt a0 x0 /\ Rlt x0 b0) x HxR Hconj).
- (** intersection refinement **)
  let b1. assume Hb1.
  let b2. assume Hb2.
  let x. assume Hx1 Hx2.
  (** destruct b1 = (a1,b1') and b2 = (a2,b2') with endpoints in R **)
  claim Hexa1 : exists a1 :e R, b1 :e {open_interval a1 b|b :e R}.
  { exact (famunionE R (fun a0 : set => {open_interval a0 b|b :e R}) b1 Hb1). }
  claim Hexa2 : exists a2 :e R, b2 :e {open_interval a2 b|b :e R}.
  { exact (famunionE R (fun a0 : set => {open_interval a0 b|b :e R}) b2 Hb2). }
  apply Hexa1.
  let a1. assume Ha1pair.
  claim Ha1R : a1 :e R.
  { exact (andEL (a1 :e R) (b1 :e {open_interval a1 b|b :e R}) Ha1pair). }
  claim Hb1fam : b1 :e {open_interval a1 b|b :e R}.
  { exact (andER (a1 :e R) (b1 :e {open_interval a1 b|b :e R}) Ha1pair). }
  claim Hexb1 : exists bb1 :e R, b1 = open_interval a1 bb1.
  { exact (ReplE R (fun bb : set => open_interval a1 bb) b1 Hb1fam). }
  apply Hexb1.
  let bb1. assume Hbb1pair.
  claim Hbb1R : bb1 :e R.
  { exact (andEL (bb1 :e R) (b1 = open_interval a1 bb1) Hbb1pair). }
  claim Hb1eq : b1 = open_interval a1 bb1.
  { exact (andER (bb1 :e R) (b1 = open_interval a1 bb1) Hbb1pair). }
  apply Hexa2.
  let a2. assume Ha2pair.
  claim Ha2R : a2 :e R.
  { exact (andEL (a2 :e R) (b2 :e {open_interval a2 b|b :e R}) Ha2pair). }
  claim Hb2fam : b2 :e {open_interval a2 b|b :e R}.
  { exact (andER (a2 :e R) (b2 :e {open_interval a2 b|b :e R}) Ha2pair). }
  claim Hexb2 : exists bb2 :e R, b2 = open_interval a2 bb2.
  { exact (ReplE R (fun bb : set => open_interval a2 bb) b2 Hb2fam). }
  apply Hexb2.
  let bb2. assume Hbb2pair.
  claim Hbb2R : bb2 :e R.
  { exact (andEL (bb2 :e R) (b2 = open_interval a2 bb2) Hbb2pair). }
  claim Hb2eq : b2 = open_interval a2 bb2.
  { exact (andER (bb2 :e R) (b2 = open_interval a2 bb2) Hbb2pair). }
  (** extract inequalities from x  intervals **)
  claim HxIn1 : x :e open_interval a1 bb1.
  { rewrite <- Hb1eq. exact Hx1. }
  claim HxIn2 : x :e open_interval a2 bb2.
  { rewrite <- Hb2eq. exact Hx2. }
  claim HxR : x :e R.
  { exact (SepE1 R (fun x0 : set => Rlt a1 x0 /\ Rlt x0 bb1) x HxIn1). }
  claim HxProp1 : Rlt a1 x /\ Rlt x bb1.
  { exact (SepE2 R (fun x0 : set => Rlt a1 x0 /\ Rlt x0 bb1) x HxIn1). }
  claim HxProp2 : Rlt a2 x /\ Rlt x bb2.
  { exact (SepE2 R (fun x0 : set => Rlt a2 x0 /\ Rlt x0 bb2) x HxIn2). }
  claim Ha1x : Rlt a1 x.
  { exact (andEL (Rlt a1 x) (Rlt x bb1) HxProp1). }
  claim Hxbb1 : Rlt x bb1.
  { exact (andER (Rlt a1 x) (Rlt x bb1) HxProp1). }
  claim Ha2x : Rlt a2 x.
  { exact (andEL (Rlt a2 x) (Rlt x bb2) HxProp2). }
  claim Hxbb2 : Rlt x bb2.
  { exact (andER (Rlt a2 x) (Rlt x bb2) HxProp2). }
  (** choose endpoints a3 = max(a1,a2) and b3 = min(bb1,bb2) by trichotomy **)
  claim Ha1S : SNo a1.
  { exact (real_SNo a1 Ha1R). }
  claim Ha2S : SNo a2.
  { exact (real_SNo a2 Ha2R). }
  claim Hb1S : SNo bb1.
  { exact (real_SNo bb1 Hbb1R). }
  claim Hb2S : SNo bb2.
  { exact (real_SNo bb2 Hbb2R). }
  claim HxS : SNo x.
  { exact (real_SNo x HxR). }
  (** a3 and b3 are selected by case splits; proof is classical but long **)
  claim Ha1xlt : a1 < x.
  { exact (RltE_lt a1 x Ha1x). }
  claim Ha2xlt : a2 < x.
  { exact (RltE_lt a2 x Ha2x). }
  claim Hxltbb1 : x < bb1.
  { exact (RltE_lt x bb1 Hxbb1). }
  claim Hxltbb2 : x < bb2.
  { exact (RltE_lt x bb2 Hxbb2). }
  (** Decide which left endpoint is larger **)
  apply (SNoLt_trichotomy_or_impred a1 a2 Ha1S Ha2S
           (exists b3 :e R_standard_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
  - assume Ha1lt : a1 < a2.
    (** left endpoint a2 **)
    apply (SNoLt_trichotomy_or_impred bb1 bb2 Hb1S Hb2S
             (exists b3 :e R_standard_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
    + assume Hb1lt : bb1 < bb2.
      (** right endpoint bb1 **)
      set I3 := open_interval a2 bb1.
      witness I3.
      apply andI.
      * (** I3 in basis **)
        claim HI3fam : I3 :e {open_interval a2 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => open_interval a2 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a2 I3 Ha2R HI3fam).
      * apply andI.
        { (** x in I3 **)
          claim Hax : Rlt a2 x.
          { exact Ha2x. }
          claim Hxb : Rlt x bb1.
          { exact Hxbb1. }
          claim Hconj : Rlt a2 x /\ Rlt x bb1.
          { apply andI.
            - exact Hax.
            - exact Hxb. }
          exact (SepI R (fun z : set => Rlt a2 z /\ Rlt z bb1) x HxR Hconj). }
        { (** I3 subset b1  b2 **)
          let y. assume HyI3 : y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => Rlt a2 z /\ Rlt z bb1) y HyI3). }
          claim HyProp : Rlt a2 y /\ Rlt y bb1.
          { exact (SepE2 R (fun z : set => Rlt a2 z /\ Rlt z bb1) y HyI3). }
          claim Ha2y : Rlt a2 y.
          { exact (andEL (Rlt a2 y) (Rlt y bb1) HyProp). }
          claim Hybb1 : Rlt y bb1.
          { exact (andER (Rlt a2 y) (Rlt y bb1) HyProp). }
          claim HyS : SNo y.
          { exact (real_SNo y HyR). }
          claim Ha1S' : SNo a1.
          { exact Ha1S. }
          claim Ha2S' : SNo a2.
          { exact Ha2S. }
          claim Hbb1S' : SNo bb1.
          { exact Hb1S. }
          claim Hbb2S' : SNo bb2.
          { exact Hb2S. }
          claim Ha2ylt : a2 < y.
          { exact (RltE_lt a2 y Ha2y). }
          claim Hybb1lt : y < bb1.
          { exact (RltE_lt y bb1 Hybb1). }
          (** y in b2 = (a2,bb2) **)
          claim Hybb2lt : y < bb2.
          { exact (SNoLt_tra y bb1 bb2 HyS Hbb1S' Hbb2S' Hybb1lt Hb1lt). }
          claim Hybb2 : Rlt y bb2.
          { exact (RltI y bb2 HyR Hbb2R Hybb2lt). }
          claim HyIn2 : y :e open_interval a2 bb2.
          { exact (SepI R (fun z : set => Rlt a2 z /\ Rlt z bb2) y HyR (andI (Rlt a2 y) (Rlt y bb2) Ha2y Hybb2)). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq. exact HyIn2. }
          (** y in b1 = (a1,bb1) **)
          claim Ha1ylt : a1 < y.
          { exact (SNoLt_tra a1 a2 y Ha1S' Ha2S' HyS Ha1lt Ha2ylt). }
          claim Ha1y : Rlt a1 y.
          { exact (RltI a1 y Ha1R HyR Ha1ylt). }
          claim HyIn1 : y :e open_interval a1 bb1.
          { exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyR (andI (Rlt a1 y) (Rlt y bb1) Ha1y Hybb1)). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq. exact HyIn1. }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hbeq : bb1 = bb2.
      set I3 := open_interval a2 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {open_interval a2 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => open_interval a2 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a2 I3 Ha2R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a2 x /\ Rlt x bb1.
          { apply andI.
            - exact Ha2x.
            - exact Hxbb1. }
          exact (SepI R (fun z : set => Rlt a2 z /\ Rlt z bb1) x HxR Hconj). }
        { let y. assume HyI3 : y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => Rlt a2 z /\ Rlt z bb1) y HyI3). }
          claim HyProp : Rlt a2 y /\ Rlt y bb1.
          { exact (SepE2 R (fun z : set => Rlt a2 z /\ Rlt z bb1) y HyI3). }
          claim Ha2y : Rlt a2 y.
          { exact (andEL (Rlt a2 y) (Rlt y bb1) HyProp). }
          claim Hybb1 : Rlt y bb1.
          { exact (andER (Rlt a2 y) (Rlt y bb1) HyProp). }
          claim HyS : SNo y.
          { exact (real_SNo y HyR). }
          claim Ha2ylt : a2 < y.
          { exact (RltE_lt a2 y Ha2y). }
          claim Hybb1lt : y < bb1.
          { exact (RltE_lt y bb1 Hybb1). }
          (** y in b2 using bb2=bb1 **)
          claim Hybb2 : Rlt y bb2.
          { rewrite <- Hbeq. exact Hybb1. }
          claim HyIn2 : y :e open_interval a2 bb2.
          { exact (SepI R (fun z : set => Rlt a2 z /\ Rlt z bb2) y HyR (andI (Rlt a2 y) (Rlt y bb2) Ha2y Hybb2)). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq. exact HyIn2. }
          (** y in b1 using a1<a2 **)
          claim Ha1ylt : a1 < y.
          { exact (SNoLt_tra a1 a2 y Ha1S Ha2S HyS Ha1lt Ha2ylt). }
          claim Ha1y : Rlt a1 y.
          { exact (RltI a1 y Ha1R HyR Ha1ylt). }
          claim HyIn1 : y :e open_interval a1 bb1.
          { exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyR (andI (Rlt a1 y) (Rlt y bb1) Ha1y Hybb1)). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq. exact HyIn1. }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hb2lt : bb2 < bb1.
      (** right endpoint bb2 **)
      set I3 := open_interval a2 bb2.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {open_interval a2 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => open_interval a2 bb) bb2 Hbb2R). }
        exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a2 I3 Ha2R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a2 x /\ Rlt x bb2.
          { apply andI.
            - exact Ha2x.
            - exact Hxbb2. }
          exact (SepI R (fun z : set => Rlt a2 z /\ Rlt z bb2) x HxR Hconj). }
        { let y. assume HyI3 : y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => Rlt a2 z /\ Rlt z bb2) y HyI3). }
          claim HyProp : Rlt a2 y /\ Rlt y bb2.
          { exact (SepE2 R (fun z : set => Rlt a2 z /\ Rlt z bb2) y HyI3). }
          claim Ha2y : Rlt a2 y.
          { exact (andEL (Rlt a2 y) (Rlt y bb2) HyProp). }
          claim Hybb2 : Rlt y bb2.
          { exact (andER (Rlt a2 y) (Rlt y bb2) HyProp). }
          claim HyS : SNo y.
          { exact (real_SNo y HyR). }
          claim Ha2ylt : a2 < y.
          { exact (RltE_lt a2 y Ha2y). }
          claim Hybb2lt : y < bb2.
          { exact (RltE_lt y bb2 Hybb2). }
          (** y in b1 uses bb2<bb1 **)
          claim Hybb1lt : y < bb1.
          { exact (SNoLt_tra y bb2 bb1 HyS Hb2S Hb1S Hybb2lt Hb2lt). }
          claim Hybb1 : Rlt y bb1.
          { exact (RltI y bb1 HyR Hbb1R Hybb1lt). }
          claim Ha1ylt : a1 < y.
          { exact (SNoLt_tra a1 a2 y Ha1S Ha2S HyS Ha1lt Ha2ylt). }
          claim Ha1y : Rlt a1 y.
          { exact (RltI a1 y Ha1R HyR Ha1ylt). }
          claim HyIn1 : y :e open_interval a1 bb1.
          { exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyR (andI (Rlt a1 y) (Rlt y bb1) Ha1y Hybb1)). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq. exact HyIn1. }
          claim HyIn2 : y :e open_interval a2 bb2.
          { exact (SepI R (fun z : set => Rlt a2 z /\ Rlt z bb2) y HyR (andI (Rlt a2 y) (Rlt y bb2) Ha2y Hybb2)). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq. exact HyIn2. }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
  - assume Haeq : a1 = a2.
    (** left endpoint a1 **)
    apply (SNoLt_trichotomy_or_impred bb1 bb2 Hb1S Hb2S
             (exists b3 :e R_standard_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
    + assume Hb1lt : bb1 < bb2.
      set I3 := open_interval a1 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {open_interval a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => open_interval a1 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hax : Rlt a1 x.
          { exact Ha1x. }
          claim Hconj : Rlt a1 x /\ Rlt x bb1.
          { apply andI.
            - exact Hax.
            - exact Hxbb1. }
          exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) x HxR Hconj). }
        { let y. assume HyI3 : y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyI3). }
          claim HyProp : Rlt a1 y /\ Rlt y bb1.
          { exact (SepE2 R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyI3). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (Rlt y bb1) HyProp). }
          claim Hybb1 : Rlt y bb1.
          { exact (andER (Rlt a1 y) (Rlt y bb1) HyProp). }
          claim HyS : SNo y.
          { exact (real_SNo y HyR). }
          claim Hybb1lt : y < bb1.
          { exact (RltE_lt y bb1 Hybb1). }
          claim Hybb2lt : y < bb2.
          { exact (SNoLt_tra y bb1 bb2 HyS Hb1S Hb2S Hybb1lt Hb1lt). }
	          claim Hybb2 : Rlt y bb2.
	          { exact (RltI y bb2 HyR Hbb2R Hybb2lt). }
	          claim HyIn1 : y :e open_interval a1 bb1.
	          { exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyR (andI (Rlt a1 y) (Rlt y bb1) Ha1y Hybb1)). }
	          claim HyIn2 : y :e open_interval a2 bb2.
	          { rewrite <- Haeq.
	            exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb2) y HyR (andI (Rlt a1 y) (Rlt y bb2) Ha1y Hybb2)). }
	          claim Hyb1 : y :e b1.
	          { rewrite Hb1eq. exact HyIn1. }
	          claim Hyb2 : y :e b2.
	          { rewrite Hb2eq. exact HyIn2. }
	          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hbeq : bb1 = bb2.
      set I3 := open_interval a1 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {open_interval a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => open_interval a1 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ Rlt x bb1.
          { apply andI.
            - exact Ha1x.
            - exact Hxbb1. }
          exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) x HxR Hconj). }
        { let y. assume HyI3 : y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyI3). }
          claim HyProp : Rlt a1 y /\ Rlt y bb1.
          { exact (SepE2 R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyI3). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (Rlt y bb1) HyProp). }
          claim Hybb1 : Rlt y bb1.
          { exact (andER (Rlt a1 y) (Rlt y bb1) HyProp). }
          claim Hybb2 : Rlt y bb2.
          { rewrite <- Hbeq. exact Hybb1. }
	          claim HyIn1 : y :e open_interval a1 bb1.
	          { exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyR (andI (Rlt a1 y) (Rlt y bb1) Ha1y Hybb1)). }
	          claim HyIn2 : y :e open_interval a2 bb2.
	          { rewrite <- Haeq.
	            exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb2) y HyR (andI (Rlt a1 y) (Rlt y bb2) Ha1y Hybb2)). }
	          claim Hyb1 : y :e b1.
	          { rewrite Hb1eq. exact HyIn1. }
	          claim Hyb2 : y :e b2.
	          { rewrite Hb2eq. exact HyIn2. }
	          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hb2lt : bb2 < bb1.
      set I3 := open_interval a1 bb2.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {open_interval a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => open_interval a1 bb) bb2 Hbb2R). }
        exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ Rlt x bb2.
          { apply andI.
            - exact Ha1x.
            - exact Hxbb2. }
          exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb2) x HxR Hconj). }
        { let y. assume HyI3 : y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => Rlt a1 z /\ Rlt z bb2) y HyI3). }
          claim HyProp : Rlt a1 y /\ Rlt y bb2.
          { exact (SepE2 R (fun z : set => Rlt a1 z /\ Rlt z bb2) y HyI3). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (Rlt y bb2) HyProp). }
          claim Hybb2 : Rlt y bb2.
          { exact (andER (Rlt a1 y) (Rlt y bb2) HyProp). }
          claim HyS : SNo y.
          { exact (real_SNo y HyR). }
          claim Hybb2lt : y < bb2.
          { exact (RltE_lt y bb2 Hybb2). }
          claim Hybb1lt : y < bb1.
          { exact (SNoLt_tra y bb2 bb1 HyS Hb2S Hb1S Hybb2lt Hb2lt). }
          claim Hybb1 : Rlt y bb1.
          { exact (RltI y bb1 HyR Hbb1R Hybb1lt). }
	          claim HyIn1 : y :e open_interval a1 bb1.
	          { exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyR (andI (Rlt a1 y) (Rlt y bb1) Ha1y Hybb1)). }
	          claim HyIn2 : y :e open_interval a2 bb2.
	          { rewrite <- Haeq.
	            exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb2) y HyR (andI (Rlt a1 y) (Rlt y bb2) Ha1y Hybb2)). }
	          claim Hyb1 : y :e b1.
	          { rewrite Hb1eq. exact HyIn1. }
	          claim Hyb2 : y :e b2.
	          { rewrite Hb2eq. exact HyIn2. }
	          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
  - assume Ha2lt : a2 < a1.
    (** symmetric to first main case; use left endpoint a1 **)
    apply (SNoLt_trichotomy_or_impred bb1 bb2 Hb1S Hb2S
             (exists b3 :e R_standard_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
    + assume Hb1lt : bb1 < bb2.
      set I3 := open_interval a1 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {open_interval a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => open_interval a1 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ Rlt x bb1.
          { apply andI.
            - exact Ha1x.
            - exact Hxbb1. }
          exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) x HxR Hconj). }
        { let y. assume HyI3 : y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyI3). }
          claim HyProp : Rlt a1 y /\ Rlt y bb1.
          { exact (SepE2 R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyI3). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (Rlt y bb1) HyProp). }
          claim Hybb1 : Rlt y bb1.
          { exact (andER (Rlt a1 y) (Rlt y bb1) HyProp). }
          claim HyS : SNo y.
          { exact (real_SNo y HyR). }
          claim Ha1ylt : a1 < y.
          { exact (RltE_lt a1 y Ha1y). }
          claim Hybb1lt : y < bb1.
          { exact (RltE_lt y bb1 Hybb1). }
          (** y in b2: need a2<y and y<bb2 **)
          claim Ha2ylt : a2 < y.
          { exact (SNoLt_tra a2 a1 y Ha2S Ha1S HyS Ha2lt Ha1ylt). }
          claim Ha2y : Rlt a2 y.
          { exact (RltI a2 y Ha2R HyR Ha2ylt). }
          claim Hybb2lt : y < bb2.
          { exact (SNoLt_tra y bb1 bb2 HyS Hb1S Hb2S Hybb1lt Hb1lt). }
          claim Hybb2 : Rlt y bb2.
          { exact (RltI y bb2 HyR Hbb2R Hybb2lt). }
	          claim HyIn1 : y :e open_interval a1 bb1.
	          { exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyR (andI (Rlt a1 y) (Rlt y bb1) Ha1y Hybb1)). }
	          claim HyIn2 : y :e open_interval a2 bb2.
	          { exact (SepI R (fun z : set => Rlt a2 z /\ Rlt z bb2) y HyR (andI (Rlt a2 y) (Rlt y bb2) Ha2y Hybb2)). }
	          claim Hyb1 : y :e b1.
	          { rewrite Hb1eq. exact HyIn1. }
	          claim Hyb2 : y :e b2.
	          { rewrite Hb2eq. exact HyIn2. }
	          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hbeq : bb1 = bb2.
      set I3 := open_interval a1 bb2.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {open_interval a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => open_interval a1 bb) bb2 Hbb2R). }
        exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ Rlt x bb2.
          { apply andI.
            - exact Ha1x.
            - rewrite <- Hbeq.
              exact Hxbb1. }
          exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb2) x HxR Hconj). }
        { let y. assume HyI3 : y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => Rlt a1 z /\ Rlt z bb2) y HyI3). }
          claim HyProp : Rlt a1 y /\ Rlt y bb2.
          { exact (SepE2 R (fun z : set => Rlt a1 z /\ Rlt z bb2) y HyI3). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (Rlt y bb2) HyProp). }
	          claim Hybb2 : Rlt y bb2.
	          { exact (andER (Rlt a1 y) (Rlt y bb2) HyProp). }
	          claim Hybb1 : Rlt y bb1.
	          { rewrite Hbeq. exact Hybb2. }
          claim HyS : SNo y.
          { exact (real_SNo y HyR). }
          claim Ha1ylt : a1 < y.
          { exact (RltE_lt a1 y Ha1y). }
          claim Ha2ylt : a2 < y.
          { exact (SNoLt_tra a2 a1 y Ha2S Ha1S HyS Ha2lt Ha1ylt). }
          claim Ha2y : Rlt a2 y.
          { exact (RltI a2 y Ha2R HyR Ha2ylt). }
	          claim HyIn1 : y :e open_interval a1 bb1.
	          { exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyR (andI (Rlt a1 y) (Rlt y bb1) Ha1y Hybb1)). }
	          claim HyIn2 : y :e open_interval a2 bb2.
	          { exact (SepI R (fun z : set => Rlt a2 z /\ Rlt z bb2) y HyR (andI (Rlt a2 y) (Rlt y bb2) Ha2y Hybb2)). }
	          claim Hyb1 : y :e b1.
	          { rewrite Hb1eq. exact HyIn1. }
	          claim Hyb2 : y :e b2.
	          { rewrite Hb2eq. exact HyIn2. }
	          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hb2lt : bb2 < bb1.
      set I3 := open_interval a1 bb2.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {open_interval a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => open_interval a1 bb) bb2 Hbb2R). }
        exact (famunionI R (fun aa : set => {open_interval aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ Rlt x bb2.
          { apply andI.
            - exact Ha1x.
            - exact Hxbb2. }
          exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb2) x HxR Hconj). }
        { let y. assume HyI3 : y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun z : set => Rlt a1 z /\ Rlt z bb2) y HyI3). }
          claim HyProp : Rlt a1 y /\ Rlt y bb2.
          { exact (SepE2 R (fun z : set => Rlt a1 z /\ Rlt z bb2) y HyI3). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (Rlt y bb2) HyProp). }
          claim Hybb2 : Rlt y bb2.
          { exact (andER (Rlt a1 y) (Rlt y bb2) HyProp). }
          claim HyS : SNo y.
          { exact (real_SNo y HyR). }
          claim Ha1ylt : a1 < y.
          { exact (RltE_lt a1 y Ha1y). }
          claim Ha2ylt : a2 < y.
          { exact (SNoLt_tra a2 a1 y Ha2S Ha1S HyS Ha2lt Ha1ylt). }
          claim Ha2y : Rlt a2 y.
          { exact (RltI a2 y Ha2R HyR Ha2ylt). }
          claim Hybb2lt : y < bb2.
          { exact (RltE_lt y bb2 Hybb2). }
          claim Hybb1lt : y < bb1.
          { exact (SNoLt_tra y bb2 bb1 HyS Hb2S Hb1S Hybb2lt Hb2lt). }
          claim Hybb1 : Rlt y bb1.
          { exact (RltI y bb1 HyR Hbb1R Hybb1lt). }
	          claim HyIn1 : y :e open_interval a1 bb1.
	          { exact (SepI R (fun z : set => Rlt a1 z /\ Rlt z bb1) y HyR (andI (Rlt a1 y) (Rlt y bb1) Ha1y Hybb1)). }
	          claim HyIn2 : y :e open_interval a2 bb2.
	          { exact (SepI R (fun z : set => Rlt a2 z /\ Rlt z bb2) y HyR (andI (Rlt a2 y) (Rlt y bb2) Ha2y Hybb2)). }
	          claim Hyb1 : y :e b1.
	          { rewrite Hb1eq. exact HyIn1. }
	          claim Hyb2 : y :e b2.
	          { rewrite Hb2eq. exact HyIn2. }
	          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
Qed.

(** helper: any open interval is open in the standard topology **)
(** LATEX VERSION: Every interval (a,b) is open in the standard topology on . **)
Theorem open_interval_in_R_standard_topology : forall a b:set,
  Rlt a b -> open_interval a b :e R_standard_topology.
let a b. assume Hab.
claim HaR: a :e R.
{ exact (RltE_left a b Hab). }
claim HbR: b :e R.
{ exact (RltE_right a b Hab). }
claim HbFam : open_interval a b :e {open_interval a b0|b0 :e R}.
{ exact (ReplI R (fun b0:set => open_interval a b0) b HbR). }
claim HbStd : open_interval a b :e R_standard_basis.
{ exact (famunionI R (fun a0:set => {open_interval a0 b0|b0 :e R}) a (open_interval a b) HaR HbFam). }
exact (generated_topology_contains_basis R R_standard_basis R_standard_basis_is_basis_local (open_interval a b) HbStd).
Qed.

(** from 13: the standard topology on R is a topology **)
(** LATEX VERSION: The topology generated by the standard basis satisfies the topology axioms. **)
Theorem R_standard_topology_is_topology_local : topology_on R R_standard_topology.
exact (lemma_topology_from_basis R R_standard_basis R_standard_basis_is_basis_local).
Qed.

Definition R_lower_limit_basis : set :=
  \/_ a :e R, {halfopen_interval_left a b|b :e R}.

Definition R_lower_limit_topology : set :=
  generated_topology R R_lower_limit_basis.

(** from 13 Exercise 7: basis for the upper limit topology on R **)
(** LATEX VERSION: The upper limit topology on R is generated by half open intervals (a,b]. **)
Definition R_upper_limit_basis : set :=
  \/_ a :e R, {halfopen_interval_right a b|b :e R}.

(** helper: the upper limit basis is a basis on R **)
Theorem R_upper_limit_basis_is_basis_local : basis_on R R_upper_limit_basis.
prove basis_on R R_upper_limit_basis.
prove R_upper_limit_basis c= Power R
  /\ (forall x :e R, exists b :e R_upper_limit_basis, x :e b)
  /\ (forall b1 :e R_upper_limit_basis, forall b2 :e R_upper_limit_basis, forall x:set,
        x :e b1 -> x :e b2 ->
        exists b3 :e R_upper_limit_basis, x :e b3 /\ b3 c= b1 :/\: b2).
apply andI.
- apply andI.
  + (** basis elements are subsets of R **)
    let U. assume HU : U :e R_upper_limit_basis.
    prove U :e Power R.
    claim Hexa : exists a :e R, U :e {halfopen_interval_right a b|b :e R}.
    { exact (famunionE R (fun a0 : set => {halfopen_interval_right a0 b|b :e R}) U HU). }
    apply Hexa.
    let a. assume Hapair.
    claim HaR : a :e R.
    { exact (andEL (a :e R) (U :e {halfopen_interval_right a b|b :e R}) Hapair). }
    claim HUfam : U :e {halfopen_interval_right a b|b :e R}.
    { exact (andER (a :e R) (U :e {halfopen_interval_right a b|b :e R}) Hapair). }
    claim Hexb : exists b :e R, U = halfopen_interval_right a b.
    { exact (ReplE R (fun b0 : set => halfopen_interval_right a b0) U HUfam). }
    apply Hexb.
    let b. assume Hbpair.
    claim HbR : b :e R.
    { exact (andEL (b :e R) (U = halfopen_interval_right a b) Hbpair). }
    claim HUeq : U = halfopen_interval_right a b.
    { exact (andER (b :e R) (U = halfopen_interval_right a b) Hbpair). }
    rewrite HUeq.
    exact (PowerI R (halfopen_interval_right a b) (halfopen_interval_right_Subq_R a b)).
  + (** coverage: every x has a basis neighborhood (x-1,x] **)
    let x. assume HxR.
    claim Hm1R : minus_SNo 1 :e R.
    { exact (real_minus_SNo 1 real_1). }
    set a0 := add_SNo x (minus_SNo 1).
    claim Ha0R : a0 :e R.
    { exact (real_add_SNo x HxR (minus_SNo 1) Hm1R). }
    set I := halfopen_interval_right a0 x.
    witness I.
    apply andI.
    * (** I is in the upper limit basis **)
      claim HIa : I :e {halfopen_interval_right a0 bb|bb :e R}.
      { exact (ReplI R (fun bb : set => halfopen_interval_right a0 bb) x HxR). }
      exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R}) a0 I Ha0R HIa).
    * (** x is in I **)
      claim HxS : SNo x.
      { exact (real_SNo x HxR). }
      claim Hm1S : SNo (minus_SNo 1).
      { exact (SNo_minus_SNo 1 SNo_1). }
      claim Ha0ltx : a0 < x.
      { claim Hlt : add_SNo x (minus_SNo 1) < add_SNo x 0.
        { exact (add_SNo_Lt2 x (minus_SNo 1) 0 HxS Hm1S SNo_0 minus_1_lt_0). }
        rewrite <- (add_SNo_0R x HxS) at 2.
        exact Hlt. }
      claim Ha0x : Rlt a0 x.
      { exact (RltI a0 x Ha0R HxR Ha0ltx). }
      claim Hnx : ~(Rlt x x).
      { exact (not_Rlt_refl x HxR). }
      claim Hconj : Rlt a0 x /\ ~(Rlt x x).
      { apply andI.
        - exact Ha0x.
        - exact Hnx. }
      exact (SepI R (fun x0 : set => Rlt a0 x0 /\ ~(Rlt x x0)) x HxR Hconj).
- (** intersection refinement **)
  let b1. assume Hb1.
  let b2. assume Hb2.
  let x. assume Hx1 Hx2.
  (** destruct b1 and b2 as halfopen intervals (a,bb] **)
  claim Hexa1 : exists a1 :e R, b1 :e {halfopen_interval_right a1 b|b :e R}.
  { exact (famunionE R (fun a0 : set => {halfopen_interval_right a0 b|b :e R}) b1 Hb1). }
  claim Hexa2 : exists a2 :e R, b2 :e {halfopen_interval_right a2 b|b :e R}.
  { exact (famunionE R (fun a0 : set => {halfopen_interval_right a0 b|b :e R}) b2 Hb2). }
  apply Hexa1.
  let a1. assume Ha1pair.
  claim Ha1R : a1 :e R.
  { exact (andEL (a1 :e R) (b1 :e {halfopen_interval_right a1 b|b :e R}) Ha1pair). }
  claim Hb1fam : b1 :e {halfopen_interval_right a1 b|b :e R}.
  { exact (andER (a1 :e R) (b1 :e {halfopen_interval_right a1 b|b :e R}) Ha1pair). }
  claim Hexb1 : exists bb1 :e R, b1 = halfopen_interval_right a1 bb1.
  { exact (ReplE R (fun bb : set => halfopen_interval_right a1 bb) b1 Hb1fam). }
  apply Hexb1.
  let bb1. assume Hbb1pair.
  claim Hbb1R : bb1 :e R.
  { exact (andEL (bb1 :e R) (b1 = halfopen_interval_right a1 bb1) Hbb1pair). }
  claim Hb1eq : b1 = halfopen_interval_right a1 bb1.
  { exact (andER (bb1 :e R) (b1 = halfopen_interval_right a1 bb1) Hbb1pair). }
  apply Hexa2.
  let a2. assume Ha2pair.
  claim Ha2R : a2 :e R.
  { exact (andEL (a2 :e R) (b2 :e {halfopen_interval_right a2 b|b :e R}) Ha2pair). }
  claim Hb2fam : b2 :e {halfopen_interval_right a2 b|b :e R}.
  { exact (andER (a2 :e R) (b2 :e {halfopen_interval_right a2 b|b :e R}) Ha2pair). }
  claim Hexb2 : exists bb2 :e R, b2 = halfopen_interval_right a2 bb2.
  { exact (ReplE R (fun bb : set => halfopen_interval_right a2 bb) b2 Hb2fam). }
  apply Hexb2.
  let bb2. assume Hbb2pair.
  claim Hbb2R : bb2 :e R.
  { exact (andEL (bb2 :e R) (b2 = halfopen_interval_right a2 bb2) Hbb2pair). }
  claim Hb2eq : b2 = halfopen_interval_right a2 bb2.
  { exact (andER (bb2 :e R) (b2 = halfopen_interval_right a2 bb2) Hbb2pair). }
  (** extract constraints from x membership **)
  claim HxIn1 : x :e halfopen_interval_right a1 bb1.
  { rewrite <- Hb1eq. exact Hx1. }
  claim HxIn2 : x :e halfopen_interval_right a2 bb2.
  { rewrite <- Hb2eq. exact Hx2. }
  claim HxR : x :e R.
  { exact (SepE1 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) x HxIn1). }
  claim HxProp1 : Rlt a1 x /\ ~(Rlt bb1 x).
  { exact (SepE2 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) x HxIn1). }
  claim HxProp2 : Rlt a2 x /\ ~(Rlt bb2 x).
  { exact (SepE2 R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb2 x0)) x HxIn2). }
  claim Ha1x : Rlt a1 x.
  { exact (andEL (Rlt a1 x) (~(Rlt bb1 x)) HxProp1). }
  claim Hnbb1x : ~(Rlt bb1 x).
  { exact (andER (Rlt a1 x) (~(Rlt bb1 x)) HxProp1). }
  claim Ha2x : Rlt a2 x.
  { exact (andEL (Rlt a2 x) (~(Rlt bb2 x)) HxProp2). }
  claim Hnbb2x : ~(Rlt bb2 x).
  { exact (andER (Rlt a2 x) (~(Rlt bb2 x)) HxProp2). }
  claim Ha1S : SNo a1.
  { exact (real_SNo a1 Ha1R). }
  claim Ha2S : SNo a2.
  { exact (real_SNo a2 Ha2R). }
  claim Hb1S : SNo bb1.
  { exact (real_SNo bb1 Hbb1R). }
  claim Hb2S : SNo bb2.
  { exact (real_SNo bb2 Hbb2R). }
  (** choose max left endpoint and min right endpoint by trichotomy **)
  apply (SNoLt_trichotomy_or_impred a1 a2 Ha1S Ha2S
           (exists b3 :e R_upper_limit_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
  - assume Ha1lt : a1 < a2.
    claim Ha1a2 : Rlt a1 a2.
    { exact (RltI a1 a2 Ha1R Ha2R Ha1lt). }
    apply (SNoLt_trichotomy_or_impred bb1 bb2 Hb1S Hb2S
             (exists b3 :e R_upper_limit_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
    + assume Hb1lt : bb1 < bb2.
      claim Hbb1bb2 : Rlt bb1 bb2.
      { exact (RltI bb1 bb2 Hbb1R Hbb2R Hb1lt). }
      set I3 := halfopen_interval_right a2 bb1.
      witness I3.
      apply andI.
      * (** I3 is in the basis **)
        claim HI3fam : I3 :e {halfopen_interval_right a2 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_right a2 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R}) a2 I3 Ha2R HI3fam).
      * apply andI.
        { (** x in I3 **)
          claim Hconj : Rlt a2 x /\ ~(Rlt bb1 x).
          { apply andI.
            - exact Ha2x.
            - exact Hnbb1x. }
          exact (SepI R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb1 x0)) x HxR Hconj). }
        { (** I3 subset b1  b2 **)
          let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb1 x0)) y Hy). }
          claim HyProp : Rlt a2 y /\ ~(Rlt bb1 y).
          { exact (SepE2 R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb1 x0)) y Hy). }
          claim Ha2y : Rlt a2 y.
          { exact (andEL (Rlt a2 y) (~(Rlt bb1 y)) HyProp). }
          claim Hnbb1y : ~(Rlt bb1 y).
          { exact (andER (Rlt a2 y) (~(Rlt bb1 y)) HyProp). }
          claim Ha1y : Rlt a1 y.
          { exact (Rlt_tra a1 a2 y Ha1a2 Ha2y). }
          claim Hnbb2y : ~(Rlt bb2 y).
          { assume Hbb2y : Rlt bb2 y.
            claim Hbb1y : Rlt bb1 y.
            { exact (Rlt_tra bb1 bb2 y Hbb1bb2 Hbb2y). }
            exact (Hnbb1y Hbb1y). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            claim Hc1 : Rlt a1 y /\ ~(Rlt bb1 y).
            { apply andI.
              - exact Ha1y.
              - exact Hnbb1y. }
            exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y HyR Hc1). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            claim Hc2 : Rlt a2 y /\ ~(Rlt bb2 y).
            { apply andI.
              - exact Ha2y.
              - exact Hnbb2y. }
            exact (SepI R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb2 x0)) y HyR Hc2). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hbeq : bb1 = bb2.
      set I3 := halfopen_interval_right a2 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_right a2 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_right a2 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R}) a2 I3 Ha2R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a2 x /\ ~(Rlt bb1 x).
          { apply andI.
            - exact Ha2x.
            - exact Hnbb1x. }
          exact (SepI R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb1 x0)) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb1 x0)) y Hy). }
          claim HyProp : Rlt a2 y /\ ~(Rlt bb1 y).
          { exact (SepE2 R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb1 x0)) y Hy). }
          claim Ha2y : Rlt a2 y.
          { exact (andEL (Rlt a2 y) (~(Rlt bb1 y)) HyProp). }
          claim Hnbb1y : ~(Rlt bb1 y).
          { exact (andER (Rlt a2 y) (~(Rlt bb1 y)) HyProp). }
          claim Ha1y : Rlt a1 y.
          { exact (Rlt_tra a1 a2 y Ha1a2 Ha2y). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            claim Hc1 : Rlt a1 y /\ ~(Rlt bb1 y).
            { apply andI.
              - exact Ha1y.
              - exact Hnbb1y. }
            exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y HyR Hc1). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            rewrite <- Hbeq.
            claim Hc2 : Rlt a2 y /\ ~(Rlt bb1 y).
            { apply andI.
              - exact Ha2y.
              - exact Hnbb1y. }
            exact (SepI R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb1 x0)) y HyR Hc2). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hb2lt : bb2 < bb1.
      claim Hbb2bb1 : Rlt bb2 bb1.
      { exact (RltI bb2 bb1 Hbb2R Hbb1R Hb2lt). }
      set I3 := halfopen_interval_right a2 bb2.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_right a2 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_right a2 bb) bb2 Hbb2R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R}) a2 I3 Ha2R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a2 x /\ ~(Rlt bb2 x).
          { apply andI.
            - exact Ha2x.
            - exact Hnbb2x. }
          exact (SepI R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb2 x0)) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb2 x0)) y Hy). }
          claim HyProp : Rlt a2 y /\ ~(Rlt bb2 y).
          { exact (SepE2 R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb2 x0)) y Hy). }
          claim Ha2y : Rlt a2 y.
          { exact (andEL (Rlt a2 y) (~(Rlt bb2 y)) HyProp). }
          claim Hnbb2y : ~(Rlt bb2 y).
          { exact (andER (Rlt a2 y) (~(Rlt bb2 y)) HyProp). }
          claim Ha1y : Rlt a1 y.
          { exact (Rlt_tra a1 a2 y Ha1a2 Ha2y). }
          claim Hnbb1y : ~(Rlt bb1 y).
          { assume Hbb1y : Rlt bb1 y.
            claim Hbb2y : Rlt bb2 y.
            { exact (Rlt_tra bb2 bb1 y Hbb2bb1 Hbb1y). }
            exact (Hnbb2y Hbb2y). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            claim Hc1 : Rlt a1 y /\ ~(Rlt bb1 y).
            { apply andI.
              - exact Ha1y.
              - exact Hnbb1y. }
            exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y HyR Hc1). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            claim Hc2 : Rlt a2 y /\ ~(Rlt bb2 y).
            { apply andI.
              - exact Ha2y.
              - exact Hnbb2y. }
            exact (SepI R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb2 x0)) y HyR Hc2). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
  - assume Haeq : a1 = a2.
    apply (SNoLt_trichotomy_or_impred bb1 bb2 Hb1S Hb2S
             (exists b3 :e R_upper_limit_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
    + assume Hb1lt : bb1 < bb2.
      claim Hbb1bb2 : Rlt bb1 bb2.
      { exact (RltI bb1 bb2 Hbb1R Hbb2R Hb1lt). }
      set I3 := halfopen_interval_right a1 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_right a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_right a1 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ ~(Rlt bb1 x).
          { apply andI.
            - exact Ha1x.
            - exact Hnbb1x. }
          exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y Hy). }
          claim HyProp : Rlt a1 y /\ ~(Rlt bb1 y).
          { exact (SepE2 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y Hy). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (~(Rlt bb1 y)) HyProp). }
          claim Hnbb1y : ~(Rlt bb1 y).
          { exact (andER (Rlt a1 y) (~(Rlt bb1 y)) HyProp). }
          claim Hnbb2y : ~(Rlt bb2 y).
          { assume Hbb2y : Rlt bb2 y.
            claim Hbb1y : Rlt bb1 y.
            { exact (Rlt_tra bb1 bb2 y Hbb1bb2 Hbb2y). }
            exact (Hnbb1y Hbb1y). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            claim Hc1 : Rlt a1 y /\ ~(Rlt bb1 y).
            { apply andI.
              - exact Ha1y.
              - exact Hnbb1y. }
            exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y HyR Hc1). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            rewrite <- Haeq.
            claim Hc2 : Rlt a1 y /\ ~(Rlt bb2 y).
            { apply andI.
              - exact Ha1y.
              - exact Hnbb2y. }
            exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb2 x0)) y HyR Hc2). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hbeq : bb1 = bb2.
      set I3 := halfopen_interval_right a1 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_right a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_right a1 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ ~(Rlt bb1 x).
          { apply andI.
            - exact Ha1x.
            - exact Hnbb1x. }
          exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq. exact Hy. }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            rewrite <- Haeq.
            rewrite <- Hbeq.
            exact Hy. }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hb2lt : bb2 < bb1.
      claim Hbb2bb1 : Rlt bb2 bb1.
      { exact (RltI bb2 bb1 Hbb2R Hbb1R Hb2lt). }
      set I3 := halfopen_interval_right a1 bb2.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_right a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_right a1 bb) bb2 Hbb2R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ ~(Rlt bb2 x).
          { apply andI.
            - exact Ha1x.
            - exact Hnbb2x. }
          exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb2 x0)) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb2 x0)) y Hy). }
          claim HyProp : Rlt a1 y /\ ~(Rlt bb2 y).
          { exact (SepE2 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb2 x0)) y Hy). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (~(Rlt bb2 y)) HyProp). }
          claim Hnbb2y : ~(Rlt bb2 y).
          { exact (andER (Rlt a1 y) (~(Rlt bb2 y)) HyProp). }
          claim Hnbb1y : ~(Rlt bb1 y).
          { assume Hbb1y : Rlt bb1 y.
            claim Hbb2y : Rlt bb2 y.
            { exact (Rlt_tra bb2 bb1 y Hbb2bb1 Hbb1y). }
            exact (Hnbb2y Hbb2y). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            claim Hc1 : Rlt a1 y /\ ~(Rlt bb1 y).
            { apply andI.
              - exact Ha1y.
              - exact Hnbb1y. }
            exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y HyR Hc1). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            rewrite <- Haeq.
            claim Hc2 : Rlt a1 y /\ ~(Rlt bb2 y).
            { apply andI.
              - exact Ha1y.
              - exact Hnbb2y. }
            exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb2 x0)) y HyR Hc2). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
  - assume Ha2lt : a2 < a1.
    claim Ha2a1 : Rlt a2 a1.
    { exact (RltI a2 a1 Ha2R Ha1R Ha2lt). }
    apply (SNoLt_trichotomy_or_impred bb1 bb2 Hb1S Hb2S
             (exists b3 :e R_upper_limit_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
    + assume Hb1lt : bb1 < bb2.
      claim Hbb1bb2 : Rlt bb1 bb2.
      { exact (RltI bb1 bb2 Hbb1R Hbb2R Hb1lt). }
      set I3 := halfopen_interval_right a1 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_right a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_right a1 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ ~(Rlt bb1 x).
          { apply andI.
            - exact Ha1x.
            - exact Hnbb1x. }
          exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y Hy). }
          claim HyProp : Rlt a1 y /\ ~(Rlt bb1 y).
          { exact (SepE2 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y Hy). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (~(Rlt bb1 y)) HyProp). }
          claim Hnbb1y : ~(Rlt bb1 y).
          { exact (andER (Rlt a1 y) (~(Rlt bb1 y)) HyProp). }
          claim Ha2y : Rlt a2 y.
          { exact (Rlt_tra a2 a1 y Ha2a1 Ha1y). }
          claim Hnbb2y : ~(Rlt bb2 y).
          { assume Hbb2y : Rlt bb2 y.
            claim Hbb1y : Rlt bb1 y.
            { exact (Rlt_tra bb1 bb2 y Hbb1bb2 Hbb2y). }
            exact (Hnbb1y Hbb1y). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            claim Hc1 : Rlt a1 y /\ ~(Rlt bb1 y).
            { apply andI.
              - exact Ha1y.
              - exact Hnbb1y. }
            exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y HyR Hc1). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            claim Hc2 : Rlt a2 y /\ ~(Rlt bb2 y).
            { apply andI.
              - exact Ha2y.
              - exact Hnbb2y. }
            exact (SepI R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb2 x0)) y HyR Hc2). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hbeq : bb1 = bb2.
      set I3 := halfopen_interval_right a1 bb1.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_right a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_right a1 bb) bb1 Hbb1R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ ~(Rlt bb1 x).
          { apply andI.
            - exact Ha1x.
            - exact Hnbb1x. }
          exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y Hy). }
          claim HyProp : Rlt a1 y /\ ~(Rlt bb1 y).
          { exact (SepE2 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y Hy). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (~(Rlt bb1 y)) HyProp). }
          claim Hnbb1y : ~(Rlt bb1 y).
          { exact (andER (Rlt a1 y) (~(Rlt bb1 y)) HyProp). }
          claim Ha2y : Rlt a2 y.
          { exact (Rlt_tra a2 a1 y Ha2a1 Ha1y). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq. exact Hy. }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            claim Hnbb2y : ~(Rlt bb2 y).
              { assume Hbb2y : Rlt bb2 y.
                claim Hbb1y : Rlt bb1 y.
              { rewrite Hbeq at 1.
                exact Hbb2y. }
                exact (Hnbb1y Hbb1y). }
            claim Hc2 : Rlt a2 y /\ ~(Rlt bb2 y).
            { apply andI.
              - exact Ha2y.
              - exact Hnbb2y. }
            exact (SepI R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb2 x0)) y HyR Hc2). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hb2lt : bb2 < bb1.
      claim Hbb2bb1 : Rlt bb2 bb1.
      { exact (RltI bb2 bb1 Hbb2R Hbb1R Hb2lt). }
      set I3 := halfopen_interval_right a1 bb2.
      witness I3.
      apply andI.
      * claim HI3fam : I3 :e {halfopen_interval_right a1 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => halfopen_interval_right a1 bb) bb2 Hbb2R). }
        exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R}) a1 I3 Ha1R HI3fam).
      * apply andI.
        { claim Hconj : Rlt a1 x /\ ~(Rlt bb2 x).
          { apply andI.
            - exact Ha1x.
            - exact Hnbb2x. }
          exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb2 x0)) x HxR Hconj). }
        { let y. assume Hy: y :e I3.
          prove y :e b1 :/\: b2.
          claim HyR : y :e R.
          { exact (SepE1 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb2 x0)) y Hy). }
          claim HyProp : Rlt a1 y /\ ~(Rlt bb2 y).
          { exact (SepE2 R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb2 x0)) y Hy). }
          claim Ha1y : Rlt a1 y.
          { exact (andEL (Rlt a1 y) (~(Rlt bb2 y)) HyProp). }
          claim Hnbb2y : ~(Rlt bb2 y).
          { exact (andER (Rlt a1 y) (~(Rlt bb2 y)) HyProp). }
          claim Ha2y : Rlt a2 y.
          { exact (Rlt_tra a2 a1 y Ha2a1 Ha1y). }
          claim Hnbb1y : ~(Rlt bb1 y).
          { assume Hbb1y : Rlt bb1 y.
            claim Hbb2y : Rlt bb2 y.
            { exact (Rlt_tra bb2 bb1 y Hbb2bb1 Hbb1y). }
            exact (Hnbb2y Hbb2y). }
          claim Hyb1 : y :e b1.
          { rewrite Hb1eq.
            claim Hc1 : Rlt a1 y /\ ~(Rlt bb1 y).
            { apply andI.
              - exact Ha1y.
              - exact Hnbb1y. }
            exact (SepI R (fun x0 : set => Rlt a1 x0 /\ ~(Rlt bb1 x0)) y HyR Hc1). }
          claim Hyb2 : y :e b2.
          { rewrite Hb2eq.
            claim Hc2 : Rlt a2 y /\ ~(Rlt bb2 y).
            { apply andI.
              - exact Ha2y.
              - exact Hnbb2y. }
            exact (SepI R (fun x0 : set => Rlt a2 x0 /\ ~(Rlt bb2 x0)) y HyR Hc2). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
Qed.

(** from 13 Exercise 7: upper limit topology on R **)
(** LATEX VERSION: The upper limit topology is the topology generated by that basis. **)
Definition R_upper_limit_topology : set :=
  generated_topology R R_upper_limit_basis.

(** helper: the upper limit topology on R is a topology **)
Theorem R_upper_limit_topology_is_topology_local : topology_on R R_upper_limit_topology.
exact (lemma_topology_from_basis R R_upper_limit_basis R_upper_limit_basis_is_basis_local).
Qed.

(** FIXED: Now uses proper reciprocal from line 5762.
    recip_SNo computes 1/x for surreal numbers (which includes naturals).
    For n, recip_SNo n computes 1/n. **)
Definition inv_nat : set -> set := recip_SNo.

(** helper: 1/n is real for n in omega **)
Theorem inv_nat_real : forall n:set, n :e omega -> inv_nat n :e R.
let n. assume Hn: n :e omega.
prove inv_nat n :e R.
(** omega is included in SNoS_ omega, and SNoS_ omega is included in real **)
claim HnSNoS: n :e SNoS_ omega.
{ exact (omega_SNoS_omega n Hn). }
claim HnR: n :e real.
{ exact (SNoS_omega_real n HnSNoS). }
exact (real_recip_SNo n HnR).
Qed.

(** from 13 Exercise 6: the set K={1/n | n in omega and n not 0} used in the K-topology **)
(** LATEX VERSION: Let K={1/n : n in N} as a subset of R (excluding n=0). **)
Definition K_set : set := {inv_nat n|n :e omega :\: {0}}.

(** helper: 0 is not in K_set **)
Theorem zero_not_in_K_set : 0 /:e K_set.
assume H0K: 0 :e K_set.
apply (ReplE (omega :\: {0}) (fun n:set => inv_nat n) 0 H0K).
let n. assume Hnconj.
claim HnIn: n :e omega :\: {0}.
{ exact (andEL (n :e omega :\: {0}) (0 = inv_nat n) Hnconj). }
claim H0eq: 0 = inv_nat n.
{ exact (andER (n :e omega :\: {0}) (0 = inv_nat n) Hnconj). }
claim HnO: n :e omega.
{ exact (setminusE1 omega {0} n HnIn). }
claim Hnnot0: n /:e {0}.
{ exact (setminusE2 omega {0} n HnIn). }
claim HnNat: nat_p n.
{ exact (omega_nat_p n HnO). }
claim HnCase: n = 0 \/ exists k:set, nat_p k /\ n = ordsucc k.
{ exact (nat_inv n HnNat). }
claim Hexk: exists k:set, nat_p k /\ n = ordsucc k.
{ apply (HnCase (exists k:set, nat_p k /\ n = ordsucc k)).
  - assume Hn0: n = 0.
    apply FalseE.
    claim Hnin0: n :e {0}.
    { rewrite Hn0. exact (SingI 0). }
    exact (Hnnot0 Hnin0).
  - assume H. exact H. }
apply Hexk.
let k. assume Hkconj.
claim Hkeq: n = ordsucc k.
{ exact (andER (nat_p k) (n = ordsucc k) Hkconj). }
claim HkNat: nat_p k.
{ exact (andEL (nat_p k) (n = ordsucc k) Hkconj). }
claim HkOrd: ordinal k.
{ exact (nat_p_ordinal k HkNat). }
claim Hpos: 0 < n.
{ rewrite Hkeq.
  exact (ordinal_ordsucc_pos k HkOrd). }
claim HSn: SNo n.
{ exact (omega_SNo n HnO). }
claim Hposcase: inv_nat n = recip_SNo_pos n.
{ exact (recip_SNo_poscase n Hpos). }
claim HrecipPos: 0 < recip_SNo_pos n.
{ exact (recip_SNo_pos_is_pos n HSn Hpos). }
claim HinvPos: 0 < inv_nat n.
{ rewrite Hposcase.
  exact HrecipPos. }
claim H0lt0: 0 < 0.
{ rewrite H0eq at 2.
  exact HinvPos. }
exact ((SNoLt_irref 0) H0lt0).
Qed.

(** helper: K_set is a subset of R **)
Theorem K_set_Subq_R : K_set c= R.
let x. assume Hx: x :e K_set.
apply (ReplE_impred (omega :\: {0}) (fun n:set => inv_nat n) x Hx (x :e R)).
let n. assume HnIn: n :e omega :\: {0}. assume Heq: x = inv_nat n.
claim HnO: n :e omega.
{ exact (setminusE1 omega {0} n HnIn). }
rewrite Heq.
exact (inv_nat_real n HnO).
Qed.

(** helper: elements of K_set are positive reals **)
Theorem inv_nat_pos : forall n:set, n :e omega :\: {0} -> Rlt 0 (inv_nat n).
let n. assume HnIn: n :e omega :\: {0}.
claim HnO: n :e omega.
{ exact (setminusE1 omega {0} n HnIn). }
claim Hnnot0: n /:e {0}.
{ exact (setminusE2 omega {0} n HnIn). }
claim HnNat: nat_p n.
{ exact (omega_nat_p n HnO). }
claim HnCase: n = 0 \/ exists k:set, nat_p k /\ n = ordsucc k.
{ exact (nat_inv n HnNat). }
claim Hexk: exists k:set, nat_p k /\ n = ordsucc k.
{ apply (HnCase (exists k:set, nat_p k /\ n = ordsucc k)).
  - assume Hn0: n = 0.
    apply FalseE.
    claim Hnin0: n :e {0}.
    { rewrite Hn0. exact (SingI 0). }
    exact (Hnnot0 Hnin0).
  - assume H. exact H. }
apply Hexk.
let k. assume Hkconj.
claim Hkeq: n = ordsucc k.
{ exact (andER (nat_p k) (n = ordsucc k) Hkconj). }
claim HkNat: nat_p k.
{ exact (andEL (nat_p k) (n = ordsucc k) Hkconj). }
claim HkOrd: ordinal k.
{ exact (nat_p_ordinal k HkNat). }
claim Hpos: 0 < n.
{ rewrite Hkeq.
  exact (ordinal_ordsucc_pos k HkOrd). }
claim HSn: SNo n.
{ exact (omega_SNo n HnO). }
claim Hposcase: inv_nat n = recip_SNo_pos n.
{ exact (recip_SNo_poscase n Hpos). }
claim HrecipPos: 0 < recip_SNo_pos n.
{ exact (recip_SNo_pos_is_pos n HSn Hpos). }
claim HinvPos: 0 < inv_nat n.
{ rewrite Hposcase.
  exact HrecipPos. }
claim HinvR: inv_nat n :e R.
{ exact (inv_nat_real n HnO). }
exact (RltI 0 (inv_nat n) real_0 HinvR HinvPos).
Qed.

Definition R_K_basis : set :=
  \/_ a :e R, {open_interval a b :\: K_set|b :e R}.

Definition R_K_topology : set :=
  generated_topology R (R_standard_basis :\/: R_K_basis).

(** helper: the K topology basis is a basis on R **)
Theorem R_standard_plus_K_basis_is_basis_local : basis_on R (R_standard_basis :\/: R_K_basis).
prove basis_on R (R_standard_basis :\/: R_K_basis).
prove (R_standard_basis :\/: R_K_basis) c= Power R
  /\ (forall x :e R, exists b :e (R_standard_basis :\/: R_K_basis), x :e b)
  /\ (forall b1 :e (R_standard_basis :\/: R_K_basis), forall b2 :e (R_standard_basis :\/: R_K_basis), forall x:set,
        x :e b1 -> x :e b2 ->
        exists b3 :e (R_standard_basis :\/: R_K_basis), x :e b3 /\ b3 c= b1 :/\: b2).
apply andI.
- apply andI.
  + (** basis elements are subsets of R **)
    let U. assume HU: U :e (R_standard_basis :\/: R_K_basis).
    apply (binunionE' R_standard_basis R_K_basis U (U :e Power R)).
    - (** U from standard basis **)
      assume HUstd: U :e R_standard_basis.
      claim HUsubR: U c= R.
      { exact (basis_elem_subset R R_standard_basis U R_standard_basis_is_basis_local HUstd). }
      exact (PowerI R U HUsubR).
    - (** U from K basis **)
      assume HUk: U :e R_K_basis.
      claim Hexa : exists a :e R, U :e {open_interval a b :\: K_set|b :e R}.
      { exact (famunionE R (fun a0 : set => {open_interval a0 b :\: K_set|b :e R}) U HUk). }
      apply Hexa.
      let a. assume Hapair.
      claim HaR: a :e R.
      { exact (andEL (a :e R) (U :e {open_interval a b :\: K_set|b :e R}) Hapair). }
      claim HUfam: U :e {open_interval a b :\: K_set|b :e R}.
      { exact (andER (a :e R) (U :e {open_interval a b :\: K_set|b :e R}) Hapair). }
      claim Hexb: exists b :e R, U = open_interval a b :\: K_set.
      { exact (ReplE R (fun b0 : set => open_interval a b0 :\: K_set) U HUfam). }
      apply Hexb.
      let b. assume Hbpair.
      claim HbR: b :e R.
      { exact (andEL (b :e R) (U = open_interval a b :\: K_set) Hbpair). }
      claim HUeq: U = open_interval a b :\: K_set.
      { exact (andER (b :e R) (U = open_interval a b :\: K_set) Hbpair). }
      rewrite HUeq.
      claim Hsub1: (open_interval a b :\: K_set) c= open_interval a b.
      { exact (setminus_Subq (open_interval a b) K_set). }
      claim Hsub2: open_interval a b c= R.
      { exact (open_interval_Subq_R a b). }
      exact (PowerI R (open_interval a b :\: K_set) (Subq_tra (open_interval a b :\: K_set) (open_interval a b) R Hsub1 Hsub2)).
    - exact HU.
  + (** coverage: inherit from standard basis **)
    let x. assume HxR: x :e R.
    claim Hcov: forall x0 :e R, exists b :e R_standard_basis, x0 :e b.
    { exact (andER (R_standard_basis c= Power R)
                   (forall x0 :e R, exists b :e R_standard_basis, x0 :e b)
                   (andEL (R_standard_basis c= Power R /\
                           (forall x0 :e R, exists b :e R_standard_basis, x0 :e b))
                          (forall b1 :e R_standard_basis, forall b2 :e R_standard_basis, forall x0:set,
                            x0 :e b1 -> x0 :e b2 ->
                            exists b3 :e R_standard_basis, x0 :e b3 /\ b3 c= b1 :/\: b2)
                          R_standard_basis_is_basis_local)). }
    claim Hex: exists b :e R_standard_basis, x :e b.
    { exact (Hcov x HxR). }
    apply Hex.
    let b. assume Hbpair.
    witness b.
    apply andI.
    * exact (binunionI1 R_standard_basis R_K_basis b (andEL (b :e R_standard_basis) (x :e b) Hbpair)).
    * exact (andER (b :e R_standard_basis) (x :e b) Hbpair).
- (** intersection refinement **)
  let b1. assume Hb1.
  let b2. assume Hb2.
  let x. assume Hx1 Hx2.
  prove exists b3 :e (R_standard_basis :\/: R_K_basis), x :e b3 /\ b3 c= b1 :/\: b2.
  claim HstdInt:
    forall u1 :e R_standard_basis, forall u2 :e R_standard_basis, forall x0:set,
      x0 :e u1 -> x0 :e u2 ->
      exists u3 :e R_standard_basis, x0 :e u3 /\ u3 c= u1 :/\: u2.
  { exact (andER (R_standard_basis c= Power R /\ (forall x0 :e R, exists b :e R_standard_basis, x0 :e b))
                 (forall u1 :e R_standard_basis, forall u2 :e R_standard_basis, forall x0:set,
                   x0 :e u1 -> x0 :e u2 ->
                   exists u3 :e R_standard_basis, x0 :e u3 /\ u3 c= u1 :/\: u2)
                 R_standard_basis_is_basis_local). }
  apply (binunionE' R_standard_basis R_K_basis b1 (exists b3 :e (R_standard_basis :\/: R_K_basis), x :e b3 /\ b3 c= b1 :/\: b2)).
  - assume Hb1Std: b1 :e R_standard_basis.
    apply (binunionE' R_standard_basis R_K_basis b2 (exists b3 :e (R_standard_basis :\/: R_K_basis), x :e b3 /\ b3 c= b1 :/\: b2)).
    + assume Hb2Std: b2 :e R_standard_basis.
      apply (HstdInt b1 Hb1Std b2 Hb2Std x Hx1 Hx2).
      let b3std. assume Hb3pair.
      witness b3std.
      apply andI.
      * exact (binunionI1 R_standard_basis R_K_basis b3std (andEL (b3std :e R_standard_basis) (x :e b3std /\ b3std c= b1 :/\: b2) Hb3pair)).
      * exact (andER (b3std :e R_standard_basis) (x :e b3std /\ b3std c= b1 :/\: b2) Hb3pair).
    + assume Hb2K: b2 :e R_K_basis.
      (** destruct b2 = open_interval a2 bb2 \\ K_set **)
      claim Hexa2 : exists a2 :e R, b2 :e {open_interval a2 b :\: K_set|b :e R}.
      { exact (famunionE R (fun a0 : set => {open_interval a0 b :\: K_set|b :e R}) b2 Hb2K). }
      apply Hexa2.
      let a2. assume Ha2pair.
      claim Ha2R : a2 :e R.
      { exact (andEL (a2 :e R) (b2 :e {open_interval a2 b :\: K_set|b :e R}) Ha2pair). }
      claim Hb2fam : b2 :e {open_interval a2 b :\: K_set|b :e R}.
      { exact (andER (a2 :e R) (b2 :e {open_interval a2 b :\: K_set|b :e R}) Ha2pair). }
      claim Hexb2 : exists bb2 :e R, b2 = open_interval a2 bb2 :\: K_set.
      { exact (ReplE R (fun bb : set => open_interval a2 bb :\: K_set) b2 Hb2fam). }
      apply Hexb2.
      let bb2. assume Hbb2pair.
      claim Hbb2R : bb2 :e R.
      { exact (andEL (bb2 :e R) (b2 = open_interval a2 bb2 :\: K_set) Hbb2pair). }
      claim Hb2eq : b2 = open_interval a2 bb2 :\: K_set.
      { exact (andER (bb2 :e R) (b2 = open_interval a2 bb2 :\: K_set) Hbb2pair). }
      set I2 := open_interval a2 bb2.
      claim HI2Std: I2 :e R_standard_basis.
      { claim HI2fam : I2 :e {open_interval a2 b|b :e R}.
        { exact (ReplI R (fun b0 : set => open_interval a2 b0) bb2 Hbb2R). }
        exact (famunionI R (fun a0 : set => {open_interval a0 b|b :e R}) a2 I2 Ha2R HI2fam). }
      claim HxInB2: x :e I2 :\: K_set.
      { rewrite <- Hb2eq.
        exact Hx2. }
      claim HxInI2: x :e I2.
      { exact (setminusE1 I2 K_set x HxInB2). }
      claim HxNotK: x /:e K_set.
      { exact (setminusE2 I2 K_set x HxInB2). }
      apply (HstdInt b1 Hb1Std I2 HI2Std x Hx1 HxInI2).
      let I0. assume HI0pair.
      claim HI0Std: I0 :e R_standard_basis.
      { exact (andEL (I0 :e R_standard_basis) (x :e I0 /\ I0 c= b1 :/\: I2) HI0pair). }
      claim HI0rest: x :e I0 /\ I0 c= b1 :/\: I2.
      { exact (andER (I0 :e R_standard_basis) (x :e I0 /\ I0 c= b1 :/\: I2) HI0pair). }
      claim HxI0: x :e I0.
      { exact (andEL (x :e I0) (I0 c= b1 :/\: I2) HI0rest). }
      claim HI0sub: I0 c= b1 :/\: I2.
      { exact (andER (x :e I0) (I0 c= b1 :/\: I2) HI0rest). }
      (** destruct I0 = open_interval c d **)
      claim Hexc : exists c :e R, I0 :e {open_interval c b|b :e R}.
      { exact (famunionE R (fun c0 : set => {open_interval c0 b|b :e R}) I0 HI0Std). }
      apply Hexc.
      let c. assume Hcpair.
      claim HcR: c :e R.
      { exact (andEL (c :e R) (I0 :e {open_interval c b|b :e R}) Hcpair). }
      claim HI0fam: I0 :e {open_interval c b|b :e R}.
      { exact (andER (c :e R) (I0 :e {open_interval c b|b :e R}) Hcpair). }
      claim Hexd : exists d :e R, I0 = open_interval c d.
      { exact (ReplE R (fun d0 : set => open_interval c d0) I0 HI0fam). }
      apply Hexd.
      let d. assume Hdpair.
      claim HdR: d :e R.
      { exact (andEL (d :e R) (I0 = open_interval c d) Hdpair). }
      claim HI0eq: I0 = open_interval c d.
      { exact (andER (d :e R) (I0 = open_interval c d) Hdpair). }
      set Kint := open_interval c d :\: K_set.
      witness Kint.
      apply andI.
      * (** Kint is in the union basis via the K basis **)
        claim HKfam : Kint :e {open_interval c b :\: K_set|b :e R}.
        { exact (ReplI R (fun b0 : set => open_interval c b0 :\: K_set) d HdR). }
        claim HKinK : Kint :e R_K_basis.
        { exact (famunionI R (fun a0 : set => {open_interval a0 b :\: K_set|b :e R}) c Kint HcR HKfam). }
        exact (binunionI2 R_standard_basis R_K_basis Kint HKinK).
      * apply andI.
        { (** x in Kint **)
          prove x :e open_interval c d :\: K_set.
          apply setminusI.
          - prove x :e open_interval c d.
            rewrite <- HI0eq.
            exact HxI0.
          - exact HxNotK. }
        { (** subset property **)
          let y. assume Hy: y :e Kint.
          prove y :e b1 :/\: b2.
          claim HyOpen: y :e open_interval c d.
          { exact (setminusE1 (open_interval c d) K_set y Hy). }
          claim HyI0: y :e I0.
          { rewrite HI0eq.
            exact HyOpen. }
          claim HyNotK: y /:e K_set.
          { exact (setminusE2 (open_interval c d) K_set y Hy). }
          claim Hyb1I2: y :e b1 :/\: I2.
          { exact (HI0sub y HyI0). }
          claim Hyb1: y :e b1.
          { exact (binintersectE1 b1 I2 y Hyb1I2). }
          claim HyI2: y :e I2.
          { exact (binintersectE2 b1 I2 y Hyb1I2). }
          claim Hyb2: y :e b2.
          { rewrite Hb2eq.
            exact (setminusI I2 K_set y HyI2 HyNotK). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + exact Hb2.
  - assume Hb1K: b1 :e R_K_basis.
    apply (binunionE' R_standard_basis R_K_basis b2 (exists b3 :e (R_standard_basis :\/: R_K_basis), x :e b3 /\ b3 c= b1 :/\: b2)).
    + assume Hb2Std: b2 :e R_standard_basis.
      (** symmetric to the previous mixed case **)
      claim Hexa1 : exists a1 :e R, b1 :e {open_interval a1 b :\: K_set|b :e R}.
      { exact (famunionE R (fun a0 : set => {open_interval a0 b :\: K_set|b :e R}) b1 Hb1K). }
      apply Hexa1.
      let a1. assume Ha1pair.
      claim Ha1R : a1 :e R.
      { exact (andEL (a1 :e R) (b1 :e {open_interval a1 b :\: K_set|b :e R}) Ha1pair). }
      claim Hb1fam : b1 :e {open_interval a1 b :\: K_set|b :e R}.
      { exact (andER (a1 :e R) (b1 :e {open_interval a1 b :\: K_set|b :e R}) Ha1pair). }
      claim Hexb1 : exists bb1 :e R, b1 = open_interval a1 bb1 :\: K_set.
      { exact (ReplE R (fun bb : set => open_interval a1 bb :\: K_set) b1 Hb1fam). }
      apply Hexb1.
      let bb1. assume Hbb1pair.
      claim Hbb1R : bb1 :e R.
      { exact (andEL (bb1 :e R) (b1 = open_interval a1 bb1 :\: K_set) Hbb1pair). }
      claim Hb1eq : b1 = open_interval a1 bb1 :\: K_set.
      { exact (andER (bb1 :e R) (b1 = open_interval a1 bb1 :\: K_set) Hbb1pair). }
      set I1 := open_interval a1 bb1.
      claim HI1Std: I1 :e R_standard_basis.
      { claim HI1fam : I1 :e {open_interval a1 b|b :e R}.
        { exact (ReplI R (fun b0 : set => open_interval a1 b0) bb1 Hbb1R). }
        exact (famunionI R (fun a0 : set => {open_interval a0 b|b :e R}) a1 I1 Ha1R HI1fam). }
      claim HxInB1: x :e I1 :\: K_set.
      { rewrite <- Hb1eq.
        exact Hx1. }
      claim HxInI1: x :e I1.
      { exact (setminusE1 I1 K_set x HxInB1). }
      claim HxNotK: x /:e K_set.
      { exact (setminusE2 I1 K_set x HxInB1). }
      apply (HstdInt I1 HI1Std b2 Hb2Std x HxInI1 Hx2).
      let I0. assume HI0pair.
      claim HI0Std: I0 :e R_standard_basis.
      { exact (andEL (I0 :e R_standard_basis) (x :e I0 /\ I0 c= I1 :/\: b2) HI0pair). }
      claim HI0rest: x :e I0 /\ I0 c= I1 :/\: b2.
      { exact (andER (I0 :e R_standard_basis) (x :e I0 /\ I0 c= I1 :/\: b2) HI0pair). }
      claim HxI0: x :e I0.
      { exact (andEL (x :e I0) (I0 c= I1 :/\: b2) HI0rest). }
      claim HI0sub: I0 c= I1 :/\: b2.
      { exact (andER (x :e I0) (I0 c= I1 :/\: b2) HI0rest). }
      claim Hexc : exists c :e R, I0 :e {open_interval c b|b :e R}.
      { exact (famunionE R (fun c0 : set => {open_interval c0 b|b :e R}) I0 HI0Std). }
      apply Hexc.
      let c. assume Hcpair.
      claim HcR: c :e R.
      { exact (andEL (c :e R) (I0 :e {open_interval c b|b :e R}) Hcpair). }
      claim HI0fam: I0 :e {open_interval c b|b :e R}.
      { exact (andER (c :e R) (I0 :e {open_interval c b|b :e R}) Hcpair). }
      claim Hexd : exists d :e R, I0 = open_interval c d.
      { exact (ReplE R (fun d0 : set => open_interval c d0) I0 HI0fam). }
      apply Hexd.
      let d. assume Hdpair.
      claim HdR: d :e R.
      { exact (andEL (d :e R) (I0 = open_interval c d) Hdpair). }
      claim HI0eq: I0 = open_interval c d.
      { exact (andER (d :e R) (I0 = open_interval c d) Hdpair). }
      set Kint := open_interval c d :\: K_set.
      witness Kint.
      apply andI.
      * claim HKfam : Kint :e {open_interval c b :\: K_set|b :e R}.
        { exact (ReplI R (fun b0 : set => open_interval c b0 :\: K_set) d HdR). }
        claim HKinK : Kint :e R_K_basis.
        { exact (famunionI R (fun a0 : set => {open_interval a0 b :\: K_set|b :e R}) c Kint HcR HKfam). }
        exact (binunionI2 R_standard_basis R_K_basis Kint HKinK).
      * apply andI.
        { prove x :e open_interval c d :\: K_set.
          apply setminusI.
          - prove x :e open_interval c d.
            rewrite <- HI0eq.
            exact HxI0.
          - exact HxNotK. }
        { let y. assume Hy: y :e Kint.
          prove y :e b1 :/\: b2.
          claim HyOpen: y :e open_interval c d.
          { exact (setminusE1 (open_interval c d) K_set y Hy). }
          claim HyI0: y :e I0.
          { rewrite HI0eq.
            exact HyOpen. }
          claim HyNotK: y /:e K_set.
          { exact (setminusE2 (open_interval c d) K_set y Hy). }
          claim HyI1b2: y :e I1 :/\: b2.
          { exact (HI0sub y HyI0). }
          claim HyI1: y :e I1.
          { exact (binintersectE1 I1 b2 y HyI1b2). }
          claim Hyb2: y :e b2.
          { exact (binintersectE2 I1 b2 y HyI1b2). }
          claim Hyb1: y :e b1.
          { rewrite Hb1eq.
            exact (setminusI I1 K_set y HyI1 HyNotK). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + assume Hb2K: b2 :e R_K_basis.
      (** both K basis elements; refine using their open-interval parts **)
      claim Hexa1 : exists a1 :e R, b1 :e {open_interval a1 b :\: K_set|b :e R}.
      { exact (famunionE R (fun a0 : set => {open_interval a0 b :\: K_set|b :e R}) b1 Hb1K). }
      claim Hexa2 : exists a2 :e R, b2 :e {open_interval a2 b :\: K_set|b :e R}.
      { exact (famunionE R (fun a0 : set => {open_interval a0 b :\: K_set|b :e R}) b2 Hb2K). }
      apply Hexa1.
      let a1. assume Ha1pair.
      claim Ha1R : a1 :e R.
      { exact (andEL (a1 :e R) (b1 :e {open_interval a1 b :\: K_set|b :e R}) Ha1pair). }
      claim Hb1fam : b1 :e {open_interval a1 b :\: K_set|b :e R}.
      { exact (andER (a1 :e R) (b1 :e {open_interval a1 b :\: K_set|b :e R}) Ha1pair). }
      claim Hexb1 : exists bb1 :e R, b1 = open_interval a1 bb1 :\: K_set.
      { exact (ReplE R (fun bb : set => open_interval a1 bb :\: K_set) b1 Hb1fam). }
      apply Hexb1.
      let bb1. assume Hbb1pair.
      claim Hbb1R : bb1 :e R.
      { exact (andEL (bb1 :e R) (b1 = open_interval a1 bb1 :\: K_set) Hbb1pair). }
      claim Hb1eq : b1 = open_interval a1 bb1 :\: K_set.
      { exact (andER (bb1 :e R) (b1 = open_interval a1 bb1 :\: K_set) Hbb1pair). }
      apply Hexa2.
      let a2. assume Ha2pair.
      claim Ha2R : a2 :e R.
      { exact (andEL (a2 :e R) (b2 :e {open_interval a2 b :\: K_set|b :e R}) Ha2pair). }
      claim Hb2fam : b2 :e {open_interval a2 b :\: K_set|b :e R}.
      { exact (andER (a2 :e R) (b2 :e {open_interval a2 b :\: K_set|b :e R}) Ha2pair). }
      claim Hexb2 : exists bb2 :e R, b2 = open_interval a2 bb2 :\: K_set.
      { exact (ReplE R (fun bb : set => open_interval a2 bb :\: K_set) b2 Hb2fam). }
      apply Hexb2.
      let bb2. assume Hbb2pair.
      claim Hbb2R : bb2 :e R.
      { exact (andEL (bb2 :e R) (b2 = open_interval a2 bb2 :\: K_set) Hbb2pair). }
      claim Hb2eq : b2 = open_interval a2 bb2 :\: K_set.
      { exact (andER (bb2 :e R) (b2 = open_interval a2 bb2 :\: K_set) Hbb2pair). }
      set I1 := open_interval a1 bb1.
      set I2 := open_interval a2 bb2.
      claim HI1Std: I1 :e R_standard_basis.
      { claim HI1fam : I1 :e {open_interval a1 b|b :e R}.
        { exact (ReplI R (fun b0 : set => open_interval a1 b0) bb1 Hbb1R). }
        exact (famunionI R (fun a0 : set => {open_interval a0 b|b :e R}) a1 I1 Ha1R HI1fam). }
      claim HI2Std: I2 :e R_standard_basis.
      { claim HI2fam : I2 :e {open_interval a2 b|b :e R}.
        { exact (ReplI R (fun b0 : set => open_interval a2 b0) bb2 Hbb2R). }
        exact (famunionI R (fun a0 : set => {open_interval a0 b|b :e R}) a2 I2 Ha2R HI2fam). }
      claim HxInB1: x :e I1 :\: K_set.
      { rewrite <- Hb1eq.
        exact Hx1. }
      claim HxInB2: x :e I2 :\: K_set.
      { rewrite <- Hb2eq.
        exact Hx2. }
      claim HxInI1: x :e I1.
      { exact (setminusE1 I1 K_set x HxInB1). }
      claim HxInI2: x :e I2.
      { exact (setminusE1 I2 K_set x HxInB2). }
      claim HxNotK: x /:e K_set.
      { exact (setminusE2 I1 K_set x HxInB1). }
      apply (HstdInt I1 HI1Std I2 HI2Std x HxInI1 HxInI2).
      let I0. assume HI0pair.
      claim HI0Std: I0 :e R_standard_basis.
      { exact (andEL (I0 :e R_standard_basis) (x :e I0 /\ I0 c= I1 :/\: I2) HI0pair). }
      claim HI0rest: x :e I0 /\ I0 c= I1 :/\: I2.
      { exact (andER (I0 :e R_standard_basis) (x :e I0 /\ I0 c= I1 :/\: I2) HI0pair). }
      claim HxI0: x :e I0.
      { exact (andEL (x :e I0) (I0 c= I1 :/\: I2) HI0rest). }
      claim HI0sub: I0 c= I1 :/\: I2.
      { exact (andER (x :e I0) (I0 c= I1 :/\: I2) HI0rest). }
      claim Hexc : exists c :e R, I0 :e {open_interval c b|b :e R}.
      { exact (famunionE R (fun c0 : set => {open_interval c0 b|b :e R}) I0 HI0Std). }
      apply Hexc.
      let c. assume Hcpair.
      claim HcR: c :e R.
      { exact (andEL (c :e R) (I0 :e {open_interval c b|b :e R}) Hcpair). }
      claim HI0fam: I0 :e {open_interval c b|b :e R}.
      { exact (andER (c :e R) (I0 :e {open_interval c b|b :e R}) Hcpair). }
      claim Hexd : exists d :e R, I0 = open_interval c d.
      { exact (ReplE R (fun d0 : set => open_interval c d0) I0 HI0fam). }
      apply Hexd.
      let d. assume Hdpair.
      claim HdR: d :e R.
      { exact (andEL (d :e R) (I0 = open_interval c d) Hdpair). }
      claim HI0eq: I0 = open_interval c d.
      { exact (andER (d :e R) (I0 = open_interval c d) Hdpair). }
      set Kint := open_interval c d :\: K_set.
      witness Kint.
      apply andI.
      * claim HKfam : Kint :e {open_interval c b :\: K_set|b :e R}.
        { exact (ReplI R (fun b0 : set => open_interval c b0 :\: K_set) d HdR). }
        claim HKinK : Kint :e R_K_basis.
        { exact (famunionI R (fun a0 : set => {open_interval a0 b :\: K_set|b :e R}) c Kint HcR HKfam). }
        exact (binunionI2 R_standard_basis R_K_basis Kint HKinK).
      * apply andI.
        { prove x :e open_interval c d :\: K_set.
          apply setminusI.
          - prove x :e open_interval c d.
            rewrite <- HI0eq.
            exact HxI0.
          - exact HxNotK. }
        { let y. assume Hy: y :e Kint.
          prove y :e b1 :/\: b2.
          claim HyOpen: y :e open_interval c d.
          { exact (setminusE1 (open_interval c d) K_set y Hy). }
          claim HyI0: y :e I0.
          { rewrite HI0eq.
            exact HyOpen. }
          claim HyNotK: y /:e K_set.
          { exact (setminusE2 (open_interval c d) K_set y Hy). }
          claim HyI1I2: y :e I1 :/\: I2.
          { exact (HI0sub y HyI0). }
          claim HyI1: y :e I1.
          { exact (binintersectE1 I1 I2 y HyI1I2). }
          claim HyI2: y :e I2.
          { exact (binintersectE2 I1 I2 y HyI1I2). }
          claim Hyb1: y :e b1.
          { rewrite Hb1eq.
            exact (setminusI I1 K_set y HyI1 HyNotK). }
          claim Hyb2: y :e b2.
          { rewrite Hb2eq.
            exact (setminusI I2 K_set y HyI2 HyNotK). }
          exact (binintersectI b1 b2 y Hyb1 Hyb2). }
    + exact Hb2.
  - exact Hb1.
Qed.

(** helper: the K topology on R is a topology **)
Theorem R_K_topology_is_topology_local : topology_on R R_K_topology.
exact (lemma_topology_from_basis R (R_standard_basis :\/: R_K_basis) R_standard_plus_K_basis_is_basis_local).
Qed.

(** helper: K_set meets any lower limit neighborhood of 0 **)
(** LATEX VERSION: In the lower limit topology, every basic neighborhood [a,b) of 0 contains some element of K={1/n}. **)
Theorem K_set_meets_lower_limit_neighborhood_0 :
  forall a b:set,
    a :e R -> b :e R ->
    ~(Rlt 0 a) ->
    Rlt 0 b ->
    exists y:set, y :e halfopen_interval_left a b /\ y :e K_set.
let a b.
assume HaR: a :e R.
assume HbR: b :e R.
assume Hnot0a: ~(Rlt 0 a).
assume H0b: Rlt 0 b.
set r := recip_SNo b.
claim HbS: SNo b.
{ exact (real_SNo b HbR). }
claim H0ltb: 0 < b.
{ exact (RltE_lt 0 b H0b). }
claim Hbne0: b <> 0.
{ assume Hb0: b = 0.
  claim H00: 0 < 0.
  { rewrite <- Hb0 at 2.
    exact H0ltb. }
  exact ((SNoLt_irref 0) H00). }
claim HrS: SNo r.
{ exact (SNo_recip_SNo b HbS). }
claim HrR: r :e R.
{ exact (real_recip_SNo b HbR). }
claim Hrpos: 0 < r.
{ exact (recip_SNo_of_pos_is_pos b HbS H0ltb). }
claim Hrnonneg: 0 <= r.
{ exact (SNoLtLe 0 r Hrpos). }
claim Hexn: exists n :e omega, n <= r /\ r < ordsucc n.
{ exact (nonneg_real_nat_interval r HrR Hrnonneg). }
apply Hexn.
let n.
assume Hnpair: n :e omega /\ (n <= r /\ r < ordsucc n).
claim HnOmega: n :e omega.
{ exact (andEL (n :e omega) (n <= r /\ r < ordsucc n) Hnpair). }
claim Hnrest: n <= r /\ r < ordsucc n.
{ exact (andER (n :e omega) (n <= r /\ r < ordsucc n) Hnpair). }
claim HrltN: r < ordsucc n.
{ exact (andER (n <= r) (r < ordsucc n) Hnrest). }
set N := ordsucc n.
claim HNOmega: N :e omega.
{ exact (omega_ordsucc n HnOmega). }
claim HnNat: nat_p n.
{ exact (omega_nat_p n HnOmega). }
claim HnOrd: ordinal n.
{ exact (nat_p_ordinal n HnNat). }
claim H0ltN: 0 < N.
{ exact (ordinal_ordsucc_pos n HnOrd). }
claim HNS: SNo N.
{ exact (omega_SNo N HNOmega). }
claim Hineq: mul_SNo b r < mul_SNo b N.
{ exact (pos_mul_SNo_Lt b r N HbS H0ltb HrS HNS HrltN). }
claim Hbr1: mul_SNo b r = 1.
{ exact (recip_SNo_invR b HbS Hbne0). }
claim H1ltbN: 1 < mul_SNo b N.
{ rewrite <- Hbr1.
  exact Hineq. }
claim HinvLt: div_SNo 1 N < b.
{ exact (div_SNo_pos_LtL 1 N b SNo_1 HNS (real_SNo b HbR) H0ltN H1ltbN). }
claim HinvEq: div_SNo 1 N = inv_nat N.
{ prove div_SNo 1 N = inv_nat N.
  claim Hdivdef: div_SNo 1 N = mul_SNo 1 (recip_SNo N).
  { reflexivity. }
  claim Hinvdef: inv_nat N = recip_SNo N.
  { reflexivity. }
  rewrite Hdivdef.
  rewrite Hinvdef at 2.
  rewrite (mul_SNo_oneL (recip_SNo N) (SNo_recip_SNo N HNS)).
  reflexivity. }
claim Hyltb: inv_nat N < b.
{ rewrite <- HinvEq.
  exact HinvLt. }
claim HyR: inv_nat N :e R.
{ exact (inv_nat_real N HNOmega). }
claim HyRltb: Rlt (inv_nat N) b.
{ exact (RltI (inv_nat N) b HyR HbR Hyltb). }
claim HNnot0: N /:e {0}.
{ assume HNin: N :e {0}.
  claim HNeq0: N = 0.
  { exact (SingE 0 N HNin). }
  claim H00: 0 < 0.
  { rewrite <- HNeq0 at 2.
    exact H0ltN. }
  exact ((SNoLt_irref 0) H00). }
claim HNinSetminus: N :e omega :\: {0}.
{ apply setminusI.
  - exact HNOmega.
  - exact HNnot0. }
claim HyK: inv_nat N :e K_set.
{ exact (ReplI (omega :\: {0}) (fun m:set => inv_nat m) N HNinSetminus). }
claim Hypos: Rlt 0 (inv_nat N).
{ exact (inv_nat_pos N HNinSetminus). }
claim HnotHyLta: ~(Rlt (inv_nat N) a).
{ assume Hylta: Rlt (inv_nat N) a.
  claim H0lta: Rlt 0 a.
  { exact (Rlt_tra 0 (inv_nat N) a Hypos Hylta). }
  exact (Hnot0a H0lta). }
witness (inv_nat N).
apply andI.
- prove inv_nat N :e halfopen_interval_left a b.
  exact (SepI R (fun x0:set => ~(Rlt x0 a) /\ Rlt x0 b) (inv_nat N) HyR
          (andI (~(Rlt (inv_nat N) a)) (Rlt (inv_nat N) b) HnotHyLta HyRltb)).
- exact HyK.
Qed.

(** LATEX VERSION: Exercise 6: The lower-limit topology and the K-topology on  are incomparable. **)
Theorem ex13_6_Rl_RK_not_comparable :
  ~finer_than R_lower_limit_topology R_K_topology /\
  ~finer_than R_K_topology R_lower_limit_topology.
prove ~finer_than R_lower_limit_topology R_K_topology /\ ~finer_than R_K_topology R_lower_limit_topology.
apply andI.
- (** not finer_than R_lower_limit_topology R_K_topology **)
  assume Hf: finer_than R_lower_limit_topology R_K_topology.
  prove False.
  set U := open_interval (minus_SNo 1) 1 :\: K_set.
  claim HUm1R: minus_SNo 1 :e R.
  { exact (real_minus_SNo 1 real_1). }
  claim HU1R: 1 :e R.
  { exact real_1. }
  claim HUinKbasis: U :e R_K_basis.
  { prove U :e R_K_basis.
    apply (famunionI R (fun a0:set => {open_interval a0 b :\: K_set|b :e R})
             (minus_SNo 1) U HUm1R).
    claim HUfam: U :e {open_interval (minus_SNo 1) b :\: K_set|b :e R}.
    { exact (ReplI R (fun b0:set => open_interval (minus_SNo 1) b0 :\: K_set) 1 HU1R). }
    exact HUfam. }
  claim HUinB: U :e (R_standard_basis :\/: R_K_basis).
  { exact (binunionI2 R_standard_basis R_K_basis U HUinKbasis). }
  claim HUinKtop: U :e R_K_topology.
  { exact (basis_in_generated R (R_standard_basis :\/: R_K_basis) U
            R_standard_plus_K_basis_is_basis_local HUinB). }
  claim HUinLower: U :e R_lower_limit_topology.
  { exact (Hf U HUinKtop). }
  claim H0inU: 0 :e U.
  { prove 0 :e U.
    apply setminusI.
    - prove 0 :e open_interval (minus_SNo 1) 1.
      claim Hm10: Rlt (minus_SNo 1) 0.
      { apply RltI.
        - exact HUm1R.
        - exact real_0.
        - exact minus_1_lt_0. }
      claim H01: Rlt 0 1.
      { exact Rlt_0_1. }
      claim H0prop: Rlt (minus_SNo 1) 0 /\ Rlt 0 1.
      { exact (andI (Rlt (minus_SNo 1) 0) (Rlt 0 1) Hm10 H01). }
      exact (SepI R (fun x0:set => Rlt (minus_SNo 1) x0 /\ Rlt x0 1) 0 real_0 H0prop).
    - exact zero_not_in_K_set. }
  claim HUcond: forall x :e U, exists b :e R_lower_limit_basis, x :e b /\ b c= U.
  { exact (SepE2 (Power R)
            (fun U0:set => forall x0 :e U0, exists b0 :e R_lower_limit_basis, x0 :e b0 /\ b0 c= U0)
            U HUinLower). }
  claim Hexb0: exists b0 :e R_lower_limit_basis, 0 :e b0 /\ b0 c= U.
  { exact (HUcond 0 H0inU). }
  apply Hexb0.
  let b0. assume Hb0pair: b0 :e R_lower_limit_basis /\ (0 :e b0 /\ b0 c= U).
  claim Hb0inB: b0 :e R_lower_limit_basis.
  { exact (andEL (b0 :e R_lower_limit_basis) (0 :e b0 /\ b0 c= U) Hb0pair). }
  claim Hb0rest: 0 :e b0 /\ b0 c= U.
  { exact (andER (b0 :e R_lower_limit_basis) (0 :e b0 /\ b0 c= U) Hb0pair). }
  claim H0inb0: 0 :e b0.
  { exact (andEL (0 :e b0) (b0 c= U) Hb0rest). }
  claim Hb0subU: b0 c= U.
  { exact (andER (0 :e b0) (b0 c= U) Hb0rest). }
  claim Hexa0: exists a0 :e R, b0 :e {halfopen_interval_left a0 b|b :e R}.
  { exact (famunionE R (fun a0:set => {halfopen_interval_left a0 b|b :e R}) b0 Hb0inB). }
  apply Hexa0.
  let a0. assume Ha0pair: a0 :e R /\ b0 :e {halfopen_interval_left a0 b|b :e R}.
  claim Ha0R: a0 :e R.
  { exact (andEL (a0 :e R) (b0 :e {halfopen_interval_left a0 b|b :e R}) Ha0pair). }
  claim Hb0fam: b0 :e {halfopen_interval_left a0 b|b :e R}.
  { exact (andER (a0 :e R) (b0 :e {halfopen_interval_left a0 b|b :e R}) Ha0pair). }
  claim Hexb1: exists b1 :e R, b0 = halfopen_interval_left a0 b1.
  { exact (ReplE R (fun b1:set => halfopen_interval_left a0 b1) b0 Hb0fam). }
  apply Hexb1.
  let b1. assume Hb1pair: b1 :e R /\ b0 = halfopen_interval_left a0 b1.
  claim Hb1R: b1 :e R.
  { exact (andEL (b1 :e R) (b0 = halfopen_interval_left a0 b1) Hb1pair). }
  claim Hb0eq: b0 = halfopen_interval_left a0 b1.
  { exact (andER (b1 :e R) (b0 = halfopen_interval_left a0 b1) Hb1pair). }
  claim H0inHalf: 0 :e halfopen_interval_left a0 b1.
  { rewrite <- Hb0eq. exact H0inb0. }
  claim H0prop: ~(Rlt 0 a0) /\ Rlt 0 b1.
  { exact (SepE2 R (fun x0:set => ~(Rlt x0 a0) /\ Rlt x0 b1) 0 H0inHalf). }
  claim Hnot0lta0: ~(Rlt 0 a0).
  { exact (andEL (~(Rlt 0 a0)) (Rlt 0 b1) H0prop). }
  claim H0ltb1: Rlt 0 b1.
  { exact (andER (~(Rlt 0 a0)) (Rlt 0 b1) H0prop). }
  claim Hexy: exists y:set, y :e b0 /\ y :e K_set.
  { claim Hexy2: exists y:set, y :e halfopen_interval_left a0 b1 /\ y :e K_set.
    { exact (K_set_meets_lower_limit_neighborhood_0 a0 b1 Ha0R Hb1R Hnot0lta0 H0ltb1). }
    apply Hexy2.
    let y. assume Hyconj2: y :e halfopen_interval_left a0 b1 /\ y :e K_set.
    witness y.
    apply andI.
    - prove y :e b0.
      rewrite Hb0eq.
      exact (andEL (y :e halfopen_interval_left a0 b1) (y :e K_set) Hyconj2).
    - exact (andER (y :e halfopen_interval_left a0 b1) (y :e K_set) Hyconj2). }
  apply Hexy.
  let y. assume Hyconj: y :e b0 /\ y :e K_set.
  claim Hyb0: y :e b0.
  { exact (andEL (y :e b0) (y :e K_set) Hyconj). }
  claim HyK: y :e K_set.
  { exact (andER (y :e b0) (y :e K_set) Hyconj). }
  claim HyinU: y :e U.
  { exact (Hb0subU y Hyb0). }
  claim HynotK: y /:e K_set.
  { exact (setminusE2 (open_interval (minus_SNo 1) 1) K_set y HyinU). }
  exact (HynotK HyK).
- (** not finer_than R_K_topology R_lower_limit_topology **)
  assume Hf: finer_than R_K_topology R_lower_limit_topology.
  prove False.
  set U0 := halfopen_interval_left 0 1.
  claim HU0Lower: U0 :e R_lower_limit_topology.
  { prove U0 :e R_lower_limit_topology.
    (** R_lower_limit_topology = generated_topology R R_lower_limit_basis **)
    prove U0 :e generated_topology R R_lower_limit_basis.
    claim HU0Pow: U0 :e Power R.
    { exact (PowerI R U0 (halfopen_interval_left_Subq_R 0 1)). }
    claim HU0Prop: forall x :e U0, exists b0 :e R_lower_limit_basis, x :e b0 /\ b0 c= U0.
    { let x. assume HxU0: x :e U0.
      claim HxR: x :e R.
      { exact (SepE1 R (fun x0:set => ~(Rlt x0 0) /\ Rlt x0 1) x HxU0). }
      claim HxProp: ~(Rlt x 0) /\ Rlt x 1.
      { exact (SepE2 R (fun x0:set => ~(Rlt x0 0) /\ Rlt x0 1) x HxU0). }
      claim Hxlt1: Rlt x 1.
      { exact (andER (~(Rlt x 0)) (Rlt x 1) HxProp). }
      set bx := halfopen_interval_left x 1.
      witness bx.
      apply andI.
      - (** bx in the lower limit basis **)
        prove bx :e R_lower_limit_basis.
        apply (famunionI R (fun a0:set => {halfopen_interval_left a0 b|b :e R}) x bx HxR).
        exact (ReplI R (fun b0:set => halfopen_interval_left x b0) 1 real_1).
      - apply andI.
        + (** x in bx **)
          prove x :e bx.
          claim Hnotxx: ~(Rlt x x).
          { exact (not_Rlt_refl x HxR). }
          claim Hxpropbx: ~(Rlt x x) /\ Rlt x 1.
          { exact (andI (~(Rlt x x)) (Rlt x 1) Hnotxx Hxlt1). }
          exact (SepI R (fun t:set => ~(Rlt t x) /\ Rlt t 1) x HxR Hxpropbx).
        + (** bx subset U0 **)
          prove bx c= U0.
          let y. assume Hybx: y :e bx.
          claim HyR: y :e R.
          { exact (SepE1 R (fun t:set => ~(Rlt t x) /\ Rlt t 1) y Hybx). }
          claim HyProp: ~(Rlt y x) /\ Rlt y 1.
          { exact (SepE2 R (fun t:set => ~(Rlt t x) /\ Rlt t 1) y Hybx). }
          claim Hylt1: Rlt y 1.
          { exact (andER (~(Rlt y x)) (Rlt y 1) HyProp). }
          claim Hnotyltx: ~(Rlt y x).
          { exact (andEL (~(Rlt y x)) (Rlt y 1) HyProp). }
          claim Hnotxlt0: ~(x < 0).
          { assume Hxlt0: x < 0.
            claim HxRlt0: Rlt x 0.
            { exact (RltI x 0 HxR real_0 Hxlt0). }
            exact ((andEL (~(Rlt x 0)) (Rlt x 1) HxProp) HxRlt0). }
          claim HxS: SNo x.
          { exact (real_SNo x HxR). }
          claim H0S: SNo 0.
          { exact SNo_0. }
          claim HxLe0or: x < 0 \/ 0 <= x.
          { exact (SNoLtLe_or x 0 HxS H0S). }
          claim H0Lex: 0 <= x.
          { apply (HxLe0or (0 <= x)).
            - assume Hxlt0: x < 0.
              apply FalseE.
              exact (Hnotxlt0 Hxlt0).
            - assume H. exact H. }
          claim Hnotylt0: ~(Rlt y 0).
          { assume Hylt0: Rlt y 0.
            claim Hylt0lt: y < 0.
            { exact (RltE_lt y 0 Hylt0). }
            claim HyS: SNo y.
            { exact (real_SNo y HyR). }
            claim Hyltx: y < x.
            { exact (SNoLtLe_tra y 0 x HyS H0S HxS Hylt0lt H0Lex). }
            claim HyRltx: Rlt y x.
            { exact (RltI y x HyR HxR Hyltx). }
            exact (Hnotyltx HyRltx). }
          claim HyPropU0: ~(Rlt y 0) /\ Rlt y 1.
          { exact (andI (~(Rlt y 0)) (Rlt y 1) Hnotylt0 Hylt1). }
          exact (SepI R (fun z:set => ~(Rlt z 0) /\ Rlt z 1) y HyR HyPropU0). }
    exact (SepI (Power R)
                (fun U:set => forall x :e U, exists b0 :e R_lower_limit_basis, x :e b0 /\ b0 c= U)
                U0
                HU0Pow
                HU0Prop). }
  claim HU0K: U0 :e R_K_topology.
  { exact (Hf U0 HU0Lower). }
  claim H0inU0: 0 :e U0.
  { prove 0 :e U0.
    claim Hnot00: ~(Rlt 0 0).
    { exact (not_Rlt_refl 0 real_0). }
    claim H0prop: ~(Rlt 0 0) /\ Rlt 0 1.
    { exact (andI (~(Rlt 0 0)) (Rlt 0 1) Hnot00 Rlt_0_1). }
    exact (SepI R (fun z:set => ~(Rlt z 0) /\ Rlt z 1) 0 real_0 H0prop). }
  claim HU0cond: forall x :e U0, exists b1 :e (R_standard_basis :\/: R_K_basis), x :e b1 /\ b1 c= U0.
  { exact (SepE2 (Power R)
            (fun U:set => forall x0 :e U, exists b1 :e (R_standard_basis :\/: R_K_basis), x0 :e b1 /\ b1 c= U)
            U0 HU0K). }
  claim Hexb1: exists b1 :e (R_standard_basis :\/: R_K_basis), 0 :e b1 /\ b1 c= U0.
  { exact (HU0cond 0 H0inU0). }
  apply Hexb1.
  let b1. assume Hb1pair.
  claim Hb1B: b1 :e (R_standard_basis :\/: R_K_basis).
  { exact (andEL (b1 :e (R_standard_basis :\/: R_K_basis)) (0 :e b1 /\ b1 c= U0) Hb1pair). }
  claim Hb1rest: 0 :e b1 /\ b1 c= U0.
  { exact (andER (b1 :e (R_standard_basis :\/: R_K_basis)) (0 :e b1 /\ b1 c= U0) Hb1pair). }
  claim H0inb1: 0 :e b1.
  { exact (andEL (0 :e b1) (b1 c= U0) Hb1rest). }
  claim Hb1subU0: b1 c= U0.
  { exact (andER (0 :e b1) (b1 c= U0) Hb1rest). }
	  apply (binunionE R_standard_basis R_K_basis b1 Hb1B).
	  - (** b1 from standard basis **)
	    assume Hb1Std: b1 :e R_standard_basis.
    (** destruct b1 = open_interval a c **)
    claim Hexa: exists a :e R, b1 :e {open_interval a b|b :e R}.
    { exact (famunionE R (fun a0:set => {open_interval a0 b|b :e R}) b1 Hb1Std). }
    apply Hexa.
    let a0. assume Ha0pair.
    claim Ha0R: a0 :e R.
    { exact (andEL (a0 :e R) (b1 :e {open_interval a0 b|b :e R}) Ha0pair). }
    claim Hb1Fam: b1 :e {open_interval a0 b|b :e R}.
    { exact (andER (a0 :e R) (b1 :e {open_interval a0 b|b :e R}) Ha0pair). }
    claim Hexc: exists c0 :e R, b1 = open_interval a0 c0.
    { exact (ReplE R (fun c:set => open_interval a0 c) b1 Hb1Fam). }
    apply Hexc.
    let c0. assume Hc0pair.
    claim Hc0R: c0 :e R.
    { exact (andEL (c0 :e R) (b1 = open_interval a0 c0) Hc0pair). }
    claim Hb1eq: b1 = open_interval a0 c0.
    { exact (andER (c0 :e R) (b1 = open_interval a0 c0) Hc0pair). }
    claim H0inInt: 0 :e open_interval a0 c0.
    { rewrite <- Hb1eq. exact H0inb1. }
    claim H0IntProp: Rlt a0 0 /\ Rlt 0 c0.
    { exact (SepE2 R (fun t:set => Rlt a0 t /\ Rlt t c0) 0 H0inInt). }
    claim Ha0lt0: Rlt a0 0.
    { exact (andEL (Rlt a0 0) (Rlt 0 c0) H0IntProp). }
    claim H0ltc0: Rlt 0 c0.
    { exact (andER (Rlt a0 0) (Rlt 0 c0) H0IntProp). }
    set e1 := eps_ 1.
    claim H1omega: 1 :e omega.
    { exact (nat_p_omega 1 nat_1). }
    claim He1SNoS: e1 :e SNoS_ omega.
    { exact (SNo_eps_SNoS_omega 1 H1omega). }
    claim He1R: e1 :e R.
    { exact (SNoS_omega_real e1 He1SNoS). }
    claim He1S: SNo e1.
    { exact (real_SNo e1 He1R). }
    claim He1pos: 0 < e1.
    { exact (SNo_eps_pos 1 H1omega). }
    claim H0Ord: ordinal 0.
    { exact (nat_p_ordinal 0 nat_0). }
    claim H0in1: 0 :e 1.
    { exact (ordinal_0_In_ordsucc 0 H0Ord). }
    claim He1lt1: e1 < 1.
    { claim He1ltE0: eps_ 1 < eps_ 0.
      { exact (SNo_eps_decr 1 H1omega 0 H0in1). }
      rewrite <- (eps_0_1) at 2.
      exact He1ltE0. }
	    set y := mul_SNo a0 e1.
	    claim HyR: y :e R.
	    { exact (real_mul_SNo a0 Ha0R e1 He1R). }
	    claim Ha0S: SNo a0.
	    { exact (real_SNo a0 Ha0R). }
    claim HyNeg: y < 0.
    { exact (mul_SNo_neg_pos a0 e1 Ha0S He1S (RltE_lt a0 0 Ha0lt0) He1pos). }
    claim Hyltc0: y < c0.
    { claim H0ltc0lt: 0 < c0.
      { exact (RltE_lt 0 c0 H0ltc0). }
      claim Hc0S: SNo c0.
      { exact (real_SNo c0 Hc0R). }
      claim HyS: SNo y.
      { exact (real_SNo y HyR). }
      exact (SNoLt_tra y 0 c0 HyS SNo_0 Hc0S HyNeg H0ltc0lt). }
	    claim Ha0lty: a0 < y.
	    { claim Ha0lt: a0 < 0.
	      { exact (RltE_lt a0 0 Ha0lt0). }
	      claim Ha0mul: mul_SNo a0 1 < mul_SNo a0 e1.
	      { exact (neg_mul_SNo_Lt a0 1 e1 Ha0S Ha0lt SNo_1 He1S He1lt1). }
	      prove a0 < y.
	      rewrite <- (mul_SNo_oneR a0 Ha0S) at 1.
	      exact Ha0mul. }
	    claim HyInt: y :e open_interval a0 c0.
	    { prove y :e open_interval a0 c0.
	      claim Harlt: Rlt a0 y.
	      { exact (RltI a0 y Ha0R HyR Ha0lty). }
	      claim Hyrc0: Rlt y c0.
	      { exact (RltI y c0 HyR Hc0R Hyltc0). }
	      claim Hconj: Rlt a0 y /\ Rlt y c0.
	      { exact (andI (Rlt a0 y) (Rlt y c0) Harlt Hyrc0). }
	      exact (SepI R (fun t:set => Rlt a0 t /\ Rlt t c0) y HyR Hconj). }
    claim Hyinb1: y :e b1.
    { rewrite Hb1eq. exact HyInt. }
    claim HyinU0: y :e U0.
    { exact (Hb1subU0 y Hyinb1). }
    claim HyU0prop: ~(Rlt y 0) /\ Rlt y 1.
    { exact (SepE2 R (fun z:set => ~(Rlt z 0) /\ Rlt z 1) y HyinU0). }
    claim Hnotylt0: ~(Rlt y 0).
    { exact (andEL (~(Rlt y 0)) (Rlt y 1) HyU0prop). }
    claim HyRlt0: Rlt y 0.
    { exact (RltI y 0 HyR real_0 HyNeg). }
    exact (Hnotylt0 HyRlt0).
	  - (** b1 from K basis **)
	    assume Hb1K: b1 :e R_K_basis.
    (** destruct b1 = open_interval a c \\ K_set **)
    claim Hexa: exists a :e R, b1 :e {open_interval a b :\: K_set|b :e R}.
    { exact (famunionE R (fun a0:set => {open_interval a0 b :\: K_set|b :e R}) b1 Hb1K). }
    apply Hexa.
    let a0. assume Ha0pair.
    claim Ha0R: a0 :e R.
    { exact (andEL (a0 :e R) (b1 :e {open_interval a0 b :\: K_set|b :e R}) Ha0pair). }
    claim Hb1Fam: b1 :e {open_interval a0 b :\: K_set|b :e R}.
    { exact (andER (a0 :e R) (b1 :e {open_interval a0 b :\: K_set|b :e R}) Ha0pair). }
    claim Hexc: exists c0 :e R, b1 = open_interval a0 c0 :\: K_set.
    { exact (ReplE R (fun c:set => open_interval a0 c :\: K_set) b1 Hb1Fam). }
    apply Hexc.
    let c0. assume Hc0pair.
    claim Hc0R: c0 :e R.
    { exact (andEL (c0 :e R) (b1 = open_interval a0 c0 :\: K_set) Hc0pair). }
    claim Hb1eq: b1 = open_interval a0 c0 :\: K_set.
    { exact (andER (c0 :e R) (b1 = open_interval a0 c0 :\: K_set) Hc0pair). }
    claim H0inSetminus: 0 :e open_interval a0 c0 :\: K_set.
    { rewrite <- Hb1eq. exact H0inb1. }
    claim H0inInt: 0 :e open_interval a0 c0.
    { exact (setminusE1 (open_interval a0 c0) K_set 0 H0inSetminus). }
    claim H0IntProp: Rlt a0 0 /\ Rlt 0 c0.
    { exact (SepE2 R (fun t:set => Rlt a0 t /\ Rlt t c0) 0 H0inInt). }
    claim Ha0lt0: Rlt a0 0.
    { exact (andEL (Rlt a0 0) (Rlt 0 c0) H0IntProp). }
    claim H0ltc0: Rlt 0 c0.
    { exact (andER (Rlt a0 0) (Rlt 0 c0) H0IntProp). }
    set e1 := eps_ 1.
    claim H1omega: 1 :e omega.
    { exact (nat_p_omega 1 nat_1). }
    claim He1SNoS: e1 :e SNoS_ omega.
    { exact (SNo_eps_SNoS_omega 1 H1omega). }
    claim He1R: e1 :e R.
    { exact (SNoS_omega_real e1 He1SNoS). }
    claim He1S: SNo e1.
    { exact (real_SNo e1 He1R). }
    claim He1pos: 0 < e1.
    { exact (SNo_eps_pos 1 H1omega). }
    claim H0Ord: ordinal 0.
    { exact (nat_p_ordinal 0 nat_0). }
    claim H0in1: 0 :e 1.
    { exact (ordinal_0_In_ordsucc 0 H0Ord). }
    claim He1lt1: e1 < 1.
    { claim He1ltE0: eps_ 1 < eps_ 0.
      { exact (SNo_eps_decr 1 H1omega 0 H0in1). }
      rewrite <- (eps_0_1) at 2.
      exact He1ltE0. }
	    set y := mul_SNo a0 e1.
	    claim Ha0S: SNo a0.
	    { exact (real_SNo a0 Ha0R). }
	    claim HyR: y :e R.
	    { exact (real_mul_SNo a0 Ha0R e1 He1R). }
	    claim HyNeg: y < 0.
    { exact (mul_SNo_neg_pos a0 e1 Ha0S He1S (RltE_lt a0 0 Ha0lt0) He1pos). }
    claim Hyltc0: y < c0.
    { claim H0ltc0lt: 0 < c0.
      { exact (RltE_lt 0 c0 H0ltc0). }
      claim Hc0S: SNo c0.
      { exact (real_SNo c0 Hc0R). }
      claim HyS: SNo y.
      { exact (real_SNo y HyR). }
      exact (SNoLt_tra y 0 c0 HyS SNo_0 Hc0S HyNeg H0ltc0lt). }
	    claim Ha0lty: a0 < y.
	    { claim Ha0lt: a0 < 0.
	      { exact (RltE_lt a0 0 Ha0lt0). }
	      claim Ha0mul: mul_SNo a0 1 < mul_SNo a0 e1.
	      { exact (neg_mul_SNo_Lt a0 1 e1 Ha0S Ha0lt SNo_1 He1S He1lt1). }
	      prove a0 < y.
	      rewrite <- (mul_SNo_oneR a0 Ha0S) at 1.
	      exact Ha0mul. }
	    claim HyInt: y :e open_interval a0 c0.
	    { prove y :e open_interval a0 c0.
	      claim Harlt: Rlt a0 y.
	      { exact (RltI a0 y Ha0R HyR Ha0lty). }
	      claim Hyrc0: Rlt y c0.
	      { exact (RltI y c0 HyR Hc0R Hyltc0). }
	      claim Hconj: Rlt a0 y /\ Rlt y c0.
	      { exact (andI (Rlt a0 y) (Rlt y c0) Harlt Hyrc0). }
	      exact (SepI R (fun t:set => Rlt a0 t /\ Rlt t c0) y HyR Hconj). }
    claim HynotK: y /:e K_set.
    { assume HyK: y :e K_set.
      apply (ReplE_impred (omega :\: {0}) (fun m:set => inv_nat m) y HyK False).
      let m. assume HmIn: m :e omega :\: {0}. assume Hyeq: y = inv_nat m.
      claim Hypos: Rlt 0 y.
      { rewrite Hyeq.
        exact (inv_nat_pos m HmIn). }
      claim Hyposlt: 0 < y.
      { exact (RltE_lt 0 y Hypos). }
      claim HyS: SNo y.
      { exact (real_SNo y HyR). }
      claim H0lt0: 0 < 0.
      { exact (SNoLt_tra 0 y 0 SNo_0 HyS SNo_0 Hyposlt HyNeg). }
      exact ((SNoLt_irref 0) H0lt0). }
    claim HyinSetminus: y :e open_interval a0 c0 :\: K_set.
    { exact (setminusI (open_interval a0 c0) K_set y HyInt HynotK). }
    claim Hyinb1: y :e b1.
    { rewrite Hb1eq. exact HyinSetminus. }
    claim HyinU0: y :e U0.
    { exact (Hb1subU0 y Hyinb1). }
    claim HyU0prop: ~(Rlt y 0) /\ Rlt y 1.
    { exact (SepE2 R (fun z:set => ~(Rlt z 0) /\ Rlt z 1) y HyinU0). }
    claim Hnotylt0: ~(Rlt y 0).
    { exact (andEL (~(Rlt y 0)) (Rlt y 1) HyU0prop). }
    claim HyRlt0: Rlt y 0.
    { exact (RltI y 0 HyR real_0 HyNeg). }
    exact (Hnotylt0 HyRlt0).
Qed.

(** from 13 Exercise 7: containment relations among five  topologies **) 
(** LATEX VERSION: Exercise 7 lists several standard  topologies and records which contain which (upper limit finer than standard, etc.). **)
Definition R_finite_complement_topology : set := finite_complement_topology R.
Definition R_ray_topology : set :=
  {U :e Power R|U = Empty \/ U = R \/ (exists a :e R, U = {x :e R|Rlt x a})}.

(** from 13 Exercise 7: open rays are open in the standard topology **)
(** LATEX VERSION: The ray (a,) is open in the standard topology on . **)
Theorem open_ray_in_R_standard_topology : forall a:set, a :e R -> {x :e R|Rlt a x} :e R_standard_topology.
let a. assume HaR.
set U := {x :e R|Rlt a x}.
prove U :e R_standard_topology.
claim HUinPow : U :e Power R.
{ apply PowerI.
  let x. assume Hx.
  exact (SepE1 R (fun x0 : set => Rlt a x0) x Hx). }
claim HUprop : forall x :e U, exists b :e R_standard_basis, x :e b /\ b c= U.
{ let x. assume HxU.
  claim HxR : x :e R.
  { exact (SepE1 R (fun x0 : set => Rlt a x0) x HxU). }
  claim Hax : Rlt a x.
  { exact (SepE2 R (fun x0 : set => Rlt a x0) x HxU). }
  claim H0omega : 0 :e omega.
  { exact (nat_p_omega 0 nat_0). }
  set e0 := eps_ 0.
  claim He0SNoS : e0 :e SNoS_ omega.
  { exact (SNo_eps_SNoS_omega 0 H0omega). }
  claim He0R : e0 :e R.
  { exact (SNoS_omega_real e0 He0SNoS). }
  claim HbR : add_SNo x e0 :e R.
  { exact (real_add_SNo x HxR e0 He0R). }
  set b := open_interval a (add_SNo x e0).
  claim HbStd : b :e R_standard_basis.
  { claim HbFam : b :e {open_interval a b0|b0 :e R}.
    { exact (ReplI R (fun b0 : set => open_interval a b0) (add_SNo x e0) HbR). }
    exact (famunionI R
                      (fun a0 : set => {open_interval a0 b0|b0 :e R})
                      a
                      b
                      HaR
                      HbFam). }
  claim Hxinb : x :e b.
  { claim Hxlt : x < add_SNo x e0.
    { exact (add_SNo_eps_Lt x (real_SNo x HxR) 0 H0omega). }
    claim Hxxe0 : Rlt x (add_SNo x e0).
    { exact (RltI x (add_SNo x e0) HxR HbR Hxlt). }
    claim Hpropb : Rlt a x /\ Rlt x (add_SNo x e0).
    { apply andI.
      - exact Hax.
      - exact Hxxe0. }
    exact (SepI R (fun x0 : set => Rlt a x0 /\ Rlt x0 (add_SNo x e0)) x HxR Hpropb). }
  claim HbSubU : b c= U.
  { let y. assume Hyb.
    claim HyR : y :e R.
    { exact (SepE1 R (fun x0 : set => Rlt a x0 /\ Rlt x0 (add_SNo x e0)) y Hyb). }
    claim Hyprop : Rlt a y /\ Rlt y (add_SNo x e0).
    { exact (SepE2 R (fun x0 : set => Rlt a x0 /\ Rlt x0 (add_SNo x e0)) y Hyb). }
    claim Hay : Rlt a y.
    { exact (andEL (Rlt a y) (Rlt y (add_SNo x e0)) Hyprop). }
    exact (SepI R (fun x0 : set => Rlt a x0) y HyR Hay). }
  witness b.
  apply andI.
  - exact HbStd.
  - apply andI.
    + exact Hxinb.
    + exact HbSubU. }
exact (SepI (Power R)
            (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
            U
            HUinPow
            HUprop).
Qed.

(** from 13: left open ray is open in the standard topology on R **)
(** LATEX VERSION: The ray (-infty,b) is open in the standard topology on R. **)
Theorem open_left_ray_in_R_standard_topology : forall b:set, b :e R -> {x :e R|Rlt x b} :e R_standard_topology.
let b. assume HbR.
set U := {x :e R|Rlt x b}.
prove U :e R_standard_topology.
claim HUinPow : U :e Power R.
{ apply PowerI.
  let x. assume Hx.
  exact (SepE1 R (fun x0 : set => Rlt x0 b) x Hx). }
claim HUprop : forall x :e U, exists bb :e R_standard_basis, x :e bb /\ bb c= U.
{ let x. assume HxU.
  claim HxR : x :e R.
  { exact (SepE1 R (fun x0 : set => Rlt x0 b) x HxU). }
  claim Hxb : Rlt x b.
  { exact (SepE2 R (fun x0 : set => Rlt x0 b) x HxU). }
  claim H0omega : 0 :e omega.
  { exact (nat_p_omega 0 nat_0). }
  set e0 := eps_ 0.
  claim He0SNoS : e0 :e SNoS_ omega.
  { exact (SNo_eps_SNoS_omega 0 H0omega). }
  claim He0R : e0 :e R.
  { exact (SNoS_omega_real e0 He0SNoS). }
  claim He0S : SNo e0.
  { exact (real_SNo e0 He0R). }
  claim HxS : SNo x.
  { exact (real_SNo x HxR). }
  claim HmE0R : minus_SNo e0 :e R.
  { exact (real_minus_SNo e0 He0R). }
  claim HmE0S : SNo (minus_SNo e0).
  { exact (real_SNo (minus_SNo e0) HmE0R). }
  claim HaR : add_SNo x (minus_SNo e0) :e R.
  { exact (real_add_SNo x HxR (minus_SNo e0) HmE0R). }
  set a0 := add_SNo x (minus_SNo e0).
  set I := open_interval a0 b.
  claim HIStd : I :e R_standard_basis.
  { claim HIa : I :e {open_interval a0 bb|bb :e R}.
    { exact (ReplI R (fun bb : set => open_interval a0 bb) b HbR). }
    exact (famunionI R
                     (fun aa : set => {open_interval aa bb|bb :e R})
                     a0
                     I
                     HaR
                     HIa). }
  claim HxInI : x :e I.
  { claim Hxlt : x < add_SNo x e0.
    { exact (add_SNo_eps_Lt x HxS 0 H0omega). }
    claim Hxme0ltx : a0 < x.
    { exact (add_SNo_minus_Lt1b x e0 x HxS He0S HxS Hxlt). }
    claim Hax : Rlt a0 x.
    { exact (RltI a0 x HaR HxR Hxme0ltx). }
    claim HpropI : Rlt a0 x /\ Rlt x b.
    { apply andI.
      - exact Hax.
      - exact Hxb. }
    exact (SepI R (fun x0 : set => Rlt a0 x0 /\ Rlt x0 b) x HxR HpropI). }
  claim HISubU : I c= U.
  { let y. assume HyI.
    claim HyR : y :e R.
    { exact (SepE1 R (fun y0 : set => Rlt a0 y0 /\ Rlt y0 b) y HyI). }
    claim HyProp : Rlt a0 y /\ Rlt y b.
    { exact (SepE2 R (fun y0 : set => Rlt a0 y0 /\ Rlt y0 b) y HyI). }
    claim Hyb : Rlt y b.
    { exact (andER (Rlt a0 y) (Rlt y b) HyProp). }
    exact (SepI R (fun y0 : set => Rlt y0 b) y HyR Hyb). }
  witness I.
  apply andI.
  - exact HIStd.
  - apply andI.
    + exact HxInI.
    + exact HISubU. }
exact (SepI (Power R)
            (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
            U
            HUinPow
            HUprop).
Qed.

(** from 13: unions of standard open sets are standard open **)
(** LATEX VERSION: Arbitrary unions of open sets are open; in particular, unions of two open sets are open. **)
Theorem binunion_in_R_standard_topology : forall U V:set,
  U :e R_standard_topology ->
  V :e R_standard_topology ->
  U :\/: V :e R_standard_topology.
let U V. assume HU HV.
prove U :\/: V :e R_standard_topology.
claim HUpow : U :e Power R.
{ exact (SepE1 (Power R)
               (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
               U
               HU). }
claim HVpow : V :e Power R.
{ exact (SepE1 (Power R)
               (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
               V
               HV). }
claim HUprop : forall x :e U, exists b0 :e R_standard_basis, x :e b0 /\ b0 c= U.
{ exact (SepE2 (Power R)
               (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
               U
               HU). }
claim HVprop : forall x :e V, exists b0 :e R_standard_basis, x :e b0 /\ b0 c= V.
{ exact (SepE2 (Power R)
               (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
               V
               HV). }
claim HUVpow : U :\/: V :e Power R.
{ apply PowerI.
  let x. assume HxUV : x :e U :\/: V.
  apply (binunionE U V x HxUV).
  - assume HxU : x :e U.
    exact (PowerE R U HUpow x HxU).
  - assume HxV : x :e V.
    exact (PowerE R V HVpow x HxV). }
claim HUVprop : forall x :e U :\/: V, exists b0 :e R_standard_basis, x :e b0 /\ b0 c= U :\/: V.
{ let x. assume HxUV : x :e U :\/: V.
  apply (binunionE U V x HxUV).
  - assume HxU : x :e U.
    claim Hexb : exists b0 :e R_standard_basis, x :e b0 /\ b0 c= U.
    { exact (HUprop x HxU). }
    apply Hexb.
    let b0. assume Hb0pair.
    witness b0.
    apply andI.
    + exact (andEL (b0 :e R_standard_basis) (x :e b0 /\ b0 c= U) Hb0pair).
    + claim Hb0prop : x :e b0 /\ b0 c= U.
      { exact (andER (b0 :e R_standard_basis) (x :e b0 /\ b0 c= U) Hb0pair). }
      apply andI.
      - exact (andEL (x :e b0) (b0 c= U) Hb0prop).
      - claim Hb0subU : b0 c= U.
        { exact (andER (x :e b0) (b0 c= U) Hb0prop). }
        let y. assume Hyb0.
        claim HyU : y :e U.
        { exact (Hb0subU y Hyb0). }
        exact (binunionI1 U V y HyU).
  - assume HxV : x :e V.
    claim Hexb : exists b0 :e R_standard_basis, x :e b0 /\ b0 c= V.
    { exact (HVprop x HxV). }
    apply Hexb.
    let b0. assume Hb0pair.
    witness b0.
    apply andI.
    + exact (andEL (b0 :e R_standard_basis) (x :e b0 /\ b0 c= V) Hb0pair).
    + claim Hb0prop : x :e b0 /\ b0 c= V.
      { exact (andER (b0 :e R_standard_basis) (x :e b0 /\ b0 c= V) Hb0pair). }
      apply andI.
      - exact (andEL (x :e b0) (b0 c= V) Hb0prop).
      - claim Hb0subV : b0 c= V.
        { exact (andER (x :e b0) (b0 c= V) Hb0prop). }
        let y. assume Hyb0.
        claim HyV : y :e V.
        { exact (Hb0subV y Hyb0). }
        exact (binunionI2 U V y HyV). }
exact (SepI (Power R)
            (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
            (U :\/: V)
            HUVpow
            HUVprop).
Qed.

(** from 13: complement of a point in R equals union of two open rays **)
(** LATEX VERSION: R minus {a} is (-infty,a) union (a,infty). **)
Theorem R_minus_singleton_eq_rays_union : forall a:set, a :e R ->
  R :\: {a,a} = {x :e R|Rlt x a} :\/: {x :e R|Rlt a x}.
let a. assume HaR.
apply set_ext.
- let x. assume Hx : x :e R :\: {a,a}.
  prove x :e {x0 :e R|Rlt x0 a} :\/: {x0 :e R|Rlt a x0}.
  claim Hxpair : x :e R /\ x /:e {a,a}.
  { exact (setminusE R {a,a} x Hx). }
  claim HxR : x :e R.
  { exact (andEL (x :e R) (x /:e {a,a}) Hxpair). }
  claim HxNot : x /:e {a,a}.
  { exact (andER (x :e R) (x /:e {a,a}) Hxpair). }
  claim HxS : SNo x.
  { exact (real_SNo x HxR). }
  claim HaS : SNo a.
  { exact (real_SNo a HaR). }
  apply (SNoLt_trichotomy_or_impred x a HxS HaS (x :e {x0 :e R|Rlt x0 a} :\/: {x0 :e R|Rlt a x0})).
  - assume Hxlt : x < a.
    claim HxRlt : Rlt x a.
    { exact (RltI x a HxR HaR Hxlt). }
    claim HxLeft : x :e {x0 :e R|Rlt x0 a}.
    { exact (SepI R (fun x0 : set => Rlt x0 a) x HxR HxRlt). }
    exact (binunionI1 {x0 :e R|Rlt x0 a} {x0 :e R|Rlt a x0} x HxLeft).
  - assume Hxeq : x = a.
    claim Hxinpair : x :e {a,a}.
    { rewrite Hxeq.
      exact (UPairI1 a a). }
    claim Hfalse : False.
    { exact (HxNot Hxinpair). }
    exact (FalseE Hfalse (x :e {x0 :e R|Rlt x0 a} :\/: {x0 :e R|Rlt a x0})).
  - assume Halt : a < x.
    claim HxRlt : Rlt a x.
    { exact (RltI a x HaR HxR Halt). }
    claim HxRight : x :e {x0 :e R|Rlt a x0}.
    { exact (SepI R (fun x0 : set => Rlt a x0) x HxR HxRlt). }
    exact (binunionI2 {x0 :e R|Rlt x0 a} {x0 :e R|Rlt a x0} x HxRight).
- let x. assume Hx : x :e {x0 :e R|Rlt x0 a} :\/: {x0 :e R|Rlt a x0}.
  prove x :e R :\: {a,a}.
  apply (binunionE {x0 :e R|Rlt x0 a} {x0 :e R|Rlt a x0} x Hx).
  - assume HxLeft : x :e {x0 :e R|Rlt x0 a}.
    claim HxR : x :e R.
    { exact (SepE1 R (fun x0 : set => Rlt x0 a) x HxLeft). }
    claim HxRlt : Rlt x a.
    { exact (SepE2 R (fun x0 : set => Rlt x0 a) x HxLeft). }
    claim HxNot : x /:e {a,a}.
    { assume Hxin : x :e {a,a}.
      claim Hxeq : x = a.
      { apply (UPairE x a a Hxin (x = a)).
        - assume H1. exact H1.
        - assume H1. exact H1. }
      claim Haa : Rlt a a.
      { rewrite <- Hxeq at 1.
        exact HxRlt. }
      exact ((not_Rlt_refl a HaR) Haa). }
    exact (setminusI R {a,a} x HxR HxNot).
  - assume HxRight : x :e {x0 :e R|Rlt a x0}.
    claim HxR : x :e R.
    { exact (SepE1 R (fun x0 : set => Rlt a x0) x HxRight). }
    claim HxRlt : Rlt a x.
    { exact (SepE2 R (fun x0 : set => Rlt a x0) x HxRight). }
    claim HxNot : x /:e {a,a}.
    { assume Hxin : x :e {a,a}.
      claim Hxeq : x = a.
      { apply (UPairE x a a Hxin (x = a)).
        - assume H1. exact H1.
        - assume H1. exact H1. }
      claim Haa : Rlt a a.
      { rewrite <- Hxeq at 2.
        exact HxRlt. }
      exact ((not_Rlt_refl a HaR) Haa). }
    exact (setminusI R {a,a} x HxR HxNot).
Qed.

(** from 13: complement of a point is open in the standard topology on R **)
(** LATEX VERSION: Since (-infty,a) and (a,infty) are open, their union R minus {a} is open. **)
Theorem R_minus_singleton_in_R_standard_topology : forall a:set, a :e R -> R :\: {a,a} :e R_standard_topology.
let a. assume HaR.
rewrite (R_minus_singleton_eq_rays_union a HaR).
apply (binunion_in_R_standard_topology {x :e R|Rlt x a} {x :e R|Rlt a x}).
- exact (open_left_ray_in_R_standard_topology a HaR).
- exact (open_ray_in_R_standard_topology a HaR).
Qed.

(** from 13: complement of a union is intersection of complements **)
(** LATEX VERSION: X minus (A union B) equals (X minus A) intersect (X minus B). **)
Theorem setminus_binunion_eq_binintersect : forall X A B:set,
  X :\: (A :\/: B) = (X :\: A) :/\: (X :\: B).
let X A B.
apply set_ext.
- let x. assume Hx : x :e X :\: (A :\/: B).
  prove x :e (X :\: A) :/\: (X :\: B).
  claim Hxpair : x :e X /\ x /:e (A :\/: B).
  { exact (setminusE X (A :\/: B) x Hx). }
  claim HxX : x :e X.
  { exact (andEL (x :e X) (x /:e (A :\/: B)) Hxpair). }
  claim HxNot : x /:e (A :\/: B).
  { exact (andER (x :e X) (x /:e (A :\/: B)) Hxpair). }
  claim HxNotA : x /:e A.
  { assume HxA : x :e A.
    claim HxAB : x :e A :\/: B.
    { exact (binunionI1 A B x HxA). }
    exact (HxNot HxAB). }
  claim HxNotB : x /:e B.
  { assume HxB : x :e B.
    claim HxAB : x :e A :\/: B.
    { exact (binunionI2 A B x HxB). }
    exact (HxNot HxAB). }
  exact (binintersectI (X :\: A) (X :\: B) x (setminusI X A x HxX HxNotA) (setminusI X B x HxX HxNotB)).
- let x. assume Hx : x :e (X :\: A) :/\: (X :\: B).
  prove x :e X :\: (A :\/: B).
  claim HxXA : x :e X :\: A.
  { exact (binintersectE1 (X :\: A) (X :\: B) x Hx). }
  claim HxXB : x :e X :\: B.
  { exact (binintersectE2 (X :\: A) (X :\: B) x Hx). }
  claim HxX : x :e X.
  { exact (setminusE1 X A x HxXA). }
  claim HxNotA : x /:e A.
  { exact (setminusE2 X A x HxXA). }
  claim HxNotB : x /:e B.
  { exact (setminusE2 X B x HxXB). }
  claim HxNotAB : x /:e (A :\/: B).
  { assume HxAB : x :e A :\/: B.
    apply (binunionE A B x HxAB).
    - assume HxA. exact (HxNotA HxA).
    - assume HxB. exact (HxNotB HxB). }
  exact (setminusI X (A :\/: B) x HxX HxNotAB).
Qed.

(** from 13: complement of an intersection is union of complements **)
(** LATEX VERSION: X minus (A intersect B) equals (X minus A) union (X minus B). **)
Theorem setminus_binintersect_eq_binunion : forall X A B:set,
  X :\: (A :/\: B) = (X :\: A) :\/: (X :\: B).
let X A B.
apply set_ext.
- let x. assume Hx : x :e X :\: (A :/\: B).
  prove x :e (X :\: A) :\/: (X :\: B).
  claim Hxpair : x :e X /\ x /:e (A :/\: B).
  { exact (setminusE X (A :/\: B) x Hx). }
  claim HxX : x :e X.
  { exact (andEL (x :e X) (x /:e (A :/\: B)) Hxpair). }
  claim HxNotAB : x /:e (A :/\: B).
  { exact (andER (x :e X) (x /:e (A :/\: B)) Hxpair). }
  apply (xm (x :e A)).
  + assume HxA : x :e A.
    claim HxNotB : x /:e B.
    { assume HxB : x :e B.
      claim HxAB : x :e A :/\: B.
      { exact (binintersectI A B x HxA HxB). }
      exact (HxNotAB HxAB). }
    exact (binunionI2 (X :\: A) (X :\: B) x (setminusI X B x HxX HxNotB)).
  + assume HxNotA : ~(x :e A).
    exact (binunionI1 (X :\: A) (X :\: B) x (setminusI X A x HxX HxNotA)).
- let x. assume Hx : x :e (X :\: A) :\/: (X :\: B).
  prove x :e X :\: (A :/\: B).
  apply (binunionE (X :\: A) (X :\: B) x Hx).
  + assume HxXA : x :e X :\: A.
    claim HxX : x :e X.
    { exact (setminusE1 X A x HxXA). }
    claim HxNotAB : x /:e A :/\: B.
    { assume HxAB : x :e A :/\: B.
      claim HxA : x :e A.
      { exact (binintersectE1 A B x HxAB). }
      exact ((setminusE2 X A x HxXA) HxA). }
    exact (setminusI X (A :/\: B) x HxX HxNotAB).
  + assume HxXB : x :e X :\: B.
    claim HxX : x :e X.
    { exact (setminusE1 X B x HxXB). }
    claim HxNotAB : x /:e A :/\: B.
    { assume HxAB : x :e A :/\: B.
      claim HxB : x :e B.
      { exact (binintersectE2 A B x HxAB). }
      exact ((setminusE2 X B x HxXB) HxB). }
    exact (setminusI X (A :/\: B) x HxX HxNotAB).
Qed.

(** from 13: double complement inside X **)
(** LATEX VERSION: If U is a subset of X then X minus (X minus U) equals U. **)
Theorem setminus_setminus_eq : forall X U:set,
  U c= X ->
  X :\: (X :\: U) = U.
let X U. assume HUsub.
apply set_ext.
- let x. assume Hx : x :e X :\: (X :\: U).
  prove x :e U.
  claim Hxpair : x :e X /\ x /:e (X :\: U).
  { exact (setminusE X (X :\: U) x Hx). }
  claim HxX : x :e X.
  { exact (andEL (x :e X) (x /:e (X :\: U)) Hxpair). }
  claim HxNot : x /:e (X :\: U).
  { exact (andER (x :e X) (x /:e (X :\: U)) Hxpair). }
  apply (xm (x :e U)).
  - assume HxU. exact HxU.
  - assume HxNotU : ~(x :e U).
    claim HxXU : x :e X :\: U.
    { exact (setminusI X U x HxX HxNotU). }
    exact (FalseE (HxNot HxXU) (x :e U)).
- let x. assume HxU : x :e U.
  prove x :e X :\: (X :\: U).
  claim HxX : x :e X.
  { exact (HUsub x HxU). }
  claim HxNot : x /:e (X :\: U).
  { assume HxXU : x :e X :\: U.
    exact ((setminusE2 X U x HxXU) HxU). }
  exact (setminusI X (X :\: U) x HxX HxNot).
Qed.

(** from 12: finite intersections of closed sets are closed **)
(** LATEX VERSION: Finite intersections of closed sets are closed because their complements are finite unions of open sets. **)
Theorem binintersect_closed : forall X T C D:set,
  closed_in X T C ->
  closed_in X T D ->
  closed_in X T (C :/\: D).
let X T C D.
assume HC: closed_in X T C.
assume HD: closed_in X T D.
prove closed_in X T (C :/\: D).
claim HTx: topology_on X T.
{ exact (andEL (topology_on X T) (C c= X /\ exists U :e T, C = X :\: U) HC). }
claim HCsubX: C c= X.
{ exact (andEL (C c= X) (exists U :e T, C = X :\: U)
        (andER (topology_on X T) (C c= X /\ exists U :e T, C = X :\: U) HC)). }
claim HDsubX: D c= X.
{ exact (andEL (D c= X) (exists U :e T, D = X :\: U)
        (andER (topology_on X T) (D c= X /\ exists U :e T, D = X :\: U) HD)). }
claim HopenC: open_in X T (X :\: C).
{ exact (open_of_closed_complement X T C HC). }
claim HopenD: open_in X T (X :\: D).
{ exact (open_of_closed_complement X T D HD). }
claim HXCdT: X :\: C :e T.
{ exact (andER (topology_on X T) (X :\: C :e T) HopenC). }
claim HXDdT: X :\: D :e T.
{ exact (andER (topology_on X T) (X :\: D :e T) HopenD). }
claim Hunion_compl_in_T: (X :\: C) :\/: (X :\: D) :e T.
{ claim Hpairsub: {X :\: C, X :\: D} c= T.
  { let U. assume HU: U :e {X :\: C, X :\: D}.
    claim Hor: U = X :\: C \/ U = X :\: D.
    { exact (UPairE U (X :\: C) (X :\: D) HU). }
    apply Hor.
    - assume HUeq: U = X :\: C.
      rewrite HUeq. exact HXCdT.
    - assume HUeq: U = X :\: D.
      rewrite HUeq. exact HXDdT.
  }
  claim HUnionPair: Union {X :\: C, X :\: D} :e T.
  { exact (topology_union_closed X T {X :\: C, X :\: D} HTx Hpairsub). }
  rewrite (binunion_eq_Union_pair (X :\: C) (X :\: D)).
  exact HUnionPair.
}
prove topology_on X T /\ (C :/\: D c= X /\ exists U :e T, C :/\: D = X :\: U).
apply andI.
- exact HTx.
- apply andI.
  + exact (Subq_tra (C :/\: D) C X (binintersect_Subq_1 C D) HCsubX).
  + witness ((X :\: C) :\/: (X :\: D)).
    apply andI.
    * exact Hunion_compl_in_T.
    * prove C :/\: D = X :\: ((X :\: C) :\/: (X :\: D)).
      rewrite (setminus_binunion_eq_binintersect X (X :\: C) (X :\: D)).
      rewrite (setminus_setminus_eq X C HCsubX).
      rewrite (setminus_setminus_eq X D HDsubX).
      reflexivity.
Qed.

(** from 12: finite unions of closed sets are closed **)
(** LATEX VERSION: Finite unions of closed sets are closed because their complements are finite intersections of open sets. **)
Theorem binunion_closed : forall X T C D:set,
  closed_in X T C ->
  closed_in X T D ->
  closed_in X T (C :\/: D).
let X T C D.
assume HC: closed_in X T C.
assume HD: closed_in X T D.
prove closed_in X T (C :\/: D).
claim HTx: topology_on X T.
{ exact (andEL (topology_on X T) (C c= X /\ exists U :e T, C = X :\: U) HC). }
claim HCsubX: C c= X.
{ exact (andEL (C c= X) (exists U :e T, C = X :\: U)
        (andER (topology_on X T) (C c= X /\ exists U :e T, C = X :\: U) HC)). }
claim HDsubX: D c= X.
{ exact (andEL (D c= X) (exists U :e T, D = X :\: U)
        (andER (topology_on X T) (D c= X /\ exists U :e T, D = X :\: U) HD)). }
claim HopenC: open_in X T (X :\: C).
{ exact (open_of_closed_complement X T C HC). }
claim HopenD: open_in X T (X :\: D).
{ exact (open_of_closed_complement X T D HD). }
claim Hinter_compl_in_T: (X :\: C) :/\: (X :\: D) :e T.
{ claim HXCdT: X :\: C :e T.
  { exact (andER (topology_on X T) (X :\: C :e T) HopenC). }
  claim HXDdT: X :\: D :e T.
  { exact (andER (topology_on X T) (X :\: D :e T) HopenD). }
  exact (topology_binintersect_closed X T (X :\: C) (X :\: D) HTx HXCdT HXDdT).
}
prove topology_on X T /\ (C :\/: D c= X /\ exists U :e T, C :\/: D = X :\: U).
apply andI.
- exact HTx.
- apply andI.
  + exact (binunion_Subq_min C D X HCsubX HDsubX).
  + witness ((X :\: C) :/\: (X :\: D)).
    apply andI.
    * exact Hinter_compl_in_T.
    * prove C :\/: D = X :\: ((X :\: C) :/\: (X :\: D)).
      rewrite (setminus_binintersect_eq_binunion X (X :\: C) (X :\: D)).
      rewrite (setminus_setminus_eq X C HCsubX).
      rewrite (setminus_setminus_eq X D HDsubX).
      reflexivity.
Qed.

(** from 13: complements of finite sets are open in the standard topology on R **)
(** LATEX VERSION: In the standard topology, the complement of a finite set is open. **)
Theorem Sing_eq_UPair : forall x:set, {x} = {x,x}.
let x.
apply set_ext.
- let y. assume Hy : y :e {x}.
  claim Hyeq : y = x.
  { exact (SingE x y Hy). }
  rewrite Hyeq.
  exact (UPairI1 x x).
- let y. assume Hy : y :e {x,x}.
  claim Hyeq : y = x.
  { apply (UPairE y x x Hy (y = x)).
    - assume H1. exact H1.
    - assume H1. exact H1. }
  rewrite Hyeq.
  exact (SingI x).
Qed.

Theorem finite_complement_open_in_R_standard_topology : forall F:set,
  finite F ->
  F c= R ->
  R :\: F :e R_standard_topology.
let F. assume HFin.
assume HFsubR.
set p := fun F0:set => F0 c= R -> R :\: F0 :e R_standard_topology.
claim HpEmpty : p Empty.
{ assume Hsub : Empty c= R.
  claim Hreq : R :\: Empty = R.
  { apply set_ext.
    - let x. assume Hx : x :e R :\: Empty.
      exact (setminusE1 R Empty x Hx).
    - let x. assume HxR : x :e R.
      exact (setminusI R Empty x HxR (EmptyE x)). }
  rewrite Hreq.
  exact (topology_has_X R R_standard_topology (R_standard_topology_is_topology_local)).
}
claim HpStep : forall X y:set,
  finite X ->
  y /:e X ->
  p X ->
  p (X :\/: {y}).
{ let X y. assume HFinX HyNot HXind.
  assume HsubXY : (X :\/: {y}) c= R.
  claim HsubX : X c= R.
  { let z. assume HzX : z :e X.
    exact (HsubXY z (binunionI1 X {y} z HzX)). }
  claim HyR : y :e R.
  { exact (HsubXY y (binunionI2 X {y} y (SingI y))). }
  claim HXopen : R :\: X :e R_standard_topology.
  { exact (HXind HsubX). }
  claim Hyopen : R :\: {y} :e R_standard_topology.
  { rewrite (Sing_eq_UPair y).
    exact (R_minus_singleton_in_R_standard_topology y HyR). }
  claim Hdecomp : R :\: (X :\/: {y}) = (R :\: X) :/\: (R :\: {y}).
  { exact (setminus_binunion_eq_binintersect R X {y}). }
  rewrite Hdecomp.
  exact (topology_binintersect_closed R R_standard_topology (R :\: X) (R :\: {y})
         (R_standard_topology_is_topology_local)
         HXopen
         Hyopen).
}
claim Hall : forall F0:set, finite F0 -> p F0.
{ exact (finite_ind p HpEmpty HpStep). }
exact (Hall F HFin HFsubR).
Qed.

(** LATEX VERSION: Containment statements among the five  topologies in Exercise 7. **)
Theorem ex13_7_R_topology_containments :
  finer_than R_upper_limit_topology R_standard_topology /\
  finer_than R_K_topology R_standard_topology /\
  finer_than R_standard_topology R_finite_complement_topology /\
  finer_than R_standard_topology R_ray_topology.
prove finer_than R_upper_limit_topology R_standard_topology /\ finer_than R_K_topology R_standard_topology /\ finer_than R_standard_topology R_finite_complement_topology /\ finer_than R_standard_topology R_ray_topology.
apply andI.
- apply andI.
  + apply andI.
    * prove finer_than R_upper_limit_topology R_standard_topology.
      (** finer_than T' T means T c= T' **)
      prove R_standard_topology c= R_upper_limit_topology.
      let U. assume HU: U :e R_standard_topology.
      (** Expand generated_topology membership for the standard topology **)
      claim HUinPow : U :e Power R.
      { exact (SepE1 (Power R)
                     (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
                     U
                     HU). }
      claim HUprop : forall x :e U, exists b0 :e R_standard_basis, x :e b0 /\ b0 c= U.
      { exact (SepE2 (Power R)
                     (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
                     U
                     HU). }
      (** Refine a standard basis neighborhood (a,b) to an upper-limit neighborhood (a,x] around x **)
      claim HUpropUpper : forall x :e U, exists b0 :e R_upper_limit_basis, x :e b0 /\ b0 c= U.
      { let x. assume HxU.
        claim HexStd : exists bStd :e R_standard_basis, x :e bStd /\ bStd c= U.
        { exact (HUprop x HxU). }
        apply HexStd.
        let bStd. assume HbStdPair.
        claim HbStdIn : bStd :e R_standard_basis.
        { exact (andEL (bStd :e R_standard_basis) (x :e bStd /\ bStd c= U) HbStdPair). }
        claim HbStdProp : x :e bStd /\ bStd c= U.
        { exact (andER (bStd :e R_standard_basis) (x :e bStd /\ bStd c= U) HbStdPair). }
        claim HxInbStd : x :e bStd.
        { exact (andEL (x :e bStd) (bStd c= U) HbStdProp). }
        claim HbStdSubU : bStd c= U.
        { exact (andER (x :e bStd) (bStd c= U) HbStdProp). }
        (** Unpack bStd as an open interval open_interval a0 b0 **)
        claim Hexa0 : exists a0 :e R, bStd :e {open_interval a0 b0|b0 :e R}.
        { exact (famunionE R (fun a0 : set => {open_interval a0 b0|b0 :e R}) bStd HbStdIn). }
        apply Hexa0.
        let a0. assume Ha0Pair.
        claim Ha0R : a0 :e R.
        { exact (andEL (a0 :e R) (bStd :e {open_interval a0 b0|b0 :e R}) Ha0Pair). }
        claim HbStdFam : bStd :e {open_interval a0 b0|b0 :e R}.
        { exact (andER (a0 :e R) (bStd :e {open_interval a0 b0|b0 :e R}) Ha0Pair). }
        claim Hexb0 : exists b0 :e R, bStd = open_interval a0 b0.
        { exact (ReplE R (fun b0 : set => open_interval a0 b0) bStd HbStdFam). }
        apply Hexb0.
        let b0. assume Hb0Pair.
        claim Hb0R : b0 :e R.
        { exact (andEL (b0 :e R) (bStd = open_interval a0 b0) Hb0Pair). }
        claim HbStdEq : bStd = open_interval a0 b0.
        { exact (andER (b0 :e R) (bStd = open_interval a0 b0) Hb0Pair). }
        (** From x in bStd, extract x in open_interval a0 b0 **)
        claim HxInI : x :e open_interval a0 b0.
        { rewrite <- HbStdEq.
          exact HxInbStd. }
        claim HxR : x :e R.
        { exact (SepE1 R (fun x0 : set => Rlt a0 x0 /\ Rlt x0 b0) x HxInI). }
        claim HxIProp : Rlt a0 x /\ Rlt x b0.
        { exact (SepE2 R (fun x0 : set => Rlt a0 x0 /\ Rlt x0 b0) x HxInI). }
        claim Ha0x : Rlt a0 x.
        { exact (andEL (Rlt a0 x) (Rlt x b0) HxIProp). }
        claim Hxb0 : Rlt x b0.
        { exact (andER (Rlt a0 x) (Rlt x b0) HxIProp). }
        (** Define the upper-limit neighborhood (a0,x] **)
        set bUpper := halfopen_interval_right a0 x.
        witness bUpper.
        apply andI.
        - (** bUpper is in the upper-limit basis **)
          claim HbFamUpper : bUpper :e {halfopen_interval_right a0 bb|bb :e R}.
          { exact (ReplI R (fun bb : set => halfopen_interval_right a0 bb) x HxR). }
          exact (famunionI R (fun aa : set => {halfopen_interval_right aa bb|bb :e R})
                           a0
                           bUpper
                           Ha0R
                           HbFamUpper).
        - apply andI.
          + (** x is in (a0,x] **)
            exact (halfopen_interval_right_rightmem a0 x Ha0x).
          + (** (a0,x] is contained in U **)
            let y. assume HyUpper : y :e bUpper.
            prove y :e U.
            claim HyR : y :e R.
            { exact (SepE1 R (fun y0 : set => Rlt a0 y0 /\ ~(Rlt x y0)) y HyUpper). }
            claim HyProp : Rlt a0 y /\ ~(Rlt x y).
            { exact (SepE2 R (fun y0 : set => Rlt a0 y0 /\ ~(Rlt x y0)) y HyUpper). }
            claim Ha0y : Rlt a0 y.
            { exact (andEL (Rlt a0 y) (~(Rlt x y)) HyProp). }
            claim HnotRltxy : ~(Rlt x y).
            { exact (andER (Rlt a0 y) (~(Rlt x y)) HyProp). }
            (** Convert ~(Rlt x y) into ~(x<y) using known realness of x and y **)
            claim Hnot_xlt_y : ~(x < y).
            { assume Hxy : x < y.
              claim HxyRlt : Rlt x y.
              { exact (RltI x y HxR HyR Hxy). }
              exact (HnotRltxy HxyRlt). }
            (** Show y < b0 using trichotomy between y and x, since x < b0 **)
            claim HyS : SNo y.
            { exact (real_SNo y HyR). }
            claim HxS : SNo x.
            { exact (real_SNo x HxR). }
            claim Hb0S : SNo b0.
            { exact (real_SNo b0 Hb0R). }
            claim Hxltb0 : x < b0.
            { exact (RltE_lt x b0 Hxb0). }
            claim Hyltb0 : y < b0.
            { apply (SNoLt_trichotomy_or_impred y x HyS HxS (y < b0)).
              - assume Hyltx : y < x.
                exact (SNoLt_tra y x b0 HyS HxS Hb0S Hyltx Hxltb0).
              - assume Heyx : y = x.
                rewrite Heyx.
                exact Hxltb0.
              - assume HxltY : x < y.
                claim HxyFalse : False.
                { exact (Hnot_xlt_y HxltY). }
                exact (FalseE HxyFalse (y < b0)). }
            claim HyRltb0 : Rlt y b0.
            { exact (RltI y b0 HyR Hb0R Hyltb0). }
            (** y is in the standard open interval (a0,b0) = bStd **)
            claim HyConj : Rlt a0 y /\ Rlt y b0.
            { apply andI.
              - exact Ha0y.
              - exact HyRltb0. }
            claim HyInI : y :e open_interval a0 b0.
            { exact (SepI R (fun y0 : set => Rlt a0 y0 /\ Rlt y0 b0) y HyR HyConj). }
            claim HyInbStd : y :e bStd.
            { rewrite HbStdEq at 1.
              exact HyInI. }
            exact (HbStdSubU y HyInbStd).
      }
      (** Conclude: U is open in R_upper_limit_topology by definition **)
      exact (SepI (Power R)
                  (fun U0 : set => forall x0 :e U0, exists b0 :e R_upper_limit_basis, x0 :e b0 /\ b0 c= U0)
                  U
                  HUinPow
                  HUpropUpper).
    * prove finer_than R_K_topology R_standard_topology.
      (** finer_than T' T means T c= T' **)
      prove R_standard_topology c= R_K_topology.
      let U. assume HU: U :e R_standard_topology.
      (** Expand generated_topology membership for the standard topology **)
      claim HUinPow : U :e Power R.
      { exact (SepE1 (Power R)
                     (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
                     U
                     HU). }
      claim HUprop : forall x :e U, exists b0 :e R_standard_basis, x :e b0 /\ b0 c= U.
      { exact (SepE2 (Power R)
                     (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
                     U
                     HU). }
      (** Show U satisfies the defining property for generated_topology R (R_standard_basis :\/: R_K_basis) **)
      claim HUpropK : forall x :e U, exists b0 :e (R_standard_basis :\/: R_K_basis), x :e b0 /\ b0 c= U.
      { let x. assume HxU.
        claim Hexb : exists b0 :e R_standard_basis, x :e b0 /\ b0 c= U.
        { exact (HUprop x HxU). }
        apply Hexb.
        let b0. assume Hb0pair.
        claim Hb0Std : b0 :e R_standard_basis.
        { exact (andEL (b0 :e R_standard_basis) (x :e b0 /\ b0 c= U) Hb0pair). }
        claim Hb0prop : x :e b0 /\ b0 c= U.
        { exact (andER (b0 :e R_standard_basis) (x :e b0 /\ b0 c= U) Hb0pair). }
        claim Hxb0 : x :e b0.
        { exact (andEL (x :e b0) (b0 c= U) Hb0prop). }
        claim Hb0subU : b0 c= U.
        { exact (andER (x :e b0) (b0 c= U) Hb0prop). }
        witness b0.
        apply andI.
        - exact (binunionI1 R_standard_basis R_K_basis b0 Hb0Std).
        - apply andI.
          + exact Hxb0.
          + exact Hb0subU. }
      exact (SepI (Power R)
                  (fun U0 : set => forall x0 :e U0, exists b0 :e (R_standard_basis :\/: R_K_basis), x0 :e b0 /\ b0 c= U0)
                  U
                  HUinPow
                  HUpropK).
  + prove finer_than R_standard_topology R_finite_complement_topology.
    (** finer_than T' T means T c= T' **)
    prove R_finite_complement_topology c= R_standard_topology.
    let U. assume HU : U :e R_finite_complement_topology.
    (** Unpack membership in finite_complement_topology R **)
    claim HUpow : U :e Power R.
    { exact (SepE1 (Power R)
                   (fun U0 : set => finite (R :\: U0) \/ U0 = Empty)
                   U
                   HU). }
    claim HUsub : U c= R.
    { exact (PowerE R U HUpow). }
    claim HUcases : finite (R :\: U) \/ U = Empty.
    { exact (SepE2 (Power R)
                   (fun U0 : set => finite (R :\: U0) \/ U0 = Empty)
                   U
                   HU). }
    apply (HUcases (U :e R_standard_topology)).
    - assume HFin : finite (R :\: U).
      prove U :e R_standard_topology.
      claim HFsubR : (R :\: U) c= R.
      { exact (setminus_Subq R U). }
      claim Hopen : R :\: (R :\: U) :e R_standard_topology.
      { exact (finite_complement_open_in_R_standard_topology (R :\: U) HFin HFsubR). }
      rewrite <- (setminus_setminus_eq R U HUsub).
      exact Hopen.
    - assume HUe : U = Empty.
      rewrite HUe.
      exact (topology_has_empty R R_standard_topology (R_standard_topology_is_topology_local)).
- prove finer_than R_standard_topology R_ray_topology.
  let U. assume HU: U :e R_ray_topology.
  claim HUcases : U = Empty \/ U = R \/ exists a :e R, U = {x :e R|Rlt x a}.
  { exact (SepE2 (Power R) (fun U0 : set => U0 = Empty \/ U0 = R \/ exists a0 :e R, U0 = {x :e R|Rlt x a0}) U HU). }
  claim Hempty : Empty :e R_standard_topology.
  { exact (SepI (Power R)
                (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
                Empty
                (Empty_In_Power R)
                (fun x0 Hx0 => EmptyE x0 Hx0 (exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= Empty))). }
  claim Hall : R :e R_standard_topology.
  { claim HRpow : R :e Power R.
    { apply PowerI.
      exact (Subq_ref R). }
    claim HRprop : forall x :e R, exists b0 :e R_standard_basis, x :e b0 /\ b0 c= R.
    { let x. assume HxR.
      set a0 := add_SNo x (minus_SNo 1).
      set b0 := add_SNo x 1.
      set I := open_interval a0 b0.
      claim Hm1R : minus_SNo 1 :e R.
      { exact (real_minus_SNo 1 real_1). }
      claim Ha0R : a0 :e R.
      { exact (real_add_SNo x HxR (minus_SNo 1) Hm1R). }
      claim Hb0R : b0 :e R.
      { exact (real_add_SNo x HxR 1 real_1). }
      claim HxS : SNo x.
      { exact (real_SNo x HxR). }
      claim Hm1S : SNo (minus_SNo 1).
      { exact (real_SNo (minus_SNo 1) Hm1R). }
      claim Ha0lt : a0 < x.
      { claim Hlt : a0 < add_SNo x 0.
        { exact (add_SNo_Lt2 x (minus_SNo 1) 0 HxS Hm1S SNo_0 minus_1_lt_0). }
        rewrite <- (add_SNo_0R x HxS) at 2.
        exact Hlt. }
      claim Hxb0 : x < b0.
      { claim Hlt : add_SNo x 0 < b0.
        { exact (add_SNo_Lt2 x 0 1 HxS SNo_0 (real_SNo 1 real_1) SNoLt_0_1). }
        rewrite <- (add_SNo_0R x HxS) at 1.
        exact Hlt. }
      claim HxInI : x :e I.
      { claim Hax : Rlt a0 x.
        { exact (RltI a0 x Ha0R HxR Ha0lt). }
        claim Hxb : Rlt x b0.
        { exact (RltI x b0 HxR Hb0R Hxb0). }
        claim Hconj : Rlt a0 x /\ Rlt x b0.
        { apply andI.
          - exact Hax.
          - exact Hxb. }
        exact (SepI R (fun x0 : set => Rlt a0 x0 /\ Rlt x0 b0) x HxR Hconj). }
      claim HIStd : I :e R_standard_basis.
      { claim HIa : I :e {open_interval a0 bb|bb :e R}.
        { exact (ReplI R (fun bb : set => open_interval a0 bb) b0 Hb0R). }
        exact (famunionI R
                         (fun aa : set => {open_interval aa bb|bb :e R})
                         a0
                         I
                         Ha0R
                         HIa). }
      witness I.
      apply andI.
      - exact HIStd.
      - apply andI.
        + exact HxInI.
        + exact (open_interval_Subq_R a0 b0). }
    exact (SepI (Power R)
                (fun U0 : set => forall x0 :e U0, exists b0 :e R_standard_basis, x0 :e b0 /\ b0 c= U0)
                R
                HRpow
                HRprop). }
  claim Hcase1 : U = Empty -> U :e R_standard_topology.
  { assume Heq. rewrite Heq. exact Hempty. }
  claim Hcase2 : U = R -> U :e R_standard_topology.
  { assume Heq. rewrite Heq. exact Hall. }
  claim Hcase3 : (exists a0 :e R, U = {x :e R|Rlt x a0}) -> U :e R_standard_topology.
  { assume Hex.
    apply Hex.
    let a0.
    assume Ha0pair : a0 :e R /\ U = {x :e R|Rlt x a0}.
    claim Ha0R : a0 :e R.
    { exact (andEL (a0 :e R) (U = {x :e R|Rlt x a0}) Ha0pair). }
    claim Heq : U = {x :e R|Rlt x a0}.
    { exact (andER (a0 :e R) (U = {x :e R|Rlt x a0}) Ha0pair). }
    rewrite Heq.
    exact (open_left_ray_in_R_standard_topology a0 Ha0R). }
  prove U :e R_standard_topology.
  apply (HUcases (U :e R_standard_topology)).
  - assume HUR : U = Empty \/ U = R.
    apply (HUR (U :e R_standard_topology)).
    + exact Hcase1.
    + exact Hcase2.
  - exact Hcase3.
Qed.

(** from 13 Exercise 8(a): rational open intervals generate standard topology on  **) 
(** LATEX VERSION: Exercise 8(a): Basis of rational open intervals generates the standard topology on . **)
Definition rational_open_intervals_basis : set :=
  \/_ q1 :e rational_numbers, {open_interval q1 q2|q2 :e rational_numbers}.

(** from 13 Exercise 8(a): rational open intervals are standard open intervals **)
(** LATEX VERSION: Any rational open interval (q1,q2) is a standard basis element since q1,q2 are real. **)
Theorem rational_open_intervals_basis_Subq_R_standard_basis :
  rational_open_intervals_basis c= R_standard_basis.
prove rational_open_intervals_basis c= R_standard_basis.
let I. assume HI: I :e rational_open_intervals_basis.
apply (famunionE_impred rational_numbers
         (fun q1 : set => {open_interval q1 q2|q2 :e rational_numbers})
         I
         HI
         (I :e R_standard_basis)).
let q1. assume Hq1Q HIq1.
apply (ReplE_impred rational_numbers
         (fun q2 : set => open_interval q1 q2)
         I
         HIq1
         (I :e R_standard_basis)).
let q2. assume Hq2Q Heq.
rewrite Heq.
claim Hq1R : q1 :e R.
{ exact (rational_numbers_in_R q1 Hq1Q). }
claim Hq2R : q2 :e R.
{ exact (rational_numbers_in_R q2 Hq2Q). }
claim HIq2 : open_interval q1 q2 :e {open_interval q1 b|b :e R}.
{ exact (ReplI R (fun b : set => open_interval q1 b) q2 Hq2R). }
exact (famunionI R (fun a : set => {open_interval a b|b :e R}) q1 (open_interval q1 q2) Hq1R HIq2).
Qed.

(** from 13 Exercise 8(a): density of rationals in reals (in order sense) **)
(** LATEX VERSION: Between any two real numbers a<b there exists a rational q with a<q<b. **)
Theorem rational_dense_between_reals : forall a b:set,
  a :e R -> b :e R -> Rlt a b ->
  exists q :e rational_numbers, Rlt a q /\ Rlt q b.
let a b.
assume HaR HbR Hab.
prove exists q :e rational_numbers, Rlt a q /\ Rlt q b.
claim HaS: SNo a.
{ exact (real_SNo a HaR). }
claim HbS: SNo b.
{ exact (real_SNo b HbR). }
claim Hablt: a < b.
{ exact (RltE_lt a b Hab). }
claim HmaR: minus_SNo a :e R.
{ exact (real_minus_SNo a HaR). }
claim HmaS: SNo (minus_SNo a).
{ exact (real_SNo (minus_SNo a) HmaR). }
set d := add_SNo b (minus_SNo a).
claim HdDef: d = add_SNo b (minus_SNo a).
{ reflexivity. }
claim HdR: d :e R.
{ rewrite HdDef.
  exact (real_add_SNo b HbR (minus_SNo a) HmaR). }
claim HdS: SNo d.
{ exact (real_SNo d HdR). }
claim H0ltd: 0 < d.
{ rewrite HdDef.
  claim Hlt: add_SNo a (minus_SNo a) < add_SNo b (minus_SNo a).
  { exact (add_SNo_Lt1 a (minus_SNo a) b HaS HmaS HbS Hablt). }
  claim H0eq: add_SNo a (minus_SNo a) = 0.
  { exact (add_SNo_minus_SNo_rinv a HaS). }
  rewrite <- H0eq.
  exact Hlt. }
(** choose N with eps_N < d using invd = 1/d and a bounded eps product **)
set invd := recip_SNo_pos d.
claim HinvdDef: invd = recip_SNo_pos d.
{ reflexivity. }
claim HinvdR: invd :e R.
{ rewrite HinvdDef.
  exact (real_recip_SNo_pos d HdR H0ltd). }
claim HinvdS: SNo invd.
{ exact (real_SNo invd HinvdR). }
claim Hinvdpos: 0 < invd.
{ exact (recip_SNo_pos_is_pos d HdS H0ltd). }
claim HexN: exists N :e omega, eps_ N < d.
{ apply (real_E invd HinvdR (exists N :e omega, eps_ N < d)).
  assume HinvS: SNo invd.
  assume Hlev.
  assume HinS.
  assume Hlow.
  assume Hup.
  assume Huniq.
  assume Happrox.
  claim HexNlt: exists N :e omega, mul_SNo (eps_ N) invd < 1.
  { exact (SNoS_ordsucc_omega_bdd_eps_pos invd HinS Hinvdpos Hup). }
  apply HexNlt.
  let N. assume HNpair.
  claim HNomega: N :e omega.
  { exact (andEL (N :e omega) (mul_SNo (eps_ N) invd < 1) HNpair). }
  claim HmulLt: mul_SNo (eps_ N) invd < 1.
  { exact (andER (N :e omega) (mul_SNo (eps_ N) invd < 1) HNpair). }
  witness N.
  apply andI.
  - exact HNomega.
  - claim HepsS: SNo (eps_ N).
    { exact (SNo_eps_ N HNomega). }
    (** eps_N < 1/:/invd, then 1/:/invd = d **)
    claim HepsLtDiv: eps_ N < div_SNo 1 invd.
    { exact (div_SNo_pos_LtR 1 invd (eps_ N) SNo_1 HinvS HepsS Hinvdpos HmulLt). }
    claim HdivEq: div_SNo 1 invd = d.
    { claim Hposcase: recip_SNo invd = recip_SNo_pos invd.
      { exact (recip_SNo_poscase invd Hinvdpos). }
      claim HrecipInv: recip_SNo_pos invd = d.
      { rewrite HinvdDef.
        exact (recip_SNo_pos_invol d HdS H0ltd). }
      claim HdivDef: div_SNo 1 invd = mul_SNo 1 (recip_SNo invd).
      { reflexivity. }
      rewrite HdivDef.
      rewrite Hposcase.
      rewrite HrecipInv.
      exact (mul_SNo_oneL d HdS). }
    rewrite <- HdivEq.
    exact HepsLtDiv.
}
apply HexN.
let N. assume HNpair.
claim HNomega: N :e omega.
{ exact (andEL (N :e omega) (eps_ N < d) HNpair). }
claim HepsNlt: eps_ N < d.
{ exact (andER (N :e omega) (eps_ N < d) HNpair). }
(** approximate b from below within eps_N using real_E, then show the approximant lies above a **)
claim Hexq: exists q :e SNoS_ omega, q < b /\ b < add_SNo q (eps_ N).
{ apply (real_E b HbR (exists q :e SNoS_ omega, q < b /\ b < add_SNo q (eps_ N))).
  assume HbS': SNo b.
  assume Hlev.
  assume HbInS.
  assume Hlow.
  assume Hup.
  assume Huniq.
  assume Happrox.
  exact (Happrox N HNomega). }
apply Hexq.
let q. assume Hqpair. apply Hqpair.
assume HqInS: q :e SNoS_ omega.
assume Hqprop: q < b /\ b < add_SNo q (eps_ N).
claim Hqltb: q < b.
{ exact (andEL (q < b) (b < add_SNo q (eps_ N)) Hqprop). }
claim Hbltqeps: b < add_SNo q (eps_ N).
{ exact (andER (q < b) (b < add_SNo q (eps_ N)) Hqprop). }
claim HqRat: q :e rational_numbers.
{ exact (Subq_SNoS_omega_rational q HqInS). }
claim HqR: q :e R.
{ exact (rational_numbers_in_R q HqRat). }
claim HqS: SNo q.
{ exact (real_SNo q HqR). }
claim HepsR: eps_ N :e R.
{ exact (rational_numbers_in_R (eps_ N) (Subq_SNoS_omega_rational (eps_ N) (SNo_eps_SNoS_omega N HNomega))). }
claim HepsS: SNo (eps_ N).
{ exact (real_SNo (eps_ N) HepsR). }
claim Hbmepsltq: add_SNo b (minus_SNo (eps_ N)) < q.
{ exact (add_SNo_minus_Lt1b b (eps_ N) q HbS HepsS HqS Hbltqeps). }
claim Haepsltb: add_SNo a (eps_ N) < b.
{ prove add_SNo a (eps_ N) < b.
  claim Hlt1: add_SNo (eps_ N) a < add_SNo d a.
  { exact (add_SNo_Lt1 (eps_ N) a d HepsS HaS HdS HepsNlt). }
  claim Hdplus: add_SNo d a = b.
  { rewrite HdDef.
    exact (add_SNo_minus_R2' b a HbS HaS). }
  claim Hcom: add_SNo (eps_ N) a = add_SNo a (eps_ N).
  { exact (add_SNo_com (eps_ N) a HepsS HaS). }
  rewrite <- Hcom.
  rewrite <- Hdplus.
  exact Hlt1. }
claim Haltbmeps: a < add_SNo b (minus_SNo (eps_ N)).
{ exact (add_SNo_minus_Lt2b b (eps_ N) a HbS HepsS HaS Haepsltb). }
claim HbmepsS: SNo (add_SNo b (minus_SNo (eps_ N))).
{ exact (SNo_add_SNo b (minus_SNo (eps_ N)) HbS (SNo_minus_SNo (eps_ N) HepsS)). }
claim Hqlt: a < q.
{ exact (SNoLt_tra a (add_SNo b (minus_SNo (eps_ N))) q HaS HbmepsS HqS Haltbmeps Hbmepsltq). }
claim Haq: Rlt a q.
{ exact (RltI a q HaR HqR Hqlt). }
claim Hqb: Rlt q b.
{ exact (RltI q b HqR HbR Hqltb). }
witness q.
apply andI.
- exact HqRat.
- apply andI.
  - exact Haq.
  - exact Hqb.
Qed.

(** from 13 Exercise 8(a): rational endpoints around a point in a real open interval **)
(** LATEX VERSION: If x is in (a,b) then there are rationals q1,q2 with q1<x<q2 and (q1,q2) contained in (a,b). **)
Theorem rational_interval_refines_real_interval : forall a b x:set,
  a :e R -> b :e R -> x :e R ->
  x :e open_interval a b ->
  exists q1 :e rational_numbers, exists q2 :e rational_numbers,
    x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a b.
let a b x.
assume HaR HbR HxR HxInab.
claim HxabProp: Rlt a x /\ Rlt x b.
{ exact (SepE2 R (fun z : set => Rlt a z /\ Rlt z b) x HxInab). }
claim Hax: Rlt a x.
{ exact (andEL (Rlt a x) (Rlt x b) HxabProp). }
claim Hxb: Rlt x b.
{ exact (andER (Rlt a x) (Rlt x b) HxabProp). }
(** choose q1 rational with a<q1<x **)
apply (rational_dense_between_reals a x HaR HxR Hax).
let q1. assume Hq1pair. apply Hq1pair.
assume Hq1Q: q1 :e rational_numbers.
assume Hq1Prop: Rlt a q1 /\ Rlt q1 x.
claim Hq1R: q1 :e R.
{ exact (rational_numbers_in_R q1 Hq1Q). }
claim Haq1: Rlt a q1.
{ exact (andEL (Rlt a q1) (Rlt q1 x) Hq1Prop). }
claim Hq1x: Rlt q1 x.
{ exact (andER (Rlt a q1) (Rlt q1 x) Hq1Prop). }
(** choose q2 rational with x<q2<b **)
apply (rational_dense_between_reals x b HxR HbR Hxb).
let q2. assume Hq2pair. apply Hq2pair.
assume Hq2Q: q2 :e rational_numbers.
assume Hq2Prop: Rlt x q2 /\ Rlt q2 b.
claim Hq2R: q2 :e R.
{ exact (rational_numbers_in_R q2 Hq2Q). }
claim Hxq2: Rlt x q2.
{ exact (andEL (Rlt x q2) (Rlt q2 b) Hq2Prop). }
claim Hq2b: Rlt q2 b.
{ exact (andER (Rlt x q2) (Rlt q2 b) Hq2Prop). }
(** witness the rational interval (q1,q2) around x **)
witness q1.
apply andI.
- exact Hq1Q.
- witness q2.
  apply andI.
  * exact Hq2Q.
  * apply andI.
    { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z q2) x HxR
                   (andI (Rlt q1 x) (Rlt x q2) Hq1x Hxq2)). }
    { let y. assume Hy: y :e open_interval q1 q2.
      prove y :e open_interval a b.
      claim HyR: y :e R.
      { exact (SepE1 R (fun z : set => Rlt q1 z /\ Rlt z q2) y Hy). }
      claim HyProp: Rlt q1 y /\ Rlt y q2.
      { exact (SepE2 R (fun z : set => Rlt q1 z /\ Rlt z q2) y Hy). }
      claim Hq1y: Rlt q1 y.
      { exact (andEL (Rlt q1 y) (Rlt y q2) HyProp). }
      claim Hyq2: Rlt y q2.
      { exact (andER (Rlt q1 y) (Rlt y q2) HyProp). }
      claim HaS: SNo a.
      { exact (real_SNo a HaR). }
      claim Hq1S: SNo q1.
      { exact (real_SNo q1 Hq1R). }
      claim HyS: SNo y.
      { exact (real_SNo y HyR). }
      claim HbS: SNo b.
      { exact (real_SNo b HbR). }
      claim Hq2S: SNo q2.
      { exact (real_SNo q2 Hq2R). }
      claim Haq1lt: a < q1.
      { exact (RltE_lt a q1 Haq1). }
      claim Hq1ylt: q1 < y.
      { exact (RltE_lt q1 y Hq1y). }
      claim Hyq2lt: y < q2.
      { exact (RltE_lt y q2 Hyq2). }
      claim Hq2blt: q2 < b.
      { exact (RltE_lt q2 b Hq2b). }
      claim Haylt: a < y.
      { exact (SNoLt_tra a q1 y HaS Hq1S HyS Haq1lt Hq1ylt). }
      claim Hyblt: y < b.
      { exact (SNoLt_tra y q2 b HyS Hq2S HbS Hyq2lt Hq2blt). }
      claim Hay: Rlt a y.
      { exact (RltI a y HaR HyR Haylt). }
      claim Hyb: Rlt y b.
      { exact (RltI y b HyR HbR Hyblt). }
      claim Hconj: Rlt a y /\ Rlt y b.
      { apply andI.
        - exact Hay.
        - exact Hyb. }
      exact (SepI R (fun z : set => Rlt a z /\ Rlt z b) y HyR Hconj). }
Qed.

Theorem ex13_8a_rational_intervals_basis_standard :
  basis_on R rational_open_intervals_basis /\
  generated_topology R rational_open_intervals_basis = R_standard_topology.
prove basis_on R rational_open_intervals_basis /\ generated_topology R rational_open_intervals_basis = R_standard_topology.
(** NOTE: This needs a density lemma for `rational_numbers` in `R`:
    for any `a b :e R` with `Rlt a b` and any `x :e open_interval a b`,
    there exist rationals `q1 q2` with `Rlt a q1`, `Rlt q1 x`, `Rlt x q2`, `Rlt q2 b`.
    A promising route is to use `real_E` (pre-topology, trusted) to approximate reals by elements of `SNoS_ omega`,
    then use `Subq_SNoS_omega_rational` to view those approximants as rationals. The missing piece is a clean
    inequality bridge showing that sufficiently small `eps_ k` yields a strict point between `a` and `b`. **)
apply andI.
- (** rational open intervals satisfy basis_on R (partial: subset property) **)
  prove rational_open_intervals_basis c= Power R
    /\ (forall x :e R, exists b :e rational_open_intervals_basis, x :e b)
    /\ (forall b1 :e rational_open_intervals_basis, forall b2 :e rational_open_intervals_basis, forall x:set,
          x :e b1 -> x :e b2 ->
          exists b3 :e rational_open_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2).
  apply andI.
  - prove rational_open_intervals_basis c= Power R /\ (forall x :e R, exists b :e rational_open_intervals_basis, x :e b).
    apply andI.
    + (** every rational open interval is a subset of R **)
      prove rational_open_intervals_basis c= Power R.
      let b. assume Hb: b :e rational_open_intervals_basis.
      prove b :e Power R.
      apply (famunionE_impred rational_numbers
               (fun q1 : set => {open_interval q1 q2|q2 :e rational_numbers})
               b
               Hb
               (b :e Power R)).
      let q1. assume Hq1 Hbq1.
      apply (ReplE_impred rational_numbers
               (fun q2 : set => open_interval q1 q2)
               b
               Hbq1
               (b :e Power R)).
	      let q2. assume Hq2 Heq.
	      rewrite Heq.
	      exact (PowerI R (open_interval q1 q2) (open_interval_Subq_R q1 q2)).
	    + (** coverage of R by rational open intervals **)
	      let x. assume HxR.
	      set a0 := add_SNo x (minus_SNo 1).
	      set b0 := add_SNo x 1.
	      claim Hm1R : minus_SNo 1 :e R.
	      { exact (real_minus_SNo 1 real_1). }
	      claim Ha0R : a0 :e R.
	      { exact (real_add_SNo x HxR (minus_SNo 1) Hm1R). }
	      claim Hb0R : b0 :e R.
	      { exact (real_add_SNo x HxR 1 real_1). }
	      claim HxInI : x :e open_interval a0 b0.
	      { exact (real_in_open_interval_minus1_plus1 x HxR). }
	      claim HexRat : exists q1 :e rational_numbers, exists q2 :e rational_numbers,
	        x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a0 b0.
	      { exact (rational_interval_refines_real_interval a0 b0 x Ha0R Hb0R HxR HxInI). }
	      apply HexRat.
	      let q1. assume Hq1pair. apply Hq1pair.
	      assume Hq1: q1 :e rational_numbers.
	      assume Hexq2: exists q2 :e rational_numbers,
	        x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a0 b0.
	      apply Hexq2.
	      let q2. assume Hq2pair. apply Hq2pair.
	      assume Hq2: q2 :e rational_numbers.
	      assume HxInQ : x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a0 b0.
	      claim HxInQint : x :e open_interval q1 q2.
	      { exact (andEL (x :e open_interval q1 q2) (open_interval q1 q2 c= open_interval a0 b0) HxInQ). }
	      witness (open_interval q1 q2).
	      apply andI.
	      * (** open_interval q1 q2 is in the rational-open-interval basis **)
	        claim Hq2fam : open_interval q1 q2 :e {open_interval q1 q2'|q2' :e rational_numbers}.
	        { exact (ReplI rational_numbers (fun q2' : set => open_interval q1 q2') q2 Hq2). }
	        exact (famunionI rational_numbers
	                 (fun q1' : set => {open_interval q1' q2'|q2' :e rational_numbers})
	                 q1
	                 (open_interval q1 q2)
	                 Hq1
	                 Hq2fam).
	      * exact HxInQint.
	  - (** intersection refinement using rational endpoints **)
	    let b1. assume Hb1.
	    let b2. assume Hb2.
	    let x. assume Hx1 Hx2.
	    prove exists b3 :e rational_open_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2.
	    (** destruct b1 = open_interval q1 q2 with q1,q2 rationals **)
	    claim Hexq1 : exists q1 :e rational_numbers, b1 :e {open_interval q1 q2|q2 :e rational_numbers}.
	    { exact (famunionE rational_numbers (fun q1 : set => {open_interval q1 q2|q2 :e rational_numbers}) b1 Hb1). }
	    apply Hexq1.
	    let q1. assume Hq1pair. apply Hq1pair.
	    assume Hq1Q : q1 :e rational_numbers.
	    assume Hb1fam : b1 :e {open_interval q1 q2|q2 :e rational_numbers}.
	    claim Hexq2 : exists q2 :e rational_numbers, b1 = open_interval q1 q2.
	    { exact (ReplE rational_numbers (fun q2 : set => open_interval q1 q2) b1 Hb1fam). }
	    apply Hexq2.
	    let q2. assume Hq2pair. apply Hq2pair.
	    assume Hq2Q : q2 :e rational_numbers.
	    assume Hb1eq : b1 = open_interval q1 q2.
	    (** destruct b2 = open_interval r1 r2 with r1,r2 rationals **)
	    claim Hexr1 : exists r1 :e rational_numbers, b2 :e {open_interval r1 r2|r2 :e rational_numbers}.
	    { exact (famunionE rational_numbers (fun r1 : set => {open_interval r1 r2|r2 :e rational_numbers}) b2 Hb2). }
	    apply Hexr1.
	    let r1. assume Hr1pair. apply Hr1pair.
	    assume Hr1Q : r1 :e rational_numbers.
	    assume Hb2fam : b2 :e {open_interval r1 r2|r2 :e rational_numbers}.
	    claim Hexr2 : exists r2 :e rational_numbers, b2 = open_interval r1 r2.
	    { exact (ReplE rational_numbers (fun r2 : set => open_interval r1 r2) b2 Hb2fam). }
	    apply Hexr2.
	    let r2. assume Hr2pair. apply Hr2pair.
	    assume Hr2Q : r2 :e rational_numbers.
	    assume Hb2eq : b2 = open_interval r1 r2.
	    (** x in the two intervals **)
	    claim HxIn1 : x :e open_interval q1 q2.
	    { rewrite <- Hb1eq. exact Hx1. }
	    claim HxIn2 : x :e open_interval r1 r2.
	    { rewrite <- Hb2eq. exact Hx2. }
	    claim HxR : x :e R.
	    { exact (SepE1 R (fun z : set => Rlt q1 z /\ Rlt z q2) x HxIn1). }
	    claim HxProp1 : Rlt q1 x /\ Rlt x q2.
	    { exact (SepE2 R (fun z : set => Rlt q1 z /\ Rlt z q2) x HxIn1). }
	    claim HxProp2 : Rlt r1 x /\ Rlt x r2.
	    { exact (SepE2 R (fun z : set => Rlt r1 z /\ Rlt z r2) x HxIn2). }
	    claim Hq1x : Rlt q1 x.
	    { exact (andEL (Rlt q1 x) (Rlt x q2) HxProp1). }
	    claim Hxq2 : Rlt x q2.
	    { exact (andER (Rlt q1 x) (Rlt x q2) HxProp1). }
	    claim Hr1x : Rlt r1 x.
	    { exact (andEL (Rlt r1 x) (Rlt x r2) HxProp2). }
	    claim Hxr2 : Rlt x r2.
	    { exact (andER (Rlt r1 x) (Rlt x r2) HxProp2). }
	    (** endpoint types **)
	    claim Hq1R : q1 :e R.
	    { exact (rational_numbers_in_R q1 Hq1Q). }
	    claim Hq2R : q2 :e R.
	    { exact (rational_numbers_in_R q2 Hq2Q). }
	    claim Hr1R : r1 :e R.
	    { exact (rational_numbers_in_R r1 Hr1Q). }
	    claim Hr2R : r2 :e R.
	    { exact (rational_numbers_in_R r2 Hr2Q). }
	    claim Hq1S : SNo q1.
	    { exact (real_SNo q1 Hq1R). }
	    claim Hq2S : SNo q2.
	    { exact (real_SNo q2 Hq2R). }
	    claim Hr1S : SNo r1.
	    { exact (real_SNo r1 Hr1R). }
	    claim Hr2S : SNo r2.
	    { exact (real_SNo r2 Hr2R). }
	    claim HxS : SNo x.
	    { exact (real_SNo x HxR). }
	    claim Hq1xlt : q1 < x.
	    { exact (RltE_lt q1 x Hq1x). }
	    claim Hr1xlt : r1 < x.
	    { exact (RltE_lt r1 x Hr1x). }
	    claim Hxq2lt : x < q2.
	    { exact (RltE_lt x q2 Hxq2). }
	    claim Hxr2lt : x < r2.
	    { exact (RltE_lt x r2 Hxr2). }
	    (** choose max left endpoint and min right endpoint by trichotomy **)
	    apply (SNoLt_trichotomy_or_impred q1 r1 Hq1S Hr1S
	             (exists b3 :e rational_open_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
	    - assume Hq1lt : q1 < r1.
	      (** left endpoint r1 **)
	      apply (SNoLt_trichotomy_or_impred q2 r2 Hq2S Hr2S
	               (exists b3 :e rational_open_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
	      + assume Hq2lt : q2 < r2.
	        (** right endpoint q2 **)
	        set I3 := open_interval r1 q2.
	        witness I3.
	        apply andI.
	        * (** I3 in basis **)
	          claim HI3fam : I3 :e {open_interval r1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => open_interval r1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {open_interval aa bb|bb :e rational_numbers})
	                   r1
	                   I3
	                   Hr1Q
	                   HI3fam).
	        * apply andI.
	          { (** x in I3 **)
	            claim Hr1xRlt : Rlt r1 x.
	            { exact Hr1x. }
	            claim Hxq2Rlt : Rlt x q2.
	            { exact Hxq2. }
	            exact (SepI R (fun z : set => Rlt r1 z /\ Rlt z q2) x HxR
	                         (andI (Rlt r1 x) (Rlt x q2) Hr1xRlt Hxq2Rlt)). }
	          { (** I3 subset b1  b2 **)
	            let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => Rlt r1 z /\ Rlt z q2) y HyI3). }
	            claim HyProp : Rlt r1 y /\ Rlt y q2.
	            { exact (SepE2 R (fun z : set => Rlt r1 z /\ Rlt z q2) y HyI3). }
	            claim Hr1y : Rlt r1 y.
	            { exact (andEL (Rlt r1 y) (Rlt y q2) HyProp). }
	            claim Hyq2 : Rlt y q2.
	            { exact (andER (Rlt r1 y) (Rlt y q2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hr1ylt : r1 < y.
	            { exact (RltE_lt r1 y Hr1y). }
	            claim Hyq2lt : y < q2.
	            { exact (RltE_lt y q2 Hyq2). }
	            (** y in b2 = (r1,r2) since q2<r2 **)
	            claim Hyr2lt : y < r2.
	            { exact (SNoLt_tra y q2 r2 HyS Hq2S Hr2S Hyq2lt Hq2lt). }
	            claim Hyr2 : Rlt y r2.
	            { exact (RltI y r2 HyR Hr2R Hyr2lt). }
	            claim HyIn2 : y :e open_interval r1 r2.
	            { exact (SepI R (fun z : set => Rlt r1 z /\ Rlt z r2) y HyR
	                         (andI (Rlt r1 y) (Rlt y r2) Hr1y Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            (** y in b1 = (q1,q2) since q1<r1 **)
	            claim Hq1ylt : q1 < y.
	            { exact (SNoLt_tra q1 r1 y Hq1S Hr1S HyS Hq1lt Hr1ylt). }
	            claim Hq1y : Rlt q1 y.
	            { exact (RltI q1 y Hq1R HyR Hq1ylt). }
	            claim HyIn1 : y :e open_interval q1 q2.
	            { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyR
	                         (andI (Rlt q1 y) (Rlt y q2) Hq1y Hyq2)). }
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyIn1. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hq2eq : q2 = r2.
	        set I3 := open_interval r1 q2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {open_interval r1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => open_interval r1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {open_interval aa bb|bb :e rational_numbers})
	                   r1
	                   I3
	                   Hr1Q
	                   HI3fam).
	        * apply andI.
	          { exact (SepI R (fun z : set => Rlt r1 z /\ Rlt z q2) x HxR
	                         (andI (Rlt r1 x) (Rlt x q2) Hr1x Hxq2)). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => Rlt r1 z /\ Rlt z q2) y HyI3). }
	            claim HyProp : Rlt r1 y /\ Rlt y q2.
	            { exact (SepE2 R (fun z : set => Rlt r1 z /\ Rlt z q2) y HyI3). }
	            claim Hr1y : Rlt r1 y.
	            { exact (andEL (Rlt r1 y) (Rlt y q2) HyProp). }
	            claim Hyq2 : Rlt y q2.
	            { exact (andER (Rlt r1 y) (Rlt y q2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hr1ylt : r1 < y.
	            { exact (RltE_lt r1 y Hr1y). }
	            claim Hyq2lt : y < q2.
	            { exact (RltE_lt y q2 Hyq2). }
	            (** y in b2 using r2=q2 **)
	            claim Hyr2 : Rlt y r2.
	            { rewrite <- Hq2eq. exact Hyq2. }
	            claim HyIn2 : y :e open_interval r1 r2.
	            { exact (SepI R (fun z : set => Rlt r1 z /\ Rlt z r2) y HyR
	                         (andI (Rlt r1 y) (Rlt y r2) Hr1y Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            (** y in b1 since q1<r1 **)
	            claim Hq1ylt : q1 < y.
	            { exact (SNoLt_tra q1 r1 y Hq1S Hr1S HyS Hq1lt Hr1ylt). }
	            claim Hq1y : Rlt q1 y.
	            { exact (RltI q1 y Hq1R HyR Hq1ylt). }
	            claim HyIn1 : y :e open_interval q1 q2.
	            { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyR
	                         (andI (Rlt q1 y) (Rlt y q2) Hq1y Hyq2)). }
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyIn1. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hr2lt : r2 < q2.
	        (** right endpoint r2 **)
	        set I3 := open_interval r1 r2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {open_interval r1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => open_interval r1 qq) r2 Hr2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {open_interval aa bb|bb :e rational_numbers})
	                   r1
	                   I3
	                   Hr1Q
	                   HI3fam).
	        * apply andI.
	          { exact (SepI R (fun z : set => Rlt r1 z /\ Rlt z r2) x HxR
	                         (andI (Rlt r1 x) (Rlt x r2) Hr1x Hxr2)). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => Rlt r1 z /\ Rlt z r2) y HyI3). }
	            claim HyProp : Rlt r1 y /\ Rlt y r2.
	            { exact (SepE2 R (fun z : set => Rlt r1 z /\ Rlt z r2) y HyI3). }
	            claim Hr1y : Rlt r1 y.
	            { exact (andEL (Rlt r1 y) (Rlt y r2) HyProp). }
	            claim Hyr2 : Rlt y r2.
	            { exact (andER (Rlt r1 y) (Rlt y r2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hr1ylt : r1 < y.
	            { exact (RltE_lt r1 y Hr1y). }
	            claim Hyr2lt : y < r2.
	            { exact (RltE_lt y r2 Hyr2). }
	            (** y in b1: need y<q2 since r2<q2 **)
	            claim Hyq2lt : y < q2.
	            { exact (SNoLt_tra y r2 q2 HyS Hr2S Hq2S Hyr2lt Hr2lt). }
	            claim Hyq2 : Rlt y q2.
	            { exact (RltI y q2 HyR Hq2R Hyq2lt). }
	            claim Hq1ylt : q1 < y.
	            { exact (SNoLt_tra q1 r1 y Hq1S Hr1S HyS Hq1lt Hr1ylt). }
	            claim Hq1y : Rlt q1 y.
	            { exact (RltI q1 y Hq1R HyR Hq1ylt). }
	            claim HyIn1 : y :e open_interval q1 q2.
	            { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyR
	                         (andI (Rlt q1 y) (Rlt y q2) Hq1y Hyq2)). }
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyIn1. }
	            (** y in b2 = (r1,r2) **)
	            claim HyIn2 : y :e open_interval r1 r2.
	            { exact (SepI R (fun z : set => Rlt r1 z /\ Rlt z r2) y HyR
	                         (andI (Rlt r1 y) (Rlt y r2) Hr1y Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	    - assume Hq1eq : q1 = r1.
	      (** left endpoint q1 **)
	      apply (SNoLt_trichotomy_or_impred q2 r2 Hq2S Hr2S
	               (exists b3 :e rational_open_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
	      + assume Hq2lt : q2 < r2.
	        set I3 := open_interval q1 q2.
	        witness I3.
	        apply andI.
	        * (** I3 in basis **)
	          claim HI3fam : I3 :e {open_interval q1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => open_interval q1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {open_interval aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
	        * apply andI.
	          { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z q2) x HxR HxProp1). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            (** y in b1 directly **)
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyI3. }
	            (** y in b2 since r1=q1 and q2<r2 **)
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyI3). }
	            claim HyProp : Rlt q1 y /\ Rlt y q2.
	            { exact (SepE2 R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyI3). }
	            claim Hqy : Rlt q1 y.
	            { exact (andEL (Rlt q1 y) (Rlt y q2) HyProp). }
	            claim Hyq2 : Rlt y q2.
	            { exact (andER (Rlt q1 y) (Rlt y q2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hyq2lt : y < q2.
	            { exact (RltE_lt y q2 Hyq2). }
	            claim Hyr2lt : y < r2.
	            { exact (SNoLt_tra y q2 r2 HyS Hq2S Hr2S Hyq2lt Hq2lt). }
	            claim Hyr2 : Rlt y r2.
	            { exact (RltI y r2 HyR Hr2R Hyr2lt). }
	            claim HyIn2 : y :e open_interval r1 r2.
	            { rewrite <- Hq1eq.
	              exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z r2) y HyR
	                           (andI (Rlt q1 y) (Rlt y r2) Hqy Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hq2eq : q2 = r2.
	        set I3 := open_interval q1 q2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {open_interval q1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => open_interval q1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {open_interval aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
	        * apply andI.
	          { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z q2) x HxR HxProp1). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyI3. }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. rewrite <- Hq1eq. rewrite <- Hq2eq. exact HyI3. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hr2lt : r2 < q2.
	        set I3 := open_interval q1 r2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {open_interval q1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => open_interval q1 qq) r2 Hr2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {open_interval aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
	        * apply andI.
	          { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z r2) x HxR
	                         (andI (Rlt q1 x) (Rlt x r2) Hq1x Hxr2)). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => Rlt q1 z /\ Rlt z r2) y HyI3). }
	            claim HyProp : Rlt q1 y /\ Rlt y r2.
	            { exact (SepE2 R (fun z : set => Rlt q1 z /\ Rlt z r2) y HyI3). }
	            claim Hq1y : Rlt q1 y.
	            { exact (andEL (Rlt q1 y) (Rlt y r2) HyProp). }
	            claim Hyr2 : Rlt y r2.
	            { exact (andER (Rlt q1 y) (Rlt y r2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hyr2lt : y < r2.
	            { exact (RltE_lt y r2 Hyr2). }
	            claim Hyq2lt : y < q2.
	            { exact (SNoLt_tra y r2 q2 HyS Hr2S Hq2S Hyr2lt Hr2lt). }
	            claim Hyq2 : Rlt y q2.
	            { exact (RltI y q2 HyR Hq2R Hyq2lt). }
	            claim HyIn1 : y :e open_interval q1 q2.
	            { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyR
	                         (andI (Rlt q1 y) (Rlt y q2) Hq1y Hyq2)). }
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyIn1. }
	            claim HyIn2 : y :e open_interval r1 r2.
	            { rewrite <- Hq1eq.
	              exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z r2) y HyR
	                           (andI (Rlt q1 y) (Rlt y r2) Hq1y Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	    - assume Hr1lt : r1 < q1.
	      (** left endpoint q1 **)
	      apply (SNoLt_trichotomy_or_impred q2 r2 Hq2S Hr2S
	               (exists b3 :e rational_open_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
	      + assume Hq2lt : q2 < r2.
	        set I3 := open_interval q1 q2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {open_interval q1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => open_interval q1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {open_interval aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
	        * apply andI.
	          { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z q2) x HxR HxProp1). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            (** y in b1 directly **)
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyI3. }
	            (** y in b2 since r1<q1 and q2<r2 **)
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyI3). }
	            claim HyProp : Rlt q1 y /\ Rlt y q2.
	            { exact (SepE2 R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyI3). }
	            claim Hq1y : Rlt q1 y.
	            { exact (andEL (Rlt q1 y) (Rlt y q2) HyProp). }
	            claim Hyq2 : Rlt y q2.
	            { exact (andER (Rlt q1 y) (Rlt y q2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hq1ylt : q1 < y.
	            { exact (RltE_lt q1 y Hq1y). }
	            claim Hyq2lt : y < q2.
	            { exact (RltE_lt y q2 Hyq2). }
	            claim Hr1ylt : r1 < y.
	            { exact (SNoLt_tra r1 q1 y Hr1S Hq1S HyS Hr1lt Hq1ylt). }
	            claim Hr1y : Rlt r1 y.
	            { exact (RltI r1 y Hr1R HyR Hr1ylt). }
	            claim Hyr2lt : y < r2.
	            { exact (SNoLt_tra y q2 r2 HyS Hq2S Hr2S Hyq2lt Hq2lt). }
	            claim Hyr2 : Rlt y r2.
	            { exact (RltI y r2 HyR Hr2R Hyr2lt). }
	            claim HyIn2 : y :e open_interval r1 r2.
	            { exact (SepI R (fun z : set => Rlt r1 z /\ Rlt z r2) y HyR
	                         (andI (Rlt r1 y) (Rlt y r2) Hr1y Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hq2eq : q2 = r2.
	        set I3 := open_interval q1 q2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {open_interval q1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => open_interval q1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {open_interval aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
	        * apply andI.
	          { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z q2) x HxR HxProp1). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyI3. }
	            (** y in b2 using r2=q2 and r1<q1 **)
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyI3). }
	            claim HyProp : Rlt q1 y /\ Rlt y q2.
	            { exact (SepE2 R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyI3). }
	            claim Hq1y : Rlt q1 y.
	            { exact (andEL (Rlt q1 y) (Rlt y q2) HyProp). }
	            claim Hyq2 : Rlt y q2.
	            { exact (andER (Rlt q1 y) (Rlt y q2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hq1ylt : q1 < y.
	            { exact (RltE_lt q1 y Hq1y). }
	            claim Hr1ylt : r1 < y.
	            { exact (SNoLt_tra r1 q1 y Hr1S Hq1S HyS Hr1lt Hq1ylt). }
	            claim Hr1y : Rlt r1 y.
	            { exact (RltI r1 y Hr1R HyR Hr1ylt). }
	            claim Hyr2 : Rlt y r2.
	            { rewrite <- Hq2eq. exact Hyq2. }
	            claim HyIn2 : y :e open_interval r1 r2.
	            { exact (SepI R (fun z : set => Rlt r1 z /\ Rlt z r2) y HyR
	                         (andI (Rlt r1 y) (Rlt y r2) Hr1y Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hr2lt : r2 < q2.
	        set I3 := open_interval q1 r2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {open_interval q1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => open_interval q1 qq) r2 Hr2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {open_interval aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
	        * apply andI.
	          { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z r2) x HxR
	                         (andI (Rlt q1 x) (Rlt x r2) Hq1x Hxr2)). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => Rlt q1 z /\ Rlt z r2) y HyI3). }
	            claim HyProp : Rlt q1 y /\ Rlt y r2.
	            { exact (SepE2 R (fun z : set => Rlt q1 z /\ Rlt z r2) y HyI3). }
	            claim Hq1y : Rlt q1 y.
	            { exact (andEL (Rlt q1 y) (Rlt y r2) HyProp). }
	            claim Hyr2 : Rlt y r2.
	            { exact (andER (Rlt q1 y) (Rlt y r2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hq1ylt : q1 < y.
	            { exact (RltE_lt q1 y Hq1y). }
	            claim Hyr2lt : y < r2.
	            { exact (RltE_lt y r2 Hyr2). }
	            claim Hyq2lt : y < q2.
	            { exact (SNoLt_tra y r2 q2 HyS Hr2S Hq2S Hyr2lt Hr2lt). }
	            claim Hyq2 : Rlt y q2.
	            { exact (RltI y q2 HyR Hq2R Hyq2lt). }
	            claim HyIn1 : y :e open_interval q1 q2.
	            { exact (SepI R (fun z : set => Rlt q1 z /\ Rlt z q2) y HyR
	                         (andI (Rlt q1 y) (Rlt y q2) Hq1y Hyq2)). }
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyIn1. }
	            (** y in b2 since r1<q1 and y<r2 **)
	            claim Hr1ylt : r1 < y.
	            { exact (SNoLt_tra r1 q1 y Hr1S Hq1S HyS Hr1lt Hq1ylt). }
		    claim Hr1y : Rlt r1 y.
		    { exact (RltI r1 y Hr1R HyR Hr1ylt). }
		    claim HyIn2 : y :e open_interval r1 r2.
		    { exact (SepI R (fun z : set => Rlt r1 z /\ Rlt z r2) y HyR
		                         (andI (Rlt r1 y) (Rlt y r2) Hr1y Hyr2)). }
		    claim Hyb2 : y :e b2.
		    { rewrite Hb2eq. exact HyIn2. }
		    exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	- (** generated_topology R rational_open_intervals_basis equals R_standard_topology **)
	  prove generated_topology R rational_open_intervals_basis = R_standard_topology.
	  (** R_standard_topology = generated_topology R R_standard_basis **)
	  apply set_ext.
	  + let U. assume HU: U :e generated_topology R rational_open_intervals_basis.
	    prove U :e R_standard_topology.
	    (** Unpack U membership in generated_topology R rational_open_intervals_basis **)
	    claim HUpow: U :e Power R.
	    { exact (SepE1 (Power R)
	             (fun U0 : set => forall x0 :e U0, exists b :e rational_open_intervals_basis, x0 :e b /\ b c= U0)
	             U
	             HU). }
	    claim HUprop: forall x0 :e U, exists b :e rational_open_intervals_basis, x0 :e b /\ b c= U.
	    { exact (SepE2 (Power R)
	             (fun U0 : set => forall x0 :e U0, exists b :e rational_open_intervals_basis, x0 :e b /\ b c= U0)
	             U
	             HU). }
	    (** Show U satisfies the standard-basis neighborhood property **)
	    prove U :e generated_topology R R_standard_basis.
	    prove U :e {U0 :e Power R | forall x0 :e U0, exists b :e R_standard_basis, x0 :e b /\ b c= U0}.
	    claim HUstdprop: forall x0 :e U, exists b :e R_standard_basis, x0 :e b /\ b c= U.
	    { let x. assume HxU: x :e U.
	      apply (HUprop x HxU).
	      let b. assume Hbpair.
	      claim HbB: b :e rational_open_intervals_basis.
	      { exact (andEL (b :e rational_open_intervals_basis) (x :e b /\ b c= U) Hbpair). }
	      claim Hbprop: x :e b /\ b c= U.
	      { exact (andER (b :e rational_open_intervals_basis) (x :e b /\ b c= U) Hbpair). }
	      claim Hxb: x :e b.
	      { exact (andEL (x :e b) (b c= U) Hbprop). }
	      claim HbsubU: b c= U.
	      { exact (andER (x :e b) (b c= U) Hbprop). }
	      claim HbStd: b :e R_standard_basis.
	      { exact (rational_open_intervals_basis_Subq_R_standard_basis b HbB). }
	      witness b.
	      apply andI.
	      - exact HbStd.
	      - apply andI.
	        + exact Hxb.
	        + exact HbsubU.
	    }
	    exact (SepI (Power R)
	            (fun U0 : set => forall x0 :e U0, exists b :e R_standard_basis, x0 :e b /\ b c= U0)
	            U
	            HUpow
	            HUstdprop).
	  + let U. assume HU: U :e R_standard_topology.
	    prove U :e generated_topology R rational_open_intervals_basis.
	    (** Unpack U membership in R_standard_topology = generated_topology R R_standard_basis **)
	    claim HUpow: U :e Power R.
	    { exact (SepE1 (Power R)
	             (fun U0 : set => forall x0 :e U0, exists b :e R_standard_basis, x0 :e b /\ b c= U0)
	             U
	             HU). }
	    claim HUprop: forall x0 :e U, exists b :e R_standard_basis, x0 :e b /\ b c= U.
	    { exact (SepE2 (Power R)
	             (fun U0 : set => forall x0 :e U0, exists b :e R_standard_basis, x0 :e b /\ b c= U0)
	             U
	             HU). }
	    claim HUsubR: U c= R.
	    { exact (PowerE R U HUpow). }
	    prove U :e {U0 :e Power R | forall x0 :e U0, exists b :e rational_open_intervals_basis, x0 :e b /\ b c= U0}.
	    apply SepI.
	    - exact HUpow.
	    - let x. assume HxU: x :e U.
	      claim HxR: x :e R.
	      { exact (HUsubR x HxU). }
	      apply (HUprop x HxU).
	      let I. assume HIpair.
	      claim HIStd: I :e R_standard_basis.
	      { exact (andEL (I :e R_standard_basis) (x :e I /\ I c= U) HIpair). }
	      claim HIprop: x :e I /\ I c= U.
	      { exact (andER (I :e R_standard_basis) (x :e I /\ I c= U) HIpair). }
	      claim HxI: x :e I.
	      { exact (andEL (x :e I) (I c= U) HIprop). }
	      claim HIsubU: I c= U.
	      { exact (andER (x :e I) (I c= U) HIprop). }
	      (** Destruct I as an open_interval a b with a,b in R **)
	      claim Hexa: exists a :e R, I :e {open_interval a b|b :e R}.
	      { exact (famunionE R (fun a0 : set => {open_interval a0 b|b :e R}) I HIStd). }
	      apply Hexa.
	      let a. assume Hapair. apply Hapair.
	      assume HaR: a :e R.
	      assume HIfam: I :e {open_interval a b|b :e R}.
	      claim Hexb: exists b :e R, I = open_interval a b.
	      { exact (ReplE R (fun b0 : set => open_interval a b0) I HIfam). }
	      apply Hexb.
	      let b. assume Hbpair. apply Hbpair.
	      assume HbR: b :e R.
	      assume HIeq: I = open_interval a b.
	      claim HxInab: x :e open_interval a b.
	      { rewrite <- HIeq. exact HxI. }
	      (** refine the real interval (a,b) to a rational interval around x **)
	      claim HexRat: exists q1 :e rational_numbers, exists q2 :e rational_numbers,
	        x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a b.
	      { exact (rational_interval_refines_real_interval a b x HaR HbR HxR HxInab). }
	      apply HexRat.
	      let q1. assume Hq1pair. apply Hq1pair.
	      assume Hq1Q: q1 :e rational_numbers.
	      assume Hexq2: exists q2 :e rational_numbers,
	        x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a b.
	      apply Hexq2.
	      let q2. assume Hq2pair. apply Hq2pair.
	      assume Hq2Q: q2 :e rational_numbers.
	      assume HxInQ: x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a b.
	      claim HxInQint: x :e open_interval q1 q2.
	      { exact (andEL (x :e open_interval q1 q2) (open_interval q1 q2 c= open_interval a b) HxInQ). }
	      claim HQsub: open_interval q1 q2 c= open_interval a b.
	      { exact (andER (x :e open_interval q1 q2) (open_interval q1 q2 c= open_interval a b) HxInQ). }
	      claim HabsubU: open_interval a b c= U.
	      { rewrite <- HIeq.
	        exact HIsubU. }
	      claim HQsubU: open_interval q1 q2 c= U.
	      { exact (Subq_tra (open_interval q1 q2) (open_interval a b) U HQsub HabsubU). }
	      (** show open_interval q1 q2 is in rational_open_intervals_basis **)
	      claim Hq2fam : open_interval q1 q2 :e {open_interval q1 q2'|q2' :e rational_numbers}.
	      { exact (ReplI rational_numbers (fun q2' : set => open_interval q1 q2') q2 Hq2Q). }
	      claim HbInB: open_interval q1 q2 :e rational_open_intervals_basis.
	      { exact (famunionI rational_numbers
	               (fun q1' : set => {open_interval q1' q2'|q2' :e rational_numbers})
	               q1
	               (open_interval q1 q2)
	               Hq1Q
	               Hq2fam). }
	      witness (open_interval q1 q2).
	      apply andI.
	      * exact HbInB.
	      * apply andI.
	        { exact HxInQint. }
	        { exact HQsubU. }
Qed.

(** from 13 Exercise 8(b): half-open rational intervals generate a different topology **) 
(** LATEX VERSION: Exercise 8(b): Half-open rational intervals form a basis whose generated topology differs from the lower limit topology. **)
Definition rational_halfopen_intervals_basis : set :=
  \/_ q1 :e rational_numbers, {halfopen_interval_left q1 q2|q2 :e rational_numbers}.

(** LATEX VERSION: The half-open rational basis generates a topology distinct from the lower limit topology. **)
Theorem ex13_8b_halfopen_rational_basis_topology :
  basis_on R rational_halfopen_intervals_basis /\
  generated_topology R rational_halfopen_intervals_basis <> R_lower_limit_topology.
prove basis_on R rational_halfopen_intervals_basis /\ generated_topology R rational_halfopen_intervals_basis <> R_lower_limit_topology.
(** NOTE: This similarly needs density of rationals plus a separation argument showing
    the generated topology from halfopen rational intervals does not coincide with
    the lower limit topology on `R`. As in (a), `real_E` plus `Subq_SNoS_omega_rational` should supply many rational
    endpoints once the relevant order/epsilon inequalities are available. **)
apply andI.
- (** rational half-open intervals satisfy basis_on R (partial: subset property) **)
  prove rational_halfopen_intervals_basis c= Power R
    /\ (forall x :e R, exists b :e rational_halfopen_intervals_basis, x :e b)
    /\ (forall b1 :e rational_halfopen_intervals_basis, forall b2 :e rational_halfopen_intervals_basis, forall x:set,
          x :e b1 -> x :e b2 ->
          exists b3 :e rational_halfopen_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2).
  apply andI.
  - prove rational_halfopen_intervals_basis c= Power R /\ (forall x :e R, exists b :e rational_halfopen_intervals_basis, x :e b).
    apply andI.
	    + (** every rational half-open interval is a subset of R **)
	      prove rational_halfopen_intervals_basis c= Power R.
      let b. assume Hb: b :e rational_halfopen_intervals_basis.
      prove b :e Power R.
      apply (famunionE_impred rational_numbers
               (fun q1 : set => {halfopen_interval_left q1 q2|q2 :e rational_numbers})
               b
               Hb
               (b :e Power R)).
      let q1. assume Hq1 Hbq1.
      apply (ReplE_impred rational_numbers
               (fun q2 : set => halfopen_interval_left q1 q2)
               b
               Hbq1
               (b :e Power R)).
      let q2. assume Hq2 Heq.
	      rewrite Heq.
	      exact (PowerI R (halfopen_interval_left q1 q2) (halfopen_interval_left_Subq_R q1 q2)).
	    + (** coverage of R by rational half-open intervals **)
	      prove forall x :e R, exists b :e rational_halfopen_intervals_basis, x :e b.
	      let x. assume HxR.
	      set a0 := add_SNo x (minus_SNo 1).
	      set b0 := add_SNo x 1.
	      claim Hm1R : minus_SNo 1 :e R.
	      { exact (real_minus_SNo 1 real_1). }
	      claim Ha0R : a0 :e R.
	      { exact (real_add_SNo x HxR (minus_SNo 1) Hm1R). }
	      claim Hb0R : b0 :e R.
	      { exact (real_add_SNo x HxR 1 real_1). }
	      claim HxInab : x :e open_interval a0 b0.
	      { exact (real_in_open_interval_minus1_plus1 x HxR). }
	      claim HexRat: exists q1 :e rational_numbers, exists q2 :e rational_numbers,
	        x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a0 b0.
	      { exact (rational_interval_refines_real_interval a0 b0 x Ha0R Hb0R HxR HxInab). }
	      apply HexRat.
	      let q1. assume Hq1pair. apply Hq1pair.
	      assume Hq1Q: q1 :e rational_numbers.
	      assume Hexq2: exists q2 :e rational_numbers,
	        x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a0 b0.
	      apply Hexq2.
	      let q2. assume Hq2pair. apply Hq2pair.
	      assume Hq2Q: q2 :e rational_numbers.
	      assume Hxpair: x :e open_interval q1 q2 /\ open_interval q1 q2 c= open_interval a0 b0.
	      claim HxInQ : x :e open_interval q1 q2.
	      { exact (andEL (x :e open_interval q1 q2) (open_interval q1 q2 c= open_interval a0 b0) Hxpair). }
	      claim HxInQprop : Rlt q1 x /\ Rlt x q2.
	      { exact (SepE2 R (fun z : set => Rlt q1 z /\ Rlt z q2) x HxInQ). }
	      claim Hq1x : Rlt q1 x.
	      { exact (andEL (Rlt q1 x) (Rlt x q2) HxInQprop). }
	      claim Hxq2 : Rlt x q2.
	      { exact (andER (Rlt q1 x) (Rlt x q2) HxInQprop). }
	      set I := halfopen_interval_left q1 q2.
	      claim HIinFam : I :e {halfopen_interval_left q1 qq|qq :e rational_numbers}.
	      { exact (ReplI rational_numbers (fun qq : set => halfopen_interval_left q1 qq) q2 Hq2Q). }
	      claim HIinB : I :e rational_halfopen_intervals_basis.
	      { exact (famunionI rational_numbers
	               (fun aa : set => {halfopen_interval_left aa bb|bb :e rational_numbers})
	               q1
	               I
	               Hq1Q
	               HIinFam). }
	      claim Hnxq1 : ~(Rlt x q1).
	      { assume Hxq1 : Rlt x q1.
	        claim HxS : SNo x.
	        { exact (real_SNo x HxR). }
	        claim Hq1R : q1 :e R.
	        { exact (rational_numbers_in_R q1 Hq1Q). }
	        claim Hq1S : SNo q1.
	        { exact (real_SNo q1 Hq1R). }
	        claim Hxq1lt : x < q1.
	        { exact (RltE_lt x q1 Hxq1). }
	        claim Hq1xlt : q1 < x.
	        { exact (RltE_lt q1 x Hq1x). }
	        claim Hxxlt : x < x.
	        { exact (SNoLt_tra x q1 x HxS Hq1S HxS Hxq1lt Hq1xlt). }
	        exact ((SNoLt_irref x) Hxxlt). }
	      claim HxInI : x :e I.
	      { claim Hconj : ~(Rlt x q1) /\ Rlt x q2.
	        { apply andI.
	          - exact Hnxq1.
	          - exact Hxq2. }
	        exact (SepI R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) x HxR Hconj). }
	      witness I.
	      apply andI.
	      * exact HIinB.
	      * exact HxInI.
		  - (** intersection refinement using rational endpoints **)
		    let b1. assume Hb1.
		    let b2. assume Hb2.
		    let x. assume Hx1 Hx2.
	    prove exists b3 :e rational_halfopen_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2.
	    (** destruct b1 = halfopen_interval_left q1 q2 with q1,q2 rationals **)
	    claim Hexq1 : exists q1 :e rational_numbers, b1 :e {halfopen_interval_left q1 q2|q2 :e rational_numbers}.
	    { exact (famunionE rational_numbers (fun q1 : set => {halfopen_interval_left q1 q2|q2 :e rational_numbers}) b1 Hb1). }
	    apply Hexq1.
	    let q1. assume Hq1pair. apply Hq1pair.
	    assume Hq1Q : q1 :e rational_numbers.
	    assume Hb1fam : b1 :e {halfopen_interval_left q1 q2|q2 :e rational_numbers}.
	    claim Hexq2 : exists q2 :e rational_numbers, b1 = halfopen_interval_left q1 q2.
	    { exact (ReplE rational_numbers (fun q2 : set => halfopen_interval_left q1 q2) b1 Hb1fam). }
	    apply Hexq2.
	    let q2. assume Hq2pair. apply Hq2pair.
	    assume Hq2Q : q2 :e rational_numbers.
	    assume Hb1eq : b1 = halfopen_interval_left q1 q2.
	    (** destruct b2 = halfopen_interval_left r1 r2 with r1,r2 rationals **)
	    claim Hexr1 : exists r1 :e rational_numbers, b2 :e {halfopen_interval_left r1 r2|r2 :e rational_numbers}.
	    { exact (famunionE rational_numbers (fun r1 : set => {halfopen_interval_left r1 r2|r2 :e rational_numbers}) b2 Hb2). }
	    apply Hexr1.
	    let r1. assume Hr1pair. apply Hr1pair.
	    assume Hr1Q : r1 :e rational_numbers.
	    assume Hb2fam : b2 :e {halfopen_interval_left r1 r2|r2 :e rational_numbers}.
	    claim Hexr2 : exists r2 :e rational_numbers, b2 = halfopen_interval_left r1 r2.
	    { exact (ReplE rational_numbers (fun r2 : set => halfopen_interval_left r1 r2) b2 Hb2fam). }
	    apply Hexr2.
	    let r2. assume Hr2pair. apply Hr2pair.
	    assume Hr2Q : r2 :e rational_numbers.
	    assume Hb2eq : b2 = halfopen_interval_left r1 r2.
	    (** x in the two half-open intervals **)
	    claim HxIn1 : x :e halfopen_interval_left q1 q2.
	    { rewrite <- Hb1eq. exact Hx1. }
	    claim HxIn2 : x :e halfopen_interval_left r1 r2.
	    { rewrite <- Hb2eq. exact Hx2. }
	    claim HxR : x :e R.
	    { exact (SepE1 R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) x HxIn1). }
	    claim HxProp1 : ~(Rlt x q1) /\ Rlt x q2.
	    { exact (SepE2 R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) x HxIn1). }
	    claim HxProp2 : ~(Rlt x r1) /\ Rlt x r2.
	    { exact (SepE2 R (fun z : set => ~(Rlt z r1) /\ Rlt z r2) x HxIn2). }
	    claim Hnxq1 : ~(Rlt x q1).
	    { exact (andEL (~(Rlt x q1)) (Rlt x q2) HxProp1). }
	    claim Hxq2 : Rlt x q2.
	    { exact (andER (~(Rlt x q1)) (Rlt x q2) HxProp1). }
	    claim Hnxr1 : ~(Rlt x r1).
	    { exact (andEL (~(Rlt x r1)) (Rlt x r2) HxProp2). }
	    claim Hxr2 : Rlt x r2.
	    { exact (andER (~(Rlt x r1)) (Rlt x r2) HxProp2). }
	    (** endpoint types **)
	    claim Hq1R : q1 :e R.
	    { exact (rational_numbers_in_R q1 Hq1Q). }
	    claim Hq2R : q2 :e R.
	    { exact (rational_numbers_in_R q2 Hq2Q). }
	    claim Hr1R : r1 :e R.
	    { exact (rational_numbers_in_R r1 Hr1Q). }
	    claim Hr2R : r2 :e R.
	    { exact (rational_numbers_in_R r2 Hr2Q). }
	    claim Hq1S : SNo q1.
	    { exact (real_SNo q1 Hq1R). }
	    claim Hq2S : SNo q2.
	    { exact (real_SNo q2 Hq2R). }
	    claim Hr1S : SNo r1.
	    { exact (real_SNo r1 Hr1R). }
	    claim Hr2S : SNo r2.
	    { exact (real_SNo r2 Hr2R). }
	    claim HxS : SNo x.
	    { exact (real_SNo x HxR). }
	    claim Hxq2lt : x < q2.
	    { exact (RltE_lt x q2 Hxq2). }
	    claim Hxr2lt : x < r2.
	    { exact (RltE_lt x r2 Hxr2). }
	    (** choose max left endpoint and min right endpoint by trichotomy **)
	    apply (SNoLt_trichotomy_or_impred q1 r1 Hq1S Hr1S
	             (exists b3 :e rational_halfopen_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
	    - assume Hq1lt : q1 < r1.
	      (** left endpoint r1 **)
	      apply (SNoLt_trichotomy_or_impred q2 r2 Hq2S Hr2S
	               (exists b3 :e rational_halfopen_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
	      + assume Hq2lt : q2 < r2.
	        (** right endpoint q2 **)
	        set I3 := halfopen_interval_left r1 q2.
	        witness I3.
	        apply andI.
	        * (** I3 in basis **)
	          claim HI3fam : I3 :e {halfopen_interval_left r1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => halfopen_interval_left r1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {halfopen_interval_left aa bb|bb :e rational_numbers})
	                   r1
	                   I3
	                   Hr1Q
	                   HI3fam).
	        * apply andI.
	          { (** x in I3 **)
	            claim Hconj : ~(Rlt x r1) /\ Rlt x q2.
	            { apply andI.
	              - exact Hnxr1.
	              - exact Hxq2. }
	            exact (SepI R (fun z : set => ~(Rlt z r1) /\ Rlt z q2) x HxR Hconj). }
	          { (** I3 subset b1  b2 **)
	            let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => ~(Rlt z r1) /\ Rlt z q2) y HyI3). }
	            claim HyProp : ~(Rlt y r1) /\ Rlt y q2.
	            { exact (SepE2 R (fun z : set => ~(Rlt z r1) /\ Rlt z q2) y HyI3). }
	            claim Hnyr1 : ~(Rlt y r1).
	            { exact (andEL (~(Rlt y r1)) (Rlt y q2) HyProp). }
	            claim Hyq2 : Rlt y q2.
	            { exact (andER (~(Rlt y r1)) (Rlt y q2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hyq2lt : y < q2.
	            { exact (RltE_lt y q2 Hyq2). }
	            (** y in b2: y < r2 since y<q2 and q2<r2 **)
	            claim Hyr2lt : y < r2.
	            { exact (SNoLt_tra y q2 r2 HyS Hq2S Hr2S Hyq2lt Hq2lt). }
	            claim Hyr2 : Rlt y r2.
	            { exact (RltI y r2 HyR Hr2R Hyr2lt). }
	            claim HyIn2 : y :e halfopen_interval_left r1 r2.
	            { exact (SepI R (fun z : set => ~(Rlt z r1) /\ Rlt z r2) y HyR
	                         (andI (~(Rlt y r1)) (Rlt y r2) Hnyr1 Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            (** y in b1: need ~(Rlt y q1) and Rlt y q2 (already) **)
	            claim Hnyq1 : ~(Rlt y q1).
	            { assume Hyq1 : Rlt y q1.
	              claim Hyq1lt : y < q1.
	              { exact (RltE_lt y q1 Hyq1). }
	              claim Hyr1lt : y < r1.
	              { exact (SNoLt_tra y q1 r1 HyS Hq1S Hr1S Hyq1lt Hq1lt). }
	              claim Hyr1 : Rlt y r1.
	              { exact (RltI y r1 HyR Hr1R Hyr1lt). }
	              exact (Hnyr1 Hyr1). }
	            claim HyIn1 : y :e halfopen_interval_left q1 q2.
	            { exact (SepI R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyR
	                         (andI (~(Rlt y q1)) (Rlt y q2) Hnyq1 Hyq2)). }
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyIn1. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hq2eq : q2 = r2.
	        set I3 := halfopen_interval_left r1 q2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {halfopen_interval_left r1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => halfopen_interval_left r1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {halfopen_interval_left aa bb|bb :e rational_numbers})
	                   r1
	                   I3
	                   Hr1Q
	                   HI3fam).
	        * apply andI.
	          { exact (SepI R (fun z : set => ~(Rlt z r1) /\ Rlt z q2) x HxR
	                         (andI (~(Rlt x r1)) (Rlt x q2) Hnxr1 Hxq2)). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => ~(Rlt z r1) /\ Rlt z q2) y HyI3). }
	            claim HyProp : ~(Rlt y r1) /\ Rlt y q2.
	            { exact (SepE2 R (fun z : set => ~(Rlt z r1) /\ Rlt z q2) y HyI3). }
	            claim Hnyr1 : ~(Rlt y r1).
	            { exact (andEL (~(Rlt y r1)) (Rlt y q2) HyProp). }
	            claim Hyq2 : Rlt y q2.
	            { exact (andER (~(Rlt y r1)) (Rlt y q2) HyProp). }
	            claim Hyr2 : Rlt y r2.
	            { rewrite <- Hq2eq. exact Hyq2. }
	            claim HyIn2 : y :e halfopen_interval_left r1 r2.
	            { exact (SepI R (fun z : set => ~(Rlt z r1) /\ Rlt z r2) y HyR
	                         (andI (~(Rlt y r1)) (Rlt y r2) Hnyr1 Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            claim Hnyq1 : ~(Rlt y q1).
	            { assume Hyq1 : Rlt y q1.
	              claim HyS : SNo y.
	              { exact (real_SNo y HyR). }
	              claim Hyq1lt : y < q1.
	              { exact (RltE_lt y q1 Hyq1). }
	              claim Hyr1lt : y < r1.
	              { exact (SNoLt_tra y q1 r1 HyS Hq1S Hr1S Hyq1lt Hq1lt). }
	              claim Hyr1 : Rlt y r1.
	              { exact (RltI y r1 HyR Hr1R Hyr1lt). }
	              exact (Hnyr1 Hyr1). }
	            claim HyIn1 : y :e halfopen_interval_left q1 q2.
	            { exact (SepI R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyR
	                         (andI (~(Rlt y q1)) (Rlt y q2) Hnyq1 Hyq2)). }
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyIn1. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hr2lt : r2 < q2.
	        (** right endpoint r2 **)
	        set I3 := halfopen_interval_left r1 r2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {halfopen_interval_left r1 rr|rr :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun rr : set => halfopen_interval_left r1 rr) r2 Hr2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {halfopen_interval_left aa bb|bb :e rational_numbers})
	                   r1
	                   I3
	                   Hr1Q
	                   HI3fam).
	        * apply andI.
	          { (** x in I3 **)
	            claim Hconj : ~(Rlt x r1) /\ Rlt x r2.
	            { apply andI.
	              - exact Hnxr1.
	              - exact Hxr2. }
	            exact (SepI R (fun z : set => ~(Rlt z r1) /\ Rlt z r2) x HxR Hconj). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => ~(Rlt z r1) /\ Rlt z r2) y HyI3). }
	            claim HyProp : ~(Rlt y r1) /\ Rlt y r2.
	            { exact (SepE2 R (fun z : set => ~(Rlt z r1) /\ Rlt z r2) y HyI3). }
	            claim Hnyr1 : ~(Rlt y r1).
	            { exact (andEL (~(Rlt y r1)) (Rlt y r2) HyProp). }
	            claim Hyr2 : Rlt y r2.
	            { exact (andER (~(Rlt y r1)) (Rlt y r2) HyProp). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyI3. }
	            (** y in b1: need Rlt y q2 since r2<q2 **)
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hyr2lt : y < r2.
	            { exact (RltE_lt y r2 Hyr2). }
	            claim Hyq2lt : y < q2.
	            { exact (SNoLt_tra y r2 q2 HyS Hr2S Hq2S Hyr2lt Hr2lt). }
	            claim Hyq2 : Rlt y q2.
	            { exact (RltI y q2 HyR Hq2R Hyq2lt). }
	            claim Hnyq1 : ~(Rlt y q1).
	            { assume Hyq1 : Rlt y q1.
	              claim Hyq1lt : y < q1.
	              { exact (RltE_lt y q1 Hyq1). }
	              claim Hyr1lt : y < r1.
	              { exact (SNoLt_tra y q1 r1 HyS Hq1S Hr1S Hyq1lt Hq1lt). }
	              claim Hyr1 : Rlt y r1.
	              { exact (RltI y r1 HyR Hr1R Hyr1lt). }
	              exact (Hnyr1 Hyr1). }
	            claim HyIn1 : y :e halfopen_interval_left q1 q2.
	            { exact (SepI R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyR
	                         (andI (~(Rlt y q1)) (Rlt y q2) Hnyq1 Hyq2)). }
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyIn1. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	    - assume Hq1eq : q1 = r1.
	      (** left endpoint q1 **)
	      apply (SNoLt_trichotomy_or_impred q2 r2 Hq2S Hr2S
	               (exists b3 :e rational_halfopen_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
	      + assume Hq2lt : q2 < r2.
	        set I3 := halfopen_interval_left q1 q2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {halfopen_interval_left q1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => halfopen_interval_left q1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {halfopen_interval_left aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
		        * apply andI.
		          { exact HxIn1. }
		          { let y. assume HyI3 : y :e I3.
		            prove y :e b1 :/\: b2.
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyI3. }
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyI3). }
	            claim HyProp : ~(Rlt y q1) /\ Rlt y q2.
	            { exact (SepE2 R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyI3). }
	            claim Hnyq1 : ~(Rlt y q1).
	            { exact (andEL (~(Rlt y q1)) (Rlt y q2) HyProp). }
	            claim Hyq2 : Rlt y q2.
	            { exact (andER (~(Rlt y q1)) (Rlt y q2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hyq2lt : y < q2.
	            { exact (RltE_lt y q2 Hyq2). }
	            claim Hyr2lt : y < r2.
	            { exact (SNoLt_tra y q2 r2 HyS Hq2S Hr2S Hyq2lt Hq2lt). }
	            claim Hyr2 : Rlt y r2.
	            { exact (RltI y r2 HyR Hr2R Hyr2lt). }
	            claim HyIn2 : y :e halfopen_interval_left r1 r2.
	            { rewrite <- Hq1eq at 1.
	              exact (SepI R (fun z : set => ~(Rlt z q1) /\ Rlt z r2) y HyR
	                           (andI (~(Rlt y q1)) (Rlt y r2) Hnyq1 Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hq2eq : q2 = r2.
	        set I3 := halfopen_interval_left q1 q2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {halfopen_interval_left q1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => halfopen_interval_left q1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {halfopen_interval_left aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
		        * apply andI.
		          { exact HxIn1. }
		          { let y. assume HyI3 : y :e I3.
		            prove y :e b1 :/\: b2.
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyI3. }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. rewrite <- Hq1eq. rewrite <- Hq2eq. exact HyI3. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hr2lt : r2 < q2.
	        set I3 := halfopen_interval_left q1 r2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {halfopen_interval_left q1 rr|rr :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun rr : set => halfopen_interval_left q1 rr) r2 Hr2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {halfopen_interval_left aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
		        * apply andI.
		          { claim Hconj : ~(Rlt x q1) /\ Rlt x r2.
		            { apply andI.
		              - exact Hnxq1.
		              - exact Hxr2. }
		            exact (SepI R (fun z : set => ~(Rlt z q1) /\ Rlt z r2) x HxR Hconj). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => ~(Rlt z q1) /\ Rlt z r2) y HyI3). }
	            claim HyProp : ~(Rlt y q1) /\ Rlt y r2.
	            { exact (SepE2 R (fun z : set => ~(Rlt z q1) /\ Rlt z r2) y HyI3). }
	            claim Hnyq1 : ~(Rlt y q1).
	            { exact (andEL (~(Rlt y q1)) (Rlt y r2) HyProp). }
	            claim Hyr2 : Rlt y r2.
	            { exact (andER (~(Rlt y q1)) (Rlt y r2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hyr2lt : y < r2.
	            { exact (RltE_lt y r2 Hyr2). }
	            claim Hyq2lt : y < q2.
	            { exact (SNoLt_tra y r2 q2 HyS Hr2S Hq2S Hyr2lt Hr2lt). }
	            claim Hyq2 : Rlt y q2.
	            { exact (RltI y q2 HyR Hq2R Hyq2lt). }
	            claim HyIn1 : y :e halfopen_interval_left q1 q2.
	            { exact (SepI R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyR
	                         (andI (~(Rlt y q1)) (Rlt y q2) Hnyq1 Hyq2)). }
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyIn1. }
	            claim HyIn2 : y :e halfopen_interval_left r1 r2.
	            { rewrite <- Hq1eq at 1.
	              exact (SepI R (fun z : set => ~(Rlt z q1) /\ Rlt z r2) y HyR
	                           (andI (~(Rlt y q1)) (Rlt y r2) Hnyq1 Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	    - assume Hr1lt : r1 < q1.
	      (** left endpoint q1 **)
	      apply (SNoLt_trichotomy_or_impred q2 r2 Hq2S Hr2S
	               (exists b3 :e rational_halfopen_intervals_basis, x :e b3 /\ b3 c= b1 :/\: b2)).
	      + assume Hq2lt : q2 < r2.
	        set I3 := halfopen_interval_left q1 q2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {halfopen_interval_left q1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => halfopen_interval_left q1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {halfopen_interval_left aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
	        * apply andI.
	          { exact HxIn1. }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyI3. }
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyI3). }
	            claim HyProp : ~(Rlt y q1) /\ Rlt y q2.
	            { exact (SepE2 R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyI3). }
	            claim Hnyq1 : ~(Rlt y q1).
	            { exact (andEL (~(Rlt y q1)) (Rlt y q2) HyProp). }
	            claim Hyq2 : Rlt y q2.
	            { exact (andER (~(Rlt y q1)) (Rlt y q2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hyq2lt : y < q2.
	            { exact (RltE_lt y q2 Hyq2). }
	            claim Hyr2lt : y < r2.
	            { exact (SNoLt_tra y q2 r2 HyS Hq2S Hr2S Hyq2lt Hq2lt). }
	            claim Hyr2 : Rlt y r2.
	            { exact (RltI y r2 HyR Hr2R Hyr2lt). }
	            claim Hnyr1 : ~(Rlt y r1).
	            { assume Hyr1 : Rlt y r1.
	              claim Hyr1lt : y < r1.
	              { exact (RltE_lt y r1 Hyr1). }
	              claim Hyq1lt : y < q1.
	              { exact (SNoLt_tra y r1 q1 HyS Hr1S Hq1S Hyr1lt Hr1lt). }
	              claim Hyq1 : Rlt y q1.
	              { exact (RltI y q1 HyR Hq1R Hyq1lt). }
	              exact (Hnyq1 Hyq1). }
	            claim HyIn2 : y :e halfopen_interval_left r1 r2.
	            { exact (SepI R (fun z : set => ~(Rlt z r1) /\ Rlt z r2) y HyR
	                         (andI (~(Rlt y r1)) (Rlt y r2) Hnyr1 Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hq2eq : q2 = r2.
	        set I3 := halfopen_interval_left q1 q2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {halfopen_interval_left q1 qq|qq :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun qq : set => halfopen_interval_left q1 qq) q2 Hq2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {halfopen_interval_left aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
	        * apply andI.
	          { exact HxIn1. }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyI3. }
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyI3). }
	            claim HyProp : ~(Rlt y q1) /\ Rlt y q2.
	            { exact (SepE2 R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyI3). }
	            claim Hnyq1 : ~(Rlt y q1).
	            { exact (andEL (~(Rlt y q1)) (Rlt y q2) HyProp). }
	            claim Hyq2 : Rlt y q2.
	            { exact (andER (~(Rlt y q1)) (Rlt y q2) HyProp). }
	            claim Hyr2 : Rlt y r2.
	            { rewrite <- Hq2eq. exact Hyq2. }
	            claim Hnyr1 : ~(Rlt y r1).
	            { assume Hyr1 : Rlt y r1.
	              claim HyS : SNo y.
	              { exact (real_SNo y HyR). }
	              claim Hyr1lt : y < r1.
	              { exact (RltE_lt y r1 Hyr1). }
	              claim Hyq1lt : y < q1.
	              { exact (SNoLt_tra y r1 q1 HyS Hr1S Hq1S Hyr1lt Hr1lt). }
	              claim Hyq1 : Rlt y q1.
	              { exact (RltI y q1 HyR Hq1R Hyq1lt). }
	              exact (Hnyq1 Hyq1). }
	            claim HyIn2 : y :e halfopen_interval_left r1 r2.
	            { exact (SepI R (fun z : set => ~(Rlt z r1) /\ Rlt z r2) y HyR
	                         (andI (~(Rlt y r1)) (Rlt y r2) Hnyr1 Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	      + assume Hr2lt : r2 < q2.
	        set I3 := halfopen_interval_left q1 r2.
	        witness I3.
	        apply andI.
	        * claim HI3fam : I3 :e {halfopen_interval_left q1 rr|rr :e rational_numbers}.
	          { exact (ReplI rational_numbers (fun rr : set => halfopen_interval_left q1 rr) r2 Hr2Q). }
	          exact (famunionI rational_numbers
	                   (fun aa : set => {halfopen_interval_left aa bb|bb :e rational_numbers})
	                   q1
	                   I3
	                   Hq1Q
	                   HI3fam).
	        * apply andI.
	          { claim Hconj : ~(Rlt x q1) /\ Rlt x r2.
	            { apply andI.
	              - exact Hnxq1.
	              - exact Hxr2. }
	            exact (SepI R (fun z : set => ~(Rlt z q1) /\ Rlt z r2) x HxR Hconj). }
	          { let y. assume HyI3 : y :e I3.
	            prove y :e b1 :/\: b2.
	            claim HyR : y :e R.
	            { exact (SepE1 R (fun z : set => ~(Rlt z q1) /\ Rlt z r2) y HyI3). }
	            claim HyProp : ~(Rlt y q1) /\ Rlt y r2.
	            { exact (SepE2 R (fun z : set => ~(Rlt z q1) /\ Rlt z r2) y HyI3). }
	            claim Hnyq1 : ~(Rlt y q1).
	            { exact (andEL (~(Rlt y q1)) (Rlt y r2) HyProp). }
	            claim Hyr2 : Rlt y r2.
	            { exact (andER (~(Rlt y q1)) (Rlt y r2) HyProp). }
	            claim HyS : SNo y.
	            { exact (real_SNo y HyR). }
	            claim Hyr2lt : y < r2.
	            { exact (RltE_lt y r2 Hyr2). }
	            claim Hyq2lt : y < q2.
	            { exact (SNoLt_tra y r2 q2 HyS Hr2S Hq2S Hyr2lt Hr2lt). }
	            claim Hyq2 : Rlt y q2.
	            { exact (RltI y q2 HyR Hq2R Hyq2lt). }
	            claim HyIn1 : y :e halfopen_interval_left q1 q2.
	            { exact (SepI R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) y HyR
	                         (andI (~(Rlt y q1)) (Rlt y q2) Hnyq1 Hyq2)). }
	            claim Hyb1 : y :e b1.
	            { rewrite Hb1eq. exact HyIn1. }
	            claim Hnyr1 : ~(Rlt y r1).
	            { assume Hyr1 : Rlt y r1.
	              claim Hyr1lt : y < r1.
	              { exact (RltE_lt y r1 Hyr1). }
	              claim Hyq1lt : y < q1.
	              { exact (SNoLt_tra y r1 q1 HyS Hr1S Hq1S Hyr1lt Hr1lt). }
	              claim Hyq1 : Rlt y q1.
	              { exact (RltI y q1 HyR Hq1R Hyq1lt). }
	              exact (Hnyq1 Hyq1). }
	            claim HyIn2 : y :e halfopen_interval_left r1 r2.
	            { exact (SepI R (fun z : set => ~(Rlt z r1) /\ Rlt z r2) y HyR
	                         (andI (~(Rlt y r1)) (Rlt y r2) Hnyr1 Hyr2)). }
	            claim Hyb2 : y :e b2.
	            { rewrite Hb2eq. exact HyIn2. }
	            exact (binintersectI b1 b2 y Hyb1 Hyb2). }
	- (** generated topology differs from R_lower_limit_topology **)
	  assume Heq: generated_topology R rational_halfopen_intervals_basis = R_lower_limit_topology.
	  set a := sqrt_SNo_nonneg 2.
	  set U := {x :e R | ~(Rlt x a)}.
	  claim HaDiff: a :e R :\: rational_numbers.
	  { exact sqrt_2_irrational. }
	  claim HaR: a :e R.
	  { exact (setminusE1 R rational_numbers a HaDiff). }
	  claim HaNotQ: a /:e rational_numbers.
	  { exact (setminusE2 R rational_numbers a HaDiff). }
	  (** U is open in the lower limit topology **)
	  claim HUinLower: U :e R_lower_limit_topology.
	  { prove U :e R_lower_limit_topology.
	    prove U :e generated_topology R R_lower_limit_basis.
	    prove U :e {U0 :e Power R | forall x0 :e U0, exists b0 :e R_lower_limit_basis, x0 :e b0 /\ b0 c= U0}.
	    claim HUsub: U c= R.
	    { let y. assume HyU.
	      exact (SepE1 R (fun z : set => ~(Rlt z a)) y HyU). }
	    claim HUpow: U :e Power R.
	    { exact (PowerI R U HUsub). }
	    claim HUprop: forall x0 :e U, exists b0 :e R_lower_limit_basis, x0 :e b0 /\ b0 c= U.
	    { let x0. assume Hx0U.
	      claim Hx0R: x0 :e R.
	      { exact (SepE1 R (fun z : set => ~(Rlt z a)) x0 Hx0U). }
	      claim Hnx0a: ~(Rlt x0 a).
	      { exact (SepE2 R (fun z : set => ~(Rlt z a)) x0 Hx0U). }
	      set b0 := add_SNo x0 1.
	      claim Hb0R: b0 :e R.
	      { exact (real_add_SNo x0 Hx0R 1 real_1). }
	      set I0 := halfopen_interval_left a b0.
	      claim HI0fam: I0 :e {halfopen_interval_left a bb|bb :e R}.
	      { exact (ReplI R (fun bb : set => halfopen_interval_left a bb) b0 Hb0R). }
	      claim HI0inB: I0 :e R_lower_limit_basis.
	      { exact (famunionI R (fun aa : set => {halfopen_interval_left aa bb|bb :e R}) a I0 HaR HI0fam). }
	      claim Hx0InStd: x0 :e open_interval (add_SNo x0 (minus_SNo 1)) b0.
	      { exact (real_in_open_interval_minus1_plus1 x0 Hx0R). }
	      claim Hx0StdProp: Rlt (add_SNo x0 (minus_SNo 1)) x0 /\ Rlt x0 b0.
	      { exact (SepE2 R (fun z : set => Rlt (add_SNo x0 (minus_SNo 1)) z /\ Rlt z b0) x0 Hx0InStd). }
	      claim Hx0b0: Rlt x0 b0.
	      { exact (andER (Rlt (add_SNo x0 (minus_SNo 1)) x0) (Rlt x0 b0) Hx0StdProp). }
	      claim Hx0InI0: x0 :e I0.
	      { claim Hconj: ~(Rlt x0 a) /\ Rlt x0 b0.
	        { apply andI.
	          - exact Hnx0a.
	          - exact Hx0b0. }
	        exact (SepI R (fun z : set => ~(Rlt z a) /\ Rlt z b0) x0 Hx0R Hconj). }
	      claim HI0subU: I0 c= U.
	      { let y. assume HyI0.
	        claim HyR: y :e R.
	        { exact (SepE1 R (fun z : set => ~(Rlt z a) /\ Rlt z b0) y HyI0). }
	        claim HyProp: ~(Rlt y a) /\ Rlt y b0.
	        { exact (SepE2 R (fun z : set => ~(Rlt z a) /\ Rlt z b0) y HyI0). }
	        claim Hnya: ~(Rlt y a).
	        { exact (andEL (~(Rlt y a)) (Rlt y b0) HyProp). }
	        exact (SepI R (fun z : set => ~(Rlt z a)) y HyR Hnya). }
	      witness I0.
	      apply andI.
	      - exact HI0inB.
	      - apply andI.
	        { exact Hx0InI0. }
	        { exact HI0subU. } }
	    exact (SepI (Power R)
	              (fun U0 : set => forall x0 :e U0, exists b0 :e R_lower_limit_basis, x0 :e b0 /\ b0 c= U0)
	              U
	              HUpow
	              HUprop). }
	  (** Using the assumed equality, U would be open in the rational half-open topology **)
	  claim HUinRat: U :e generated_topology R rational_halfopen_intervals_basis.
	  { rewrite Heq. exact HUinLower. }
	  claim HUpropRat: forall x0 :e U, exists b0 :e rational_halfopen_intervals_basis, x0 :e b0 /\ b0 c= U.
	  { exact (SepE2 (Power R)
	            (fun U0 : set => forall x0 :e U0, exists b0 :e rational_halfopen_intervals_basis, x0 :e b0 /\ b0 c= U0)
	            U
	            HUinRat). }
	  (** But a has no neighborhood inside U using rational left endpoints **)
	  claim HaU: a :e U.
	  { exact (SepI R (fun z : set => ~(Rlt z a)) a HaR (not_Rlt_refl a HaR)). }
	  apply (HUpropRat a HaU).
	  let b. assume Hbpair. apply Hbpair.
	  assume HbInB: b :e rational_halfopen_intervals_basis.
	  assume Hbrest: a :e b /\ b c= U.
	  claim Hab: a :e b.
	  { exact (andEL (a :e b) (b c= U) Hbrest). }
	  claim HbsubU: b c= U.
	  { exact (andER (a :e b) (b c= U) Hbrest). }
	  (** destruct b as [q1,q2) with rationals q1,q2 **)
	  claim Hexq1: exists q1 :e rational_numbers, b :e {halfopen_interval_left q1 q2|q2 :e rational_numbers}.
	  { exact (famunionE rational_numbers (fun q1 : set => {halfopen_interval_left q1 q2|q2 :e rational_numbers}) b HbInB). }
	  apply Hexq1.
	  let q1. assume Hq1pair. apply Hq1pair.
	  assume Hq1Q: q1 :e rational_numbers.
	  assume HbFam: b :e {halfopen_interval_left q1 q2|q2 :e rational_numbers}.
	  claim Hexq2: exists q2 :e rational_numbers, b = halfopen_interval_left q1 q2.
	  { exact (ReplE rational_numbers (fun q2 : set => halfopen_interval_left q1 q2) b HbFam). }
	  apply Hexq2.
	  let q2. assume Hq2pair. apply Hq2pair.
	  assume Hq2Q: q2 :e rational_numbers.
	  assume HbEq: b = halfopen_interval_left q1 q2.
	  claim Hq1R: q1 :e R.
	  { exact (rational_numbers_in_R q1 Hq1Q). }
	  claim Hq2R: q2 :e R.
	  { exact (rational_numbers_in_R q2 Hq2Q). }
	  claim Hq1S: SNo q1.
	  { exact (real_SNo q1 Hq1R). }
	  claim Hq2S: SNo q2.
	  { exact (real_SNo q2 Hq2R). }
	  claim HaS: SNo a.
	  { exact (real_SNo a HaR). }
		  claim HaInInt: a :e halfopen_interval_left q1 q2.
		  { rewrite <- HbEq. exact Hab. }
	  claim HaIntProp: ~(Rlt a q1) /\ Rlt a q2.
	  { exact (SepE2 R (fun z : set => ~(Rlt z q1) /\ Rlt z q2) a HaInInt). }
	  claim HnaRq1: ~(Rlt a q1).
	  { exact (andEL (~(Rlt a q1)) (Rlt a q2) HaIntProp). }
	  claim Haq2: Rlt a q2.
	  { exact (andER (~(Rlt a q1)) (Rlt a q2) HaIntProp). }
	  claim HnaLt: ~(a < q1).
	  { assume Haq1lt: a < q1.
	    claim Haq1: Rlt a q1.
	    { exact (RltI a q1 HaR Hq1R Haq1lt). }
	    exact (HnaRq1 Haq1). }
	  claim Hq1lta: q1 < a.
	  { apply (SNoLt_trichotomy_or_impred a q1 HaS Hq1S (q1 < a)).
	    - assume Haq1lt: a < q1.
	      apply FalseE.
	      exact (HnaLt Haq1lt).
		    - assume Haq1eq: a = q1.
		      claim HaQ: a :e rational_numbers.
		      { rewrite Haq1eq. exact Hq1Q. }
		      apply FalseE.
		      exact (HaNotQ HaQ).
	    - assume Hq1alt: q1 < a.
	      exact Hq1alt. }
	  claim Hq1a: Rlt q1 a.
	  { exact (RltI q1 a Hq1R HaR Hq1lta). }
	  claim Haq2lt: a < q2.
	  { exact (RltE_lt a q2 Haq2). }
	  claim Hq1q2lt: q1 < q2.
	  { exact (SNoLt_tra q1 a q2 Hq1S HaS Hq2S Hq1lta Haq2lt). }
	  claim Hq1q2: Rlt q1 q2.
	  { exact (RltI q1 q2 Hq1R Hq2R Hq1q2lt). }
	  claim Hq1Inb: q1 :e b.
	  { rewrite HbEq.
	    exact (halfopen_interval_left_leftmem q1 q2 Hq1q2). }
	  claim Hq1U: q1 :e U.
	  { exact (HbsubU q1 Hq1Inb). }
	  claim Hnq1a: ~(Rlt q1 a).
	  { exact (SepE2 R (fun z : set => ~(Rlt z a)) q1 Hq1U). }
	  exact (Hnq1a Hq1a).
	Qed.

(** from 14 Definition: basis for the order topology **) 
(** LATEX VERSION: For a simply ordered set X, the order-topology basis consists of all open intervals/rays; here represented abstractly. **)
(** FIXED: For dictionary order on R, a and b are ordered pairs (a1,a2) and (b1,b2),
    not Cartesian products a1a2 and b1b2.
    Was: a = setprod a1 a2 (which is a1a2, a SET of all pairs)
    Now: a = (a1,a2) (which is a SINGLE ordered pair) **)
(** SUSPICIOUS DEFINITION: `order_rel` is implemented as a case split over a small list of carrier sets used later; this is not a general interface for simply ordered sets and may force later axioms. **)
Definition order_rel : set -> set -> set -> prop := fun X a b =>
  (X = R /\ Rlt a b)
  \/
  (X = rational_numbers /\ Rlt a b)
  \/
  (X = omega /\ a :e b)
  \/
  (X = omega :\: {0} /\ a :e b)
  \/
  (X = setprod 2 omega /\
   exists i m j n:set,
     i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
     a = (i, m) /\ b = (j, n) /\
     (i :e j \/ (i = j /\ m :e n)))
  \/
  (X = setprod R R /\
   exists a1 a2 b1 b2:set,
     a = (a1, a2) /\ b = (b1, b2) /\
     (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))).

(** Helper: strict order on  implies order_rel on  **)
(** LATEX VERSION: If a<b in  then order_rel(,a,b) holds (first disjunct in the definition). **)
Theorem Rlt_implies_order_rel_R : forall a b:set, Rlt a b -> order_rel R a b.
let a b. assume Hab.
prove order_rel R a b.
(** Unfold `order_rel` at X = R. **)
prove (R = R /\ Rlt a b)
  \/
  (R = rational_numbers /\ Rlt a b)
  \/
  (R = omega /\ a :e b)
  \/
  (R = omega :\: {0} /\ a :e b)
  \/
  (R = setprod 2 omega /\
   exists i m j n:set,
     i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
     a = (i, m) /\ b = (j, n) /\
     (i :e j \/ (i = j /\ m :e n)))
  \/
  (R = setprod R R /\
   exists a1 a2 b1 b2:set,
     a = (a1, a2) /\ b = (b1, b2) /\
     (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))).
(** `\/` is left-associative; inject into the leftmost disjunct repeatedly. **)
apply orIL.
apply orIL.
apply orIL.
apply orIL.
apply orIL.
prove R = R /\ Rlt a b.
apply andI.
- reflexivity.
- exact Hab.
Qed.

(** Helper: strict order on  implies order_rel on  **)
(** LATEX VERSION: If a<b in  then order_rel(,a,b) holds (second disjunct in the definition). **)
Theorem Rlt_implies_order_rel_Q : forall a b:set, Rlt a b -> order_rel rational_numbers a b.
let a b. assume Hab.
prove order_rel rational_numbers a b.
(** Unfold `order_rel` at X = rational_numbers. **)
prove (rational_numbers = R /\ Rlt a b)
  \/
  (rational_numbers = rational_numbers /\ Rlt a b)
  \/
  (rational_numbers = omega /\ a :e b)
  \/
  (rational_numbers = omega :\: {0} /\ a :e b)
  \/
  (rational_numbers = setprod 2 omega /\
   exists i m j n:set,
     i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
     a = (i, m) /\ b = (j, n) /\
     (i :e j \/ (i = j /\ m :e n)))
  \/
  (rational_numbers = setprod R R /\
   exists a1 a2 b1 b2:set,
     a = (a1, a2) /\ b = (b1, b2) /\
     (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))).
(** Reach the inner disjunction (A \/ B), then choose B. **)
apply orIL.
apply orIL.
apply orIL.
apply orIL.
apply orIR.
prove rational_numbers = rational_numbers /\ Rlt a b.
apply andI.
- reflexivity.
- exact Hab.
Qed.

(** Helper: membership order on  implies order_rel on  **)
(** LATEX VERSION: For , the strict order is membership: if ab then order_rel(,a,b). **)
Theorem mem_implies_order_rel_omega : forall a b:set, a :e b -> order_rel omega a b.
let a b. assume Hab.
prove order_rel omega a b.
(** Unfold `order_rel` at X = omega and inject into the 3rd disjunct. **)
prove (omega = R /\ Rlt a b)
  \/
  (omega = rational_numbers /\ Rlt a b)
  \/
  (omega = omega /\ a :e b)
  \/
  (omega = omega :\: {0} /\ a :e b)
  \/
  (omega = setprod 2 omega /\
   exists i m j n:set,
     i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
     a = (i, m) /\ b = (j, n) /\
     (i :e j \/ (i = j /\ m :e n)))
  \/
  (omega = setprod R R /\
   exists a1 a2 b1 b2:set,
     a = (a1, a2) /\ b = (b1, b2) /\
     (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))).
apply orIL.
apply orIL.
apply orIL.
apply orIR.
prove omega = omega /\ a :e b.
apply andI.
- reflexivity.
- exact Hab.
Qed.

(** Helper: membership order on \\{0} implies order_rel on \\{0} **)
(** LATEX VERSION: For \\{0}, we still use membership as the strict order. **)
Theorem mem_implies_order_rel_omega_nonzero : forall a b:set, a :e b -> order_rel (omega :\: {0}) a b.
let a b. assume Hab.
prove order_rel (omega :\: {0}) a b.
(** Unfold and inject into the 4th disjunct. **)
prove (omega :\: {0} = R /\ Rlt a b)
  \/
  (omega :\: {0} = rational_numbers /\ Rlt a b)
  \/
  (omega :\: {0} = omega /\ a :e b)
  \/
  (omega :\: {0} = omega :\: {0} /\ a :e b)
  \/
  (omega :\: {0} = setprod 2 omega /\
   exists i m j n:set,
     i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
     a = (i, m) /\ b = (j, n) /\
     (i :e j \/ (i = j /\ m :e n)))
  \/
  (omega :\: {0} = setprod R R /\
   exists a1 a2 b1 b2:set,
     a = (a1, a2) /\ b = (b1, b2) /\
     (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2))).
apply orIL.
apply orIL.
apply orIR.
prove omega :\: {0} = omega :\: {0} /\ a :e b.
apply andI.
- reflexivity.
- exact Hab.
Qed.

Definition order_topology_basis : set -> set := fun X =>
  ({I :e Power X | exists a :e X, exists b :e X,
        I = {x :e X | order_rel X a x /\ order_rel X x b}}
   :\/:
   {I :e Power X | exists b :e X, I = {x :e X | order_rel X x b}}
   :\/:
   {I :e Power X | exists a :e X, I = {x :e X | order_rel X a x}}).

(** from 14 Definition: order topology on a simply ordered set **)
(** LATEX VERSION: The order topology on X is the topology generated by the order-topology basis on X. **)
Definition order_topology : set -> set := fun X => generated_topology X (order_topology_basis X).

(** Helper: order topology basis satisfies basis axioms **)
Axiom order_topology_basis_is_basis : forall X:set,
  basis_on X (order_topology_basis X).

(** from 14: order topology is a topology **) 
(** LATEX VERSION: The order topology satisfies the topology axioms. **)
Theorem order_topology_is_topology : forall X:set,
  topology_on X (order_topology X).
let X.
prove topology_on X (order_topology X).
(** order_topology X = generated_topology X (order_topology_basis X) **)
(** Apply axiom that order_topology_basis X is a basis, then use lemma_topology_from_basis **)
exact (lemma_topology_from_basis X (order_topology_basis X) (order_topology_basis_is_basis X)).
Qed.

(** from 14: open rays form a subbasis for the order topology **) 
(** LATEX VERSION: The upper and lower open rays form a subbasis generating the order topology. **)
Definition open_ray_upper : set -> set -> set := fun X a => {x :e X | order_rel X a x}.
Definition open_ray_lower : set -> set -> set := fun X a => {x :e X | order_rel X x a}.

Definition open_rays_subbasis : set -> set := fun X =>
  (({I :e Power X | exists a :e X, I = open_ray_upper X a}
    :\/:
    {I :e Power X | exists b :e X, I = open_ray_lower X b})
   :\/:
   {X}).

(** Helper: open rays subbasis is a subset of Power X **)
Theorem open_rays_subbasis_sub_Power : forall X:set,
  open_rays_subbasis X c= Power X.
let X.
prove open_rays_subbasis X c= Power X.
let I. assume HI: I :e open_rays_subbasis X.
prove I :e Power X.
apply (binunionE' ({I0 :e Power X | exists a :e X, I0 = open_ray_upper X a}
                   :\/:
                   {I0 :e Power X | exists b :e X, I0 = open_ray_lower X b})
                  {X}
                  I
                  (I :e Power X)).
- assume HI0: I :e ({I0 :e Power X | exists a :e X, I0 = open_ray_upper X a}
                    :\/:
                    {I0 :e Power X | exists b :e X, I0 = open_ray_lower X b}).
  apply (binunionE' {I0 :e Power X | exists a :e X, I0 = open_ray_upper X a}
                    {I0 :e Power X | exists b :e X, I0 = open_ray_lower X b}
                    I
                    (I :e Power X)).
  + assume HI1: I :e {I0 :e Power X | exists a :e X, I0 = open_ray_upper X a}.
    exact (SepE1 (Power X) (fun I0 : set => exists a :e X, I0 = open_ray_upper X a) I HI1).
  + assume HI2: I :e {I0 :e Power X | exists b :e X, I0 = open_ray_lower X b}.
    exact (SepE1 (Power X) (fun I0 : set => exists b :e X, I0 = open_ray_lower X b) I HI2).
  + exact HI0.
- assume HIX: I :e {X}.
  claim HIEq: I = X.
  { exact (SingE X I HIX). }
  rewrite HIEq.
  exact (Self_In_Power X).
- exact HI.
Qed.

(** Helper: open rays subbasis covers X and lies in Power X **)
Theorem open_rays_subbasis_is_subbasis : forall X:set,
  subbasis_on X (open_rays_subbasis X).
let X.
prove subbasis_on X (open_rays_subbasis X).
prove (open_rays_subbasis X c= Power X) /\ Union (open_rays_subbasis X) = X.
apply andI.
- exact (open_rays_subbasis_sub_Power X).
- apply set_ext.
  + let x. assume HxU: x :e Union (open_rays_subbasis X).
    prove x :e X.
    apply (UnionE_impred (open_rays_subbasis X) x HxU).
    let U.
    assume HxUin: x :e U.
    assume HU: U :e open_rays_subbasis X.
    claim HUpow: U :e Power X.
    { exact (open_rays_subbasis_sub_Power X U HU). }
    claim HUsub: U c= X.
    { exact (PowerE X U HUpow). }
    exact (HUsub x HxUin).
  + let x. assume HxX: x :e X.
    prove x :e Union (open_rays_subbasis X).
    claim HXInS: X :e open_rays_subbasis X.
    { exact (binunionI2 ({I0 :e Power X | exists a :e X, I0 = open_ray_upper X a}
                         :\/:
                         {I0 :e Power X | exists b :e X, I0 = open_ray_lower X b})
                        {X}
                        X
                        (SingI X)). }
    exact (UnionI (open_rays_subbasis X) x X HxX HXInS).
Qed.

(** Helper: an upper ray is a basis element for the order topology **)
Theorem open_ray_upper_in_order_topology_basis : forall X a:set,
  a :e X -> open_ray_upper X a :e order_topology_basis X.
let X a. assume HaX.
prove open_ray_upper X a :e order_topology_basis X.
set U := open_ray_upper X a.
claim HUpow: U :e Power X.
{ apply PowerI.
  let x. assume HxU: x :e U.
  exact (SepE1 X (fun x0 : set => order_rel X a x0) x HxU). }
claim HUex: exists a0 :e X, U = {x :e X | order_rel X a0 x}.
{ witness a.
  prove a :e X /\ U = {x :e X | order_rel X a x}.
  apply andI.
  - exact HaX.
  - reflexivity.
}
claim HUfam: U :e {I :e Power X | exists a0 :e X, I = {x :e X | order_rel X a0 x}}.
{ exact (SepI (Power X)
              (fun I0 : set => exists a0 :e X, I0 = {x :e X | order_rel X a0 x})
              U
              HUpow
              HUex). }
exact (binunionI2 ({I :e Power X | exists a0 :e X, exists b0 :e X,
                      I = {x :e X | order_rel X a0 x /\ order_rel X x b0}}
                   :\/:
                   {I :e Power X | exists b0 :e X, I = {x :e X | order_rel X x b0}})
                  {I :e Power X | exists a0 :e X, I = {x :e X | order_rel X a0 x}}
                  U
                  HUfam).
Qed.

(** Helper: a lower ray is a basis element for the order topology **)
Theorem open_ray_lower_in_order_topology_basis : forall X b:set,
  b :e X -> open_ray_lower X b :e order_topology_basis X.
let X b. assume HbX.
prove open_ray_lower X b :e order_topology_basis X.
set U := open_ray_lower X b.
claim HUpow: U :e Power X.
{ apply PowerI.
  let x. assume HxU: x :e U.
  exact (SepE1 X (fun x0 : set => order_rel X x0 b) x HxU). }
claim HUex: exists b0 :e X, U = {x :e X | order_rel X x b0}.
{ witness b.
  prove b :e X /\ U = {x :e X | order_rel X x b}.
  apply andI.
  - exact HbX.
  - reflexivity.
}
claim HUfam: U :e {I :e Power X | exists b0 :e X, I = {x :e X | order_rel X x b0}}.
{ exact (SepI (Power X)
              (fun I0 : set => exists b0 :e X, I0 = {x :e X | order_rel X x b0})
              U
              HUpow
              HUex). }
exact (binunionI1 ({I :e Power X | exists a0 :e X, exists b0 :e X,
                      I = {x :e X | order_rel X a0 x /\ order_rel X x b0}}
                   :\/:
                   {I :e Power X | exists b0 :e X, I = {x :e X | order_rel X x b0}})
                  {I :e Power X | exists a0 :e X, I = {x :e X | order_rel X a0 x}}
                  U
                  (binunionI2 {I :e Power X | exists a0 :e X, exists b0 :e X,
                                I = {x :e X | order_rel X a0 x /\ order_rel X x b0}}
                              {I :e Power X | exists b0 :e X, I = {x :e X | order_rel X x b0}}
                              U
                              HUfam)).
Qed.

(** Helper: open rays subbasis elements are open in the order topology **)
Theorem open_rays_subbasis_sub_order_topology : forall X:set,
  open_rays_subbasis X c= order_topology X.
let X.
prove open_rays_subbasis X c= order_topology X.
let U. assume HU: U :e open_rays_subbasis X.
prove U :e order_topology X.
apply (binunionE' ({I0 :e Power X | exists a :e X, I0 = open_ray_upper X a}
                   :\/:
                   {I0 :e Power X | exists b :e X, I0 = open_ray_lower X b})
                  {X}
                  U
                  (U :e order_topology X)).
- assume HU0: U :e ({I0 :e Power X | exists a :e X, I0 = open_ray_upper X a}
                    :\/:
                    {I0 :e Power X | exists b :e X, I0 = open_ray_lower X b}).
  apply (binunionE' {I0 :e Power X | exists a :e X, I0 = open_ray_upper X a}
                    {I0 :e Power X | exists b :e X, I0 = open_ray_lower X b}
                    U
                    (U :e order_topology X)).
  + assume HU1: U :e {I0 :e Power X | exists a :e X, I0 = open_ray_upper X a}.
    claim Hex: exists a :e X, U = open_ray_upper X a.
    { exact (SepE2 (Power X) (fun I0 : set => exists a :e X, I0 = open_ray_upper X a) U HU1). }
    apply Hex.
    let a.
    assume Hcore: a :e X /\ U = open_ray_upper X a.
    apply Hcore.
    assume HaX: a :e X.
    assume HUeq: U = open_ray_upper X a.
    rewrite HUeq.
    claim HUinB: open_ray_upper X a :e order_topology_basis X.
    { exact (open_ray_upper_in_order_topology_basis X a HaX). }
    exact (generated_topology_contains_basis X (order_topology_basis X) (order_topology_basis_is_basis X)
            (open_ray_upper X a) HUinB).
  + assume HU2: U :e {I0 :e Power X | exists b :e X, I0 = open_ray_lower X b}.
    claim Hex: exists b :e X, U = open_ray_lower X b.
    { exact (SepE2 (Power X) (fun I0 : set => exists b :e X, I0 = open_ray_lower X b) U HU2). }
    apply Hex.
    let b.
    assume Hcore: b :e X /\ U = open_ray_lower X b.
    apply Hcore.
    assume HbX: b :e X.
    assume HUeq: U = open_ray_lower X b.
    rewrite HUeq.
    claim HUinB: open_ray_lower X b :e order_topology_basis X.
    { exact (open_ray_lower_in_order_topology_basis X b HbX). }
    exact (generated_topology_contains_basis X (order_topology_basis X) (order_topology_basis_is_basis X)
            (open_ray_lower X b) HUinB).
  + exact HU0.
- assume HUX: U :e {X}.
  claim HUeq: U = X.
  { exact (SingE X U HUX). }
  rewrite HUeq.
  exact (topology_has_X X (order_topology X) (order_topology_is_topology X)).
- exact HU.
Qed.

(** Helper: any subbasis element is open in the generated topology from the subbasis **)
Theorem subbasis_elem_open_in_generated_from_subbasis : forall X S s:set,
  subbasis_on X S ->
  s :e S ->
  s :e generated_topology_from_subbasis X S.
let X S s.
assume HS HsS.
apply (xm (s = Empty)).
- assume HsEmpty.
  rewrite HsEmpty.
  claim HT: topology_on X (generated_topology_from_subbasis X S).
  { exact (topology_from_subbasis_is_topology X S HS). }
  exact (topology_has_empty X (generated_topology_from_subbasis X S) HT).
- assume HsNe.
  claim HBasis: basis_on X (basis_of_subbasis X S).
  { exact (finite_intersections_basis_of_subbasis X S HS). }
  claim HsBasis: s :e basis_of_subbasis X S.
  { exact (subbasis_elem_in_basis X S s HS HsS HsNe). }
  exact (generated_topology_contains_basis X (basis_of_subbasis X S) HBasis s HsBasis).
Qed.

(** Helper: upper ray belongs to open_rays_subbasis **)
Theorem open_ray_upper_in_open_rays_subbasis : forall X a:set,
  a :e X ->
  open_ray_upper X a :e open_rays_subbasis X.
let X a. assume HaX.
set U := open_ray_upper X a.
claim HUpow: U :e Power X.
{ apply PowerI.
  let x. assume HxU: x :e U.
  exact (SepE1 X (fun x0 : set => order_rel X a x0) x HxU). }
claim HUex: exists a0 :e X, U = open_ray_upper X a0.
{ witness a.
  prove a :e X /\ U = open_ray_upper X a.
  apply andI.
  - exact HaX.
  - reflexivity.
}
claim HUfam: U :e {I0 :e Power X | exists a0 :e X, I0 = open_ray_upper X a0}.
{ exact (SepI (Power X)
              (fun I0 : set => exists a0 :e X, I0 = open_ray_upper X a0)
              U
              HUpow
              HUex). }
exact (binunionI1 ({I0 :e Power X | exists a0 :e X, I0 = open_ray_upper X a0}
                   :\/:
                   {I0 :e Power X | exists b0 :e X, I0 = open_ray_lower X b0})
                  {X}
                  U
                  (binunionI1 {I0 :e Power X | exists a0 :e X, I0 = open_ray_upper X a0}
                              {I0 :e Power X | exists b0 :e X, I0 = open_ray_lower X b0}
                              U
                              HUfam)).
Qed.

(** Helper: lower ray belongs to open_rays_subbasis **)
Theorem open_ray_lower_in_open_rays_subbasis : forall X b:set,
  b :e X ->
  open_ray_lower X b :e open_rays_subbasis X.
let X b. assume HbX.
set U := open_ray_lower X b.
claim HUpow: U :e Power X.
{ apply PowerI.
  let x. assume HxU: x :e U.
  exact (SepE1 X (fun x0 : set => order_rel X x0 b) x HxU). }
claim HUex: exists b0 :e X, U = open_ray_lower X b0.
{ witness b.
  prove b :e X /\ U = open_ray_lower X b.
  apply andI.
  - exact HbX.
  - reflexivity.
}
claim HUfam: U :e {I0 :e Power X | exists b0 :e X, I0 = open_ray_lower X b0}.
{ exact (SepI (Power X)
              (fun I0 : set => exists b0 :e X, I0 = open_ray_lower X b0)
              U
              HUpow
              HUex). }
exact (binunionI1 ({I0 :e Power X | exists a0 :e X, I0 = open_ray_upper X a0}
                   :\/:
                   {I0 :e Power X | exists b0 :e X, I0 = open_ray_lower X b0})
                  {X}
                  U
                  (binunionI2 {I0 :e Power X | exists a0 :e X, I0 = open_ray_upper X a0}
                              {I0 :e Power X | exists b0 :e X, I0 = open_ray_lower X b0}
                              U
                              HUfam)).
Qed.

(** Helper: open interval equals intersection of open rays **)
Theorem open_interval_eq_rays_intersection : forall X a b:set,
  {x :e X | order_rel X a x /\ order_rel X x b}
  =
  (open_ray_upper X a) :/\: (open_ray_lower X b).
let X a b.
apply set_ext.
- let x. assume Hx: x :e {x0 :e X | order_rel X a x0 /\ order_rel X x0 b}.
  prove x :e (open_ray_upper X a) :/\: (open_ray_lower X b).
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0 : set => order_rel X a x0 /\ order_rel X x0 b) x Hx). }
  claim HxRel: order_rel X a x /\ order_rel X x b.
  { exact (SepE2 X (fun x0 : set => order_rel X a x0 /\ order_rel X x0 b) x Hx). }
  claim HxUp: x :e open_ray_upper X a.
  { exact (SepI X (fun x0 : set => order_rel X a x0) x HxX
                 (andEL (order_rel X a x) (order_rel X x b) HxRel)). }
  claim HxLo: x :e open_ray_lower X b.
  { exact (SepI X (fun x0 : set => order_rel X x0 b) x HxX
                 (andER (order_rel X a x) (order_rel X x b) HxRel)). }
  exact (binintersectI (open_ray_upper X a) (open_ray_lower X b) x HxUp HxLo).
- let x. assume Hx: x :e (open_ray_upper X a) :/\: (open_ray_lower X b).
  prove x :e {x0 :e X | order_rel X a x0 /\ order_rel X x0 b}.
  claim HxUp: x :e open_ray_upper X a.
  { exact (binintersectE1 (open_ray_upper X a) (open_ray_lower X b) x Hx). }
  claim HxLo: x :e open_ray_lower X b.
  { exact (binintersectE2 (open_ray_upper X a) (open_ray_lower X b) x Hx). }
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0 : set => order_rel X a x0) x HxUp). }
  claim HxRelUp: order_rel X a x.
  { exact (SepE2 X (fun x0 : set => order_rel X a x0) x HxUp). }
  claim HxRelLo: order_rel X x b.
  { exact (SepE2 X (fun x0 : set => order_rel X x0 b) x HxLo). }
  exact (SepI X (fun x0 : set => order_rel X a x0 /\ order_rel X x0 b) x HxX
              (andI (order_rel X a x) (order_rel X x b) HxRelUp HxRelLo)).
Qed.

(** Helper: order topology basis elements are open in the topology generated by open rays **)
Theorem order_topology_basis_sub_generated_from_open_rays : forall X:set,
  order_topology_basis X c= generated_topology_from_subbasis X (open_rays_subbasis X).
let X.
set Tsub := generated_topology_from_subbasis X (open_rays_subbasis X).
claim HSsub: subbasis_on X (open_rays_subbasis X).
{ exact (open_rays_subbasis_is_subbasis X). }
claim HTsub: topology_on X Tsub.
{ exact (topology_from_subbasis_is_topology X (open_rays_subbasis X) HSsub). }
prove order_topology_basis X c= Tsub.
let I. assume HI: I :e order_topology_basis X.
prove I :e Tsub.
apply (binunionE' ({I0 :e Power X | exists a0 :e X, exists b0 :e X,
                      I0 = {x :e X | order_rel X a0 x /\ order_rel X x b0}}
                   :\/:
                   {I0 :e Power X | exists b0 :e X, I0 = {x :e X | order_rel X x b0}})
                  {I0 :e Power X | exists a0 :e X, I0 = {x :e X | order_rel X a0 x}}
                  I
                  (I :e Tsub)).
- assume HI0: I :e ({I0 :e Power X | exists a0 :e X, exists b0 :e X,
                      I0 = {x :e X | order_rel X a0 x /\ order_rel X x b0}}
                     :\/:
                     {I0 :e Power X | exists b0 :e X, I0 = {x :e X | order_rel X x b0}}).
  apply (binunionE' {I0 :e Power X | exists a0 :e X, exists b0 :e X,
                       I0 = {x :e X | order_rel X a0 x /\ order_rel X x b0}}
                    {I0 :e Power X | exists b0 :e X, I0 = {x :e X | order_rel X x b0}}
                    I
                    (I :e Tsub)).
  + assume HIint: I :e {I0 :e Power X | exists a0 :e X, exists b0 :e X,
                          I0 = {x :e X | order_rel X a0 x /\ order_rel X x b0}}.
    claim Hex: exists a0 :e X, exists b0 :e X, I = {x :e X | order_rel X a0 x /\ order_rel X x b0}.
    { exact (SepE2 (Power X)
                   (fun I0 : set => exists a0 :e X, exists b0 :e X, I0 = {x :e X | order_rel X a0 x /\ order_rel X x b0})
                   I
                   HIint). }
    apply Hex.
    let a0.
    assume Hcore: a0 :e X /\ exists b0 :e X, I = {x :e X | order_rel X a0 x /\ order_rel X x b0}.
    apply Hcore.
    assume HaX: a0 :e X.
    assume Hexb: exists b0 :e X, I = {x :e X | order_rel X a0 x /\ order_rel X x b0}.
    apply Hexb.
    let b0.
    assume Hcore2: b0 :e X /\ I = {x :e X | order_rel X a0 x /\ order_rel X x b0}.
    apply Hcore2.
    assume HbX: b0 :e X.
    assume HIeq: I = {x :e X | order_rel X a0 x /\ order_rel X x b0}.
    rewrite HIeq.
    set U1 := open_ray_upper X a0.
    set U2 := open_ray_lower X b0.
    claim HU1S: U1 :e open_rays_subbasis X.
    { exact (open_ray_upper_in_open_rays_subbasis X a0 HaX). }
    claim HU2S: U2 :e open_rays_subbasis X.
    { exact (open_ray_lower_in_open_rays_subbasis X b0 HbX). }
    claim HU1open: U1 :e Tsub.
    { exact (subbasis_elem_open_in_generated_from_subbasis X (open_rays_subbasis X) U1 HSsub HU1S). }
    claim HU2open: U2 :e Tsub.
    { exact (subbasis_elem_open_in_generated_from_subbasis X (open_rays_subbasis X) U2 HSsub HU2S). }
    claim Heq: {x :e X | order_rel X a0 x /\ order_rel X x b0} = U1 :/\: U2.
    { exact (open_interval_eq_rays_intersection X a0 b0). }
    rewrite Heq.
    exact (topology_binintersect_closed X Tsub U1 U2 HTsub HU1open HU2open).
  + assume HIlow: I :e {I0 :e Power X | exists b0 :e X, I0 = {x :e X | order_rel X x b0}}.
    claim Hex: exists b0 :e X, I = {x :e X | order_rel X x b0}.
    { exact (SepE2 (Power X)
                   (fun I0 : set => exists b0 :e X, I0 = {x :e X | order_rel X x b0})
                   I
                   HIlow). }
    apply Hex.
    let b0.
    assume Hcore: b0 :e X /\ I = {x :e X | order_rel X x b0}.
    apply Hcore.
    assume HbX: b0 :e X.
    assume HIeq: I = {x :e X | order_rel X x b0}.
    rewrite HIeq.
    claim Hdef: open_ray_lower X b0 = {x :e X | order_rel X x b0}.
    { reflexivity. }
    rewrite <- Hdef.
    set U := open_ray_lower X b0.
    claim HUS: U :e open_rays_subbasis X.
    { exact (open_ray_lower_in_open_rays_subbasis X b0 HbX). }
    exact (subbasis_elem_open_in_generated_from_subbasis X (open_rays_subbasis X) U HSsub HUS).
  + exact HI0.
- assume HIup: I :e {I0 :e Power X | exists a0 :e X, I0 = {x :e X | order_rel X a0 x}}.
  claim Hex: exists a0 :e X, I = {x :e X | order_rel X a0 x}.
  { exact (SepE2 (Power X)
                 (fun I0 : set => exists a0 :e X, I0 = {x :e X | order_rel X a0 x})
                 I
                 HIup). }
  apply Hex.
  let a0.
  assume Hcore: a0 :e X /\ I = {x :e X | order_rel X a0 x}.
  apply Hcore.
  assume HaX: a0 :e X.
  assume HIeq: I = {x :e X | order_rel X a0 x}.
  rewrite HIeq.
  claim Hdef: open_ray_upper X a0 = {x :e X | order_rel X a0 x}.
  { reflexivity. }
  rewrite <- Hdef.
  set U := open_ray_upper X a0.
  claim HUS: U :e open_rays_subbasis X.
  { exact (open_ray_upper_in_open_rays_subbasis X a0 HaX). }
  exact (subbasis_elem_open_in_generated_from_subbasis X (open_rays_subbasis X) U HSsub HUS).
- exact HI.
Qed.

Theorem open_rays_subbasis_for_order_topology : forall X:set,
  generated_topology_from_subbasis X (open_rays_subbasis X) = order_topology X.
let X.
prove generated_topology_from_subbasis X (open_rays_subbasis X) = order_topology X.
apply set_ext.
- let U. assume HU : U :e generated_topology_from_subbasis X (open_rays_subbasis X).
  prove U :e order_topology X.
  claim HS: subbasis_on X (open_rays_subbasis X).
  { exact (open_rays_subbasis_is_subbasis X). }
  claim HT: topology_on X (order_topology X).
  { exact (order_topology_is_topology X). }
  claim HSsub: open_rays_subbasis X c= order_topology X.
  { exact (open_rays_subbasis_sub_order_topology X). }
  claim Hmin: finer_than (order_topology X) (generated_topology_from_subbasis X (open_rays_subbasis X)).
  { exact (topology_generated_by_basis_is_minimal X (open_rays_subbasis X) (order_topology X) HS HT HSsub). }
  exact (Hmin U HU).
- let U. assume HU : U :e order_topology X.
  prove U :e generated_topology_from_subbasis X (open_rays_subbasis X).
  set Tsub := generated_topology_from_subbasis X (open_rays_subbasis X).
  claim HS: subbasis_on X (open_rays_subbasis X).
  { exact (open_rays_subbasis_is_subbasis X). }
  claim HTsub: topology_on X Tsub.
  { exact (topology_from_subbasis_is_topology X (open_rays_subbasis X) HS). }
  claim HBsub: forall b :e order_topology_basis X, b :e Tsub.
  { let b. assume Hb.
    exact (order_topology_basis_sub_generated_from_open_rays X b Hb). }
  claim Hfiner: finer_than Tsub (generated_topology X (order_topology_basis X)).
  { exact (generated_topology_finer X (order_topology_basis X) Tsub (order_topology_basis_is_basis X) HTsub HBsub). }
  exact (Hfiner U HU).
Qed.

(** from 14 Example 1: standard basis is a basis on  **)
(** LATEX VERSION: The standard open-interval basis on  satisfies the basis axioms. **)
Theorem R_standard_basis_is_basis : basis_on R R_standard_basis.
prove basis_on R R_standard_basis.
(** Reuse the earlier proof to avoid duplicate work. **)
exact R_standard_basis_is_basis_local.
Qed.

(** from 14 Example 1: standard topology is a topology **)
(** LATEX VERSION: The standard topology on  satisfies the topology axioms. **)
Theorem R_standard_topology_is_topology : topology_on R R_standard_topology.
prove topology_on R R_standard_topology.
exact (lemma_topology_from_basis R R_standard_basis (R_standard_basis_is_basis)).
Qed.

(** from 14 Example 1: standard topology on  is the order topology **)
(** LATEX VERSION: Example 1: The standard topology on  equals its order topology. **)
(** NOTE: The earlier axiom equating bases was too strong; we only need equality of the generated topologies. **)
Axiom standard_topology_is_order_topology_axiom : order_topology R = R_standard_topology.

Theorem standard_topology_is_order_topology : order_topology R = R_standard_topology.
prove order_topology R = R_standard_topology.
exact standard_topology_is_order_topology_axiom.
Qed.

(** from 14 Example 2: dictionary order topology on  **) 
(** LATEX VERSION: Example 2 defines the dictionary order topology on  via the order topology construction. **)
Definition R2_dictionary_order_topology : set := order_topology (setprod R R).

Theorem dictionary_order_topology_is_topology :
  topology_on (setprod R R) R2_dictionary_order_topology.
prove topology_on (setprod R R) R2_dictionary_order_topology.
(** R2_dictionary_order_topology = order_topology (setprod R R) by definition **)
exact (order_topology_is_topology (setprod R R)).
Qed.

(** from 14 Example 2: rectangle subbasis yields product-style topology **) 
(** LATEX VERSION: Rectangle-type sets give a basis generating the dictionary order topology on . **)
(** NOTE: Current witness uses `order_topology_basis`; rectangle characterization is not yet formalized. **)
Theorem rectangles_basis_for_R2 :
  exists B:set, basis_on (setprod R R) B /\ generated_topology (setprod R R) B = R2_dictionary_order_topology.
prove exists B:set, basis_on (setprod R R) B /\ generated_topology (setprod R R) B = R2_dictionary_order_topology.
witness (order_topology_basis (setprod R R)).
apply andI.
- exact (order_topology_basis_is_basis (setprod R R)).
- reflexivity.
Qed.

(** from 14 Example 3: order topology on  is discrete **)
(** LATEX VERSION: Example 3: The order topology on the positive integers is the discrete topology. **)
Definition Zplus : set := omega :\: {0}.

(** Helper: 0 is not in Zplus **)
(** Uses the definition Zplus = omega :\: {0}. **)
Theorem zero_not_in_Zplus : 0 /:e Zplus.
prove ~(0 :e Zplus).
assume H0: 0 :e Zplus.
prove False.
claim H0m: 0 :e omega :\: {0}.
{ exact H0. }
claim Hcore: 0 :e omega /\ 0 /:e {0}.
{ exact (setminusE omega {0} 0 H0m). }
claim H0not: 0 /:e {0}.
{ exact (andER (0 :e omega) (0 /:e {0}) Hcore). }
exact (H0not (SingI 0)).
Qed.

(** Helper: 1 is in Zplus **)
(** Uses the definition Zplus = omega :\: {0}. **)
Theorem one_in_Zplus : 1 :e Zplus.
prove 1 :e omega :\: {0}.
claim H1omega: 1 :e omega.
{ exact (nat_p_omega 1 nat_1). }
claim H1not0: 1 /:e {0}.
{ assume H1: 1 :e {0}.
  prove False.
  claim Heq: 1 = 0.
  { exact (SingE 0 1 H1). }
  exact (neq_1_0 Heq). }
exact (setminusI omega {0} 1 H1omega H1not0).
Qed.

(** Helper: 2 is in Zplus **)
(** Uses the definition Zplus = omega :\: {0}. **)
Theorem two_in_Zplus : 2 :e Zplus.
prove 2 :e omega :\: {0}.
claim H2omega: 2 :e omega.
{ exact (nat_p_omega 2 nat_2). }
claim H2not0: 2 /:e {0}.
{ assume H2: 2 :e {0}.
  prove False.
  claim Heq: 2 = 0.
  { exact (SingE 0 2 H2). }
  exact (neq_2_0 Heq). }
exact (setminusI omega {0} 2 H2omega H2not0).
Qed.

(** Helper: 0 is in rational_numbers **)
(** Uses the definition rational = {x :e real | exists m :e int, exists n :e omega :\: {0}, x = m :/: n}. **)
Theorem zero_in_rational_numbers : 0 :e rational_numbers.
prove 0 :e rational.
claim H0real: 0 :e real.
{ exact real_0. }
claim H0omega: 0 :e omega.
{ exact (nat_p_omega 0 nat_0). }
claim H0int: 0 :e int.
{ exact (Subq_omega_int 0 H0omega). }
claim H1omega: 1 :e omega.
{ exact (nat_p_omega 1 nat_1). }
claim H1not0: 1 /:e {0}.
{ assume H1: 1 :e {0}.
  prove False.
  claim Heq: 1 = 0.
  { exact (SingE 0 1 H1). }
  exact (neq_1_0 Heq). }
claim H1nonzero: 1 :e omega :\: {0}.
{ exact (setminusI omega {0} 1 H1omega H1not0). }
claim Heq0: 0 = div_SNo 0 1.
{ claim Hdiv: div_SNo 0 1 = 0.
  { exact (div_SNo_0_num 1 SNo_1). }
  rewrite <- Hdiv at 1.
  reflexivity. }
claim Hex: exists m :e int, exists n :e omega :\: {0}, 0 = div_SNo m n.
{ witness 0.
  apply andI.
  - exact H0int.
  - witness 1.
    apply andI.
    + exact H1nonzero.
    + exact Heq0. }
exact (SepI real
            (fun x:set => exists m :e int, exists n :e omega :\: {0}, x = div_SNo m n)
            0
            H0real
            Hex).
Qed.

(** Helper: Zplus is not omega **)
Theorem Zplus_neq_omega : Zplus <> omega.
assume Heq: Zplus = omega.
prove False.
claim H0omega: 0 :e omega.
{ exact (nat_p_omega 0 nat_0). }
claim H0Z: 0 :e Zplus.
{ rewrite Heq. exact H0omega. }
exact (zero_not_in_Zplus H0Z).
Qed.

(** Helper: Zplus is not R **)
Theorem Zplus_neq_R : Zplus <> R.
assume Heq: Zplus = R.
prove False.
claim H0R: 0 :e R.
{ exact real_0. }
claim H0Z: 0 :e Zplus.
{ rewrite Heq. exact H0R. }
exact (zero_not_in_Zplus H0Z).
Qed.

(** Helper: Zplus is not rational_numbers **)
Theorem Zplus_neq_rational_numbers : Zplus <> rational_numbers.
assume Heq: Zplus = rational_numbers.
prove False.
claim H0Q: 0 :e rational_numbers.
{ exact zero_in_rational_numbers. }
claim H0Z: 0 :e Zplus.
{ rewrite Heq. exact H0Q. }
exact (zero_not_in_Zplus H0Z).
Qed.

(** Helper: Inj1 0 equals 1 **)
Theorem Inj1_0_eq_1 : Inj1 0 = 1.
apply set_ext.
- let y. assume Hy: y :e Inj1 0.
  prove y :e 1.
  claim Hcase: y = 0 \/ exists x :e 0, y = Inj1 x.
  { exact (Inj1E 0 y Hy). }
  apply (Hcase (y :e 1)).
  * assume Hy0: y = 0.
    rewrite Hy0.
    exact In_0_1.
  * assume Hex: exists x :e 0, y = Inj1 x.
    apply Hex.
    let x. assume Hxp.
    apply Hxp.
    assume Hx0 HyEq.
    apply FalseE.
    exact (EmptyE x Hx0).
- let y. assume Hy: y :e 1.
  prove y :e Inj1 0.
  claim HySing: y :e {0}.
  { prove y :e {0}.
    rewrite <- eq_1_Sing0.
    exact Hy. }
  claim Hy0: y = 0.
  { exact (SingE 0 y HySing). }
  rewrite Hy0.
  exact (Inj1I1 0).
Qed.

(** Helper: {1} is not transitive **)
Theorem not_TransSet_singleton_1 : ~ TransSet {1}.
assume H: TransSet {1}.
prove False.
claim H1in: 1 :e {1}.
{ exact (SingI 1). }
claim Hsub: 1 c= {1}.
{ exact (H 1 H1in). }
claim H0in1: 0 :e 1.
{ exact In_0_1. }
claim H0inSing1: 0 :e {1}.
{ exact (Hsub 0 H0in1). }
claim Heq: 0 = 1.
{ exact (SingE 1 0 H0inSing1). }
exact (neq_0_1 Heq).
Qed.

(** Helper: {1} is not in omega **)
Theorem Sing1_not_in_omega : {1} /:e omega.
assume H: {1} :e omega.
prove False.
claim Hnat: nat_p {1}.
{ exact (omega_nat_p {1} H). }
claim Hord: ordinal {1}.
{ exact (nat_p_ordinal {1} Hnat). }
claim Htr: TransSet {1}.
{ exact (ordinal_TransSet {1} Hord). }
exact (not_TransSet_singleton_1 Htr).
Qed.

(** Helper: tuple (0,1) equals {1} **)
Theorem tuple_0_1_eq_Sing1 : (0,1) = {1}.
prove (0,1) = {1}.
apply set_ext.
- let z. assume Hz: z :e (0,1).
  prove z :e {1}.
  claim Hzsum: z :e 0 :+: 1.
  { prove z :e 0 :+: 1.
    rewrite (tuple_pair 0 1).
    exact Hz. }
  claim Hcases: (exists x :e 0, z = Inj0 x) \/ (exists y :e 1, z = Inj1 y).
  { exact (setsum_Inj_inv 0 1 z Hzsum). }
  apply (Hcases (z :e {1})).
  * assume Hex: exists x :e 0, z = Inj0 x.
    apply Hex.
    let x. assume Hxp.
    apply Hxp.
    assume Hx0 HzEq.
    apply FalseE.
    exact (EmptyE x Hx0).
  * assume Hex: exists y :e 1, z = Inj1 y.
    apply Hex.
    let y. assume Hyp.
    apply Hyp.
    assume Hy1 HzEq.
    claim HySing: y :e {0}.
    { prove y :e {0}.
      rewrite <- eq_1_Sing0.
      exact Hy1. }
    claim Hy0: y = 0.
    { exact (SingE 0 y HySing). }
    claim HzInj10: z = Inj1 0.
    { prove z = Inj1 0.
      rewrite <- Hy0.
      exact HzEq. }
    claim Hz1: z = 1.
    { rewrite HzInj10.
      rewrite Inj1_0_eq_1.
      reflexivity. }
    rewrite Hz1.
    exact (SingI 1).
- let z. assume Hz: z :e {1}.
  prove z :e (0,1).
  rewrite <- (tuple_pair 0 1).
  claim Hz1: z = 1.
  { exact (SingE 1 z Hz). }
  rewrite Hz1.
  rewrite <- Inj1_0_eq_1 at 1.
  exact (Inj1_setsum 0 1 0 In_0_1).
Qed.

(** Helper: Zplus is not setprod 2 omega **)
Theorem Zplus_neq_setprod_2_omega : Zplus <> setprod 2 omega.
assume Heq: Zplus = setprod 2 omega.
prove False.
claim H1omega: 1 :e omega.
{ exact (nat_p_omega 1 nat_1). }
claim Hp: (0,1) :e setprod 2 omega.
{ exact (tuple_2_setprod 2 omega 0 In_0_2 1 H1omega). }
claim HpZ: (0,1) :e Zplus.
{ rewrite Heq. exact Hp. }
claim Hcore: (0,1) :e omega /\ (0,1) /:e {0}.
{ exact (setminusE omega {0} (0,1) HpZ). }
claim HpOmega: (0,1) :e omega.
{ exact (andEL ((0,1) :e omega) ((0,1) /:e {0}) Hcore). }
claim HSingOmega: {1} :e omega.
{ prove {1} :e omega.
  rewrite <- tuple_0_1_eq_Sing1.
  exact HpOmega. }
exact (Sing1_not_in_omega HSingOmega).
Qed.

(** Helper: Zplus is not setprod R R **)
Theorem Zplus_neq_setprod_R_R : Zplus <> setprod R R.
assume Heq: Zplus = setprod R R.
prove False.
claim Hp: (0,1) :e setprod R R.
{ exact (tuple_2_setprod R R 0 real_0 1 real_1). }
claim HpZ: (0,1) :e Zplus.
{ rewrite Heq. exact Hp. }
claim Hcore: (0,1) :e omega /\ (0,1) /:e {0}.
{ exact (setminusE omega {0} (0,1) HpZ). }
claim HpOmega: (0,1) :e omega.
{ exact (andEL ((0,1) :e omega) ((0,1) /:e {0}) Hcore). }
claim HSingOmega: {1} :e omega.
{ prove {1} :e omega.
  rewrite <- tuple_0_1_eq_Sing1.
  exact HpOmega. }
exact (Sing1_not_in_omega HSingOmega).
Qed.

(** Helper: on Zplus, order_rel is membership order **)
Theorem order_rel_Zplus_iff_mem : forall a b:set,
  a :e Zplus -> b :e Zplus -> (order_rel Zplus a b <-> a :e b).
let a b. assume HaZ HbZ.
apply iffI.
- assume Hrel: order_rel Zplus a b.
  prove a :e b.
  (** eliminate disjunctions in order_rel using Zplus inequalities **)
  apply (Hrel (a :e b)).
  - assume Hleft.
    apply (Hleft (a :e b)).
    - assume Hmid.
      apply (Hmid (a :e b)).
      + assume Hm2.
        apply (Hm2 (a :e b)).
        - assume Hm3.
          apply (Hm3 (a :e b)).
          - assume Hc1.
             apply FalseE.
             claim Heq: Zplus = R.
             { exact (andEL (Zplus = R) (Rlt a b) Hc1). }
             exact (Zplus_neq_R Heq).
          - assume Hc2.
             apply FalseE.
             claim Heq: Zplus = rational_numbers.
             { exact (andEL (Zplus = rational_numbers) (Rlt a b) Hc2). }
             exact (Zplus_neq_rational_numbers Heq).
        - assume Hc3.
          apply FalseE.
          claim Heq: Zplus = omega.
          { exact (andEL (Zplus = omega) (a :e b) Hc3). }
          exact (Zplus_neq_omega Heq).
      + assume Hc4.
        exact (andER (Zplus = omega :\: {0}) (a :e b) Hc4).
    - assume Hc5.
      apply FalseE.
      claim Heq: Zplus = setprod 2 omega.
      { exact (andEL (Zplus = setprod 2 omega)
                    (exists i m j n:set,
                      i :e 2 /\ m :e omega /\ j :e 2 /\ n :e omega /\
                      a = (i, m) /\ b = (j, n) /\
                      (i :e j \/ (i = j /\ m :e n)))
                    Hc5). }
      exact (Zplus_neq_setprod_2_omega Heq).
  - assume Hc6.
    apply FalseE.
    claim Heq: Zplus = setprod R R.
    { exact (andEL (Zplus = setprod R R)
                  (exists a1 a2 b1 b2:set,
                    a = (a1, a2) /\ b = (b1, b2) /\
                    (Rlt a1 b1 \/ (a1 = b1 /\ Rlt a2 b2)))
                  Hc6). }
    exact (Zplus_neq_setprod_R_R Heq).
- assume Hab: a :e b.
  prove order_rel Zplus a b.
  claim Heq: Zplus = omega :\: {0}.
  { reflexivity. }
  rewrite Heq.
  exact (mem_implies_order_rel_omega_nonzero a b Hab).
Qed.

(** Helper: membership in Zplus implies membership in omega **)
Theorem Zplus_mem_omega : forall n:set, n :e Zplus -> n :e omega.
let n. assume Hn: n :e Zplus.
claim Hcore: n :e omega /\ n /:e {0}.
{ exact (setminusE omega {0} n Hn). }
exact (andEL (n :e omega) (n /:e {0}) Hcore).
Qed.

(** Helper: membership in Zplus implies n<>0 **)
Theorem Zplus_mem_nonzero : forall n:set, n :e Zplus -> n <> 0.
let n. assume Hn: n :e Zplus.
assume Heq: n = 0.
prove False.
claim Hcore: n :e omega /\ n /:e {0}.
{ exact (setminusE omega {0} n Hn). }
claim Hnnot0: n /:e {0}.
{ exact (andER (n :e omega) (n /:e {0}) Hcore). }
claim HnIn: n :e {0}.
{ rewrite Heq.
  exact (SingI 0). }
exact (Hnnot0 HnIn).
Qed.

(** Helper: Zplus is a subset of omega **)
Theorem Zplus_Subq_omega : Zplus c= omega.
let n. assume Hn: n :e Zplus.
exact (Zplus_mem_omega n Hn).
Qed.

(** Helper: successor of a Zplus element is again in Zplus **)
Theorem Zplus_ordsucc_closed : forall n:set, n :e Zplus -> ordsucc n :e Zplus.
let n. assume Hn: n :e Zplus.
claim HnOmega: n :e omega.
{ exact (Zplus_mem_omega n Hn). }
claim HsuccOmega: ordsucc n :e omega.
{ exact (omega_ordsucc n HnOmega). }
claim HsuccNot0: ordsucc n /:e {0}.
{ assume H0: ordsucc n :e {0}.
  prove False.
  claim Heq0: ordsucc n = 0.
  { exact (SingE 0 (ordsucc n) H0). }
  exact (neq_ordsucc_0 n Heq0). }
exact (setminusI omega {0} (ordsucc n) HsuccOmega HsuccNot0).
Qed.

(** Helper: singleton sets are basic opens in the order topology basis on Zplus **)
Theorem nat_nonzero_in_Zplus : forall n:set, nat_p n -> n <> 0 -> n :e Zplus.
let n. assume HnNat HnNeq.
prove n :e omega :\: {0}.
claim HnOmega: n :e omega.
{ exact (nat_p_omega n HnNat). }
claim Hnnot0: n /:e {0}.
{ assume Hn0: n :e {0}.
  prove False.
  claim Heq: n = 0.
  { exact (SingE 0 n Hn0). }
  exact (HnNeq Heq). }
exact (setminusI omega {0} n HnOmega Hnnot0).
Qed.

(** Helper: singleton {1} is in the order topology basis on Zplus **)
Theorem singleton_ordsucc0_in_order_topology_basis_Zplus :
  {ordsucc 0} :e order_topology_basis Zplus.
prove {ordsucc 0} :e order_topology_basis Zplus.
(** expand order_topology_basis **)
claim Hdef: order_topology_basis Zplus =
  ({I :e Power Zplus | exists a :e Zplus, exists b :e Zplus,
        I = {x :e Zplus | order_rel Zplus a x /\ order_rel Zplus x b}}
   :\/:
   {I :e Power Zplus | exists b :e Zplus, I = {x :e Zplus | order_rel Zplus x b}}
   :\/:
   {I :e Power Zplus | exists a :e Zplus, I = {x :e Zplus | order_rel Zplus a x}}).
{ reflexivity. }
rewrite Hdef.
(** order_topology_basis Zplus is a union of three families; use lower ray family **)
apply binunionI1.
apply binunionI2.
apply (SepI (Power Zplus)
            (fun I : set => exists b0 :e Zplus, I = {x :e Zplus | order_rel Zplus x b0})
            {ordsucc 0}).
- apply PowerI.
  let x. assume Hx: x :e {ordsucc 0}.
  prove x :e Zplus.
  claim HxEq: x = ordsucc 0.
  { exact (SingE (ordsucc 0) x Hx). }
  rewrite HxEq.
  exact one_in_Zplus.
- witness (ordsucc (ordsucc 0)).
  apply andI.
  - exact two_in_Zplus.
  - prove {ordsucc 0} = {x :e Zplus | order_rel Zplus x (ordsucc (ordsucc 0))}.
    apply set_ext.
    - let x. assume Hx: x :e {ordsucc 0}.
       prove x :e {x :e Zplus | order_rel Zplus x (ordsucc (ordsucc 0))}.
       claim HxEq: x = ordsucc 0.
       { exact (SingE (ordsucc 0) x Hx). }
       apply (SepI Zplus
                   (fun t : set => order_rel Zplus t (ordsucc (ordsucc 0)))
                   x).
       - rewrite HxEq.
         exact one_in_Zplus.
       - rewrite HxEq.
         claim Hmem: ordsucc 0 :e ordsucc (ordsucc 0).
         { exact (ordsuccI2 (ordsucc 0)). }
         exact (iffER (order_rel Zplus (ordsucc 0) (ordsucc (ordsucc 0)))
                      (ordsucc 0 :e ordsucc (ordsucc 0))
                      (order_rel_Zplus_iff_mem (ordsucc 0) (ordsucc (ordsucc 0)) one_in_Zplus two_in_Zplus)
                      Hmem).
    - let x. assume Hx: x :e {x :e Zplus | order_rel Zplus x (ordsucc (ordsucc 0))}.
       prove x :e {ordsucc 0}.
       claim HxZ: x :e Zplus.
       { exact (SepE1 Zplus (fun t : set => order_rel Zplus t (ordsucc (ordsucc 0))) x Hx). }
       claim Hrel: order_rel Zplus x (ordsucc (ordsucc 0)).
       { exact (SepE2 Zplus (fun t : set => order_rel Zplus t (ordsucc (ordsucc 0))) x Hx). }
       claim Hmem: x :e ordsucc (ordsucc 0).
       { exact (iffEL (order_rel Zplus x (ordsucc (ordsucc 0)))
                      (x :e ordsucc (ordsucc 0))
                      (order_rel_Zplus_iff_mem x (ordsucc (ordsucc 0)) HxZ two_in_Zplus)
                      Hrel). }
       claim HxNe0: x <> 0.
       { exact (Zplus_mem_nonzero x HxZ). }
       claim Hcase: x :e ordsucc 0 \/ x = ordsucc 0.
       { exact (ordsuccE (ordsucc 0) x Hmem). }
       claim HxEq1: x = ordsucc 0.
       { apply (Hcase (x = ordsucc 0)).
         - assume HxIn1: x :e ordsucc 0.
           apply FalseE.
           claim Hcase0: x :e 0 \/ x = 0.
           { exact (ordsuccE 0 x HxIn1). }
           claim Hx0: x = 0.
           { apply (Hcase0 (x = 0)).
             + assume HxIn0: x :e 0.
               apply FalseE.
               exact (EmptyE x HxIn0).
             + assume Hx0. exact Hx0. }
           exact (HxNe0 Hx0).
         - assume HxEq. exact HxEq. }
       rewrite HxEq1.
       exact (SingI (ordsucc 0)).
Qed.

(** Helper: singleton of a successor is in the order topology basis on Zplus **)
Theorem singleton_ordsucc_in_order_topology_basis_Zplus : forall m:set,
  m :e Zplus -> {ordsucc m} :e order_topology_basis Zplus.
let m. assume Hm.
prove {ordsucc m} :e order_topology_basis Zplus.
(** expand order_topology_basis **)
claim Hdef: order_topology_basis Zplus =
  ({I :e Power Zplus | exists a :e Zplus, exists b :e Zplus,
        I = {x :e Zplus | order_rel Zplus a x /\ order_rel Zplus x b}}
   :\/:
   {I :e Power Zplus | exists b :e Zplus, I = {x :e Zplus | order_rel Zplus x b}}
   :\/:
   {I :e Power Zplus | exists a :e Zplus, I = {x :e Zplus | order_rel Zplus a x}}).
{ reflexivity. }
rewrite Hdef.
(** use open interval (m, ordsucc (ordsucc m)) in the interval family **)
apply binunionI1.
apply binunionI1.
apply (SepI (Power Zplus)
            (fun I : set =>
               exists a :e Zplus, exists b :e Zplus,
                 I = {x :e Zplus | order_rel Zplus a x /\ order_rel Zplus x b})
            {ordsucc m}).
- apply PowerI.
  let x. assume Hx: x :e {ordsucc m}.
  prove x :e Zplus.
  claim HxEq: x = ordsucc m.
  { exact (SingE (ordsucc m) x Hx). }
  rewrite HxEq.
  exact (Zplus_ordsucc_closed m Hm).
- witness m.
  apply andI.
  - exact Hm.
  - witness (ordsucc (ordsucc m)).
    apply andI.
    - exact (Zplus_ordsucc_closed (ordsucc m) (Zplus_ordsucc_closed m Hm)).
    - prove {ordsucc m} =
        {x :e Zplus | order_rel Zplus m x /\ order_rel Zplus x (ordsucc (ordsucc m))}.
       apply set_ext.
       - let x. assume Hx: x :e {ordsucc m}.
          prove x :e {x :e Zplus | order_rel Zplus m x /\ order_rel Zplus x (ordsucc (ordsucc m))}.
          claim HxEq: x = ordsucc m.
          { exact (SingE (ordsucc m) x Hx). }
          apply (SepI Zplus
                      (fun t : set => order_rel Zplus m t /\ order_rel Zplus t (ordsucc (ordsucc m)))
                      x).
          - rewrite HxEq.
            exact (Zplus_ordsucc_closed m Hm).
          - rewrite HxEq.
            apply andI.
            * claim Hmem1: m :e ordsucc m.
              { exact (ordsuccI2 m). }
              exact (iffER (order_rel Zplus m (ordsucc m))
                           (m :e ordsucc m)
                           (order_rel_Zplus_iff_mem m (ordsucc m) Hm (Zplus_ordsucc_closed m Hm))
                           Hmem1).
            * claim Hmem2: ordsucc m :e ordsucc (ordsucc m).
              { exact (ordsuccI2 (ordsucc m)). }
              exact (iffER (order_rel Zplus (ordsucc m) (ordsucc (ordsucc m)))
                           (ordsucc m :e ordsucc (ordsucc m))
                           (order_rel_Zplus_iff_mem (ordsucc m) (ordsucc (ordsucc m))
                                                    (Zplus_ordsucc_closed m Hm)
                                                    (Zplus_ordsucc_closed (ordsucc m) (Zplus_ordsucc_closed m Hm)))
                           Hmem2).
       - let x. assume Hx: x :e {x :e Zplus | order_rel Zplus m x /\ order_rel Zplus x (ordsucc (ordsucc m))}.
          prove x :e {ordsucc m}.
          claim HxZ: x :e Zplus.
          { exact (SepE1 Zplus
                        (fun t : set => order_rel Zplus m t /\ order_rel Zplus t (ordsucc (ordsucc m)))
                        x
                        Hx). }
          claim Hconj: order_rel Zplus m x /\ order_rel Zplus x (ordsucc (ordsucc m)).
          { exact (SepE2 Zplus
                        (fun t : set => order_rel Zplus m t /\ order_rel Zplus t (ordsucc (ordsucc m)))
                        x
                        Hx). }
          claim Hrel1: order_rel Zplus m x.
          { exact (andEL (order_rel Zplus m x)
                         (order_rel Zplus x (ordsucc (ordsucc m)))
                         Hconj). }
          claim Hrel2: order_rel Zplus x (ordsucc (ordsucc m)).
          { exact (andER (order_rel Zplus m x)
                         (order_rel Zplus x (ordsucc (ordsucc m)))
                         Hconj). }
          claim Hmemb: m :e x.
          { exact (iffEL (order_rel Zplus m x)
                         (m :e x)
                         (order_rel_Zplus_iff_mem m x Hm HxZ)
                         Hrel1). }
          claim HbZ: ordsucc (ordsucc m) :e Zplus.
          { exact (Zplus_ordsucc_closed (ordsucc m) (Zplus_ordsucc_closed m Hm)). }
          claim HxInb: x :e ordsucc (ordsucc m).
          { exact (iffEL (order_rel Zplus x (ordsucc (ordsucc m)))
                         (x :e ordsucc (ordsucc m))
                         (order_rel_Zplus_iff_mem x (ordsucc (ordsucc m)) HxZ HbZ)
                         Hrel2). }
          claim Hcase: x :e ordsucc m \/ x = ordsucc m.
          { exact (ordsuccE (ordsucc m) x HxInb). }
          claim HxEq: x = ordsucc m.
          { apply (Hcase (x = ordsucc m)).
            - assume HxIn1: x :e ordsucc m.
              apply FalseE.
              claim Hcase2: x :e m \/ x = m.
              { exact (ordsuccE m x HxIn1). }
              claim HxInm: x :e m.
              { apply (Hcase2 (x :e m)).
                + assume Hxm. exact Hxm.
                + assume Hxeq.
                  apply FalseE.
                  claim Hmm: m :e m.
                  { prove m :e m.
                    rewrite <- Hxeq at 2.
                    exact Hmemb. }
                  exact (In_irref m Hmm). }
              exact (In_no2cycle m x Hmemb HxInm).
            - assume Hxeq. exact Hxeq. }
          rewrite HxEq.
          exact (SingI (ordsucc m)).
Qed.

Theorem singleton_in_order_topology_basis_Zplus : forall n:set,
  n :e Zplus -> {n} :e order_topology_basis Zplus.
let n. assume HnZ.
claim HnOmega: n :e omega.
{ exact (Zplus_mem_omega n HnZ). }
claim HnNat: nat_p n.
{ exact (omega_nat_p n HnOmega). }
claim HnNeq0: n <> 0.
{ exact (Zplus_mem_nonzero n HnZ). }
claim Hcase: n = 0 \/ exists m:set, nat_p m /\ n = ordsucc m.
{ exact (nat_inv n HnNat). }
apply (Hcase ({n} :e order_topology_basis Zplus)).
- assume Hn0: n = 0.
  prove {n} :e order_topology_basis Zplus.
  apply FalseE.
  exact (HnNeq0 Hn0).
- assume Hex: exists m:set, nat_p m /\ n = ordsucc m.
  apply Hex.
  let m. assume Hmpair.
  apply Hmpair.
  assume HmNat HnEq.
  apply (xm (m = 0)).
  + assume Hm0: m = 0.
    prove {n} :e order_topology_basis Zplus.
    rewrite HnEq.
    rewrite Hm0.
    exact singleton_ordsucc0_in_order_topology_basis_Zplus.
  + assume HmNe0: m <> 0.
    prove {n} :e order_topology_basis Zplus.
    claim HmZ: m :e Zplus.
    { exact (nat_nonzero_in_Zplus m HmNat HmNe0). }
    rewrite HnEq.
    exact (singleton_ordsucc_in_order_topology_basis_Zplus m HmZ).
Qed.

(** Helper: order topology on Zplus is discrete **)
Theorem Zplus_order_topology_is_discrete :
  generated_topology Zplus (order_topology_basis Zplus) = Power Zplus.
prove generated_topology Zplus (order_topology_basis Zplus) = Power Zplus.
apply set_ext.
- let U. assume HU: U :e generated_topology Zplus (order_topology_basis Zplus).
  prove U :e Power Zplus.
  exact (SepE1 (Power Zplus)
               (fun U0 : set => forall x :e U0, exists b :e order_topology_basis Zplus, x :e b /\ b c= U0)
               U HU).
- let U. assume HU: U :e Power Zplus.
  prove U :e generated_topology Zplus (order_topology_basis Zplus).
  prove U :e {U0 :e Power Zplus | forall x :e U0, exists b :e order_topology_basis Zplus, x :e b /\ b c= U0}.
  apply (SepI (Power Zplus)
              (fun U0 : set => forall x :e U0, exists b :e order_topology_basis Zplus, x :e b /\ b c= U0)
              U
              HU).
  claim HUsub: U c= Zplus.
  { exact (PowerE Zplus U HU). }
  let x. assume Hx: x :e U.
  witness {x}.
  apply andI.
  + exact (singleton_in_order_topology_basis_Zplus x (HUsub x Hx)).
  + apply andI.
    * exact (SingI x).
    * let y. assume Hy: y :e {x}.
      prove y :e U.
      claim HyEq: y = x.
      { exact (SingE x y Hy). }
      rewrite HyEq.
      exact Hx.
Qed.

Theorem order_topology_on_Zplus_discrete :
  order_topology Zplus = discrete_topology Zplus.
prove order_topology Zplus = discrete_topology Zplus.
(** Zplus = omega :\: {0} by definition **)
(** order_topology Zplus = generated_topology Zplus (order_topology_basis Zplus) **)
(** discrete_topology Zplus = Power Zplus **)
exact Zplus_order_topology_is_discrete.
Qed.

(** from 14 Example 4: two-row dictionary order space is not discrete **) 
(** LATEX VERSION: Example 4: The dictionary order topology on {1,2} is not discrete. **)
Definition two_by_nat : set := setprod 2 omega.
Definition two_by_nat_order_topology : set := order_topology two_by_nat.

(** Helper: singleton {(1,0)} is not open in two_by_nat order topology **)
Axiom two_by_nat_singleton_not_open :
  ~ ({(1,0)} :e two_by_nat_order_topology).

(** LATEX VERSION: The two-by- dictionary order space fails to be discrete. **)
Theorem two_by_nat_not_discrete :
  ~ (two_by_nat_order_topology = discrete_topology two_by_nat).
prove ~ (two_by_nat_order_topology = discrete_topology two_by_nat).
(** Proof by contradiction: assume they're equal **)
assume Heq: two_by_nat_order_topology = discrete_topology two_by_nat.
(** In discrete topology, all singletons are open **)
set singleton_1_0 := {(1,0)}.
claim Hsingleton_in_discrete: singleton_1_0 :e discrete_topology two_by_nat.
{ (** discrete_topology two_by_nat = Power two_by_nat, so any subset is open **)
  (** Need to show singleton_1_0 :e Power two_by_nat **)
  (** This requires singleton_1_0 c= two_by_nat **)
  claim H0omega: 0 :e omega.
  { exact (nat_p_omega 0 nat_0). }
  claim Helem: (1,0) :e two_by_nat.
  { exact (tuple_2_setprod 2 omega 1 In_1_2 0 H0omega). }
  claim Hsub: singleton_1_0 c= two_by_nat.
  { let y. assume Hy: y :e singleton_1_0.
    prove y :e two_by_nat.
    claim HyEq: y = (1,0).
    { exact (SingE (1,0) y Hy). }
    rewrite HyEq.
    exact Helem. }

  exact (PowerI two_by_nat singleton_1_0 Hsub).
}
claim Hsingleton_in_order: singleton_1_0 :e two_by_nat_order_topology.
{ rewrite Heq. exact Hsingleton_in_discrete. }
(** But this contradicts the axiom **)
exact (two_by_nat_singleton_not_open Hsingleton_in_order).
Qed.

(** from 15 Definition: product topology on XY **) 
(** LATEX VERSION: The product topology on XY is generated by the basis of rectangles UV with U open in X and V open in Y. **)
Definition rectangle_set : set -> set -> set := fun U V => setprod U V.

(** Helper: surjective pairing for setprod **)
Theorem setprod_eta : forall X Y p:set,
  p :e setprod X Y -> p = (p 0, p 1).
let X Y p.
assume Hp: p :e setprod X Y.
prove p = (p 0, p 1).
apply (Sigma_E X (fun _ : set => Y) p Hp).
let x.
assume Hx_pair.
apply Hx_pair.
assume HxX Hexy.
apply Hexy.
let y.
assume Hy_pair.
apply Hy_pair.
assume HyY Hpeq.
claim HeqT: p = (x,y).
{ prove p = (x,y).
  rewrite <- (tuple_pair x y).
  exact Hpeq. }
claim Hp0: p 0 = x.
{ rewrite HeqT. exact (tuple_2_0_eq x y). }
claim Hp1: p 1 = y.
{ rewrite HeqT. exact (tuple_2_1_eq x y). }
rewrite Hp0.
rewrite Hp1.
exact HeqT.
Qed.

(** Helper: cartesian products preserve subset relation **)
Theorem setprod_Subq : forall U V X Y:set,
  U c= X -> V c= Y -> setprod U V c= setprod X Y.
let U V X Y.
assume HU: U c= X.
assume HV: V c= Y.
prove setprod U V c= setprod X Y.
let p.
assume Hp: p :e setprod U V.
prove p :e setprod X Y.
claim Hp0: p 0 :e U.
{ exact (ap0_Sigma U (fun u => V) p Hp). }
claim Hp1: p 1 :e V.
{ exact (ap1_Sigma U (fun u => V) p Hp). }
claim Hp0X: p 0 :e X.
{ exact (HU (p 0) Hp0). }
claim Hp1Y: p 1 :e Y.
{ exact (HV (p 1) Hp1). }
claim Heta: p = (p 0, p 1).
{ exact (setprod_eta U V p Hp). }
rewrite Heta.
prove (p 0, p 1) :e setprod X Y.
exact (tuple_2_setprod X Y (p 0) Hp0X (p 1) Hp1Y).
Qed.

(** Helper: elements of cartesian products have coordinates **)
Theorem setprod_elem_decompose : forall X Y p:set,
  p :e setprod X Y ->
  exists x :e X, exists y :e Y, p :e setprod {x} {y}.
let X Y p.
assume Hp: p :e setprod X Y.
claim Hp0X: p 0 :e X.
{ exact (ap0_Sigma X (fun _ : set => Y) p Hp). }
claim Hp1Y: p 1 :e Y.
{ exact (ap1_Sigma X (fun _ : set => Y) p Hp). }
witness (p 0).
apply andI.
- exact Hp0X.
- witness (p 1).
  apply andI.
  * exact Hp1Y.
  * claim Heta: p = (p 0, p 1).
    { exact (setprod_eta X Y p Hp). }
    rewrite Heta at 1.
    exact (tuple_2_setprod {p 0} {p 1} (p 0) (SingI (p 0)) (p 1) (SingI (p 1))).
Qed.

(** Helper: singleton subset property **)
Theorem singleton_subset : forall x U:set, x :e U -> {x} c= U.
let x U. assume HxU.
prove {x} c= U.
let y. assume Hy: y :e {x}.
prove y :e U.
claim HyEq: y = x.
{ exact (SingE x y Hy). }
rewrite HyEq.
exact HxU.
Qed.

(** Helper: singleton element equality **)
Theorem singleton_elem : forall x y:set, x :e {y} -> x = y.
let x y. assume H.
exact (SingE y x H).
Qed.

(** Helper: coordinates of product elements **)
Theorem setprod_coords_in : forall x y U V p:set,
  p :e setprod {x} {y} -> p :e setprod U V -> x :e U /\ y :e V.
let x y U V p.
assume Hpxy: p :e setprod {x} {y}.
assume HpUV: p :e setprod U V.
prove x :e U /\ y :e V.
claim Hp0x: p 0 :e {x}.
{ exact (ap0_Sigma {x} (fun u => {y}) p Hpxy). }
claim Hp1y: p 1 :e {y}.
{ exact (ap1_Sigma {x} (fun u => {y}) p Hpxy). }
claim Hp0_eq_x: p 0 = x.
{ exact (singleton_elem (p 0) x Hp0x). }
claim Hp1_eq_y: p 1 = y.
{ exact (singleton_elem (p 1) y Hp1y). }
claim Hp0U: p 0 :e U.
{ exact (ap0_Sigma U (fun u => V) p HpUV). }
claim Hp1V: p 1 :e V.
{ exact (ap1_Sigma U (fun u => V) p HpUV). }
apply andI.
- prove x :e U.
  rewrite <- Hp0_eq_x.
  exact Hp0U.
- prove y :e V.
  rewrite <- Hp1_eq_y.
  exact Hp1V.
Qed.

(** Helper: intersection of cartesian products **)
Theorem setprod_intersection : forall U1 V1 U2 V2:set,
  setprod U1 V1 :/\: setprod U2 V2 = setprod (U1 :/\: U2) (V1 :/\: V2).
let U1 V1 U2 V2.
prove setprod U1 V1 :/\: setprod U2 V2 = setprod (U1 :/\: U2) (V1 :/\: V2).
apply set_ext.
- let p. assume Hp: p :e setprod U1 V1 :/\: setprod U2 V2.
  prove p :e setprod (U1 :/\: U2) (V1 :/\: V2).
  claim HpU1V1: p :e setprod U1 V1.
  { exact (binintersectE1 (setprod U1 V1) (setprod U2 V2) p Hp). }
  claim HpU2V2: p :e setprod U2 V2.
  { exact (binintersectE2 (setprod U1 V1) (setprod U2 V2) p Hp). }
  claim Hp0U1: p 0 :e U1.
  { exact (ap0_Sigma U1 (fun u => V1) p HpU1V1). }
  claim Hp1V1: p 1 :e V1.
  { exact (ap1_Sigma U1 (fun u => V1) p HpU1V1). }
  claim Hp0U2: p 0 :e U2.
  { exact (ap0_Sigma U2 (fun u => V2) p HpU2V2). }
  claim Hp1V2: p 1 :e V2.
  { exact (ap1_Sigma U2 (fun u => V2) p HpU2V2). }
  claim Hp0: p 0 :e U1 :/\: U2.
  { exact (binintersectI U1 U2 (p 0) Hp0U1 Hp0U2). }
  claim Hp1: p 1 :e V1 :/\: V2.
  { exact (binintersectI V1 V2 (p 1) Hp1V1 Hp1V2). }
  claim Heta: p = (p 0, p 1).
  { exact (setprod_eta U1 V1 p HpU1V1). }
  rewrite Heta.
  exact (tuple_2_setprod (U1 :/\: U2) (V1 :/\: V2) (p 0) Hp0 (p 1) Hp1).
- let p. assume Hp: p :e setprod (U1 :/\: U2) (V1 :/\: V2).
  prove p :e setprod U1 V1 :/\: setprod U2 V2.
  claim Hp0: p 0 :e U1 :/\: U2.
  { exact (ap0_Sigma (U1 :/\: U2) (fun u => V1 :/\: V2) p Hp). }
  claim Hp1: p 1 :e V1 :/\: V2.
  { exact (ap1_Sigma (U1 :/\: U2) (fun u => V1 :/\: V2) p Hp). }
  claim Hp0U1: p 0 :e U1.
  { exact (binintersectE1 U1 U2 (p 0) Hp0). }
  claim Hp0U2: p 0 :e U2.
  { exact (binintersectE2 U1 U2 (p 0) Hp0). }
  claim Hp1V1: p 1 :e V1.
  { exact (binintersectE1 V1 V2 (p 1) Hp1). }
  claim Hp1V2: p 1 :e V2.
  { exact (binintersectE2 V1 V2 (p 1) Hp1). }
  claim Heta: p = (p 0, p 1).
  { exact (setprod_eta (U1 :/\: U2) (V1 :/\: V2) p Hp). }
  rewrite Heta.
  apply binintersectI.
  + exact (tuple_2_setprod U1 V1 (p 0) Hp0U1 (p 1) Hp1V1).
  + exact (tuple_2_setprod U2 V2 (p 0) Hp0U2 (p 1) Hp1V2).
Qed.

Definition product_subbasis : set -> set -> set -> set -> set :=
  fun X Tx Y Ty =>
    \/_ U :e Tx, {rectangle_set U V|V :e Ty}.

Definition product_topology : set -> set -> set -> set -> set :=
  fun X Tx Y Ty => generated_topology (setprod X Y) (product_subbasis X Tx Y Ty).

(** Helper: product subbasis satisfies basis axioms **)
Theorem product_subbasis_is_basis : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
let X Tx Y Ty.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
prove product_subbasis X Tx Y Ty c= Power (setprod X Y)
  /\ (forall p :e setprod X Y, exists b :e product_subbasis X Tx Y Ty, p :e b)
  /\ (forall b1 :e product_subbasis X Tx Y Ty,
        forall b2 :e product_subbasis X Tx Y Ty,
          forall p:set, p :e b1 -> p :e b2 ->
            exists b3 :e product_subbasis X Tx Y Ty, p :e b3 /\ b3 c= b1 :/\: b2).
apply andI.
- apply andI.
  + (** subset axiom: every rectangle is a subset of XY **)
    let b. assume Hb: b :e product_subbasis X Tx Y Ty.
    prove b :e Power (setprod X Y).
    claim HTxSub: Tx c= Power X.
    { exact (topology_subset_axiom X Tx HTx). }
    claim HTySub: Ty c= Power Y.
    { exact (topology_subset_axiom Y Ty HTy). }
    claim HexU: exists U :e Tx, b :e {rectangle_set U V|V :e Ty}.
    { exact (famunionE Tx (fun U0:set => {rectangle_set U0 V|V :e Ty}) b Hb). }
    apply HexU.
    let U. assume HUconj: U :e Tx /\ b :e {rectangle_set U V|V :e Ty}.
    claim HU: U :e Tx.
    { exact (andEL (U :e Tx) (b :e {rectangle_set U V|V :e Ty}) HUconj). }
    claim HbRepl: b :e {rectangle_set U V|V :e Ty}.
    { exact (andER (U :e Tx) (b :e {rectangle_set U V|V :e Ty}) HUconj). }
    claim HexV: exists V :e Ty, b = rectangle_set U V.
    { exact (ReplE Ty (fun V0:set => rectangle_set U V0) b HbRepl). }
    apply HexV.
    let V. assume HVconj: V :e Ty /\ b = rectangle_set U V.
    claim HV: V :e Ty.
    { exact (andEL (V :e Ty) (b = rectangle_set U V) HVconj). }
    claim Hbeq: b = rectangle_set U V.
    { exact (andER (V :e Ty) (b = rectangle_set U V) HVconj). }
    claim HUpow: U :e Power X.
    { exact (HTxSub U HU). }
    claim HVpow: V :e Power Y.
    { exact (HTySub V HV). }
    claim HUsubX: U c= X.
    { exact (PowerE X U HUpow). }
    claim HVsubY: V c= Y.
    { exact (PowerE Y V HVpow). }
    claim HrectSub: rectangle_set U V c= setprod X Y.
    { exact (setprod_Subq U V X Y HUsubX HVsubY). }
    rewrite Hbeq.
    exact (PowerI (setprod X Y) (rectangle_set U V) HrectSub).
  + (** cover axiom: every p in XY lies in some rectangle in the subbasis **)
    let p. assume Hp: p :e setprod X Y.
    witness (rectangle_set X Y).
    apply andI.
    * prove rectangle_set X Y :e product_subbasis X Tx Y Ty.
      claim HXTx: X :e Tx.
      { exact (topology_has_X X Tx HTx). }
      claim HYTy: Y :e Ty.
      { exact (topology_has_X Y Ty HTy). }
      claim HRfam: rectangle_set X Y :e {rectangle_set X V|V :e Ty}.
      { exact (ReplI Ty (fun V0:set => rectangle_set X V0) Y HYTy). }
      exact (famunionI Tx (fun U0:set => {rectangle_set U0 V|V :e Ty}) X (rectangle_set X Y) HXTx HRfam).
    * (** p is in XY **)
      exact Hp.
- (** refinement axiom: intersection of two rectangles refines to a rectangle **)
  let b1. assume Hb1: b1 :e product_subbasis X Tx Y Ty.
  let b2. assume Hb2: b2 :e product_subbasis X Tx Y Ty.
  let p. assume Hp1: p :e b1.
  assume Hp2: p :e b2.
  claim HexU1: exists U1 :e Tx, b1 :e {rectangle_set U1 V|V :e Ty}.
  { exact (famunionE Tx (fun U0:set => {rectangle_set U0 V|V :e Ty}) b1 Hb1). }
  apply HexU1.
  let U1. assume HU1conj: U1 :e Tx /\ b1 :e {rectangle_set U1 V|V :e Ty}.
  claim HU1: U1 :e Tx.
  { exact (andEL (U1 :e Tx) (b1 :e {rectangle_set U1 V|V :e Ty}) HU1conj). }
  claim Hb1Repl: b1 :e {rectangle_set U1 V|V :e Ty}.
  { exact (andER (U1 :e Tx) (b1 :e {rectangle_set U1 V|V :e Ty}) HU1conj). }
  claim HexV1: exists V1 :e Ty, b1 = rectangle_set U1 V1.
  { exact (ReplE Ty (fun V0:set => rectangle_set U1 V0) b1 Hb1Repl). }
  apply HexV1.
  let V1. assume HV1conj: V1 :e Ty /\ b1 = rectangle_set U1 V1.
  claim HV1: V1 :e Ty.
  { exact (andEL (V1 :e Ty) (b1 = rectangle_set U1 V1) HV1conj). }
  claim Hb1eq: b1 = rectangle_set U1 V1.
  { exact (andER (V1 :e Ty) (b1 = rectangle_set U1 V1) HV1conj). }

  claim HexU2: exists U2 :e Tx, b2 :e {rectangle_set U2 V|V :e Ty}.
  { exact (famunionE Tx (fun U0:set => {rectangle_set U0 V|V :e Ty}) b2 Hb2). }
  apply HexU2.
  let U2. assume HU2conj: U2 :e Tx /\ b2 :e {rectangle_set U2 V|V :e Ty}.
  claim HU2: U2 :e Tx.
  { exact (andEL (U2 :e Tx) (b2 :e {rectangle_set U2 V|V :e Ty}) HU2conj). }
  claim Hb2Repl: b2 :e {rectangle_set U2 V|V :e Ty}.
  { exact (andER (U2 :e Tx) (b2 :e {rectangle_set U2 V|V :e Ty}) HU2conj). }
  claim HexV2: exists V2 :e Ty, b2 = rectangle_set U2 V2.
  { exact (ReplE Ty (fun V0:set => rectangle_set U2 V0) b2 Hb2Repl). }
  apply HexV2.
  let V2. assume HV2conj: V2 :e Ty /\ b2 = rectangle_set U2 V2.
  claim HV2: V2 :e Ty.
  { exact (andEL (V2 :e Ty) (b2 = rectangle_set U2 V2) HV2conj). }
  claim Hb2eq: b2 = rectangle_set U2 V2.
  { exact (andER (V2 :e Ty) (b2 = rectangle_set U2 V2) HV2conj). }

  set b3 := rectangle_set (U1 :/\: U2) (V1 :/\: V2).
  witness b3.
  apply andI.
  + (** b3 in the product subbasis **)
    claim HU12: (U1 :/\: U2) :e Tx.
    { exact (topology_binintersect_closed X Tx U1 U2 HTx HU1 HU2). }
    claim HV12: (V1 :/\: V2) :e Ty.
    { exact (topology_binintersect_closed Y Ty V1 V2 HTy HV1 HV2). }
    claim Hb3fam: rectangle_set (U1 :/\: U2) (V1 :/\: V2) :e {rectangle_set (U1 :/\: U2) V|V :e Ty}.
    { exact (ReplI Ty (fun V0:set => rectangle_set (U1 :/\: U2) V0) (V1 :/\: V2) HV12). }
    exact (famunionI Tx (fun U0:set => {rectangle_set U0 V|V :e Ty}) (U1 :/\: U2) b3 HU12 Hb3fam).
  + (** p in b3 and b3 subset of b1b2 **)
    apply andI.
    * (** membership **)
      claim HpU1V1: p :e rectangle_set U1 V1.
      { rewrite <- Hb1eq.
        exact Hp1. }
      claim HpU2V2: p :e rectangle_set U2 V2.
      { rewrite <- Hb2eq.
        exact Hp2. }
      claim HpInt: p :e (rectangle_set U1 V1) :/\: (rectangle_set U2 V2).
      { exact (binintersectI (rectangle_set U1 V1) (rectangle_set U2 V2) p HpU1V1 HpU2V2). }
      rewrite <- (setprod_intersection U1 V1 U2 V2).
      exact HpInt.
    * (** subset **)
      claim HintEq: b1 :/\: b2 = b3.
      { prove b1 :/\: b2 = b3.
        rewrite Hb1eq.
        rewrite Hb2eq.
        exact (setprod_intersection U1 V1 U2 V2). }
      rewrite HintEq.
      exact (Subq_ref b3).
Qed.

(** from 15: product topology is a topology **)
(** LATEX VERSION: The product topology determined by Tx and Ty satisfies the topology axioms on XY. **)
Theorem product_topology_is_topology : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  topology_on (setprod X Y) (product_topology X Tx Y Ty).
let X Tx Y Ty.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove topology_on (setprod X Y) (product_topology X Tx Y Ty).
(** product_topology X Tx Y Ty = generated_topology (setprod X Y) (product_subbasis X Tx Y Ty) **)
(** Use axiom that product_subbasis forms a basis, then apply lemma_topology_from_basis **)
exact (lemma_topology_from_basis (setprod X Y) (product_subbasis X Tx Y Ty)
         (product_subbasis_is_basis X Tx Y Ty HTx HTy)).
Qed.

(** Definition: product basis from two bases **)
Definition product_basis_from : set -> set -> set :=
  fun Bx By => \/_ U :e Bx, {setprod U V | V :e By}.

(** Helper: product basis generates product topology **)
Theorem product_basis_generates_product_topology : forall X Y Bx By Tx Ty:set,
  basis_on X Bx -> generated_topology X Bx = Tx ->
  basis_on Y By -> generated_topology Y By = Ty ->
  generated_topology (setprod X Y) (product_basis_from Bx By) = product_topology X Tx Y Ty.
let X Y Bx By Tx Ty.
assume HBx_basis: basis_on X Bx.
assume HTx_eq: generated_topology X Bx = Tx.
assume HBy_basis: basis_on Y By.
assume HTy_eq: generated_topology Y By = Ty.
claim HTx: topology_on X Tx.
{ rewrite <- HTx_eq.
  exact (lemma_topology_from_basis X Bx HBx_basis). }
claim HTy: topology_on Y Ty.
{ rewrite <- HTy_eq.
  exact (lemma_topology_from_basis Y By HBy_basis). }
claim HTprod: topology_on (setprod X Y) (product_topology X Tx Y Ty).
{ exact (product_topology_is_topology X Tx Y Ty HTx HTy). }
claim HCsub: forall c :e product_basis_from Bx By, c :e product_topology X Tx Y Ty.
{ let c. assume HcC.
  claim HBprod: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
  { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
  claim HexU: exists U :e Bx, c :e {setprod U V | V :e By}.
  { exact (famunionE Bx (fun U0:set => {setprod U0 V0 | V0 :e By}) c HcC). }
  apply HexU.
  let U. assume HUconj: U :e Bx /\ c :e {setprod U V | V :e By}.
  claim HU: U :e Bx.
  { exact (andEL (U :e Bx) (c :e {setprod U V | V :e By}) HUconj). }
  claim HcRepl: c :e {setprod U V | V :e By}.
  { exact (andER (U :e Bx) (c :e {setprod U V | V :e By}) HUconj). }
  claim HexV: exists V :e By, c = setprod U V.
  { exact (ReplE By (fun V0:set => setprod U V0) c HcRepl). }
  apply HexV.
  let V. assume HVconj: V :e By /\ c = setprod U V.
  claim HV: V :e By.
  { exact (andEL (V :e By) (c = setprod U V) HVconj). }
  claim Hceq: c = setprod U V.
  { exact (andER (V :e By) (c = setprod U V) HVconj). }
  claim HUTx: U :e Tx.
  { rewrite <- HTx_eq.
    exact (generated_topology_contains_basis X Bx HBx_basis U HU). }
  claim HVTy: V :e Ty.
  { rewrite <- HTy_eq.
    exact (generated_topology_contains_basis Y By HBy_basis V HV). }
  claim HcSub: c :e product_subbasis X Tx Y Ty.
  { rewrite Hceq.
    claim Hrepl: rectangle_set U V :e {rectangle_set U W | W :e Ty}.
    { exact (ReplI Ty (fun W:set => rectangle_set U W) V HVTy). }
    exact (famunionI Tx (fun U0:set => {rectangle_set U0 W | W :e Ty}) U (rectangle_set U V) HUTx Hrepl). }
  exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBprod c HcSub). }
claim Href: forall U :e product_topology X Tx Y Ty, forall p :e U,
  exists Cx :e product_basis_from Bx By, p :e Cx /\ Cx c= U.
{ let U. assume HU: U :e product_topology X Tx Y Ty.
  let p. assume Hp: p :e U.
  claim HUprop: forall q :e U, exists b :e product_subbasis X Tx Y Ty, q :e b /\ b c= U.
  { exact (SepE2 (Power (setprod X Y))
                 (fun U0:set => forall q0 :e U0, exists b0 :e product_subbasis X Tx Y Ty, q0 :e b0 /\ b0 c= U0)
                 U HU). }
  claim Hexb: exists b :e product_subbasis X Tx Y Ty, p :e b /\ b c= U.
  { exact (HUprop p Hp). }
  apply Hexb.
  let b. assume Hbpair.
  claim HbSub: b :e product_subbasis X Tx Y Ty.
  { exact (andEL (b :e product_subbasis X Tx Y Ty) (p :e b /\ b c= U) Hbpair). }
  claim Hbprop: p :e b /\ b c= U.
  { exact (andER (b :e product_subbasis X Tx Y Ty) (p :e b /\ b c= U) Hbpair). }
  claim Hpb: p :e b.
  { exact (andEL (p :e b) (b c= U) Hbprop). }
  claim HbsubU: b c= U.
  { exact (andER (p :e b) (b c= U) Hbprop). }
  claim HexU0: exists U0 :e Tx, b :e {rectangle_set U0 V0 | V0 :e Ty}.
  { exact (famunionE Tx (fun U1:set => {rectangle_set U1 V1 | V1 :e Ty}) b HbSub). }
  apply HexU0.
  let U0. assume HU0conj: U0 :e Tx /\ b :e {rectangle_set U0 V0 | V0 :e Ty}.
  claim HU0: U0 :e Tx.
  { exact (andEL (U0 :e Tx) (b :e {rectangle_set U0 V0 | V0 :e Ty}) HU0conj). }
  claim HbRepl: b :e {rectangle_set U0 V0 | V0 :e Ty}.
  { exact (andER (U0 :e Tx) (b :e {rectangle_set U0 V0 | V0 :e Ty}) HU0conj). }
  claim HexV0: exists V0 :e Ty, b = rectangle_set U0 V0.
  { exact (ReplE Ty (fun V1:set => rectangle_set U0 V1) b HbRepl). }
  apply HexV0.
  let V0. assume HV0conj: V0 :e Ty /\ b = rectangle_set U0 V0.
  claim HV0: V0 :e Ty.
  { exact (andEL (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }
  claim Hbeq: b = rectangle_set U0 V0.
  { exact (andER (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }
  claim Hpb0: p :e rectangle_set U0 V0.
  { prove p :e rectangle_set U0 V0.
    rewrite <- Hbeq.
    exact Hpb. }
  claim Hp0U0: p 0 :e U0.
  { exact (ap0_Sigma U0 (fun _ : set => V0) p Hpb0). }
  claim Hp1V0: p 1 :e V0.
  { exact (ap1_Sigma U0 (fun _ : set => V0) p Hpb0). }
  claim HU0gen: U0 :e generated_topology X Bx.
  { rewrite HTx_eq. exact HU0. }
  claim HV0gen: V0 :e generated_topology Y By.
  { rewrite HTy_eq. exact HV0. }
  claim HU0loc: forall x :e U0, exists bx :e Bx, x :e bx /\ bx c= U0.
  { exact (SepE2 (Power X)
                 (fun U1:set => forall x1 :e U1, exists b1 :e Bx, x1 :e b1 /\ b1 c= U1)
                 U0 HU0gen). }
  claim HV0loc: forall y :e V0, exists by :e By, y :e by /\ by c= V0.
  { exact (SepE2 (Power Y)
                 (fun V1:set => forall y1 :e V1, exists b1 :e By, y1 :e b1 /\ b1 c= V1)
                 V0 HV0gen). }
  claim Hexbx: exists bx :e Bx, p 0 :e bx /\ bx c= U0.
  { exact (HU0loc (p 0) Hp0U0). }
  apply Hexbx.
  let bx. assume Hbxpair.
  claim Hbx: bx :e Bx.
  { exact (andEL (bx :e Bx) (p 0 :e bx /\ bx c= U0) Hbxpair). }
  claim Hbxprop: p 0 :e bx /\ bx c= U0.
  { exact (andER (bx :e Bx) (p 0 :e bx /\ bx c= U0) Hbxpair). }
  claim Hp0bx: p 0 :e bx.
  { exact (andEL (p 0 :e bx) (bx c= U0) Hbxprop). }
  claim Hbxsub: bx c= U0.
  { exact (andER (p 0 :e bx) (bx c= U0) Hbxprop). }
  claim Hexby: exists by :e By, p 1 :e by /\ by c= V0.
  { exact (HV0loc (p 1) Hp1V0). }
  apply Hexby.
  let by. assume Hbypair.
  claim Hby: by :e By.
  { exact (andEL (by :e By) (p 1 :e by /\ by c= V0) Hbypair). }
  claim Hbyprop: p 1 :e by /\ by c= V0.
  { exact (andER (by :e By) (p 1 :e by /\ by c= V0) Hbypair). }
  claim Hp1by: p 1 :e by.
  { exact (andEL (p 1 :e by) (by c= V0) Hbyprop). }
  claim Hbysub: by c= V0.
  { exact (andER (p 1 :e by) (by c= V0) Hbyprop). }
  witness (setprod bx by).
  apply andI.
  - (** membership in product_basis_from **)
    claim Hrepl: setprod bx by :e {setprod bx w | w :e By}.
    { exact (ReplI By (fun w:set => setprod bx w) by Hby). }
    exact (famunionI Bx (fun u:set => {setprod u w | w :e By}) bx (setprod bx by) Hbx Hrepl).
  - apply andI.
    + (** p in setprod bx by **)
      claim Heta: p = (p 0, p 1).
      { exact (setprod_eta U0 V0 p Hpb0). }
      rewrite Heta.
      exact (tuple_2_setprod bx by (p 0) Hp0bx (p 1) Hp1by).
    + (** subset **)
      claim Hsubbb: setprod bx by c= setprod U0 V0.
      { exact (setprod_Subq bx by U0 V0 Hbxsub Hbysub). }
      claim HsubbU: setprod U0 V0 c= U.
      { rewrite <- Hbeq. exact HbsubU. }
      exact (Subq_tra (setprod bx by) (setprod U0 V0) U Hsubbb HsubbU). }
apply (andER (basis_on (setprod X Y) (product_basis_from Bx By))
             (generated_topology (setprod X Y) (product_basis_from Bx By) = product_topology X Tx Y Ty)
             (basis_refines_topology (setprod X Y) (product_topology X Tx Y Ty) (product_basis_from Bx By) HTprod HCsub Href)).
Qed.

(** from 15 Theorem: basis of products of basis elements **)
(** LATEX VERSION: If Bx, By are bases for Tx, Ty, then the collection {UV|UBx, VBy} is a basis generating the product topology. **)
Theorem product_basis_generates :
  forall X Tx Y Ty Bx By:set,
    basis_on X Bx /\ generated_topology X Bx = Tx ->
    basis_on Y By /\ generated_topology Y By = Ty ->
    exists B:set,
      basis_on (setprod X Y) B /\
      (forall U :e Bx, forall V :e By, setprod U V :e B) /\
  generated_topology (setprod X Y) B = product_topology X Tx Y Ty.
let X Tx Y Ty Bx By.
assume HBx: basis_on X Bx /\ generated_topology X Bx = Tx.
assume HBy: basis_on Y By /\ generated_topology Y By = Ty.
prove exists B:set,
      basis_on (setprod X Y) B /\
      (forall U :e Bx, forall V :e By, setprod U V :e B) /\
  generated_topology (setprod X Y) B = product_topology X Tx Y Ty.
(** Witness B = product_basis_from Bx By = {UV | UBx, VBy} **)
witness (product_basis_from Bx By).
prove basis_on (setprod X Y) (product_basis_from Bx By) /\
      (forall U :e Bx, forall V :e By, setprod U V :e product_basis_from Bx By) /\
  generated_topology (setprod X Y) (product_basis_from Bx By) = product_topology X Tx Y Ty.
apply andI.
- (** Part 1 & 2: product_basis_from Bx By is a basis and contains all UV **)
  apply andI.
  + (** Prove basis_on (setprod X Y) (product_basis_from Bx By) **)
    (** Extract properties from assumptions **)
    claim HBx_basis: basis_on X Bx.
    { exact (andEL (basis_on X Bx) (generated_topology X Bx = Tx) HBx). }
    claim HBy_basis: basis_on Y By.
    { exact (andEL (basis_on Y By) (generated_topology Y By = Ty) HBy). }
    (** Verify three basis axioms for product_basis_from Bx By **)
    prove product_basis_from Bx By c= Power (setprod X Y)
      /\ (forall p :e setprod X Y, exists b :e product_basis_from Bx By, p :e b)
      /\ (forall b1 :e product_basis_from Bx By, forall b2 :e product_basis_from Bx By, forall p:set,
            p :e b1 -> p :e b2 -> exists b3 :e product_basis_from Bx By, p :e b3 /\ b3 c= b1 :/\: b2).
    (** Left-associative structure: (Axiom1 /\ Axiom2) /\ Axiom3 **)
    apply andI.
    * (** Prove Axiom1 /\ Axiom2 **)
      apply andI.
      - (** Axiom 1: product_basis_from Bx By c= Power (setprod X Y) **)
        let b. assume Hb: b :e product_basis_from Bx By.
        prove b :e Power (setprod X Y).
        (** b is in the family union, so b = setprod U V for some U :e Bx, V :e By **)
        claim Hexists: exists U :e Bx, b :e {setprod U V' | V' :e By}.
        { exact (famunionE Bx (fun U' => {setprod U' V' | V' :e By}) b Hb). }
        apply Hexists.
        let U. assume HU_conj: U :e Bx /\ b :e {setprod U V' | V' :e By}.
        claim HU: U :e Bx.
        { exact (andEL (U :e Bx) (b :e {setprod U V' | V' :e By}) HU_conj). }
        claim HbRepl: b :e {setprod U V' | V' :e By}.
        { exact (andER (U :e Bx) (b :e {setprod U V' | V' :e By}) HU_conj). }
        (** b :e {setprod U V' | V' :e By}, so b = setprod U V for some V :e By **)
        claim Hexists2: exists V :e By, b = setprod U V.
        { exact (ReplE By (fun V' => setprod U V') b HbRepl). }
        apply Hexists2.
        let V. assume HV_conj: V :e By /\ b = setprod U V.
        claim HV: V :e By.
        { exact (andEL (V :e By) (b = setprod U V) HV_conj). }
        claim Hbeq: b = setprod U V.
        { exact (andER (V :e By) (b = setprod U V) HV_conj). }
        (** Now show setprod U V :e Power (setprod X Y) **)
        (** Need U c= X and V c= Y **)
        claim HBx_sub: Bx c= Power X.
        { exact (andEL (Bx c= Power X) (forall x :e X, exists b :e Bx, x :e b) (andEL (Bx c= Power X /\ (forall x :e X, exists b :e Bx, x :e b)) (forall b1 :e Bx, forall b2 :e Bx, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e Bx, x :e b3 /\ b3 c= b1 :/\: b2) HBx_basis)). }
        claim HBy_sub: By c= Power Y.
        { exact (andEL (By c= Power Y) (forall y :e Y, exists b :e By, y :e b) (andEL (By c= Power Y /\ (forall y :e Y, exists b :e By, y :e b)) (forall b1 :e By, forall b2 :e By, forall y:set, y :e b1 -> y :e b2 -> exists b3 :e By, y :e b3 /\ b3 c= b1 :/\: b2) HBy_basis)). }
        claim HUsubX: U c= X.
        { exact (PowerE X U (HBx_sub U HU)). }
        claim HVsubY: V c= Y.
        { exact (PowerE Y V (HBy_sub V HV)). }
        claim HUVsub: setprod U V c= setprod X Y.
        { exact (setprod_Subq U V X Y HUsubX HVsubY). }
        (** Since b = setprod U V, we have b c= setprod X Y **)
        claim Hbsub: b c= setprod X Y.
        { rewrite Hbeq. exact HUVsub. }
        exact (PowerI (setprod X Y) b Hbsub).
      - (** Axiom 2: covering - every (x,y) is in some UV **)
        let p. assume Hp: p :e setprod X Y.
        prove exists b :e product_basis_from Bx By, p :e b.
        (** Use setprod_elem_decompose to extract coordinates **)
        claim Hcoords: exists x :e X, exists y :e Y, p :e setprod {x} {y}.
        { exact (setprod_elem_decompose X Y p Hp). }
        apply Hcoords.
        let x. assume Hx_conj: x :e X /\ exists y :e Y, p :e setprod {x} {y}.
        claim Hx: x :e X.
        { exact (andEL (x :e X) (exists y :e Y, p :e setprod {x} {y}) Hx_conj). }
        claim Hy_exists: exists y :e Y, p :e setprod {x} {y}.
        { exact (andER (x :e X) (exists y :e Y, p :e setprod {x} {y}) Hx_conj). }
        apply Hy_exists.
        let y. assume Hy_conj: y :e Y /\ p :e setprod {x} {y}.
        claim Hy: y :e Y.
        { exact (andEL (y :e Y) (p :e setprod {x} {y}) Hy_conj). }
        claim Hp_sing: p :e setprod {x} {y}.
        { exact (andER (y :e Y) (p :e setprod {x} {y}) Hy_conj). }
        (** Use covering property of Bx to find U containing x **)
        claim HBx_cover: forall x' :e X, exists U :e Bx, x' :e U.
        { exact (andER (Bx c= Power X) (forall x' :e X, exists U :e Bx, x' :e U)
                       (andEL (Bx c= Power X /\ (forall x' :e X, exists U :e Bx, x' :e U))
                              (forall b1 :e Bx, forall b2 :e Bx, forall x':set, x' :e b1 -> x' :e b2 -> exists b3 :e Bx, x' :e b3 /\ b3 c= b1 :/\: b2)
                              HBx_basis)). }
        claim HU_exists: exists U :e Bx, x :e U.
        { exact (HBx_cover x Hx). }
        apply HU_exists.
        let U. assume HU_conj: U :e Bx /\ x :e U.
        claim HU: U :e Bx.
        { exact (andEL (U :e Bx) (x :e U) HU_conj). }
        claim Hx_in_U: x :e U.
        { exact (andER (U :e Bx) (x :e U) HU_conj). }
        (** Use covering property of By to find V containing y **)
        claim HBy_cover: forall y' :e Y, exists V :e By, y' :e V.
        { exact (andER (By c= Power Y) (forall y' :e Y, exists V :e By, y' :e V)
                       (andEL (By c= Power Y /\ (forall y' :e Y, exists V :e By, y' :e V))
                              (forall b1 :e By, forall b2 :e By, forall y':set, y' :e b1 -> y' :e b2 -> exists b3 :e By, y' :e b3 /\ b3 c= b1 :/\: b2)
                              HBy_basis)). }
        claim HV_exists: exists V :e By, y :e V.
        { exact (HBy_cover y Hy). }
        apply HV_exists.
        let V. assume HV_conj: V :e By /\ y :e V.
        claim HV: V :e By.
        { exact (andEL (V :e By) (y :e V) HV_conj). }
        claim Hy_in_V: y :e V.
        { exact (andER (V :e By) (y :e V) HV_conj). }
        (** Now show p :e setprod U V using singleton subsets **)
        claim Hx_sing_sub: {x} c= U.
        { exact (singleton_subset x U Hx_in_U). }
        claim Hy_sing_sub: {y} c= V.
        { exact (singleton_subset y V Hy_in_V). }
        claim HUV_sub: setprod {x} {y} c= setprod U V.
        { exact (setprod_Subq {x} {y} U V Hx_sing_sub Hy_sing_sub). }
        claim Hp_in_UV: p :e setprod U V.
        { exact (HUV_sub p Hp_sing). }
        (** Finally, witness setprod U V :e product_basis_from Bx By **)
        witness (setprod U V).
        prove setprod U V :e product_basis_from Bx By /\ p :e setprod U V.
        apply andI.
        + (** Show setprod U V :e product_basis_from Bx By **)
          claim HUVinRepl: setprod U V :e {setprod U V' | V' :e By}.
          { exact (ReplI By (fun V' => setprod U V') V HV). }
          exact (famunionI Bx (fun U' => {setprod U' V' | V' :e By}) U (setprod U V) HU HUVinRepl).
        + exact Hp_in_UV.

    * (** Axiom 3: intersection property **)
      let b1. assume Hb1: b1 :e product_basis_from Bx By.
      let b2. assume Hb2: b2 :e product_basis_from Bx By.
      let p. assume Hpb1: p :e b1. assume Hpb2: p :e b2.
      prove exists b3 :e product_basis_from Bx By, p :e b3 /\ b3 c= b1 :/\: b2.
      (** Extract U1, V1 from b1 **)
      claim Hexists1: exists U1 :e Bx, b1 :e {setprod U1 V' | V' :e By}.
      { exact (famunionE Bx (fun U' => {setprod U' V' | V' :e By}) b1 Hb1). }
      apply Hexists1.
      let U1. assume HU1_conj: U1 :e Bx /\ b1 :e {setprod U1 V' | V' :e By}.
      claim HU1: U1 :e Bx.
      { exact (andEL (U1 :e Bx) (b1 :e {setprod U1 V' | V' :e By}) HU1_conj). }
      claim Hb1Repl: b1 :e {setprod U1 V' | V' :e By}.
      { exact (andER (U1 :e Bx) (b1 :e {setprod U1 V' | V' :e By}) HU1_conj). }
      claim Hexists1b: exists V1 :e By, b1 = setprod U1 V1.
      { exact (ReplE By (fun V' => setprod U1 V') b1 Hb1Repl). }
      apply Hexists1b.
      let V1. assume HV1_conj: V1 :e By /\ b1 = setprod U1 V1.
      claim HV1: V1 :e By.
      { exact (andEL (V1 :e By) (b1 = setprod U1 V1) HV1_conj). }
      claim Hb1eq: b1 = setprod U1 V1.
      { exact (andER (V1 :e By) (b1 = setprod U1 V1) HV1_conj). }
      (** Extract U2, V2 from b2 **)
      claim Hexists2: exists U2 :e Bx, b2 :e {setprod U2 V' | V' :e By}.
      { exact (famunionE Bx (fun U' => {setprod U' V' | V' :e By}) b2 Hb2). }
      apply Hexists2.
      let U2. assume HU2_conj: U2 :e Bx /\ b2 :e {setprod U2 V' | V' :e By}.
      claim HU2: U2 :e Bx.
      { exact (andEL (U2 :e Bx) (b2 :e {setprod U2 V' | V' :e By}) HU2_conj). }
      claim Hb2Repl: b2 :e {setprod U2 V' | V' :e By}.
      { exact (andER (U2 :e Bx) (b2 :e {setprod U2 V' | V' :e By}) HU2_conj). }
      claim Hexists2b: exists V2 :e By, b2 = setprod U2 V2.
      { exact (ReplE By (fun V' => setprod U2 V') b2 Hb2Repl). }
      apply Hexists2b.
      let V2. assume HV2_conj: V2 :e By /\ b2 = setprod U2 V2.
      claim HV2: V2 :e By.
      { exact (andEL (V2 :e By) (b2 = setprod U2 V2) HV2_conj). }
      claim Hb2eq: b2 = setprod U2 V2.
      { exact (andER (V2 :e By) (b2 = setprod U2 V2) HV2_conj). }
      (** Show p :e setprod X Y **)
      claim Hb1sub: b1 c= setprod X Y.
      { claim Hb1Power: b1 :e Power (setprod X Y).
        { (** Use same logic as Axiom 1 **)
          claim HBx_sub: Bx c= Power X.
          { exact (andEL (Bx c= Power X) (forall x :e X, exists b :e Bx, x :e b) (andEL (Bx c= Power X /\ (forall x :e X, exists b :e Bx, x :e b)) (forall b1 :e Bx, forall b2 :e Bx, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e Bx, x :e b3 /\ b3 c= b1 :/\: b2) HBx_basis)). }
          claim HBy_sub: By c= Power Y.
          { exact (andEL (By c= Power Y) (forall y :e Y, exists b :e By, y :e b) (andEL (By c= Power Y /\ (forall y :e Y, exists b :e By, y :e b)) (forall b1 :e By, forall b2 :e By, forall y:set, y :e b1 -> y :e b2 -> exists b3 :e By, y :e b3 /\ b3 c= b1 :/\: b2) HBy_basis)). }
          claim HU1subX: U1 c= X.
          { exact (PowerE X U1 (HBx_sub U1 HU1)). }
          claim HV1subY: V1 c= Y.
          { exact (PowerE Y V1 (HBy_sub V1 HV1)). }
          claim HU1V1sub: setprod U1 V1 c= setprod X Y.
          { exact (setprod_Subq U1 V1 X Y HU1subX HV1subY). }
          claim Hb1sub_inner: b1 c= setprod X Y.
          { rewrite Hb1eq. exact HU1V1sub. }
          exact (PowerI (setprod X Y) b1 Hb1sub_inner). }
        exact (PowerE (setprod X Y) b1 Hb1Power). }
      claim Hp_XY: p :e setprod X Y.
      { exact (Hb1sub p Hpb1). }
      (** Extract coordinates x, y from p **)
      claim Hcoords: exists x :e X, exists y :e Y, p :e setprod {x} {y}.
      { exact (setprod_elem_decompose X Y p Hp_XY). }
      apply Hcoords.
      let x. assume Hx_conj: x :e X /\ exists y :e Y, p :e setprod {x} {y}.
      claim Hx: x :e X.
      { exact (andEL (x :e X) (exists y :e Y, p :e setprod {x} {y}) Hx_conj). }
      claim Hy_exists: exists y :e Y, p :e setprod {x} {y}.
      { exact (andER (x :e X) (exists y :e Y, p :e setprod {x} {y}) Hx_conj). }
      apply Hy_exists.
      let y. assume Hy_conj: y :e Y /\ p :e setprod {x} {y}.
      claim Hy: y :e Y.
      { exact (andEL (y :e Y) (p :e setprod {x} {y}) Hy_conj). }
      claim Hp_sing: p :e setprod {x} {y}.
      { exact (andER (y :e Y) (p :e setprod {x} {y}) Hy_conj). }
      (** Show x :e U1 :/\: U2 and y :e V1 :/\: V2 **)
      claim Hp_b1: p :e setprod U1 V1.
      { rewrite <- Hb1eq. exact Hpb1. }
      claim Hp_b2: p :e setprod U2 V2.
      { rewrite <- Hb2eq. exact Hpb2. }
      claim Hxy_U1V1: x :e U1 /\ y :e V1.
      { exact (setprod_coords_in x y U1 V1 p Hp_sing Hp_b1). }
      claim Hxy_U2V2: x :e U2 /\ y :e V2.
      { exact (setprod_coords_in x y U2 V2 p Hp_sing Hp_b2). }
      claim Hx_U1: x :e U1.
      { exact (andEL (x :e U1) (y :e V1) Hxy_U1V1). }
      claim Hy_V1: y :e V1.
      { exact (andER (x :e U1) (y :e V1) Hxy_U1V1). }
      claim Hx_U2: x :e U2.
      { exact (andEL (x :e U2) (y :e V2) Hxy_U2V2). }
      claim Hy_V2: y :e V2.
      { exact (andER (x :e U2) (y :e V2) Hxy_U2V2). }
      (** Use basis intersection property for Bx **)
      claim HBx_intersect: forall b1' :e Bx, forall b2' :e Bx, forall x':set,
        x' :e b1' -> x' :e b2' -> exists b3' :e Bx, x' :e b3' /\ b3' c= b1' :/\: b2'.
      { exact (andER (Bx c= Power X /\ (forall x' :e X, exists b :e Bx, x' :e b))
                     (forall b1' :e Bx, forall b2' :e Bx, forall x':set, x' :e b1' -> x' :e b2' -> exists b3' :e Bx, x' :e b3' /\ b3' c= b1' :/\: b2')
                     HBx_basis). }
      claim HU3_exists: exists U3 :e Bx, x :e U3 /\ U3 c= U1 :/\: U2.
      { exact (HBx_intersect U1 HU1 U2 HU2 x Hx_U1 Hx_U2). }
      apply HU3_exists.
      let U3. assume HU3_conj: U3 :e Bx /\ (x :e U3 /\ U3 c= U1 :/\: U2).
      claim HU3: U3 :e Bx.
      { exact (andEL (U3 :e Bx) (x :e U3 /\ U3 c= U1 :/\: U2) HU3_conj). }
      claim Hx_U3_and_sub: x :e U3 /\ U3 c= U1 :/\: U2.
      { exact (andER (U3 :e Bx) (x :e U3 /\ U3 c= U1 :/\: U2) HU3_conj). }
      claim Hx_U3: x :e U3.
      { exact (andEL (x :e U3) (U3 c= U1 :/\: U2) Hx_U3_and_sub). }
      claim HU3_sub: U3 c= U1 :/\: U2.
      { exact (andER (x :e U3) (U3 c= U1 :/\: U2) Hx_U3_and_sub). }
      (** Use basis intersection property for By **)
      claim HBy_intersect: forall b1' :e By, forall b2' :e By, forall y':set,
        y' :e b1' -> y' :e b2' -> exists b3' :e By, y' :e b3' /\ b3' c= b1' :/\: b2'.
      { exact (andER (By c= Power Y /\ (forall y' :e Y, exists b :e By, y' :e b))
                     (forall b1' :e By, forall b2' :e By, forall y':set, y' :e b1' -> y' :e b2' -> exists b3' :e By, y' :e b3' /\ b3' c= b1' :/\: b2')
                     HBy_basis). }
      claim HV3_exists: exists V3 :e By, y :e V3 /\ V3 c= V1 :/\: V2.
      { exact (HBy_intersect V1 HV1 V2 HV2 y Hy_V1 Hy_V2). }
      apply HV3_exists.
      let V3. assume HV3_conj: V3 :e By /\ (y :e V3 /\ V3 c= V1 :/\: V2).
      claim HV3: V3 :e By.
      { exact (andEL (V3 :e By) (y :e V3 /\ V3 c= V1 :/\: V2) HV3_conj). }
      claim Hy_V3_and_sub: y :e V3 /\ V3 c= V1 :/\: V2.
      { exact (andER (V3 :e By) (y :e V3 /\ V3 c= V1 :/\: V2) HV3_conj). }
      claim Hy_V3: y :e V3.
      { exact (andEL (y :e V3) (V3 c= V1 :/\: V2) Hy_V3_and_sub). }
      claim HV3_sub: V3 c= V1 :/\: V2.
      { exact (andER (y :e V3) (V3 c= V1 :/\: V2) Hy_V3_and_sub). }
      (** Show p :e setprod U3 V3 **)
      claim Hx_sing_sub: {x} c= U3.
      { exact (singleton_subset x U3 Hx_U3). }
      claim Hy_sing_sub: {y} c= V3.
      { exact (singleton_subset y V3 Hy_V3). }
      claim HU3V3_super: setprod {x} {y} c= setprod U3 V3.
      { exact (setprod_Subq {x} {y} U3 V3 Hx_sing_sub Hy_sing_sub). }
      claim Hp_U3V3: p :e setprod U3 V3.
      { exact (HU3V3_super p Hp_sing). }
      (** Show setprod U3 V3 c= b1 :/\: b2 **)
      claim Hb1b2_int: b1 :/\: b2 = setprod U1 V1 :/\: setprod U2 V2.
      { rewrite Hb1eq. rewrite Hb2eq. reflexivity. }
      claim Hprod_int: setprod U1 V1 :/\: setprod U2 V2 = setprod (U1 :/\: U2) (V1 :/\: V2).
      { exact (setprod_intersection U1 V1 U2 V2). }
      claim HU3V3_sub: setprod U3 V3 c= setprod (U1 :/\: U2) (V1 :/\: V2).
      { exact (setprod_Subq U3 V3 (U1 :/\: U2) (V1 :/\: V2) HU3_sub HV3_sub). }
      claim HU3V3_sub_b1b2: setprod U3 V3 c= b1 :/\: b2.
      { rewrite Hb1b2_int. rewrite Hprod_int. exact HU3V3_sub. }
      (** Witness setprod U3 V3 **)
      witness (setprod U3 V3).
      prove setprod U3 V3 :e product_basis_from Bx By /\ (p :e setprod U3 V3 /\ setprod U3 V3 c= b1 :/\: b2).
      apply andI.
      + claim HU3V3inRepl: setprod U3 V3 :e {setprod U3 V' | V' :e By}.
        { exact (ReplI By (fun V' => setprod U3 V') V3 HV3). }
        exact (famunionI Bx (fun U' => {setprod U' V' | V' :e By}) U3 (setprod U3 V3) HU3 HU3V3inRepl).
      + apply andI.
        - exact Hp_U3V3.
        - exact HU3V3_sub_b1b2.
  + (** Prove forall U :e Bx, forall V :e By, setprod U V :e product_basis_from Bx By **)
    let U. assume HU: U :e Bx.
    let V. assume HV: V :e By.
    prove setprod U V :e product_basis_from Bx By.
    (** product_basis_from Bx By = \/_ U' :e Bx, {setprod U' V' | V' :e By} **)
    (** Use famunionI with U :e Bx and setprod U V :e {setprod U V' | V' :e By} **)
    claim HUVinRepl: setprod U V :e {setprod U V' | V' :e By}.
    { exact (ReplI By (fun V' => setprod U V') V HV). }
    exact (famunionI Bx (fun U' => {setprod U' V' | V' :e By}) U (setprod U V) HU HUVinRepl).
- (** Part 3: generated_topology (setprod X Y) (product_basis_from Bx By) = product_topology X Tx Y Ty **)
  (** product_topology X Tx Y Ty = generated_topology (setprod X Y) (product_subbasis X Tx Y Ty) **)
  (** product_subbasis X Tx Y Ty uses Tx and Ty, which equal generated_topology X Bx and generated_topology Y By **)
  (** product_basis_from Bx By = {UV | U :e Bx, V :e By} **)
  (** Use the axiom that product basis generates product topology **)
  claim HBx_basis: basis_on X Bx.
  { exact (andEL (basis_on X Bx) (generated_topology X Bx = Tx) HBx). }
  claim HBy_basis: basis_on Y By.
  { exact (andEL (basis_on Y By) (generated_topology Y By = Ty) HBy). }
  claim HTx_eq: generated_topology X Bx = Tx.
  { exact (andER (basis_on X Bx) (generated_topology X Bx = Tx) HBx). }
  claim HTy_eq: generated_topology Y By = Ty.
  { exact (andER (basis_on Y By) (generated_topology Y By = Ty) HBy). }
  exact (product_basis_generates_product_topology X Y Bx By Tx Ty HBx_basis HTx_eq HBy_basis HTy_eq).
Qed.

(** from 15 Definition: projections on a product **) 
(** LATEX VERSION: Define coordinate projection relations  and  from XY. **)
(** FIXED: Projections must use ordered pairs for function graphs.
    proj: XY  X maps (x,y)  x, graph = {((x,y), x) | xX, yY}.
    proj: XY  Y maps (x,y)  y, graph = {((x,y), y) | xX, yY}.
    Was using UPair (setprod x y) which is wrong on two counts:
    (1) UPair is unordered, need ordered pairs (tuple notation)
    (2) setprod x y is XY cartesian product, need (x,y) for single ordered pair **)
Definition projection1 : set -> set -> set := fun X Y =>
  {(p, p 0) | p :e setprod X Y}.
Definition projection2 : set -> set -> set := fun X Y =>
  {(p, p 1) | p :e setprod X Y}.

(** from 15 Theorem 15.2: projection preimages form a subbasis **) 
(** LATEX VERSION: The inverse images of opens under projections give a subbasis for the product topology. **)
Theorem product_subbasis_from_projections : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  exists S:set,
    S = product_subbasis X Tx Y Ty /\
    generated_topology (setprod X Y) S = product_topology X Tx Y Ty.
let X Tx Y Ty.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove exists S:set,
    S = product_subbasis X Tx Y Ty /\
    generated_topology (setprod X Y) S = product_topology X Tx Y Ty.
(** Witness S = product_subbasis X Tx Y Ty **)
witness (product_subbasis X Tx Y Ty).
prove product_subbasis X Tx Y Ty = product_subbasis X Tx Y Ty /\
      generated_topology (setprod X Y) (product_subbasis X Tx Y Ty) = product_topology X Tx Y Ty.
apply andI.
- (** S = product_subbasis X Tx Y Ty **)
  reflexivity.
- (** generated_topology (setprod X Y) S = product_topology X Tx Y Ty **)
  (** By definition: product_topology X Tx Y Ty = generated_topology (setprod X Y) (product_subbasis X Tx Y Ty) **)
  reflexivity.
Qed.

(** FIXED: Function-related definitions must use ordered pairs, not UPair.
    Functions are represented as sets of ordered pairs (x,y) where xy.
    apply_fun looks up y such that (x,y)  f.
    Identity function: {(y,y) | y  X}.
    Constant family: {(i, X) | i  I}. **)
(** SUSPICIOUS DEFINITION: `apply_fun` is based on `Eps_i`, so `function_on` only constrains the chosen values, not that `f` is a genuine functional graph; later results about unions/preimages may require extra axioms. Use `total_function_on` when totality is required. **)
Definition apply_fun : set -> set -> set := fun f x => Eps_i (fun y => (x,y) :e f).
Definition function_on : set -> set -> set -> prop := fun f X Y => forall x:set, x :e X -> apply_fun f x :e Y.
Definition function_space : set -> set -> set := fun X Y => {f :e Power (setprod X Y)|function_on f X Y}.

(** Helper: graph of a meta level function as a set of ordered pairs **)
Definition graph : set -> (set -> set) -> set := fun A g => {(a, g a) | a :e A}.

(** Helper: evaluating apply_fun on a graph built by Repl **)
Theorem apply_fun_graph : forall A:set, forall g:set->set, forall a:set,
  a :e A -> apply_fun (graph A g) a = g a.
let A g a.
assume Ha: a :e A.
prove apply_fun (graph A g) a = g a.
prove Eps_i (fun y => (a,y) :e graph A g) = g a.
claim H1: (a, g a) :e graph A g.
{ exact (ReplI A (fun a0:set => (a0, g a0)) a Ha). }
claim H2: (a, Eps_i (fun y => (a,y) :e graph A g)) :e graph A g.
{ exact (Eps_i_ax (fun y => (a,y) :e graph A g) (g a) H1). }
apply (ReplE_impred A (fun a0:set => (a0, g a0))
        (a, Eps_i (fun y => (a,y) :e graph A g)) H2
        (Eps_i (fun y => (a,y) :e graph A g) = g a)).
let a0. assume Ha0: a0 :e A.
assume Heq: (a, Eps_i (fun y => (a,y) :e graph A g)) = (a0, g a0).
claim Ha_eq: a = a0.
{ rewrite <- (tuple_2_0_eq a (Eps_i (fun y => (a,y) :e graph A g))).
  rewrite <- (tuple_2_0_eq a0 (g a0)).
  rewrite Heq.
  reflexivity. }
claim Hy_eq: Eps_i (fun y => (a,y) :e graph A g) = g a0.
{ rewrite <- (tuple_2_1_eq a (Eps_i (fun y => (a,y) :e graph A g))).
  rewrite <- (tuple_2_1_eq a0 (g a0)).
  rewrite Heq.
  reflexivity. }
rewrite Hy_eq.
rewrite <- Ha_eq.
reflexivity.
Qed.

(** Helper: total function graph on X into Y (in addition to function_on) **)
Definition total_function_on : set -> set -> set -> prop := fun f X Y =>
  function_on f X Y /\ forall x:set, x :e X -> exists y:set, y :e Y /\ (x,y) :e f.

(** Helper: total_function_on implies function_on **)
Theorem total_function_on_function_on : forall f X Y:set,
  total_function_on f X Y -> function_on f X Y.
let f X Y.
assume H: total_function_on f X Y.
exact (andEL (function_on f X Y)
             (forall x:set, x :e X -> exists y:set, y :e Y /\ (x,y) :e f)
             H).
Qed.

(** Helper: total_function_on gives a graph witness for each x **)
Theorem total_function_on_totality : forall f X Y:set,
  total_function_on f X Y ->
  forall x:set, x :e X -> exists y:set, y :e Y /\ (x,y) :e f.
let f X Y.
assume H: total_function_on f X Y.
exact (andER (function_on f X Y)
             (forall x:set, x :e X -> exists y:set, y :e Y /\ (x,y) :e f)
             H).
Qed.

(** Helper: constant function as a graph **)
Definition const_fun : set -> set -> set := fun A x => {(a,x) | a :e A}.

(** Helper: apply_fun for const_fun **)
Theorem const_fun_apply : forall A x a:set,
  a :e A ->
  apply_fun (const_fun A x) a = x.
let A x a.
assume Ha: a :e A.
prove apply_fun (const_fun A x) a = x.
prove Eps_i (fun y => (a,y) :e const_fun A x) = x.
claim H1: (a,x) :e const_fun A x.
{ exact (ReplI A (fun a0:set => (a0,x)) a Ha). }
claim H2: (a, Eps_i (fun y => (a,y) :e const_fun A x)) :e const_fun A x.
{ exact (Eps_i_ax (fun y => (a,y) :e const_fun A x) x H1). }
apply (ReplE_impred A (fun a0:set => (a0,x)) (a, Eps_i (fun y => (a,y) :e const_fun A x)) H2).
let a0.
assume Ha0: a0 :e A.
assume Heq: (a, Eps_i (fun y => (a,y) :e const_fun A x)) = (a0,x).
	rewrite <- (tuple_2_1_eq a (Eps_i (fun y => (a,y) :e const_fun A x))) at 1.
	rewrite <- (tuple_2_1_eq a0 x) at 2.
	rewrite Heq.
	reflexivity.
	Qed.

(** Helper: const_fun is total_function_on **)
Theorem const_fun_total_function_on : forall A Y x:set,
  x :e Y -> total_function_on (const_fun A x) A Y.
let A Y x.
assume HxY: x :e Y.
prove function_on (const_fun A x) A Y /\
  forall a:set, a :e A -> exists y:set, y :e Y /\ (a,y) :e const_fun A x.
apply andI.
- (** function_on **)
  let a. assume HaA: a :e A.
  prove apply_fun (const_fun A x) a :e Y.
  claim Happ: apply_fun (const_fun A x) a = x.
  { exact (const_fun_apply A x a HaA). }
  rewrite Happ.
  exact HxY.
- (** totality **)
  let a. assume HaA: a :e A.
  prove exists y:set, y :e Y /\ (a,y) :e const_fun A x.
  witness x.
  apply andI.
  + exact HxY.
  + exact (ReplI A (fun a0:set => (a0,x)) a HaA).
Qed.

		(** Helper: identity function application **)
Theorem identity_function_apply : forall X x:set,
  x :e X -> apply_fun {(y,y) | y :e X} x = x.
let X x. assume Hx: x :e X.
prove apply_fun {(y,y) | y :e X} x = x.
prove Eps_i (fun z => (x,z) :e {(y,y) | y :e X}) = x.
claim H1: (x,x) :e {(y,y) | y :e X}.
{ exact (ReplI X (fun y => (y,y)) x Hx). }
claim H2: (x, Eps_i (fun z => (x,z) :e {(y,y) | y :e X})) :e {(y,y) | y :e X}.
{ exact (Eps_i_ax (fun z => (x,z) :e {(y,y) | y :e X}) x H1). }
apply (ReplE_impred X (fun y => (y,y)) (x, Eps_i (fun z => (x,z) :e {(y,y) | y :e X})) H2).
let y.
assume Hy: y :e X.
assume Heq: (x, Eps_i (fun z => (x,z) :e {(y,y) | y :e X})) = (y,y).
claim Hx_eq: x = y.
{ rewrite <- (tuple_2_0_eq x (Eps_i (fun z => (x,z) :e {(y,y) | y :e X}))).
  rewrite <- (tuple_2_0_eq y y).
  rewrite Heq.
  reflexivity. }
claim Hz_eq: Eps_i (fun z => (x,z) :e {(y,y) | y :e X}) = y.
{ rewrite <- (tuple_2_1_eq x (Eps_i (fun z => (x,z) :e {(y,y) | y :e X}))).
  rewrite <- (tuple_2_1_eq y y).
  rewrite Heq.
  reflexivity. }
rewrite Hz_eq.
rewrite <- Hx_eq.
reflexivity.
Qed.

(** Helper: identity graph is total_function_on **)
Theorem identity_total_function_on : forall X:set,
  total_function_on {(y,y) | y :e X} X X.
let X.
prove function_on {(y,y) | y :e X} X X /\
  forall x:set, x :e X -> exists y:set, y :e X /\ (x,y) :e {(y,y) | y :e X}.
apply andI.
- let x. assume HxX: x :e X.
  prove apply_fun {(y,y) | y :e X} x :e X.
  rewrite (identity_function_apply X x HxX).
  exact HxX.
- let x. assume HxX: x :e X.
  prove exists y:set, y :e X /\ (x,y) :e {(y,y) | y :e X}.
  witness x.
  apply andI.
  + exact HxX.
  + exact (ReplI X (fun y0:set => (y0,y0)) x HxX).
Qed.

Definition const_family : set -> set -> set := fun I X => {(i,X)|i :e I}.

(** Helper: apply_fun for const_family **)
Theorem const_family_apply : forall I X i:set,
  i :e I -> apply_fun (const_family I X) i = X.
let I X i.
assume Hi: i :e I.
prove apply_fun (const_family I X) i = X.
exact (const_fun_apply I X i Hi).
Qed.

Definition product_component : set -> set -> set := fun Xi i => (apply_fun Xi i) 0.
Definition product_component_topology : set -> set -> set := fun Xi i => (apply_fun Xi i) 1.

(** Helper: unfold product_component and product_component_topology **)
Theorem product_component_def : forall Xi i:set,
  product_component Xi i = (apply_fun Xi i) 0.
let Xi i.
prove product_component Xi i = (apply_fun Xi i) 0.
reflexivity.
Qed.

Theorem product_component_topology_def : forall Xi i:set,
  product_component_topology Xi i = (apply_fun Xi i) 1.
let Xi i.
prove product_component_topology Xi i = (apply_fun Xi i) 1.
reflexivity.
Qed.

(** family of spaces as a family of pairs (X_i, T_i) **) 
Definition const_space_family : set -> set -> set -> set := fun I X Tx =>
  {(i,(X,Tx))|i :e I}.

(** Helper: apply_fun for const_space_family **)
Theorem const_space_family_apply : forall I X Tx i:set,
  i :e I -> apply_fun (const_space_family I X Tx) i = (X,Tx).
let I X Tx i.
assume Hi: i :e I.
prove apply_fun (const_space_family I X Tx) i = (X,Tx).
exact (const_fun_apply I (X,Tx) i Hi).
Qed.

Definition space_family_set : set -> set -> set := fun Xi i => (apply_fun Xi i) 0.
Definition space_family_topology : set -> set -> set := fun Xi i => (apply_fun Xi i) 1.

Definition space_family_union : set -> set -> set := fun I Xi =>
  Union {space_family_set Xi i|i :e I}.
Definition topology_family_union : set -> set -> set := fun I Xi =>
  Union {space_family_topology Xi i|i :e I}.

Definition product_space : set -> set -> set := fun I Xi =>
  {f :e Power (setprod I (space_family_union I Xi))|
     function_on f I (space_family_union I Xi) /\
     forall i:set, i :e I -> apply_fun f i :e space_family_set Xi i}.
Definition product_cylinder : set -> set -> set -> set -> set :=
  fun I Xi i U =>
    {f :e product_space I Xi | i :e I /\ U :e space_family_topology Xi i /\ apply_fun f i :e U}.
Definition product_subbasis_full : set -> set -> set :=
  fun I Xi => \/_ i :e I, {product_cylinder I Xi i U|U :e space_family_topology Xi i}.
Definition product_topology_full : set -> set -> set := fun I Xi =>
  generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi).
(** FIXED: Was using Power set which generates discrete topology, not box topology!
    Was: generated_topology (product_space I Xi) (Power (product_space I Xi))
         (Power set as subbasis generates discrete topology - all sets open!)
    Now: Box basis = products of open sets from each component
         Box topology = topology generated by box basis **)
Definition box_basis : set -> set -> set := fun I Xi =>
  {B :e Power (product_space I Xi) |
    exists U:set, function_on U I (topology_family_union I Xi) /\
      (forall i:set, i :e I -> apply_fun U i :e space_family_topology Xi i) /\
      B = {f :e product_space I Xi | forall i:set, i :e I -> apply_fun f i :e apply_fun U i}}.
Definition box_topology : set -> set -> set := fun I Xi =>
  generated_topology (product_space I Xi) (box_basis I Xi).
Definition countable_product_space : set -> set -> set := fun I Xi =>
  product_space I Xi.
Definition countable_product_topology : set -> set -> set := fun I Xi =>
  product_topology_full I Xi.
Definition euclidean_space : set -> set := fun n => product_space n (const_space_family n R R_standard_topology).
Definition euclidean_topology : set -> set := fun n => product_topology_full n (const_space_family n R R_standard_topology).

(** from 15 Example: standard topology on  as product topology **) 
(** LATEX VERSION: The standard topology on  coincides with the product of the standard topologies on . **)
Definition R2_standard_topology : set := product_topology R R_standard_topology R R_standard_topology.

Theorem R2_standard_equals_product :
  R2_standard_topology = product_topology R R_standard_topology R R_standard_topology.
prove R2_standard_topology = product_topology R R_standard_topology R R_standard_topology.
(** R2_standard_topology is defined as product_topology R R_standard_topology R R_standard_topology **)
reflexivity.
Qed.

(** from 16 Definition: subspace topology **) 
(** LATEX VERSION: The subspace topology on YX with topology Tx consists of intersections VY with V open in X. **)
Definition subspace_topology : set -> set -> set -> set :=
  fun X Tx Y => {U :e Power Y | exists V :e Tx, U = V :/\: Y}.

(** helper: subspace topology on whole space equals original topology **)
Theorem subspace_topology_whole : forall X Tx:set,
  topology_on X Tx ->
  subspace_topology X Tx X = Tx.
let X Tx.
assume HTx: topology_on X Tx.
prove subspace_topology X Tx X = Tx.
apply set_ext.
- let U. assume HU: U :e subspace_topology X Tx X.
  prove U :e Tx.
  claim Hex: exists V :e Tx, U = V :/\: X.
  { exact (SepE2 (Power X) (fun U0:set => exists V :e Tx, U0 = V :/\: X) U HU). }
  apply Hex.
  let V. assume HVpair.
  claim HV: V :e Tx.
  { exact (andEL (V :e Tx) (U = V :/\: X) HVpair). }
  claim HUeq: U = V :/\: X.
  { exact (andER (V :e Tx) (U = V :/\: X) HVpair). }
  claim HVsub: V c= X.
  { exact (topology_elem_subset X Tx V HTx HV). }
  claim HVeql: V :/\: X = V.
  { exact (binintersect_Subq_eq_1 V X HVsub). }
  claim HUeqV: U = V.
  { rewrite HUeq. exact HVeql. }
  rewrite HUeqV.
  exact HV.
- let U. assume HU: U :e Tx.
  prove U :e subspace_topology X Tx X.
  claim HUsub: U c= X.
  { exact (topology_elem_subset X Tx U HTx HU). }
  claim HUpow: U :e Power X.
  { exact (PowerI X U HUsub). }
  claim Hex: exists V :e Tx, U = V :/\: X.
  { witness U.
    apply andI.
    - exact HU.
    - prove U = U :/\: X.
      rewrite (binintersect_Subq_eq_1 U X HUsub).
      reflexivity. }
  exact (SepI (Power X) (fun U0:set => exists V :e Tx, U0 = V :/\: X) U HUpow Hex).
Qed.

(** from 16: subspace topology is a topology **) 
(** LATEX VERSION: The subspace topology on Y inherits the topology axioms. **)
Theorem subspace_topology_is_topology : forall X Tx Y:set,
  topology_on X Tx -> Y c= X ->
  topology_on Y (subspace_topology X Tx Y).
let X Tx Y.
assume HTx: topology_on X Tx.
assume HY: Y c= X.
prove topology_on Y (subspace_topology X Tx Y).
prove subspace_topology X Tx Y c= Power Y
  /\ Empty :e subspace_topology X Tx Y
  /\ Y :e subspace_topology X Tx Y
  /\ (forall UFam :e Power (subspace_topology X Tx Y), Union UFam :e subspace_topology X Tx Y)
  /\ (forall U :e subspace_topology X Tx Y, forall V :e subspace_topology X Tx Y, U :/\: V :e subspace_topology X Tx Y).
apply andI.
- prove (subspace_topology X Tx Y c= Power Y /\ Empty :e subspace_topology X Tx Y) /\ Y :e subspace_topology X Tx Y /\ (forall UFam :e Power (subspace_topology X Tx Y), Union UFam :e subspace_topology X Tx Y).
  apply andI.
  + prove subspace_topology X Tx Y c= Power Y /\ Empty :e subspace_topology X Tx Y /\ Y :e subspace_topology X Tx Y.
    apply andI.
    * prove subspace_topology X Tx Y c= Power Y /\ Empty :e subspace_topology X Tx Y.
      apply andI.
      { prove subspace_topology X Tx Y c= Power Y.
        let U. assume HU: U :e subspace_topology X Tx Y.
        exact (SepE1 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HU).
      }
      { prove Empty :e subspace_topology X Tx Y.
        claim HEmptyTx: Empty :e Tx.
        { exact (topology_has_empty X Tx HTx). }
        claim HPred: exists V :e Tx, Empty = V :/\: Y.
        { witness Empty.
          apply andI.
          - exact HEmptyTx.
          - prove Empty = Empty :/\: Y.
            claim H1: Empty :/\: Y = Empty.
            { apply Empty_Subq_eq.
              exact (binintersect_Subq_1 Empty Y). }
            rewrite H1.
            reflexivity.
        }
        exact (SepI (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) Empty (Empty_In_Power Y) HPred).
      }
    * prove Y :e subspace_topology X Tx Y.
      claim HXTx: X :e Tx.
      { exact (topology_has_X X Tx HTx). }
      claim HPredY: exists V :e Tx, Y = V :/\: Y.
      { witness X.
        apply andI.
        - exact HXTx.
        - prove Y = X :/\: Y.
          apply set_ext.
          + let y. assume Hy: y :e Y.
            apply binintersectI.
            * exact (HY y Hy).
            * exact Hy.
          + exact (binintersect_Subq_2 X Y).
      }
      exact (SepI (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) Y (Self_In_Power Y) HPredY).
  + prove forall UFam :e Power (subspace_topology X Tx Y), Union UFam :e subspace_topology X Tx Y.
    let UFam. assume HUFam: UFam :e Power (subspace_topology X Tx Y).
    prove Union UFam :e subspace_topology X Tx Y.
    claim HUFamsub: UFam c= subspace_topology X Tx Y.
    { exact (PowerE (subspace_topology X Tx Y) UFam HUFam). }
    set VFam := {V :e Tx | exists U :e UFam, U = V :/\: Y}.
    claim HVFamTx: VFam c= Tx.
    { let V. assume HV: V :e VFam.
      exact (SepE1 Tx (fun V0 => exists U :e UFam, U = V0 :/\: Y) V HV). }
    claim HVFamPower: VFam :e Power Tx.
    { apply PowerI. exact HVFamTx. }
    claim HUnionVFam: Union VFam :e Tx.
    { exact (topology_union_closed X Tx VFam HTx HVFamTx). }
    claim HUnionEq: Union UFam = (Union VFam) :/\: Y.
    { apply set_ext.
      - let x. assume Hx: x :e Union UFam.
        apply UnionE_impred UFam x Hx.
        let U. assume HxU: x :e U. assume HUinFam: U :e UFam.
        claim HUinSubspace: U :e subspace_topology X Tx Y.
        { exact (HUFamsub U HUinFam). }
        claim HUexists: exists V :e Tx, U = V :/\: Y.
        { exact (SepE2 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HUinSubspace). }
        apply HUexists.
        let V. assume HVandEq. apply HVandEq.
        assume HVTx: V :e Tx. assume HUeq: U = V :/\: Y.
        apply binintersectI.
        + prove x :e Union VFam.
          claim HxV: x :e V.
          { claim HxVY: x :e V :/\: Y.
            { rewrite <- HUeq. exact HxU. }
            exact (binintersectE1 V Y x HxVY).
          }
          claim HVinVFam: V :e VFam.
          { apply (SepI Tx (fun V0 => exists U :e UFam, U = V0 :/\: Y) V HVTx).
            witness U. apply andI.
            - exact HUinFam.
            - exact HUeq.
          }
          exact (UnionI VFam x V HxV HVinVFam).
        + prove x :e Y.
          claim HxVY: x :e V :/\: Y.
          { rewrite <- HUeq. exact HxU. }
          exact (binintersectE2 V Y x HxVY).
      - let x. assume Hx: x :e (Union VFam) :/\: Y.
        claim HxUnionV: x :e Union VFam.
        { exact (binintersectE1 (Union VFam) Y x Hx). }
        claim HxY: x :e Y.
        { exact (binintersectE2 (Union VFam) Y x Hx). }
        apply UnionE_impred VFam x HxUnionV.
        let V. assume HxV: x :e V. assume HVinVFam: V :e VFam.
        claim HVexists: exists U :e UFam, U = V :/\: Y.
        { exact (SepE2 Tx (fun V0 => exists U :e UFam, U = V0 :/\: Y) V HVinVFam). }
        apply HVexists.
        let U. assume HUandEq. apply HUandEq.
        assume HUinFam: U :e UFam. assume HUeq: U = V :/\: Y.
        claim HxU: x :e U.
        { rewrite HUeq.
          apply binintersectI.
          - exact HxV.
          - exact HxY.
        }
        exact (UnionI UFam x U HxU HUinFam).
    }
    claim HPredUnion: exists V :e Tx, Union UFam = V :/\: Y.
    { witness (Union VFam).
      apply andI.
      - exact HUnionVFam.
      - exact HUnionEq.
    }
    claim HUnionInPowerY: Union UFam :e Power Y.
    { apply PowerI.
      let x. assume Hx: x :e Union UFam.
      claim HxVY: x :e (Union VFam) :/\: Y.
      { rewrite <- HUnionEq. exact Hx. }
      exact (binintersectE2 (Union VFam) Y x HxVY).
    }
    exact (SepI (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) (Union UFam) HUnionInPowerY HPredUnion).
- prove forall U :e subspace_topology X Tx Y, forall V :e subspace_topology X Tx Y, U :/\: V :e subspace_topology X Tx Y.
  let U. assume HU: U :e subspace_topology X Tx Y.
  let V. assume HV: V :e subspace_topology X Tx Y.
  prove U :/\: V :e subspace_topology X Tx Y.
  claim HUexists: exists V1 :e Tx, U = V1 :/\: Y.
  { exact (SepE2 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HU). }
  claim HVexists: exists V2 :e Tx, V = V2 :/\: Y.
  { exact (SepE2 (Power Y) (fun V0:set => exists V :e Tx, V0 = V :/\: Y) V HV). }
  apply HUexists.
  let V1. assume HV1andEq. apply HV1andEq.
  assume HV1Tx: V1 :e Tx. assume HUeq: U = V1 :/\: Y.
  apply HVexists.
  let V2. assume HV2andEq. apply HV2andEq.
  assume HV2Tx: V2 :e Tx. assume HVeq: V = V2 :/\: Y.
  claim HV1V2: V1 :/\: V2 :e Tx.
  { exact (topology_binintersect_closed X Tx V1 V2 HTx HV1Tx HV2Tx). }
  claim HIntEq: U :/\: V = (V1 :/\: V2) :/\: Y.
  { rewrite HUeq.
    rewrite HVeq.
    prove (V1 :/\: Y) :/\: (V2 :/\: Y) = (V1 :/\: V2) :/\: Y.
    apply set_ext.
    - let x. assume Hx: x :e (V1 :/\: Y) :/\: (V2 :/\: Y).
      claim HxV1Y: x :e V1 :/\: Y.
      { exact (binintersectE1 (V1 :/\: Y) (V2 :/\: Y) x Hx). }
      claim HxV2Y: x :e V2 :/\: Y.
      { exact (binintersectE2 (V1 :/\: Y) (V2 :/\: Y) x Hx). }
      claim HxV1: x :e V1.
      { exact (binintersectE1 V1 Y x HxV1Y). }
      claim HxV2: x :e V2.
      { exact (binintersectE1 V2 Y x HxV2Y). }
      claim HxY: x :e Y.
      { exact (binintersectE2 V1 Y x HxV1Y). }
      apply binintersectI.
      + apply binintersectI.
        * exact HxV1.
        * exact HxV2.
      + exact HxY.
    - let x. assume Hx: x :e (V1 :/\: V2) :/\: Y.
      claim HxV1V2: x :e V1 :/\: V2.
      { exact (binintersectE1 (V1 :/\: V2) Y x Hx). }
      claim HxY: x :e Y.
      { exact (binintersectE2 (V1 :/\: V2) Y x Hx). }
      claim HxV1: x :e V1.
      { exact (binintersectE1 V1 V2 x HxV1V2). }
      claim HxV2: x :e V2.
      { exact (binintersectE2 V1 V2 x HxV1V2). }
      apply binintersectI.
      + apply binintersectI.
        * exact HxV1.
        * exact HxY.
      + apply binintersectI.
        * exact HxV2.
        * exact HxY.
  }
  claim HPredInt: exists W :e Tx, U :/\: V = W :/\: Y.
  { witness (V1 :/\: V2).
    apply andI.
    - exact HV1V2.
    - exact HIntEq.
  }
  claim HIntInPowerY: U :/\: V :e Power Y.
  { apply PowerI.
    let x. assume Hx: x :e U :/\: V.
    claim HxU: x :e U.
    { exact (binintersectE1 U V x Hx). }
    claim HUinPowerY: U :e Power Y.
    { exact (SepE1 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HU). }
    claim HUsub: U c= Y.
    { exact (PowerE Y U HUinPowerY). }
    exact (HUsub x HxU).
  }
  exact (SepI (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) (U :/\: V) HIntInPowerY HPredInt).
Qed.

(** from 16: openness in subspace via ambient openness **) 
(** LATEX VERSION: A set UY is open in the subspace topology iff U = VY for some V open in X. **)
Theorem open_in_subspace_iff : forall X Tx Y U:set,
  topology_on X Tx -> Y c= X -> U c= Y ->
  (open_in Y (subspace_topology X Tx Y) U <->
  exists V :e Tx, U = V :/\: Y).
let X Tx Y U.
assume HTx: topology_on X Tx.
assume HY: Y c= X.
assume HU: U c= Y.
prove open_in Y (subspace_topology X Tx Y) U <-> exists V :e Tx, U = V :/\: Y.
apply iffI.
- assume HopenU: open_in Y (subspace_topology X Tx Y) U.
  prove exists V :e Tx, U = V :/\: Y.
  claim HUinSubspace: U :e subspace_topology X Tx Y.
  { exact (andER (topology_on Y (subspace_topology X Tx Y)) (U :e subspace_topology X Tx Y) HopenU). }
  exact (SepE2 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HUinSubspace).
- assume Hexists: exists V :e Tx, U = V :/\: Y.
  prove open_in Y (subspace_topology X Tx Y) U.
  prove topology_on Y (subspace_topology X Tx Y) /\ U :e subspace_topology X Tx Y.
  apply andI.
  + prove topology_on Y (subspace_topology X Tx Y).
    exact (subspace_topology_is_topology X Tx Y HTx HY).
  + prove U :e subspace_topology X Tx Y.
    claim HUinPowerY: U :e Power Y.
    { apply PowerI. exact HU. }
    exact (SepI (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HUinPowerY Hexists).
Qed.

(** from 16 Lemma 16.1: basis for the subspace topology **) 
(** LATEX VERSION: Lemma 16.1: If B is a basis for Tx, then {bY | bB} is a basis for the subspace topology on Y. **)
Theorem subspace_basis : forall X Tx Y B:set,
  topology_on X Tx ->
  Y c= X ->
  basis_on X B /\ generated_topology X B = Tx ->
  basis_on Y {b :/\: Y | b :e B} /\
  generated_topology Y {b :/\: Y | b :e B} = subspace_topology X Tx Y.
let X Tx Y B.
assume HTx: topology_on X Tx.
assume HYsub: Y c= X.
assume HB: basis_on X B /\ generated_topology X B = Tx.
prove basis_on Y {b :/\: Y | b :e B} /\ generated_topology Y {b :/\: Y | b :e B} = subspace_topology X Tx Y.
(** Use basis_refines_topology with C = {bY | bB} on the subspace topology. **)
claim HBasis: basis_on X B.
{ exact (andEL (basis_on X B) (generated_topology X B = Tx) HB). }
claim HgenEq: generated_topology X B = Tx.
{ exact (andER (basis_on X B) (generated_topology X B = Tx) HB). }
claim HtopSub: topology_on Y (subspace_topology X Tx Y).
{ exact (subspace_topology_is_topology X Tx Y HTx HYsub). }
claim HCsub: forall c :e {b :/\: Y | b :e B}, c :e subspace_topology X Tx Y.
{ let c. assume HcC.
  claim Hexb: exists b :e B, c = b :/\: Y.
  { exact (ReplE B (fun b0:set => b0 :/\: Y) c HcC). }
  apply Hexb.
  let b. assume Hbpair.
  claim HbB: b :e B.
  { exact (andEL (b :e B) (c = b :/\: Y) Hbpair). }
  claim Hceq: c = b :/\: Y.
  { exact (andER (b :e B) (c = b :/\: Y) Hbpair). }
  claim HbGen: b :e generated_topology X B.
  { exact (generated_topology_contains_basis X B HBasis b HbB). }
  claim HbTx: b :e Tx.
  { prove b :e Tx.
    rewrite <- HgenEq.
    exact HbGen. }
  claim HcPowY: c :e Power Y.
  { apply PowerI Y c.
    let y. assume Hyc: y :e c.
    claim HycBY: y :e b :/\: Y.
    { prove y :e b :/\: Y.
      rewrite <- Hceq.
      exact Hyc. }
    exact (binintersectE2 b Y y HycBY). }
  claim HcProp: exists V :e Tx, c = V :/\: Y.
  { witness b.
    apply andI.
    - exact HbTx.
    - exact Hceq. }
  exact (SepI (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) c HcPowY HcProp). }
claim Href: forall U :e subspace_topology X Tx Y, forall x :e U,
  exists Cx :e {b :/\: Y | b :e B}, x :e Cx /\ Cx c= U.
{ let U. assume HU: U :e subspace_topology X Tx Y.
  let x. assume HxU: x :e U.
  claim HUprop: exists V :e Tx, U = V :/\: Y.
  { exact (SepE2 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HU). }
  apply HUprop.
  let V. assume HVpair.
  claim HVTx: V :e Tx.
  { exact (andEL (V :e Tx) (U = V :/\: Y) HVpair). }
  claim HUeq: U = V :/\: Y.
  { exact (andER (V :e Tx) (U = V :/\: Y) HVpair). }
  claim HxVY: x :e V :/\: Y.
  { rewrite <- HUeq. exact HxU. }
  claim HxV: x :e V.
  { exact (binintersectE1 V Y x HxVY). }
  claim HxY: x :e Y.
  { exact (binintersectE2 V Y x HxVY). }
  claim HVGen: V :e generated_topology X B.
  { prove V :e generated_topology X B.
    rewrite HgenEq.
    exact HVTx. }
  claim HVref: forall z :e V, exists b :e B, z :e b /\ b c= V.
  { exact (SepE2 (Power X)
                 (fun U0 : set => forall z0 :e U0, exists b0 :e B, z0 :e b0 /\ b0 c= U0)
                 V
                 HVGen). }
  claim Hexb: exists b :e B, x :e b /\ b c= V.
  { exact (HVref x HxV). }
  apply Hexb.
  let b. assume Hbpair2.
  claim HbB: b :e B.
  { exact (andEL (b :e B) (x :e b /\ b c= V) Hbpair2). }
  claim Hbprop: x :e b /\ b c= V.
  { exact (andER (b :e B) (x :e b /\ b c= V) Hbpair2). }
  claim Hxb: x :e b.
  { exact (andEL (x :e b) (b c= V) Hbprop). }
  claim HbsubV: b c= V.
  { exact (andER (x :e b) (b c= V) Hbprop). }
  set Cx := b :/\: Y.
  witness Cx.
  apply andI.
  - prove Cx :e {b0 :/\: Y | b0 :e B}.
    exact (ReplI B (fun b0:set => b0 :/\: Y) b HbB).
  - apply andI.
    + prove x :e Cx.
      exact (binintersectI b Y x Hxb HxY).
    + prove Cx c= U.
      let y. assume HyCx: y :e Cx.
      claim Hyb: y :e b.
      { exact (binintersectE1 b Y y HyCx). }
      claim HyY: y :e Y.
      { exact (binintersectE2 b Y y HyCx). }
      claim HyV: y :e V.
      { exact (HbsubV y Hyb). }
      claim HyVY: y :e V :/\: Y.
      { exact (binintersectI V Y y HyV HyY). }
      rewrite HUeq.
      exact HyVY. }
exact (basis_refines_topology Y (subspace_topology X Tx Y) {b :/\: Y | b :e B} HtopSub HCsub Href).
Qed.

(** from 16 Lemma 16.2: openness inherited when subspace is open **) 
(** LATEX VERSION: Lemma 16.2: If Y itself is open in X, any set open in the subspace Y is open in X. **)
Theorem open_in_subspace_if_ambient_open : forall X Tx Y U:set,
  topology_on X Tx -> Y :e Tx -> U c= Y ->
  open_in Y (subspace_topology X Tx Y) U ->
  U :e Tx.
let X Tx Y U.
assume HTx: topology_on X Tx.
assume HY: Y :e Tx.
assume HU: U c= Y.
assume HUopen: open_in Y (subspace_topology X Tx Y) U.
prove U :e Tx.
claim HYsub: Y c= X.
{ exact (topology_elem_subset X Tx Y HTx HY). }
claim HUiffExists: open_in Y (subspace_topology X Tx Y) U <-> exists V :e Tx, U = V :/\: Y.
{ exact (open_in_subspace_iff X Tx Y U HTx HYsub HU). }
claim Hexists: exists V :e Tx, U = V :/\: Y.
{ exact (iffEL (open_in Y (subspace_topology X Tx Y) U) (exists V :e Tx, U = V :/\: Y) HUiffExists HUopen). }
apply Hexists.
let V. assume HVandEq. apply HVandEq.
assume HV: V :e Tx. assume HUeq: U = V :/\: Y.
claim HVY: V :/\: Y :e Tx.
{ exact (topology_binintersect_closed X Tx V Y HTx HV HY). }
claim HUinTx: U :e Tx.
{ rewrite HUeq. exact HVY. }
exact HUinTx.
Qed.

(** from 16 Theorem 16.3: product of subspaces equals subspace of product **) 
(** LATEX VERSION: The product topology on AB (with subspace topologies) equals the subspace topology of AB inside XY. **)
Theorem product_subspace_topology : forall X Tx Y Ty A B:set,
  topology_on X Tx -> topology_on Y Ty ->
  A c= X -> B c= Y ->
  product_topology A (subspace_topology X Tx A) B (subspace_topology Y Ty B) =
  subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B).
let X Tx Y Ty A B.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
assume HA: A c= X.
assume HB: B c= Y.
prove product_topology A (subspace_topology X Tx A) B (subspace_topology Y Ty B) =
  subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B).
(** Use the rectangle family (UA)(VB) as a common basis for both topologies. **)
set Bx := {U :/\: A | U :e Tx}.
set By := {V :/\: B | V :e Ty}.
set C := product_basis_from Bx By.

(** First, show Tx generates itself, so Bx generates the subspace topology on A, and similarly for By. **)
claim HgenTx: basis_on X Tx /\ generated_topology X Tx = Tx.
{ prove basis_on X Tx /\ generated_topology X Tx = Tx.
  apply (basis_refines_topology X Tx Tx HTx).
  - let c. assume Hc: c :e Tx.
    exact Hc.
  - let U. assume HU: U :e Tx.
    let x. assume Hx: x :e U.
    prove exists Cx :e Tx, x :e Cx /\ Cx c= U.
    witness U.
    apply andI.
    + exact HU.
    + apply andI.
      * exact Hx.
      * exact (Subq_ref U). }
claim HgenTy: basis_on Y Ty /\ generated_topology Y Ty = Ty.
{ prove basis_on Y Ty /\ generated_topology Y Ty = Ty.
  apply (basis_refines_topology Y Ty Ty HTy).
  - let c. assume Hc: c :e Ty.
    exact Hc.
  - let U. assume HU: U :e Ty.
    let x. assume Hx: x :e U.
    prove exists Cx :e Ty, x :e Cx /\ Cx c= U.
    witness U.
    apply andI.
    + exact HU.
    + apply andI.
      * exact Hx.
      * exact (Subq_ref U). }

claim HBx: basis_on A Bx /\ generated_topology A Bx = subspace_topology X Tx A.
{ exact (subspace_basis X Tx A Tx HTx HA HgenTx). }
claim HBy: basis_on B By /\ generated_topology B By = subspace_topology Y Ty B.
{ exact (subspace_basis Y Ty B Ty HTy HB HgenTy). }

claim HBx_basis: basis_on A Bx.
{ exact (andEL (basis_on A Bx) (generated_topology A Bx = subspace_topology X Tx A) HBx). }
claim HBy_basis: basis_on B By.
{ exact (andEL (basis_on B By) (generated_topology B By = subspace_topology Y Ty B) HBy). }
claim HBx_eq: generated_topology A Bx = subspace_topology X Tx A.
{ exact (andER (basis_on A Bx) (generated_topology A Bx = subspace_topology X Tx A) HBx). }
claim HBy_eq: generated_topology B By = subspace_topology Y Ty B.
{ exact (andER (basis_on B By) (generated_topology B By = subspace_topology Y Ty B) HBy). }

(** Product of subspaces is generated by C. **)
claim Hprod_gen:
  generated_topology (setprod A B) C =
  product_topology A (subspace_topology X Tx A) B (subspace_topology Y Ty B).
{ exact (product_basis_generates_product_topology
          A B Bx By
          (subspace_topology X Tx A) (subspace_topology Y Ty B)
          HBx_basis HBx_eq
          HBy_basis HBy_eq). }

(** Now show that the subspace topology of the product is also generated by C, using basis_refines_topology. **)
claim HABsub: setprod A B c= setprod X Y.
{ exact (setprod_Subq A B X Y HA HB). }
claim HtopProd: topology_on (setprod X Y) (product_topology X Tx Y Ty).
{ exact (product_topology_is_topology X Tx Y Ty HTx HTy). }
claim HtopSubProd: topology_on (setprod A B)
  (subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B)).
{ exact (subspace_topology_is_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B) HtopProd HABsub). }

claim HCsub: forall c :e C,
  c :e subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B).
{ let c. assume HcC.
  claim HexU: exists U :e Bx, c :e {setprod U V|V :e By}.
  { exact (famunionE Bx (fun U0:set => {setprod U0 V|V :e By}) c HcC). }
  apply HexU.
  let U. assume HUconj.
  claim HUbx: U :e Bx.
  { exact (andEL (U :e Bx) (c :e {setprod U V|V :e By}) HUconj). }
  claim HcRepl: c :e {setprod U V|V :e By}.
  { exact (andER (U :e Bx) (c :e {setprod U V|V :e By}) HUconj). }
  claim HexV: exists V :e By, c = setprod U V.
  { exact (ReplE By (fun V0:set => setprod U V0) c HcRepl). }
  apply HexV.
  let V. assume HVconj.
  claim HVby: V :e By.
  { exact (andEL (V :e By) (c = setprod U V) HVconj). }
  claim HcEqUV: c = setprod U V.
  { exact (andER (V :e By) (c = setprod U V) HVconj). }

  claim HexUx: exists U0 :e Tx, U = U0 :/\: A.
  { exact (ReplE Tx (fun U0:set => U0 :/\: A) U HUbx). }
  claim HexVy: exists V0 :e Ty, V = V0 :/\: B.
  { exact (ReplE Ty (fun V0:set => V0 :/\: B) V HVby). }
  apply HexUx.
  let U0. assume HU0conj.
  claim HU0Tx: U0 :e Tx.
  { exact (andEL (U0 :e Tx) (U = U0 :/\: A) HU0conj). }
  claim HUeq: U = U0 :/\: A.
  { exact (andER (U0 :e Tx) (U = U0 :/\: A) HU0conj). }
  apply HexVy.
  let V0. assume HV0conj.
  claim HV0Ty: V0 :e Ty.
  { exact (andEL (V0 :e Ty) (V = V0 :/\: B) HV0conj). }
  claim HVeq: V = V0 :/\: B.
  { exact (andER (V0 :e Ty) (V = V0 :/\: B) HV0conj). }

  set W := setprod U0 V0.
  claim HWsub: W :e product_subbasis X Tx Y Ty.
  { prove W :e product_subbasis X Tx Y Ty.
    claim HWV: rectangle_set U0 V0 :e {rectangle_set U0 V|V :e Ty}.
    { exact (ReplI Ty (fun V1:set => rectangle_set U0 V1) V0 HV0Ty). }
    exact (famunionI Tx (fun U1:set => {rectangle_set U1 V|V :e Ty}) U0 (rectangle_set U0 V0) HU0Tx HWV). }
  claim HBsubbasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
  { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
  claim HWopen: W :e product_topology X Tx Y Ty.
  { exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty)
            HBsubbasis W HWsub). }

  claim HcPow: c :e Power (setprod A B).
  { apply PowerI (setprod A B) c.
    let p. assume Hp: p :e c.
    prove p :e setprod A B.
    claim HpUV: p :e setprod U V.
    { prove p :e setprod U V.
      rewrite <- HcEqUV.
      exact Hp. }
    claim HsubU: U c= A.
    { prove U c= A.
      rewrite HUeq.
      exact (binintersect_Subq_2 U0 A). }
    claim HsubV: V c= B.
    { prove V c= B.
      rewrite HVeq.
      exact (binintersect_Subq_2 V0 B). }
    claim HsubUV: setprod U V c= setprod A B.
    { exact (setprod_Subq U V A B HsubU HsubV). }
    exact (HsubUV p HpUV). }
  claim HcEqSub: c = W :/\: setprod A B.
  { prove c = W :/\: setprod A B.
    rewrite HcEqUV.
    rewrite HUeq.
    rewrite HVeq.
    rewrite <- (setprod_intersection U0 V0 A B).
    reflexivity. }
  claim HexW: exists V1 :e product_topology X Tx Y Ty, c = V1 :/\: setprod A B.
  { witness W.
    apply andI.
    - exact HWopen.
    - exact HcEqSub. }
  exact (SepI (Power (setprod A B))
              (fun U1:set => exists V1 :e product_topology X Tx Y Ty, U1 = V1 :/\: setprod A B)
              c
              HcPow
              HexW). }

claim Href: forall U1 :e subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B),
  forall p :e U1,
  exists Cx :e C, p :e Cx /\ Cx c= U1.
{ let U1. assume HU1: U1 :e subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B).
  let p. assume HpU1: p :e U1.
  claim HU1sub: U1 c= setprod A B.
  { exact (PowerE (setprod A B) U1 (SepE1 (Power (setprod A B))
                (fun U0:set => exists V0 :e product_topology X Tx Y Ty, U0 = V0 :/\: setprod A B)
                U1 HU1)). }
  claim HpAB: p :e setprod A B.
  { exact (HU1sub p HpU1). }
  claim HU1prop: exists W :e product_topology X Tx Y Ty, U1 = W :/\: setprod A B.
  { exact (SepE2 (Power (setprod A B))
                 (fun U0:set => exists V0 :e product_topology X Tx Y Ty, U0 = V0 :/\: setprod A B)
                 U1 HU1). }
  apply HU1prop.
  let W. assume HWconj.
  claim HWopen: W :e product_topology X Tx Y Ty.
  { exact (andEL (W :e product_topology X Tx Y Ty) (U1 = W :/\: setprod A B) HWconj). }
  claim HU1eq: U1 = W :/\: setprod A B.
  { exact (andER (W :e product_topology X Tx Y Ty) (U1 = W :/\: setprod A B) HWconj). }
  claim HpWAB: p :e W :/\: setprod A B.
  { rewrite <- HU1eq. exact HpU1. }
  claim HpW: p :e W.
  { exact (binintersectE1 W (setprod A B) p HpWAB). }

  claim HWgen: W :e generated_topology (setprod X Y) (product_subbasis X Tx Y Ty).
  { exact HWopen. }
  claim HWref: forall z :e W, exists b :e product_subbasis X Tx Y Ty, z :e b /\ b c= W.
  { exact (SepE2 (Power (setprod X Y))
                 (fun U0 : set => forall z0 :e U0, exists b0 :e product_subbasis X Tx Y Ty, z0 :e b0 /\ b0 c= U0)
                 W
                 HWgen). }
  claim Hexb: exists b :e product_subbasis X Tx Y Ty, p :e b /\ b c= W.
  { exact (HWref p HpW). }
  apply Hexb.
  let b. assume Hbconj.
  claim HbSub: b :e product_subbasis X Tx Y Ty.
  { exact (andEL (b :e product_subbasis X Tx Y Ty) (p :e b /\ b c= W) Hbconj). }
  claim Hbprop: p :e b /\ b c= W.
  { exact (andER (b :e product_subbasis X Tx Y Ty) (p :e b /\ b c= W) Hbconj). }
  claim Hpb: p :e b.
  { exact (andEL (p :e b) (b c= W) Hbprop). }
  claim HbsubW: b c= W.
  { exact (andER (p :e b) (b c= W) Hbprop). }

  claim HexU: exists U0 :e Tx, b :e {rectangle_set U0 V|V :e Ty}.
  { exact (famunionE Tx (fun U0:set => {rectangle_set U0 V|V :e Ty}) b HbSub). }
  apply HexU.
  let U0. assume HU0conj.
  claim HU0Tx: U0 :e Tx.
  { exact (andEL (U0 :e Tx) (b :e {rectangle_set U0 V|V :e Ty}) HU0conj). }
  claim HbRepl: b :e {rectangle_set U0 V|V :e Ty}.
  { exact (andER (U0 :e Tx) (b :e {rectangle_set U0 V|V :e Ty}) HU0conj). }
  claim HexV: exists V0 :e Ty, b = rectangle_set U0 V0.
  { exact (ReplE Ty (fun V0:set => rectangle_set U0 V0) b HbRepl). }
  apply HexV.
  let V0. assume HV0conj.
  claim HV0Ty: V0 :e Ty.
  { exact (andEL (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }
  claim Hbeq: b = rectangle_set U0 V0.
  { exact (andER (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }

  set Cx := setprod (U0 :/\: A) (V0 :/\: B).
  witness Cx.
  apply andI.
  - prove Cx :e C.
    claim HU0Bx: U0 :/\: A :e Bx.
    { exact (ReplI Tx (fun U1:set => U1 :/\: A) U0 HU0Tx). }
    claim HV0By: V0 :/\: B :e By.
    { exact (ReplI Ty (fun V1:set => V1 :/\: B) V0 HV0Ty). }
    claim HcxRepl: setprod (U0 :/\: A) (V0 :/\: B) :e {setprod (U0 :/\: A) V|V :e By}.
    { exact (ReplI By (fun V1:set => setprod (U0 :/\: A) V1) (V0 :/\: B) HV0By). }
    exact (famunionI Bx (fun U1:set => {setprod U1 V|V :e By}) (U0 :/\: A)
            (setprod (U0 :/\: A) (V0 :/\: B)) HU0Bx HcxRepl).
  - apply andI.
    + prove p :e Cx.
      claim HpInInter: p :e (rectangle_set U0 V0) :/\: setprod A B.
      { prove p :e (rectangle_set U0 V0) :/\: setprod A B.
        apply binintersectI.
        - prove p :e rectangle_set U0 V0.
          rewrite <- Hbeq.
          exact Hpb.
        - exact HpAB. }
      rewrite <- (setprod_intersection U0 V0 A B).
      exact HpInInter.
    + prove Cx c= U1.
      claim HCx_sub_b: Cx c= rectangle_set U0 V0.
      { exact (setprod_Subq (U0 :/\: A) (V0 :/\: B) U0 V0 (binintersect_Subq_1 U0 A) (binintersect_Subq_1 V0 B)). }
      claim HCx_sub_W: Cx c= W.
      { claim HrectSubb: rectangle_set U0 V0 c= b.
        { prove rectangle_set U0 V0 c= b.
          rewrite <- Hbeq.
          exact (Subq_ref b). }
        exact (Subq_tra Cx (rectangle_set U0 V0) W HCx_sub_b
                 (Subq_tra (rectangle_set U0 V0) b W HrectSubb HbsubW)). }
      claim HCx_sub_AB: Cx c= setprod A B.
      { exact (setprod_Subq (U0 :/\: A) (V0 :/\: B) A B (binintersect_Subq_2 U0 A) (binintersect_Subq_2 V0 B)). }
      claim HCx_sub_WAB: Cx c= W :/\: setprod A B.
      { exact (binintersect_Subq_max W (setprod A B) Cx HCx_sub_W HCx_sub_AB). }
      rewrite HU1eq.
      exact HCx_sub_WAB. }

claim HsubEq:
  generated_topology (setprod A B) C =
  subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B).
{ exact (andER (basis_on (setprod A B) C)
               (generated_topology (setprod A B) C = subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B))
               (basis_refines_topology (setprod A B)
                 (subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod A B))
                 C
                 HtopSubProd
                 HCsub
                 Href)). }

(** Conclude by identifying both sides with generated_topology (setprod A B) C. **)
rewrite <- Hprod_gen.
rewrite HsubEq.
reflexivity.
Qed.

(** from 16 Example 3: ordered square versus subspace topology **) 
(** LATEX VERSION: Example 3: The order topology on the ordered square differs from the subspace topology inherited from the dictionary order on . **)
(** FIXED: Unit interval [0,1] = {x  R | 0  x  1}.
    Using negated strict inequality: x  0 means ~(x < 0), x  1 means ~(1 < x). **)
Definition unit_interval : set := {x :e R | ~(Rlt x 0) /\ ~(Rlt 1 x)}.
Definition ordered_square : set := setprod unit_interval unit_interval.
Definition ordered_square_topology : set := order_topology ordered_square.
(** LATEX VERSION: The vertical strip {1/2}(1/2,1] inside II. **)
Definition ordered_square_open_strip : set :=
  {p :e ordered_square|exists y:set, p = (eps_ 1,y) /\ Rlt (eps_ 1) y /\ ~(Rlt 1 y)}.
Definition ordered_square_subspace_topology : set :=
  subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square.

Axiom ordered_square_not_subspace_dictionary_axiom :
  ordered_square_topology <> subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square.

Theorem ordered_square_not_subspace_dictionary :
  ordered_square_topology <> subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square.
prove ordered_square_topology <> subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square.
exact ordered_square_not_subspace_dictionary_axiom.
Qed.

(** from 16 Theorem 16.4: convex subspaces share the order topology **) 
(** LATEX VERSION: Theorem 16.4: A convex subset Y of an ordered set X inherits the order topology as a subspace topology. **)
(** Helper: order interval (a,b) in an ordered set **)
Definition order_interval : set -> set -> set -> set := fun X a b =>
  {x :e X | order_rel X a x /\ order_rel X x b}.

(** Helper: convex subset definition used in Theorem 16.4 **)
Definition convex_in : set -> set -> prop := fun X Y =>
  Y c= X /\
  forall a b:set, a :e Y -> b :e Y -> order_interval X a b c= Y.

Axiom convex_subspace_order_topology_axiom : forall X Y:set,
  convex_in X Y ->
  order_topology Y = subspace_topology X (order_topology X) Y.

Theorem convex_subspace_order_topology : forall X Y:set,
  convex_in X Y ->
  order_topology Y = subspace_topology X (order_topology X) Y.
let X Y.
assume Hconv: convex_in X Y.
prove order_topology Y = subspace_topology X (order_topology X) Y.
exact (convex_subspace_order_topology_axiom X Y Hconv).
Qed.

(** helper: intersection with a subset can drop the larger set **) 
Theorem binintersect_right_absorb_subset : forall W Y A:set,
  A c= Y -> (W :/\: Y) :/\: A = W :/\: A.
let W Y A.
assume Hsub: A c= Y.
apply set_ext.
- let x. assume Hx: x :e (W :/\: Y) :/\: A.
  claim Hpair : x :e W :/\: Y /\ x :e A.
  { exact (binintersectE (W :/\: Y) A x Hx). }
  claim HWY : x :e W :/\: Y.
  { exact (andEL (x :e W :/\: Y) (x :e A) Hpair). }
  claim HA : x :e A.
  { exact (andER (x :e W :/\: Y) (x :e A) Hpair). }
  claim HWYpair : x :e W /\ x :e Y.
  { exact (binintersectE W Y x HWY). }
  claim HW : x :e W.
  { exact (andEL (x :e W) (x :e Y) HWYpair). }
  apply binintersectI.
  * exact HW.
  * exact HA.
- let x. assume Hx: x :e W :/\: A.
  claim Hpair : x :e W /\ x :e A.
  { exact (binintersectE W A x Hx). }
  claim HW : x :e W.
  { exact (andEL (x :e W) (x :e A) Hpair). }
  claim HA : x :e A.
  { exact (andER (x :e W) (x :e A) Hpair). }
  claim HY : x :e Y.
  { exact (Hsub x HA). }
  claim HWY : x :e W :/\: Y.
  { exact (binintersectI W Y x HW HY). }
  apply binintersectI.
  * exact HWY.
  * exact HA.
Qed.

(** from 16 Exercise 1: subspace of subspace inherits same topology **)
(** LATEX VERSION: Exercise 1: Subspace of a subspace has the same topology as taking the subspace directly. **)
Theorem ex16_1_subspace_transitive : forall X Tx Y A:set,
  topology_on X Tx -> Y c= X -> A c= Y ->
  subspace_topology Y (subspace_topology X Tx Y) A =
  subspace_topology X Tx A.
let X Tx Y A.
assume Htop: topology_on X Tx.
assume HY: Y c= X.
assume HA: A c= Y.
prove subspace_topology Y (subspace_topology X Tx Y) A = subspace_topology X Tx A.
(** Strategy: Prove both sides equal {W  Power A | VTx, W = VA} using binintersect_right_absorb_subset: (VY)A = VA when AY **)
apply set_ext.
- let W.
  assume HW: W :e subspace_topology Y (subspace_topology X Tx Y) A.
  prove W :e subspace_topology X Tx A.
  (** W  subspace_topology Y (subspace_topology X Tx Y) A means:
      W  Power A  U(subspace_topology X Tx Y), W = U  A **)
  claim HWPowerA: W :e Power A.
  { exact (SepE1 (Power A) (fun U0:set => exists U :e subspace_topology X Tx Y, U0 = U :/\: A) W HW). }
  claim HWexists: exists U :e subspace_topology X Tx Y, W = U :/\: A.
  { exact (SepE2 (Power A) (fun U0:set => exists U :e subspace_topology X Tx Y, U0 = U :/\: A) W HW). }
  apply HWexists.
  let U.
  assume HU: U :e subspace_topology X Tx Y /\ W = U :/\: A.
  claim HUinSubY: U :e subspace_topology X Tx Y.
  { exact (andEL (U :e subspace_topology X Tx Y) (W = U :/\: A) HU). }
  claim HWeqUA: W = U :/\: A.
  { exact (andER (U :e subspace_topology X Tx Y) (W = U :/\: A) HU). }
  (** U  subspace_topology X Tx Y means U  Power Y  VTx, U = V  Y **)
  claim HUPowerY: U :e Power Y.
  { exact (SepE1 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HUinSubY). }
  claim HUexists: exists V :e Tx, U = V :/\: Y.
  { exact (SepE2 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HUinSubY). }
  apply HUexists.
  let V.
  assume HV: V :e Tx /\ U = V :/\: Y.
  claim HVinTx: V :e Tx.
  { exact (andEL (V :e Tx) (U = V :/\: Y) HV). }
  claim HUeqVY: U = V :/\: Y.
  { exact (andER (V :e Tx) (U = V :/\: Y) HV). }
  (** Now W = U  A = (V  Y)  A = V  A by binintersect_right_absorb_subset **)
  claim HWeqVA: W = V :/\: A.
  { rewrite HWeqUA.
    rewrite HUeqVY.
    exact (binintersect_right_absorb_subset V Y A HA). }
  (** So W  {W  Power A | VTx, W = VA} = subspace_topology X Tx A **)
  claim HWPred: exists V0 :e Tx, W = V0 :/\: A.
  { witness V.
    apply andI.
    - exact HVinTx.
    - exact HWeqVA. }
  exact (SepI (Power A) (fun W0:set => exists V0 :e Tx, W0 = V0 :/\: A) W HWPowerA HWPred).
- let W.
  assume HW: W :e subspace_topology X Tx A.
  prove W :e subspace_topology Y (subspace_topology X Tx Y) A.
  (** W  subspace_topology X Tx A means W  Power A  VTx, W = V  A **)
  claim HWPowerA: W :e Power A.
  { exact (SepE1 (Power A) (fun W0:set => exists V :e Tx, W0 = V :/\: A) W HW). }
  claim HWexists: exists V :e Tx, W = V :/\: A.
  { exact (SepE2 (Power A) (fun W0:set => exists V :e Tx, W0 = V :/\: A) W HW). }
  apply HWexists.
  let V.
  assume HV: V :e Tx /\ W = V :/\: A.
  claim HVinTx: V :e Tx.
  { exact (andEL (V :e Tx) (W = V :/\: A) HV). }
  claim HWeqVA: W = V :/\: A.
  { exact (andER (V :e Tx) (W = V :/\: A) HV). }
  (** Set U = V  Y. Then U  subspace_topology X Tx Y, and W = U  A **)
  set U := V :/\: Y.
  claim HUinSubY: U :e subspace_topology X Tx Y.
  { claim HUPowerY: U :e Power Y.
    { exact (PowerI Y U (binintersect_Subq_2 V Y)). }
    claim HUPred: exists V0 :e Tx, U = V0 :/\: Y.
    { witness V.
      apply andI.
      - exact HVinTx.
      - reflexivity. }
    exact (SepI (Power Y) (fun U0:set => exists V0 :e Tx, U0 = V0 :/\: Y) U HUPowerY HUPred). }
  claim HWeqUA: W = U :/\: A.
  { rewrite HWeqVA.
    symmetry.
    exact (binintersect_right_absorb_subset V Y A HA). }
  (** So W  {W  Power A | U(subspace_topology X Tx Y), W = UA} **)
  claim HWPred: exists U0 :e subspace_topology X Tx Y, W = U0 :/\: A.
  { witness U.
    apply andI.
    - exact HUinSubY.
    - exact HWeqUA. }
  exact (SepI (Power A) (fun W0:set => exists U0 :e subspace_topology X Tx Y, W0 = U0 :/\: A) W HWPowerA HWPred).
Qed.

(** from 16 Exercise 2: fineness relation passes to subspaces **)
(** LATEX VERSION: Exercise 2: If T'T on X, then the induced subspace topology from T' on Y is contained in that from T. **)
Theorem ex16_2_finer_subspaces : forall X T T' Y:set,
  topology_on X T -> topology_on X T' -> T' c= T -> Y c= X ->
  subspace_topology X T' Y c= subspace_topology X T Y.
let X T T' Y.
assume Htop: topology_on X T.
assume Htop': topology_on X T'.
assume Hfiner: T' c= T.
assume HY: Y c= X.
prove subspace_topology X T' Y c= subspace_topology X T Y.
(** Strategy: If W  subspace_topology X T' Y, then W = V'  Y for some V'  T'.
    Since T'  T, we have V'  T, so W  subspace_topology X T Y. **)
let W.
assume HW: W :e subspace_topology X T' Y.
prove W :e subspace_topology X T Y.
(** W  subspace_topology X T' Y means W  Power Y  V'T', W = V'  Y **)
claim HWPowerY: W :e Power Y.
{ exact (SepE1 (Power Y) (fun W0:set => exists V :e T', W0 = V :/\: Y) W HW). }
claim HWexists: exists V :e T', W = V :/\: Y.
{ exact (SepE2 (Power Y) (fun W0:set => exists V :e T', W0 = V :/\: Y) W HW). }
apply HWexists.
let V'.
assume HV': V' :e T' /\ W = V' :/\: Y.
claim HV'inT': V' :e T'.
{ exact (andEL (V' :e T') (W = V' :/\: Y) HV'). }
claim HWeqV'Y: W = V' :/\: Y.
{ exact (andER (V' :e T') (W = V' :/\: Y) HV'). }
(** Since T'  T, we have V'  T **)
claim HV'inT: V' :e T.
{ exact (Hfiner V' HV'inT'). }
(** So W = V'  Y with V'  T, meaning W  subspace_topology X T Y **)
claim HWPred: exists V :e T, W = V :/\: Y.
{ witness V'.
  apply andI.
  - exact HV'inT.
  - exact HWeqV'Y. }
exact (SepI (Power Y) (fun W0:set => exists V :e T, W0 = V :/\: Y) W HWPowerY HWPred).
Qed.

(** from 16 Exercise 3: openness of specific sets in subspace [-1,1] **)
(** LATEX VERSION: Exercise 3: Determine openness in subspace [-1,1]; formalized as existence of ambient open V with U=VY. **)
(** LATEX VERSION: A={x|1/2<|x|<1}, B={x|1/2<|x|<=1}, C={x|1/2<=|x|<1}, D={x|1/2<=|x|<=1},
    E={x|0<|x|<1 and 1/x not in Zplus}. **)
Definition one_half : set := inv_nat 2.
Definition interval_A : set := {x :e R | one_half < abs_SNo x /\ abs_SNo x < 1}.
Definition interval_B : set := {x :e R | one_half < abs_SNo x /\ ~(1 < abs_SNo x)}.
Definition interval_C : set := {x :e R | ~(abs_SNo x < one_half) /\ abs_SNo x < 1}.
Definition interval_D : set := {x :e R | ~(abs_SNo x < one_half) /\ ~(1 < abs_SNo x)}.
Definition interval_E : set := {x :e R | 0 < abs_SNo x /\ abs_SNo x < 1 /\ ~ (div_SNo 1 x :e Zplus)}.

Theorem ex16_3_open_sets_subspace : forall X Tx Y:set,
  topology_on X Tx -> Y c= X ->
  forall U:set, open_in Y (subspace_topology X Tx Y) U -> exists V:set, open_in X Tx V /\ U = V :/\: Y.
let X Tx Y.
assume Htop: topology_on X Tx.
assume HY: Y c= X.
let U.
assume HU: open_in Y (subspace_topology X Tx Y) U.
prove exists V:set, open_in X Tx V /\ U = V :/\: Y.
(** open_in Y (subspace_topology X Tx Y) U means:
    topology_on Y (subspace_topology X Tx Y)  U  subspace_topology X Tx Y **)
claim HtopY: topology_on Y (subspace_topology X Tx Y).
{ exact (andEL (topology_on Y (subspace_topology X Tx Y)) (U :e subspace_topology X Tx Y) HU). }
claim HUinSub: U :e subspace_topology X Tx Y.
{ exact (andER (topology_on Y (subspace_topology X Tx Y)) (U :e subspace_topology X Tx Y) HU). }
(** U  subspace_topology X Tx Y means U  Power Y  VTx, U = V  Y **)
claim HUPowerY: U :e Power Y.
{ exact (SepE1 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HUinSub). }
claim HUexists: exists V :e Tx, U = V :/\: Y.
{ exact (SepE2 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HUinSub). }
apply HUexists.
let V.
assume HV: V :e Tx /\ U = V :/\: Y.
claim HVinTx: V :e Tx.
{ exact (andEL (V :e Tx) (U = V :/\: Y) HV). }
claim HUeqVY: U = V :/\: Y.
{ exact (andER (V :e Tx) (U = V :/\: Y) HV). }
(** Now open_in X Tx V means topology_on X Tx  V  Tx, both of which we have **)
claim HVopen: open_in X Tx V.
{ exact (andI (topology_on X Tx) (V :e Tx) Htop HVinTx). }
witness V.
apply andI.
- exact HVopen.
- exact HUeqVY.
Qed.

(** from 16 Exercise 4: projections are open maps **)
(** LATEX VERSION: Exercise 4: Projections from a product are open maps. **)
Definition projection_image1 : set -> set -> set -> set :=
  fun X Y U => {x :e X | exists y:set, (x,y) :e U}.
Definition projection_image2 : set -> set -> set -> set :=
  fun X Y U => {y :e Y | exists x:set, (x,y) :e U}.

(** helper: nonempty set has an element **)
Theorem nonempty_has_element : forall V:set, V <> Empty -> exists y:set, y :e V.
let V. assume Hne: V <> Empty.
apply (xm (exists y:set, y :e V)).
- assume Hex. exact Hex.
- assume Hno: ~(exists y:set, y :e V).
  claim HVsub: V c= Empty.
  { let y. assume Hy: y :e V.
    prove y :e Empty.
    apply FalseE.
    claim Hexy: exists z:set, z :e V.
    { witness y. exact Hy. }
    exact (Hno Hexy). }
  claim HVEmpty: V = Empty.
  { exact (Empty_Subq_eq V HVsub). }
  apply FalseE.
  exact (Hne HVEmpty).
Qed.

(** helper: set with an element is nonempty **)
Theorem elem_implies_nonempty : forall V y:set, y :e V -> V <> Empty.
let V y.
assume Hy: y :e V.
prove V <> Empty.
assume HV: V = Empty.
claim HyE: y :e Empty.
{ rewrite <- HV.
  exact Hy. }
exact (EmptyE y HyE).
Qed.

(** helper: projection of a rectangle to the first coordinate **)
Theorem projection_image1_rectangle_nonempty : forall X Y U V:set,
  U c= X ->
  V c= Y ->
  V <> Empty ->
  projection_image1 X Y (setprod U V) = U.
let X Y U V.
assume HUsub: U c= X.
assume HVsub: V c= Y.
assume HVne: V <> Empty.
set y0 := Eps_i (fun y:set => y :e V).
claim Hexy: exists y:set, y :e V.
{ exact (nonempty_has_element V HVne). }
claim Hy0: y0 :e V.
{ exact (Eps_i_ex (fun y:set => y :e V) Hexy). }
apply set_ext.
- let x. assume Hx: x :e projection_image1 X Y (setprod U V).
  prove x :e U.
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0:set => exists y:set, (x0,y) :e setprod U V) x Hx). }
  claim Hex: exists y:set, (x,y) :e setprod U V.
  { exact (SepE2 X (fun x0:set => exists y:set, (x0,y) :e setprod U V) x Hx). }
  apply Hex.
  let y. assume Hxy: (x,y) :e setprod U V.
  claim Hx0: ((x,y) 0) :e U.
  { exact (ap0_Sigma U (fun _:set => V) (x,y) Hxy). }
  rewrite <- (tuple_2_0_eq x y).
  exact Hx0.
- let x. assume HxU: x :e U.
  prove x :e projection_image1 X Y (setprod U V).
  claim HxX: x :e X.
  { exact (HUsub x HxU). }
  claim Hpred: exists y:set, (x,y) :e setprod U V.
  { witness y0.
    exact (lamI2 U (fun _:set => V) x HxU y0 Hy0). }
  exact (SepI X (fun x0:set => exists y:set, (x0,y) :e setprod U V) x HxX Hpred).
Qed.

Theorem projection_image1_rectangle_empty : forall X Y U:set,
  projection_image1 X Y (setprod U Empty) = Empty.
let X Y U.
apply set_ext.
- let x. assume Hx: x :e projection_image1 X Y (setprod U Empty).
  prove x :e Empty.
  claim Hex: exists y:set, (x,y) :e setprod U Empty.
  { exact (SepE2 X (fun x0:set => exists y:set, (x0,y) :e setprod U Empty) x Hx). }
  apply Hex.
  let y. assume Hxy: (x,y) :e setprod U Empty.
  claim HyEmpty: ((x,y) 1) :e Empty.
  { exact (ap1_Sigma U (fun _:set => Empty) (x,y) Hxy). }
  claim HyE: y :e Empty.
  { prove y :e Empty.
    rewrite <- (tuple_2_1_eq x y).
    exact HyEmpty. }
  apply FalseE.
  exact (EmptyE y HyE).
- let x. assume Hx: x :e Empty.
  apply (EmptyE x Hx).
Qed.

(** helper: projection of a rectangle to the second coordinate **)
Theorem projection_image2_rectangle_nonempty : forall X Y U V:set,
  U c= X ->
  V c= Y ->
  U <> Empty ->
  projection_image2 X Y (setprod U V) = V.
let X Y U V.
assume HUsub: U c= X.
assume HVsub: V c= Y.
assume HUne: U <> Empty.
set x0 := Eps_i (fun x:set => x :e U).
claim Hexx: exists x:set, x :e U.
{ exact (nonempty_has_element U HUne). }
claim Hx0: x0 :e U.
{ exact (Eps_i_ex (fun x:set => x :e U) Hexx). }
apply set_ext.
- let y. assume Hy: y :e projection_image2 X Y (setprod U V).
  prove y :e V.
  claim HyY: y :e Y.
  { exact (SepE1 Y (fun y0:set => exists x:set, (x,y0) :e setprod U V) y Hy). }
  claim Hex: exists x:set, (x,y) :e setprod U V.
  { exact (SepE2 Y (fun y0:set => exists x:set, (x,y0) :e setprod U V) y Hy). }
  apply Hex.
  let x. assume Hxy: (x,y) :e setprod U V.
  claim Hy1: ((x,y) 1) :e V.
  { exact (ap1_Sigma U (fun _:set => V) (x,y) Hxy). }
  rewrite <- (tuple_2_1_eq x y).
  exact Hy1.
- let y. assume HyV: y :e V.
  prove y :e projection_image2 X Y (setprod U V).
  claim HyY: y :e Y.
  { exact (HVsub y HyV). }
  claim Hpred: exists x:set, (x,y) :e setprod U V.
  { witness x0.
    exact (lamI2 U (fun _:set => V) x0 Hx0 y HyV). }
  exact (SepI Y (fun y0:set => exists x:set, (x,y0) :e setprod U V) y HyY Hpred).
Qed.

Theorem projection_image2_rectangle_empty : forall X Y V:set,
  projection_image2 X Y (setprod Empty V) = Empty.
let X Y V.
apply set_ext.
- let y. assume Hy: y :e projection_image2 X Y (setprod Empty V).
  prove y :e Empty.
  claim Hex: exists x:set, (x,y) :e setprod Empty V.
  { exact (SepE2 Y (fun y0:set => exists x:set, (x,y0) :e setprod Empty V) y Hy). }
  apply Hex.
  let x. assume Hxy: (x,y) :e setprod Empty V.
  claim HxEmpty: ((x,y) 0) :e Empty.
  { exact (ap0_Sigma Empty (fun _:set => V) (x,y) Hxy). }
  claim HxE: x :e Empty.
  { prove x :e Empty.
    rewrite <- (tuple_2_0_eq x y).
    exact HxEmpty. }
  apply FalseE.
  exact (EmptyE x HxE).
- let y. assume Hy: y :e Empty.
  apply (EmptyE y Hy).
Qed.

Theorem ex16_4_projections_open : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  forall U:set, U :e product_topology X Tx Y Ty ->
    open_in X Tx (projection_image1 X Y U) /\ open_in Y Ty (projection_image2 X Y U).
let X Tx Y Ty.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
let U.
assume HU: U :e product_topology X Tx Y Ty.
prove open_in X Tx (projection_image1 X Y U) /\ open_in Y Ty (projection_image2 X Y U).
apply andI.
- prove open_in X Tx (projection_image1 X Y U).
  prove topology_on X Tx /\ projection_image1 X Y U :e Tx.
  apply andI.
  + exact HTx.
  + (** represent U as a union of product subbasis elements **)
    claim HtopProd: topology_on (setprod X Y) (product_topology X Tx Y Ty).
    { exact (product_topology_is_topology X Tx Y Ty HTx HTy). }
    claim HUopen: open_in (setprod X Y) (product_topology X Tx Y Ty) U.
    { exact (andI (topology_on (setprod X Y) (product_topology X Tx Y Ty)) (U :e product_topology X Tx Y Ty) HtopProd HU). }
    claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
    { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
    claim HexFam: exists Fam :e Power (product_subbasis X Tx Y Ty), Union Fam = U.
    { exact (open_sets_as_unions_of_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis U HUopen). }
    apply HexFam.
    let Fam. assume HFampair.
    claim HFamPow: Fam :e Power (product_subbasis X Tx Y Ty).
    { exact (andEL (Fam :e Power (product_subbasis X Tx Y Ty)) (Union Fam = U) HFampair). }
    claim HUnionEq: Union Fam = U.
    { exact (andER (Fam :e Power (product_subbasis X Tx Y Ty)) (Union Fam = U) HFampair). }
    set P1Fam := {projection_image1 X Y b|b :e Fam}.
    claim HP1open: open_in X Tx (Union P1Fam).
    { apply (union_open X Tx P1Fam HTx).
      let W. assume HW: W :e P1Fam.
      prove open_in X Tx W.
      claim Hexb: exists b :e Fam, W = projection_image1 X Y b.
      { exact (ReplE Fam (fun b0:set => projection_image1 X Y b0) W HW). }
      apply Hexb.
      let b. assume Hbpair.
      claim HbFam: b :e Fam.
      { exact (andEL (b :e Fam) (W = projection_image1 X Y b) Hbpair). }
      claim HWeq: W = projection_image1 X Y b.
      { exact (andER (b :e Fam) (W = projection_image1 X Y b) Hbpair). }
      claim HbSub: b :e product_subbasis X Tx Y Ty.
      { exact (PowerE (product_subbasis X Tx Y Ty) Fam HFamPow b HbFam). }
      claim HexU0: exists U0 :e Tx, b :e {rectangle_set U0 V|V :e Ty}.
      { exact (famunionE Tx (fun U0:set => {rectangle_set U0 V|V :e Ty}) b HbSub). }
      apply HexU0.
      let U0. assume HU0conj.
      claim HU0Tx: U0 :e Tx.
      { exact (andEL (U0 :e Tx) (b :e {rectangle_set U0 V|V :e Ty}) HU0conj). }
      claim HbRepl: b :e {rectangle_set U0 V|V :e Ty}.
      { exact (andER (U0 :e Tx) (b :e {rectangle_set U0 V|V :e Ty}) HU0conj). }
      claim HexV0: exists V0 :e Ty, b = rectangle_set U0 V0.
      { exact (ReplE Ty (fun V0:set => rectangle_set U0 V0) b HbRepl). }
      apply HexV0.
      let V0. assume HV0conj.
      claim HV0Ty: V0 :e Ty.
      { exact (andEL (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }
      claim Hbeq: b = rectangle_set U0 V0.
      { exact (andER (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }
      claim HU0subX: U0 c= X.
      { exact (topology_elem_subset X Tx U0 HTx HU0Tx). }
      claim HV0subY: V0 c= Y.
      { exact (topology_elem_subset Y Ty V0 HTy HV0Ty). }
      apply (xm (V0 = Empty)).
      - assume HV0E: V0 = Empty.
        claim HWEmpty: W = Empty.
        { prove W = Empty.
          rewrite HWeq.
          rewrite Hbeq.
          rewrite HV0E.
          exact (projection_image1_rectangle_empty X Y U0). }
        rewrite HWEmpty.
        exact (andI (topology_on X Tx) (Empty :e Tx) HTx (topology_has_empty X Tx HTx)).
      - assume HV0NE: ~(V0 = Empty).
        claim HV0ne: V0 <> Empty.
        { exact HV0NE. }
        claim HWU0: W = U0.
        { prove W = U0.
          rewrite HWeq.
          rewrite Hbeq.
          exact (projection_image1_rectangle_nonempty X Y U0 V0 HU0subX HV0subY HV0ne). }
        rewrite HWU0.
        exact (andI (topology_on X Tx) (U0 :e Tx) HTx HU0Tx). }
    claim HP1inTx: Union P1Fam :e Tx.
    { exact (andER (topology_on X Tx) (Union P1Fam :e Tx) HP1open). }
    claim HUnionP1: Union P1Fam = projection_image1 X Y (Union Fam).
    { apply set_ext.
      - let x. assume Hx: x :e Union P1Fam.
        claim HexW: exists W:set, x :e W /\ W :e P1Fam.
        { exact (UnionE P1Fam x Hx). }
        apply HexW.
        let W. assume HWconj.
        claim HxW: x :e W.
        { exact (andEL (x :e W) (W :e P1Fam) HWconj). }
        claim HWPF: W :e P1Fam.
        { exact (andER (x :e W) (W :e P1Fam) HWconj). }
        claim Hexb: exists b :e Fam, W = projection_image1 X Y b.
        { exact (ReplE Fam (fun b0:set => projection_image1 X Y b0) W HWPF). }
        apply Hexb.
        let b. assume Hbpair.
        claim HbFam: b :e Fam.
        { exact (andEL (b :e Fam) (W = projection_image1 X Y b) Hbpair). }
        claim HWeq: W = projection_image1 X Y b.
        { exact (andER (b :e Fam) (W = projection_image1 X Y b) Hbpair). }
        claim HxP1b: x :e projection_image1 X Y b.
        { rewrite <- HWeq. exact HxW. }
        claim HxX: x :e X.
        { exact (SepE1 X (fun x0:set => exists y:set, (x0,y) :e b) x HxP1b). }
        claim Hexy: exists y:set, (x,y) :e b.
        { exact (SepE2 X (fun x0:set => exists y:set, (x0,y) :e b) x HxP1b). }
        claim Hpred: exists y:set, (x,y) :e Union Fam.
        { apply Hexy.
          let y. assume Hxy: (x,y) :e b.
          claim HbInUnion: (x,y) :e Union Fam.
          { exact (UnionI Fam (x,y) b Hxy HbFam). }
          witness y.
          exact HbInUnion. }
        exact (SepI X (fun x0:set => exists y:set, (x0,y) :e Union Fam) x HxX Hpred).
      - let x. assume Hx: x :e projection_image1 X Y (Union Fam).
        prove x :e Union P1Fam.
        claim HxX: x :e X.
        { exact (SepE1 X (fun x0:set => exists y:set, (x0,y) :e Union Fam) x Hx). }
        claim Hexy: exists y:set, (x,y) :e Union Fam.
        { exact (SepE2 X (fun x0:set => exists y:set, (x0,y) :e Union Fam) x Hx). }
        apply Hexy.
        let y. assume HxyUnion: (x,y) :e Union Fam.
        apply UnionE_impred Fam (x,y) HxyUnion.
        let b. assume Hxyb HbFam.
        claim HbPF: projection_image1 X Y b :e P1Fam.
        { exact (ReplI Fam (fun b0:set => projection_image1 X Y b0) b HbFam). }
        claim HxP1b: x :e projection_image1 X Y b.
        { claim Hpred: exists y0:set, (x,y0) :e b.
          { witness y.
            exact Hxyb. }
          exact (SepI X (fun x0:set => exists y0:set, (x0,y0) :e b) x HxX Hpred). }
        exact (UnionI P1Fam x (projection_image1 X Y b) HxP1b HbPF). }
    rewrite <- HUnionEq.
    rewrite <- HUnionP1.
    exact HP1inTx.
- prove open_in Y Ty (projection_image2 X Y U).
  prove topology_on Y Ty /\ projection_image2 X Y U :e Ty.
  apply andI.
  + exact HTy.
  + claim HtopProd: topology_on (setprod X Y) (product_topology X Tx Y Ty).
    { exact (product_topology_is_topology X Tx Y Ty HTx HTy). }
    claim HUopen: open_in (setprod X Y) (product_topology X Tx Y Ty) U.
    { exact (andI (topology_on (setprod X Y) (product_topology X Tx Y Ty)) (U :e product_topology X Tx Y Ty) HtopProd HU). }
    claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
    { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
    claim HexFam: exists Fam :e Power (product_subbasis X Tx Y Ty), Union Fam = U.
    { exact (open_sets_as_unions_of_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis U HUopen). }
    apply HexFam.
    let Fam. assume HFampair.
    claim HFamPow: Fam :e Power (product_subbasis X Tx Y Ty).
    { exact (andEL (Fam :e Power (product_subbasis X Tx Y Ty)) (Union Fam = U) HFampair). }
    claim HUnionEq: Union Fam = U.
    { exact (andER (Fam :e Power (product_subbasis X Tx Y Ty)) (Union Fam = U) HFampair). }
    set P2Fam := {projection_image2 X Y b|b :e Fam}.
    claim HP2open: open_in Y Ty (Union P2Fam).
    { apply (union_open Y Ty P2Fam HTy).
      let W. assume HW: W :e P2Fam.
      prove open_in Y Ty W.
      claim Hexb: exists b :e Fam, W = projection_image2 X Y b.
      { exact (ReplE Fam (fun b0:set => projection_image2 X Y b0) W HW). }
      apply Hexb.
      let b. assume Hbpair.
      claim HbFam: b :e Fam.
      { exact (andEL (b :e Fam) (W = projection_image2 X Y b) Hbpair). }
      claim HWeq: W = projection_image2 X Y b.
      { exact (andER (b :e Fam) (W = projection_image2 X Y b) Hbpair). }
      claim HbSub: b :e product_subbasis X Tx Y Ty.
      { exact (PowerE (product_subbasis X Tx Y Ty) Fam HFamPow b HbFam). }
      claim HexU0: exists U0 :e Tx, b :e {rectangle_set U0 V|V :e Ty}.
      { exact (famunionE Tx (fun U0:set => {rectangle_set U0 V|V :e Ty}) b HbSub). }
      apply HexU0.
      let U0. assume HU0conj.
      claim HU0Tx: U0 :e Tx.
      { exact (andEL (U0 :e Tx) (b :e {rectangle_set U0 V|V :e Ty}) HU0conj). }
      claim HbRepl: b :e {rectangle_set U0 V|V :e Ty}.
      { exact (andER (U0 :e Tx) (b :e {rectangle_set U0 V|V :e Ty}) HU0conj). }
      claim HexV0: exists V0 :e Ty, b = rectangle_set U0 V0.
      { exact (ReplE Ty (fun V0:set => rectangle_set U0 V0) b HbRepl). }
      apply HexV0.
      let V0. assume HV0conj.
      claim HV0Ty: V0 :e Ty.
      { exact (andEL (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }
      claim Hbeq: b = rectangle_set U0 V0.
      { exact (andER (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }
      claim HU0subX: U0 c= X.
      { exact (topology_elem_subset X Tx U0 HTx HU0Tx). }
      claim HV0subY: V0 c= Y.
      { exact (topology_elem_subset Y Ty V0 HTy HV0Ty). }
      apply (xm (U0 = Empty)).
      - assume HU0E: U0 = Empty.
        claim HWEmpty: W = Empty.
        { prove W = Empty.
          rewrite HWeq.
          rewrite Hbeq.
          rewrite HU0E.
          exact (projection_image2_rectangle_empty X Y V0). }
        rewrite HWEmpty.
        exact (andI (topology_on Y Ty) (Empty :e Ty) HTy (topology_has_empty Y Ty HTy)).
      - assume HU0NE: ~(U0 = Empty).
        claim HUne: U0 <> Empty.
        { exact HU0NE. }
        claim HWV0: W = V0.
        { prove W = V0.
          rewrite HWeq.
          rewrite Hbeq.
          exact (projection_image2_rectangle_nonempty X Y U0 V0 HU0subX HV0subY HUne). }
        rewrite HWV0.
        exact (andI (topology_on Y Ty) (V0 :e Ty) HTy HV0Ty). }
    claim HP2inTy: Union P2Fam :e Ty.
    { exact (andER (topology_on Y Ty) (Union P2Fam :e Ty) HP2open). }
    claim HUnionP2: Union P2Fam = projection_image2 X Y (Union Fam).
    { apply set_ext.
      - let y. assume Hy: y :e Union P2Fam.
        claim HexW: exists W:set, y :e W /\ W :e P2Fam.
        { exact (UnionE P2Fam y Hy). }
        apply HexW.
        let W. assume HWconj.
        claim HyW: y :e W.
        { exact (andEL (y :e W) (W :e P2Fam) HWconj). }
        claim HWPF: W :e P2Fam.
        { exact (andER (y :e W) (W :e P2Fam) HWconj). }
        claim Hexb: exists b :e Fam, W = projection_image2 X Y b.
        { exact (ReplE Fam (fun b0:set => projection_image2 X Y b0) W HWPF). }
        apply Hexb.
        let b. assume Hbpair.
        claim HbFam: b :e Fam.
        { exact (andEL (b :e Fam) (W = projection_image2 X Y b) Hbpair). }
        claim HWeq: W = projection_image2 X Y b.
        { exact (andER (b :e Fam) (W = projection_image2 X Y b) Hbpair). }
        claim HyP2b: y :e projection_image2 X Y b.
        { rewrite <- HWeq. exact HyW. }
        claim HyY: y :e Y.
        { exact (SepE1 Y (fun y0:set => exists x:set, (x,y0) :e b) y HyP2b). }
        claim Hexx: exists x:set, (x,y) :e b.
        { exact (SepE2 Y (fun y0:set => exists x:set, (x,y0) :e b) y HyP2b). }
        claim Hpred: exists x:set, (x,y) :e Union Fam.
        { apply Hexx.
          let x. assume Hxy: (x,y) :e b.
          claim HbInUnion: (x,y) :e Union Fam.
          { exact (UnionI Fam (x,y) b Hxy HbFam). }
          witness x.
          exact HbInUnion. }
        exact (SepI Y (fun y0:set => exists x:set, (x,y0) :e Union Fam) y HyY Hpred).
      - let y. assume Hy: y :e projection_image2 X Y (Union Fam).
        prove y :e Union P2Fam.
        claim HyY: y :e Y.
        { exact (SepE1 Y (fun y0:set => exists x:set, (x,y0) :e Union Fam) y Hy). }
        claim Hexx: exists x:set, (x,y) :e Union Fam.
        { exact (SepE2 Y (fun y0:set => exists x:set, (x,y0) :e Union Fam) y Hy). }
        apply Hexx.
        let x. assume HxyUnion: (x,y) :e Union Fam.
        apply UnionE_impred Fam (x,y) HxyUnion.
        let b. assume Hxyb HbFam.
        claim HbPF: projection_image2 X Y b :e P2Fam.
        { exact (ReplI Fam (fun b0:set => projection_image2 X Y b0) b HbFam). }
        claim HyP2b: y :e projection_image2 X Y b.
        { claim Hpred: exists x0:set, (x0,y) :e b.
          { witness x.
            exact Hxyb. }
          exact (SepI Y (fun y0:set => exists x0:set, (x0,y0) :e b) y HyY Hpred). }
        exact (UnionI P2Fam y (projection_image2 X Y b) HyP2b HbPF). }
    rewrite <- HUnionEq.
    rewrite <- HUnionP2.
    exact HP2inTy.
Qed.

(** from 16 Exercise 5(a): product topology monotonicity **)
(** LATEX VERSION: Exercise 5(a): If TT' and UU', then the product topology from T,U is contained in that from T',U'. **)
Theorem ex16_5a_product_monotone : forall X T T' Y U U':set,
  X <> Empty -> Y <> Empty ->
  topology_on X T -> topology_on X T' -> topology_on Y U -> topology_on Y U' ->
  T c= T' /\ U c= U' ->
  product_topology X T Y U c= product_topology X T' Y U'.
	let X T T' Y U U'.
	assume HXne: X <> Empty.
	assume HYne: Y <> Empty.
	assume HTx: topology_on X T.
	assume HTx': topology_on X T'.
	assume HTy: topology_on Y U.
	assume HTy': topology_on Y U'.
	assume Hfiner: T c= T' /\ U c= U'.
	prove product_topology X T Y U c= product_topology X T' Y U'.
	claim HBasis: basis_on (setprod X Y) (product_subbasis X T Y U).
	{ exact (product_subbasis_is_basis X T Y U HTx HTy). }
	claim HTprod': topology_on (setprod X Y) (product_topology X T' Y U').
	{ exact (product_topology_is_topology X T' Y U' HTx' HTy'). }
	apply (generated_topology_finer (setprod X Y) (product_subbasis X T Y U) (product_topology X T' Y U') HBasis HTprod').
	let b. assume Hb: b :e product_subbasis X T Y U.
	prove b :e product_topology X T' Y U'.
	claim HexU0: exists U0 :e T, b :e {rectangle_set U0 V|V :e U}.
	{ exact (famunionE T (fun U0:set => {rectangle_set U0 V|V :e U}) b Hb). }
	apply HexU0.
	let U0. assume HU0conj.
	claim HU0T: U0 :e T.
	{ exact (andEL (U0 :e T) (b :e {rectangle_set U0 V|V :e U}) HU0conj). }
	claim HbRepl: b :e {rectangle_set U0 V|V :e U}.
	{ exact (andER (U0 :e T) (b :e {rectangle_set U0 V|V :e U}) HU0conj). }
	claim HexV0: exists V0 :e U, b = rectangle_set U0 V0.
	{ exact (ReplE U (fun V0:set => rectangle_set U0 V0) b HbRepl). }
	apply HexV0.
	let V0. assume HV0conj.
	claim HV0U: V0 :e U.
	{ exact (andEL (V0 :e U) (b = rectangle_set U0 V0) HV0conj). }
	claim Hbeq: b = rectangle_set U0 V0.
	{ exact (andER (V0 :e U) (b = rectangle_set U0 V0) HV0conj). }
	claim HU0sub: U0 :e T'.
	{ claim HTsub: T c= T'.
	  { exact (andEL (T c= T') (U c= U') Hfiner). }
	  exact (HTsub U0 HU0T). }
	claim HV0sub: V0 :e U'.
	{ claim HUsub: U c= U'.
	  { exact (andER (T c= T') (U c= U') Hfiner). }
	  exact (HUsub V0 HV0U). }
	claim HBasis': basis_on (setprod X Y) (product_subbasis X T' Y U').
	{ exact (product_subbasis_is_basis X T' Y U' HTx' HTy'). }
	claim HbSub': b :e product_subbasis X T' Y U'.
	{ prove b :e product_subbasis X T' Y U'.
	  claim HbV: rectangle_set U0 V0 :e {rectangle_set U0 V|V :e U'}.
	  { exact (ReplI U' (fun V1:set => rectangle_set U0 V1) V0 HV0sub). }
	  rewrite Hbeq.
	  exact (famunionI T' (fun U1:set => {rectangle_set U1 V|V :e U'}) U0 (rectangle_set U0 V0) HU0sub HbV). }
	exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X T' Y U') HBasis' b HbSub').
Qed.

(** from 16 Exercise 5(b): converse question about product fineness **)
(** LATEX VERSION: Exercise 5(b): If product topology from T,U is contained in that from T',U', then TT' and UU'. **)
Theorem ex16_5b_product_converse : forall X T T' Y U U':set,
  X <> Empty -> Y <> Empty ->
  topology_on X T -> topology_on X T' -> topology_on Y U -> topology_on Y U' ->
  product_topology X T Y U c= product_topology X T' Y U' ->
  T c= T' /\ U c= U'.
	let X T T' Y U U'.
	assume HXne: X <> Empty.
	assume HYne: Y <> Empty.
	assume HTx: topology_on X T.
	assume HTx': topology_on X T'.
	assume HTy: topology_on Y U.
	assume HTy': topology_on Y U'.
	assume Hprod: product_topology X T Y U c= product_topology X T' Y U'.
	prove T c= T' /\ U c= U'.
	apply andI.
	- (** show T c= T' using openness of projection_image1 **)
	  let V. assume HV: V :e T.
	  prove V :e T'.
	  claim HVsubX: V c= X.
	  { exact (topology_elem_subset X T V HTx HV). }
	  claim HYsubY: Y c= Y.
	  { let y. assume Hy: y :e Y. exact Hy. }
	  claim HYU: Y :e U.
	  { exact (topology_has_X Y U HTy). }
	  claim HbSub: rectangle_set V Y :e product_subbasis X T Y U.
	  { prove rectangle_set V Y :e product_subbasis X T Y U.
	    claim HbV: rectangle_set V Y :e {rectangle_set V W|W :e U}.
	    { exact (ReplI U (fun W1:set => rectangle_set V W1) Y HYU). }
	    exact (famunionI T (fun U0:set => {rectangle_set U0 W|W :e U}) V (rectangle_set V Y) HV HbV). }
	  claim HBasis: basis_on (setprod X Y) (product_subbasis X T Y U).
	  { exact (product_subbasis_is_basis X T Y U HTx HTy). }
	  claim HbOpen: rectangle_set V Y :e product_topology X T Y U.
	  { exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X T Y U) HBasis (rectangle_set V Y) HbSub). }
	  claim HbOpen': rectangle_set V Y :e product_topology X T' Y U'.
	  { exact (Hprod (rectangle_set V Y) HbOpen). }
	  claim HprojOpen: open_in X T' (projection_image1 X Y (rectangle_set V Y)).
	  { exact (andEL (open_in X T' (projection_image1 X Y (rectangle_set V Y))) (open_in Y U' (projection_image2 X Y (rectangle_set V Y)))
	                 (ex16_4_projections_open X T' Y U' HTx' HTy' (rectangle_set V Y) HbOpen')). }
	  claim HVeqProj: projection_image1 X Y (rectangle_set V Y) = V.
	  { exact (projection_image1_rectangle_nonempty X Y V Y HVsubX HYsubY HYne). }
	  claim HVinT': projection_image1 X Y (rectangle_set V Y) :e T'.
	  { exact (andER (topology_on X T') (projection_image1 X Y (rectangle_set V Y) :e T') HprojOpen). }
	  rewrite <- HVeqProj.
	  exact HVinT'.
	- (** show U c= U' using openness of projection_image2 **)
	  let W. assume HW: W :e U.
	  prove W :e U'.
	  claim HWsubY: W c= Y.
	  { exact (topology_elem_subset Y U W HTy HW). }
	  claim HXsubX: X c= X.
	  { let x. assume Hx: x :e X. exact Hx. }
	  claim HX_T: X :e T.
	  { exact (topology_has_X X T HTx). }
	  claim HbSub: rectangle_set X W :e product_subbasis X T Y U.
	  { prove rectangle_set X W :e product_subbasis X T Y U.
	    claim HbW: rectangle_set X W :e {rectangle_set X V|V :e U}.
	    { exact (ReplI U (fun V1:set => rectangle_set X V1) W HW). }
	    exact (famunionI T (fun U0:set => {rectangle_set U0 V|V :e U}) X (rectangle_set X W) HX_T HbW). }
	  claim HBasis: basis_on (setprod X Y) (product_subbasis X T Y U).
	  { exact (product_subbasis_is_basis X T Y U HTx HTy). }
	  claim HbOpen: rectangle_set X W :e product_topology X T Y U.
	  { exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X T Y U) HBasis (rectangle_set X W) HbSub). }
	  claim HbOpen': rectangle_set X W :e product_topology X T' Y U'.
	  { exact (Hprod (rectangle_set X W) HbOpen). }
	  claim HprojOpen: open_in Y U' (projection_image2 X Y (rectangle_set X W)).
	  { exact (andER (open_in X T' (projection_image1 X Y (rectangle_set X W))) (open_in Y U' (projection_image2 X Y (rectangle_set X W)))
	                 (ex16_4_projections_open X T' Y U' HTx' HTy' (rectangle_set X W) HbOpen')). }
	  claim HWeqProj: projection_image2 X Y (rectangle_set X W) = W.
	  { exact (projection_image2_rectangle_nonempty X Y X W HXsubX HWsubY HXne). }
	  claim HWinU': projection_image2 X Y (rectangle_set X W) :e U'.
	  { exact (andER (topology_on Y U') (projection_image2 X Y (rectangle_set X W) :e U') HprojOpen). }
	  rewrite <- HWeqProj.
	  exact HWinU'.
Qed.

(** from 16 Exercise 6: rational rectangles form a basis for  **)
(** LATEX VERSION: Exercise 6: Rational rectangles form a basis generating the standard topology on . **)
Definition rational_rectangle_basis : set :=
  {r :e Power (setprod R R) |
     exists a b c d:set,
       a :e rational_numbers /\ b :e rational_numbers /\
       c :e rational_numbers /\ d :e rational_numbers /\
       r = setprod (open_interval a b) (open_interval c d)}.

Axiom ex16_6_rational_rectangles_basis_axiom :
  basis_on (setprod R R) rational_rectangle_basis /\
  generated_topology (setprod R R) rational_rectangle_basis = R2_standard_topology.

Theorem ex16_6_rational_rectangles_basis :
  basis_on (setprod R R) rational_rectangle_basis /\
  generated_topology (setprod R R) rational_rectangle_basis = R2_standard_topology.
prove basis_on (setprod R R) rational_rectangle_basis /\ generated_topology (setprod R R) rational_rectangle_basis = R2_standard_topology.
exact ex16_6_rational_rectangles_basis_axiom.
Qed.

(** from 16 Exercise 7: convex subset implies interval or ray? **) 
(** LATEX VERSION: Exercise 7: Let X be an ordered set. If Y is a proper subset of X that is convex in X, does it follow that Y is an interval or a ray in X. **)
Definition closed_interval_in : set -> set -> set -> set := fun X a b =>
  {x :e X | (x = a \/ order_rel X a x) /\ (x = b \/ order_rel X x b)}.

Definition halfopen_interval_left_in : set -> set -> set -> set := fun X a b =>
  {x :e X | (x = a \/ order_rel X a x) /\ order_rel X x b}.

Definition halfopen_interval_right_in : set -> set -> set -> set := fun X a b =>
  {x :e X | order_rel X a x /\ (x = b \/ order_rel X x b)}.

Definition closed_ray_upper : set -> set -> set := fun X a =>
  {x :e X | x = a \/ order_rel X a x}.

Definition closed_ray_lower : set -> set -> set := fun X a =>
  {x :e X | x = a \/ order_rel X x a}.

Definition interval_in : set -> set -> set -> set -> prop := fun X a b Y =>
  Y = order_interval X a b
  \/ Y = halfopen_interval_left_in X a b
  \/ Y = halfopen_interval_right_in X a b
  \/ Y = closed_interval_in X a b.

Definition ray_in : set -> set -> set -> prop := fun X a Y =>
  Y = open_ray_upper X a
  \/ Y = closed_ray_upper X a
  \/ Y = open_ray_lower X a
  \/ Y = closed_ray_lower X a.

Definition interval_or_ray_in : set -> set -> prop := fun X Y =>
  (exists a b:set, a :e X /\ b :e X /\ interval_in X a b Y)
  \/ (exists a:set, a :e X /\ ray_in X a Y).

(** Counterexample pattern inside Q: points with q^2 < 2 form a convex set with no endpoint in Q. **)
Definition Q_sqrt2_cut : set := {q :e rational_numbers | mul_SNo q q < 2}.

Axiom ex16_7_convex_interval_or_ray_axiom :
  exists X Y:set, convex_in X Y /\ Y <> X /\ ~ interval_or_ray_in X Y.

Theorem ex16_7_convex_interval_or_ray :
  exists X Y:set, convex_in X Y /\ Y <> X /\ ~ interval_or_ray_in X Y.
prove exists X Y:set, convex_in X Y /\ Y <> X /\ ~ interval_or_ray_in X Y.
exact ex16_7_convex_interval_or_ray_axiom.
Qed.

(** from 16 Exercise 8: lines as subspaces of lower limit products **) 
(** LATEX VERSION: Exercise 8: The diagonal line in  with the lower limit product topology is homeomorphic to  with lower limit topology. **)
Axiom ex16_8_lines_in_lower_limit_products_axiom :
  exists L:set, L c= setprod R R /\
    L = {(x,x)|x :e R} /\
    subspace_topology (setprod R R) (product_topology R R_lower_limit_topology R R_lower_limit_topology) L =
      R_lower_limit_topology.

Theorem ex16_8_lines_in_lower_limit_products :
  exists L:set, L c= setprod R R /\
    L = {(x,x)|x :e R} /\
    subspace_topology (setprod R R) (product_topology R R_lower_limit_topology R R_lower_limit_topology) L =
      R_lower_limit_topology.
prove exists L:set, L c= setprod R R /\ L = {(x,x)|x :e R} /\ subspace_topology (setprod R R) (product_topology R R_lower_limit_topology R R_lower_limit_topology) L = R_lower_limit_topology.
exact ex16_8_lines_in_lower_limit_products_axiom.
Qed.

(** from 16 Exercise 9: dictionary order topology on  equals _d   **) 
(** LATEX VERSION: Exercise 9: The dictionary order topology on  is the same as the product topology _d; compare it with the standard topology. **)
Axiom ex16_9_dictionary_equals_product_axiom :
  R2_dictionary_order_topology = product_topology R (discrete_topology R) R R_standard_topology
  /\ R2_dictionary_order_topology <> R2_standard_topology.

Theorem ex16_9_dictionary_equals_product :
  R2_dictionary_order_topology = product_topology R (discrete_topology R) R R_standard_topology
  /\ R2_dictionary_order_topology <> R2_standard_topology.
prove R2_dictionary_order_topology = product_topology R (discrete_topology R) R R_standard_topology /\ R2_dictionary_order_topology <> R2_standard_topology.
exact ex16_9_dictionary_equals_product_axiom.
Qed.

(** from 16 Exercise 10: compare topologies on II **) 
(** LATEX VERSION: Exercise 10: Compare ordered square topology, dictionary subspace topology, and product topology on II. **)
Axiom ex16_10_compare_topologies_on_square_axiom :
  ordered_square_topology <> subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square /\
  subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square <>
    product_topology unit_interval R_standard_topology unit_interval R_standard_topology.

Theorem ex16_10_compare_topologies_on_square :
  ordered_square_topology <> subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square /\
  subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square <>
    product_topology unit_interval R_standard_topology unit_interval R_standard_topology.
prove ordered_square_topology <> subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square /\ subspace_topology (setprod R R) R2_dictionary_order_topology ordered_square <> product_topology unit_interval R_standard_topology unit_interval R_standard_topology.
exact ex16_10_compare_topologies_on_square_axiom.
Qed.

(** from 17 Definition: interior and closure of a set **) 
(** LATEX VERSION: Interior of A is union of opens inside A; closure of A consists of points whose every open neighborhood meets A. **)
Definition interior_of : set -> set -> set -> set := fun X T A =>
  {x :e X | exists U:set, U :e T /\ x :e U /\ U c= A}.
Definition closure_of : set -> set -> set -> set := fun X T A =>
  {x :e X | forall U:set, U :e T -> x :e U -> U :/\: A <> Empty}.

(** Helper: A is a subset of its closure **)
Theorem subset_of_closure : forall X Tx A:set,
  topology_on X Tx -> A c= X -> A c= closure_of X Tx A.
let X Tx A.
assume Htop: topology_on X Tx.
assume HA: A c= X.
prove A c= closure_of X Tx A.
let x. assume Hx: x :e A.
prove x :e closure_of X Tx A.
(** Show x :e X and for all U open containing x, U  A   **)
claim HxX: x :e X.
{ exact (HA x Hx). }
claim Hcond: forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
{ let U. assume HU: U :e Tx. assume HxU: x :e U.
  prove U :/\: A <> Empty.
  assume Hempty: U :/\: A = Empty.
  (** Derive contradiction: x :e U and x :e A, so x :e U  A **)
  claim HxUA: x :e U :/\: A.
  { exact (binintersectI U A x HxU Hx). }
  claim HxEmpty: x :e Empty.
  { rewrite <- Hempty. exact HxUA. }
  exact (EmptyE x HxEmpty). }
exact (SepI X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x HxX Hcond).
Qed.

(** Helper: Closure is monotone **)
Theorem closure_monotone : forall X Tx A B:set,
  topology_on X Tx -> A c= B -> B c= X -> closure_of X Tx A c= closure_of X Tx B.
let X Tx A B.
assume Htop: topology_on X Tx.
assume HAB: A c= B.
assume HB: B c= X.
prove closure_of X Tx A c= closure_of X Tx B.
let x. assume Hx: x :e closure_of X Tx A.
prove x :e closure_of X Tx B.
(** x satisfies: x :e X and for all U open containing x, U  A   **)
claim HxX: x :e X.
{ exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx). }
claim HcondA: forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
{ exact (SepE2 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx). }
(** Need to show: for all U open containing x, U  B   **)
claim HcondB: forall U:set, U :e Tx -> x :e U -> U :/\: B <> Empty.
{ let U. assume HU: U :e Tx. assume HxU: x :e U.
  prove U :/\: B <> Empty.
  (** We know U  A  , and A  B, so U  A  U  B **)
  claim HUA_ne: U :/\: A <> Empty.
  { exact (HcondA U HU HxU). }
  assume Hempty: U :/\: B = Empty.
  (** Show U  A =  by showing U  A  U  B =  **)
  claim HUA_sub_UB: U :/\: A c= U :/\: B.
  { let y. assume Hy: y :e U :/\: A.
    claim HyU: y :e U.
    { exact (binintersectE1 U A y Hy). }
    claim HyA: y :e A.
    { exact (binintersectE2 U A y Hy). }
    claim HyB: y :e B.
    { exact (HAB y HyA). }
    exact (binintersectI U B y HyU HyB). }
  claim HUA_empty: U :/\: A = Empty.
  { apply Empty_Subq_eq.
    claim HUB_sub_Empty: U :/\: B c= Empty.
    { rewrite Hempty. exact (Subq_ref Empty). }
    exact (Subq_tra (U :/\: A) (U :/\: B) Empty HUA_sub_UB HUB_sub_Empty). }
  exact (HUA_ne HUA_empty). }
exact (SepI X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: B <> Empty) x HxX HcondB).
Qed.

(** Helper: interior of A is contained in A **)
Theorem interior_subset : forall X Tx A:set,
  topology_on X Tx -> interior_of X Tx A c= A.
let X Tx A.
assume Htop: topology_on X Tx.
prove interior_of X Tx A c= A.
let x. assume Hx: x :e interior_of X Tx A.
prove x :e A.
claim Hexists: exists U:set, U :e Tx /\ x :e U /\ U c= A.
{ exact (SepE2 X (fun x0 => exists U:set, U :e Tx /\ x0 :e U /\ U c= A) x Hx). }
apply Hexists.
let U. assume HU_conj: U :e Tx /\ x :e U /\ U c= A.
(** Conjunction is left-associative: ((U :e Tx /\ x :e U) /\ U c= A) **)
claim HU_and_x: U :e Tx /\ x :e U.
{ exact (andEL (U :e Tx /\ x :e U) (U c= A) HU_conj). }
claim HUsub: U c= A.
{ exact (andER (U :e Tx /\ x :e U) (U c= A) HU_conj). }
claim HxU: x :e U.
{ exact (andER (U :e Tx) (x :e U) HU_and_x). }
exact (HUsub x HxU).
Qed.

(** Helper: interior is monotone **)
Theorem interior_monotone : forall X Tx A B:set,
  topology_on X Tx -> A c= B -> interior_of X Tx A c= interior_of X Tx B.
let X Tx A B.
assume Htop: topology_on X Tx.
assume HAB: A c= B.
prove interior_of X Tx A c= interior_of X Tx B.
let x. assume Hx: x :e interior_of X Tx A.
prove x :e interior_of X Tx B.
claim HxX: x :e X.
{ exact (SepE1 X (fun x0 => exists U:set, U :e Tx /\ x0 :e U /\ U c= A) x Hx). }
claim Hexists: exists U:set, U :e Tx /\ x :e U /\ U c= A.
{ exact (SepE2 X (fun x0 => exists U:set, U :e Tx /\ x0 :e U /\ U c= A) x Hx). }
apply Hexists.
let U. assume HU_conj: U :e Tx /\ x :e U /\ U c= A.
(** Conjunction is left-associative: ((U :e Tx /\ x :e U) /\ U c= A) **)
claim HU_and_x: U :e Tx /\ x :e U.
{ exact (andEL (U :e Tx /\ x :e U) (U c= A) HU_conj). }
claim HUsub_A: U c= A.
{ exact (andER (U :e Tx /\ x :e U) (U c= A) HU_conj). }
claim HU: U :e Tx.
{ exact (andEL (U :e Tx) (x :e U) HU_and_x). }
claim HxU: x :e U.
{ exact (andER (U :e Tx) (x :e U) HU_and_x). }
claim HUsub_B: U c= B.
{ exact (Subq_tra U A B HUsub_A HAB). }
(** Now construct the witness for x :e interior_of X Tx B **)
claim Hwitness: U :e Tx /\ x :e U /\ U c= B.
{ apply andI.
  - apply andI.
    + exact HU.
    + exact HxU.
  - exact HUsub_B. }
claim Hexists_B: exists V:set, V :e Tx /\ x :e V /\ V c= B.
{ witness U.
  exact Hwitness. }
exact (SepI X (fun x0 => exists V:set, V :e Tx /\ x0 :e V /\ V c= B) x HxX Hexists_B).
Qed.

(** Helper: open sets equal their interior **)
Theorem open_interior_eq : forall X Tx U:set,
  topology_on X Tx -> U :e Tx -> interior_of X Tx U = U.
let X Tx U.
assume Htop: topology_on X Tx.
assume HU: U :e Tx.
prove interior_of X Tx U = U.
apply set_ext.
- (** interior(U)  U **)
  exact (interior_subset X Tx U Htop).
- (** U  interior(U) **)
  let x. assume Hx: x :e U.
  prove x :e interior_of X Tx U.
  claim HUsub: U c= X.
  { exact (topology_elem_subset X Tx U Htop HU). }
  claim HxX: x :e X.
  { exact (HUsub x Hx). }
  claim Hwitness: U :e Tx /\ x :e U /\ U c= U.
  { apply andI.
    - apply andI.
      + exact HU.
      + exact Hx.
    - exact (Subq_ref U). }
  claim Hexists: exists V:set, V :e Tx /\ x :e V /\ V c= U.
  { witness U.
    exact Hwitness. }
  exact (SepI X (fun x0 => exists V:set, V :e Tx /\ x0 :e V /\ V c= U) x HxX Hexists).
Qed.

(** Helper: interior of empty set is empty **)
Theorem interior_of_empty : forall X Tx:set,
  topology_on X Tx -> interior_of X Tx Empty = Empty.
let X Tx.
assume Htop: topology_on X Tx.
prove interior_of X Tx Empty = Empty.
apply set_ext.
- (** interior(Empty)  Empty **)
  exact (interior_subset X Tx Empty Htop).
- (** Empty  interior(Empty) **)
  exact (Subq_Empty (interior_of X Tx Empty)).
Qed.

(** Helper: interior of whole space is the space **)
Theorem interior_of_space : forall X Tx:set,
  topology_on X Tx -> interior_of X Tx X = X.
let X Tx.
assume Htop: topology_on X Tx.
prove interior_of X Tx X = X.
claim HXopen: X :e Tx.
{ exact (topology_has_X X Tx Htop). }
exact (open_interior_eq X Tx X Htop HXopen).
Qed.

(** Helper: interior is open **)
Theorem interior_is_open : forall X Tx A:set,
  topology_on X Tx -> A c= X -> interior_of X Tx A :e Tx.
let X Tx A.
assume Htop: topology_on X Tx.
assume HA: A c= X.
prove interior_of X Tx A :e Tx.
(** Strategy: interior(A) is the union of all open sets contained in A.
    The union of a family of open sets is open. **)
set F := {U :e Tx | U c= A}.
claim Hint_eq_union: interior_of X Tx A = Union F.
{ apply set_ext.
  - (** interior(A)  Union(F) **)
    let x. assume Hx: x :e interior_of X Tx A.
    prove x :e Union F.
    claim HxX: x :e X.
    { exact (SepE1 X (fun x0 => exists U:set, U :e Tx /\ x0 :e U /\ U c= A) x Hx). }
    claim Hexists: exists U:set, U :e Tx /\ x :e U /\ U c= A.
    { exact (SepE2 X (fun x0 => exists U:set, U :e Tx /\ x0 :e U /\ U c= A) x Hx). }
    apply Hexists.
    let U. assume HU_conj: U :e Tx /\ x :e U /\ U c= A.
    claim HU_and_x: U :e Tx /\ x :e U.
    { exact (andEL (U :e Tx /\ x :e U) (U c= A) HU_conj). }
    claim HUsub: U c= A.
    { exact (andER (U :e Tx /\ x :e U) (U c= A) HU_conj). }
    claim HU: U :e Tx.
    { exact (andEL (U :e Tx) (x :e U) HU_and_x). }
    claim HxU: x :e U.
    { exact (andER (U :e Tx) (x :e U) HU_and_x). }
    claim HUinF: U :e F.
    { apply SepI.
      - exact HU.
      - exact HUsub. }
    exact (UnionI F x U HxU HUinF).
  - (** Union(F)  interior(A) **)
    let x. assume Hx: x :e Union F.
    prove x :e interior_of X Tx A.
    apply (UnionE_impred F x Hx (x :e interior_of X Tx A)).
    let U. assume HxU: x :e U. assume HUinF: U :e F.
    claim HU: U :e Tx.
    { exact (SepE1 Tx (fun U0 => U0 c= A) U HUinF). }
    claim HUsub: U c= A.
    { exact (SepE2 Tx (fun U0 => U0 c= A) U HUinF). }
    claim HUsub_X: U c= X.
    { exact (topology_elem_subset X Tx U Htop HU). }
    claim HxX: x :e X.
    { exact (HUsub_X x HxU). }
    claim Hwitness: U :e Tx /\ x :e U /\ U c= A.
    { apply andI.
      - apply andI.
        + exact HU.
        + exact HxU.
      - exact HUsub. }
    claim Hexists: exists V:set, V :e Tx /\ x :e V /\ V c= A.
    { witness U. exact Hwitness. }
    exact (SepI X (fun x0 => exists V:set, V :e Tx /\ x0 :e V /\ V c= A) x HxX Hexists). }
(** Now show Union F is open **)
claim HF_sub_Tx: F c= Tx.
{ let U. assume HU: U :e F.
  exact (SepE1 Tx (fun U0 => U0 c= A) U HU). }
claim Hunion_in_Tx: Union F :e Tx.
{ exact (topology_union_closed X Tx F Htop HF_sub_Tx). }
(** By Hint_eq_union, interior_of X Tx A = Union F, so interior is open **)
(** Use equality: if A = B and B :e Tx, then A :e Tx **)
claim Heq_substitution: forall S T:set, S = T -> T :e Tx -> S :e Tx.
{ let S T. assume HeqST: S = T. assume HTinTx: T :e Tx.
  (** Rewrite S as T in the goal S :e Tx **)
  prove S :e Tx.
  claim HST_equiv: forall P:set -> prop, P T -> P S.
  { let P. assume HPT: P T.
    (** Use symmetry of equality and substitution **)
    prove P S.
    rewrite HeqST.
    exact HPT. }
  exact (HST_equiv (fun X0 => X0 :e Tx) HTinTx). }
exact (Heq_substitution (interior_of X Tx A) (Union F) Hint_eq_union Hunion_in_Tx).
Qed.

(** Helper: union of interiors contained in interior of union **)
Theorem interior_union_contains_union_interiors : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  interior_of X Tx A :\/: interior_of X Tx B c= interior_of X Tx (A :\/: B).
let X Tx A B.
assume Htop: topology_on X Tx.
assume HA: A c= X.
assume HB: B c= X.
prove interior_of X Tx A :\/: interior_of X Tx B c= interior_of X Tx (A :\/: B).
(** Use monotonicity: A  AB and B  AB **)
claim HAB_union_A: A c= A :\/: B.
{ let x. assume Hx: x :e A. exact (binunionI1 A B x Hx). }
claim HAB_union_B: B c= A :\/: B.
{ let x. assume Hx: x :e B. exact (binunionI2 A B x Hx). }
claim HAB_sub: A :\/: B c= X.
{ let x. assume Hx: x :e A :\/: B.
  apply (binunionE A B x Hx).
  - assume HxA: x :e A. exact (HA x HxA).
  - assume HxB: x :e B. exact (HB x HxB). }
claim HintA: interior_of X Tx A c= interior_of X Tx (A :\/: B).
{ exact (interior_monotone X Tx A (A :\/: B) Htop HAB_union_A). }
claim HintB: interior_of X Tx B c= interior_of X Tx (A :\/: B).
{ exact (interior_monotone X Tx B (A :\/: B) Htop HAB_union_B). }
let x. assume Hx: x :e interior_of X Tx A :\/: interior_of X Tx B.
apply (binunionE (interior_of X Tx A) (interior_of X Tx B) x Hx).
- assume HxA: x :e interior_of X Tx A. exact (HintA x HxA).
- assume HxB: x :e interior_of X Tx B. exact (HintB x HxB).
Qed.

(** Helper: interior of intersection contains intersection of interiors **)
Theorem interior_intersection_contains_intersection : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  interior_of X Tx (A :/\: B) c= interior_of X Tx A :/\: interior_of X Tx B.
let X Tx A B.
assume Htop: topology_on X Tx.
assume HA: A c= X.
assume HB: B c= X.
prove interior_of X Tx (A :/\: B) c= interior_of X Tx A :/\: interior_of X Tx B.
(** Use monotonicity: A  B  A and A  B  B **)
claim HAB_A: A :/\: B c= A.
{ exact (binintersect_Subq_1 A B). }
claim HAB_B: A :/\: B c= B.
{ exact (binintersect_Subq_2 A B). }
claim HintAB_A: interior_of X Tx (A :/\: B) c= interior_of X Tx A.
{ exact (interior_monotone X Tx (A :/\: B) A Htop HAB_A). }
claim HintAB_B: interior_of X Tx (A :/\: B) c= interior_of X Tx B.
{ exact (interior_monotone X Tx (A :/\: B) B Htop HAB_B). }
let x. assume Hx: x :e interior_of X Tx (A :/\: B).
apply binintersectI.
- exact (HintAB_A x Hx).
- exact (HintAB_B x Hx).
Qed.

(** Helper: interior of intersection of open sets **)
Theorem interior_intersection_of_opens : forall X Tx U V:set,
  topology_on X Tx -> U :e Tx -> V :e Tx ->
  interior_of X Tx (U :/\: V) = U :/\: V.
let X Tx U V.
assume Htop: topology_on X Tx.
assume HU: U :e Tx.
assume HV: V :e Tx.
prove interior_of X Tx (U :/\: V) = U :/\: V.
(** Strategy: U  V is open (by topology axioms), and open sets equal their interior **)
claim HUV_open: U :/\: V :e Tx.
{ exact (lemma_intersection_two_open X Tx U V Htop HU HV). }
exact (open_interior_eq X Tx (U :/\: V) Htop HUV_open).
Qed.

(** Helper: interior is idempotent **)
Theorem interior_idempotent : forall X Tx A:set,
  topology_on X Tx -> A c= X -> interior_of X Tx (interior_of X Tx A) = interior_of X Tx A.
let X Tx A.
assume Htop: topology_on X Tx.
assume HA: A c= X.
prove interior_of X Tx (interior_of X Tx A) = interior_of X Tx A.
(** Strategy: interior(A) is open, and open sets equal their interior **)
claim HintA_open: interior_of X Tx A :e Tx.
{ exact (interior_is_open X Tx A Htop HA). }
exact (open_interior_eq X Tx (interior_of X Tx A) Htop HintA_open).
Qed.

(** Helper: interior-closure duality **)

Theorem not_in_closure_has_disjoint_open : forall X Tx A x:set,
  topology_on X Tx -> A c= X -> x :e X -> x /:e closure_of X Tx A ->
  exists U:set, U :e Tx /\ x :e U /\ U :/\: A = Empty.
let X Tx A x.
assume Htop: topology_on X Tx.
assume HA: A c= X.
assume HxX: x :e X.
assume Hxnotcl: x /:e closure_of X Tx A.
prove exists U:set, U :e Tx /\ x :e U /\ U :/\: A = Empty.
(** By definition, x  cl(A) means x  X and U open, x  U  U  A   **)
(** Since x  cl(A) and x  X, there must exist U open with x  U and U  A =  **)
apply (xm (exists U:set, U :e Tx /\ x :e U /\ U :/\: A = Empty)).
- assume H. exact H.
- assume Hnoex: ~(exists U:set, U :e Tx /\ x :e U /\ U :/\: A = Empty).
  (** Then U open, x  U  U  A  , which means x  cl(A) **)
  apply FalseE.
  apply Hxnotcl.
  prove x :e closure_of X Tx A.
  prove x :e {y :e X | forall U:set, U :e Tx -> y :e U -> U :/\: A <> Empty}.
  apply SepI.
  + exact HxX.
  + prove forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
    let U. assume HU: U :e Tx. assume HxU: x :e U.
    prove U :/\: A <> Empty.
    assume Heq: U :/\: A = Empty.
    apply Hnoex.
    witness U.
    prove U :e Tx /\ x :e U /\ U :/\: A = Empty.
    apply andI.
    * apply andI.
      + exact HU.
      + exact HxU.
    * exact Heq.
Qed.

Theorem closure_is_closed : forall X Tx A:set,
  topology_on X Tx -> A c= X -> closed_in X Tx (closure_of X Tx A).
let X Tx A.
assume Htop: topology_on X Tx.
assume HA: A c= X.
prove closed_in X Tx (closure_of X Tx A).
(** Strategy: Show X \ cl(A) is open by showing it's a union of open sets **)
(** For each x  X \ cl(A), there exists open U with x  U and U  A =  **)
(** Then X \ cl(A) = {U : x  X \ cl(A)}, which is open **)
prove topology_on X Tx /\ (closure_of X Tx A c= X /\ exists U :e Tx, closure_of X Tx A = X :\: U).
apply andI.
- exact Htop.
- prove closure_of X Tx A c= X /\ exists U :e Tx, closure_of X Tx A = X :\: U.
  apply andI.
  + (** closure(A)  X **)
    prove closure_of X Tx A c= X.
    let x. assume Hx: x :e closure_of X Tx A.
    exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx).
  + (** Prove X \ cl(A) is open **)
    set Complement := X :\: closure_of X Tx A.
    set OpenFamily := {U :e Tx | U :/\: A = Empty}.
    claim Hcomp_eq: Complement = Union OpenFamily.
    { apply set_ext.
      - (** Complement  Union OpenFamily **)
        let x. assume Hx: x :e Complement.
        prove x :e Union OpenFamily.
        claim HxX: x :e X.
        { exact (setminusE1 X (closure_of X Tx A) x Hx). }
        claim Hxnotcl: x /:e closure_of X Tx A.
        { exact (setminusE2 X (closure_of X Tx A) x Hx). }
        claim Hexists: exists U:set, U :e Tx /\ x :e U /\ U :/\: A = Empty.
        { exact (not_in_closure_has_disjoint_open X Tx A x Htop HA HxX Hxnotcl). }
        apply Hexists.
        let U. assume HU_parts.
        claim HU_and_xU: U :e Tx /\ x :e U.
        { exact (andEL (U :e Tx /\ x :e U) (U :/\: A = Empty) HU_parts). }
        claim HU: U :e Tx.
        { exact (andEL (U :e Tx) (x :e U) HU_and_xU). }
        claim HxU: x :e U.
        { exact (andER (U :e Tx) (x :e U) HU_and_xU). }
        claim HUdisj: U :/\: A = Empty.
        { exact (andER (U :e Tx /\ x :e U) (U :/\: A = Empty) HU_parts). }
        claim HUinFam: U :e OpenFamily.
        { exact (SepI Tx (fun V => V :/\: A = Empty) U HU HUdisj). }
        exact (UnionI OpenFamily x U HxU HUinFam).
      - (** Union OpenFamily  Complement **)
        let x. assume Hx: x :e Union OpenFamily.
        prove x :e Complement.
        apply (UnionE_impred OpenFamily x Hx).
        let U. assume HxU: x :e U. assume HUFam: U :e OpenFamily.
        claim HU: U :e Tx.
        { exact (SepE1 Tx (fun V => V :/\: A = Empty) U HUFam). }
        claim HUdisj: U :/\: A = Empty.
        { exact (SepE2 Tx (fun V => V :/\: A = Empty) U HUFam). }
        claim HUsub: U c= X.
        { exact (topology_elem_subset X Tx U Htop HU). }
        claim HxX: x :e X.
        { exact (HUsub x HxU). }
        apply setminusI.
        + exact HxX.
        + assume Hxcl: x :e closure_of X Tx A.
          claim Hcond: forall V:set, V :e Tx -> x :e V -> V :/\: A <> Empty.
          { exact (SepE2 X (fun y => forall V:set, V :e Tx -> y :e V -> V :/\: A <> Empty) x Hxcl). }
          claim Hcontra: U :/\: A <> Empty.
          { exact (Hcond U HU HxU). }
          exact (Hcontra HUdisj). }
    claim Hopen_subset: OpenFamily c= Tx.
    { let U. assume HU: U :e OpenFamily.
      exact (SepE1 Tx (fun V => V :/\: A = Empty) U HU). }
    claim Hcomp_open: Complement :e Tx.
    { rewrite Hcomp_eq.
      exact (topology_union_closed X Tx OpenFamily Htop Hopen_subset). }
    witness Complement.
    apply andI.
    * exact Hcomp_open.
    * (** closure(A) = X \ Complement **)
      apply set_ext.
      + let x. assume Hx: x :e closure_of X Tx A.
        prove x :e X :\: Complement.
        claim HxX: x :e X.
        { exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx). }
        apply setminusI.
        * exact HxX.
        * assume Hxcomp: x :e Complement.
          claim Hxnotcl: x /:e closure_of X Tx A.
          { exact (setminusE2 X (closure_of X Tx A) x Hxcomp). }
          exact (Hxnotcl Hx).
      + let x. assume Hx: x :e X :\: Complement.
        prove x :e closure_of X Tx A.
        claim HxX: x :e X.
        { exact (setminusE1 X Complement x Hx). }
        claim Hxnotcomp: x /:e Complement.
        { exact (setminusE2 X Complement x Hx). }
        apply (xm (x :e closure_of X Tx A)).
        * assume H. exact H.
        * assume Hxnotcl: x /:e closure_of X Tx A.
          apply FalseE.
          apply Hxnotcomp.
          apply setminusI.
          - exact HxX.
          - exact Hxnotcl.
Qed.

Theorem interior_closure_complement_duality : forall X Tx A:set,
  topology_on X Tx -> A c= X ->
  interior_of X Tx A = X :\: closure_of X Tx (X :\: A).
let X Tx A.
assume Htop: topology_on X Tx.
assume HA: A c= X.
prove interior_of X Tx A = X :\: closure_of X Tx (X :\: A).
(** Strategy: int(A) is the largest open subset of A.
    X \ cl(X\A) is open (complement of closed), and we show it equals int(A). **)
claim HXA_sub: X :\: A c= X.
{ let x. assume Hx: x :e X :\: A.
  exact (setminusE1 X A x Hx). }
(** cl(X\A) is closed, so X \ cl(X\A) is open **)
claim Hclosed: closed_in X Tx (closure_of X Tx (X :\: A)).
{ exact (closure_is_closed X Tx (X :\: A) Htop HXA_sub). }
(** Extract that there exists U open with cl(X\A) = X \ U, so X \ cl(X\A) = U is open **)
claim Hclosed_parts: topology_on X Tx /\ (closure_of X Tx (X :\: A) c= X /\ exists U :e Tx, closure_of X Tx (X :\: A) = X :\: U).
{ exact Hclosed. }
claim Hexists: exists U :e Tx, closure_of X Tx (X :\: A) = X :\: U.
{ claim Hpart2: closure_of X Tx (X :\: A) c= X /\ exists U :e Tx, closure_of X Tx (X :\: A) = X :\: U.
  { exact (andER (topology_on X Tx) (closure_of X Tx (X :\: A) c= X /\ exists U :e Tx, closure_of X Tx (X :\: A) = X :\: U) Hclosed_parts). }
  exact (andER (closure_of X Tx (X :\: A) c= X) (exists U :e Tx, closure_of X Tx (X :\: A) = X :\: U) Hpart2). }
apply Hexists.
let U. assume HU_conj: U :e Tx /\ closure_of X Tx (X :\: A) = X :\: U.
claim HU_open: U :e Tx.
{ exact (andEL (U :e Tx) (closure_of X Tx (X :\: A) = X :\: U) HU_conj). }
claim Heq_clXA: closure_of X Tx (X :\: A) = X :\: U.
{ exact (andER (U :e Tx) (closure_of X Tx (X :\: A) = X :\: U) HU_conj). }
(** Now show X \ cl(X\A) = U **)
claim HcompU: X :\: closure_of X Tx (X :\: A) = U.
{ apply set_ext.
  - let x. assume Hx: x :e X :\: closure_of X Tx (X :\: A).
    prove x :e U.
    claim HxX: x :e X.
    { exact (setminusE1 X (closure_of X Tx (X :\: A)) x Hx). }
    claim Hxnotcl: x /:e closure_of X Tx (X :\: A).
    { exact (setminusE2 X (closure_of X Tx (X :\: A)) x Hx). }
    (** From Heq_clXA: cl(X\A) = X \ U, so x  cl(X\A) means x  X \ U, i.e., x  U **)
    apply (xm (x :e U)).
    + assume H. exact H.
    + assume HxnotU: x /:e U.
      apply FalseE.
      apply Hxnotcl.
      (** x  X and x  U, so x  X \ U = cl(X\A) **)
      claim HxXminusU: x :e X :\: U.
      { apply setminusI. exact HxX. exact HxnotU. }
      (** Use Heq_clXA: cl(X\A) = X \ U **)
      prove x :e closure_of X Tx (X :\: A).
      rewrite Heq_clXA.
      exact HxXminusU.
  - let x. assume Hx: x :e U.
    prove x :e X :\: closure_of X Tx (X :\: A).
    claim HUsub: U c= X.
    { exact (topology_elem_subset X Tx U Htop HU_open). }
    claim HxX: x :e X.
    { exact (HUsub x Hx). }
    apply setminusI.
    + exact HxX.
    + assume Hxcl: x :e closure_of X Tx (X :\: A).
      (** From Heq_clXA: cl(X\A) = X \ U, so x  cl(X\A) means x  X \ U, so x  U **)
      claim HxXminusU: x :e X :\: U.
      { rewrite <- Heq_clXA. exact Hxcl. }
      claim HxnotU: x /:e U.
      { exact (setminusE2 X U x HxXminusU). }
      exact (HxnotU Hx). }
(** Now show U  A **)
claim HUsub_A: U c= A.
{ let x. assume Hx: x :e U.
  prove x :e A.
  claim HUsub: U c= X.
  { exact (topology_elem_subset X Tx U Htop HU_open). }
  claim HxX: x :e X.
  { exact (HUsub x Hx). }
  apply (xm (x :e A)).
  - assume H. exact H.
  - assume HxnotA: x /:e A.
    (** Then x  X \ A, so x  cl(X\A) = X \ U, so x  U, contradiction **)
    apply FalseE.
    claim HxXminusA: x :e X :\: A.
    { apply setminusI. exact HxX. exact HxnotA. }
    claim Hxincl: x :e closure_of X Tx (X :\: A).
    { exact (subset_of_closure X Tx (X :\: A) Htop HXA_sub x HxXminusA). }
    claim HxXminusU: x :e X :\: U.
    { rewrite <- Heq_clXA. exact Hxincl. }
    claim HxnotU: x /:e U.
    { exact (setminusE2 X U x HxXminusU). }
    exact (HxnotU Hx). }
(** Finally show int(A) = U **)
claim Hint_eq_U: interior_of X Tx A = U.
{ apply set_ext.
- (** int(A)  U **)
  let x. assume Hx: x :e interior_of X Tx A.
  prove x :e U.
  claim HxX: x :e X.
  { exact (SepE1 X (fun y => exists V:set, V :e Tx /\ y :e V /\ V c= A) x Hx). }
  claim Hexists_V: exists V:set, V :e Tx /\ x :e V /\ V c= A.
  { exact (SepE2 X (fun y => exists V:set, V :e Tx /\ y :e V /\ V c= A) x Hx). }
  apply Hexists_V.
  let V. assume HV_conj.
  claim HV_and_xV: V :e Tx /\ x :e V.
  { exact (andEL (V :e Tx /\ x :e V) (V c= A) HV_conj). }
  claim HV: V :e Tx.
  { exact (andEL (V :e Tx) (x :e V) HV_and_xV). }
  claim HxV: x :e V.
  { exact (andER (V :e Tx) (x :e V) HV_and_xV). }
  claim HVsub: V c= A.
  { exact (andER (V :e Tx /\ x :e V) (V c= A) HV_conj). }
  (** Show x  cl(X\A), which means x  U **)
  apply (xm (x :e U)).
  + assume H. exact H.
  + assume HxnotU: x /:e U.
    (** Then x  X \ U = cl(X\A), but V is open with x  V  A, so V  (X\A) = , contradiction **)
    apply FalseE.
    claim HxXminusU: x :e X :\: U.
    { apply setminusI. exact HxX. exact HxnotU. }
    claim Hxcl: x :e closure_of X Tx (X :\: A).
    { rewrite Heq_clXA. exact HxXminusU. }
    (** x  cl(X\A) means V  (X\A)   **)
    claim Hcond: forall W:set, W :e Tx -> x :e W -> W :/\: (X :\: A) <> Empty.
    { exact (SepE2 X (fun y => forall W:set, W :e Tx -> y :e W -> W :/\: (X :\: A) <> Empty) x Hxcl). }
    claim HVmeets: V :/\: (X :\: A) <> Empty.
    { exact (Hcond V HV HxV). }
    (** But V  A, so V  (X\A) =  **)
    claim HVdisj: V :/\: (X :\: A) = Empty.
    { apply set_ext.
      - let y. assume Hy: y :e V :/\: (X :\: A).
        prove y :e Empty.
        claim HyV: y :e V.
        { exact (binintersectE1 V (X :\: A) y Hy). }
        claim HyXminusA: y :e X :\: A.
        { exact (binintersectE2 V (X :\: A) y Hy). }
        claim HyA: y :e A.
        { exact (HVsub y HyV). }
        claim HynotA: y /:e A.
        { exact (setminusE2 X A y HyXminusA). }
        apply FalseE.
        exact (HynotA HyA).
      - exact (Subq_Empty (V :/\: (X :\: A))). }
    exact (HVmeets HVdisj).
- (** U  int(A) **)
  let x. assume Hx: x :e U.
  prove x :e interior_of X Tx A.
  claim HUsub: U c= X.
  { exact (topology_elem_subset X Tx U Htop HU_open). }
  claim HxX: x :e X.
  { exact (HUsub x Hx). }
  prove x :e {y :e X | exists V:set, V :e Tx /\ y :e V /\ V c= A}.
  apply SepI.
  + exact HxX.
  + prove exists V:set, V :e Tx /\ x :e V /\ V c= A.
    witness U.
    prove U :e Tx /\ x :e U /\ U c= A.
    apply andI.
    * apply andI.
      - exact HU_open.
      - exact Hx.
    * exact HUsub_A. }
(** Now use HcompU to get the final result **)
prove interior_of X Tx A = X :\: closure_of X Tx (X :\: A).
rewrite HcompU.
exact Hint_eq_U.
Qed.


(** Helper: closure contains the set **)
Theorem closure_contains_set : forall X Tx A:set,
  topology_on X Tx -> A c= X -> A c= closure_of X Tx A.
let X Tx A.
assume Htop: topology_on X Tx.
assume HA: A c= X.
exact (subset_of_closure X Tx A Htop HA).
Qed.

(** Helper: closure is in X **)
Theorem closure_in_space : forall X Tx A:set,
  topology_on X Tx -> closure_of X Tx A c= X.
let X Tx A.
assume Htop: topology_on X Tx.
prove closure_of X Tx A c= X.
let x. assume Hx: x :e closure_of X Tx A.
prove x :e X.
exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx).
Qed.

(** Helper: closure is contained in any closed superset **)
Theorem closure_subset_of_closed_superset : forall X Tx A C:set,
  topology_on X Tx ->
  A c= C ->
  closed_in X Tx C ->
  closure_of X Tx A c= C.
let X Tx A C.
assume Htop: topology_on X Tx.
assume HAC: A c= C.
assume HC: closed_in X Tx C.
prove closure_of X Tx A c= C.
let x. assume Hx: x :e closure_of X Tx A.
prove x :e C.
apply (xm (x :e C)).
- assume HxC: x :e C. exact HxC.
- assume HxnotC: x /:e C.
  claim HCparts: C c= X /\ exists U :e Tx, C = X :\: U.
  { exact (andER (topology_on X Tx) (C c= X /\ exists U :e Tx, C = X :\: U) HC). }
  claim HxX: x :e X.
  { exact (closure_in_space X Tx A Htop x Hx). }
  claim HcondA: forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
  { exact (SepE2 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx). }
  apply (andER (C c= X) (exists U :e Tx, C = X :\: U) HCparts).
  let U. assume HUconj: U :e Tx /\ C = X :\: U.
  claim HU: U :e Tx.
  { exact (andEL (U :e Tx) (C = X :\: U) HUconj). }
  claim HCeq: C = X :\: U.
  { exact (andER (U :e Tx) (C = X :\: U) HUconj). }
  claim HxU: x :e U.
  { apply (xm (x :e U)).
    - assume H. exact H.
    - assume HxnotU: x /:e U.
      apply FalseE.
      apply HxnotC.
      claim HxXU: x :e X :\: U.
      { exact (setminusI X U x HxX HxnotU). }
      rewrite HCeq.
      exact HxXU. }
  claim HUAne: U :/\: A <> Empty.
  { exact (HcondA U HU HxU). }
  claim HUAempty: U :/\: A = Empty.
  { apply Empty_Subq_eq.
    let y. assume Hy: y :e U :/\: A.
    prove y :e Empty.
    claim HyU: y :e U.
    { exact (binintersectE1 U A y Hy). }
    claim HyA: y :e A.
    { exact (binintersectE2 U A y Hy). }
    claim HyC: y :e C.
    { exact (HAC y HyA). }
    claim HyXU: y :e X :\: U.
    { rewrite <- HCeq. exact HyC. }
    claim HynotU: y /:e U.
    { exact (setminusE2 X U y HyXU). }
    apply FalseE.
    exact (HynotU HyU). }
  apply FalseE.
  exact (HUAne HUAempty).
Qed.

(** Helper: closure of union contains union of closures **)
Theorem closure_union_contains_union_closures : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  closure_of X Tx A :\/: closure_of X Tx B c= closure_of X Tx (A :\/: B).
let X Tx A B.
assume Htop: topology_on X Tx.
assume HA: A c= X.
assume HB: B c= X.
prove closure_of X Tx A :\/: closure_of X Tx B c= closure_of X Tx (A :\/: B).
(** Use monotonicity of closure with A c= AB and B c= AB **)
claim HAB_union: A c= A :\/: B.
{ let x. assume Hx: x :e A. exact (binunionI1 A B x Hx). }
claim HBB_union: B c= A :\/: B.
{ let x. assume Hx: x :e B. exact (binunionI2 A B x Hx). }
claim HAB_sub: A :\/: B c= X.
{ let x. assume Hx: x :e A :\/: B.
  apply (binunionE A B x Hx).
  - assume HxA: x :e A. exact (HA x HxA).
  - assume HxB: x :e B. exact (HB x HxB). }
claim HclA: closure_of X Tx A c= closure_of X Tx (A :\/: B).
{ exact (closure_monotone X Tx A (A :\/: B) Htop HAB_union HAB_sub). }
claim HclB: closure_of X Tx B c= closure_of X Tx (A :\/: B).
{ exact (closure_monotone X Tx B (A :\/: B) Htop HBB_union HAB_sub). }
let x. assume Hx: x :e closure_of X Tx A :\/: closure_of X Tx B.
apply (binunionE (closure_of X Tx A) (closure_of X Tx B) x Hx).
- assume HxA: x :e closure_of X Tx A. exact (HclA x HxA).
- assume HxB: x :e closure_of X Tx B. exact (HclB x HxB).
Qed.

(** Helper: closure of empty set is empty **)
Theorem closure_of_empty : forall X Tx:set,
  topology_on X Tx -> closure_of X Tx Empty = Empty.
let X Tx.
assume Htop: topology_on X Tx.
prove closure_of X Tx Empty = Empty.
apply set_ext.
- prove closure_of X Tx Empty c= Empty.
  let x. assume Hx: x :e closure_of X Tx Empty.
  prove x :e Empty.
  (** x :e closure means: x :e X and for all U open with x :e U, U  Empty  Empty.
      But U  Empty = Empty always, so this is impossible unless X is open and x :e X forces contradiction. **)
  apply (SepE X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: Empty <> Empty) x Hx).
  assume HxX: x :e X.
  assume Hcond: forall U:set, U :e Tx -> x :e U -> U :/\: Empty <> Empty.
  (** Get X itself as an open set containing x **)
  claim HXopen: X :e Tx.
  { exact (topology_has_X X Tx Htop). }
  claim HXne: X :/\: Empty <> Empty.
  { exact (Hcond X HXopen HxX). }
  (** But X  Empty = Empty **)
  claim HXempty: X :/\: Empty = Empty.
  { apply set_ext.
    - let y. assume Hy: y :e X :/\: Empty.
      exact (binintersectE2 X Empty y Hy).
    - exact (Subq_Empty (X :/\: Empty)). }
  apply HXne.
  exact HXempty.
- exact (Subq_Empty (closure_of X Tx Empty)).
Qed.

(** Helper: closure of the whole space is the space itself **)
Theorem closure_of_space : forall X Tx:set,
  topology_on X Tx -> closure_of X Tx X = X.
let X Tx.
assume Htop: topology_on X Tx.
prove closure_of X Tx X = X.
apply set_ext.
- exact (closure_in_space X Tx X Htop).
- exact (subset_of_closure X Tx X Htop (Subq_ref X)).
Qed.

(** Helper: union of two closed sets is closed **)
Theorem union_of_closed_is_closed : forall X Tx C D:set,
  topology_on X Tx -> closed_in X Tx C -> closed_in X Tx D ->
  closed_in X Tx (C :\/: D).
let X Tx C D.
assume Htop: topology_on X Tx.
assume HC: closed_in X Tx C.
assume HD: closed_in X Tx D.
prove closed_in X Tx (C :\/: D).
(** C = X \ U and D = X \ V for some open U, V.
    Then C  D = X \ (U  V), and U  V is open. **)
prove topology_on X Tx /\ (C :\/: D c= X /\ exists W :e Tx, C :\/: D = X :\: W).
apply andI.
- exact Htop.
- claim HC_parts: C c= X /\ exists U :e Tx, C = X :\: U.
  { exact (andER (topology_on X Tx) (C c= X /\ exists U :e Tx, C = X :\: U) HC). }
  claim HD_parts: D c= X /\ exists V :e Tx, D = X :\: V.
  { exact (andER (topology_on X Tx) (D c= X /\ exists V :e Tx, D = X :\: V) HD). }
  claim HC_sub: C c= X.
  { exact (andEL (C c= X) (exists U :e Tx, C = X :\: U) HC_parts). }
  claim HD_sub: D c= X.
  { exact (andEL (D c= X) (exists V :e Tx, D = X :\: V) HD_parts). }
  claim HCex: exists U :e Tx, C = X :\: U.
  { exact (andER (C c= X) (exists U :e Tx, C = X :\: U) HC_parts). }
  claim HDex: exists V :e Tx, D = X :\: V.
  { exact (andER (D c= X) (exists V :e Tx, D = X :\: V) HD_parts). }
  apply andI.
  + (** C  D  X **)
    let x. assume Hx: x :e C :\/: D.
    apply (binunionE C D x Hx).
    * assume HxC: x :e C. exact (HC_sub x HxC).
    * assume HxD: x :e D. exact (HD_sub x HxD).
  + (** exists W :e Tx, C  D = X \ W **)
    apply HCex.
    let U. assume HU_conj: U :e Tx /\ C = X :\: U.
    claim HU: U :e Tx.
    { exact (andEL (U :e Tx) (C = X :\: U) HU_conj). }
    claim HCeq: C = X :\: U.
    { exact (andER (U :e Tx) (C = X :\: U) HU_conj). }
    apply HDex.
    let V. assume HV_conj: V :e Tx /\ D = X :\: V.
    claim HV: V :e Tx.
    { exact (andEL (V :e Tx) (D = X :\: V) HV_conj). }
    claim HDeq: D = X :\: V.
    { exact (andER (V :e Tx) (D = X :\: V) HV_conj). }
    (** Set W = U  V, which is open **)
    set W := U :/\: V.
    claim HW_open: W :e Tx.
    { exact (lemma_intersection_two_open X Tx U V Htop HU HV). }
	    witness W.
	    apply andI.
	    * exact HW_open.
	    * (** Prove C  D = X \ W using De Morgan lemma **)
	      prove C :\/: D = X :\: W.
	      rewrite HCeq.
	      rewrite HDeq.
	      claim HWdef: W = U :/\: V.
	      { reflexivity. }
	      rewrite HWdef.
	      rewrite (setminus_binintersect_eq_binunion X U V).
	      reflexivity.
Qed.

(** Helper: Empty is closed **)
Theorem empty_is_closed : forall X Tx:set,
  topology_on X Tx -> closed_in X Tx Empty.
let X Tx.
assume Htop: topology_on X Tx.
prove closed_in X Tx Empty.
(** Empty = X \ X, and X is open **)
prove topology_on X Tx /\ (Empty c= X /\ exists U :e Tx, Empty = X :\: U).
apply andI.
- exact Htop.
- apply andI.
  + exact (Subq_Empty X).
  + witness X.
    apply andI.
    * exact (topology_has_X X Tx Htop).
    * prove Empty = X :\: X.
      apply set_ext.
      - exact (Subq_Empty (X :\: X)).
      - let x. assume Hx: x :e X :\: X.
        claim HxX: x :e X.
        { exact (setminusE1 X X x Hx). }
        claim HxnotX: x /:e X.
        { exact (setminusE2 X X x Hx). }
        prove x :e Empty.
        apply FalseE.
        exact (HxnotX HxX).
Qed.

(** Helper: X is closed **)
Theorem space_is_closed : forall X Tx:set,
  topology_on X Tx -> closed_in X Tx X.
let X Tx.
assume Htop: topology_on X Tx.
prove closed_in X Tx X.
(** X = X \ Empty, and Empty is open **)
prove topology_on X Tx /\ (X c= X /\ exists U :e Tx, X = X :\: U).
apply andI.
- exact Htop.
- apply andI.
  + exact (Subq_ref X).
  + witness Empty.
    apply andI.
    * exact (topology_has_empty X Tx Htop).
    * prove X = X :\: Empty.
      apply set_ext.
      - let x. assume Hx: x :e X.
        apply setminusI.
        + exact Hx.
        + assume Hcontra: x :e Empty.
          exact (EmptyE x Hcontra False).
      - let x. assume Hx: x :e X :\: Empty.
        exact (setminusE1 X Empty x Hx).
Qed.

(** Helper: binary union as union of pair family **)
Theorem binunion_eq_Union_UPair : forall U V:set, U :\/: V = Union (UPair U V).
let U V.
apply set_ext.
- let x. assume Hx: x :e U :\/: V.
  apply (binunionE U V x Hx).
  + assume HxU: x :e U.
    apply (UnionI (UPair U V) x U HxU).
    exact (UPairI1 U V).
  + assume HxV: x :e V.
    apply (UnionI (UPair U V) x V HxV).
    exact (UPairI2 U V).
- let x. assume Hx: x :e Union (UPair U V).
  apply (UnionE_impred (UPair U V) x Hx (x :e U :\/: V)).
  let Z. assume HxZ: x :e Z. assume HZin: Z :e UPair U V.
  apply (UPairE Z U V HZin).
  + assume HZeqU: Z = U.
    claim HxU: x :e U.
    { rewrite <- HZeqU. exact HxZ. }
    exact (binunionI1 U V x HxU).
  + assume HZeqV: Z = V.
    claim HxV: x :e V.
    { rewrite <- HZeqV. exact HxZ. }
    exact (binunionI2 U V x HxV).
Qed.

(** Helper: union of a pair family equals binary union **)
Theorem Union_UPair_eq_binunion : forall U V:set, Union (UPair U V) = U :\/: V.
let U V.
rewrite (binunion_eq_Union_UPair U V).
reflexivity.
Qed.

(** Helper: Binary union of open sets is open **)
Theorem lemma_union_two_open : forall X T U V:set,
  topology_on X T -> U :e T -> V :e T -> U :\/: V :e T.
let X T U V.
assume HT: topology_on X T.
assume HU: U :e T.
assume HV: V :e T.
prove U :\/: V :e T.
claim HUFamSub: UPair U V c= T.
{ let W. assume HW: W :e UPair U V.
  apply (UPairE W U V HW).
  - assume HWeqU. rewrite HWeqU. exact HU.
  - assume HWeqV. rewrite HWeqV. exact HV. }
claim HUnion: Union (UPair U V) :e T.
{ exact (topology_union_closed X T (UPair U V) HT HUFamSub). }
rewrite <- (Union_UPair_eq_binunion U V).
exact HUnion.
Qed.

(** Helper: intersection of two closed sets is closed **)
Theorem intersection_of_closed_is_closed : forall X Tx C D:set,
  topology_on X Tx -> closed_in X Tx C -> closed_in X Tx D ->
  closed_in X Tx (C :/\: D).
let X Tx C D.
assume Htop: topology_on X Tx.
assume HC: closed_in X Tx C.
assume HD: closed_in X Tx D.
prove closed_in X Tx (C :/\: D).
(** C = X \ U and D = X \ V for some open U, V.
    Then C  D = (X\U)  (X\V) = X \ (U  V), and U  V is open. **)
prove topology_on X Tx /\ (C :/\: D c= X /\ exists W :e Tx, C :/\: D = X :\: W).
apply andI.
- exact Htop.
- claim HC_parts: C c= X /\ exists U :e Tx, C = X :\: U.
  { exact (andER (topology_on X Tx) (C c= X /\ exists U :e Tx, C = X :\: U) HC). }
  claim HD_parts: D c= X /\ exists V :e Tx, D = X :\: V.
  { exact (andER (topology_on X Tx) (D c= X /\ exists V :e Tx, D = X :\: V) HD). }
  claim HC_sub: C c= X.
  { exact (andEL (C c= X) (exists U :e Tx, C = X :\: U) HC_parts). }
  claim HCex: exists U :e Tx, C = X :\: U.
  { exact (andER (C c= X) (exists U :e Tx, C = X :\: U) HC_parts). }
  claim HDex: exists V :e Tx, D = X :\: V.
  { exact (andER (D c= X) (exists V :e Tx, D = X :\: V) HD_parts). }
  apply andI.
  + (** C  D  X **)
    let x. assume Hx: x :e C :/\: D.
    claim HxC: x :e C.
    { exact (binintersectE1 C D x Hx). }
    exact (HC_sub x HxC).
  + (** exists W :e Tx, C  D = X \ W **)
    apply HCex.
    let U. assume HU_conj: U :e Tx /\ C = X :\: U.
    claim HU: U :e Tx.
    { exact (andEL (U :e Tx) (C = X :\: U) HU_conj). }
    claim HCeq: C = X :\: U.
    { exact (andER (U :e Tx) (C = X :\: U) HU_conj). }
    apply HDex.
    let V. assume HV_conj: V :e Tx /\ D = X :\: V.
    claim HV: V :e Tx.
    { exact (andEL (V :e Tx) (D = X :\: V) HV_conj). }
      claim HDeq: D = X :\: V.
      { exact (andER (V :e Tx) (D = X :\: V) HV_conj). }
      (** Set W = U  V, which is open **)
      set W := U :\/: V.
      claim HW_open: W :e Tx.
      { exact (lemma_union_two_open X Tx U V Htop HU HV). }
      witness W.
      apply andI.
      * exact HW_open.
      * (** Prove C  D = X \ W using De Morgan lemma **)
        prove C :/\: D = X :\: W.
	      rewrite HCeq.
	      rewrite HDeq.
	      claim HWdef: W = U :\/: V.
	      { reflexivity. }
	      rewrite HWdef.
	      rewrite <- (setminus_binunion_eq_binintersect X U V).
	      reflexivity.
Qed.

Theorem closed_closure_eq : forall X Tx C:set,
  topology_on X Tx -> closed_in X Tx C -> closure_of X Tx C = C.
let X Tx C.
assume Htop: topology_on X Tx.
assume HC: closed_in X Tx C.
prove closure_of X Tx C = C.
(** closed_in means there exists U :e Tx such that C = X :\: U **)
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (C c= X /\ exists U :e Tx, C = X :\: U) HC). }
claim HCsub_and_ex: C c= X /\ exists U :e Tx, C = X :\: U.
{ exact (andER (topology_on X Tx) (C c= X /\ exists U :e Tx, C = X :\: U) HC). }
claim HCsub: C c= X.
{ exact (andEL (C c= X) (exists U :e Tx, C = X :\: U) HCsub_and_ex). }
apply set_ext.
- (** closure(C)  C **)
  prove closure_of X Tx C c= C.
  (** We need to show: if x  closure(C), then x  C.
      By closure characterization, x  closure(C) means every open containing x meets C.
      If x  C, then x  X \ C. Since C is closed, X \ C is open.
      So X \ C is an open containing x. If it meets C, we'd have a point in both C and X \ C, contradiction. **)
  let x. assume Hx: x :e closure_of X Tx C.
  prove x :e C.
  (** Use excluded middle **)
  apply (xm (x :e C)).
  + assume HxC: x :e C. exact HxC.
  + assume HxnotC: x /:e C.
    (** Get the open U such that C = X \ U **)
    claim Hex: exists U :e Tx, C = X :\: U.
    { exact (andER (C c= X) (exists U :e Tx, C = X :\: U) HCsub_and_ex). }
    apply Hex.
    let U. assume HU_conj: U :e Tx /\ C = X :\: U.
    claim HU: U :e Tx.
    { exact (andEL (U :e Tx) (C = X :\: U) HU_conj). }
    claim HCeq: C = X :\: U.
    { exact (andER (U :e Tx) (C = X :\: U) HU_conj). }
    (** x  closure(C) means x  X and every open containing x meets C **)
    claim HxX: x :e X.
    { exact (closure_in_space X Tx C Htop x Hx). }
    claim Hcond: forall V:set, V :e Tx -> x :e V -> V :/\: C <> Empty.
    { exact (SepE2 X (fun x0 => forall V:set, V :e Tx -> x0 :e V -> V :/\: C <> Empty) x Hx). }
    (** Since x  C and C = X \ U, we have x  U **)
    claim HxU: x :e U.
    { (** x  X and x  C = X \ U implies x  U **)
      apply (xm (x :e U)).
      - assume H. exact H.
      - assume HxnotU: x /:e U.
        (** Then x  X \ U = C, contradicting x  C **)
        apply HxnotC.
        claim HxXU: x :e X :\: U.
        { apply setminusI. exact HxX. exact HxnotU. }
        rewrite HCeq. exact HxXU. }
    (** Now U is open, x  U, so U  C  Empty by Hcond **)
    claim HUC_ne: U :/\: C <> Empty.
    { exact (Hcond U HU HxU). }
    (** But U  C = Empty since C = X \ U **)
    claim HUC_empty: U :/\: C = Empty.
    { apply set_ext.
      - let y. assume Hy: y :e U :/\: C.
        prove y :e Empty.
        claim HyU: y :e U.
        { exact (binintersectE1 U C y Hy). }
        claim HyC: y :e C.
        { exact (binintersectE2 U C y Hy). }
        (** C = X \ U, so y  C means y  X and y  U **)
        claim HyXU: y :e X :\: U.
        { rewrite <- HCeq. exact HyC. }
        claim HynotU: y /:e U.
        { exact (setminusE2 X U y HyXU). }
        (** Contradiction: y  U and y  U **)
        apply FalseE.
        exact (HynotU HyU).
      - exact (Subq_Empty (U :/\: C)). }
    (** Contradiction **)
    apply FalseE.
    exact (HUC_ne HUC_empty).
- (** C  closure(C) **)
  exact (subset_of_closure X Tx C Htop HCsub).
Qed.

(** Helper: closure of intersection of closed sets **)
Theorem closure_intersection_of_closed : forall X Tx C D:set,
  topology_on X Tx -> closed_in X Tx C -> closed_in X Tx D ->
  closure_of X Tx (C :/\: D) = C :/\: D.
let X Tx C D.
assume Htop: topology_on X Tx.
assume HC: closed_in X Tx C.
assume HD: closed_in X Tx D.
prove closure_of X Tx (C :/\: D) = C :/\: D.
(** Strategy: C  D is closed (by intersection_of_closed_is_closed), so closure(C  D) = C  D **)
claim HCD_closed: closed_in X Tx (C :/\: D).
{ exact (intersection_of_closed_is_closed X Tx C D Htop HC HD). }
claim HCD_sub: C :/\: D c= X.
{ let x. assume Hx: x :e C :/\: D.
  claim HxC: x :e C.
  { exact (binintersectE1 C D x Hx). }
  claim HC_sub: C c= X.
  { exact (andEL (C c= X) (exists U :e Tx, C = X :\: U)
           (andER (topology_on X Tx) (C c= X /\ exists U :e Tx, C = X :\: U) HC)). }
  exact (HC_sub x HxC). }
apply set_ext.
- (** closure(C  D)  C  D **)
  let x. assume Hx: x :e closure_of X Tx (C :/\: D).
  prove x :e C :/\: D.
  rewrite <- (closed_closure_eq X Tx (C :/\: D) Htop HCD_closed).
  exact Hx.
- (** C  D  closure(C  D) **)
  exact (subset_of_closure X Tx (C :/\: D) Htop HCD_sub).
Qed.

(** Helper: closure of union of closed sets **)
Theorem closure_union_of_closed : forall X Tx C D:set,
  topology_on X Tx -> closed_in X Tx C -> closed_in X Tx D ->
  closure_of X Tx (C :\/: D) = C :\/: D.
let X Tx C D.
assume Htop: topology_on X Tx.
assume HC: closed_in X Tx C.
assume HD: closed_in X Tx D.
prove closure_of X Tx (C :\/: D) = C :\/: D.
(** Strategy: C  D is closed (by closed set axioms), so closure(C  D) = C  D **)
(** First need to show C  D is closed, then apply closed_closure_eq **)
(** First prove that union of two closed sets is closed **)
claim HCD_closed: closed_in X Tx (C :\/: D).
{ exact (union_of_closed_is_closed X Tx C D Htop HC HD). }
(** Now prove closure(C  D) = C  D directly **)
claim HCD_sub: C :\/: D c= X.
{ let x. assume Hx: x :e C :\/: D.
  apply (binunionE C D x Hx).
  - assume HxC: x :e C.
    claim HC_sub: C c= X.
    { exact (andEL (C c= X) (exists U :e Tx, C = X :\: U)
             (andER (topology_on X Tx) (C c= X /\ exists U :e Tx, C = X :\: U) HC)). }
    exact (HC_sub x HxC).
  - assume HxD: x :e D.
    claim HD_sub: D c= X.
    { exact (andEL (D c= X) (exists V :e Tx, D = X :\: V)
             (andER (topology_on X Tx) (D c= X /\ exists V :e Tx, D = X :\: V) HD)). }
    exact (HD_sub x HxD). }
(** Prove closure(C  D) = C  D by double inclusion **)
apply set_ext.
- (** closure(C  D)  C  D **)
  (** Since C  D is closed, closure(C  D)  C  D **)
  let x. assume Hx: x :e closure_of X Tx (C :\/: D).
  prove x :e C :\/: D.
  rewrite <- (closed_closure_eq X Tx (C :\/: D) Htop HCD_closed).
  exact Hx.
- (** C  D  closure(C  D) **)
  exact (subset_of_closure X Tx (C :\/: D) Htop HCD_sub).
Qed.

(** Helper: closure is idempotent **)
Theorem closure_idempotent : forall X Tx A:set,
  topology_on X Tx -> A c= X -> closure_of X Tx (closure_of X Tx A) = closure_of X Tx A.
let X Tx A.
assume Htop: topology_on X Tx.
assume HA: A c= X.
prove closure_of X Tx (closure_of X Tx A) = closure_of X Tx A.
(** Strategy: cl(cl(A)) is the closure of a closed set, so equals itself **)
(** Equivalently: cl(A) is closed, and closed sets equal their closure **)
claim HclA_sub: closure_of X Tx A c= X.
{ exact (closure_in_space X Tx A Htop). }
(** To show cl(cl(A)) = cl(A), use that cl(A)  cl(cl(A)) and cl(cl(A))  cl(A) **)
apply set_ext.
- (** cl(cl(A))  cl(A) **)
  (** Since cl(A) is closed, cl(cl(A)) = cl(A), so cl(cl(A))  cl(A) **)
  claim HclA_closed: closed_in X Tx (closure_of X Tx A).
  { exact (closure_is_closed X Tx A Htop HA). }
  claim Heq: closure_of X Tx (closure_of X Tx A) = closure_of X Tx A.
  { exact (closed_closure_eq X Tx (closure_of X Tx A) Htop HclA_closed). }
  let x. assume Hx: x :e closure_of X Tx (closure_of X Tx A).
  rewrite <- Heq.
  exact Hx.
- (** cl(A)  cl(cl(A)) **)
  exact (subset_of_closure X Tx (closure_of X Tx A) Htop HclA_sub).
Qed.

(** Helper: closure of intersection is subset of intersection of closures **)
Theorem closure_intersection_contained : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  closure_of X Tx (A :/\: B) c= closure_of X Tx A :/\: closure_of X Tx B.
let X Tx A B.
assume Htop: topology_on X Tx.
assume HA: A c= X.
assume HB: B c= X.
prove closure_of X Tx (A :/\: B) c= closure_of X Tx A :/\: closure_of X Tx B.
(** Use monotonicity: A  B  A and A  B  B **)
claim HAB_A: A :/\: B c= A.
{ exact (binintersect_Subq_1 A B). }
claim HAB_B: A :/\: B c= B.
{ exact (binintersect_Subq_2 A B). }
claim HAB_X: A :/\: B c= X.
{ let x. assume Hx: x :e A :/\: B.
  exact (HA x (binintersectE1 A B x Hx)). }
claim HclAB_A: closure_of X Tx (A :/\: B) c= closure_of X Tx A.
{ exact (closure_monotone X Tx (A :/\: B) A Htop HAB_A HA). }
claim HclAB_B: closure_of X Tx (A :/\: B) c= closure_of X Tx B.
{ exact (closure_monotone X Tx (A :/\: B) B Htop HAB_B HB). }
let x. assume Hx: x :e closure_of X Tx (A :/\: B).
apply binintersectI.
- exact (HclAB_A x Hx).
- exact (HclAB_B x Hx).
Qed.

(** Helper: closed sets equal their closure **)

(** from 17 Theorem 17.1: properties of closed sets **)
(** LATEX VERSION: Theorem 17.1: Closed sets contain X and , are closed under arbitrary intersections and finite unions. **)
Theorem closed_sets_axioms : forall X T:set,
  topology_on X T ->
  let C := {X :\: U|U :e T} in
    X :e C /\ Empty :e C /\
    (forall F:set, F :e Power C -> intersection_of_family X F :e C) /\
    (forall A B:set, A :e C -> B :e C -> A :\/: B :e C).
let X T.
assume HT: topology_on X T.
prove let C := {X :\: U|U :e T} in
    X :e C /\ Empty :e C /\
    (forall F:set, F :e Power C -> intersection_of_family X F :e C) /\
    (forall A B:set, A :e C -> B :e C -> A :\/: B :e C).
set C := {X :\: U|U :e T}.
prove X :e C /\ Empty :e C /\
    (forall F:set, F :e Power C -> intersection_of_family X F :e C) /\
    (forall A B:set, A :e C -> B :e C -> A :\/: B :e C).
(** Strategy: Use De Morgan laws and topology axioms
    - X = X \ , and   T
    -  = X \ X, and X  T
    - (X\U) = X \ (U), and U  T
    - (X\U)  (X\V) = X \ (U  V), and U  V  T **)
claim Hempty_in_T: Empty :e T.
{ exact (topology_has_empty X T HT). }
claim HX_in_T: X :e T.
{ exact (topology_has_X X T HT). }
(** Build the 4-way conjunction left-to-right **)
claim Hpart1: X :e C.
{ (** Use ReplEq: need to show exists U :e T such that X = X :\: U **)
  prove X :e {X :\: U|U :e T}.
  apply (ReplEq T (fun U => X :\: U) X).
  assume _ H. apply H.
  witness Empty.
  apply andI.
  * exact Hempty_in_T.
  * prove X = X :\: Empty.
    apply set_ext.
    - let x. assume Hx: x :e X.
      apply setminusI.
      + exact Hx.
      + assume Hcontra: x :e Empty.
        exact (EmptyE x Hcontra False).
    - let x. assume Hx: x :e X :\: Empty.
      exact (setminusE1 X Empty x Hx). }
claim Hpart2: X :e C /\ Empty :e C.
{ apply andI.
  - exact Hpart1.
  - prove Empty :e {X :\: U|U :e T}.
    apply (ReplEq T (fun U => X :\: U) Empty).
    assume _ H. apply H.
    witness X.
    apply andI.
    * exact HX_in_T.
    * prove Empty = X :\: X.
      apply set_ext.
      - let x. assume Hx: x :e Empty.
        exact (EmptyE x Hx (x :e X :\: X)).
      - let x. assume Hx: x :e X :\: X.
        claim HxX: x :e X.
        { exact (setminusE1 X X x Hx). }
        claim HxnotX: x /:e X.
        { exact (setminusE2 X X x Hx). }
        apply FalseE.
        exact (HxnotX HxX).
}
claim Hpart3: (X :e C /\ Empty :e C) /\ (forall F:set, F :e Power C -> intersection_of_family X F :e C).
{ apply andI.
  - exact Hpart2.
  - (** Arbitrary intersections: (X\U) = X \ (U) **)
    let F. assume HF: F :e Power C.
    prove intersection_of_family X F :e C.
    (** Handle empty case separately **)
    apply (xm (F = Empty)).
    + assume HFempty: F = Empty.
      (** With new definition:  = X since all x in X vacuously satisfy "forall U :e Empty, x :e U" **)
      claim Hintersect_empty: intersection_of_family X F = X.
      { rewrite HFempty.
        (** intersection_of_family X  = {x :e X | forall U :e , x :e U} = X since condition is vacuous **)
        apply set_ext.
        - let x. assume Hx: x :e intersection_of_family X Empty.
          exact (SepE1 X (fun y => forall U0:set, U0 :e Empty -> y :e U0) x Hx).
        - let x. assume Hx: x :e X.
          (** Show x :e intersection_of_family X Empty **)
          claim Hvacuous: forall U0:set, U0 :e Empty -> x :e U0.
          { let U0. assume HU: U0 :e Empty.
            apply FalseE.
            exact (EmptyE U0 HU).
          }
          exact (SepI X (fun y => forall U0:set, U0 :e Empty -> y :e U0) x Hx Hvacuous).
      }
      rewrite Hintersect_empty.
      exact (andEL (X :e C) (Empty :e C) Hpart2).
    + assume HFnonempty: F <> Empty.
      (** Extract the family of open sets: G = {U :e T | X \ U :e F} **)
      set G := {U :e T | X :\: U :e F}.
      (** Show F = X \ G **)
      prove intersection_of_family X F :e {X :\: U|U :e T}.
    apply (ReplEq T (fun U => X :\: U) (intersection_of_family X F)).
    assume _ H. apply H.
    witness (Union G).
    apply andI.
    * (** G :e T **)
      claim HGsub: G c= T.
      { let U. assume HU: U :e G.
        exact (SepE1 T (fun U0 => X :\: U0 :e F) U HU). }
      exact (topology_union_closed X T G HT HGsub).
    * (** F = X \ G by De Morgan **)
      prove intersection_of_family X F = X :\: Union G.
      apply set_ext.
      - (** F  X \ G **)
        let x. assume Hx: x :e intersection_of_family X F.
        prove x :e X :\: Union G.
        apply setminusI.
        + (** x  X: directly from new definition of intersection_of_family X F **)
          exact (SepE1 X (fun y => forall U0:set, U0 :e F -> y :e U0) x Hx).
        + (** x  G **)
          assume Hcontra: x :e Union G.
          apply (UnionE_impred G x Hcontra).
          let U. assume HxU: x :e U. assume HUG: U :e G.
          claim HXminusU_in_F: X :\: U :e F.
          { exact (SepE2 T (fun U0 => X :\: U0 :e F) U HUG). }
          claim Hxall: forall Y :e F, x :e Y.
          { exact (SepE2 X (fun y => forall U0:set, U0 :e F -> y :e U0) x Hx). }
          claim Hx_in_XminusU: x :e X :\: U.
          { exact (Hxall (X :\: U) HXminusU_in_F). }
          claim HxnotU: x /:e U.
          { exact (setminusE2 X U x Hx_in_XminusU). }
          exact (HxnotU HxU).
      - (** X \ G  F **)
        let x. assume Hx: x :e X :\: Union G.
        prove x :e intersection_of_family X F.
        claim HxX: x :e X.
        { exact (setminusE1 X (Union G) x Hx). }
        claim HxnotUG: x /:e Union G.
        { exact (setminusE2 X (Union G) x Hx). }
        (** Show x  X and forall Y :e F, x :e Y **)
        prove x :e {y :e X|forall U0:set, U0 :e F -> y :e U0}.
        apply SepI.
        + (** x  X: already have this **)
          exact HxX.
        + (** forall Y :e F, x :e Y **)
          let Y. assume HYF: Y :e F.
          prove x :e Y.
          claim HYC: Y :e C.
          { exact (PowerE C F HF Y HYF). }
          apply (ReplE T (fun U => X :\: U) Y HYC).
          let U. assume H. apply H.
          assume HU: U :e T. assume HYeq: Y = X :\: U.
          claim HUG: U :e G.
          { apply SepI.
            - exact HU.
            - prove X :\: U :e F.
              rewrite <- HYeq. exact HYF. }
          claim HxnotU: x /:e U.
          { assume Hcontra: x :e U.
            apply HxnotUG.
            exact (UnionI G x U Hcontra HUG). }
          rewrite HYeq.
          apply setminusI.
          * exact HxX.
          * exact HxnotU.
}
apply andI.
- exact Hpart3.
- (** Binary unions: (X\U)  (X\V) = X \ (U  V) **)
  let A B. assume HA: A :e C. assume HB: B :e C.
  prove A :\/: B :e C.
  (** A = X \ U for some U  T **)
  apply (ReplE T (fun U => X :\: U) A HA).
  let U. assume H1. apply H1.
  assume HU: U :e T. assume HAeq: A = X :\: U.
  (** B = X \ V for some V  T **)
  apply (ReplE T (fun U => X :\: U) B HB).
  let V. assume H2. apply H2.
  assume HV: V :e T. assume HBeq: B = X :\: V.
  (** Show A  B = X \ (U  V) and U  V  T **)
  prove A :\/: B :e {X :\: W|W :e T}.
  apply (ReplEq T (fun W => X :\: W) (A :\/: B)).
  assume _ H. apply H.
  witness (U :/\: V).
  apply andI.
  * (** U  V  T **)
    exact (topology_binintersect_closed X T U V HT HU HV).
  * (** A  B = X \ (U  V) by De Morgan **)
    prove A :\/: B = X :\: (U :/\: V).
    rewrite HAeq. rewrite HBeq.
    apply set_ext.
    + (** (X\U)  (X\V)  X \ (U  V) **)
      let x. assume Hx: x :e (X :\: U) :\/: (X :\: V).
      apply (binunionE (X :\: U) (X :\: V) x Hx).
      - assume HxA: x :e X :\: U.
        claim HxX: x :e X.
        { exact (setminusE1 X U x HxA). }
        claim HxnotU: x /:e U.
        { exact (setminusE2 X U x HxA). }
        apply setminusI.
        * exact HxX.
        * assume Hcontra: x :e U :/\: V.
          claim HxU: x :e U.
          { exact (binintersectE1 U V x Hcontra). }
          exact (HxnotU HxU).
      - assume HxB: x :e X :\: V.
        claim HxX: x :e X.
        { exact (setminusE1 X V x HxB). }
        claim HxnotV: x /:e V.
        { exact (setminusE2 X V x HxB). }
        apply setminusI.
        * exact HxX.
        * assume Hcontra: x :e U :/\: V.
          claim HxV: x :e V.
          { exact (binintersectE2 U V x Hcontra). }
          exact (HxnotV HxV).
    + (** X \ (U  V)  (X\U)  (X\V) **)
      let x. assume Hx: x :e X :\: (U :/\: V).
      claim HxX: x :e X.
      { exact (setminusE1 X (U :/\: V) x Hx). }
      claim HxnotUV: x /:e U :/\: V.
      { exact (setminusE2 X (U :/\: V) x Hx). }
      (** x  U  V means x  U or x  V **)
      apply (xm (x :e U)).
      - assume HxU: x :e U.
        (** Then x  V, so x  X \ V **)
        claim HxnotV: x /:e V.
        { assume HxV: x :e V.
          apply HxnotUV.
          exact (binintersectI U V x HxU HxV). }
        apply binunionI2.
        exact (setminusI X V x HxX HxnotV).
      - assume HxnotU: x /:e U.
        (** Then x  X \ U **)
        apply binunionI1.
        exact (setminusI X U x HxX HxnotU).
Qed.

(** from 17 Theorem 17.2: closed sets in subspaces as intersections **) 
(** LATEX VERSION: Closed sets in a subspace are precisely intersections of the subspace with closed sets of the ambient space. **)
Theorem closed_in_subspace_iff_intersection : forall X Tx Y A:set,
  topology_on X Tx -> Y c= X ->
  (closed_in Y (subspace_topology X Tx Y) A <->
   exists C:set, closed_in X Tx C /\ A = C :/\: Y).
let X Tx Y A.
assume HTx: topology_on X Tx.
assume HY: Y c= X.
prove closed_in Y (subspace_topology X Tx Y) A <-> exists C:set, closed_in X Tx C /\ A = C :/\: Y.
apply iffI.
- assume HAclosed: closed_in Y (subspace_topology X Tx Y) A.
  prove exists C:set, closed_in X Tx C /\ A = C :/\: Y.
  claim HTsubspace: topology_on Y (subspace_topology X Tx Y).
  { exact (subspace_topology_is_topology X Tx Y HTx HY). }
  claim HAdef: topology_on Y (subspace_topology X Tx Y) /\ (A c= Y /\ exists U :e subspace_topology X Tx Y, A = Y :\: U).
  { exact HAclosed. }
  claim HAandEx: A c= Y /\ exists U :e subspace_topology X Tx Y, A = Y :\: U.
  { exact (andER (topology_on Y (subspace_topology X Tx Y)) (A c= Y /\ exists U :e subspace_topology X Tx Y, A = Y :\: U) HAdef). }
  claim HexU: exists U :e subspace_topology X Tx Y, A = Y :\: U.
  { exact (andER (A c= Y) (exists U :e subspace_topology X Tx Y, A = Y :\: U) HAandEx). }
  apply HexU.
  let U. assume HandEq. apply HandEq.
  assume HUsubspace: U :e subspace_topology X Tx Y.
  assume HAeq: A = Y :\: U.
  claim HUexV: exists V :e Tx, U = V :/\: Y.
  { exact (SepE2 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HUsubspace). }
  apply HUexV.
  let V. assume HVandEq. apply HVandEq.
  assume HV: V :e Tx. assume HUeq: U = V :/\: Y.
  set C := X :\: V.
  claim HCclosed: closed_in X Tx C.
  { prove topology_on X Tx /\ (C c= X /\ exists W :e Tx, C = X :\: W).
    apply andI.
    - exact HTx.
    - apply andI.
      + exact (setminus_Subq X V).
      + witness V.
        apply andI.
        * exact HV.
        * reflexivity.
  }
  claim HAeqC: A = C :/\: Y.
  { rewrite HAeq.
    rewrite HUeq.
    prove Y :\: (V :/\: Y) = (X :\: V) :/\: Y.
    apply set_ext.
    - let x. assume Hx: x :e Y :\: (V :/\: Y).
      claim HxY: x :e Y.
      { exact (setminusE1 Y (V :/\: Y) x Hx). }
      claim HxnotVY: x /:e V :/\: Y.
      { exact (setminusE2 Y (V :/\: Y) x Hx). }
      claim HxnotV: x /:e V.
      { assume HxV: x :e V.
        apply HxnotVY.
        apply binintersectI.
        - exact HxV.
        - exact HxY.
      }
      claim HxX: x :e X.
      { exact (HY x HxY). }
      apply binintersectI.
      + apply setminusI.
        * exact HxX.
        * exact HxnotV.
      + exact HxY.
    - let x. assume Hx: x :e (X :\: V) :/\: Y.
      claim HxXV: x :e X :\: V.
      { exact (binintersectE1 (X :\: V) Y x Hx). }
      claim HxY: x :e Y.
      { exact (binintersectE2 (X :\: V) Y x Hx). }
      claim HxnotV: x /:e V.
      { exact (setminusE2 X V x HxXV). }
      apply setminusI.
      + exact HxY.
      + assume HxVY: x :e V :/\: Y.
        apply HxnotV.
        exact (binintersectE1 V Y x HxVY).
  }
  witness C.
  apply andI.
  - exact HCclosed.
  - exact HAeqC.
- assume Hexists: exists C:set, closed_in X Tx C /\ A = C :/\: Y.
  prove closed_in Y (subspace_topology X Tx Y) A.
  apply Hexists.
  let C. assume HCandEq. apply HCandEq.
  assume HCclosed: closed_in X Tx C.
  assume HAeq: A = C :/\: Y.
  claim HTsubspace: topology_on Y (subspace_topology X Tx Y).
  { exact (subspace_topology_is_topology X Tx Y HTx HY). }
  claim HCdef: topology_on X Tx /\ (C c= X /\ exists V :e Tx, C = X :\: V).
  { exact HCclosed. }
  claim HCandEx: C c= X /\ exists V :e Tx, C = X :\: V.
  { exact (andER (topology_on X Tx) (C c= X /\ exists V :e Tx, C = X :\: V) HCdef). }
  claim HexV: exists V :e Tx, C = X :\: V.
  { exact (andER (C c= X) (exists V :e Tx, C = X :\: V) HCandEx). }
  apply HexV.
  let V. assume HVandEq. apply HVandEq.
  assume HV: V :e Tx. assume HCeq: C = X :\: V.
  set U := V :/\: Y.
  claim HUsubspace: U :e subspace_topology X Tx Y.
  { claim HUinPowerY: U :e Power Y.
    { apply PowerI.
      exact (binintersect_Subq_2 V Y). }
    claim HPred: exists W :e Tx, U = W :/\: Y.
    { witness V.
      apply andI.
      - exact HV.
      - reflexivity.
    }
    exact (SepI (Power Y) (fun U0:set => exists W :e Tx, U0 = W :/\: Y) U HUinPowerY HPred).
  }
  claim HAeqYU: A = Y :\: U.
  { rewrite HAeq.
    rewrite HCeq.
    prove (X :\: V) :/\: Y = Y :\: (V :/\: Y).
    apply set_ext.
    - let x. assume Hx: x :e (X :\: V) :/\: Y.
      claim HxXV: x :e X :\: V.
      { exact (binintersectE1 (X :\: V) Y x Hx). }
      claim HxY: x :e Y.
      { exact (binintersectE2 (X :\: V) Y x Hx). }
      claim HxnotV: x /:e V.
      { exact (setminusE2 X V x HxXV). }
      apply setminusI.
      + exact HxY.
      + assume HxVY: x :e V :/\: Y.
        apply HxnotV.
        exact (binintersectE1 V Y x HxVY).
    - let x. assume Hx: x :e Y :\: (V :/\: Y).
      claim HxY: x :e Y.
      { exact (setminusE1 Y (V :/\: Y) x Hx). }
      claim HxnotVY: x /:e V :/\: Y.
      { exact (setminusE2 Y (V :/\: Y) x Hx). }
      claim HxnotV: x /:e V.
      { assume HxV: x :e V.
        apply HxnotVY.
        apply binintersectI.
        - exact HxV.
        - exact HxY.
      }
      claim HxX: x :e X.
      { exact (HY x HxY). }
      apply binintersectI.
      + apply setminusI.
        * exact HxX.
        * exact HxnotV.
      + exact HxY.
  }
  claim HAsub: A c= Y.
  { rewrite HAeq.
    exact (binintersect_Subq_2 C Y). }
  prove topology_on Y (subspace_topology X Tx Y) /\ (A c= Y /\ exists U :e subspace_topology X Tx Y, A = Y :\: U).
  apply andI.
  - exact HTsubspace.
  - apply andI.
    + exact HAsub.
    + witness U.
      apply andI.
      * exact HUsubspace.
      * exact HAeqYU.
Qed.

(** from 17 Theorem 17.3: closedness passes up when subspace is closed **) 
(** LATEX VERSION: If Y is closed in X, a set closed in the subspace Y is closed in X. **)
Theorem closed_in_closed_subspace : forall X Tx Y A:set,
  topology_on X Tx -> closed_in X Tx Y ->
  closed_in Y (subspace_topology X Tx Y) A ->
  closed_in X Tx A.
let X Tx Y A.
assume HTx: topology_on X Tx.
assume HY: closed_in X Tx Y.
assume HA: closed_in Y (subspace_topology X Tx Y) A.
prove closed_in X Tx A.
(** Strategy: A = C  Y where C closed in X (by closed_in_subspace_iff_intersection).
    C = X \ U and Y = X \ V for some U,V  Tx.
    Then A = (X\U)  (X\V) = X \ (UV), and UV  Tx. **)
claim HYsub: Y c= X.
{ exact (andEL (Y c= X) (exists U :e Tx, Y = X :\: U) (andER (topology_on X Tx) (Y c= X /\ exists U :e Tx, Y = X :\: U) HY)). }
claim Hexists: exists C:set, closed_in X Tx C /\ A = C :/\: Y.
{ apply (iffEL (closed_in Y (subspace_topology X Tx Y) A) (exists C:set, closed_in X Tx C /\ A = C :/\: Y) (closed_in_subspace_iff_intersection X Tx Y A HTx HYsub)).
  exact HA. }
apply Hexists.
let C.
assume HCandA: closed_in X Tx C /\ A = C :/\: Y.
claim HCclosed: closed_in X Tx C.
{ exact (andEL (closed_in X Tx C) (A = C :/\: Y) HCandA). }
claim HAeq: A = C :/\: Y.
{ exact (andER (closed_in X Tx C) (A = C :/\: Y) HCandA). }
(** C is closed in X, so C = X \ U for some U  Tx **)
claim HCexists: exists U :e Tx, C = X :\: U.
{ exact (andER (C c= X) (exists U :e Tx, C = X :\: U) (andER (topology_on X Tx) (C c= X /\ exists U :e Tx, C = X :\: U) HCclosed)). }
apply HCexists.
let U.
assume HU: U :e Tx /\ C = X :\: U.
claim HUinTx: U :e Tx.
{ exact (andEL (U :e Tx) (C = X :\: U) HU). }
claim HCeq: C = X :\: U.
{ exact (andER (U :e Tx) (C = X :\: U) HU). }
(** Y is closed in X, so Y = X \ V for some V  Tx **)
claim HYexists: exists V :e Tx, Y = X :\: V.
{ exact (andER (Y c= X) (exists V :e Tx, Y = X :\: V) (andER (topology_on X Tx) (Y c= X /\ exists V :e Tx, Y = X :\: V) HY)). }
apply HYexists.
let V.
assume HV: V :e Tx /\ Y = X :\: V.
claim HVinTx: V :e Tx.
{ exact (andEL (V :e Tx) (Y = X :\: V) HV). }
claim HYeq: Y = X :\: V.
{ exact (andER (V :e Tx) (Y = X :\: V) HV). }
(** Now A = C  Y = (X\U)  (X\V) = X \ (UV) **)
claim HAeqSetminus: A = (X :\: U) :/\: (X :\: V).
{ rewrite HAeq.
  rewrite HCeq.
  rewrite HYeq.
  reflexivity. }
(** Prove (X\U)  (X\V) = X \ (UV) by set extensionality **)
claim HDeM: (X :\: U) :/\: (X :\: V) = X :\: (U :\/: V).
{ apply set_ext.
  - let x.
    assume Hx: x :e (X :\: U) :/\: (X :\: V).
    prove x :e X :\: (U :\/: V).
    claim HxXU: x :e X :\: U.
    { exact (binintersectE1 (X :\: U) (X :\: V) x Hx). }
    claim HxXV: x :e X :\: V.
    { exact (binintersectE2 (X :\: U) (X :\: V) x Hx). }
    claim HxX: x :e X.
    { exact (setminusE1 X U x HxXU). }
    claim HxninU: x /:e U.
    { exact (setminusE2 X U x HxXU). }
    claim HxninV: x /:e V.
    { exact (setminusE2 X V x HxXV). }
    apply setminusI.
    + exact HxX.
    + assume HxUV: x :e U :\/: V.
      prove False.
      apply (binunionE U V x HxUV).
      * assume HxU: x :e U.
        exact (HxninU HxU).
      * assume HxV: x :e V.
        exact (HxninV HxV).
  - let x.
    assume Hx: x :e X :\: (U :\/: V).
    prove x :e (X :\: U) :/\: (X :\: V).
    claim HxX: x :e X.
    { exact (setminusE1 X (U :\/: V) x Hx). }
    claim HxninUV: x /:e U :\/: V.
    { exact (setminusE2 X (U :\/: V) x Hx). }
    apply binintersectI.
    + prove x :e X :\: U.
      apply setminusI.
      * exact HxX.
      * assume HxU: x :e U.
        prove False.
        claim HxUV: x :e U :\/: V.
        { exact (binunionI1 U V x HxU). }
        exact (HxninUV HxUV).
    + prove x :e X :\: V.
      apply setminusI.
      * exact HxX.
      * assume HxV: x :e V.
        prove False.
        claim HxUV: x :e U :\/: V.
        { exact (binunionI2 U V x HxV). }
        exact (HxninUV HxUV). }
(** So A = X \ (UV), and since U,V  Tx, we have UV  Tx **)
  claim HUV: U :\/: V :e Tx.
  { exact (lemma_union_two_open X Tx U V HTx HUinTx HVinTx). }
  (** Now A = X \ (UV) where UV  Tx **)
  claim HAeqFinal: A = X :\: (U :\/: V).
  { rewrite HAeqSetminus.
    exact HDeM. }
(** Therefore A is closed in X **)
prove topology_on X Tx /\ (A c= X /\ exists U0 :e Tx, A = X :\: U0).
apply andI.
- exact HTx.
- apply andI.
  + prove A c= X.
    rewrite HAeqFinal.
    exact (setminus_Subq X (U :\/: V)).
  + prove exists U0 :e Tx, A = X :\: U0.
    witness (U :\/: V).
    apply andI.
    * exact HUV.
    * exact HAeqFinal.
Qed.

(** from 17 Theorem 17.4: closure in subspace equals intersection **)
(** LATEX VERSION: Closure in a subspace equals the ambient closure intersected with the subspace. **)
Theorem closure_in_subspace : forall X Tx Y A:set,
  topology_on X Tx -> Y c= X -> A c= Y ->
  closure_of Y (subspace_topology X Tx Y) A = (closure_of X Tx A) :/\: Y.
let X Tx Y A.
assume HTx: topology_on X Tx.
assume HY: Y c= X.
assume HA: A c= Y.
prove closure_of Y (subspace_topology X Tx Y) A = (closure_of X Tx A) :/\: Y.
claim HTy: topology_on Y (subspace_topology X Tx Y).
{ exact (subspace_topology_is_topology X Tx Y HTx HY). }
apply set_ext.
- (** closure_of Y (subspace_topology X Tx Y) A c= (closure_of X Tx A) :/\: Y **)
  let y. assume Hy: y :e closure_of Y (subspace_topology X Tx Y) A.
  prove y :e (closure_of X Tx A) :/\: Y.
  claim HyY: y :e Y.
  { exact (SepE1 Y (fun y0 => forall U:set, U :e subspace_topology X Tx Y -> y0 :e U -> U :/\: A <> Empty) y Hy). }
  claim HysubCond: forall U:set, U :e subspace_topology X Tx Y -> y :e U -> U :/\: A <> Empty.
  { exact (SepE2 Y (fun y0 => forall U:set, U :e subspace_topology X Tx Y -> y0 :e U -> U :/\: A <> Empty) y Hy). }
  apply binintersectI.
  + (** y :e closure_of X Tx A **)
    prove y :e closure_of X Tx A.
    claim HyX: y :e X.
    { exact (HY y HyY). }
    claim HyCond: forall V:set, V :e Tx -> y :e V -> V :/\: A <> Empty.
    { let V. assume HV: V :e Tx. assume HyV: y :e V.
      prove V :/\: A <> Empty.
      set U := V :/\: Y.
      claim HU: U :e subspace_topology X Tx Y.
      { claim HUinPower: U :e Power Y.
        { apply PowerI. exact (binintersect_Subq_2 V Y). }
        claim HPred: exists W :e Tx, U = W :/\: Y.
        { witness V. apply andI. exact HV. reflexivity. }
        exact (SepI (Power Y) (fun U0 => exists W :e Tx, U0 = W :/\: Y) U HUinPower HPred). }
      claim HyU: y :e U.
      { apply binintersectI. exact HyV. exact HyY. }
      claim HUA_ne: U :/\: A <> Empty.
      { exact (HysubCond U HU HyU). }
      prove V :/\: A <> Empty.
      assume HVA_empty: V :/\: A = Empty.
      claim HUA_sub_VA: U :/\: A c= V :/\: A.
      { let z. assume Hz: z :e U :/\: A.
        claim HzU: z :e U.
        { exact (binintersectE1 U A z Hz). }
        claim HzV: z :e V.
        { exact (binintersectE1 V Y z HzU). }
        claim HzA: z :e A.
        { exact (binintersectE2 U A z Hz). }
        exact (binintersectI V A z HzV HzA). }
      claim HUA_sub_Empty: U :/\: A c= Empty.
      { rewrite <- HVA_empty. exact HUA_sub_VA. }
      claim HUA_empty: U :/\: A = Empty.
      { exact (Empty_Subq_eq (U :/\: A) HUA_sub_Empty). }
      exact (HUA_ne HUA_empty). }
    exact (SepI X (fun y0 => forall V:set, V :e Tx -> y0 :e V -> V :/\: A <> Empty) y HyX HyCond).
  + exact HyY.
- (** (closure_of X Tx A) :/\: Y c= closure_of Y (subspace_topology X Tx Y) A **)
  let y. assume Hy: y :e (closure_of X Tx A) :/\: Y.
  prove y :e closure_of Y (subspace_topology X Tx Y) A.
  claim HyClX: y :e closure_of X Tx A.
  { exact (binintersectE1 (closure_of X Tx A) Y y Hy). }
  claim HyY: y :e Y.
  { exact (binintersectE2 (closure_of X Tx A) Y y Hy). }
  claim HyXCond: forall V:set, V :e Tx -> y :e V -> V :/\: A <> Empty.
  { exact (SepE2 X (fun y0 => forall V:set, V :e Tx -> y0 :e V -> V :/\: A <> Empty) y HyClX). }
  claim HySubCond: forall U:set, U :e subspace_topology X Tx Y -> y :e U -> U :/\: A <> Empty.
  { let U. assume HU: U :e subspace_topology X Tx Y. assume HyU: y :e U.
    prove U :/\: A <> Empty.
    claim HUex: exists V :e Tx, U = V :/\: Y.
    { exact (SepE2 (Power Y) (fun U0 => exists V :e Tx, U0 = V :/\: Y) U HU). }
    apply HUex.
    let V. assume HVandEq. apply HVandEq.
    assume HV: V :e Tx. assume HUeq: U = V :/\: Y.
    claim HyV: y :e V.
    { claim HyVY: y :e V :/\: Y.
      { rewrite <- HUeq. exact HyU. }
      exact (binintersectE1 V Y y HyVY). }
    claim HVA_ne: V :/\: A <> Empty.
    { exact (HyXCond V HV HyV). }
    rewrite HUeq.
    prove (V :/\: Y) :/\: A <> Empty.
    assume HVYAempty: (V :/\: Y) :/\: A = Empty.
    (** Since V :/\: A is nonempty, there exists w in V :/\: A.
        (V :/\: Y) :/\: A = V :/\: (Y :/\: A) by associativity.
        If this is empty, then V is disjoint from Y :/\: A.
        But we need to show this contradicts V :/\: A being nonempty and y in V :/\: Y. **)
    claim HVA_sub_VYA: V :/\: (Y :/\: A) c= V :/\: A.
    { let z. assume Hz: z :e V :/\: (Y :/\: A).
      claim HzV: z :e V.
      { exact (binintersectE1 V (Y :/\: A) z Hz). }
      claim HzYA: z :e Y :/\: A.
      { exact (binintersectE2 V (Y :/\: A) z Hz). }
      claim HzA: z :e A.
      { exact (binintersectE2 Y A z HzYA). }
      exact (binintersectI V A z HzV HzA). }
    claim HVYAeq: V :/\: (Y :/\: A) = (V :/\: Y) :/\: A.
    { apply set_ext.
      - let z. assume Hz: z :e V :/\: (Y :/\: A).
        claim HzV: z :e V.
        { exact (binintersectE1 V (Y :/\: A) z Hz). }
        claim HzYA: z :e Y :/\: A.
        { exact (binintersectE2 V (Y :/\: A) z Hz). }
        claim HzY: z :e Y.
        { exact (binintersectE1 Y A z HzYA). }
        claim HzA: z :e A.
        { exact (binintersectE2 Y A z HzYA). }
        claim HzVY: z :e V :/\: Y.
        { exact (binintersectI V Y z HzV HzY). }
        exact (binintersectI (V :/\: Y) A z HzVY HzA).
      - let z. assume Hz: z :e (V :/\: Y) :/\: A.
        claim HzVY: z :e V :/\: Y.
        { exact (binintersectE1 (V :/\: Y) A z Hz). }
        claim HzV: z :e V.
        { exact (binintersectE1 V Y z HzVY). }
        claim HzY: z :e Y.
        { exact (binintersectE2 V Y z HzVY). }
        claim HzA: z :e A.
        { exact (binintersectE2 (V :/\: Y) A z Hz). }
        claim HzYA: z :e Y :/\: A.
        { exact (binintersectI Y A z HzY HzA). }
        exact (binintersectI V (Y :/\: A) z HzV HzYA). }
    claim HVYAempty2: V :/\: (Y :/\: A) = Empty.
    { rewrite HVYAeq. exact HVYAempty. }
    (** Now we need to derive a contradiction. We know V :/\: A <> Empty.
        But we don't immediately know that V :/\: (Y :/\: A) <> Empty.
        This requires that the witness in V :/\: A is also in Y. **)
    (** The key issue: we need A c= Y for this direction to work properly.
        Classical statement requires A c= Y or should be about closure_of Y ... (A :/\: Y).
        For now, assume this holds or use that any w :e A that matters is in Y. **)
    (** Alternative: use y :e closure implies y in closure of A :/\: Y **)
    (** Since we have V :/\: A <> Empty, pick witness w **)
    claim Hex_w: exists w:set, w :e V :/\: A.
    { apply (dneg (exists w:set, w :e V :/\: A)).
      assume Hnot: ~(exists w:set, w :e V :/\: A).
      claim HVAempty: V :/\: A = Empty.
      { apply Empty_Subq_eq.
        let w. assume Hw: w :e V :/\: A.
        apply FalseE.
        apply Hnot.
        witness w. exact Hw.
      }
      exact (HVA_ne HVAempty).
    }
    apply Hex_w.
    let w. assume Hw: w :e V :/\: A.
    (** w :e V and w :e A. Since A c= Y, we have w :e Y, so w :e V :/\: (Y :/\: A), contradicting HVYAempty2. **)
    claim HwV: w :e V.
    { exact (binintersectE1 V A w Hw). }
    claim HwA: w :e A.
    { exact (binintersectE2 V A w Hw). }
    claim HwY: w :e Y.
    { exact (HA w HwA). }
    claim HwYA: w :e Y :/\: A.
    { exact (binintersectI Y A w HwY HwA). }
    claim HwVYA: w :e V :/\: (Y :/\: A).
    { exact (binintersectI V (Y :/\: A) w HwV HwYA). }
    claim HVYAnonempty: V :/\: (Y :/\: A) <> Empty.
    { assume HVYAempty_contra: V :/\: (Y :/\: A) = Empty.
      claim Hwempty: w :e Empty.
      { rewrite <- HVYAempty_contra. exact HwVYA. }
      exact (EmptyE w Hwempty False). }
    exact (HVYAnonempty HVYAempty2).
    }
  exact (SepI Y (fun y0 => forall U:set, U :e subspace_topology X Tx Y -> y0 :e U -> U :/\: A <> Empty) y HyY HySubCond).
Qed.

(** from 17 Theorem 17.5: closure via neighborhoods/basis **) 
(** LATEX VERSION: Characterization of closure: x is in closure of A iff every open neighborhood of x meets A. **)
Theorem closure_characterization : forall X Tx A x:set,
  topology_on X Tx -> x :e X ->
  (x :e closure_of X Tx A <-> (forall U :e Tx, x :e U -> U :/\: A <> Empty)).
let X Tx A x.
assume HTx: topology_on X Tx.
assume HxX: x :e X.
prove x :e closure_of X Tx A <-> (forall U :e Tx, x :e U -> U :/\: A <> Empty).
(** Strategy: unfold definition of closure_of using SepE and SepI **)
apply iffI.
- assume Hx: x :e closure_of X Tx A.
  prove forall U :e Tx, x :e U -> U :/\: A <> Empty.
  (** closure_of X Tx A = {x :e X | forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty} **)
  exact (SepE2 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx).
- assume Hcond: forall U :e Tx, x :e U -> U :/\: A <> Empty.
  prove x :e closure_of X Tx A.
  (** Have x :e X as hypothesis; just need to apply SepI with x and the condition **)
  exact (SepI X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x HxX Hcond).
Qed.

(** from 17 Corollary 17.7: closed iff contains all limit points **) 
(** LATEX VERSION: Limit point x of A means every neighborhood of x contains a point of A different from x; closure equals A plus its limit points. **)
Definition limit_point_of : set -> set -> set -> set -> prop := fun X Tx A x =>
  topology_on X Tx /\ x :e X /\
  forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
Definition limit_points_of : set -> set -> set -> set := fun X Tx A => {x :e X|limit_point_of X Tx A x}.

(** LATEX VERSION: Corollary 17.7: The closure of A equals A together with all its limit points. **)
Theorem closure_equals_set_plus_limit_points : forall X Tx A:set,
  topology_on X Tx -> A c= X ->
  closure_of X Tx A = A :\/: limit_points_of X Tx A.
let X Tx A.
assume HTx: topology_on X Tx.
assume HA: A c= X.
prove closure_of X Tx A = A :\/: limit_points_of X Tx A.
(** Strategy: cl(A) = A  lim(A) by double inclusion.
    - A  cl(A) already known, and lim(A)  cl(A) since limit points satisfy closure condition
    - If x  cl(A) and x  A, then x is a limit point **)
apply set_ext.
- (** cl(A)  A  lim(A) **)
  let x. assume Hx: x :e closure_of X Tx A.
  prove x :e A :\/: limit_points_of X Tx A.
  apply (xm (x :e A)).
  + assume HxA: x :e A.
    apply binunionI1.
    exact HxA.
  + assume HxnotA: x /:e A.
    (** Show x is a limit point **)
    apply binunionI2.
    prove x :e limit_points_of X Tx A.
    prove x :e {y :e X|limit_point_of X Tx A y}.
    claim HxX: x :e X.
    { exact (closure_in_space X Tx A HTx x Hx). }
    claim Hcond: forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
    { exact (SepE2 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx). }
    apply SepI.
    * exact HxX.
    * prove limit_point_of X Tx A x.
      prove topology_on X Tx /\ x :e X /\ forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
      apply andI.
      - apply andI.
        + exact HTx.
        + exact HxX.
      - prove forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
          let U. assume HU: U :e Tx. assume HxU: x :e U.
          prove exists y:set, y :e A /\ y <> x /\ y :e U.
          claim HUne: U :/\: A <> Empty.
          { exact (Hcond U HU HxU). }
          claim Hexists: exists y:set, y :e U :/\: A.
          { apply (xm (exists y:set, y :e U :/\: A)).
            - assume H. exact H.
            - assume Hnoex: ~(exists y:set, y :e U :/\: A).
              apply FalseE.
              apply HUne.
              apply set_ext.
              + let y. assume Hy: y :e U :/\: A.
                apply FalseE.
                apply Hnoex.
                witness y. exact Hy.
              + exact (Subq_Empty (U :/\: A)). }
          apply Hexists.
          let y. assume Hy: y :e U :/\: A.
          witness y.
          claim HyU: y :e U.
          { exact (binintersectE1 U A y Hy). }
          claim HyA: y :e A.
          { exact (binintersectE2 U A y Hy). }
          prove y :e A /\ y <> x /\ y :e U.
          apply andI.
          - apply andI.
            + exact HyA.
            + prove y <> x.
              assume Heq: y = x.
              apply HxnotA.
              rewrite <- Heq.
              exact HyA.
          - exact HyU.
- (** A  lim(A)  cl(A) **)
  let x. assume Hx: x :e A :\/: limit_points_of X Tx A.
  prove x :e closure_of X Tx A.
  apply (binunionE A (limit_points_of X Tx A) x Hx).
  + assume HxA: x :e A.
    (** Show x  cl(A) directly. Need x  X first. **)
    apply (xm (x :e X)).
    * assume HxX: x :e X.
      (** Now show for all U open containing x, U  A   **)
      prove x :e {y :e X | forall U:set, U :e Tx -> y :e U -> U :/\: A <> Empty}.
      apply SepI.
      - exact HxX.
      - prove forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
        let U. assume HU: U :e Tx. assume HxU: x :e U.
        assume Hempty: U :/\: A = Empty.
        (** x  U and x  A, so x  U  A, contradiction **)
        claim HxUA: x :e U :/\: A.
        { apply binintersectI. exact HxU. exact HxA. }
        claim HxEmpty: x :e Empty.
        { rewrite <- Hempty. exact HxUA. }
        exact (EmptyE x HxEmpty).
    * assume HxnotX: x /:e X.
      (** x  X but x  A. But we have A  X, so x  A implies x  X, contradiction. **)
      apply FalseE.
      claim HxX: x :e X.
      { exact (HA x HxA). }
      exact (HxnotX HxX).
  + assume Hxlim: x :e limit_points_of X Tx A.
    (** x is a limit point, so for all U open containing x, exists y  A with y  x in U, thus U  A   **)
    claim Hlimparts: x :e X /\ limit_point_of X Tx A x.
    { exact (SepE X (fun y => limit_point_of X Tx A y) x Hxlim). }
    claim HxX: x :e X.
    { exact (andEL (x :e X) (limit_point_of X Tx A x) Hlimparts). }
    claim Hlim: limit_point_of X Tx A x.
    { exact (andER (x :e X) (limit_point_of X Tx A x) Hlimparts). }
    claim Hlim_cond: forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
    { claim Hlim_full: topology_on X Tx /\ x :e X /\ forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
      { exact Hlim. }
      exact (andER (topology_on X Tx /\ x :e X) (forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U) Hlim_full). }
    prove x :e {y :e X | forall U:set, U :e Tx -> y :e U -> U :/\: A <> Empty}.
    apply SepI.
    * exact HxX.
    * prove forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
      let U. assume HU: U :e Tx. assume HxU: x :e U.
      prove U :/\: A <> Empty.
      claim Hexists: exists y:set, y :e A /\ y <> x /\ y :e U.
      { exact (Hlim_cond U HU HxU). }
      apply Hexists.
      let y. assume Hy_parts: y :e A /\ y <> x /\ y :e U.
      (** Extract components from (y :e A /\ y <> x) /\ y :e U **)
      claim Hy_left: y :e A /\ y <> x.
      { exact (andEL (y :e A /\ y <> x) (y :e U) Hy_parts). }
      claim HyA: y :e A.
      { exact (andEL (y :e A) (y <> x) Hy_left). }
      claim HyU: y :e U.
      { exact (andER (y :e A /\ y <> x) (y :e U) Hy_parts). }
      assume Heq: U :/\: A = Empty.
      claim HyUA: y :e U :/\: A.
      { apply binintersectI. exact HyU. exact HyA. }
      claim HyEmpty: y :e Empty.
      { rewrite <- Heq. exact HyUA. }
      exact (EmptyE y HyEmpty).
Qed.

(** from 17: closed sets contain all limit points **)
(** LATEX VERSION: A set A is closed iff it contains all its limit points. **)
Theorem closed_iff_contains_limit_points : forall X Tx A:set,
  topology_on X Tx -> A c= X ->
  (closed_in X Tx A <-> limit_points_of X Tx A c= A).
let X Tx A.
assume HTx: topology_on X Tx.
assume HA: A c= X.
prove closed_in X Tx A <-> limit_points_of X Tx A c= A.
(** Strategy: A closed iff cl(A) = A iff A  lim(A) = A iff lim(A)  A **)
apply iffI.
- (** Forward: If A closed, then lim(A)  A **)
  assume HAclosed: closed_in X Tx A.
  prove limit_points_of X Tx A c= A.
  let x. assume Hx: x :e limit_points_of X Tx A.
  prove x :e A.
  (** A is closed means cl(A) = A. We have cl(A) = A  lim(A), so A = A  lim(A), thus lim(A)  A. **)
  claim Heq_cl: closure_of X Tx A = A.
  { exact (closed_closure_eq X Tx A HTx HAclosed). }
  (** Use closure_equals_set_plus_limit_points: cl(A) = A  lim(A) **)
  claim Heq_union: closure_of X Tx A = A :\/: limit_points_of X Tx A.
  { exact (closure_equals_set_plus_limit_points X Tx A HTx HA). }
  (** From Heq_cl: A = cl(A), and Heq_union: cl(A) = A  lim(A), we get A = A  lim(A) **)
  (** So x  lim(A) implies x  A  lim(A) = A **)
  claim HxclA: x :e closure_of X Tx A.
  { rewrite Heq_union. apply binunionI2. exact Hx. }
  claim HxA: x :e A.
  { rewrite <- Heq_cl. exact HxclA. }
  exact HxA.
- (** Backward: If lim(A)  A, then A closed **)
  assume Hlim_sub: limit_points_of X Tx A c= A.
  prove closed_in X Tx A.
  (** Strategy:
      1. cl(A) = A  lim(A) by closure_equals_set_plus_limit_points
      2. lim(A)  A given, so A  lim(A) = A
      3. Therefore cl(A) = A
      4. cl(A)  X by definition, so A  X
      5. cl(A) is closed by closure_is_closed
      6. Since A = cl(A) and cl(A) is closed, A is closed **)
  claim Heq_union: closure_of X Tx A = A :\/: limit_points_of X Tx A.
  { exact (closure_equals_set_plus_limit_points X Tx A HTx HA). }
  (** Show A  lim(A) = A when lim(A)  A **)
  claim Hunion_eq: A :\/: limit_points_of X Tx A = A.
  { apply set_ext.
    - let x. assume Hx: x :e A :\/: limit_points_of X Tx A.
      prove x :e A.
      apply (binunionE A (limit_points_of X Tx A) x Hx).
      + assume HxA: x :e A. exact HxA.
      + assume Hxlim: x :e limit_points_of X Tx A.
        exact (Hlim_sub x Hxlim).
    - let x. assume HxA: x :e A.
      prove x :e A :\/: limit_points_of X Tx A.
      apply binunionI1. exact HxA. }
  (** Therefore cl(A) = A **)
  claim HclA_eq: closure_of X Tx A = A.
  { rewrite Heq_union. exact Hunion_eq. }
  (** cl(A) is closed by closure_is_closed **)
  claim HclA_closed: closed_in X Tx (closure_of X Tx A).
  { exact (closure_is_closed X Tx A HTx HA). }
  (** Since A = cl(A) and cl(A) is closed, A is closed **)
  prove closed_in X Tx A.
  rewrite <- HclA_eq.
  exact HclA_closed.
Qed.

(** from 17 Definition: Hausdorff and T1 spaces **) 
(** LATEX VERSION: Hausdorff (T): distinct points have disjoint neighborhoods; T: all finite sets closed. **)
Definition Hausdorff_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
    exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.

(** FIXED: Quantifier scope error.
    Was: forall F:set, finite F -> closed_in X Tx F (applies to ALL finite sets!)
    Issue: For F not a subset of X, closed_in X Tx F is false (closed_in requires F c= X).
           So this requires: "for all finite F (even those not in X), F is closed in X",
           which is impossible, making T1_space always false.
    Now: forall F:set, F c= X -> finite F -> closed_in X Tx F
    T1 property should only require finite subsets of X to be closed. **)
Definition T1_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\ (forall F:set, F c= X -> finite F -> closed_in X Tx F).

(** helper: in a Hausdorff space, the complement of a singleton is open **)
Theorem Hausdorff_singleton_complement_open : forall X Tx x:set,
  Hausdorff_space X Tx -> x :e X -> X :\: {x} :e Tx.
let X Tx x.
assume HH: Hausdorff_space X Tx.
assume HxX: x :e X.
prove X :\: {x} :e Tx.
claim Htop: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }
claim HSep: forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
  exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
{ exact (andER (topology_on X Tx)
               (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }
(** family of open sets missing x, indexed by points y in X with y<>x **)
set UFam := {V :e Power X |
  exists y:set,
    y :e X /\ y <> x /\ V :e Tx /\ y :e V /\ x /:e V}.
claim HUFam_sub: UFam c= Tx.
{ let V. assume HV: V :e UFam.
  claim HVpred: exists y:set, y :e X /\ y <> x /\ V :e Tx /\ y :e V /\ x /:e V.
  { exact (SepE2 (Power X)
                 (fun V0 : set =>
                   exists y:set, y :e X /\ y <> x /\ V0 :e Tx /\ y :e V0 /\ x /:e V0)
                 V
                 HV). }
  apply HVpred.
  let y. assume Hy_conj: y :e X /\ y <> x /\ V :e Tx /\ y :e V /\ x /:e V.
  claim H0: ((y :e X /\ y <> x) /\ V :e Tx) /\ y :e V.
  { exact (andEL (((y :e X /\ y <> x) /\ V :e Tx) /\ y :e V) (x /:e V) Hy_conj). }
  claim H1: (y :e X /\ y <> x) /\ V :e Tx.
  { exact (andEL ((y :e X /\ y <> x) /\ V :e Tx) (y :e V) H0). }
  exact (andER (y :e X /\ y <> x) (V :e Tx) H1). }
claim HUnionOpen: Union UFam :e Tx.
{ exact (topology_union_closed X Tx UFam Htop HUFam_sub). }
claim HUnionEq: Union UFam = X :\: {x}.
{ apply set_ext.
  - let z. assume Hz: z :e Union UFam.
    prove z :e X :\: {x}.
    apply (UnionE_impred UFam z Hz (z :e X :\: {x})).
    let V. assume HzV: z :e V. assume HV: V :e UFam.
    claim HVpow: V :e Power X.
    { exact (SepE1 (Power X)
                   (fun V0 : set =>
                     exists y:set, y :e X /\ y <> x /\ V0 :e Tx /\ y :e V0 /\ x /:e V0)
                   V
                   HV). }
    claim HVsubX: V c= X.
    { exact (PowerE X V HVpow). }
    claim HzX: z :e X.
    { exact (HVsubX z HzV). }
    claim HVpred: exists y:set, y :e X /\ y <> x /\ V :e Tx /\ y :e V /\ x /:e V.
    { exact (SepE2 (Power X)
                   (fun V0 : set =>
                     exists y:set, y :e X /\ y <> x /\ V0 :e Tx /\ y :e V0 /\ x /:e V0)
                   V
                   HV). }
	    apply HVpred.
	    let y. assume Hy_conj: y :e X /\ y <> x /\ V :e Tx /\ y :e V /\ x /:e V.
	    claim HxNotV: x /:e V.
	    { exact (andER (((y :e X /\ y <> x) /\ V :e Tx) /\ y :e V) (x /:e V) Hy_conj). }
	    claim HznotSing: z /:e {x}.
	    { assume HzSing: z :e {x}.
	      claim Hzeq: z = x.
      { exact (SingE x z HzSing). }
      claim HxV: x :e V.
      { rewrite <- Hzeq. exact HzV. }
      exact (HxNotV HxV). }
    exact (setminusI X {x} z HzX HznotSing).
  - let z. assume Hz: z :e X :\: {x}.
    prove z :e Union UFam.
    claim HzX: z :e X.
    { exact (setminusE1 X {x} z Hz). }
    claim HznotSing: z /:e {x}.
    { exact (setminusE2 X {x} z Hz). }
    claim Hzneq: z <> x.
    { assume Hzeq: z = x.
      claim HzSing: z :e {x}.
      { rewrite Hzeq. exact (SingI x). }
      exact (HznotSing HzSing). }
    claim HexUV: exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ z :e V /\ U :/\: V = Empty.
    { exact (HSep x z HxX HzX (neq_i_sym z x Hzneq)). }
    apply HexUV.
    let U. assume HexV: exists V:set, U :e Tx /\ V :e Tx /\ x :e U /\ z :e V /\ U :/\: V = Empty.
    apply HexV.
    let V. assume Hconj: U :e Tx /\ V :e Tx /\ x :e U /\ z :e V /\ U :/\: V = Empty.
    claim Hconj1: ((U :e Tx /\ V :e Tx) /\ x :e U) /\ z :e V.
    { exact (andEL (((U :e Tx /\ V :e Tx) /\ x :e U) /\ z :e V) (U :/\: V = Empty) Hconj). }
    claim HUVempty: U :/\: V = Empty.
    { exact (andER (((U :e Tx /\ V :e Tx) /\ x :e U) /\ z :e V) (U :/\: V = Empty) Hconj). }
    claim Hconj2: (U :e Tx /\ V :e Tx) /\ x :e U.
    { exact (andEL ((U :e Tx /\ V :e Tx) /\ x :e U) (z :e V) Hconj1). }
    claim HUV1: U :e Tx /\ V :e Tx.
    { exact (andEL (U :e Tx /\ V :e Tx) (x :e U) Hconj2). }
    claim HxU: x :e U.
    { exact (andER (U :e Tx /\ V :e Tx) (x :e U) Hconj2). }
    claim HVTx: V :e Tx.
    { exact (andER (U :e Tx) (V :e Tx) HUV1). }
    claim HzV: z :e V.
    { exact (andER ((U :e Tx /\ V :e Tx) /\ x :e U) (z :e V) Hconj1). }
    claim HxNotV: x /:e V.
    { assume HxV: x :e V.
      claim HxUV: x :e U :/\: V.
      { exact (binintersectI U V x HxU HxV). }
      claim HxEmp: x :e Empty.
      { rewrite <- HUVempty. exact HxUV. }
      exact (EmptyE x HxEmp False). }
    claim HVpow: V :e Power X.
    { claim HTsub: Tx c= Power X.
      { exact (topology_subset_axiom X Tx Htop). }
      exact (HTsub V HVTx). }
    claim HVin: V :e UFam.
    { apply (SepI (Power X)
                  (fun V0 : set =>
                    exists y:set, y :e X /\ y <> x /\ V0 :e Tx /\ y :e V0 /\ x /:e V0)
                  V
                  HVpow).
      witness z.
      apply andI.
      { apply andI.
        { apply andI.
          { apply andI.
            exact HzX.
            exact Hzneq. }
          exact HVTx. }
        exact HzV. }
      { exact HxNotV. } }
    exact (UnionI UFam z V HzV HVin).
}
rewrite <- HUnionEq.
exact HUnionOpen.
Qed.

(** helper: in a Hausdorff space, singletons are closed **)
Theorem Hausdorff_singletons_closed : forall X Tx x:set,
  Hausdorff_space X Tx -> x :e X -> closed_in X Tx {x}.
let X Tx x.
assume HH: Hausdorff_space X Tx.
assume HxX: x :e X.
prove closed_in X Tx {x}.
claim Htop: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }
claim HxSub: {x} c= X.
{ let y. assume Hy: y :e {x}.
  claim Hyeq: y = x.
  { exact (SingE x y Hy). }
  rewrite Hyeq. exact HxX. }
claim HUopen: X :\: {x} :e Tx.
{ exact (Hausdorff_singleton_complement_open X Tx x HH HxX). }
claim Hclosed: closed_in X Tx (X :\: (X :\: {x})).
{ exact (closed_of_open_complement X Tx (X :\: {x}) Htop HUopen). }
claim Heq: X :\: (X :\: {x}) = {x}.
{ exact (setminus_setminus_eq X {x} HxSub). }
rewrite <- Heq.
exact Hclosed.
Qed.

(** from 17 Theorem 17.8: finite sets closed in Hausdorff **) 
(** LATEX VERSION: In any Hausdorff space, every finite subset is closed. **)
Theorem finite_sets_closed_in_Hausdorff : forall X Tx:set,
  Hausdorff_space X Tx -> forall F:set, F c= X -> finite F -> closed_in X Tx F.
let X Tx.
assume HH: Hausdorff_space X Tx.
let F.
assume HFsub: F c= X.
assume HF: finite F.
prove closed_in X Tx F.
claim Htop: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }
claim Hclosed_empty: closed_in X Tx Empty.
{ exact (empty_is_closed X Tx Htop). }
claim Hall: forall F0:set, finite F0 -> (F0 c= X -> closed_in X Tx F0).
{ exact (finite_ind
           (fun F0:set => F0 c= X -> closed_in X Tx F0)
           (fun _ => Hclosed_empty)
           (fun F0 y:set =>
              fun HFin0 HyNotin IH =>
                fun HsubUnion =>
                  union_of_closed_is_closed X Tx F0 {y} Htop
                    (IH (fun z Hz => HsubUnion z (binunionI1 F0 {y} z Hz)))
                    (Hausdorff_singletons_closed X Tx y HH
                      (HsubUnion y (binunionI2 F0 {y} y (SingI y)))))
         ). }
exact ((Hall F HF) HFsub).
Qed.

(** from 17 Theorem 17.9: limit points in T1 spaces have infinite neighborhoods **) 
(** LATEX VERSION: In T spaces, x is a limit point of A iff every neighborhood of x meets A in infinitely many points. **)
Theorem limit_points_infinite_neighborhoods : forall X Tx A x:set,
  T1_space X Tx ->
  x :e X ->
  (limit_point_of X Tx A x <->
  (forall U :e Tx, x :e U -> infinite (U :/\: A))).
let X Tx A x.
assume HT1: T1_space X Tx.
assume HxX: x :e X.
prove limit_point_of X Tx A x <-> (forall U :e Tx, x :e U -> infinite (U :/\: A)).
claim Htop: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (forall F:set, F c= X -> finite F -> closed_in X Tx F) HT1). }
claim Hfinite_closed: forall F:set, F c= X -> finite F -> closed_in X Tx F.
{ exact (andER (topology_on X Tx) (forall F:set, F c= X -> finite F -> closed_in X Tx F) HT1). }
apply iffI.
- (** limit point gives infinite intersections **)
  assume Hlim: limit_point_of X Tx A x.
  prove forall U :e Tx, x :e U -> infinite (U :/\: A).
  let U. assume HU: U :e Tx. assume HxU: x :e U.
  prove infinite (U :/\: A).
  prove ~finite (U :/\: A).
  assume Hfin: finite (U :/\: A).
  claim Hnbr: forall W:set, W :e Tx -> x :e W -> exists y:set, y :e A /\ y <> x /\ y :e W.
  { exact (andER (topology_on X Tx /\ x :e X) (forall W:set, W :e Tx -> x :e W -> exists y:set, y :e A /\ y <> x /\ y :e W)
           Hlim). }
  apply (xm (x :e A)).
  + (** case x in A: remove all other A-points from U **)
    assume HxA: x :e A.
    set F := (U :/\: A) :\: {x}.
    claim HFsub: F c= U :/\: A.
    { exact (setminus_Subq (U :/\: A) {x}). }
    claim HFfin: finite F.
    { exact (Subq_finite (U :/\: A) Hfin F HFsub). }
    claim HFsubX: F c= X.
    { let z. assume HzF: z :e F.
      claim HzUA: z :e U :/\: A.
      { exact (setminusE1 (U :/\: A) {x} z HzF). }
      claim HzU: z :e U.
      { exact (binintersectE1 U A z HzUA). }
      claim HUsubX: U c= X.
      { exact (topology_elem_subset X Tx U Htop HU). }
      exact (HUsubX z HzU). }
    claim HFclosed: closed_in X Tx F.
    { exact (Hfinite_closed F HFsubX HFfin). }
    claim HXFopen: open_in X Tx (X :\: F).
    { exact (open_of_closed_complement X Tx F HFclosed). }
    claim HXF: X :\: F :e Tx.
    { exact (andER (topology_on X Tx) (X :\: F :e Tx) HXFopen). }
    set V := U :/\: (X :\: F).
    claim HV: V :e Tx.
    { exact (topology_binintersect_closed X Tx U (X :\: F) Htop HU HXF). }
    claim HxnotF: x /:e F.
    { assume HxF: x :e F.
      claim HxnotSing: x /:e {x}.
      { exact (setminusE2 (U :/\: A) {x} x HxF). }
      exact (HxnotSing (SingI x)). }
    claim HxXF: x :e X :\: F.
    { exact (setminusI X F x HxX HxnotF). }
    claim HxV: x :e V.
    { exact (binintersectI U (X :\: F) x HxU HxXF). }
	    apply (Hnbr V HV HxV).
	    let y. assume Hyconj: y :e A /\ y <> x /\ y :e V.
	    claim HyAneq: y :e A /\ y <> x.
	    { exact (andEL (y :e A /\ y <> x) (y :e V) Hyconj). }
	    claim HyA: y :e A.
	    { exact (andEL (y :e A) (y <> x) HyAneq). }
	    claim Hyneq: y <> x.
	    { exact (andER (y :e A) (y <> x) HyAneq). }
	    claim HyV: y :e V.
	    { exact (andER (y :e A /\ y <> x) (y :e V) Hyconj). }
    claim HyU: y :e U.
    { exact (binintersectE1 U (X :\: F) y HyV). }
    claim HyXF: y :e X :\: F.
    { exact (binintersectE2 U (X :\: F) y HyV). }
    claim HyNotF: y /:e F.
    { exact (setminusE2 X F y HyXF). }
    claim HyUA: y :e U :/\: A.
    { exact (binintersectI U A y HyU HyA). }
    claim HyNotSing: y /:e {x}.
    { assume HySing: y :e {x}.
      claim Hyeq: y = x.
      { exact (SingE x y HySing). }
      exact (Hyneq Hyeq). }
    claim HyF: y :e F.
    { exact (setminusI (U :/\: A) {x} y HyUA HyNotSing). }
    exact (HyNotF HyF).
  + (** case x not in A: remove all A-points from U **)
    assume HxnotA: x /:e A.
    set F := U :/\: A.
    claim HFsubX: F c= X.
    { let z. assume HzF: z :e F.
      claim HzU: z :e U.
      { exact (binintersectE1 U A z HzF). }
      claim HUsubX: U c= X.
      { exact (topology_elem_subset X Tx U Htop HU). }
      exact (HUsubX z HzU). }
    claim HFclosed: closed_in X Tx F.
    { exact (Hfinite_closed F HFsubX Hfin). }
    claim HXFopen: open_in X Tx (X :\: F).
    { exact (open_of_closed_complement X Tx F HFclosed). }
    claim HXF: X :\: F :e Tx.
    { exact (andER (topology_on X Tx) (X :\: F :e Tx) HXFopen). }
    set V := U :/\: (X :\: F).
    claim HV: V :e Tx.
    { exact (topology_binintersect_closed X Tx U (X :\: F) Htop HU HXF). }
    claim HxnotF: x /:e F.
    { assume HxF: x :e F.
      claim HxA': x :e A.
      { exact (binintersectE2 U A x HxF). }
      exact (HxnotA HxA'). }
    claim HxXF: x :e X :\: F.
    { exact (setminusI X F x HxX HxnotF). }
    claim HxV: x :e V.
    { exact (binintersectI U (X :\: F) x HxU HxXF). }
	    apply (Hnbr V HV HxV).
	    let y. assume Hyconj: y :e A /\ y <> x /\ y :e V.
	    claim HyAneq: y :e A /\ y <> x.
	    { exact (andEL (y :e A /\ y <> x) (y :e V) Hyconj). }
	    claim HyA: y :e A.
	    { exact (andEL (y :e A) (y <> x) HyAneq). }
	    claim Hyneq: y <> x.
	    { exact (andER (y :e A) (y <> x) HyAneq). }
	    claim HyV: y :e V.
	    { exact (andER (y :e A /\ y <> x) (y :e V) Hyconj). }
    claim HyU: y :e U.
    { exact (binintersectE1 U (X :\: F) y HyV). }
    claim HyXF: y :e X :\: F.
    { exact (binintersectE2 U (X :\: F) y HyV). }
    claim HyNotF: y /:e F.
    { exact (setminusE2 X F y HyXF). }
    claim HyF: y :e F.
    { exact (binintersectI U A y HyU HyA). }
    exact (HyNotF HyF).
- (** infinite intersections give limit point **)
  assume Hinf: forall U :e Tx, x :e U -> infinite (U :/\: A).
  prove limit_point_of X Tx A x.
  prove topology_on X Tx /\ x :e X /\ forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
  apply andI.
  - apply andI.
    + exact Htop.
    + exact HxX.
  - let U. assume HU: U :e Tx. assume HxU: x :e U.
    claim HinfUA: infinite (U :/\: A).
    { exact (Hinf U HU HxU). }
    claim Hnotfin: ~finite (U :/\: A).
    { exact HinfUA. }
    apply (xm (exists y:set, y :e U :/\: A /\ y <> x)).
    + assume Hex. apply Hex.
      let y. assume Hypair.
      witness y.
      claim HyUA: y :e U :/\: A.
      { exact (andEL (y :e U :/\: A) (y <> x) Hypair). }
      claim Hyneq: y <> x.
      { exact (andER (y :e U :/\: A) (y <> x) Hypair). }
      claim HyU: y :e U.
      { exact (binintersectE1 U A y HyUA). }
      claim HyA: y :e A.
      { exact (binintersectE2 U A y HyUA). }
      apply andI.
      - apply andI.
        + exact HyA.
        + exact Hyneq.
      - exact HyU.
    + assume Hno: ~(exists y:set, y :e U :/\: A /\ y <> x).
      claim HsubSing: U :/\: A c= {x}.
      { let y. assume HyUA: y :e U :/\: A.
        apply (xm (y = x)).
        - assume Heq: y = x.
          rewrite Heq.
          exact (SingI x).
        - assume Hneq: ~(y = x).
          apply FalseE.
          apply Hno.
          witness y.
          apply andI.
          - exact HyUA.
          - assume Heq: y = x.
            exact (Hneq Heq). }
	      claim HfinUA: finite (U :/\: A).
	      { exact (Subq_finite {x} (Sing_finite x) (U :/\: A) HsubSing). }
	      apply FalseE.
	      exact (Hnotfin HfinUA).
Qed.

(** from 17 Theorem 17.10: uniqueness of limits in Hausdorff spaces **) 
(** LATEX VERSION: In Hausdorff spaces, sequences (or nets) have at most one limit. **)
Theorem Hausdorff_unique_limits : forall X Tx seq x y:set,
  Hausdorff_space X Tx ->
  x :e X ->
  y :e X ->
  x <> y ->
  function_on seq omega X ->
  (forall U:set, U :e Tx -> x :e U -> exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U) ->
  (forall U:set, U :e Tx -> y :e U -> exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U) ->
  False.
let X Tx seq x y.
assume HH: Hausdorff_space X Tx.
assume HxX: x :e X.
assume HyX: y :e X.
assume Hneq: x <> y.
assume Hseq: function_on seq omega X.
assume Hx: forall U:set, U :e Tx -> x :e U -> exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U.
assume Hy: forall U:set, U :e Tx -> y :e U -> exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U.
prove False.
(** Strategy: Use Hausdorff property to separate x and y with disjoint opens U, V.
    Sequence converges to x means eventually in U.
    Sequence converges to y means eventually in V.
    But U  V = , so seq can't be in both eventually - contradiction. **)
(** Extract topology and separation property **)
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 -> exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }
claim HSep: forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 -> exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
{ exact (andER (topology_on X Tx)
               (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 -> exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }
(** Apply separation to x and y **)
claim HexUV: exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ y :e V /\ U :/\: V = Empty.
{ exact (HSep x y HxX HyX Hneq). }
(** Handle nested existentials - need to carefully unpack structure **)
(** Unpack the existential for U and V **)
apply HexUV.
let U. assume HexV: exists V:set, U :e Tx /\ V :e Tx /\ x :e U /\ y :e V /\ U :/\: V = Empty.
apply HexV.
let V. assume Hconj: U :e Tx /\ V :e Tx /\ x :e U /\ y :e V /\ U :/\: V = Empty.
(** Extract all the conjuncts - remember /\ is left-associative **)
(** Hconj is: (((U :e Tx /\ V :e Tx) /\ x :e U) /\ y :e V) /\ U :/\: V = Empty **)
claim HU: U :e Tx.
{ exact (andEL (U :e Tx) (V :e Tx)
         (andEL (U :e Tx /\ V :e Tx) (x :e U)
          (andEL (U :e Tx /\ V :e Tx /\ x :e U) (y :e V)
           (andEL (U :e Tx /\ V :e Tx /\ x :e U /\ y :e V) (U :/\: V = Empty) Hconj)))). }
claim HV: V :e Tx.
{ exact (andER (U :e Tx) (V :e Tx)
         (andEL (U :e Tx /\ V :e Tx) (x :e U)
          (andEL (U :e Tx /\ V :e Tx /\ x :e U) (y :e V)
           (andEL (U :e Tx /\ V :e Tx /\ x :e U /\ y :e V) (U :/\: V = Empty) Hconj)))). }
claim HxU: x :e U.
{ exact (andER (U :e Tx /\ V :e Tx) (x :e U)
          (andEL (U :e Tx /\ V :e Tx /\ x :e U) (y :e V)
           (andEL (U :e Tx /\ V :e Tx /\ x :e U /\ y :e V) (U :/\: V = Empty) Hconj))). }
claim HyV: y :e V.
{ exact (andER (U :e Tx /\ V :e Tx /\ x :e U) (y :e V)
           (andEL (U :e Tx /\ V :e Tx /\ x :e U /\ y :e V) (U :/\: V = Empty) Hconj)). }
claim HUV_empty: U :/\: V = Empty.
{ exact (andER (U :e Tx /\ V :e Tx /\ x :e U /\ y :e V) (U :/\: V = Empty) Hconj). }
(** Now we have U, V open, disjoint, x :e U, y :e V **)
(** Sequence converges to x: eventually in U **)
claim HexNx: exists Nx:set, Nx :e omega /\ forall n:set, n :e omega -> Nx c= n -> apply_fun seq n :e U.
{ exact (Hx U HU HxU). }
apply HexNx.
let Nx. assume HNx_and_conv.
claim HNx: Nx :e omega.
{ exact (andEL (Nx :e omega) (forall n:set, n :e omega -> Nx c= n -> apply_fun seq n :e U) HNx_and_conv). }
claim Hconv_x: forall n:set, n :e omega -> Nx c= n -> apply_fun seq n :e U.
{ exact (andER (Nx :e omega) (forall n:set, n :e omega -> Nx c= n -> apply_fun seq n :e U) HNx_and_conv). }
(** Sequence converges to y: eventually in V **)
claim HexNy: exists Ny:set, Ny :e omega /\ forall n:set, n :e omega -> Ny c= n -> apply_fun seq n :e V.
{ exact (Hy V HV HyV). }
apply HexNy.
let Ny. assume HNy_and_conv.
claim HNy: Ny :e omega.
{ exact (andEL (Ny :e omega) (forall n:set, n :e omega -> Ny c= n -> apply_fun seq n :e V) HNy_and_conv). }
claim Hconv_y: forall n:set, n :e omega -> Ny c= n -> apply_fun seq n :e V.
{ exact (andER (Ny :e omega) (forall n:set, n :e omega -> Ny c= n -> apply_fun seq n :e V) HNy_and_conv). }
(** Take n = ordsucc (Nx  Ny), which is >= both Nx and Ny **)
(** Since Nx, Ny are ordinals in omega, Nx  Ny = max(Nx, Ny) **)
set N := ordsucc (Nx :\/: Ny).
claim HN_omega: N :e omega.
{ claim Hmax_omega: Nx :\/: Ny :e omega.
  { (** Nx  Ny is the max of two elements of omega, hence in omega **)
    apply (xm (Nx :e Ny)).
    - assume HNx_in_Ny: Nx :e Ny.
      (** If Nx < Ny, then Nx  Ny = Ny **)
      claim Hmax_eq_Ny: Nx :\/: Ny = Ny.
      { (** Nx  Ny since Nx :e Ny and Ny is an ordinal (transitive) **)
        claim HNx_sub_Ny: Nx c= Ny.
        { (** Ny is a natural, hence ordinal, hence TransSet **)
          claim HNy_nat: nat_p Ny.
          { exact (omega_nat_p Ny HNy). }
          claim HNy_ord: ordinal Ny.
          { exact (nat_p_ordinal Ny HNy_nat). }
          claim HNy_trans: TransSet Ny.
          { exact (andEL (TransSet Ny) (forall beta :e Ny, TransSet beta) HNy_ord). }
          (** Now use TransSet property: x :e Ny implies x c= Ny **)
          exact (HNy_trans Nx HNx_in_Ny).
        }
        apply set_ext.
        - (** Nx :\/: Ny c= Ny **)
          claim HNy_refl: Ny c= Ny.
          { exact (Subq_ref Ny). }
          exact (binunion_Subq_min Nx Ny Ny HNx_sub_Ny HNy_refl).
        - (** Ny c= Nx :\/: Ny **)
          exact (binunion_Subq_2 Nx Ny).
      }
      rewrite Hmax_eq_Ny.
      exact HNy.
    - assume HNx_nin_Ny: Nx /:e Ny.
      (** If Nx >= Ny, then Ny  Nx **)
      claim HNy_sub_or_eq_Nx: Ny c= Nx.
      { (** In omega, if Nx /:e Ny, then Ny :e Nx or Ny = Nx (trichotomy) **)
        (** Use ordinal trichotomy: Nx and Ny are ordinals since they're in omega **)
        claim HNx_nat: nat_p Nx.
        { exact (omega_nat_p Nx HNx). }
        claim HNy_nat: nat_p Ny.
        { exact (omega_nat_p Ny HNy). }
        claim HNx_ord: ordinal Nx.
        { exact (nat_p_ordinal Nx HNx_nat). }
        claim HNy_ord: ordinal Ny.
        { exact (nat_p_ordinal Ny HNy_nat). }
        (** Apply ordinal_In_Or_Subq: either Nx :e Ny or Ny c= Nx **)
        claim Hcases: Nx :e Ny \/ Ny c= Nx.
        { exact (ordinal_In_Or_Subq Nx Ny HNx_ord HNy_ord). }
        (** We have Nx /:e Ny, so must have Ny c= Nx **)
        apply (Hcases (Ny c= Nx)).
        - assume HNx_in_Ny: Nx :e Ny.
          apply FalseE.
          exact (HNx_nin_Ny HNx_in_Ny).
        - assume H. exact H.
      }
      claim Hmax_eq_Nx: Nx :\/: Ny = Nx.
      { apply set_ext.
        - (** Nx :\/: Ny c= Nx **)
          claim HNx_refl: Nx c= Nx.
          { exact (Subq_ref Nx). }
          exact (binunion_Subq_min Nx Ny Nx HNx_refl HNy_sub_or_eq_Nx).
        - (** Nx c= Nx :\/: Ny **)
          exact (binunion_Subq_1 Nx Ny).
      }
      rewrite Hmax_eq_Nx.
      exact HNx.
  }
  exact (omega_ordsucc (Nx :\/: Ny) Hmax_omega).
}
claim HNx_sub_N: Nx c= N.
{ (** Nx  Nx  Ny  ordsucc(Nx  Ny) **)
  claim HNx_sub_union: Nx c= Nx :\/: Ny.
  { exact (binunion_Subq_1 Nx Ny). }
  claim Hunion_sub_ordsucc: Nx :\/: Ny c= ordsucc (Nx :\/: Ny).
  { exact (ordsuccI1 (Nx :\/: Ny)). }
  exact (Subq_tra Nx (Nx :\/: Ny) (ordsucc (Nx :\/: Ny)) HNx_sub_union Hunion_sub_ordsucc).
}
claim HNy_sub_N: Ny c= N.
{ (** Ny  Nx  Ny  ordsucc(Nx  Ny) **)
  claim HNy_sub_union: Ny c= Nx :\/: Ny.
  { exact (binunion_Subq_2 Nx Ny). }
  claim Hunion_sub_ordsucc: Nx :\/: Ny c= ordsucc (Nx :\/: Ny).
  { exact (ordsuccI1 (Nx :\/: Ny)). }
  exact (Subq_tra Ny (Nx :\/: Ny) (ordsucc (Nx :\/: Ny)) HNy_sub_union Hunion_sub_ordsucc).
}
(** Then apply_fun seq N is in both U and V **)
claim Hseq_N_in_U: apply_fun seq N :e U.
{ exact (Hconv_x N HN_omega HNx_sub_N). }
claim Hseq_N_in_V: apply_fun seq N :e V.
{ exact (Hconv_y N HN_omega HNy_sub_N). }
(** So apply_fun seq N :e U  V **)
claim Hseq_N_in_UV: apply_fun seq N :e U :/\: V.
{ exact (binintersectI U V (apply_fun seq N) Hseq_N_in_U Hseq_N_in_V). }
(** But U  V = , so apply_fun seq N :e , which is False **)
claim Hseq_N_in_empty: apply_fun seq N :e Empty.
{ rewrite <- HUV_empty. exact Hseq_N_in_UV. }
exact (EmptyE (apply_fun seq N) Hseq_N_in_empty False).
Qed.

(** from 17 Theorem 17.11: Hausdorff stability under constructions **) 
(** LATEX VERSION: Products of Hausdorff spaces are Hausdorff. **)
Theorem Hausdorff_stability : forall X Tx Y Ty:set,
  Hausdorff_space X Tx /\ Hausdorff_space Y Ty ->
  Hausdorff_space (setprod X Y) (product_topology X Tx Y Ty).
let X Tx Y Ty.
assume H: Hausdorff_space X Tx /\ Hausdorff_space Y Ty.
prove Hausdorff_space (setprod X Y) (product_topology X Tx Y Ty).
(** Strategy: Same as ex17_11_product_Hausdorff - use rectangles to separate distinct points **)
(** Extract components from Hausdorff definitions **)
claim HX: Hausdorff_space X Tx.
{ exact (andEL (Hausdorff_space X Tx) (Hausdorff_space Y Ty) H). }
claim HY: Hausdorff_space Y Ty.
{ exact (andER (Hausdorff_space X Tx) (Hausdorff_space Y Ty) H). }
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 -> exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HX). }
claim HTy: topology_on Y Ty.
{ exact (andEL (topology_on Y Ty)
               (forall y1 y2:set, y1 :e Y -> y2 :e Y -> y1 <> y2 -> exists U V:set, U :e Ty /\ V :e Ty /\ y1 :e U /\ y2 :e V /\ U :/\: V = Empty)
               HY). }
claim HSepX: forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 -> exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
{ exact (andER (topology_on X Tx)
               (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 -> exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HX). }
claim HSepY: forall y1 y2:set, y1 :e Y -> y2 :e Y -> y1 <> y2 -> exists U V:set, U :e Ty /\ V :e Ty /\ y1 :e U /\ y2 :e V /\ U :/\: V = Empty.
{ exact (andER (topology_on Y Ty)
               (forall y1 y2:set, y1 :e Y -> y2 :e Y -> y1 <> y2 -> exists U V:set, U :e Ty /\ V :e Ty /\ y1 :e U /\ y2 :e V /\ U :/\: V = Empty)
               HY). }
(** Build Hausdorff property for product **)
claim HTProd: topology_on (setprod X Y) (product_topology X Tx Y Ty).
{ exact (product_topology_is_topology X Tx Y Ty HTx HTy). }
prove topology_on (setprod X Y) (product_topology X Tx Y Ty) /\
      (forall p1 p2:set, p1 :e setprod X Y -> p2 :e setprod X Y -> p1 <> p2 ->
       exists U V:set, U :e product_topology X Tx Y Ty /\ V :e product_topology X Tx Y Ty /\
                       p1 :e U /\ p2 :e V /\ U :/\: V = Empty).
apply andI.
- exact HTProd.
- let p1 p2. assume Hp1: p1 :e setprod X Y. assume Hp2: p2 :e setprod X Y. assume Hne: p1 <> p2.
  prove exists U V:set, U :e product_topology X Tx Y Ty /\ V :e product_topology X Tx Y Ty /\
                        p1 :e U /\ p2 :e V /\ U :/\: V = Empty.
  (** Decompose p1 = (x1,y1), p2 = (x2,y2) **)
  apply (Sigma_E X (fun _ : set => Y) p1 Hp1).
  let x1. assume Hx1_pair.
  apply Hx1_pair.
  assume Hx1X Hexy1.
  apply Hexy1.
  let y1. assume Hy1_pair.
  apply Hy1_pair.
  assume Hy1Y Hp1eq.
  apply (Sigma_E X (fun _ : set => Y) p2 Hp2).
  let x2. assume Hx2_pair.
  apply Hx2_pair.
  assume Hx2X Hexy2.
  apply Hexy2.
  let y2. assume Hy2_pair.
  apply Hy2_pair.
  assume Hy2Y Hp2eq.
  (** Split by whether x-coordinates coincide **)
  apply (xm (x1 = x2)).
  - assume Hx12: x1 = x2.
    claim Hy12: y1 <> y2.
    { assume HyEq: y1 = y2.
      claim HpEq: p1 = p2.
      { rewrite Hp1eq.
        rewrite Hp2eq.
        rewrite Hx12.
        rewrite HyEq.
        reflexivity. }
      exact (Hne HpEq). }
    (** Separate by y-coordinate using opens in Ty **)
    apply (HSepY y1 y2 Hy1Y Hy2Y Hy12).
    let U. assume HexV.
    apply HexV.
    let V. assume HUV_conj.
    apply HUV_conj.
    assume Hcore HUVempty.
    apply Hcore.
    assume Hcore2 Hy2V.
    apply Hcore2.
    assume Hcore3 Hy1U.
    apply Hcore3.
    assume HU HV.
    set R1 := rectangle_set X U.
    set R2 := rectangle_set X V.
    witness R1.
    witness R2.
    prove R1 :e product_topology X Tx Y Ty /\ R2 :e product_topology X Tx Y Ty /\ p1 :e R1 /\ p2 :e R2 /\ R1 :/\: R2 = Empty.
    apply andI.
    + apply andI.
      * apply andI.
        { apply andI.
          (** R1 open in product topology **)
          - claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
            { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
            claim HXTx: X :e Tx.
            { exact (topology_has_X X Tx HTx). }
            claim HR1sub: R1 :e product_subbasis X Tx Y Ty.
            { prove R1 :e product_subbasis X Tx Y Ty.
              claim HR1fam: rectangle_set X U :e {rectangle_set X V0|V0 :e Ty}.
              { exact (ReplI Ty (fun V0:set => rectangle_set X V0) U HU). }
              exact (famunionI Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) X (rectangle_set X U) HXTx HR1fam). }
            exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis R1 HR1sub).
          (** R2 open in product topology **)
          - claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
            { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
            claim HXTx: X :e Tx.
            { exact (topology_has_X X Tx HTx). }
            claim HR2sub: R2 :e product_subbasis X Tx Y Ty.
            { prove R2 :e product_subbasis X Tx Y Ty.
              claim HR2fam: rectangle_set X V :e {rectangle_set X V0|V0 :e Ty}.
              { exact (ReplI Ty (fun V0:set => rectangle_set X V0) V HV). }
              exact (famunionI Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) X (rectangle_set X V) HXTx HR2fam). }
            exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis R2 HR2sub). }
        (** p1 in R1 **)
        { rewrite Hp1eq.
          exact (pair_Sigma X (fun _ : set => U) x1 Hx1X y1 Hy1U). }
      (** p2 in R2 **)
      * rewrite Hp2eq.
        rewrite <- Hx12 at 1.
        exact (pair_Sigma X (fun _ : set => V) x1 Hx1X y2 Hy2V).
    (** disjointness of rectangles **)
    + prove R1 :/\: R2 = Empty.
      apply set_ext.
      { let p. assume Hp: p :e R1 :/\: R2.
        prove p :e Empty.
        apply FalseE.
        claim HpR1: p :e R1.
        { exact (binintersectE1 R1 R2 p Hp). }
        claim HpR2: p :e R2.
        { exact (binintersectE2 R1 R2 p Hp). }
        claim Hcoords1: exists x :e X, exists y :e U, p :e setprod {x} {y}.
        { exact (setprod_elem_decompose X U p HpR1). }
        apply Hcoords1.
        let x. assume Hx_pair.
        claim HxX': x :e X.
        { exact (andEL (x :e X) (exists y0 :e U, p :e setprod {x} {y0}) Hx_pair). }
        claim Hexy: exists y0 :e U, p :e setprod {x} {y0}.
        { exact (andER (x :e X) (exists y0 :e U, p :e setprod {x} {y0}) Hx_pair). }
        apply Hexy.
        let y. assume Hy_pair.
        claim HyU': y :e U.
        { exact (andEL (y :e U) (p :e setprod {x} {y}) Hy_pair). }
        claim Hpsing1: p :e setprod {x} {y}.
        { exact (andER (y :e U) (p :e setprod {x} {y}) Hy_pair). }
        claim Hcoords2: exists x0 :e X, exists y0 :e V, p :e setprod {x0} {y0}.
        { exact (setprod_elem_decompose X V p HpR2). }
        apply Hcoords2.
        let x0. assume Hx0_pair.
        claim Hexy0: exists y0 :e V, p :e setprod {x0} {y0}.
        { exact (andER (x0 :e X) (exists y0 :e V, p :e setprod {x0} {y0}) Hx0_pair). }
        apply Hexy0.
        let y0. assume Hy0_pair.
        claim Hpsing2: p :e setprod {x0} {y0}.
        { exact (andER (y0 :e V) (p :e setprod {x0} {y0}) Hy0_pair). }
        claim HyV': y :e V.
        { exact (andER (x :e X) (y :e V) (setprod_coords_in x y X V p Hpsing1 HpR2)). }
        claim HyUV: y :e U :/\: V.
        { exact (binintersectI U V y HyU' HyV'). }
        claim HyE: y :e Empty.
        { rewrite <- HUVempty. exact HyUV. }
        exact (EmptyE y HyE False). }
      { exact (Subq_Empty (R1 :/\: R2)). }
  - assume Hx12n: x1 <> x2.
    (** Separate by x-coordinate using opens in Tx **)
    apply (HSepX x1 x2 Hx1X Hx2X Hx12n).
    let U. assume HexV.
    apply HexV.
    let V. assume HUV_conj.
    apply HUV_conj.
    assume Hcore HUVempty.
    apply Hcore.
    assume Hcore2 Hx2V.
    apply Hcore2.
    assume Hcore3 Hx1U.
    apply Hcore3.
    assume HU HV.
    set R1 := rectangle_set U Y.
    set R2 := rectangle_set V Y.
    witness R1.
    witness R2.
    prove R1 :e product_topology X Tx Y Ty /\ R2 :e product_topology X Tx Y Ty /\ p1 :e R1 /\ p2 :e R2 /\ R1 :/\: R2 = Empty.
    apply andI.
    + apply andI.
      * apply andI.
        { apply andI.
          (** R1 open in product topology **)
          - claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
            { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
            claim HYTy: Y :e Ty.
            { exact (topology_has_X Y Ty HTy). }
            claim HR1sub: R1 :e product_subbasis X Tx Y Ty.
            { prove R1 :e product_subbasis X Tx Y Ty.
              claim HR1fam: rectangle_set U Y :e {rectangle_set U V0|V0 :e Ty}.
              { exact (ReplI Ty (fun V0:set => rectangle_set U V0) Y HYTy). }
              exact (famunionI Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) U (rectangle_set U Y) HU HR1fam). }
            exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis R1 HR1sub).
          (** R2 open in product topology **)
          - claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
            { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
            claim HYTy: Y :e Ty.
            { exact (topology_has_X Y Ty HTy). }
            claim HR2sub: R2 :e product_subbasis X Tx Y Ty.
            { prove R2 :e product_subbasis X Tx Y Ty.
              claim HR2fam: rectangle_set V Y :e {rectangle_set V V0|V0 :e Ty}.
              { exact (ReplI Ty (fun V0:set => rectangle_set V V0) Y HYTy). }
              exact (famunionI Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) V (rectangle_set V Y) HV HR2fam). }
            exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis R2 HR2sub). }
        (** p1 in R1 **)
        { rewrite Hp1eq.
          exact (pair_Sigma U (fun _ : set => Y) x1 Hx1U y1 Hy1Y). }
      (** p2 in R2 **)
      * rewrite Hp2eq.
        exact (pair_Sigma V (fun _ : set => Y) x2 Hx2V y2 Hy2Y).
    (** disjointness of rectangles **)
    + prove R1 :/\: R2 = Empty.
      apply set_ext.
      { let p. assume Hp: p :e R1 :/\: R2.
        prove p :e Empty.
        apply FalseE.
        claim HpR1: p :e R1.
        { exact (binintersectE1 R1 R2 p Hp). }
        claim HpR2: p :e R2.
        { exact (binintersectE2 R1 R2 p Hp). }
        claim Hcoords1: exists x :e U, exists y :e Y, p :e setprod {x} {y}.
        { exact (setprod_elem_decompose U Y p HpR1). }
        apply Hcoords1.
        let x. assume Hx_pair.
        claim HxU': x :e U.
        { exact (andEL (x :e U) (exists y0 :e Y, p :e setprod {x} {y0}) Hx_pair). }
        claim Hexy: exists y0 :e Y, p :e setprod {x} {y0}.
        { exact (andER (x :e U) (exists y0 :e Y, p :e setprod {x} {y0}) Hx_pair). }
        apply Hexy.
        let y. assume Hy_pair.
        claim Hpsing1: p :e setprod {x} {y}.
        { exact (andER (y :e Y) (p :e setprod {x} {y}) Hy_pair). }
        claim Hcoords2: exists x0 :e V, exists y0 :e Y, p :e setprod {x0} {y0}.
        { exact (setprod_elem_decompose V Y p HpR2). }
        apply Hcoords2.
        let x0. assume Hx0_pair.
        claim Hexy0: exists y0 :e Y, p :e setprod {x0} {y0}.
        { exact (andER (x0 :e V) (exists y0 :e Y, p :e setprod {x0} {y0}) Hx0_pair). }
        apply Hexy0.
        let y0. assume Hy0_pair.
        claim Hpsing2: p :e setprod {x0} {y0}.
        { exact (andER (y0 :e Y) (p :e setprod {x0} {y0}) Hy0_pair). }
        claim HxV': x :e V.
        { exact (andEL (x :e V) (y :e Y) (setprod_coords_in x y V Y p Hpsing1 HpR2)). }
        claim HxUV: x :e U :/\: V.
        { exact (binintersectI U V x HxU' HxV'). }
        claim HxE: x :e Empty.
        { rewrite <- HUVempty. exact HxUV. }
        exact (EmptyE x HxE False). }
      { exact (Subq_Empty (R1 :/\: R2)). }
Qed.

(** from 17 Exercises 120: closures, boundaries, Hausdorff properties **) 
(** LATEX VERSION: Exercise 1: Given a notion of closed sets satisfying axioms, prove they come from a topology. **)
Theorem ex17_1_topology_from_closed_sets : forall X Tx:set,
  closed_in X Tx X -> (forall A:set, closed_in X Tx A -> closed_in X Tx (X :\: A)) -> topology_on X Tx.
let X Tx.
assume H1: closed_in X Tx X.
assume H2: forall A:set, closed_in X Tx A -> closed_in X Tx (X :\: A).
prove topology_on X Tx.
(** By definition, closed_in X Tx X means topology_on X Tx /\ ... **)
(** So we can extract topology_on X Tx directly from H1 **)
exact (andEL (topology_on X Tx) (X c= X /\ exists U :e Tx, X = X :\: U) H1).
Qed.

(** LATEX VERSION: Exercise 2: If Y is closed in X and A is closed in the subspace Y, then A is closed in X. **)
Theorem ex17_2_closed_in_closed_subspace : forall X Tx Y A:set,
  closed_in X Tx Y -> closed_in Y (subspace_topology X Tx Y) A -> closed_in X Tx A.
let X Tx Y A.
assume HY: closed_in X Tx Y.
assume HA: closed_in Y (subspace_topology X Tx Y) A.
prove closed_in X Tx A.
(** Extract topology_on X Tx from closed_in X Tx Y and apply closed_in_closed_subspace **)
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (Y c= X /\ exists U :e Tx, Y = X :\: U) HY). }
exact (closed_in_closed_subspace X Tx Y A HTx HY HA).
Qed.

(** LATEX VERSION: Exercise 3: Products of closed sets are closed in the product topology. **)
Theorem ex17_3_product_of_closed_sets_closed : forall X Tx Y Ty A B:set,
  closed_in X Tx A -> closed_in Y Ty B ->
  closed_in (setprod X Y) (product_topology X Tx Y Ty) (setprod A B).
let X Tx Y Ty A B.
assume HA: closed_in X Tx A.
assume HB: closed_in Y Ty B.
prove closed_in (setprod X Y) (product_topology X Tx Y Ty) (setprod A B).
(** Strategy: Show complement of AB is open in product topology.
    (XY) \ (AB) = (X\A)Y  X(Y\B)
    Since A,B closed, X\A,Y\B are open.
    Products of opens are open in product topology.
    Union of two opens is open. **)
(** Extract topologies and components from closed_in **)
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (A c= X /\ exists U :e Tx, A = X :\: U) HA). }
claim HTy: topology_on Y Ty.
{ exact (andEL (topology_on Y Ty) (B c= Y /\ exists V :e Ty, B = Y :\: V) HB). }
claim HAparts: A c= X /\ exists U :e Tx, A = X :\: U.
{ exact (andER (topology_on X Tx) (A c= X /\ exists U :e Tx, A = X :\: U) HA). }
claim HBparts: B c= Y /\ exists V :e Ty, B = Y :\: V.
{ exact (andER (topology_on Y Ty) (B c= Y /\ exists V :e Ty, B = Y :\: V) HB). }
claim HAsub: A c= X.
{ exact (andEL (A c= X) (exists U :e Tx, A = X :\: U) HAparts). }
claim HBsub: B c= Y.
{ exact (andEL (B c= Y) (exists V :e Ty, B = Y :\: V) HBparts). }
claim HexU: exists U :e Tx, A = X :\: U.
{ exact (andER (A c= X) (exists U :e Tx, A = X :\: U) HAparts). }
claim HexV: exists V :e Ty, B = Y :\: V.
{ exact (andER (B c= Y) (exists V :e Ty, B = Y :\: V) HBparts). }
(** Build the closed set property for product **)
claim HTProd: topology_on (setprod X Y) (product_topology X Tx Y Ty).
{ exact (product_topology_is_topology X Tx Y Ty HTx HTy). }
prove topology_on (setprod X Y) (product_topology X Tx Y Ty) /\
      (setprod A B c= setprod X Y /\
       exists W :e product_topology X Tx Y Ty, setprod A B = (setprod X Y) :\: W).
	apply andI.
	- exact HTProd.
	- apply andI.
	  + (** AB  XY **)
	    exact (setprod_Subq A B X Y HAsub HBsub).
	  + (** exists open W such that AB = (XY) \ W **)
	    apply HexU.
	    let U. assume HU_conj.
	    claim HUinTx: U :e Tx.
	    { exact (andEL (U :e Tx) (A = X :\: U) HU_conj). }
	    claim HAeq: A = X :\: U.
	    { exact (andER (U :e Tx) (A = X :\: U) HU_conj). }
	    apply HexV.
	    let V. assume HV_conj.
	    claim HVinTy: V :e Ty.
	    { exact (andEL (V :e Ty) (B = Y :\: V) HV_conj). }
	    claim HBeq: B = Y :\: V.
	    { exact (andER (V :e Ty) (B = Y :\: V) HV_conj). }
	    claim HUsubX: U c= X.
	    { exact (topology_elem_subset X Tx U HTx HUinTx). }
	    claim HVsubY: V c= Y.
	    { exact (topology_elem_subset Y Ty V HTy HVinTy). }
	    claim HXminusA: X :\: A = U.
	    { rewrite HAeq at 1.
	      exact (setminus_setminus_eq X U HUsubX). }
	    claim HYminusB: Y :\: B = V.
	    { rewrite HBeq at 1.
	      exact (setminus_setminus_eq Y V HVsubY). }
	    set W1 := setprod (X :\: A) Y.
	    set W2 := setprod X (Y :\: B).
	    set W := W1 :\/: W2.
	    witness W.
	    apply andI.
	    - (** W is open in product topology **)
	      claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
	      { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
	      claim HW1sub: W1 :e product_subbasis X Tx Y Ty.
	      { prove W1 :e product_subbasis X Tx Y Ty.
	        rewrite HXminusA.
	        claim HYTy: Y :e Ty.
	        { exact (topology_has_X Y Ty HTy). }
	        claim HW1fam: rectangle_set U Y :e {rectangle_set U V0|V0 :e Ty}.
	        { exact (ReplI Ty (fun V0:set => rectangle_set U V0) Y HYTy). }
	        exact (famunionI Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) U (rectangle_set U Y) HUinTx HW1fam). }
	      claim HW2sub: W2 :e product_subbasis X Tx Y Ty.
	      { prove W2 :e product_subbasis X Tx Y Ty.
	        rewrite HYminusB.
	        claim HXTx: X :e Tx.
	        { exact (topology_has_X X Tx HTx). }
	        claim HW2fam: rectangle_set X V :e {rectangle_set X V0|V0 :e Ty}.
	        { exact (ReplI Ty (fun V0:set => rectangle_set X V0) V HVinTy). }
	        exact (famunionI Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) X (rectangle_set X V) HXTx HW2fam). }
	      claim HW1open: W1 :e product_topology X Tx Y Ty.
	      { exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis W1 HW1sub). }
	      claim HW2open: W2 :e product_topology X Tx Y Ty.
	      { exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis W2 HW2sub). }
	      exact (lemma_union_two_open (setprod X Y) (product_topology X Tx Y Ty) W1 W2 HTProd HW1open HW2open).
	    - (** AB is complement of W **)
	      prove setprod A B = setprod X Y :\: W.
	      apply set_ext.
	      + let p. assume Hp: p :e setprod A B.
	        prove p :e setprod X Y :\: W.
	        claim HpXY: p :e setprod X Y.
	        { exact ((setprod_Subq A B X Y HAsub HBsub) p Hp). }
	        claim Hexab: exists x :e A, exists y :e B, p :e setprod {x} {y}.
	        { exact (setprod_elem_decompose A B p Hp). }
		        claim HpNotW: p /:e W.
		        { apply Hexab.
		          let x. assume Hx_conj.
		          claim HxA': x :e A.
		          { exact (andEL (x :e A) (exists y0 :e B, p :e setprod {x} {y0}) Hx_conj). }
		          claim Hexy: exists y0 :e B, p :e setprod {x} {y0}.
		          { exact (andER (x :e A) (exists y0 :e B, p :e setprod {x} {y0}) Hx_conj). }
		          apply Hexy.
		          let y. assume Hy_conj.
		          claim HyB: y :e B.
		          { exact (andEL (y :e B) (p :e setprod {x} {y}) Hy_conj). }
		          claim Hpsing: p :e setprod {x} {y}.
		          { exact (andER (y :e B) (p :e setprod {x} {y}) Hy_conj). }
		          assume HpW: p :e W.
		          apply (binunionE W1 W2 p HpW).
		          - assume HpW1: p :e W1.
		            claim Hxy: x :e (X :\: A) /\ y :e Y.
		            { exact (setprod_coords_in x y (X :\: A) Y p Hpsing HpW1). }
		            claim HxXA: x :e X :\: A.
		            { exact (andEL (x :e X :\: A) (y :e Y) Hxy). }
		            exact ((setminusE2 X A x HxXA) HxA').
	          - assume HpW2: p :e W2.
	            claim Hxy: x :e X /\ y :e (Y :\: B).
	            { exact (setprod_coords_in x y X (Y :\: B) p Hpsing HpW2). }
	            claim HyYB: y :e Y :\: B.
	            { exact (andER (x :e X) (y :e Y :\: B) Hxy). }
		            exact ((setminusE2 Y B y HyYB) HyB). }
		        exact (setminusI (setprod X Y) W p HpXY HpNotW).
	      + let p. assume Hp: p :e setprod X Y :\: W.
	        prove p :e setprod A B.
	        claim HpXY: p :e setprod X Y.
	        { exact (setminusE1 (setprod X Y) W p Hp). }
	        claim HpNotW: p /:e W.
	        { exact (setminusE2 (setprod X Y) W p Hp). }
		        claim Hexxy: exists x :e X, exists y :e Y, p :e setprod {x} {y}.
		        { exact (setprod_elem_decompose X Y p HpXY). }
		        apply Hexxy.
		        let x. assume Hx_conj.
		        claim HxX: x :e X.
		        { exact (andEL (x :e X) (exists y0 :e Y, p :e setprod {x} {y0}) Hx_conj). }
		        claim Hexy: exists y0 :e Y, p :e setprod {x} {y0}.
		        { exact (andER (x :e X) (exists y0 :e Y, p :e setprod {x} {y0}) Hx_conj). }
		        apply Hexy.
		        let y. assume Hy_conj.
		        claim HyY: y :e Y.
		        { exact (andEL (y :e Y) (p :e setprod {x} {y}) Hy_conj). }
		        claim Hpsing: p :e setprod {x} {y}.
		        { exact (andER (y :e Y) (p :e setprod {x} {y}) Hy_conj). }
		        claim HxA: x :e A.
	        { apply (xm (x :e A)).
	          - assume H. exact H.
	          - assume HxNotA: ~(x :e A).
	            claim HxXA: x :e X :\: A.
	            { exact (setminusI X A x HxX HxNotA). }
	            claim HxSingSub: {x} c= X :\: A.
	            { exact (singleton_subset x (X :\: A) HxXA). }
	            claim HySingSub: {y} c= Y.
	            { exact (singleton_subset y Y HyY). }
	            claim HpW1: p :e W1.
	            { claim Hsub: setprod {x} {y} c= W1.
	              { exact (setprod_Subq {x} {y} (X :\: A) Y HxSingSub HySingSub). }
	              exact (Hsub p Hpsing). }
	            apply FalseE.
	            exact (HpNotW (binunionI1 W1 W2 p HpW1)). }
	        claim HyB: y :e B.
	        { apply (xm (y :e B)).
	          - assume H. exact H.
	          - assume HyNotB: ~(y :e B).
	            claim HyYB: y :e Y :\: B.
	            { exact (setminusI Y B y HyY HyNotB). }
	            claim HySingSub: {y} c= Y :\: B.
	            { exact (singleton_subset y (Y :\: B) HyYB). }
	            claim HxSingSub: {x} c= X.
	            { exact (singleton_subset x X HxX). }
	            claim HpW2: p :e W2.
	            { claim Hsub: setprod {x} {y} c= W2.
	              { exact (setprod_Subq {x} {y} X (Y :\: B) HxSingSub HySingSub). }
	              exact (Hsub p Hpsing). }
	            apply FalseE.
	            exact (HpNotW (binunionI2 W1 W2 p HpW2)). }
	        claim HxSingSubA: {x} c= A.
	        { exact (singleton_subset x A HxA). }
	        claim HySingSubB: {y} c= B.
	        { exact (singleton_subset y B HyB). }
	        claim HpAB: p :e setprod A B.
	        { claim Hsub: setprod {x} {y} c= setprod A B.
	          { exact (setprod_Subq {x} {y} A B HxSingSubA HySingSubB). }
	          exact (Hsub p Hpsing). }
	        exact HpAB.
Qed.

(** LATEX VERSION: Exercise 4: For open U and closed A, U\\A is open and A\\U is closed. **)
Theorem ex17_4_open_minus_closed_and_closed_minus_open : forall X Tx U A:set,
  topology_on X Tx -> open_in X Tx U -> closed_in X Tx A ->
  open_in X Tx (U :\: A) /\ closed_in X Tx (A :\: U).
let X Tx U A.
assume Htop: topology_on X Tx.
assume HU: open_in X Tx U.
assume HA: closed_in X Tx A.
prove open_in X Tx (U :\: A) /\ closed_in X Tx (A :\: U).
(** Strategy: U\A = U  V for some V open (from A = X\V); A\U = A  (X\U) closed **)
claim HUtop: U :e Tx.
{ exact (andER (topology_on X Tx) (U :e Tx) HU). }
claim HAdef: A c= X /\ (exists V :e Tx, A = X :\: V).
{ exact (andER (topology_on X Tx) (A c= X /\ (exists V :e Tx, A = X :\: V)) HA). }
claim HexV: exists V :e Tx, A = X :\: V.
{ exact (andER (A c= X) (exists V :e Tx, A = X :\: V) HAdef). }
apply HexV.
let V. assume HVandEq. apply HVandEq.
assume HV: V :e Tx.
assume HAeq: A = X :\: V.
apply andI.
- prove open_in X Tx (U :\: A).
  (** U :\: A = U :\: (X :\: V) = U :/\: V when U c= X **)
  claim HUsub: U c= X.
  { exact (topology_elem_subset X Tx U Htop HUtop). }
  claim HUminusA_eq_UinterV: U :\: A = U :/\: V.
  { rewrite HAeq.
    apply set_ext.
    + let x. assume Hx: x :e U :\: (X :\: V).
      claim HxU: x :e U.
      { exact (setminusE1 U (X :\: V) x Hx). }
      claim HxnotXV: x /:e X :\: V.
      { exact (setminusE2 U (X :\: V) x Hx). }
      claim HxV: x :e V.
      { claim HxX: x :e X.
        { exact (HUsub x HxU). }
        apply xm (x :e V).
        * assume Hv. exact Hv.
        * assume Hnv.
          apply FalseE.
          apply HxnotXV.
          exact (setminusI X V x HxX Hnv). }
      exact (binintersectI U V x HxU HxV).
    + let x. assume Hx: x :e U :/\: V.
      claim HxU: x :e U.
      { exact (binintersectE1 U V x Hx). }
      claim HxV: x :e V.
      { exact (binintersectE2 U V x Hx). }
      claim HxnotXV: x /:e X :\: V.
      { assume H. apply (setminusE2 X V x H). exact HxV. }
      exact (setminusI U (X :\: V) x HxU HxnotXV). }
  rewrite HUminusA_eq_UinterV.
  claim HUinterV: U :/\: V :e Tx.
  { exact (topology_binintersect_closed X Tx U V Htop HUtop HV). }
  exact (andI (topology_on X Tx) (U :/\: V :e Tx) Htop HUinterV).
- prove closed_in X Tx (A :\: U).
  (** A :\: U = (X :\: V) :\: U = X :\: (V :\/: U), and V :\/: U is open **)
  claim HAsub: A c= X.
  { exact (andEL (A c= X) (exists V0 :e Tx, A = X :\: V0) HAdef). }
  claim HAminusU_sub: A :\: U c= X.
  { let x. assume Hx. claim HxA: x :e A. { exact (setminusE1 A U x Hx). }
    exact (HAsub x HxA). }
  claim HVU: V :\/: U :e Tx.
  { exact (lemma_union_two_open X Tx V U Htop HV HUtop). }
  claim HAminusU_eq_XminusVU: A :\: U = X :\: (V :\/: U).
  { rewrite HAeq.
    apply set_ext.
    + let x. assume Hx: x :e (X :\: V) :\: U.
      claim HxXV: x :e X :\: V.
      { exact (setminusE1 (X :\: V) U x Hx). }
      claim HxnotU: x /:e U.
      { exact (setminusE2 (X :\: V) U x Hx). }
      claim HxX: x :e X.
      { exact (setminusE1 X V x HxXV). }
      claim HxnotV: x /:e V.
      { exact (setminusE2 X V x HxXV). }
      claim HxnotVU: x /:e V :\/: U.
      { assume H. apply (binunionE V U x H).
        - assume HxV. exact (HxnotV HxV).
        - assume HxU. exact (HxnotU HxU). }
      exact (setminusI X (V :\/: U) x HxX HxnotVU).
    + let x. assume Hx: x :e X :\: (V :\/: U).
      claim HxX: x :e X.
      { exact (setminusE1 X (V :\/: U) x Hx). }
      claim HxnotVU: x /:e V :\/: U.
      { exact (setminusE2 X (V :\/: U) x Hx). }
      claim HxnotV: x /:e V.
      { assume HxV. apply HxnotVU. exact (binunionI1 V U x HxV). }
      claim HxnotU: x /:e U.
      { assume HxU. apply HxnotVU. exact (binunionI2 V U x HxU). }
      claim HxXV: x :e X :\: V.
      { exact (setminusI X V x HxX HxnotV). }
      exact (setminusI (X :\: V) U x HxXV HxnotU). }
  claim HPred: exists W :e Tx, A :\: U = X :\: W.
  { witness (V :\/: U).
    apply andI.
    - exact HVU.
    - exact HAminusU_eq_XminusVU. }
  exact (andI (topology_on X Tx) (A :\: U c= X /\ (exists W :e Tx, A :\: U = X :\: W)) Htop (andI (A :\: U c= X) (exists W :e Tx, A :\: U = X :\: W) HAminusU_sub HPred)).
Qed.

(** LATEX VERSION: Exercise 5: Let X be an ordered set in the order topology. Show that cl((a,b)) c= [a,b]. Under what conditions does equality hold **)
Axiom ex17_5_closure_of_interval_in_order_topology_axiom : forall X a b:set,
  closure_of X (order_topology X) (order_interval X a b) c= closed_interval_in X a b.
Theorem ex17_5_closure_of_interval_in_order_topology : forall X a b:set,
  closure_of X (order_topology X) (order_interval X a b) c= closed_interval_in X a b.
let X a b.
prove closure_of X (order_topology X) (order_interval X a b) c= closed_interval_in X a b.
exact (ex17_5_closure_of_interval_in_order_topology_axiom X a b).
Qed.

(** Helper definition for Exercise 5: no immediate successor and predecessor endpoints **)
Definition no_immediate_successor : set -> set -> prop := fun X a =>
  forall c:set, c :e X -> order_rel X a c ->
    exists x:set, x :e X /\ order_rel X a x /\ order_rel X x c.

Definition no_immediate_predecessor : set -> set -> prop := fun X b =>
  forall c:set, c :e X -> order_rel X c b ->
    exists x:set, x :e X /\ order_rel X c x /\ order_rel X x b.

(** LATEX VERSION: Exercise 5: Equality holds when the endpoints are limit points of (a,b) from within X, e.g. in a dense order without gaps **)
Axiom ex17_5_closure_of_interval_eq_conditions_axiom : forall X a b:set,
  a :e X -> b :e X -> order_rel X a b ->
  no_immediate_successor X a ->
  no_immediate_predecessor X b ->
  closure_of X (order_topology X) (order_interval X a b) = closed_interval_in X a b.
Theorem ex17_5_closure_of_interval_eq_conditions : forall X a b:set,
  a :e X -> b :e X -> order_rel X a b ->
  no_immediate_successor X a ->
  no_immediate_predecessor X b ->
  closure_of X (order_topology X) (order_interval X a b) = closed_interval_in X a b.
let X a b.
assume Ha: a :e X.
assume Hb: b :e X.
assume Hab: order_rel X a b.
assume Hsucc: no_immediate_successor X a.
assume Hpred: no_immediate_predecessor X b.
prove closure_of X (order_topology X) (order_interval X a b) = closed_interval_in X a b.
exact (ex17_5_closure_of_interval_eq_conditions_axiom X a b Ha Hb Hab Hsucc Hpred).
Qed.

(** Helper: closure is idempotent and closed **)
(** LATEX VERSION: Closure is closed and idempotent: cl(cl(A)) = cl(A), and cl(A) is closed **)
Theorem closure_idempotent_and_closed : forall X Tx A:set,
  topology_on X Tx ->
  closure_of X Tx (closure_of X Tx A) = closure_of X Tx A /\
  closed_in X Tx (closure_of X Tx A).
let X Tx A.
assume Htop: topology_on X Tx.
prove closure_of X Tx (closure_of X Tx A) = closure_of X Tx A /\ closed_in X Tx (closure_of X Tx A).
(** Strategy: Prove part 2 first (cl(A) is closed), then use it for part 1 (idempotence) **)
set clA := closure_of X Tx A.
claim HclA_sub: clA c= X.
{ let x. assume Hx: x :e clA.
  prove x :e X.
  exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx). }
(** To prove clA is closed, we would normally apply closure_is_closed, but that requires clA c= X
    which we have. However, closure_is_closed X Tx clA gives us closed_in X Tx (closure_of X Tx clA),
    not closed_in X Tx clA. We need a more direct proof that closure is closed. **)
apply andI.
- (** cl(cl(A)) = cl(A) - idempotence follows from closure being closed **)
  prove closure_of X Tx clA = clA.
  claim HclA_closed: closed_in X Tx clA.
  { (** Apply closure_is_closed with (A :/\: X) instead of A **)
    (** Since closure_of X Tx (A :/\: X) = closure_of X Tx A, and (A :/\: X) c= X **)
    claim HAX_sub: A :/\: X c= X.
    { exact (binintersect_Subq_2 A X). }
    claim Heq_closure: closure_of X Tx (A :/\: X) = closure_of X Tx A.
    { apply set_ext.
      - let x. assume Hx: x :e closure_of X Tx (A :/\: X).
        prove x :e closure_of X Tx A.
        claim HxX: x :e X.
        { exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: (A :/\: X) <> Empty) x Hx). }
        claim Hcond: forall U:set, U :e Tx -> x :e U -> U :/\: (A :/\: X) <> Empty.
        { exact (SepE2 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: (A :/\: X) <> Empty) x Hx). }
        claim Hpred: forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
        { let U. assume HU: U :e Tx. assume HxU: x :e U.
          claim HUX: U c= X.
          { exact (topology_elem_subset X Tx U Htop HU). }
          claim Hinter1: U :/\: (A :/\: X) <> Empty.
          { exact (Hcond U HU HxU). }
          (** U :/\: (A :/\: X) = (U :/\: A) :/\: X, but since U c= X, this equals U :/\: A **)
          claim Heq_inter: U :/\: (A :/\: X) = U :/\: A.
          { apply set_ext.
            - let y. assume Hy: y :e U :/\: (A :/\: X).
              claim HyU: y :e U.
              { exact (binintersectE1 U (A :/\: X) y Hy). }
              claim HyAX: y :e A :/\: X.
              { exact (binintersectE2 U (A :/\: X) y Hy). }
              claim HyA: y :e A.
              { exact (binintersectE1 A X y HyAX). }
              exact (binintersectI U A y HyU HyA).
            - let y. assume Hy: y :e U :/\: A.
              claim HyU: y :e U.
              { exact (binintersectE1 U A y Hy). }
              claim HyA: y :e A.
              { exact (binintersectE2 U A y Hy). }
              claim HyX: y :e X.
              { exact (HUX y HyU). }
              claim HyAX: y :e A :/\: X.
              { exact (binintersectI A X y HyA HyX). }
              exact (binintersectI U (A :/\: X) y HyU HyAX). }
          rewrite <- Heq_inter.
          exact Hinter1. }
        exact (SepI X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x HxX Hpred).
      - let x. assume Hx: x :e closure_of X Tx A.
        prove x :e closure_of X Tx (A :/\: X).
        claim HxX: x :e X.
        { exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx). }
        claim Hcond: forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
        { exact (SepE2 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx). }
        claim Hpred: forall U:set, U :e Tx -> x :e U -> U :/\: (A :/\: X) <> Empty.
        { let U. assume HU: U :e Tx. assume HxU: x :e U.
          claim HUX: U c= X.
          { exact (topology_elem_subset X Tx U Htop HU). }
          claim Hinter1: U :/\: A <> Empty.
          { exact (Hcond U HU HxU). }
          claim Heq_inter: U :/\: (A :/\: X) = U :/\: A.
          { apply set_ext.
            - let y. assume Hy: y :e U :/\: (A :/\: X).
              claim HyU: y :e U.
              { exact (binintersectE1 U (A :/\: X) y Hy). }
              claim HyAX: y :e A :/\: X.
              { exact (binintersectE2 U (A :/\: X) y Hy). }
              claim HyA: y :e A.
              { exact (binintersectE1 A X y HyAX). }
              exact (binintersectI U A y HyU HyA).
            - let y. assume Hy: y :e U :/\: A.
              claim HyU: y :e U.
              { exact (binintersectE1 U A y Hy). }
              claim HyA: y :e A.
              { exact (binintersectE2 U A y Hy). }
              claim HyX: y :e X.
              { exact (HUX y HyU). }
              claim HyAX: y :e A :/\: X.
              { exact (binintersectI A X y HyA HyX). }
              exact (binintersectI U (A :/\: X) y HyU HyAX). }
          rewrite Heq_inter.
          exact Hinter1. }
        exact (SepI X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: (A :/\: X) <> Empty) x HxX Hpred).
    }
    rewrite <- Heq_closure.
    exact (closure_is_closed X Tx (A :/\: X) Htop HAX_sub).
  }
  exact (closed_closure_eq X Tx clA Htop HclA_closed).
- (** cl(A) is closed **)
  prove closed_in X Tx clA.
  (** Same proof as above **)
  claim HAX_sub: A :/\: X c= X.
  { exact (binintersect_Subq_2 A X). }
  claim Heq_closure: closure_of X Tx (A :/\: X) = closure_of X Tx A.
  { apply set_ext.
    - let x. assume Hx: x :e closure_of X Tx (A :/\: X).
      prove x :e closure_of X Tx A.
      claim HxX: x :e X.
      { exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: (A :/\: X) <> Empty) x Hx). }
      claim Hcond: forall U:set, U :e Tx -> x :e U -> U :/\: (A :/\: X) <> Empty.
      { exact (SepE2 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: (A :/\: X) <> Empty) x Hx). }
      claim Hpred: forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
      { let U. assume HU: U :e Tx. assume HxU: x :e U.
        claim HUX: U c= X.
        { exact (topology_elem_subset X Tx U Htop HU). }
        claim Hinter1: U :/\: (A :/\: X) <> Empty.
        { exact (Hcond U HU HxU). }
        claim Heq_inter: U :/\: (A :/\: X) = U :/\: A.
        { apply set_ext.
          - let y. assume Hy: y :e U :/\: (A :/\: X).
            claim HyU: y :e U.
            { exact (binintersectE1 U (A :/\: X) y Hy). }
            claim HyAX: y :e A :/\: X.
            { exact (binintersectE2 U (A :/\: X) y Hy). }
            claim HyA: y :e A.
            { exact (binintersectE1 A X y HyAX). }
            exact (binintersectI U A y HyU HyA).
          - let y. assume Hy: y :e U :/\: A.
            claim HyU: y :e U.
            { exact (binintersectE1 U A y Hy). }
            claim HyA: y :e A.
            { exact (binintersectE2 U A y Hy). }
            claim HyX: y :e X.
            { exact (HUX y HyU). }
            claim HyAX: y :e A :/\: X.
            { exact (binintersectI A X y HyA HyX). }
            exact (binintersectI U (A :/\: X) y HyU HyAX). }
        rewrite <- Heq_inter.
        exact Hinter1. }
      exact (SepI X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x HxX Hpred).
    - let x. assume Hx: x :e closure_of X Tx A.
      prove x :e closure_of X Tx (A :/\: X).
      claim HxX: x :e X.
      { exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx). }
      claim Hcond: forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
      { exact (SepE2 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x Hx). }
      claim Hpred: forall U:set, U :e Tx -> x :e U -> U :/\: (A :/\: X) <> Empty.
      { let U. assume HU: U :e Tx. assume HxU: x :e U.
        claim HUX: U c= X.
        { exact (topology_elem_subset X Tx U Htop HU). }
        claim Hinter1: U :/\: A <> Empty.
        { exact (Hcond U HU HxU). }
        claim Heq_inter: U :/\: (A :/\: X) = U :/\: A.
        { apply set_ext.
          - let y. assume Hy: y :e U :/\: (A :/\: X).
            claim HyU: y :e U.
            { exact (binintersectE1 U (A :/\: X) y Hy). }
            claim HyAX: y :e A :/\: X.
            { exact (binintersectE2 U (A :/\: X) y Hy). }
            claim HyA: y :e A.
            { exact (binintersectE1 A X y HyAX). }
            exact (binintersectI U A y HyU HyA).
          - let y. assume Hy: y :e U :/\: A.
            claim HyU: y :e U.
            { exact (binintersectE1 U A y Hy). }
            claim HyA: y :e A.
            { exact (binintersectE2 U A y Hy). }
            claim HyX: y :e X.
            { exact (HUX y HyU). }
            claim HyAX: y :e A :/\: X.
            { exact (binintersectI A X y HyA HyX). }
            exact (binintersectI U (A :/\: X) y HyU HyAX). }
        rewrite Heq_inter.
        exact Hinter1. }
      exact (SepI X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: (A :/\: X) <> Empty) x HxX Hpred).
  }
  rewrite <- Heq_closure.
  exact (closure_is_closed X Tx (A :/\: X) Htop HAX_sub).
Qed.

(** from 17 Exercise 6(a): monotonicity of closure **)
(** LATEX VERSION: If A c= B then cl(A) c= cl(B). **)
Theorem ex17_6a_closure_monotone : forall X Tx A B:set,
  topology_on X Tx -> A c= B -> B c= X -> closure_of X Tx A c= closure_of X Tx B.
let X Tx A B.
assume Htop: topology_on X Tx.
assume HAB: A c= B.
assume HB: B c= X.
prove closure_of X Tx A c= closure_of X Tx B.
exact (closure_monotone X Tx A B Htop HAB HB).
Qed.

(** from 17 Exercise 6(b): closure of a union **)
(** LATEX VERSION: cl(A :\/: B) = cl(A) :\/: cl(B). **)
Theorem ex17_6b_closure_binunion : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  closure_of X Tx (A :\/: B) = closure_of X Tx A :\/: closure_of X Tx B.
let X Tx A B.
assume Htop: topology_on X Tx.
assume HA: A c= X.
assume HB: B c= X.
prove closure_of X Tx (A :\/: B) = closure_of X Tx A :\/: closure_of X Tx B.
set clA := closure_of X Tx A.
set clB := closure_of X Tx B.
apply set_ext.
- (** closure(AB) c= cl(A)  cl(B) **)
  claim Hsup: closure_of X Tx (A :\/: B) c= clA :\/: clB.
  { (** clA  clB is closed and contains A  B **)
    claim HclA_closed: closed_in X Tx clA.
    { claim Hc: closure_of X Tx (closure_of X Tx A) = closure_of X Tx A /\ closed_in X Tx (closure_of X Tx A).
      { exact (closure_idempotent_and_closed X Tx A Htop). }
      exact (andER (closure_of X Tx (closure_of X Tx A) = closure_of X Tx A) (closed_in X Tx (closure_of X Tx A)) Hc). }
    claim HclB_closed: closed_in X Tx clB.
    { claim Hc: closure_of X Tx (closure_of X Tx B) = closure_of X Tx B /\ closed_in X Tx (closure_of X Tx B).
      { exact (closure_idempotent_and_closed X Tx B Htop). }
      exact (andER (closure_of X Tx (closure_of X Tx B) = closure_of X Tx B) (closed_in X Tx (closure_of X Tx B)) Hc). }
    claim HclUnionClosed: closed_in X Tx (clA :\/: clB).
    { exact (union_of_closed_is_closed X Tx clA clB Htop HclA_closed HclB_closed). }
    claim HABsub: A :\/: B c= clA :\/: clB.
    { let y. assume Hy: y :e A :\/: B.
      apply (binunionE A B y Hy).
      - assume HyA: y :e A.
        claim HyclA: y :e clA.
        { exact (subset_of_closure X Tx A Htop HA y HyA). }
        exact (binunionI1 clA clB y HyclA).
      - assume HyB: y :e B.
        claim HyclB: y :e clB.
        { exact (subset_of_closure X Tx B Htop HB y HyB). }
        exact (binunionI2 clA clB y HyclB). }
    exact (closure_subset_of_closed_superset X Tx (A :\/: B) (clA :\/: clB) Htop HABsub HclUnionClosed). }
  let x. assume Hx: x :e closure_of X Tx (A :\/: B).
  exact (Hsup x Hx).
- (** cl(A)  cl(B) c= closure(AB) **)
  claim Hsub: clA :\/: clB c= closure_of X Tx (A :\/: B).
  { exact (closure_union_contains_union_closures X Tx A B Htop HA HB). }
  exact Hsub.
Qed.

(** from 17 Exercise 6(c): closure of an arbitrary union contains union of closures **)
(** LATEX VERSION: cl(Union A_alpha) c=?; always have cl(Union A_alpha) c>= Union cl(A_alpha). **)
Theorem ex17_6c_closure_Union_contains_Union_closures : forall X Tx Fam:set,
  topology_on X Tx ->
  (forall A:set, A :e Fam -> A c= X) ->
  Union {closure_of X Tx A|A :e Fam} c= closure_of X Tx (Union Fam).
let X Tx Fam.
assume Htop: topology_on X Tx.
assume HFsub: forall A:set, A :e Fam -> A c= X.
prove Union {closure_of X Tx A|A :e Fam} c= closure_of X Tx (Union Fam).
set ClFam := {closure_of X Tx A|A :e Fam}.
claim HUnionSubX: Union Fam c= X.
{ let x. assume Hx: x :e Union Fam.
  apply (UnionE_impred Fam x Hx).
  let A. assume HxA. assume HAFam.
  exact ((HFsub A HAFam) x HxA). }
let x. assume Hx: x :e Union ClFam.
prove x :e closure_of X Tx (Union Fam).
apply (UnionE_impred ClFam x Hx).
let W. assume HxW. assume HWClFam.
apply (ReplE Fam (fun A:set => closure_of X Tx A) W HWClFam).
let A. assume HAconj.
claim HAFam: A :e Fam.
{ exact (andEL (A :e Fam) (W = closure_of X Tx A) HAconj). }
claim HWeq: W = closure_of X Tx A.
{ exact (andER (A :e Fam) (W = closure_of X Tx A) HAconj). }
claim HxclA: x :e closure_of X Tx A.
{ rewrite <- HWeq. exact HxW. }
claim HASubUnion: A c= Union Fam.
{ let y. assume Hy: y :e A.
  exact (UnionI Fam y A Hy HAFam). }
claim HxclUnion: x :e closure_of X Tx (Union Fam).
{ exact (closure_monotone X Tx A (Union Fam) Htop HASubUnion HUnionSubX x HxclA). }
exact HxclUnion.
Qed.

(** from 17 Exercise 7: critique the attempted proof about closures of unions **)
(** LATEX VERSION: Criticize the proof that cl(Union A_alpha) c= Union cl(A_alpha). **)
Theorem ex17_7_counterexample_union_closure :
  exists X Tx Fam:set,
    topology_on X Tx /\
    (forall A:set, A :e Fam -> A c= X) /\
    ~ (closure_of X Tx (Union Fam) c= Union {closure_of X Tx A|A :e Fam}).
claim HXomega: 0 :e omega.
{ exact (nat_p_omega 0 nat_0). }
witness omega.
witness (finite_complement_topology omega).
set X := omega.
set Tx := finite_complement_topology omega.
set Fam := {{n}|n :e X :\: {0}}.
witness Fam.
prove topology_on X Tx /\ (forall A:set, A :e Fam -> A c= X) /\ ~ (closure_of X Tx (Union Fam) c= Union {closure_of X Tx A|A :e Fam}).
apply andI.
- (** topology and subset property **)
  apply andI.
  + exact (finite_complement_topology_on X).
  + (** every member of Fam is a subset of X **)
    let A. assume HA: A :e Fam.
    prove A c= X.
    apply (ReplE (X :\: {0}) (fun n:set => {n}) A HA).
    let n. assume Hnconj.
    claim HninX0: n :e X :\: {0}.
    { exact (andEL (n :e X :\: {0}) (A = {n}) Hnconj). }
    claim HAeq: A = {n}.
    { exact (andER (n :e X :\: {0}) (A = {n}) Hnconj). }
    rewrite HAeq.
    let x. assume Hx: x :e {n}.
    claim HxEq: x = n.
    { exact (SingE n x Hx). }
    rewrite HxEq.
    exact (setminusE1 X {0} n HninX0).
- (** counterexample element: 0 **)
  prove ~ (closure_of X Tx (Union Fam) c= Union {closure_of X Tx A|A :e Fam}).
  assume Hsub: closure_of X Tx (Union Fam) c= Union {closure_of X Tx A|A :e Fam}.
    set ClFam := {closure_of X Tx A|A :e Fam}.
    claim Htop: topology_on X Tx.
    { exact (finite_complement_topology_on X). }
    (** Union Fam = X\\{0} **)
    claim HUnionEq: Union Fam = X :\: {0}.
    { apply set_ext.
      - let x. assume Hx: x :e Union Fam.
        prove x :e X :\: {0}.
        apply (UnionE_impred Fam x Hx).
        let A. assume HxA. assume HAFam.
        apply (ReplE (X :\: {0}) (fun n:set => {n}) A HAFam).
        let n. assume Hnconj.
        claim HninX0: n :e X :\: {0}.
        { exact (andEL (n :e X :\: {0}) (A = {n}) Hnconj). }
        claim HAeq: A = {n}.
        { exact (andER (n :e X :\: {0}) (A = {n}) Hnconj). }
        claim HxEq: x = n.
        { claim HxSing: x :e {n}.
          { rewrite <- HAeq. exact HxA. }
          exact (SingE n x HxSing). }
        rewrite HxEq.
        exact HninX0.
      - let x. assume Hx: x :e X :\: {0}.
        prove x :e Union Fam.
        claim HSingFam: {x} :e Fam.
        { exact (ReplI (X :\: {0}) (fun n:set => {n}) x Hx). }
        exact (UnionI Fam x {x} (SingI x) HSingFam).
    }
    (** X\\{0} is infinite, so Union Fam is infinite **)
    claim HsubXX: X c= X.
    { let x. assume Hx: x :e X. exact Hx. }
    claim Hatleast: atleastp omega X.
    { exact (Subq_atleastp omega X HsubXX). }
    claim HinfX: infinite X.
    { exact (atleastp_omega_infinite X Hatleast). }
    claim HinfUnion: infinite (Union Fam).
    { rewrite HUnionEq.
      exact (infinite_remove1 X HinfX 0). }
    (** 0 is in closure(Union Fam) **)
    claim H0in_closure: 0 :e closure_of X Tx (Union Fam).
    { apply (iffER (0 :e closure_of X Tx (Union Fam))
                   (forall U :e Tx, 0 :e U -> U :/\: (Union Fam) <> Empty)
                   (closure_characterization X Tx (Union Fam) 0 Htop HXomega)).
      let U. assume HU: U :e Tx. assume H0U: 0 :e U.
      prove U :/\: (Union Fam) <> Empty.
      claim HUdata: finite (X :\: U) \/ U = Empty.
      { exact (SepE2 (Power X) (fun U0:set => finite (X :\: U0) \/ U0 = Empty) U HU). }
      apply HUdata (U :/\: (Union Fam) <> Empty).
      - assume HUfin: finite (X :\: U).
        prove U :/\: (Union Fam) <> Empty.
        assume Hinter: U :/\: (Union Fam) = Empty.
        (** show Union Fam  X\\U, hence finite, contradiction **)
        claim Hsub: Union Fam c= X :\: U.
        { let x. assume HxUFam: x :e Union Fam.
          prove x :e X :\: U.
          claim HxX: x :e X.
          { apply (UnionE_impred Fam x HxUFam).
            let A. assume HxA. assume HAFam.
            apply (ReplE (X :\: {0}) (fun n:set => {n}) A HAFam).
            let n. assume Hnconj.
            claim HninX0: n :e X :\: {0}.
            { exact (andEL (n :e X :\: {0}) (A = {n}) Hnconj). }
            claim HAeq: A = {n}.
            { exact (andER (n :e X :\: {0}) (A = {n}) Hnconj). }
            claim HxEq: x = n.
            { claim HxSing: x :e {n}.
              { rewrite <- HAeq. exact HxA. }
              exact (SingE n x HxSing). }
            rewrite HxEq.
            exact (setminusE1 X {0} n HninX0). }
          claim HxnotU: x /:e U.
          { assume HxU: x :e U.
            claim HxInter: x :e U :/\: (Union Fam).
            { apply binintersectI.
              - exact HxU.
              - exact HxUFam. }
            claim HxEmpty: x :e Empty.
            { rewrite <- Hinter. exact HxInter. }
            exact (EmptyE x HxEmpty). }
          exact (setminusI X U x HxX HxnotU). }
        claim HfinUFam: finite (Union Fam).
        { exact (Subq_finite (X :\: U) HUfin (Union Fam) Hsub). }
        apply HinfUnion.
        exact HfinUFam.
      - assume HUempty: U = Empty.
        prove U :/\: (Union Fam) <> Empty.
        assume Hinter: U :/\: (Union Fam) = Empty.
        claim HUne: U <> Empty.
        { exact (elem_implies_nonempty U 0 H0U). }
        apply FalseE.
        exact (HUne HUempty). }
    (** 0 is not in the union of the closures **)
    claim H0not_union_closures: 0 /:e Union ClFam.
    { assume H0in: 0 :e Union ClFam.
      apply (UnionE_impred ClFam 0 H0in).
      let W. assume H0W: 0 :e W. assume HWCl: W :e ClFam.
      apply (ReplE Fam (fun A:set => closure_of X Tx A) W HWCl).
      let A. assume HAconj.
      claim HAFam: A :e Fam.
      { exact (andEL (A :e Fam) (W = closure_of X Tx A) HAconj). }
      claim HWeq: W = closure_of X Tx A.
      { exact (andER (A :e Fam) (W = closure_of X Tx A) HAconj). }
      claim H0clA: 0 :e closure_of X Tx A.
      { rewrite <- HWeq. exact H0W. }
      apply (ReplE (X :\: {0}) (fun n:set => {n}) A HAFam).
      let n. assume Hnconj.
      claim HninX0: n :e X :\: {0}.
      { exact (andEL (n :e X :\: {0}) (A = {n}) Hnconj). }
      claim HAeq: A = {n}.
      { exact (andER (n :e X :\: {0}) (A = {n}) Hnconj). }
      claim HninX: n :e X.
      { exact (setminusE1 X {0} n HninX0). }
      claim HSingSub: {n} c= X.
      { let x. assume Hx: x :e {n}.
        claim HxEq: x = n.
        { exact (SingE n x Hx). }
        rewrite HxEq.
        exact HninX. }
      claim Hclosed: closed_in X Tx {n}.
      { prove topology_on X Tx /\ ({n} c= X /\ exists U :e Tx, {n} = X :\: U).
        apply andI.
        - exact Htop.
        - apply andI.
          + exact HSingSub.
          + witness (X :\: {n}).
            apply andI.
            * (** X\\{n} is open in the finite complement topology **)
              claim HUpow: (X :\: {n}) :e Power X.
              { exact (setminus_In_Power X {n}). }
              claim HfinComp: finite (X :\: (X :\: {n})).
              { rewrite (setminus_setminus_eq X {n} HSingSub).
                exact (Sing_finite n). }
              exact (SepI (Power X) (fun U0:set => finite (X :\: U0) \/ U0 = Empty)
                          (X :\: {n})
                          HUpow
                          (orIL (finite (X :\: (X :\: {n}))) ((X :\: {n}) = Empty) HfinComp)).
            * (** {n} = X\\(X\\{n}) **)
              rewrite (setminus_setminus_eq X {n} HSingSub).
              reflexivity. }
      claim Heq_cl: closure_of X Tx {n} = {n}.
      { exact (closed_closure_eq X Tx {n} Htop Hclosed). }
      claim H0clSing: 0 :e closure_of X Tx {n}.
      { rewrite <- HAeq. exact H0clA. }
      claim H0inSing: 0 :e {n}.
      { rewrite <- Heq_cl. exact H0clSing. }
      claim H0eqn: 0 = n.
      { exact (SingE n 0 H0inSing). }
      claim Hn0: n = 0.
      { rewrite <- H0eqn. reflexivity. }
      claim Hnnot0: n /:e {0}.
      { exact (setminusE2 X {0} n HninX0). }
      claim Hnin0: n :e {0}.
      { rewrite Hn0. exact (SingI 0). }
      exact (Hnnot0 Hnin0). }
    (** contradict the assumed subset **)
    claim H0in_right: 0 :e Union ClFam.
    { exact (Hsub 0 H0in_closure). }
    exact (H0not_union_closures H0in_right).
Qed.

(** from 17 Exercise 8(a): closure of intersection is contained in intersection of closures **)
(** LATEX VERSION: Determine whether cl(A :/\\: B) = cl(A) :/\\: cl(B); always have inclusion c= . **)
Theorem ex17_8a_closure_intersection_Subq_intersection_closures : forall X Tx A B:set,
  topology_on X Tx ->
  closure_of X Tx (A :/\: B) c= closure_of X Tx A :/\: closure_of X Tx B.
let X Tx A B.
assume Htop: topology_on X Tx.
prove closure_of X Tx (A :/\: B) c= closure_of X Tx A :/\: closure_of X Tx B.
(** Strategy: if x in closure(AB), then every open containing x meets AB,
    hence meets A (and B), so x in closure(A) (and closure(B)). **)
let x.
assume Hx: x :e closure_of X Tx (A :/\: B).
prove x :e closure_of X Tx A :/\: closure_of X Tx B.
claim HxX: x :e X.
{ exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: (A :/\: B) <> Empty) x Hx). }
claim HxAB: forall U:set, U :e Tx -> x :e U -> U :/\: (A :/\: B) <> Empty.
{ exact (SepE2 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: (A :/\: B) <> Empty) x Hx). }
apply binintersectI.
- prove x :e closure_of X Tx A.
  claim HxA: x :e X /\ (forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty).
  { apply andI.
    + exact HxX.
    + let U. assume HU: U :e Tx. assume HxU: x :e U.
      prove U :/\: A <> Empty.
      claim HABne: U :/\: (A :/\: B) <> Empty.
      { exact (HxAB U HU HxU). }
      assume Hempty: U :/\: A = Empty.
      apply HABne.
      apply Empty_Subq_eq.
      let y. assume Hy: y :e U :/\: (A :/\: B).
      claim HyU: y :e U.
      { exact (binintersectE1 U (A :/\: B) y Hy). }
      claim HyAB: y :e A :/\: B.
      { exact (binintersectE2 U (A :/\: B) y Hy). }
      claim HyA: y :e A.
      { exact (binintersectE1 A B y HyAB). }
      claim HyUA: y :e U :/\: A.
      { apply binintersectI.
        - exact HyU.
        - exact HyA. }
      rewrite <- Hempty. exact HyUA.
  }
  exact (SepI X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x HxX (andER (x :e X) (forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty) HxA)).
- prove x :e closure_of X Tx B.
  claim HxB: x :e X /\ (forall U:set, U :e Tx -> x :e U -> U :/\: B <> Empty).
  { apply andI.
    + exact HxX.
    + let U. assume HU: U :e Tx. assume HxU: x :e U.
      prove U :/\: B <> Empty.
      claim HABne: U :/\: (A :/\: B) <> Empty.
      { exact (HxAB U HU HxU). }
      assume Hempty: U :/\: B = Empty.
      apply HABne.
      apply Empty_Subq_eq.
      let y. assume Hy: y :e U :/\: (A :/\: B).
      claim HyU: y :e U.
      { exact (binintersectE1 U (A :/\: B) y Hy). }
      claim HyAB: y :e A :/\: B.
      { exact (binintersectE2 U (A :/\: B) y Hy). }
      claim HyB: y :e B.
      { exact (binintersectE2 A B y HyAB). }
      claim HyUB: y :e U :/\: B.
      { apply binintersectI.
        - exact HyU.
        - exact HyB. }
      rewrite <- Hempty. exact HyUB.
  }
  exact (SepI X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: B <> Empty) x HxX (andER (x :e X) (forall U:set, U :e Tx -> x :e U -> U :/\: B <> Empty) HxB)).
Qed.

(** from 17 Exercise 8(b): closure of an arbitrary intersection and intersection of closures **)
(** LATEX VERSION: Determine whether cl(Intersection A_alpha) = Intersection cl(A_alpha); always have inclusion c= . **)
Theorem ex17_8b_closure_intersection_family_Subq_intersection_closures : forall X Tx Fam:set,
  topology_on X Tx ->
  (forall A:set, A :e Fam -> A c= X) ->
  closure_of X Tx (intersection_of_family X Fam) c=
    intersection_of_family X {closure_of X Tx A|A :e Fam}.
let X Tx Fam.
assume Htop: topology_on X Tx.
assume HFsub: forall A:set, A :e Fam -> A c= X.
prove closure_of X Tx (intersection_of_family X Fam) c= intersection_of_family X {closure_of X Tx A|A :e Fam}.
set Aint := intersection_of_family X Fam.
set ClFam := {closure_of X Tx A|A :e Fam}.
claim HAintSubX: Aint c= X.
{ let x. assume Hx: x :e Aint.
  exact (SepE1 X (fun x0 => forall U:set, U :e Fam -> x0 :e U) x Hx). }
let x. assume Hx: x :e closure_of X Tx Aint.
prove x :e intersection_of_family X ClFam.
claim HxX: x :e X.
{ exact (SepE1 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: Aint <> Empty) x Hx). }
claim Hdef: intersection_of_family X ClFam = {x0 :e X|forall U:set, U :e ClFam -> x0 :e U}.
{ reflexivity. }
rewrite Hdef.
apply SepI.
- exact HxX.
- let W. assume HW: W :e ClFam.
  prove x :e W.
  apply (ReplE Fam (fun A:set => closure_of X Tx A) W HW).
  let A. assume HAconj.
  claim HAFam: A :e Fam.
  { exact (andEL (A :e Fam) (W = closure_of X Tx A) HAconj). }
  claim HWeq: W = closure_of X Tx A.
  { exact (andER (A :e Fam) (W = closure_of X Tx A) HAconj). }
  claim HAintSubA: Aint c= A.
  { let y. assume Hy: y :e Aint.
    claim Hcond: forall U:set, U :e Fam -> y :e U.
    { exact (SepE2 X (fun x0 => forall U:set, U :e Fam -> x0 :e U) y Hy). }
    exact (Hcond A HAFam). }
  claim HxclA: x :e closure_of X Tx A.
  { exact (closure_monotone X Tx Aint A Htop HAintSubA (HFsub A HAFam) x Hx). }
  rewrite HWeq.
  exact HxclA.
Qed.

(** from 17 Exercise 8(c): closure of set difference **)
(** LATEX VERSION: Determine whether cl(A-B) = cl(A) - cl(B); at least cl(A-B) c= cl(A). **)
Theorem ex17_8c_closure_setminus_Subq_closure_left : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  closure_of X Tx (A :\: B) c= closure_of X Tx A.
let X Tx A B.
assume Htop: topology_on X Tx.
assume HA: A c= X.
assume HB: B c= X.
prove closure_of X Tx (A :\: B) c= closure_of X Tx A.
claim Hsub: A :\: B c= A.
{ let x. assume Hx: x :e A :\: B.
  exact (setminusE1 A B x Hx). }
exact (closure_monotone X Tx (A :\: B) A Htop Hsub HA).
Qed.

(** from 17 Exercise 8(c): counterexample to equality cl(A-B) = cl(A) - cl(B) **)
(** LATEX VERSION: Give an example where the equality fails. **)
Theorem ex17_8c_counterexample_equality_fails :
  exists X Tx A B:set,
    topology_on X Tx /\
    A c= X /\ B c= X /\
    closure_of X Tx (A :\: B) <> (closure_of X Tx A :\: closure_of X Tx B).
set X0 := {0} :\/: {1}.
set Tx0 := indiscrete_topology X0.
set A0 := X0.
set B0 := {0}.
witness X0.
witness Tx0.
witness A0.
witness B0.
prove topology_on X0 Tx0 /\ A0 c= X0 /\ B0 c= X0 /\ closure_of X0 Tx0 (A0 :\: B0) <> (closure_of X0 Tx0 A0 :\: closure_of X0 Tx0 B0).
apply andI.
- apply andI.
  - apply andI.
    + exact (indiscrete_topology_on X0).
    + exact (Subq_ref X0).
  - (** B0 c= X0 **)
    let x. assume Hx: x :e B0.
    prove x :e X0.
    claim Hxeq: x = 0.
    { exact (SingE 0 x Hx). }
    rewrite Hxeq.
    exact (binunionI1 {0} {1} 0 (SingI 0)).
- (** inequality **)
  assume Heq: closure_of X0 Tx0 (A0 :\: B0) = (closure_of X0 Tx0 A0 :\: closure_of X0 Tx0 B0).
  (** show 0 in left **)
  claim H0X0: 0 :e X0.
  { exact (binunionI1 {0} {1} 0 (SingI 0)). }
  claim H0in_left: 0 :e closure_of X0 Tx0 (A0 :\: B0).
  { apply (iffER (0 :e closure_of X0 Tx0 (A0 :\: B0))
                 (forall U :e Tx0, 0 :e U -> U :/\: (A0 :\: B0) <> Empty)
                 (closure_characterization X0 Tx0 (A0 :\: B0) 0 (indiscrete_topology_on X0) H0X0)).
    let U. assume HU: U :e Tx0.
    assume H0U: 0 :e U.
    prove U :/\: (A0 :\: B0) <> Empty.
    (** In the indiscrete topology, U is either Empty or X0; since 0 in U, we must have U = X0 **)
    claim HUcases: U = Empty \/ U = X0.
    { claim HU': U :e indiscrete_topology X0.
      { exact HU. }
      exact (iffEL (U :e indiscrete_topology X0) (U = Empty \/ U = X0) (indiscrete_open_iff X0 U) HU'). }
	    apply HUcases.
	    - assume HUe: U = Empty.
	      apply FalseE.
	      claim H0notU: 0 /:e U.
	      { rewrite HUe.
	        exact (EmptyE 0). }
	      exact (H0notU H0U).
	    - assume HUX: U = X0.
	      rewrite HUX.
      (** witness 1 in X0 \\ {0} **)
      claim H1X0: 1 :e X0.
      { exact (binunionI2 {0} {1} 1 (SingI 1)). }
      claim H1notB0: 1 /:e B0.
      { assume H1B0: 1 :e B0.
        claim H10: 1 = 0.
        { exact (SingE 0 1 H1B0). }
        exact (neq_1_0 H10). }
      claim H1in: 1 :e A0 :\: B0.
      { apply setminusI.
        - exact H1X0.
        - exact H1notB0. }
      claim H1in_inter: 1 :e X0 :/\: (A0 :\: B0).
      { exact (binintersectI X0 (A0 :\: B0) 1 H1X0 H1in). }
      exact (elem_implies_nonempty (X0 :/\: (A0 :\: B0)) 1 H1in_inter). }
  (** show 0 not in right **)
  claim H0in_clB: 0 :e closure_of X0 Tx0 B0.
  { claim HB0sub: B0 c= X0.
    { let x. assume Hx: x :e B0.
      prove x :e X0.
      claim Hxeq: x = 0.
      { exact (SingE 0 x Hx). }
      rewrite Hxeq.
      exact (binunionI1 {0} {1} 0 (SingI 0)). }
    exact (subset_of_closure X0 Tx0 B0 (indiscrete_topology_on X0) HB0sub 0 (SingI 0)). }
  claim H0not_right: 0 /:e (closure_of X0 Tx0 A0 :\: closure_of X0 Tx0 B0).
  { assume H0R: 0 :e (closure_of X0 Tx0 A0 :\: closure_of X0 Tx0 B0).
    claim H0not_clB: 0 /:e closure_of X0 Tx0 B0.
    { exact (setminusE2 (closure_of X0 Tx0 A0) (closure_of X0 Tx0 B0) 0 H0R). }
    exact (H0not_clB H0in_clB). }
  (** contradiction via equality **)
  apply H0not_right.
  rewrite <- Heq.
  exact H0in_left.
Qed.

(** LATEX VERSION: Exercise 9: Closure of AB in product is product of closures. **)
Theorem ex17_9_closure_of_product_subset : forall X Y Tx Ty A B:set,
  topology_on X Tx -> topology_on Y Ty ->
  closure_of (setprod X Y) (product_topology X Tx Y Ty) (setprod A B) =
    setprod (closure_of X Tx A) (closure_of Y Ty B).
let X Y Tx Ty A B.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove closure_of (setprod X Y) (product_topology X Tx Y Ty) (setprod A B) = setprod (closure_of X Tx A) (closure_of Y Ty B).
set Xprod := setprod X Y.
set Tprod := product_topology X Tx Y Ty.
set P := setprod A B.
set clA := closure_of X Tx A.
set clB := closure_of Y Ty B.
apply set_ext.
- let p. assume Hp: p :e closure_of Xprod Tprod P.
  prove p :e setprod clA clB.
  claim HpXprod: p :e Xprod.
  { exact (SepE1 Xprod (fun p0 => forall W:set, W :e Tprod -> p0 :e W -> W :/\: P <> Empty) p Hp). }
  claim Hpcl: forall W:set, W :e Tprod -> p :e W -> W :/\: P <> Empty.
  { exact (SepE2 Xprod (fun p0 => forall W:set, W :e Tprod -> p0 :e W -> W :/\: P <> Empty) p Hp). }
  apply (setprod_elem_decompose X Y p HpXprod).
  let x. assume Hxconj.
  claim HxX: x :e X.
  { exact (andEL (x :e X) (exists y :e Y, p :e setprod {x} {y}) Hxconj). }
  apply (andER (x :e X) (exists y :e Y, p :e setprod {x} {y}) Hxconj).
  let y. assume Hyconj.
  claim HyY: y :e Y.
  { exact (andEL (y :e Y) (p :e setprod {x} {y}) Hyconj). }
  claim HpXYsing: p :e setprod {x} {y}.
  { exact (andER (y :e Y) (p :e setprod {x} {y}) Hyconj). }
  (** show x :e clA **)
  claim HxclA: x :e clA.
  { prove x :e closure_of X Tx A.
    claim Hxcond: forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
    { let U. assume HU: U :e Tx. assume HxU: x :e U.
      (** apply closure condition in product to the open rectangle UY **)
      set WY := rectangle_set U Y.
      claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
      { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
      claim HYopen: Y :e Ty.
      { exact (topology_has_X Y Ty HTy). }
      claim HWYsub: WY :e product_subbasis X Tx Y Ty.
      { prove WY :e product_subbasis X Tx Y Ty.
        claim HWYV: rectangle_set U Y :e {rectangle_set U V|V :e Ty}.
        { exact (ReplI Ty (fun V1:set => rectangle_set U V1) Y HYopen). }
        exact (famunionI Tx (fun U1:set => {rectangle_set U1 V|V :e Ty}) U (rectangle_set U Y) HU HWYV). }
      claim HWYopen: WY :e Tprod.
      { exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty)
                HBasis WY HWYsub). }
      claim HpWY: p :e WY.
      { (** {x}{y}  UY, hence p  UY **)
        claim Hsx: {x} c= U.
        { exact (singleton_subset x U HxU). }
        claim Hsy: {y} c= Y.
        { exact (singleton_subset y Y HyY). }
        claim Hsub: setprod {x} {y} c= setprod U Y.
        { exact (setprod_Subq {x} {y} U Y Hsx Hsy). }
        exact (Hsub p HpXYsing). }
      claim Hnonemp: WY :/\: P <> Empty.
      { exact (Hpcl WY HWYopen HpWY). }
      apply (nonempty_has_element (WY :/\: P) Hnonemp).
      let q. assume HqInt.
      (** from q  (UY)  (AB), get a  UA **)
      claim HqWY: q :e WY.
      { exact (binintersectE1 WY P q HqInt). }
      claim HqP: q :e P.
      { exact (binintersectE2 WY P q HqInt). }
      apply (setprod_elem_decompose A B q HqP).
      let a. assume Haconj.
      claim HaA: a :e A.
      { exact (andEL (a :e A) (exists b :e B, q :e setprod {a} {b}) Haconj). }
      apply (andER (a :e A) (exists b :e B, q :e setprod {a} {b}) Haconj).
      let b. assume Hbconj.
      claim HbB: b :e B.
      { exact (andEL (b :e B) (q :e setprod {a} {b}) Hbconj). }
      claim Hqabsing: q :e setprod {a} {b}.
      { exact (andER (b :e B) (q :e setprod {a} {b}) Hbconj). }
      claim Hcoords: a :e U /\ b :e Y.
      { exact (setprod_coords_in a b U Y q Hqabsing HqWY). }
      claim HaU: a :e U.
      { exact (andEL (a :e U) (b :e Y) Hcoords). }
      claim HaUA: a :e U :/\: A.
      { exact (binintersectI U A a HaU HaA). }
      prove U :/\: A <> Empty.
      assume Hempty: U :/\: A = Empty.
      claim HaE: a :e Empty.
      { rewrite <- Hempty. exact HaUA. }
      exact (EmptyE a HaE). }
    exact (SepI X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x HxX Hxcond). }
  (** show y :e clB **)
  claim HyclB: y :e clB.
  { prove y :e closure_of Y Ty B.
    claim Hycond: forall V:set, V :e Ty -> y :e V -> V :/\: B <> Empty.
    { let V. assume HV: V :e Ty. assume HyV: y :e V.
      set WX := rectangle_set X V.
      claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
      { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
      claim HXopen: X :e Tx.
      { exact (topology_has_X X Tx HTx). }
      claim HWXsub: WX :e product_subbasis X Tx Y Ty.
      { prove WX :e product_subbasis X Tx Y Ty.
        claim HWXV: rectangle_set X V :e {rectangle_set X V0|V0 :e Ty}.
        { exact (ReplI Ty (fun V1:set => rectangle_set X V1) V HV). }
        exact (famunionI Tx (fun U1:set => {rectangle_set U1 V0|V0 :e Ty}) X (rectangle_set X V) HXopen HWXV). }
      claim HWXopen: WX :e Tprod.
      { exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty)
                HBasis WX HWXsub). }
      claim HpWX: p :e WX.
      { claim Hsx: {x} c= X.
        { exact (singleton_subset x X HxX). }
        claim Hsy: {y} c= V.
        { exact (singleton_subset y V HyV). }
        claim Hsub: setprod {x} {y} c= setprod X V.
        { exact (setprod_Subq {x} {y} X V Hsx Hsy). }
        exact (Hsub p HpXYsing). }
      claim Hnonemp: WX :/\: P <> Empty.
      { exact (Hpcl WX HWXopen HpWX). }
      apply (nonempty_has_element (WX :/\: P) Hnonemp).
      let q. assume HqInt.
      claim HqWX: q :e WX.
      { exact (binintersectE1 WX P q HqInt). }
      claim HqP: q :e P.
      { exact (binintersectE2 WX P q HqInt). }
      apply (setprod_elem_decompose A B q HqP).
      let a. assume Haconj.
      claim HaA: a :e A.
      { exact (andEL (a :e A) (exists b :e B, q :e setprod {a} {b}) Haconj). }
      apply (andER (a :e A) (exists b :e B, q :e setprod {a} {b}) Haconj).
      let b. assume Hbconj.
      claim HbB: b :e B.
      { exact (andEL (b :e B) (q :e setprod {a} {b}) Hbconj). }
      claim Hqabsing: q :e setprod {a} {b}.
      { exact (andER (b :e B) (q :e setprod {a} {b}) Hbconj). }
      claim Hcoords: a :e X /\ b :e V.
      { exact (setprod_coords_in a b X V q Hqabsing HqWX). }
      claim HbV: b :e V.
      { exact (andER (a :e X) (b :e V) Hcoords). }
      claim HbVB: b :e V :/\: B.
      { exact (binintersectI V B b HbV HbB). }
      prove V :/\: B <> Empty.
      assume Hempty: V :/\: B = Empty.
      claim HbE: b :e Empty.
      { rewrite <- Hempty. exact HbVB. }
      exact (EmptyE b HbE). }
    exact (SepI Y (fun y0 => forall V:set, V :e Ty -> y0 :e V -> V :/\: B <> Empty) y HyY Hycond). }
  (** conclude p  clAclB using {x}{y}  clAclB **)
  claim Hsx: {x} c= clA.
  { exact (singleton_subset x clA HxclA). }
  claim Hsy: {y} c= clB.
  { exact (singleton_subset y clB HyclB). }
  claim Hsub: setprod {x} {y} c= setprod clA clB.
  { exact (setprod_Subq {x} {y} clA clB Hsx Hsy). }
  exact (Hsub p HpXYsing).
- let p. assume Hp: p :e setprod clA clB.
  prove p :e closure_of Xprod Tprod P.
  claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
  { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
  claim HTprod: topology_on (setprod X Y) Tprod.
  { exact (product_topology_is_topology X Tx Y Ty HTx HTy). }
  (** decompose p into xclA, yclB and p{x}{y} **)
  apply (setprod_elem_decompose clA clB p Hp).
  let x. assume Hxconj.
  claim HxclA: x :e clA.
  { exact (andEL (x :e clA) (exists y :e clB, p :e setprod {x} {y}) Hxconj). }
  apply (andER (x :e clA) (exists y :e clB, p :e setprod {x} {y}) Hxconj).
  let y. assume Hyconj.
  claim HyclB: y :e clB.
  { exact (andEL (y :e clB) (p :e setprod {x} {y}) Hyconj). }
  claim HpXYsing: p :e setprod {x} {y}.
  { exact (andER (y :e clB) (p :e setprod {x} {y}) Hyconj). }
  (** show p  XY to satisfy closure_of's carrier condition **)
  claim HclAsubX: clA c= X.
  { exact (closure_in_space X Tx A HTx). }
  claim HclBsubY: clB c= Y.
  { exact (closure_in_space Y Ty B HTy). }
  claim HpXprod: p :e Xprod.
  { claim Hsub: setprod clA clB c= setprod X Y.
    { exact (setprod_Subq clA clB X Y HclAsubX HclBsubY). }
    exact (Hsub p Hp). }
  (** main closure condition for p **)
  claim Hpcond: forall W:set, W :e Tprod -> p :e W -> W :/\: P <> Empty.
  { let W. assume HW: W :e Tprod. assume HpW: p :e W.
    (** from openness of W, extract rectangle basis element b containing p, b  W **)
    claim HWgen: W :e generated_topology (setprod X Y) (product_subbasis X Tx Y Ty).
    { exact HW. }
    claim HWprop: forall p0 :e W, exists b :e product_subbasis X Tx Y Ty, p0 :e b /\ b c= W.
    { exact (SepE2 (Power (setprod X Y))
                   (fun U0:set => forall p0 :e U0, exists b :e product_subbasis X Tx Y Ty, p0 :e b /\ b c= U0)
                   W HWgen). }
    claim Hexb: exists b :e product_subbasis X Tx Y Ty, p :e b /\ b c= W.
    { exact (HWprop p HpW). }
    apply Hexb.
    let b. assume Hbconj.
    claim HbSub: b :e product_subbasis X Tx Y Ty.
    { exact (andEL (b :e product_subbasis X Tx Y Ty) (p :e b /\ b c= W) Hbconj). }
    claim Hpb: p :e b.
    { exact (andEL (p :e b) (b c= W) (andER (b :e product_subbasis X Tx Y Ty) (p :e b /\ b c= W) Hbconj)). }
    claim HbW: b c= W.
    { exact (andER (p :e b) (b c= W) (andER (b :e product_subbasis X Tx Y Ty) (p :e b /\ b c= W) Hbconj)). }
    (** decode b as rectangle_set U0 V0 **)
    apply (famunionE Tx (fun U1:set => {rectangle_set U1 V|V :e Ty}) b HbSub).
    let U0. assume HU0conj.
    claim HU0Tx: U0 :e Tx.
    { exact (andEL (U0 :e Tx) (b :e {rectangle_set U0 V|V :e Ty}) HU0conj). }
    claim HbInRepl: b :e {rectangle_set U0 V|V :e Ty}.
    { exact (andER (U0 :e Tx) (b :e {rectangle_set U0 V|V :e Ty}) HU0conj). }
    apply (ReplE Ty (fun V:set => rectangle_set U0 V) b HbInRepl).
    let V0. assume HV0conj.
    claim HV0Ty: V0 :e Ty.
    { exact (andEL (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }
    claim Hbeq: b = rectangle_set U0 V0.
    { exact (andER (V0 :e Ty) (b = rectangle_set U0 V0) HV0conj). }
    claim HpbRect: p :e rectangle_set U0 V0.
    { rewrite <- Hbeq.
      exact Hpb. }
    (** from p  {x}{y} and p  U0V0, get xU0 and yV0 **)
    claim Hcoords: x :e U0 /\ y :e V0.
    { exact (setprod_coords_in x y U0 V0 p HpXYsing HpbRect). }
    claim HxU0: x :e U0.
    { exact (andEL (x :e U0) (y :e V0) Hcoords). }
    claim HyV0: y :e V0.
    { exact (andER (x :e U0) (y :e V0) Hcoords). }
    (** use x  clA to get U0A nonempty **)
    claim HxclAprop: forall U:set, U :e Tx -> x :e U -> U :/\: A <> Empty.
    { exact (SepE2 X (fun x0 => forall U:set, U :e Tx -> x0 :e U -> U :/\: A <> Empty) x HxclA). }
    claim HU0Ane: U0 :/\: A <> Empty.
    { exact (HxclAprop U0 HU0Tx HxU0). }
    apply (nonempty_has_element (U0 :/\: A) HU0Ane).
    let a. assume HaUA.
    claim HaU0: a :e U0.
    { exact (binintersectE1 U0 A a HaUA). }
    claim HaA: a :e A.
    { exact (binintersectE2 U0 A a HaUA). }
    (** use y  clB to get V0B nonempty **)
    claim HyclBprop: forall V:set, V :e Ty -> y :e V -> V :/\: B <> Empty.
    { exact (SepE2 Y (fun y0 => forall V:set, V :e Ty -> y0 :e V -> V :/\: B <> Empty) y HyclB). }
    claim HV0Bne: V0 :/\: B <> Empty.
    { exact (HyclBprop V0 HV0Ty HyV0). }
    apply (nonempty_has_element (V0 :/\: B) HV0Bne).
    let b0. assume HbVB.
    claim HbV0: b0 :e V0.
    { exact (binintersectE1 V0 B b0 HbVB). }
    claim HbB: b0 :e B.
    { exact (binintersectE2 V0 B b0 HbVB). }
    (** now (a,b0)  (U0V0)  W and (a,b0)  AB **)
    set q := (a,b0).
    claim HqRect: q :e rectangle_set U0 V0.
    { exact (tuple_2_setprod U0 V0 a HaU0 b0 HbV0). }
    claim Hqb: q :e b.
    { rewrite Hbeq.
      exact HqRect. }
    claim HqW: q :e W.
    { exact (HbW q Hqb). }
    claim HqP: q :e P.
    { exact (tuple_2_setprod A B a HaA b0 HbB). }
    set I := W :/\: P.
    claim HqInt: q :e W :/\: P.
    { exact (binintersectI W P q HqW HqP). }
    exact (elem_implies_nonempty (W :/\: P) q HqInt). }
  exact (SepI Xprod (fun p0 => forall W:set, W :e Tprod -> p0 :e W -> W :/\: P <> Empty) p HpXprod Hpcond).
Qed.

(** LATEX VERSION: Exercise 10: Order topology is Hausdorff. **)
Axiom order_topology_is_Hausdorff : forall X:set,
  Hausdorff_space X (order_topology X).

Theorem ex17_10_order_topology_Hausdorff : forall X:set,
  Hausdorff_space X (order_topology X).
let X.
prove Hausdorff_space X (order_topology X).
exact (order_topology_is_Hausdorff X).
Qed.

(** LATEX VERSION: Exercise 11: Product of Hausdorff spaces is Hausdorff. **)
Theorem ex17_11_product_Hausdorff : forall X Tx Y Ty:set,
  Hausdorff_space X Tx -> Hausdorff_space Y Ty ->
  Hausdorff_space (setprod X Y) (product_topology X Tx Y Ty).
let X Tx Y Ty.
assume HX: Hausdorff_space X Tx.
assume HY: Hausdorff_space Y Ty.
prove Hausdorff_space (setprod X Y) (product_topology X Tx Y Ty).
apply (Hausdorff_stability X Tx Y Ty).
apply andI.
- exact HX.
- exact HY.
Qed.

(** LATEX VERSION: Exercise 12: Subspaces of Hausdorff spaces are Hausdorff. **)
Theorem ex17_12_subspace_Hausdorff : forall X Tx Y:set,
  Hausdorff_space X Tx -> Y c= X -> Hausdorff_space Y (subspace_topology X Tx Y).
let X Tx Y.
assume HX: Hausdorff_space X Tx.
assume HYsubX: Y c= X.
prove Hausdorff_space Y (subspace_topology X Tx Y).
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 -> exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HX). }
claim HTy: topology_on Y (subspace_topology X Tx Y).
{ exact (subspace_topology_is_topology X Tx Y HTx HYsubX). }
prove topology_on Y (subspace_topology X Tx Y) /\
      (forall y1 y2:set, y1 :e Y -> y2 :e Y -> y1 <> y2 ->
       exists U V:set, U :e subspace_topology X Tx Y /\ V :e subspace_topology X Tx Y /\
                       y1 :e U /\ y2 :e V /\ U :/\: V = Empty).
apply andI.
- exact HTy.
- let y1 y2. assume Hy1: y1 :e Y. assume Hy2: y2 :e Y. assume Hne: y1 <> y2.
  prove exists U V:set, U :e subspace_topology X Tx Y /\ V :e subspace_topology X Tx Y /\
                        y1 :e U /\ y2 :e V /\ U :/\: V = Empty.
  (** Strategy: y1, y2 are distinct points. If both in Y, they're distinct in X.
      Get disjoint X-neighborhoods U', V' from Hausdorff property.
      Then U'  Y and V'  Y are disjoint Y-neighborhoods. **)
  claim Hsepax:
    forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
      exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
  { exact (andER (topology_on X Tx)
                 (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
                 HX). }
  claim Hy1X: y1 :e X.
  { exact (HYsubX y1 Hy1). }
  claim Hy2X: y2 :e X.
  { exact (HYsubX y2 Hy2). }
  claim HexistsUV:
    exists U V:set, U :e Tx /\ V :e Tx /\ y1 :e U /\ y2 :e V /\ U :/\: V = Empty.
  { exact (Hsepax y1 y2 Hy1X Hy2X Hne). }
  set U0 := Eps_i (fun U:set => exists V:set, U :e Tx /\ V :e Tx /\ y1 :e U /\ y2 :e V /\ U :/\: V = Empty).
  claim HU0ex:
    exists V:set, U0 :e Tx /\ V :e Tx /\ y1 :e U0 /\ y2 :e V /\ U0 :/\: V = Empty.
  { exact (Eps_i_ex (fun U:set => exists V:set, U :e Tx /\ V :e Tx /\ y1 :e U /\ y2 :e V /\ U :/\: V = Empty)
                    HexistsUV). }
  set V0 := Eps_i (fun V:set => U0 :e Tx /\ V :e Tx /\ y1 :e U0 /\ y2 :e V /\ U0 :/\: V = Empty).
  claim HV0prop:
    U0 :e Tx /\ V0 :e Tx /\ y1 :e U0 /\ y2 :e V0 /\ U0 :/\: V0 = Empty.
  { exact (Eps_i_ex (fun V:set => U0 :e Tx /\ V :e Tx /\ y1 :e U0 /\ y2 :e V /\ U0 :/\: V = Empty)
                    HU0ex). }
  claim HU0Tx: U0 :e Tx.
  { exact (andEL (U0 :e Tx)
                 (V0 :e Tx)
                 (andEL (U0 :e Tx /\ V0 :e Tx)
                        (y1 :e U0)
                        (andEL ((U0 :e Tx /\ V0 :e Tx) /\ y1 :e U0)
                               (y2 :e V0)
                               (andEL (((U0 :e Tx /\ V0 :e Tx) /\ y1 :e U0) /\ y2 :e V0)
                                      (U0 :/\: V0 = Empty)
                                      HV0prop)))). }
  claim HV0Tx: V0 :e Tx.
  { exact (andER (U0 :e Tx)
                 (V0 :e Tx)
                 (andEL (U0 :e Tx /\ V0 :e Tx)
                        (y1 :e U0)
                        (andEL ((U0 :e Tx /\ V0 :e Tx) /\ y1 :e U0)
                               (y2 :e V0)
                               (andEL (((U0 :e Tx /\ V0 :e Tx) /\ y1 :e U0) /\ y2 :e V0)
                                      (U0 :/\: V0 = Empty)
                                      HV0prop)))). }
  claim Hy1U0: y1 :e U0.
  { exact (andER (U0 :e Tx /\ V0 :e Tx)
                 (y1 :e U0)
                 (andEL ((U0 :e Tx /\ V0 :e Tx) /\ y1 :e U0)
                        (y2 :e V0)
                        (andEL (((U0 :e Tx /\ V0 :e Tx) /\ y1 :e U0) /\ y2 :e V0)
                               (U0 :/\: V0 = Empty)
                               HV0prop))). }
  claim Hy2V0: y2 :e V0.
  { exact (andER ((U0 :e Tx /\ V0 :e Tx) /\ y1 :e U0)
                 (y2 :e V0)
                 (andEL (((U0 :e Tx /\ V0 :e Tx) /\ y1 :e U0) /\ y2 :e V0)
                        (U0 :/\: V0 = Empty)
                        HV0prop)). }
  claim Hdisj: U0 :/\: V0 = Empty.
  { exact (andER (((U0 :e Tx /\ V0 :e Tx) /\ y1 :e U0) /\ y2 :e V0)
                 (U0 :/\: V0 = Empty)
                 HV0prop). }
  set U := U0 :/\: Y.
  set V := V0 :/\: Y.
  claim HUinST: U :e subspace_topology X Tx Y.
  { claim HUPowY: U :e Power Y.
    { apply PowerI.
      let z. assume Hz: z :e U.
      exact (binintersectE2 U0 Y z Hz). }
    claim HUdef: exists V' :e Tx, U = V' :/\: Y.
    { witness U0.
      apply andI.
      - exact HU0Tx.
      - reflexivity. }
    exact (SepI (Power Y) (fun U1:set => exists V' :e Tx, U1 = V' :/\: Y) U HUPowY HUdef).
  }
  claim HVinST: V :e subspace_topology X Tx Y.
  { claim HVPowY: V :e Power Y.
    { apply PowerI.
      let z. assume Hz: z :e V.
      exact (binintersectE2 V0 Y z Hz). }
    claim HVdef: exists V' :e Tx, V = V' :/\: Y.
    { witness V0.
      apply andI.
      - exact HV0Tx.
      - reflexivity. }
    exact (SepI (Power Y) (fun U1:set => exists V' :e Tx, U1 = V' :/\: Y) V HVPowY HVdef).
  }
  claim Hy1U: y1 :e U.
  { exact (binintersectI U0 Y y1 Hy1U0 Hy1). }
  claim Hy2V: y2 :e V.
  { exact (binintersectI V0 Y y2 Hy2V0 Hy2). }
  claim HUVempty: U :/\: V = Empty.
  { apply Empty_Subq_eq.
    let z. assume Hz: z :e U :/\: V.
    prove z :e Empty.
    claim HzU: z :e U.
    { exact (binintersectE1 U V z Hz). }
    claim HzV: z :e V.
    { exact (binintersectE2 U V z Hz). }
    claim HzU0: z :e U0.
    { exact (binintersectE1 U0 Y z HzU). }
    claim HzV0: z :e V0.
    { exact (binintersectE1 V0 Y z HzV). }
    claim HzU0V0: z :e U0 :/\: V0.
    { exact (binintersectI U0 V0 z HzU0 HzV0). }
    rewrite <- Hdisj.
    exact HzU0V0.
  }
  witness U.
  witness V.
  apply andI.
  - apply andI.
    + apply andI.
      * apply andI.
        { exact HUinST. }
        { exact HVinST. }
      * exact Hy1U.
    + exact Hy2V.
  - exact HUVempty.
Qed.

(** LATEX VERSION: Exercise 13: Diagonal is closed in XX iff X is Hausdorff. **)
Theorem ex17_13_diagonal_closed_iff_Hausdorff : forall X Tx:set,
  topology_on X Tx ->
  (Hausdorff_space X Tx <->
    closed_in (setprod X X) (product_topology X Tx X Tx) {(x,x)|x :e X}).
let X Tx.
assume Htop: topology_on X Tx.
prove Hausdorff_space X Tx <-> closed_in (setprod X X) (product_topology X Tx X Tx) {(x,x)|x :e X}.
apply iffI.
- assume HH: Hausdorff_space X Tx.
  prove closed_in (setprod X X) (product_topology X Tx X Tx) {(x,x)|x :e X}.
  claim HTx: topology_on X Tx.
  { exact (andEL (topology_on X Tx)
                 (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
                 HH). }
  claim HSep: forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
    exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
  { exact (andER (topology_on X Tx)
                 (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
                 HH). }
  set D := {(t,t)|t :e X}.
  set U := setprod X X :\: D.
  claim HTprod: topology_on (setprod X X) (product_topology X Tx X Tx).
  { exact (product_topology_is_topology X Tx X Tx HTx HTx). }
  claim HDsub: D c= setprod X X.
  { let p. assume HpD: p :e D.
	    apply (ReplE X (fun t:set => (t,t)) p HpD).
	    let x. assume Hxpair.
	    claim HxX: x :e X.
	    { exact (andEL (x :e X) (p = (x,x)) Hxpair). }
	    claim Hpeq: p = (x,x).
	    { exact (andER (x :e X) (p = (x,x)) Hxpair). }
	    rewrite Hpeq.
	    exact (tuple_2_setprod X X x HxX x HxX). }
  claim HUinProd: U :e product_topology X Tx X Tx.
  { prove U :e product_topology X Tx X Tx.
    prove U :e generated_topology (setprod X X) (product_subbasis X Tx X Tx).
    claim HUPow: U :e Power (setprod X X).
    { apply PowerI (setprod X X) U.
      exact (setminus_Subq (setprod X X) D). }
    claim Hprop: forall p :e U, exists b :e product_subbasis X Tx X Tx, p :e b /\ b c= U.
    { let p. assume HpU: p :e U.
      claim HpXY: p :e setprod X X.
      { exact (setminusE1 (setprod X X) D p HpU). }
      claim HpnotD: p /:e D.
      { exact (setminusE2 (setprod X X) D p HpU). }
      apply (Sigma_E X (fun _ : set => X) p HpXY).
      let x. assume Hxpair.
      apply Hxpair.
      assume HxX Hexy.
      apply Hexy.
      let y. assume Hypair.
      apply Hypair.
      assume HyX Hpeq.
      claim Hxy: x <> y.
      { assume HxyEq: x = y.
        claim HpInD: p :e D.
	        { claim Hex: exists t :e X, p = (t,t).
	          { witness x.
	            apply andI.
	            - exact HxX.
	            - rewrite Hpeq.
	              rewrite <- HxyEq.
	              exact (tuple_pair x x). }
	          exact (iffER (p :e D) (exists t :e X, p = (t,t)) (ReplEq X (fun t:set => (t,t)) p) Hex). }
        exact (HpnotD HpInD). }
      claim HexUV: exists U0 V0:set, U0 :e Tx /\ V0 :e Tx /\ x :e U0 /\ y :e V0 /\ U0 :/\: V0 = Empty.
      { exact (HSep x y HxX HyX Hxy). }
      apply HexUV.
      let U0. assume HexV0.
      apply HexV0.
      let V0. assume HUV_conj.
      apply HUV_conj.
      assume Hleft HUVempty.
      apply Hleft.
      assume Hleft2 HyV0.
      apply Hleft2.
      assume Hleft3 HxU0.
      apply Hleft3.
      assume HU0 HV0.
      set b := rectangle_set U0 V0.
      witness b.
      apply andI.
      - (** b in product_subbasis **)
        prove b :e product_subbasis X Tx X Tx.
        claim HbV: rectangle_set U0 V0 :e {rectangle_set U0 V|V :e Tx}.
        { exact (ReplI Tx (fun V:set => rectangle_set U0 V) V0 HV0). }
        exact (famunionI Tx (fun U1:set => {rectangle_set U1 V|V :e Tx}) U0 (rectangle_set U0 V0) HU0 HbV).
      - apply andI.
        + (** p in b **)
          rewrite Hpeq.
          exact (pair_Sigma U0 (fun _ : set => V0) x HxU0 y HyV0).
        + (** b subset U **)
          prove b c= U.
          let q. assume Hqb: q :e b.
          prove q :e U.
          apply setminusI.
          * (** q in XX **)
            claim HU0subX: U0 c= X.
            { exact (topology_elem_subset X Tx U0 HTx HU0). }
            claim HV0subX: V0 c= X.
            { exact (topology_elem_subset X Tx V0 HTx HV0). }
            exact (setprod_Subq U0 V0 X X HU0subX HV0subX q Hqb).
          * (** q not in D **)
            assume HqD: q :e D.
            apply (ReplE X (fun t:set => (t,t)) q HqD).
            let z. assume Hzconj.
            claim HzX: z :e X.
            { exact (andEL (z :e X) (q = (z,z)) Hzconj). }
            claim Hqeq: q = (z,z).
            { exact (andER (z :e X) (q = (z,z)) Hzconj). }
            claim Hsing: q :e setprod {z} {z}.
            { rewrite Hqeq.
              exact (tuple_2_setprod {z} {z} z (SingI z) z (SingI z)). }
            claim HzUV: z :e U0 /\ z :e V0.
            { exact (setprod_coords_in z z U0 V0 q Hsing Hqb). }
            claim HzU0: z :e U0.
            { exact (andEL (z :e U0) (z :e V0) HzUV). }
            claim HzV0: z :e V0.
            { exact (andER (z :e U0) (z :e V0) HzUV). }
            claim HzInt: z :e U0 :/\: V0.
            { exact (binintersectI U0 V0 z HzU0 HzV0). }
            claim HzE: z :e Empty.
            { rewrite <- HUVempty. exact HzInt. }
            exact (EmptyE z HzE).
    }
    exact (SepI (Power (setprod X X)) (fun U0:set => forall p0 :e U0, exists b :e product_subbasis X Tx X Tx, p0 :e b /\ b c= U0) U HUPow Hprop). }
  prove topology_on (setprod X X) (product_topology X Tx X Tx) /\ (D c= setprod X X /\ exists W :e product_topology X Tx X Tx, D = setprod X X :\: W).
  apply andI.
  - exact HTprod.
  - apply andI.
    + exact HDsub.
    + witness U.
      apply andI.
      * exact HUinProd.
      * (** D = (XX) \\ U **)
        prove D = setprod X X :\: U.
        rewrite (setminus_setminus_eq (setprod X X) D HDsub).
        reflexivity.
- assume Hclosed: closed_in (setprod X X) (product_topology X Tx X Tx) {(x,x)|x :e X}.
  prove Hausdorff_space X Tx.
  set D := {(t,t)|t :e X}.
  claim HDsub: D c= setprod X X.
  { exact (andEL (D c= setprod X X) (exists U :e product_topology X Tx X Tx, D = setprod X X :\: U)
                 (andER (topology_on (setprod X X) (product_topology X Tx X Tx))
                        (D c= setprod X X /\ exists U :e product_topology X Tx X Tx, D = setprod X X :\: U)
                        Hclosed)). }
  claim HexU: exists U :e product_topology X Tx X Tx, D = setprod X X :\: U.
  { exact (andER (D c= setprod X X) (exists U :e product_topology X Tx X Tx, D = setprod X X :\: U)
                 (andER (topology_on (setprod X X) (product_topology X Tx X Tx))
                        (D c= setprod X X /\ exists U :e product_topology X Tx X Tx, D = setprod X X :\: U)
                        Hclosed)). }
  apply HexU.
  let U. assume HUconj.
  claim HUopen: U :e product_topology X Tx X Tx.
  { exact (andEL (U :e product_topology X Tx X Tx) (D = setprod X X :\: U) HUconj). }
  claim HDeq: D = setprod X X :\: U.
  { exact (andER (U :e product_topology X Tx X Tx) (D = setprod X X :\: U) HUconj). }
  claim HUsubXY: U c= setprod X X.
  { exact (generated_topology_subset (setprod X X) (product_subbasis X Tx X Tx) U HUopen). }
  claim HcompEq: setprod X X :\: D = U.
  { rewrite HDeq.
    exact (setminus_setminus_eq (setprod X X) U HUsubXY). }
  prove topology_on X Tx /\
        forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
          exists U0 V0:set, U0 :e Tx /\ V0 :e Tx /\ x1 :e U0 /\ x2 :e V0 /\ U0 :/\: V0 = Empty.
  apply andI.
  - exact Htop.
  - let x1 x2. assume Hx1X: x1 :e X. assume Hx2X: x2 :e X. assume Hx12: x1 <> x2.
    prove exists U0 V0:set, U0 :e Tx /\ V0 :e Tx /\ x1 :e U0 /\ x2 :e V0 /\ U0 :/\: V0 = Empty.
	    set p := (x1,x2).
    claim HpNotD: p /:e D.
    { assume HpD: p :e D.
	      apply (ReplE X (fun t:set => (t,t)) p HpD).
	      let z. assume Hzconj.
	      claim Hpeq: p = (z,z).
	      { exact (andER (z :e X) (p = (z,z)) Hzconj). }
      claim HpSing: p :e setprod {x1} {x2}.
      { exact (tuple_2_setprod {x1} {x2} x1 (SingI x1) x2 (SingI x2)). }
      claim HzzIn: (z,z) :e setprod {x1} {x2}.
      { rewrite <- Hpeq.
        exact HpSing. }
      claim HzzSing: (z,z) :e setprod {z} {z}.
      { exact (tuple_2_setprod {z} {z} z (SingI z) z (SingI z)). }
      claim HzIn: z :e {x1} /\ z :e {x2}.
      { exact (setprod_coords_in z z {x1} {x2} (z,z) HzzSing HzzIn). }
      claim Hzx1: z :e {x1}.
      { exact (andEL (z :e {x1}) (z :e {x2}) HzIn). }
      claim Hzx2: z :e {x2}.
      { exact (andER (z :e {x1}) (z :e {x2}) HzIn). }
      claim HzEqx1: z = x1.
      { exact (SingE x1 z Hzx1). }
      claim HzEqx2: z = x2.
      { exact (SingE x2 z Hzx2). }
      claim Hx12eq: x1 = x2.
      { rewrite <- HzEqx1.
        rewrite HzEqx2.
        reflexivity. }
      exact (Hx12 Hx12eq). }
	    claim HpInU: p :e U.
	    { rewrite <- HcompEq.
	      exact (setminusI (setprod X X) D p
	              (tuple_2_setprod X X x1 Hx1X x2 Hx2X)
	              HpNotD). }
	    claim HUprop: forall z :e U, exists b :e product_subbasis X Tx X Tx, z :e b /\ b c= U.
	    { exact (SepE2 (Power (setprod X X))
                   (fun U0:set => forall p0 :e U0, exists b :e product_subbasis X Tx X Tx, p0 :e b /\ b c= U0)
                   U HUopen). }
    claim Hexb: exists b :e product_subbasis X Tx X Tx, p :e b /\ b c= U.
    { exact (HUprop p HpInU). }
    apply Hexb.
    let b. assume Hbconj.
    claim HbSub: b :e product_subbasis X Tx X Tx.
    { exact (andEL (b :e product_subbasis X Tx X Tx) (p :e b /\ b c= U) Hbconj). }
    claim Hpb: p :e b.
    { exact (andEL (p :e b) (b c= U) (andER (b :e product_subbasis X Tx X Tx) (p :e b /\ b c= U) Hbconj)). }
    claim HbU: b c= U.
    { exact (andER (p :e b) (b c= U) (andER (b :e product_subbasis X Tx X Tx) (p :e b /\ b c= U) Hbconj)). }
    (** Decode b as a rectangle U0V0 **)
    apply (famunionE Tx (fun U1:set => {rectangle_set U1 V|V :e Tx}) b HbSub).
    let U0. assume HU0conj.
    claim HU0Tx: U0 :e Tx.
    { exact (andEL (U0 :e Tx) (b :e {rectangle_set U0 V|V :e Tx}) HU0conj). }
    claim HbInRepl: b :e {rectangle_set U0 V|V :e Tx}.
    { exact (andER (U0 :e Tx) (b :e {rectangle_set U0 V|V :e Tx}) HU0conj). }
    apply (ReplE Tx (fun V:set => rectangle_set U0 V) b HbInRepl).
    let V0. assume HV0conj.
    claim HV0Tx: V0 :e Tx.
    { exact (andEL (V0 :e Tx) (b = rectangle_set U0 V0) HV0conj). }
    claim Hbeq: b = rectangle_set U0 V0.
    { exact (andER (V0 :e Tx) (b = rectangle_set U0 V0) HV0conj). }
    claim HpbRect: p :e rectangle_set U0 V0.
    { rewrite <- Hbeq.
      exact Hpb. }
    claim HpSing: p :e setprod {x1} {x2}.
    { exact (tuple_2_setprod {x1} {x2} x1 (SingI x1) x2 (SingI x2)). }
    claim Hcoords: x1 :e U0 /\ x2 :e V0.
    { exact (setprod_coords_in x1 x2 U0 V0 p HpSing HpbRect). }
    claim Hx1U0: x1 :e U0.
    { exact (andEL (x1 :e U0) (x2 :e V0) Hcoords). }
    claim Hx2V0: x2 :e V0.
    { exact (andER (x1 :e U0) (x2 :e V0) Hcoords). }
    (** Show U0  V0 = , otherwise diagonal meets b  U = complement of D **)
    claim HUVempty: U0 :/\: V0 = Empty.
    { apply set_ext.
      - let z. assume Hz: z :e U0 :/\: V0.
        prove z :e Empty.
        apply FalseE.
        claim HzU0: z :e U0.
        { exact (binintersectE1 U0 V0 z Hz). }
        claim HzV0: z :e V0.
        { exact (binintersectE2 U0 V0 z Hz). }
        claim HzX: z :e X.
        { exact (topology_elem_subset X Tx U0 Htop HU0Tx z HzU0). }
	        set q := (z,z).
        claim HqInb: q :e rectangle_set U0 V0.
        { exact (tuple_2_setprod U0 V0 z HzU0 z HzV0). }
        claim HqInb0: q :e b.
        { rewrite Hbeq.
          exact HqInb. }
        claim HqInU: q :e U.
        { exact (HbU q HqInb0). }
        claim HqInD: q :e D.
	        { exact (ReplI X (fun t:set => (t,t)) z HzX). }
        claim HqNotU: q /:e U.
        { claim HqXYU: q :e setprod X X :\: U.
          { rewrite <- HDeq.
            exact HqInD. }
          exact (setminusE2 (setprod X X) U q HqXYU). }
        exact (HqNotU HqInU).
      - exact (Subq_Empty (U0 :/\: V0)). }
    witness U0.
    witness V0.
    apply andI.
    - apply andI.
      + apply andI.
        * apply andI.
          { exact HU0Tx. }
          { exact HV0Tx. }
        * exact Hx1U0.
      + exact Hx2V0.
    - exact HUVempty.
Qed.

(** LATEX VERSION: In the finite complement topology on R, to what point or points does the sequence x_n = 1/n converge? **)
(** For this exercise we represent the sequence by n  1/(n+1), so it is a function on omega. **)
Definition seq_one_over_n : set := (fun n :e omega => {inv_nat (ordsucc n)}).

Theorem seq_one_over_n_apply : forall n:set, n :e omega ->
  apply_fun seq_one_over_n n = inv_nat (ordsucc n).
let n. assume Hn: n :e omega.
prove apply_fun seq_one_over_n n = inv_nat (ordsucc n).
set f := seq_one_over_n.
claim HinvIn: inv_nat (ordsucc n) :e {inv_nat (ordsucc n)}.
{ exact (SingI (inv_nat (ordsucc n))). }
claim HpairIn: (n, inv_nat (ordsucc n)) :e f.
{ exact (lamI2 omega (fun k : set => {inv_nat (ordsucc k)}) n Hn (inv_nat (ordsucc n)) HinvIn). }
claim Happair: (n, apply_fun f n) :e f.
{ exact (Eps_i_ax (fun y:set => (n,y) :e f) (inv_nat (ordsucc n)) HpairIn). }
apply (lamE omega (fun k : set => {inv_nat (ordsucc k)}) (n, apply_fun f n) Happair).
let x0. assume Hx0_conj.
apply Hx0_conj.
assume Hx0 Hexy0.
apply Hexy0.
let y0. assume Hy0_conj.
apply Hy0_conj.
assume Hy0 Heq.
claim HeqT: (n, apply_fun f n) = (x0, y0).
{ rewrite <- (tuple_pair x0 y0).
  exact Heq. }
claim H0eq: (n, apply_fun f n) 0 = (x0, y0) 0.
{ rewrite HeqT. reflexivity. }
claim H1eq: (n, apply_fun f n) 1 = (x0, y0) 1.
{ rewrite HeqT. reflexivity. }
claim Hnx0: n = x0.
{ prove n = x0.
  rewrite <- (tuple_2_0_eq n (apply_fun f n)).
  rewrite <- (tuple_2_0_eq x0 y0).
  exact H0eq. }
claim Happ: apply_fun f n = y0.
{ prove apply_fun f n = y0.
  rewrite <- (tuple_2_1_eq n (apply_fun f n)).
  rewrite <- (tuple_2_1_eq x0 y0).
  exact H1eq. }
claim Hy0eq: y0 = inv_nat (ordsucc x0).
{ exact (SingE (inv_nat (ordsucc x0)) y0 Hy0). }
claim Hx0n: x0 = n.
{ rewrite Hnx0. reflexivity. }
rewrite Happ.
rewrite Hy0eq.
rewrite Hx0n.
reflexivity.
Qed.

Theorem inv_nat_ordsucc_inj : forall n m:set,
  n :e omega -> m :e omega -> inv_nat (ordsucc n) = inv_nat (ordsucc m) -> n = m.
let n m.
assume Hn: n :e omega.
assume Hm: m :e omega.
assume Heq: inv_nat (ordsucc n) = inv_nat (ordsucc m).
prove n = m.
claim Hn_ord: ordinal n.
{ exact (ordinal_Hered omega omega_ordinal n Hn). }
claim Hm_ord: ordinal m.
{ exact (ordinal_Hered omega omega_ordinal m Hm). }
claim Hposn: 0 < ordsucc n.
{ exact (ordinal_ordsucc_pos n Hn_ord). }
claim Hposm: 0 < ordsucc m.
{ exact (ordinal_ordsucc_pos m Hm_ord). }
claim Hn1: ordsucc n :e omega.
{ exact (omega_ordsucc n Hn). }
claim Hm1: ordsucc m :e omega.
{ exact (omega_ordsucc m Hm). }
claim HSn: SNo (ordsucc n).
{ exact (omega_SNo (ordsucc n) Hn1). }
claim HSm: SNo (ordsucc m).
{ exact (omega_SNo (ordsucc m) Hm1). }
claim Hposcase_n: inv_nat (ordsucc n) = recip_SNo_pos (ordsucc n).
{ exact (recip_SNo_poscase (ordsucc n) Hposn). }
claim Hposcase_m: inv_nat (ordsucc m) = recip_SNo_pos (ordsucc m).
{ exact (recip_SNo_poscase (ordsucc m) Hposm). }
claim Hpos_eq: recip_SNo_pos (ordsucc n) = recip_SNo_pos (ordsucc m).
{ prove recip_SNo_pos (ordsucc n) = recip_SNo_pos (ordsucc m).
  rewrite <- Hposcase_n.
  rewrite <- Hposcase_m.
  exact Heq. }
claim Hinv_eq: recip_SNo_pos (recip_SNo_pos (ordsucc n)) = recip_SNo_pos (recip_SNo_pos (ordsucc m)).
{ prove recip_SNo_pos (recip_SNo_pos (ordsucc n)) = recip_SNo_pos (recip_SNo_pos (ordsucc m)).
  rewrite Hpos_eq.
  reflexivity. }
claim Hord: ordsucc n = ordsucc m.
{ prove ordsucc n = ordsucc m.
  rewrite <- (recip_SNo_pos_invol (ordsucc n) HSn Hposn).
  rewrite <- (recip_SNo_pos_invol (ordsucc m) HSm Hposm).
  exact Hinv_eq. }
exact (ordsucc_inj n m Hord).
Qed.

Theorem omega_binunion : forall a b:set, a :e omega -> b :e omega -> a :\/: b :e omega.
let a b.
assume Ha: a :e omega.
assume Hb: b :e omega.
prove a :\/: b :e omega.
apply (xm (a :e b)).
- assume Hab: a :e b.
  claim Hsub: a c= b.
  { claim Hb_nat: nat_p b.
    { exact (omega_nat_p b Hb). }
    claim Hb_ord: ordinal b.
    { exact (nat_p_ordinal b Hb_nat). }
    claim Hb_trans: TransSet b.
    { exact (andEL (TransSet b) (forall beta :e b, TransSet beta) Hb_ord). }
    exact (Hb_trans a Hab). }
  claim Heq: a :\/: b = b.
  { apply set_ext.
    - exact (binunion_Subq_min a b b Hsub (Subq_ref b)).
    - exact (binunion_Subq_2 a b). }
  rewrite Heq.
  exact Hb.
- assume Hanb: a /:e b.
  claim Ha_nat: nat_p a.
  { exact (omega_nat_p a Ha). }
  claim Hb_nat: nat_p b.
  { exact (omega_nat_p b Hb). }
  claim Ha_ord: ordinal a.
  { exact (nat_p_ordinal a Ha_nat). }
  claim Hb_ord: ordinal b.
  { exact (nat_p_ordinal b Hb_nat). }
  claim Hcases: a :e b \/ b c= a.
  { exact (ordinal_In_Or_Subq a b Ha_ord Hb_ord). }
  claim Hsub: b c= a.
  { apply (Hcases (b c= a)).
    - assume Hab: a :e b.
      apply FalseE.
      exact (Hanb Hab).
    - assume H. exact H. }
  claim Heq: a :\/: b = a.
  { apply set_ext.
    - exact (binunion_Subq_min a b a (Subq_ref a) Hsub).
    - exact (binunion_Subq_1 a b). }
  rewrite Heq.
  exact Ha.
Qed.

Theorem seq_one_over_n_inj : forall n m:set, n :e omega -> m :e omega ->
  apply_fun seq_one_over_n n = apply_fun seq_one_over_n m -> n = m.
let n m.
assume Hn: n :e omega.
assume Hm: m :e omega.
assume Heq: apply_fun seq_one_over_n n = apply_fun seq_one_over_n m.
prove n = m.
claim HnEq: apply_fun seq_one_over_n n = inv_nat (ordsucc n).
{ exact (seq_one_over_n_apply n Hn). }
claim HmEq: apply_fun seq_one_over_n m = inv_nat (ordsucc m).
{ exact (seq_one_over_n_apply m Hm). }
claim Heq': inv_nat (ordsucc n) = inv_nat (ordsucc m).
{ prove inv_nat (ordsucc n) = inv_nat (ordsucc m).
  rewrite <- HnEq.
  rewrite <- HmEq.
  exact Heq. }
exact (inv_nat_ordsucc_inj n m Hn Hm Heq').
Qed.

Theorem ex17_14_sequence_in_finite_complement_topology : forall x:set,
  x :e R ->
  forall U:set,
    U :e finite_complement_topology R ->
    x :e U ->
    exists N:set, N :e omega /\
      forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n :e U.
let x.
assume HxR: x :e R.
let U.
assume HU: U :e finite_complement_topology R.
assume HxU: x :e U.
prove exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n :e U.
(** let F = R\\U, which is finite since U is nonempty **)
claim HUpow: U :e Power R.
{ exact (SepE1 (Power R) (fun U0:set => finite (R :\: U0) \/ U0 = Empty) U HU). }
claim Hcases: finite (R :\: U) \/ U = Empty.
{ exact (SepE2 (Power R) (fun U0:set => finite (R :\: U0) \/ U0 = Empty) U HU). }
claim HUne: U <> Empty.
{ assume HUe: U = Empty.
  claim HxEmpty: x :e Empty.
  { rewrite <- HUe. exact HxU. }
  exact (EmptyE x HxEmpty). }
claim HF: finite (R :\: U).
{ apply Hcases.
  - assume Hfin. exact Hfin.
  - assume HUe.
    apply FalseE.
    exact (HUne HUe). }
set F := R :\: U.
claim HF_def: F = R :\: U.
{ reflexivity. }
claim HF_fin: finite F.
{ rewrite HF_def. exact HF. }
(** build a bound N so that for all n>=N, the sequence value is not in F **)
claim Hbound: exists N:set, N :e omega /\
  forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n /:e F.
{ apply (finite_ind (fun A:set => exists N:set, N :e omega /\
        forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n /:e A)).
  - (** base **)
    prove exists N:set, N :e omega /\
      forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n /:e Empty.
    witness 0.
    apply andI.
    + exact (nat_p_omega 0 nat_0).
    + let n. assume Hn. assume Hsub.
      exact (EmptyE (apply_fun seq_one_over_n n)).
  - (** step **)
    let A y.
    assume HAfin: finite A.
    assume HynA: y /:e A.
    assume HIA: exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n /:e A.
    prove exists N:set, N :e omega /\
      forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n /:e (A :\/: {y}).
    apply HIA.
    let N0. assume HN0.
    claim HN0o: N0 :e omega.
    { exact (andEL (N0 :e omega) (forall n:set, n :e omega -> N0 c= n -> apply_fun seq_one_over_n n /:e A) HN0). }
    claim HN0prop: forall n:set, n :e omega -> N0 c= n -> apply_fun seq_one_over_n n /:e A.
    { exact (andER (N0 :e omega) (forall n:set, n :e omega -> N0 c= n -> apply_fun seq_one_over_n n /:e A) HN0). }
    (** case split: y occurs as a sequence value or not **)
    apply (xm (exists k:set, k :e omega /\ apply_fun seq_one_over_n k = y)).
    - assume Hexk: exists k:set, k :e omega /\ apply_fun seq_one_over_n k = y.
      apply Hexk.
      let k. assume Hkpair.
      claim Hk: k :e omega.
      { exact (andEL (k :e omega) (apply_fun seq_one_over_n k = y) Hkpair). }
      claim Hkeq: apply_fun seq_one_over_n k = y.
      { exact (andER (k :e omega) (apply_fun seq_one_over_n k = y) Hkpair). }
      set N := ordsucc (N0 :\/: ordsucc k).
      witness N.
      apply andI.
      + (** N in omega **)
        claim Hk1: ordsucc k :e omega.
        { exact (omega_ordsucc k Hk). }
        claim Hmax: N0 :\/: ordsucc k :e omega.
        { exact (omega_binunion N0 (ordsucc k) HN0o Hk1). }
        exact (omega_ordsucc (N0 :\/: ordsucc k) Hmax).
      + let n. assume Hn: n :e omega. assume HNsub: N c= n.
        prove apply_fun seq_one_over_n n /:e (A :\/: {y}).
        (** first, n is beyond N0 so the value is not in A **)
        claim HN0sub: N0 c= n.
        { let t. assume Ht: t :e N0.
          claim HtN: t :e N.
          { claim Htmax: t :e (N0 :\/: ordsucc k).
            { exact (binunionI1 N0 (ordsucc k) t Ht). }
            exact (ordsuccI1 (N0 :\/: ordsucc k) t Htmax). }
          exact (HNsub t HtN). }
        claim HnotA: apply_fun seq_one_over_n n /:e A.
        { exact (HN0prop n Hn HN0sub). }
        (** also, n is beyond k, so the value is not y by injectivity **)
        claim HkInN: k :e N.
        { claim HkInSk: k :e ordsucc k.
          { exact (ordsuccI2 k). }
          claim HkInMax: k :e (N0 :\/: ordsucc k).
          { exact (binunionI2 N0 (ordsucc k) k HkInSk). }
          exact (ordsuccI1 (N0 :\/: ordsucc k) k HkInMax). }
        claim HkInNn: k :e n.
        { exact (HNsub k HkInN). }
	        claim Hneqnk: n <> k.
	        { assume Hnk: n = k.
	          claim Hkin: k :e k.
	          { rewrite <- Hnk at 2. exact HkInNn. }
	          exact (In_irref k Hkin). }
	        claim Hneqval: apply_fun seq_one_over_n n <> y.
	        { assume Hval: apply_fun seq_one_over_n n = y.
	          claim HnEqk: n = k.
	          { claim Hkeq': y = apply_fun seq_one_over_n k.
	            { prove y = apply_fun seq_one_over_n k.
	              symmetry.
	              exact Hkeq. }
	            claim Heqnk: apply_fun seq_one_over_n n = apply_fun seq_one_over_n k.
	            { exact (eq_i_tra (apply_fun seq_one_over_n n) y (apply_fun seq_one_over_n k) Hval Hkeq'). }
	            exact (seq_one_over_n_inj n k Hn Hk Heqnk). }
	          exact (Hneqnk HnEqk). }
        (** combine **)
        assume Hmem: apply_fun seq_one_over_n n :e (A :\/: {y}).
        apply (binunionE' A {y} (apply_fun seq_one_over_n n) False).
        - assume HinA. exact (HnotA HinA).
        - assume HinSing.
          claim Heqv: apply_fun seq_one_over_n n = y.
          { exact (SingE y (apply_fun seq_one_over_n n) HinSing). }
          exact (Hneqval Heqv).
        - exact Hmem.
    - assume Hno: ~(exists k:set, k :e omega /\ apply_fun seq_one_over_n k = y).
      (** N0 already works **)
      witness N0.
      apply andI.
      + exact HN0o.
      + let n. assume Hn: n :e omega. assume HN0sub: N0 c= n.
        prove apply_fun seq_one_over_n n /:e (A :\/: {y}).
        claim HnotA: apply_fun seq_one_over_n n /:e A.
        { exact (HN0prop n Hn HN0sub). }
        claim Hnoty: apply_fun seq_one_over_n n /:e {y}.
        { assume Hin.
          claim Heqv: apply_fun seq_one_over_n n = y.
          { exact (SingE y (apply_fun seq_one_over_n n) Hin). }
          apply Hno.
          witness n.
          apply andI.
          - exact Hn.
          - exact Heqv. }
        assume Hmem: apply_fun seq_one_over_n n :e (A :\/: {y}).
        apply (binunionE' A {y} (apply_fun seq_one_over_n n) False).
        - assume HinA. exact (HnotA HinA).
        - assume HinS. exact (Hnoty HinS).
        - exact Hmem.
  - (** apply to F **)
    exact HF_fin.
}
apply Hbound.
let N. assume HNpair.
claim HN: N :e omega.
{ exact (andEL (N :e omega) (forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n /:e F) HNpair). }
claim HNprop: forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n /:e F.
{ exact (andER (N :e omega) (forall n:set, n :e omega -> N c= n -> apply_fun seq_one_over_n n /:e F) HNpair). }
witness N.
apply andI.
- exact HN.
- let n. assume Hn: n :e omega. assume HNsub: N c= n.
  (** show the value lies in U by contradiction: otherwise it would be in F=R\\U **)
  claim HvalR: apply_fun seq_one_over_n n :e R.
  { rewrite (seq_one_over_n_apply n Hn).
    exact (inv_nat_real (ordsucc n) (omega_ordsucc n Hn)). }
  claim HnotF: apply_fun seq_one_over_n n /:e F.
  { exact (HNprop n Hn HNsub). }
  apply (xm (apply_fun seq_one_over_n n :e U)).
  * assume HvalU. exact HvalU.
  * assume HnotU: ~(apply_fun seq_one_over_n n :e U).
    claim HinF: apply_fun seq_one_over_n n :e F.
    { prove apply_fun seq_one_over_n n :e F.
      rewrite HF_def.
      apply setminusI.
      - exact HvalR.
      - exact HnotU. }
    exact (FalseE (HnotF HinF) (apply_fun seq_one_over_n n :e U)).
Qed.

(** helper: T1_space is equivalent to all singleton subsets being closed **)
Theorem lemma_T1_singletons_closed : forall X Tx:set,
  topology_on X Tx ->
  (T1_space X Tx <-> (forall x:set, x :e X -> closed_in X Tx {x})).
let X Tx.
assume Htop: topology_on X Tx.
prove T1_space X Tx <-> (forall x:set, x :e X -> closed_in X Tx {x}).
apply iffI.
- (** Forward: T1_space  singletons closed **)
  assume HT1: T1_space X Tx.
  prove forall x:set, x :e X -> closed_in X Tx {x}.
  let x.
  assume Hx: x :e X.
  prove closed_in X Tx {x}.
  (** By definition of T1_space, all finite subsets are closed.
      Singletons are finite subsets, so {x} is closed. **)
  claim HT1_def: topology_on X Tx /\ (forall F:set, F c= X -> finite F -> closed_in X Tx F).
  { exact HT1. }
  claim Hfinite_closed: forall F:set, F c= X -> finite F -> closed_in X Tx F.
  { exact (andER (topology_on X Tx) (forall F:set, F c= X -> finite F -> closed_in X Tx F) HT1_def). }
  claim Hx_finite: finite {x}.
  { exact (Sing_finite x). }
  claim Hx_sub: {x} c= X.
  { let y. assume Hy: y :e {x}.
    claim Hyeq: y = x.
    { exact (SingE x y Hy). }
    rewrite Hyeq. exact Hx. }
  exact (Hfinite_closed {x} Hx_sub Hx_finite).
- (** Backward: singletons closed  T1_space **)
  assume Hsing: forall x:set, x :e X -> closed_in X Tx {x}.
  prove T1_space X Tx.
  prove topology_on X Tx /\ (forall F:set, F c= X -> finite F -> closed_in X Tx F).
  apply andI.
  + exact Htop.
  + prove forall F:set, F c= X -> finite F -> closed_in X Tx F.
    let F. assume HFsub: F c= X. assume HF: finite F.
	    prove closed_in X Tx F.
		    (** Strategy: Every finite subset is a finite union of singletons.
		        Since each singleton is closed and closed sets are closed under finite unions,
		        F is closed. This requires:
		        1. Decomposing F as a union of singletons
		        2. Showing binary/finite unions of closed sets are closed
		        We prove this by finite induction on F, using closure under binary unions. **)
		    claim Hclosed_empty: closed_in X Tx Empty.
		    { exact (empty_is_closed X Tx Htop). }
		    claim Hclosed_union: forall A B:set, closed_in X Tx A -> closed_in X Tx B -> closed_in X Tx (A :\/: B).
		    { let A B. assume HA. assume HB.
		      exact (union_of_closed_is_closed X Tx A B Htop HA HB). }
		    claim Hall: forall F0:set, finite F0 -> (F0 c= X -> closed_in X Tx F0).
		    { exact (finite_ind
		               (fun F0:set => F0 c= X -> closed_in X Tx F0)
		               (fun _ => Hclosed_empty)
	               (fun F0 y:set =>
	                  fun HFin0 HyNotin IH =>
                    fun HsubUnion =>
		                      Hclosed_union F0 {y}
		                        (IH (fun z Hz => HsubUnion z (binunionI1 F0 {y} z Hz)))
		                        (Hsing y (HsubUnion y (binunionI2 F0 {y} y (SingI y)))))
		               ). }
	    claim Hspec: F c= X -> closed_in X Tx F.
	    { exact (Hall F HF). }
	    exact (Hspec HFsub).
Qed.

(** helper: in a T1 space, the complement of a singleton is open **)
(** LATEX VERSION: In a T1 space, X\\{x} is open for every xX. **)
Theorem T1_singleton_complement_open : forall X Tx x:set,
  T1_space X Tx -> x :e X -> X :\: {x} :e Tx.
let X Tx x.
assume HT1: T1_space X Tx.
assume HxX: x :e X.
prove X :\: {x} :e Tx.
claim Htop: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall F:set, F c= X -> finite F -> closed_in X Tx F)
               HT1). }
claim Hsing: closed_in X Tx {x}.
{ exact ((iffEL (T1_space X Tx)
                (forall z:set, z :e X -> closed_in X Tx {z})
                (lemma_T1_singletons_closed X Tx Htop) HT1) x HxX). }
claim Hdef: topology_on X Tx /\ ({x} c= X /\ exists U :e Tx, {x} = X :\: U).
{ exact Hsing. }
claim Hsubex: {x} c= X /\ exists U :e Tx, {x} = X :\: U.
{ exact (andER (topology_on X Tx) ({x} c= X /\ exists U :e Tx, {x} = X :\: U) Hdef). }
claim HexU: exists U :e Tx, {x} = X :\: U.
{ exact (andER ({x} c= X) (exists U :e Tx, {x} = X :\: U) Hsubex). }
apply HexU.
let U. assume HUeq.
claim HUinTx: U :e Tx.
{ exact (andEL (U :e Tx) ({x} = X :\: U) HUeq). }
claim Hxeq: {x} = X :\: U.
{ exact (andER (U :e Tx) ({x} = X :\: U) HUeq). }
claim HxnotU: x /:e U.
{ claim HxIn: x :e X :\: U.
  { rewrite <- Hxeq. exact (SingI x). }
  exact (setminusE2 X U x HxIn). }
claim HeqU: U = X :\: {x}.
{ apply set_ext.
  - let z. assume HzU: z :e U.
    prove z :e X :\: {x}.
    claim HzX: z :e X.
    { claim HTsub: Tx c= Power X.
      { exact (topology_subset_axiom X Tx Htop). }
      claim HUPow: U :e Power X.
      { exact (HTsub U HUinTx). }
      claim HUsub: U c= X.
      { exact (PowerE X U HUPow). }
      exact (HUsub z HzU). }
    apply setminusI.
    + exact HzX.
    + assume HzSing: z :e {x}.
      claim Hzeq: z = x.
      { exact (SingE x z HzSing). }
      claim HxU: x :e U.
      { prove x :e U.
        rewrite <- Hzeq.
        exact HzU. }
      exact (HxnotU HxU).
  - let z. assume Hz: z :e X :\: {x}.
    prove z :e U.
    apply (xm (z :e U)).
    + assume HzU: z :e U.
      exact HzU.
    + assume HznotU: z /:e U.
      claim HzIn: z :e X :\: U.
      { exact (setminusI X U z (setminusE1 X {x} z Hz) HznotU). }
      claim HzSing: z :e {x}.
      { rewrite Hxeq. exact HzIn. }
      claim Hfalse: False.
      { exact ((setminusE2 X {x} z Hz) HzSing). }
      apply FalseE.
      exact Hfalse.
	}
rewrite <- HeqU.
exact HUinTx.
Qed.

(** helper: subspaces of T1 spaces are T1 **)
(** LATEX VERSION: If X is T1, then every subspace YX is T1 in the subspace topology. **)
Theorem subspace_T1 : forall X Tx Y:set,
  topology_on X Tx -> Y c= X -> T1_space X Tx -> T1_space Y (subspace_topology X Tx Y).
let X Tx Y.
assume HTx: topology_on X Tx.
assume HY: Y c= X.
assume HT1: T1_space X Tx.
prove T1_space Y (subspace_topology X Tx Y).
claim HTy: topology_on Y (subspace_topology X Tx Y).
{ exact (subspace_topology_is_topology X Tx Y HTx HY). }
apply (iffER (T1_space Y (subspace_topology X Tx Y))
             (forall y:set, y :e Y -> closed_in Y (subspace_topology X Tx Y) {y})
             (lemma_T1_singletons_closed Y (subspace_topology X Tx Y) HTy)).
prove forall y:set, y :e Y -> closed_in Y (subspace_topology X Tx Y) {y}.
let y. assume HyY: y :e Y.
prove closed_in Y (subspace_topology X Tx Y) {y}.
apply (iffER (closed_in Y (subspace_topology X Tx Y) {y})
             (exists C:set, closed_in X Tx C /\ {y} = C :/\: Y)
             (closed_in_subspace_iff_intersection X Tx Y {y} HTx HY)).
witness {y}.
apply andI.
- (** singleton closed in X by T1 **)
  exact ((iffEL (T1_space X Tx)
                (forall z:set, z :e X -> closed_in X Tx {z})
                (lemma_T1_singletons_closed X Tx HTx) HT1) y (HY y HyY)).
- (** {y} = {y}  Y since yY **)
  apply set_ext.
  * let z. assume Hz: z :e {y}.
    prove z :e {y} :/\: Y.
    claim Hzeq: z = y.
    { exact (SingE y z Hz). }
    rewrite Hzeq.
    exact (binintersectI {y} Y y (SingI y) HyY).
  * let z. assume Hz: z :e {y} :/\: Y.
    prove z :e {y}.
    exact (binintersectE1 {y} Y z Hz).
Qed.

(** LATEX VERSION: Exercise 15: Show the T1 axiom is equivalent to the condition that for each pair of points of X, each has a neighborhood not containing the other. **)
Theorem ex17_15_T1_characterization : forall X Tx:set,
  topology_on X Tx ->
  (T1_space X Tx <->
    forall x y:set, x :e X -> y :e X -> x <> y ->
      (exists U:set, U :e Tx /\ x :e U /\ y /:e U) /\
      (exists V:set, V :e Tx /\ y :e V /\ x /:e V)).
let X Tx.
assume Htop: topology_on X Tx.
prove T1_space X Tx <->
    forall x y:set, x :e X -> y :e X -> x <> y ->
      (exists U:set, U :e Tx /\ x :e U /\ y /:e U) /\
      (exists V:set, V :e Tx /\ y :e V /\ x /:e V).
apply iffI.
- assume HT1: T1_space X Tx.
  prove forall x y:set, x :e X -> y :e X -> x <> y ->
      (exists U:set, U :e Tx /\ x :e U /\ y /:e U) /\
      (exists V:set, V :e Tx /\ y :e V /\ x /:e V).
	  claim Hsing_closed: forall z:set, z :e X -> closed_in X Tx {z}.
	  { exact (iffEL (T1_space X Tx) (forall z:set, z :e X -> closed_in X Tx {z})
	                 (lemma_T1_singletons_closed X Tx Htop) HT1). }
  let x y.
  assume HxX: x :e X.
  assume HyX: y :e X.
  assume Hne: x <> y.
  prove (exists U:set, U :e Tx /\ x :e U /\ y /:e U) /\ (exists V:set, V :e Tx /\ y :e V /\ x /:e V).
  apply andI.
  - (** neighborhood of x missing y from closedness of {y} **)
    claim Hcy: closed_in X Tx {y}.
    { exact (Hsing_closed y HyX). }
    claim Hcy2: {y} c= X /\ exists U :e Tx, {y} = X :\: U.
    { exact (andER (topology_on X Tx) ({y} c= X /\ exists U :e Tx, {y} = X :\: U) Hcy). }
    claim HexU: exists U:set, U :e Tx /\ {y} = X :\: U.
    { exact (andER ({y} c= X) (exists U :e Tx, {y} = X :\: U) Hcy2). }
    set U := Eps_i (fun U0:set => U0 :e Tx /\ {y} = X :\: U0).
    claim HUprop: U :e Tx /\ {y} = X :\: U.
    { exact (Eps_i_ex (fun U0:set => U0 :e Tx /\ {y} = X :\: U0) HexU). }
    claim HUopen: U :e Tx.
    { exact (andEL (U :e Tx) ({y} = X :\: U) HUprop). }
    claim Heq: {y} = X :\: U.
    { exact (andER (U :e Tx) ({y} = X :\: U) HUprop). }
    witness U.
    apply andI.
    - apply andI.
      + exact HUopen.
      + (** x is in U since xy and {y}=X\\U **)
        claim Hxnoty: x /:e {y}.
        { assume Hxy: x :e {y}.
          claim Hxyeq: x = y.
          { exact (SingE y x Hxy). }
          exact (Hne Hxyeq). }
        claim Hxnot: x /:e (X :\: U).
        { rewrite <- Heq. exact Hxnoty. }
        apply (xm (x :e U)).
        * assume HxU: x :e U. exact HxU.
        * assume HxnotU: ~(x :e U).
          claim HxXU: x :e X :\: U.
          { exact (setminusI X U x HxX HxnotU). }
          exact (FalseE (Hxnot HxXU) (x :e U)).
    - (** y not in U since y  X\\U = {y} **)
      assume HyU: y :e U.
      claim HySing: y :e {y}.
      { exact (SingI y). }
      claim HyXU: y :e X :\: U.
      { prove y :e X :\: U.
        rewrite <- Heq.
        exact HySing. }
      exact ((setminusE2 X U y HyXU) HyU).
  - (** neighborhood of y missing x from closedness of {x} **)
    claim Hcx: closed_in X Tx {x}.
    { exact (Hsing_closed x HxX). }
    claim Hcx2: {x} c= X /\ exists V :e Tx, {x} = X :\: V.
    { exact (andER (topology_on X Tx) ({x} c= X /\ exists V :e Tx, {x} = X :\: V) Hcx). }
    claim HexV: exists V:set, V :e Tx /\ {x} = X :\: V.
    { exact (andER ({x} c= X) (exists V :e Tx, {x} = X :\: V) Hcx2). }
    set V := Eps_i (fun V0:set => V0 :e Tx /\ {x} = X :\: V0).
    claim HVprop: V :e Tx /\ {x} = X :\: V.
    { exact (Eps_i_ex (fun V0:set => V0 :e Tx /\ {x} = X :\: V0) HexV). }
    claim HVopen: V :e Tx.
    { exact (andEL (V :e Tx) ({x} = X :\: V) HVprop). }
    claim Heq: {x} = X :\: V.
    { exact (andER (V :e Tx) ({x} = X :\: V) HVprop). }
    witness V.
    apply andI.
    - apply andI.
      + exact HVopen.
      + (** y in V since yx and {x}=X\\V **)
	        claim Hynotx: y /:e {x}.
	        { assume Hyx: y :e {x}.
	          claim Hyxeq: y = x.
	          { exact (SingE x y Hyx). }
	          claim Hxyeq: x = y.
	          { rewrite Hyxeq. reflexivity. }
	          exact (Hne Hxyeq). }
        claim Hynot: y /:e (X :\: V).
        { rewrite <- Heq. exact Hynotx. }
        apply (xm (y :e V)).
        * assume HyV: y :e V. exact HyV.
        * assume HynotV: ~(y :e V).
          claim HyXV: y :e X :\: V.
          { exact (setminusI X V y HyX HynotV). }
          exact (FalseE (Hynot HyXV) (y :e V)).
    - (** x not in V since x  X\\V = {x} **)
      assume HxV: x :e V.
      claim HxSing: x :e {x}.
      { exact (SingI x). }
      claim HxXV: x :e X :\: V.
      { prove x :e X :\: V.
        rewrite <- Heq.
        exact HxSing. }
      exact ((setminusE2 X V x HxXV) HxV).
- assume Hsep:
    forall x y:set, x :e X -> y :e X -> x <> y ->
      (exists U:set, U :e Tx /\ x :e U /\ y /:e U) /\
      (exists V:set, V :e Tx /\ y :e V /\ x /:e V).
  prove T1_space X Tx.
  (** it suffices to prove all singletons are closed **)
  apply (iffER (T1_space X Tx) (forall z:set, z :e X -> closed_in X Tx {z})
               (lemma_T1_singletons_closed X Tx Htop)).
  prove forall z:set, z :e X -> closed_in X Tx {z}.
  let x. assume HxX: x :e X.
  prove closed_in X Tx {x}.
  (** show X\\{x} is open as union of all open sets not containing x **)
  set UFam := {U :e Tx|x /:e U}.
  claim HUnionOpen: Union UFam :e Tx.
  { claim HUFamSub: UFam c= Tx.
    { let U. assume HU: U :e UFam.
      exact (SepE1 Tx (fun U0:set => x /:e U0) U HU). }
    exact (topology_union_closed X Tx UFam Htop HUFamSub). }
  claim HUnionEq: Union UFam = X :\: {x}.
	  { apply set_ext.
	    - let y. assume HyU: y :e Union UFam.
	      prove y :e X :\: {x}.
	      claim HyUex: exists W:set, y :e W /\ W :e UFam.
	      { exact (UnionE UFam y HyU). }
	      set U := Eps_i (fun U0:set => y :e U0 /\ U0 :e UFam).
	      claim HUprop: y :e U /\ U :e UFam.
	      { exact (Eps_i_ex (fun U0:set => y :e U0 /\ U0 :e UFam) HyUex). }
      claim HyU0: y :e U.
      { exact (andEL (y :e U) (U :e UFam) HUprop). }
      claim HUin: U :e UFam.
      { exact (andER (y :e U) (U :e UFam) HUprop). }
      claim HUinTx: U :e Tx.
      { exact (SepE1 Tx (fun U0:set => x /:e U0) U HUin). }
      claim HUSubX: U c= X.
      { exact (topology_elem_subset X Tx U Htop HUinTx). }
      claim HyX: y :e X.
      { exact (HUSubX y HyU0). }
      claim Hynotx: y /:e {x}.
      { assume Hyx: y :e {x}.
	        claim Hyxeq: y = x.
	        { exact (SingE x y Hyx). }
		        claim HxnotU: x /:e U.
		        { exact (SepE2 Tx (fun U0:set => x /:e U0) U HUin). }
			        claim HynotU: y /:e U.
			        { assume HyU1: y :e U.
			          claim Hxy: x = y.
			          { prove x = y.
			            symmetry.
			            exact Hyxeq. }
				          claim HxU1: x :e U.
				          { prove x :e U.
				            rewrite Hxy at 1.
				            exact HyU1. }
				          exact (HxnotU HxU1). }
		        exact (HynotU HyU0). }
	      exact (setminusI X {x} y HyX Hynotx).
    - let y. assume HyXx: y :e X :\: {x}.
      prove y :e Union UFam.
      claim HyX: y :e X.
      { exact (setminusE1 X {x} y HyXx). }
	      claim Hynot: y /:e {x}.
	      { exact (setminusE2 X {x} y HyXx). }
	      claim Hyne: y <> x.
	      { assume Heq.
	        claim Hyx: y :e {x}.
	        { prove y :e {x}.
	          rewrite Heq.
	          exact (SingI x). }
	        exact (Hynot Hyx). }
	      claim Hsep_yx: exists V:set, V :e Tx /\ y :e V /\ x /:e V.
	      { exact (andEL (exists V:set, V :e Tx /\ y :e V /\ x /:e V)
	                     (exists U:set, U :e Tx /\ x :e U /\ y /:e U)
	                     (Hsep y x HyX HxX Hyne)). }
      set V := Eps_i (fun V0:set => V0 :e Tx /\ y :e V0 /\ x /:e V0).
	      claim HVprop: V :e Tx /\ y :e V /\ x /:e V.
	      { exact (Eps_i_ex (fun V0:set => V0 :e Tx /\ y :e V0 /\ x /:e V0) Hsep_yx). }
	      claim HVleft: V :e Tx /\ y :e V.
	      { exact (andEL (V :e Tx /\ y :e V) (x /:e V) HVprop). }
	      claim HVinTx: V :e Tx.
	      { exact (andEL (V :e Tx) (y :e V) HVleft). }
	      claim HyV: y :e V.
	      { exact (andER (V :e Tx) (y :e V) HVleft). }
	      claim HxnotV: x /:e V.
	      { exact (andER (V :e Tx /\ y :e V) (x /:e V) HVprop). }
      claim HVinFam: V :e UFam.
      { exact (SepI Tx (fun U0:set => x /:e U0) V HVinTx HxnotV). }
      exact (UnionI UFam y V HyV HVinFam).
  }
  (** {x} is closed as complement of the open set X\\{x} **)
  prove topology_on X Tx /\ ({x} c= X /\ exists U :e Tx, {x} = X :\: U).
  apply andI.
  - exact Htop.
  - apply andI.
    + let z. assume Hz: z :e {x}.
      claim Hzeq: z = x.
      { exact (SingE x z Hz). }
      rewrite Hzeq.
      exact HxX.
	    + witness (Union UFam).
		      apply andI.
		      * exact HUnionOpen.
      * apply set_ext.
        { let z. assume Hz: z :e {x}.
          prove z :e X :\: Union UFam.
          claim Hzeq: z = x.
          { exact (SingE x z Hz). }
          rewrite Hzeq.
          apply setminusI.
          - exact HxX.
          - assume Hxin: x :e Union UFam.
            claim Hxin': x :e X :\: {x}.
            { prove x :e X :\: {x}.
              rewrite <- HUnionEq.
              exact Hxin. }
            exact ((setminusE2 X {x} x Hxin') (SingI x)).
        }
        { let z. assume Hz: z :e X :\: Union UFam.
          prove z :e {x}.
          (** use setminus_setminus_eq with U = Union UFam = X\\{x} **)
          claim HsingSub: {x} c= X.
          { let t. assume Ht: t :e {x}.
            claim Hteq: t = x.
            { exact (SingE x t Ht). }
            rewrite Hteq.
            exact HxX. }
          rewrite <- (setminus_setminus_eq X {x} HsingSub).
          rewrite <- HUnionEq.
          exact Hz.
        }
Qed.

(** LATEX VERSION: Exercise 16(a): Determine the closure of K={1/n : n in Zplus} under each of the five R topologies from 13 Exercise 7. **)
Definition R_nonneg_set : set := {x :e R|0 <= x}.

Axiom ex17_16a_closure_of_K_in_five_topologies_axiom :
  closure_of R R_standard_topology K_set = K_set :\/: {0} /\
  closure_of R R_K_topology K_set = K_set /\
  closure_of R R_finite_complement_topology K_set = R /\
  closure_of R R_upper_limit_topology K_set = K_set /\
  closure_of R R_ray_topology K_set = R_nonneg_set.

Theorem ex17_16a_closure_of_K_in_five_topologies :
  closure_of R R_standard_topology K_set = K_set :\/: {0} /\
  closure_of R R_K_topology K_set = K_set /\
  closure_of R R_finite_complement_topology K_set = R /\
  closure_of R R_upper_limit_topology K_set = K_set /\
  closure_of R R_ray_topology K_set = R_nonneg_set.
prove closure_of R R_standard_topology K_set = K_set :\/: {0} /\
  closure_of R R_K_topology K_set = K_set /\
  closure_of R R_finite_complement_topology K_set = R /\
  closure_of R R_upper_limit_topology K_set = K_set /\
  closure_of R R_ray_topology K_set = R_nonneg_set.
exact ex17_16a_closure_of_K_in_five_topologies_axiom.
Qed.

(** helper: in the left ray topology, any open set containing 1 contains 0 **)
Theorem ray_topology_contains_0_if_contains_1 : forall U:set,
  U :e R_ray_topology -> 1 :e U -> 0 :e U.
let U.
assume HU: U :e R_ray_topology.
assume H1U: 1 :e U.
prove 0 :e U.
claim HUcases: U = Empty \/ U = R \/ exists a :e R, U = {x :e R|Rlt x a}.
{ exact (SepE2 (Power R) (fun U0 : set => U0 = Empty \/ U0 = R \/ exists a0 :e R, U0 = {x :e R|Rlt x a0}) U HU). }
apply (HUcases (0 :e U)).
- assume HUR: U = Empty \/ U = R.
  apply (HUR (0 :e U)).
  + assume HUe: U = Empty.
    apply FalseE.
    claim H1Empty: 1 :e Empty.
    prove 1 :e Empty.
    rewrite <- HUe at 2.
    exact H1U.
    exact ((EmptyE 1) H1Empty).
  + assume HUeqR: U = R.
    rewrite HUeqR.
    exact real_0.
- assume Hex: exists a :e R, U = {x :e R|Rlt x a}.
  apply Hex.
  let a.
  assume Hapair: a :e R /\ U = {x :e R|Rlt x a}.
  claim HaR: a :e R.
  { exact (andEL (a :e R) (U = {x :e R|Rlt x a}) Hapair). }
  claim HUeq: U = {x :e R|Rlt x a}.
  { exact (andER (a :e R) (U = {x :e R|Rlt x a}) Hapair). }
  rewrite HUeq.
  prove 0 :e {x :e R|Rlt x a}.
  claim H1in: 1 :e {x :e R|Rlt x a}.
  { rewrite <- HUeq.
    exact H1U. }
  claim H1lt: Rlt 1 a.
  { exact (SepE2 R (fun x0:set => Rlt x0 a) 1 H1in). }
  claim H0lt1: Rlt 0 1.
  { exact (RltI 0 1 real_0 real_1 SNoLt_0_1). }
  claim H0lta: Rlt 0 a.
  { exact (Rlt_tra 0 1 a H0lt1 H1lt). }
  exact (SepI R (fun x0:set => Rlt x0 a) 0 real_0 H0lta).
Qed.

(** helper: the left ray topology on R is not Hausdorff **)
Theorem ray_topology_not_Hausdorff : ~Hausdorff_space R R_ray_topology.
assume HH: Hausdorff_space R R_ray_topology.
prove False.
claim Hsep: forall x1 x2:set, x1 :e R -> x2 :e R -> x1 <> x2 ->
  exists U V:set, U :e R_ray_topology /\ V :e R_ray_topology /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
{ exact (andER (topology_on R R_ray_topology)
               (forall x1 x2:set, x1 :e R -> x2 :e R -> x1 <> x2 ->
                 exists U V:set, U :e R_ray_topology /\ V :e R_ray_topology /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }
claim H01ne: 0 <> 1.
{ assume H01eq: 0 = 1.
  claim H00lt: 0 < 0.
  { rewrite H01eq at 2.
    exact SNoLt_0_1. }
  exact ((SNoLt_irref 0) H00lt). }
claim HUVex: exists U V:set, U :e R_ray_topology /\ V :e R_ray_topology /\ 0 :e U /\ 1 :e V /\ U :/\: V = Empty.
{ exact (Hsep 0 1 real_0 real_1 H01ne). }
apply HUVex.
let U.
assume HVex: exists V:set, U :e R_ray_topology /\ V :e R_ray_topology /\ 0 :e U /\ 1 :e V /\ U :/\: V = Empty.
apply HVex.
let V.
assume HUV.
claim HUVleft: (((U :e R_ray_topology /\ V :e R_ray_topology) /\ 0 :e U) /\ 1 :e V).
{ exact (andEL (((U :e R_ray_topology /\ V :e R_ray_topology) /\ 0 :e U) /\ 1 :e V)
               (U :/\: V = Empty)
               HUV). }
claim HUVempty: U :/\: V = Empty.
{ exact (andER (((U :e R_ray_topology /\ V :e R_ray_topology) /\ 0 :e U) /\ 1 :e V)
               (U :/\: V = Empty)
               HUV). }
claim HUVleft2: ((U :e R_ray_topology /\ V :e R_ray_topology) /\ 0 :e U).
{ exact (andEL ((U :e R_ray_topology /\ V :e R_ray_topology) /\ 0 :e U)
               (1 :e V)
               HUVleft). }
claim H1V: 1 :e V.
{ exact (andER ((U :e R_ray_topology /\ V :e R_ray_topology) /\ 0 :e U)
               (1 :e V)
               HUVleft). }
claim HUVleft3: (U :e R_ray_topology /\ V :e R_ray_topology).
{ exact (andEL (U :e R_ray_topology /\ V :e R_ray_topology)
               (0 :e U)
               HUVleft2). }
claim H0U: 0 :e U.
{ exact (andER (U :e R_ray_topology /\ V :e R_ray_topology)
               (0 :e U)
               HUVleft2). }
claim HU: U :e R_ray_topology.
{ exact (andEL (U :e R_ray_topology)
               (V :e R_ray_topology)
               HUVleft3). }
claim HV: V :e R_ray_topology.
{ exact (andER (U :e R_ray_topology)
               (V :e R_ray_topology)
               HUVleft3). }
claim H0V: 0 :e V.
{ exact (ray_topology_contains_0_if_contains_1 V HV H1V). }
claim H0UV: 0 :e U :/\: V.
{ exact (binintersectI U V 0 H0U H0V). }
claim H0Empty: 0 :e Empty.
prove 0 :e Empty.
rewrite <- HUVempty at 2.
exact H0UV.
exact (EmptyE 0 H0Empty).
Qed.

(** helper: the left ray topology on R is not T1 **)
Theorem ray_topology_not_T1 : ~T1_space R R_ray_topology.
assume HT1: T1_space R R_ray_topology.
prove False.
claim Hfinite_closed: forall F:set, F c= R -> finite F -> closed_in R R_ray_topology F.
{ exact (andER (topology_on R R_ray_topology)
               (forall F:set, F c= R -> finite F -> closed_in R R_ray_topology F)
               HT1). }
claim Hsub0: {0} c= R.
{ let x. assume Hx0: x :e {0}.
  claim Hxeq: x = 0.
  { exact (SingE 0 x Hx0). }
  rewrite Hxeq.
  exact real_0. }
claim Hfin0: finite {0}.
{ exact (Sing_finite 0). }
claim Hclosed0: closed_in R R_ray_topology {0}.
{ exact (Hfinite_closed {0} Hsub0 Hfin0). }
claim Hclosed0core: {0} c= R /\ exists U :e R_ray_topology, {0} = R :\: U.
{ exact (andER (topology_on R R_ray_topology)
               ({0} c= R /\ exists U :e R_ray_topology, {0} = R :\: U)
               Hclosed0). }
claim HexUtyped: exists U :e R_ray_topology, {0} = R :\: U.
{ exact (andER ({0} c= R) (exists U :e R_ray_topology, {0} = R :\: U) Hclosed0core). }
apply HexUtyped.
let U.
assume HUrep: U :e R_ray_topology /\ {0} = R :\: U.
claim HU: U :e R_ray_topology.
{ exact (andEL (U :e R_ray_topology) ({0} = R :\: U) HUrep). }
claim Heq: {0} = R :\: U.
{ exact (andER (U :e R_ray_topology) ({0} = R :\: U) HUrep). }
claim H1in: 1 :e U.
{ claim H1not0: 1 /:e {0}.
  { assume H10: 1 :e {0}.
    claim H10eq: 1 = 0.
    { exact (SingE 0 1 H10). }
    claim H00lt: 0 < 0.
    { rewrite <- H10eq at 2.
      exact SNoLt_0_1. }
    exact ((SNoLt_irref 0) H00lt). }
  prove 1 :e U.
  apply (xm (1 :e U)).
  - assume H. exact H.
  - assume HnU: ~(1 :e U).
    claim H1incomp: 1 :e R :\: U.
    { exact (setminusI R U 1 real_1 HnU). }
    claim H1in0: 1 :e {0}.
    { claim Hsubst: forall S T:set, S = T -> 1 :e T -> 1 :e S.
      { let S T.
        assume HeqST: S = T.
        assume H1inT: 1 :e T.
        prove 1 :e S.
        rewrite HeqST.
        exact H1inT. }
      exact (Hsubst {0} (R :\: U) Heq H1incomp). }
    apply FalseE.
    exact (H1not0 H1in0). }
claim H0in: 0 :e U.
{ exact (ray_topology_contains_0_if_contains_1 U HU H1in). }
claim H0incomp: 0 :e R :\: U.
{ rewrite <- Heq.
  exact (SingI 0). }
claim H0not: 0 /:e U.
{ exact (setminusE2 R U 0 H0incomp). }
exact (H0not H0in).
Qed.

(** helper: X minus Empty equals X **)
Theorem setminus_Empty_eq : forall X:set, X :\: Empty = X.
let X.
apply set_ext.
- let x. assume Hx: x :e X :\: Empty.
  exact (setminusE1 X Empty x Hx).
- let x. assume HxX: x :e X.
  exact (setminusI X Empty x HxX (EmptyE x)).
Qed.

(** helper: R is infinite **)
Theorem infinite_R : infinite R.
(** from pre-topology: real is uncountable, so in particular infinite **)
claim Hunc: atleastp omega real /\ ~equip real omega.
{ exact form100_22_real_uncountable. }
claim Hatleast: atleastp omega real.
{ exact (andEL (atleastp omega real) (~equip real omega) Hunc). }
prove infinite R.
exact (atleastp_omega_infinite real Hatleast).
Qed.

(** helper: finite complement topology is T1 **)
Theorem finite_complement_topology_T1 : forall X:set, T1_space X (finite_complement_topology X).
let X.
claim Htop: topology_on X (finite_complement_topology X).
{ exact (finite_complement_topology_on X). }
prove topology_on X (finite_complement_topology X) /\ (forall F:set, F c= X -> finite F -> closed_in X (finite_complement_topology X) F).
apply andI.
- exact Htop.
- let F. assume HFsub: F c= X. assume HFfin: finite F.
  prove closed_in X (finite_complement_topology X) F.
  prove topology_on X (finite_complement_topology X) /\ (F c= X /\ exists U :e finite_complement_topology X, F = X :\: U).
  apply andI.
  + exact Htop.
  + apply andI.
    * exact HFsub.
    * witness (X :\: F).
      apply andI.
      - (** X\\F is open in the finite complement topology **)
        claim HUpow: (X :\: F) :e Power X.
        { exact (setminus_In_Power X F). }
        claim Hfin: finite (X :\: (X :\: F)).
        { rewrite (setminus_setminus_eq X F HFsub).
          exact HFfin. }
        exact (SepI (Power X) (fun U0:set => finite (X :\: U0) \/ U0 = Empty)
                    (X :\: F)
                    HUpow
                    (orIL (finite (X :\: (X :\: F))) ((X :\: F) = Empty) Hfin)).
      - (** F = X\\(X\\F) **)
        rewrite (setminus_setminus_eq X F HFsub).
        reflexivity.
Qed.

(** helper: the finite complement topology on R is not Hausdorff **)
Theorem R_finite_complement_not_Hausdorff : ~Hausdorff_space R R_finite_complement_topology.
assume HH: Hausdorff_space R R_finite_complement_topology.
prove False.
claim Hsep: forall x1 x2:set, x1 :e R -> x2 :e R -> x1 <> x2 ->
  exists U V:set, U :e R_finite_complement_topology /\ V :e R_finite_complement_topology /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
{ exact (andER (topology_on R R_finite_complement_topology)
               (forall x1 x2:set, x1 :e R -> x2 :e R -> x1 <> x2 ->
                 exists U V:set, U :e R_finite_complement_topology /\ V :e R_finite_complement_topology /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }
claim H01ne: 0 <> 1.
{ assume H01eq: 0 = 1.
  claim H00lt: 0 < 0.
  { rewrite H01eq at 2.
    exact SNoLt_0_1. }
  exact ((SNoLt_irref 0) H00lt). }
claim HUVex: exists U V:set, U :e R_finite_complement_topology /\ V :e R_finite_complement_topology /\ 0 :e U /\ 1 :e V /\ U :/\: V = Empty.
{ exact (Hsep 0 1 real_0 real_1 H01ne). }
apply HUVex.
let U.
assume HVex: exists V:set, U :e R_finite_complement_topology /\ V :e R_finite_complement_topology /\ 0 :e U /\ 1 :e V /\ U :/\: V = Empty.
apply HVex.
let V.
assume HUV: U :e R_finite_complement_topology /\ V :e R_finite_complement_topology /\ 0 :e U /\ 1 :e V /\ U :/\: V = Empty.
claim Hleft: (((U :e R_finite_complement_topology /\ V :e R_finite_complement_topology) /\ 0 :e U) /\ 1 :e V).
{ exact (andEL (((U :e R_finite_complement_topology /\ V :e R_finite_complement_topology) /\ 0 :e U) /\ 1 :e V)
               (U :/\: V = Empty)
               HUV). }
claim HUVempty: U :/\: V = Empty.
{ exact (andER (((U :e R_finite_complement_topology /\ V :e R_finite_complement_topology) /\ 0 :e U) /\ 1 :e V)
               (U :/\: V = Empty)
               HUV). }
claim Hleft2: ((U :e R_finite_complement_topology /\ V :e R_finite_complement_topology) /\ 0 :e U).
{ exact (andEL ((U :e R_finite_complement_topology /\ V :e R_finite_complement_topology) /\ 0 :e U) (1 :e V) Hleft). }
claim H1V: 1 :e V.
{ exact (andER ((U :e R_finite_complement_topology /\ V :e R_finite_complement_topology) /\ 0 :e U) (1 :e V) Hleft). }
claim Hpair: (U :e R_finite_complement_topology /\ V :e R_finite_complement_topology).
{ exact (andEL (U :e R_finite_complement_topology /\ V :e R_finite_complement_topology) (0 :e U) Hleft2). }
claim H0U: 0 :e U.
{ exact (andER (U :e R_finite_complement_topology /\ V :e R_finite_complement_topology) (0 :e U) Hleft2). }
claim HU: U :e R_finite_complement_topology.
{ exact (andEL (U :e R_finite_complement_topology) (V :e R_finite_complement_topology) Hpair). }
claim HV: V :e R_finite_complement_topology.
{ exact (andER (U :e R_finite_complement_topology) (V :e R_finite_complement_topology) Hpair). }

(** from HU and H0U, derive finite (R\\U); similarly for V **)
claim HUcases: finite (R :\: U) \/ U = Empty.
{ exact (SepE2 (Power R) (fun U0:set => finite (R :\: U0) \/ U0 = Empty) U HU). }
claim HUfin: finite (R :\: U).
{ apply (HUcases (finite (R :\: U))).
  - assume Hfin. exact Hfin.
  - assume HUe: U = Empty.
    apply FalseE.
    claim H0Empty: 0 :e Empty.
    { rewrite <- HUe at 2.
      exact H0U. }
    exact (EmptyE 0 H0Empty). }
claim HVcases: finite (R :\: V) \/ V = Empty.
{ exact (SepE2 (Power R) (fun U0:set => finite (R :\: U0) \/ U0 = Empty) V HV). }
claim HVfin: finite (R :\: V).
{ apply (HVcases (finite (R :\: V))).
  - assume Hfin. exact Hfin.
  - assume HVe: V = Empty.
    apply FalseE.
    claim H1Empty: 1 :e Empty.
    { rewrite <- HVe at 2.
      exact H1V. }
    exact (EmptyE 1 H1Empty). }

(** then (R\\U)  (R\\V) is finite, and so is R\\(UV) by subset **)
claim HfinUnion: finite ((R :\: U) :\/: (R :\: V)).
{ exact (binunion_finite (R :\: U) HUfin (R :\: V) HVfin). }
claim Hsub: R :\: (U :/\: V) c= (R :\: U) :\/: (R :\: V).
{ let x. assume Hx: x :e R :\: (U :/\: V).
  claim HxR: x :e R.
  { exact (setminusE1 R (U :/\: V) x Hx). }
  claim HxNotUV: x /:e (U :/\: V).
  { exact (setminusE2 R (U :/\: V) x Hx). }
  apply (xm (x :e U)).
  - assume HxU: x :e U.
    claim HxNotV: x /:e V.
    { assume HxV: x :e V.
      claim HxUV: x :e U :/\: V.
      { exact (binintersectI U V x HxU HxV). }
      exact (HxNotUV HxUV). }
    claim HxRV: x :e R :\: V.
    { exact (setminusI R V x HxR HxNotV). }
    exact (binunionI2 (R :\: U) (R :\: V) x HxRV).
  - assume HxNotU: ~(x :e U).
    claim HxRU: x :e R :\: U.
    { exact (setminusI R U x HxR HxNotU). }
    exact (binunionI1 (R :\: U) (R :\: V) x HxRU). }
claim HfinDiff: finite (R :\: (U :/\: V)).
{ exact (Subq_finite ((R :\: U) :\/: (R :\: V)) HfinUnion (R :\: (U :/\: V)) Hsub). }
claim HfinR: finite R.
{ claim HeqR: R :\: (U :/\: V) = R.
  { rewrite HUVempty.
    rewrite (setminus_Empty_eq R).
    reflexivity. }
  rewrite <- HeqR.
  exact HfinDiff. }
exact (infinite_R HfinR).
Qed.

(** helper: the standard topology on R is Hausdorff and T1 **)
Theorem R_standard_topology_Hausdorff : Hausdorff_space R R_standard_topology.
prove Hausdorff_space R R_standard_topology.
rewrite <- (standard_topology_is_order_topology).
exact (ex17_10_order_topology_Hausdorff R).
Qed.

Theorem R_standard_topology_T1 : T1_space R R_standard_topology.
claim Htop: topology_on R R_standard_topology.
{ exact R_standard_topology_is_topology_local. }
apply (iffER (T1_space R R_standard_topology)
             (forall z:set, z :e R -> closed_in R R_standard_topology {z})
             (lemma_T1_singletons_closed R R_standard_topology Htop)).
prove forall z:set, z :e R -> closed_in R R_standard_topology {z}.
let z. assume HzR: z :e R.
prove closed_in R R_standard_topology {z}.
claim HzSub: {z} c= R.
{ let y. assume Hy: y :e {z}.
  claim Heq: y = z.
  { exact (SingE z y Hy). }
  rewrite Heq. exact HzR. }
claim HUopen: R :\: {z} :e R_standard_topology.
{ rewrite (Sing_eq_UPair z).
  exact (R_minus_singleton_in_R_standard_topology z HzR). }
claim Hclosed: closed_in R R_standard_topology (R :\: (R :\: {z})).
{ exact (closed_of_open_complement R R_standard_topology (R :\: {z}) Htop HUopen). }
claim Heq: R :\: (R :\: {z}) = {z}.
{ exact (setminus_setminus_eq R {z} HzSub). }
rewrite <- Heq.
exact Hclosed.
Qed.

(** helper: Hausdorff is preserved by passing to a finer topology **)
Theorem finer_preserves_Hausdorff : forall X Tx Ty:set,
  Hausdorff_space X Tx ->
  topology_on X Ty ->
  Tx c= Ty ->
  Hausdorff_space X Ty.
let X Tx Ty.
assume HH: Hausdorff_space X Tx.
assume HTy: topology_on X Ty.
assume Hsub: Tx c= Ty.
prove Hausdorff_space X Ty.
prove topology_on X Ty /\
  forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
    exists U V:set, U :e Ty /\ V :e Ty /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
apply andI.
- exact HTy.
- claim Hsep: forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
    exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
  { exact (andER (topology_on X Tx)
                 (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
                 HH). }
  let x1 x2.
  assume Hx1: x1 :e X.
  assume Hx2: x2 :e X.
  assume Hne: x1 <> x2.
  apply (Hsep x1 x2 Hx1 Hx2 Hne).
  let U. assume HexV.
  apply HexV.
	  let V. assume HUV.
	  witness U.
	  witness V.
	  claim Hpre: (((U :e Tx /\ V :e Tx) /\ x1 :e U) /\ x2 :e V).
	  { exact (andEL (((U :e Tx /\ V :e Tx) /\ x1 :e U) /\ x2 :e V)
	                 (U :/\: V = Empty)
	                 HUV). }
	  claim Hempty: U :/\: V = Empty.
	  { exact (andER (((U :e Tx /\ V :e Tx) /\ x1 :e U) /\ x2 :e V)
	                 (U :/\: V = Empty)
	                 HUV). }
	  claim Hpre2: ((U :e Tx /\ V :e Tx) /\ x1 :e U).
	  { exact (andEL ((U :e Tx /\ V :e Tx) /\ x1 :e U) (x2 :e V) Hpre). }
	  claim Hx2V: x2 :e V.
	  { exact (andER ((U :e Tx /\ V :e Tx) /\ x1 :e U) (x2 :e V) Hpre). }
	  claim Hpair: (U :e Tx /\ V :e Tx).
	  { exact (andEL (U :e Tx /\ V :e Tx) (x1 :e U) Hpre2). }
	  claim Hx1U: x1 :e U.
	  { exact (andER (U :e Tx /\ V :e Tx) (x1 :e U) Hpre2). }
	  claim HUinTx: U :e Tx.
	  { exact (andEL (U :e Tx) (V :e Tx) Hpair). }
	  claim HVinTx: V :e Tx.
	  { exact (andER (U :e Tx) (V :e Tx) Hpair). }
  claim HUinTy: U :e Ty.
  { exact (Hsub U HUinTx). }
	  claim HVinTy: V :e Ty.
	  { exact (Hsub V HVinTx). }
	  prove U :e Ty /\ V :e Ty /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
	  apply andI.
	  - prove ((U :e Ty /\ V :e Ty) /\ x1 :e U) /\ x2 :e V.
	    apply andI.
	    + prove (U :e Ty /\ V :e Ty) /\ x1 :e U.
	      apply andI.
	      * prove U :e Ty /\ V :e Ty.
	        apply andI.
	        - exact HUinTy.
	        - exact HVinTy.
	      * exact Hx1U.
	    + exact Hx2V.
	  - exact Hempty.
Qed.

(** helper: the upper limit topology on R is Hausdorff and T1 **)
Theorem R_upper_limit_topology_Hausdorff : Hausdorff_space R R_upper_limit_topology.
claim HcontAll: finer_than R_upper_limit_topology R_standard_topology /\
                finer_than R_K_topology R_standard_topology /\
                finer_than R_standard_topology R_finite_complement_topology /\
                finer_than R_standard_topology R_ray_topology.
{ exact ex13_7_R_topology_containments. }
claim Hleft1: (finer_than R_upper_limit_topology R_standard_topology /\
               finer_than R_K_topology R_standard_topology) /\
              finer_than R_standard_topology R_finite_complement_topology.
{ exact (andEL ((finer_than R_upper_limit_topology R_standard_topology /\
                 finer_than R_K_topology R_standard_topology) /\
                finer_than R_standard_topology R_finite_complement_topology)
               (finer_than R_standard_topology R_ray_topology)
               HcontAll). }
claim Hleft2: finer_than R_upper_limit_topology R_standard_topology /\
              finer_than R_K_topology R_standard_topology.
{ exact (andEL (finer_than R_upper_limit_topology R_standard_topology /\
                finer_than R_K_topology R_standard_topology)
               (finer_than R_standard_topology R_finite_complement_topology)
               Hleft1). }
claim Hsub: R_standard_topology c= R_upper_limit_topology.
{ exact (andEL (finer_than R_upper_limit_topology R_standard_topology)
               (finer_than R_K_topology R_standard_topology)
               Hleft2). }
exact (finer_preserves_Hausdorff R R_standard_topology R_upper_limit_topology
       R_standard_topology_Hausdorff
       R_upper_limit_topology_is_topology_local
       Hsub).
Qed.

Theorem R_upper_limit_topology_T1 : T1_space R R_upper_limit_topology.
claim HtopStd: topology_on R R_standard_topology.
{ exact R_standard_topology_is_topology_local. }
claim HtopUpper: topology_on R R_upper_limit_topology.
{ exact R_upper_limit_topology_is_topology_local. }
claim HcontAll: finer_than R_upper_limit_topology R_standard_topology /\
                finer_than R_K_topology R_standard_topology /\
                finer_than R_standard_topology R_finite_complement_topology /\
                finer_than R_standard_topology R_ray_topology.
{ exact ex13_7_R_topology_containments. }
claim Hleft1: (finer_than R_upper_limit_topology R_standard_topology /\
               finer_than R_K_topology R_standard_topology) /\
              finer_than R_standard_topology R_finite_complement_topology.
{ exact (andEL ((finer_than R_upper_limit_topology R_standard_topology /\
                 finer_than R_K_topology R_standard_topology) /\
                finer_than R_standard_topology R_finite_complement_topology)
               (finer_than R_standard_topology R_ray_topology)
               HcontAll). }
claim Hleft2: finer_than R_upper_limit_topology R_standard_topology /\
              finer_than R_K_topology R_standard_topology.
{ exact (andEL (finer_than R_upper_limit_topology R_standard_topology /\
                finer_than R_K_topology R_standard_topology)
               (finer_than R_standard_topology R_finite_complement_topology)
               Hleft1). }
claim Hsub: R_standard_topology c= R_upper_limit_topology.
{ exact (andEL (finer_than R_upper_limit_topology R_standard_topology)
               (finer_than R_K_topology R_standard_topology)
               Hleft2). }
claim HpropStd:
  forall x y:set, x :e R -> y :e R -> x <> y ->
    (exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U) /\
    (exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V).
{ exact (iffEL (T1_space R R_standard_topology)
               (forall x y:set, x :e R -> y :e R -> x <> y ->
                 (exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U) /\
                 (exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V))
               (ex17_15_T1_characterization R R_standard_topology HtopStd)
               R_standard_topology_T1). }
apply (iffER (T1_space R R_upper_limit_topology)
             (forall x y:set, x :e R -> y :e R -> x <> y ->
               (exists U:set, U :e R_upper_limit_topology /\ x :e U /\ y /:e U) /\
               (exists V:set, V :e R_upper_limit_topology /\ y :e V /\ x /:e V))
             (ex17_15_T1_characterization R R_upper_limit_topology HtopUpper)).
let x y.
assume HxR: x :e R.
assume HyR: y :e R.
assume Hne: x <> y.
claim Hprop: (exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U) /\
             (exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V).
{ exact (HpropStd x y HxR HyR Hne). }
apply andI.
- claim HexU: exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U.
  { exact (andEL (exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U)
                 (exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V)
                 Hprop). }
	  apply HexU.
	  let U. assume HU.
	  witness U.
	  claim Hpre: U :e R_standard_topology /\ x :e U.
	  { exact (andEL (U :e R_standard_topology /\ x :e U) (y /:e U) HU). }
	  claim HUinStd: U :e R_standard_topology.
	  { exact (andEL (U :e R_standard_topology) (x :e U) Hpre). }
	  claim HxU: x :e U.
	  { exact (andER (U :e R_standard_topology) (x :e U) Hpre). }
	  claim Hnoty: y /:e U.
	  { exact (andER (U :e R_standard_topology /\ x :e U) (y /:e U) HU). }
	  claim HUinUpper: U :e R_upper_limit_topology.
	  { exact (Hsub U HUinStd). }
	  prove U :e R_upper_limit_topology /\ x :e U /\ y /:e U.
	  apply andI.
	  - prove U :e R_upper_limit_topology /\ x :e U.
	    apply andI.
	    + exact HUinUpper.
	    + exact HxU.
	  - exact Hnoty.
- claim HexV: exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V.
  { exact (andER (exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U)
                 (exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V)
                 Hprop). }
	  apply HexV.
	  let V. assume HV.
	  witness V.
	  claim Hpre: V :e R_standard_topology /\ y :e V.
	  { exact (andEL (V :e R_standard_topology /\ y :e V) (x /:e V) HV). }
	  claim HVinStd: V :e R_standard_topology.
	  { exact (andEL (V :e R_standard_topology) (y :e V) Hpre). }
	  claim HyV: y :e V.
	  { exact (andER (V :e R_standard_topology) (y :e V) Hpre). }
	  claim Hnotx: x /:e V.
	  { exact (andER (V :e R_standard_topology /\ y :e V) (x /:e V) HV). }
	  claim HVinUpper: V :e R_upper_limit_topology.
	  { exact (Hsub V HVinStd). }
	  prove V :e R_upper_limit_topology /\ y :e V /\ x /:e V.
	  apply andI.
	  - prove V :e R_upper_limit_topology /\ y :e V.
	    apply andI.
	    + exact HVinUpper.
	    + exact HyV.
	  - exact Hnotx.
Qed.

(** helper: the K topology on R is Hausdorff and T1 **)
Theorem R_K_topology_Hausdorff : Hausdorff_space R R_K_topology.
claim HcontAll: finer_than R_upper_limit_topology R_standard_topology /\
                finer_than R_K_topology R_standard_topology /\
                finer_than R_standard_topology R_finite_complement_topology /\
                finer_than R_standard_topology R_ray_topology.
{ exact ex13_7_R_topology_containments. }
claim Hleft1: (finer_than R_upper_limit_topology R_standard_topology /\
               finer_than R_K_topology R_standard_topology) /\
              finer_than R_standard_topology R_finite_complement_topology.
{ exact (andEL ((finer_than R_upper_limit_topology R_standard_topology /\
                 finer_than R_K_topology R_standard_topology) /\
                finer_than R_standard_topology R_finite_complement_topology)
               (finer_than R_standard_topology R_ray_topology)
               HcontAll). }
claim Hleft2: finer_than R_upper_limit_topology R_standard_topology /\
              finer_than R_K_topology R_standard_topology.
{ exact (andEL (finer_than R_upper_limit_topology R_standard_topology /\
                finer_than R_K_topology R_standard_topology)
               (finer_than R_standard_topology R_finite_complement_topology)
               Hleft1). }
claim Hsub: R_standard_topology c= R_K_topology.
{ exact (andER (finer_than R_upper_limit_topology R_standard_topology)
               (finer_than R_K_topology R_standard_topology)
               Hleft2). }
exact (finer_preserves_Hausdorff R R_standard_topology R_K_topology
       R_standard_topology_Hausdorff
       R_K_topology_is_topology_local
       Hsub).
Qed.

Theorem R_K_topology_T1 : T1_space R R_K_topology.
claim HtopStd: topology_on R R_standard_topology.
{ exact R_standard_topology_is_topology_local. }
claim HtopK: topology_on R R_K_topology.
{ exact R_K_topology_is_topology_local. }
claim HcontAll: finer_than R_upper_limit_topology R_standard_topology /\
                finer_than R_K_topology R_standard_topology /\
                finer_than R_standard_topology R_finite_complement_topology /\
                finer_than R_standard_topology R_ray_topology.
{ exact ex13_7_R_topology_containments. }
claim Hleft1: (finer_than R_upper_limit_topology R_standard_topology /\
               finer_than R_K_topology R_standard_topology) /\
              finer_than R_standard_topology R_finite_complement_topology.
{ exact (andEL ((finer_than R_upper_limit_topology R_standard_topology /\
                 finer_than R_K_topology R_standard_topology) /\
                finer_than R_standard_topology R_finite_complement_topology)
               (finer_than R_standard_topology R_ray_topology)
               HcontAll). }
claim Hleft2: finer_than R_upper_limit_topology R_standard_topology /\
              finer_than R_K_topology R_standard_topology.
{ exact (andEL (finer_than R_upper_limit_topology R_standard_topology /\
                finer_than R_K_topology R_standard_topology)
               (finer_than R_standard_topology R_finite_complement_topology)
               Hleft1). }
claim Hsub: R_standard_topology c= R_K_topology.
{ exact (andER (finer_than R_upper_limit_topology R_standard_topology)
               (finer_than R_K_topology R_standard_topology)
               Hleft2). }
claim HpropStd:
  forall x y:set, x :e R -> y :e R -> x <> y ->
    (exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U) /\
    (exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V).
{ exact (iffEL (T1_space R R_standard_topology)
               (forall x y:set, x :e R -> y :e R -> x <> y ->
                 (exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U) /\
                 (exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V))
               (ex17_15_T1_characterization R R_standard_topology HtopStd)
               R_standard_topology_T1). }
apply (iffER (T1_space R R_K_topology)
             (forall x y:set, x :e R -> y :e R -> x <> y ->
               (exists U:set, U :e R_K_topology /\ x :e U /\ y /:e U) /\
               (exists V:set, V :e R_K_topology /\ y :e V /\ x /:e V))
             (ex17_15_T1_characterization R R_K_topology HtopK)).
let x y.
assume HxR: x :e R.
assume HyR: y :e R.
assume Hne: x <> y.
claim Hprop: (exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U) /\
             (exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V).
{ exact (HpropStd x y HxR HyR Hne). }
apply andI.
- claim HexU: exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U.
  { exact (andEL (exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U)
                 (exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V)
                 Hprop). }
  apply HexU.
  let U. assume HU.
  witness U.
  claim Hpre: U :e R_standard_topology /\ x :e U.
  { exact (andEL (U :e R_standard_topology /\ x :e U) (y /:e U) HU). }
  claim HUinStd: U :e R_standard_topology.
  { exact (andEL (U :e R_standard_topology) (x :e U) Hpre). }
  claim HxU: x :e U.
  { exact (andER (U :e R_standard_topology) (x :e U) Hpre). }
  claim Hnoty: y /:e U.
  { exact (andER (U :e R_standard_topology /\ x :e U) (y /:e U) HU). }
  claim HUinK: U :e R_K_topology.
  { exact (Hsub U HUinStd). }
  prove U :e R_K_topology /\ x :e U /\ y /:e U.
  apply andI.
  - prove U :e R_K_topology /\ x :e U.
    apply andI.
    + exact HUinK.
    + exact HxU.
  - exact Hnoty.
- claim HexV: exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V.
  { exact (andER (exists U:set, U :e R_standard_topology /\ x :e U /\ y /:e U)
                 (exists V:set, V :e R_standard_topology /\ y :e V /\ x /:e V)
                 Hprop). }
  apply HexV.
  let V. assume HV.
  witness V.
  claim Hpre: V :e R_standard_topology /\ y :e V.
  { exact (andEL (V :e R_standard_topology /\ y :e V) (x /:e V) HV). }
  claim HVinStd: V :e R_standard_topology.
  { exact (andEL (V :e R_standard_topology) (y :e V) Hpre). }
  claim HyV: y :e V.
  { exact (andER (V :e R_standard_topology) (y :e V) Hpre). }
  claim Hnotx: x /:e V.
  { exact (andER (V :e R_standard_topology /\ y :e V) (x /:e V) HV). }
  claim HVinK: V :e R_K_topology.
  { exact (Hsub V HVinStd). }
  prove V :e R_K_topology /\ y :e V /\ x /:e V.
  apply andI.
  - prove V :e R_K_topology /\ y :e V.
    apply andI.
    + exact HVinK.
    + exact HyV.
  - exact Hnotx.
Qed.

(** LATEX VERSION: Exercise 16(b): For the same five R topologies, determine which satisfy the Hausdorff and the T1 axioms. **)
Theorem ex17_16b_Hausdorff_and_T1_for_five_topologies :
  (Hausdorff_space R R_standard_topology /\ T1_space R R_standard_topology) /\
  (Hausdorff_space R R_upper_limit_topology /\ T1_space R R_upper_limit_topology) /\
  (Hausdorff_space R R_K_topology /\ T1_space R R_K_topology) /\
  (~Hausdorff_space R R_finite_complement_topology /\ T1_space R R_finite_complement_topology) /\
  (~Hausdorff_space R R_ray_topology /\ ~T1_space R R_ray_topology).
prove (Hausdorff_space R R_standard_topology /\ T1_space R R_standard_topology) /\
  (Hausdorff_space R R_upper_limit_topology /\ T1_space R R_upper_limit_topology) /\
  (Hausdorff_space R R_K_topology /\ T1_space R R_K_topology) /\
  (~Hausdorff_space R R_finite_complement_topology /\ T1_space R R_finite_complement_topology) /\
  (~Hausdorff_space R R_ray_topology /\ ~T1_space R R_ray_topology).
apply andI.
- apply andI.
  * prove (Hausdorff_space R R_standard_topology /\ T1_space R R_standard_topology) /\
          (Hausdorff_space R R_upper_limit_topology /\ T1_space R R_upper_limit_topology) /\
          (Hausdorff_space R R_K_topology /\ T1_space R R_K_topology).
	    apply andI.
		    { apply andI.
		      - prove Hausdorff_space R R_standard_topology /\ T1_space R R_standard_topology.
		        apply andI.
		        + exact R_standard_topology_Hausdorff.
		        + exact R_standard_topology_T1.
		      - prove Hausdorff_space R R_upper_limit_topology /\ T1_space R R_upper_limit_topology.
		        apply andI.
		        + exact R_upper_limit_topology_Hausdorff.
		        + exact R_upper_limit_topology_T1.
		    }
		    { prove Hausdorff_space R R_K_topology /\ T1_space R R_K_topology.
		      apply andI.
		      - exact R_K_topology_Hausdorff.
		      - exact R_K_topology_T1.
		    }
	  * prove ~Hausdorff_space R R_finite_complement_topology /\ T1_space R R_finite_complement_topology.
	    apply andI.
	    { exact R_finite_complement_not_Hausdorff. }
	    { exact (finite_complement_topology_T1 R). }
- prove ~Hausdorff_space R R_ray_topology /\ ~T1_space R R_ray_topology.
  apply andI.
  + exact ray_topology_not_Hausdorff.
  + exact ray_topology_not_T1.
Qed.

(** LATEX VERSION: Exercise 17: Compare closures of A=(0,sqrt 2) and B=(sqrt 2,3) in the lower limit topology and the topology generated by the rational half open basis C. **)
(** Helper: basic real membership facts used in Exercise 17 definitions **)
Theorem real_2 : 2 :e R.
prove 2 :e R.
rewrite <- add_SNo_1_1_2.
exact (real_add_SNo 1 real_1 1 real_1).
Qed.

Theorem ordsucc_2_eq_3 : ordsucc 2 = 3.
reflexivity.
Qed.

Theorem add_SNo_2_1_eq_3 : add_SNo 2 1 = 3.
claim H2omega : 2 :e omega.
{ exact (nat_p_omega 2 nat_2). }
rewrite (add_SNo_1_ordsucc 2 H2omega).
rewrite ordsucc_2_eq_3.
reflexivity.
Qed.

Theorem real_3 : 3 :e R.
prove 3 :e R.
rewrite <- add_SNo_2_1_eq_3.
exact (real_add_SNo 2 real_2 1 real_1).
Qed.

Definition sqrt2 : set := sqrt_SNo_nonneg 2.

(** Helper: sqrt2 is real **)
Theorem sqrt2_in_R : sqrt2 :e R.
prove sqrt2 :e R.
exact (sqrt_SNo_nonneg_real 2 real_2 (SNoLtLe 0 2 SNoLt_0_2)).
Qed.

Definition R_C_topology : set := generated_topology R rational_halfopen_intervals_basis.
Definition ex17_17_interval_A : set := open_interval 0 sqrt2.
Definition ex17_17_interval_B : set := open_interval sqrt2 3.
Definition ex17_17_interval_A_closure_lower : set := {x :e R|0 <= x /\ x < sqrt2}.
Definition ex17_17_interval_A_closure_C : set := {x :e R|0 <= x /\ x <= sqrt2}.
Definition ex17_17_interval_B_closure_lower : set := {x :e R|sqrt2 <= x /\ x < 3}.

Axiom ex17_17_closures_of_A_B_in_two_topologies_axiom :
  closure_of R R_lower_limit_topology ex17_17_interval_A = ex17_17_interval_A_closure_lower /\
  closure_of R R_C_topology ex17_17_interval_A = ex17_17_interval_A_closure_C /\
  closure_of R R_lower_limit_topology ex17_17_interval_B = ex17_17_interval_B_closure_lower /\
  closure_of R R_C_topology ex17_17_interval_B = ex17_17_interval_B_closure_lower.

Theorem ex17_17_closures_of_A_B_in_two_topologies :
  closure_of R R_lower_limit_topology ex17_17_interval_A = ex17_17_interval_A_closure_lower /\
  closure_of R R_C_topology ex17_17_interval_A = ex17_17_interval_A_closure_C /\
  closure_of R R_lower_limit_topology ex17_17_interval_B = ex17_17_interval_B_closure_lower /\
  closure_of R R_C_topology ex17_17_interval_B = ex17_17_interval_B_closure_lower.
prove closure_of R R_lower_limit_topology ex17_17_interval_A = ex17_17_interval_A_closure_lower /\
  closure_of R R_C_topology ex17_17_interval_A = ex17_17_interval_A_closure_C /\
  closure_of R R_lower_limit_topology ex17_17_interval_B = ex17_17_interval_B_closure_lower /\
  closure_of R R_C_topology ex17_17_interval_B = ex17_17_interval_B_closure_lower.
exact ex17_17_closures_of_A_B_in_two_topologies_axiom.
Qed.

(** LATEX VERSION: Exercise 18: Determine the closures of the subsets A,B,C,D,E of the ordered square listed in the text. **)
Definition ordsq_A : set := {(inv_nat n,0)|n :e omega :\: {0}}.
Definition ordsq_B : set := {(add_SNo 1 (minus_SNo (inv_nat n)),eps_ 1)|n :e omega :\: {0}}.
Definition ordsq_C : set := {p :e ordered_square|exists x:set, p = (x,0) /\ Rlt 0 x /\ Rlt x 1}.
Definition ordsq_D : set := {p :e ordered_square|exists x:set, p = (x,eps_ 1) /\ Rlt 0 x /\ Rlt x 1}.
Definition ordsq_E : set := {p :e ordered_square|exists y:set, p = (eps_ 1,y) /\ Rlt 0 y /\ Rlt y 1}.

Definition ordsq_p01 : set := (0,1).
Definition ordsq_p10 : set := (1,0).
Definition ordsq_E_closure : set := ordsq_E :\/: {(eps_ 1,0)} :\/: {(eps_ 1,1)}.

Axiom ex17_18_closures_in_ordered_square_axiom :
  closure_of ordered_square ordered_square_topology ordsq_A = ordsq_A :\/: {ordsq_p01} /\
  closure_of ordered_square ordered_square_topology ordsq_B = ordsq_B :\/: {ordsq_p10} /\
  closure_of ordered_square ordered_square_topology ordsq_C = ordsq_C :\/: {ordsq_p01} :\/: {ordsq_p10} /\
  closure_of ordered_square ordered_square_topology ordsq_D = ordsq_D :\/: ordsq_C :\/: {ordsq_p01} :\/: {ordsq_p10} /\
  closure_of ordered_square ordered_square_topology ordsq_E = ordsq_E_closure.

Theorem ex17_18_closures_in_ordered_square :
  closure_of ordered_square ordered_square_topology ordsq_A = ordsq_A :\/: {ordsq_p01} /\
  closure_of ordered_square ordered_square_topology ordsq_B = ordsq_B :\/: {ordsq_p10} /\
  closure_of ordered_square ordered_square_topology ordsq_C = ordsq_C :\/: {ordsq_p01} :\/: {ordsq_p10} /\
  closure_of ordered_square ordered_square_topology ordsq_D = ordsq_D :\/: ordsq_C :\/: {ordsq_p01} :\/: {ordsq_p10} /\
  closure_of ordered_square ordered_square_topology ordsq_E = ordsq_E_closure.
prove closure_of ordered_square ordered_square_topology ordsq_A = ordsq_A :\/: {ordsq_p01} /\
  closure_of ordered_square ordered_square_topology ordsq_B = ordsq_B :\/: {ordsq_p10} /\
  closure_of ordered_square ordered_square_topology ordsq_C = ordsq_C :\/: {ordsq_p01} :\/: {ordsq_p10} /\
  closure_of ordered_square ordered_square_topology ordsq_D = ordsq_D :\/: ordsq_C :\/: {ordsq_p01} :\/: {ordsq_p10} /\
  closure_of ordered_square ordered_square_topology ordsq_E = ordsq_E_closure.
exact ex17_18_closures_in_ordered_square_axiom.
Qed.

Definition boundary_of : set -> set -> set -> set := fun X Tx A =>
  closure_of X Tx A :/\: closure_of X Tx (X :\: A).

(** LATEX VERSION: Exercise 19: The boundary of A lies in closure(A) and in closure(X\\A). **)
Theorem ex17_19_boundary_properties : forall X Tx A:set,
  topology_on X Tx ->
  boundary_of X Tx A c= closure_of X Tx A /\
  boundary_of X Tx A c= closure_of X Tx (X :\: A).
let X Tx A.
assume Htop: topology_on X Tx.
prove boundary_of X Tx A c= closure_of X Tx A /\ boundary_of X Tx A c= closure_of X Tx (X :\: A).
(** boundary_of is defined as closure(A)  closure(X\A), so both inclusions follow from binintersect_Subq **)
apply andI.
- prove boundary_of X Tx A c= closure_of X Tx A.
  exact (binintersect_Subq_1 (closure_of X Tx A) (closure_of X Tx (X :\: A))).
- prove boundary_of X Tx A c= closure_of X Tx (X :\: A).
  exact (binintersect_Subq_2 (closure_of X Tx A) (closure_of X Tx (X :\: A))).
Qed.

(** LATEX VERSION: Exercise 20: Boundary of a strip differs between standard and dictionary topologies on . **)
Axiom ex17_20_boundaries_and_interiors_in_R2_axiom :
  boundary_of (setprod R R) R2_standard_topology ordered_square_open_strip <>
  boundary_of (setprod R R) R2_dictionary_order_topology ordered_square_open_strip.
Theorem ex17_20_boundaries_and_interiors_in_R2 :
  boundary_of (setprod R R) R2_standard_topology ordered_square_open_strip <>
  boundary_of (setprod R R) R2_dictionary_order_topology ordered_square_open_strip.
prove boundary_of (setprod R R) R2_standard_topology ordered_square_open_strip <> boundary_of (setprod R R) R2_dictionary_order_topology ordered_square_open_strip.
exact ex17_20_boundaries_and_interiors_in_R2_axiom.
Qed.

(** LATEX VERSION: Exercise 21: Kuratowski example in discrete topology gives maximal closure after complement. **)
Theorem ex17_21_Kuratowski_closure_complement_maximal : forall X:set,
  closure_of X (discrete_topology X) (X :\: Empty) = X.
let X.
prove closure_of X (discrete_topology X) (X :\: Empty) = X.
claim Htop: topology_on X (discrete_topology X).
{ exact (discrete_topology_on X). }
claim HXE: X :\: Empty = X.
{ apply set_ext.
  - let x. assume Hx: x :e X :\: Empty.
    exact (setminusE1 X Empty x Hx).
  - let x. assume Hx: x :e X.
    apply setminusI.
    + exact Hx.
    + assume Hfalse: x :e Empty.
      exact (EmptyE x Hfalse). }
(** Rewrite the LHS using HXE **)
rewrite HXE.
(** Now we need to prove closure_of X (discrete_topology X) X = X **)
apply set_ext.
- exact (closure_in_space X (discrete_topology X) X Htop).
- exact (subset_of_closure X (discrete_topology X) X Htop (Subq_ref X)).
Qed.

(** from 18 Definition: continuous map between topological spaces **) 
(** LATEX VERSION: Continuity defined via preimages of open sets being open. **)
Definition preimage_of : set -> set -> set -> set := fun X f V =>
  {x :e X | apply_fun f x :e V}.

(** Helper: preimage of union of a family **)
(** LATEX VERSION: f^{-1}(Union Fam) equals Union of the preimages f^{-1}(V) for V in Fam. **)
Theorem preimage_of_Union : forall X f Fam:set,
  preimage_of X f (Union Fam) = Union {preimage_of X f V|V :e Fam}.
let X f Fam.
apply set_ext.
- let x. assume Hx: x :e preimage_of X f (Union Fam).
  prove x :e Union {preimage_of X f V|V :e Fam}.
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0:set => apply_fun f x0 :e Union Fam) x Hx). }
  claim HfxU: apply_fun f x :e Union Fam.
  { exact (SepE2 X (fun x0:set => apply_fun f x0 :e Union Fam) x Hx). }
  apply (UnionE_impred Fam (apply_fun f x) HfxU).
  let V. assume HfxV: apply_fun f x :e V.
  assume HVFam: V :e Fam.
  claim HxPre: x :e preimage_of X f V.
  { exact (SepI X (fun x0:set => apply_fun f x0 :e V) x HxX HfxV). }
  exact (UnionI {preimage_of X f V0|V0 :e Fam} x (preimage_of X f V) HxPre
               (ReplI Fam (fun V0:set => preimage_of X f V0) V HVFam)).
- let x. assume Hx: x :e Union {preimage_of X f V|V :e Fam}.
  prove x :e preimage_of X f (Union Fam).
  apply (UnionE_impred {preimage_of X f V|V :e Fam} x Hx).
  let W. assume HxW: x :e W.
  assume HW: W :e {preimage_of X f V|V :e Fam}.
  apply (ReplE_impred Fam (fun V0:set => preimage_of X f V0) W HW).
  let V. assume HVFam: V :e Fam.
  assume HWV: W = preimage_of X f V.
  claim HxPre: x :e preimage_of X f V.
  { rewrite <- HWV.
    exact HxW. }
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0:set => apply_fun f x0 :e V) x HxPre). }
  claim HfxV: apply_fun f x :e V.
  { exact (SepE2 X (fun x0:set => apply_fun f x0 :e V) x HxPre). }
  claim HfxU: apply_fun f x :e Union Fam.
  { exact (UnionI Fam (apply_fun f x) V HfxV HVFam). }
  exact (SepI X (fun x0:set => apply_fun f x0 :e Union Fam) x HxX HfxU).
Qed.

(** Helper: preimage of binary intersection **)
(** LATEX VERSION: f^{-1}(UV) = f^{-1}(U)  f^{-1}(V). **)
Theorem preimage_of_binintersect : forall X f U V:set,
  preimage_of X f (U :/\: V) = (preimage_of X f U) :/\: (preimage_of X f V).
let X f U V.
apply set_ext.
- let x. assume Hx: x :e preimage_of X f (U :/\: V).
  prove x :e (preimage_of X f U) :/\: (preimage_of X f V).
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0:set => apply_fun f x0 :e U :/\: V) x Hx). }
  claim HfxUV: apply_fun f x :e U :/\: V.
  { exact (SepE2 X (fun x0:set => apply_fun f x0 :e U :/\: V) x Hx). }
  claim HfxU: apply_fun f x :e U.
  { exact (binintersectE1 U V (apply_fun f x) HfxUV). }
  claim HfxV: apply_fun f x :e V.
  { exact (binintersectE2 U V (apply_fun f x) HfxUV). }
  claim HxPreU: x :e preimage_of X f U.
  { exact (SepI X (fun x0:set => apply_fun f x0 :e U) x HxX HfxU). }
  claim HxPreV: x :e preimage_of X f V.
  { exact (SepI X (fun x0:set => apply_fun f x0 :e V) x HxX HfxV). }
  exact (binintersectI (preimage_of X f U) (preimage_of X f V) x HxPreU HxPreV).
- let x. assume Hx: x :e (preimage_of X f U) :/\: (preimage_of X f V).
  prove x :e preimage_of X f (U :/\: V).
  claim HxPreU: x :e preimage_of X f U.
  { exact (binintersectE1 (preimage_of X f U) (preimage_of X f V) x Hx). }
  claim HxPreV: x :e preimage_of X f V.
  { exact (binintersectE2 (preimage_of X f U) (preimage_of X f V) x Hx). }
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0:set => apply_fun f x0 :e U) x HxPreU). }
  claim HfxU: apply_fun f x :e U.
  { exact (SepE2 X (fun x0:set => apply_fun f x0 :e U) x HxPreU). }
  claim HfxV: apply_fun f x :e V.
  { exact (SepE2 X (fun x0:set => apply_fun f x0 :e V) x HxPreV). }
  claim HfxUV: apply_fun f x :e U :/\: V.
  { exact (binintersectI U V (apply_fun f x) HfxU HfxV). }
  exact (SepI X (fun x0:set => apply_fun f x0 :e U :/\: V) x HxX HfxUV).
Qed.

(** Helper: preimage of Empty **)
(** LATEX VERSION: f^{-1}() = . **)
Theorem preimage_of_Empty : forall X f:set,
  preimage_of X f Empty = Empty.
let X f.
apply set_ext.
- let x. assume Hx: x :e preimage_of X f Empty.
  prove x :e Empty.
  claim HfxE: apply_fun f x :e Empty.
  { exact (SepE2 X (fun x0:set => apply_fun f x0 :e Empty) x Hx). }
  exact (FalseE ((EmptyE (apply_fun f x)) HfxE) (x :e Empty)).
- let x. assume Hx: x :e Empty.
  prove x :e preimage_of X f Empty.
  apply FalseE.
  exact ((EmptyE x) Hx).
Qed.

(** Helper: preimage of whole codomain under a function_on map **)
(** LATEX VERSION: If f maps X into Y then f^{-1}(Y)=X. **)
Theorem preimage_of_whole : forall X Y f:set,
  function_on f X Y ->
  preimage_of X f Y = X.
let X Y f.
assume Hfun: function_on f X Y.
apply set_ext.
- let x. assume Hx: x :e preimage_of X f Y.
  exact (SepE1 X (fun x0:set => apply_fun f x0 :e Y) x Hx).
- let x. assume HxX: x :e X.
  prove x :e preimage_of X f Y.
  exact (SepI X (fun x0:set => apply_fun f x0 :e Y) x HxX (Hfun x HxX)).
Qed.

(** Helper: apply_fun for projections **)
(** LATEX VERSION: For p in XY, proj1(p)=p0 and proj2(p)=p1. **)
Theorem projection1_apply : forall X Y p:set,
  p :e setprod X Y -> apply_fun (projection1 X Y) p = p 0.
let X Y p.
assume Hp: p :e setprod X Y.
prove apply_fun (projection1 X Y) p = p 0.
prove Eps_i (fun z => (p,z) :e projection1 X Y) = p 0.
claim H1: (p, p 0) :e projection1 X Y.
{ exact (ReplI (setprod X Y) (fun q:set => (q, q 0)) p Hp). }
claim H2: (p, Eps_i (fun z => (p,z) :e projection1 X Y)) :e projection1 X Y.
{ exact (Eps_i_ax (fun z => (p,z) :e projection1 X Y) (p 0) H1). }
apply (ReplE_impred (setprod X Y) (fun q:set => (q, q 0))
                     (p, Eps_i (fun z => (p,z) :e projection1 X Y)) H2).
let q.
assume Hq: q :e setprod X Y.
assume Heq: (p, Eps_i (fun z => (p,z) :e projection1 X Y)) = (q, q 0).
claim Hpq: p = q.
{ rewrite <- (tuple_2_0_eq p (Eps_i (fun z => (p,z) :e projection1 X Y))).
  rewrite <- (tuple_2_0_eq q (q 0)).
  rewrite Heq.
  reflexivity. }
claim Hzq0: Eps_i (fun z => (p,z) :e projection1 X Y) = q 0.
{ rewrite <- (tuple_2_1_eq p (Eps_i (fun z => (p,z) :e projection1 X Y))).
  rewrite <- (tuple_2_1_eq q (q 0)).
  rewrite Heq.
  reflexivity. }
claim Hq0p0: q 0 = p 0.
{ rewrite <- Hpq.
  reflexivity. }
rewrite Hzq0.
exact Hq0p0.
Qed.

Theorem projection2_apply : forall X Y p:set,
  p :e setprod X Y -> apply_fun (projection2 X Y) p = p 1.
let X Y p.
assume Hp: p :e setprod X Y.
prove apply_fun (projection2 X Y) p = p 1.
prove Eps_i (fun z => (p,z) :e projection2 X Y) = p 1.
claim H1: (p, p 1) :e projection2 X Y.
{ exact (ReplI (setprod X Y) (fun q:set => (q, q 1)) p Hp). }
claim H2: (p, Eps_i (fun z => (p,z) :e projection2 X Y)) :e projection2 X Y.
{ exact (Eps_i_ax (fun z => (p,z) :e projection2 X Y) (p 1) H1). }
apply (ReplE_impred (setprod X Y) (fun q:set => (q, q 1))
                     (p, Eps_i (fun z => (p,z) :e projection2 X Y)) H2).
let q.
assume Hq: q :e setprod X Y.
assume Heq: (p, Eps_i (fun z => (p,z) :e projection2 X Y)) = (q, q 1).
claim Hpq: p = q.
{ rewrite <- (tuple_2_0_eq p (Eps_i (fun z => (p,z) :e projection2 X Y))).
  rewrite <- (tuple_2_0_eq q (q 1)).
  rewrite Heq.
  reflexivity. }
claim Hzq1: Eps_i (fun z => (p,z) :e projection2 X Y) = q 1.
{ rewrite <- (tuple_2_1_eq p (Eps_i (fun z => (p,z) :e projection2 X Y))).
  rewrite <- (tuple_2_1_eq q (q 1)).
  rewrite Heq.
  reflexivity. }
claim Hq1p1: q 1 = p 1.
{ rewrite <- Hpq.
  reflexivity. }
rewrite Hzq1.
exact Hq1p1.
Qed.

(** Helper: preimages of opens under projections are rectangles **)
(** LATEX VERSION: proj1^{-1}(U)=UY and proj2^{-1}(V)=XV. **)
Theorem preimage_projection1_rectangle : forall X Y U:set,
  U c= X ->
  preimage_of (setprod X Y) (projection1 X Y) U = rectangle_set U Y.
let X Y U.
assume HUsub: U c= X.
apply set_ext.
- let p. assume Hp: p :e preimage_of (setprod X Y) (projection1 X Y) U.
  prove p :e rectangle_set U Y.
  claim HpXY: p :e setprod X Y.
  { exact (SepE1 (setprod X Y) (fun q => apply_fun (projection1 X Y) q :e U) p Hp). }
  claim HprojU: apply_fun (projection1 X Y) p :e U.
  { exact (SepE2 (setprod X Y) (fun q => apply_fun (projection1 X Y) q :e U) p Hp). }
  claim Happ: apply_fun (projection1 X Y) p = p 0.
  { exact (projection1_apply X Y p HpXY). }
  claim Hp0U: p 0 :e U.
  { rewrite <- Happ.
    exact HprojU. }
  claim Hp1Y: p 1 :e Y.
  { exact (ap1_Sigma X (fun _ : set => Y) p HpXY). }
  claim Heta: p = (p 0, p 1).
  { exact (setprod_eta X Y p HpXY). }
  rewrite Heta.
  exact (tuple_2_setprod U Y (p 0) Hp0U (p 1) Hp1Y).
- let p. assume Hp: p :e rectangle_set U Y.
  prove p :e preimage_of (setprod X Y) (projection1 X Y) U.
  claim HpUY: p :e setprod U Y.
  { exact Hp. }
  claim Hp0U: p 0 :e U.
  { exact (ap0_Sigma U (fun _ : set => Y) p HpUY). }
  claim Hp1Y: p 1 :e Y.
  { exact (ap1_Sigma U (fun _ : set => Y) p HpUY). }
  claim Hp0X: p 0 :e X.
  { exact (HUsub (p 0) Hp0U). }
  claim HpXY: p :e setprod X Y.
  { claim Heta: p = (p 0, p 1).
    { exact (setprod_eta U Y p HpUY). }
    rewrite Heta.
    exact (tuple_2_setprod X Y (p 0) Hp0X (p 1) Hp1Y). }
  claim Hprop: apply_fun (projection1 X Y) p :e U.
  { claim Happ: apply_fun (projection1 X Y) p = p 0.
    { exact (projection1_apply X Y p HpXY). }
    rewrite Happ.
    exact Hp0U. }
  exact (SepI (setprod X Y) (fun q => apply_fun (projection1 X Y) q :e U) p HpXY Hprop).
Qed.

Theorem preimage_projection2_rectangle : forall X Y V:set,
  V c= Y ->
  preimage_of (setprod X Y) (projection2 X Y) V = rectangle_set X V.
let X Y V.
assume HVsub: V c= Y.
apply set_ext.
- let p. assume Hp: p :e preimage_of (setprod X Y) (projection2 X Y) V.
  prove p :e rectangle_set X V.
  claim HpXY: p :e setprod X Y.
  { exact (SepE1 (setprod X Y) (fun q => apply_fun (projection2 X Y) q :e V) p Hp). }
  claim HprojV: apply_fun (projection2 X Y) p :e V.
  { exact (SepE2 (setprod X Y) (fun q => apply_fun (projection2 X Y) q :e V) p Hp). }
  claim Happ: apply_fun (projection2 X Y) p = p 1.
  { exact (projection2_apply X Y p HpXY). }
  claim Hp1V: p 1 :e V.
  { rewrite <- Happ.
    exact HprojV. }
  claim Hp0X: p 0 :e X.
  { exact (ap0_Sigma X (fun _ : set => Y) p HpXY). }
  claim Heta: p = (p 0, p 1).
  { exact (setprod_eta X Y p HpXY). }
  rewrite Heta.
  exact (tuple_2_setprod X V (p 0) Hp0X (p 1) Hp1V).
- let p. assume Hp: p :e rectangle_set X V.
  prove p :e preimage_of (setprod X Y) (projection2 X Y) V.
  claim HpXV: p :e setprod X V.
  { exact Hp. }
  claim Hp0X: p 0 :e X.
  { exact (ap0_Sigma X (fun _ : set => V) p HpXV). }
  claim Hp1V: p 1 :e V.
  { exact (ap1_Sigma X (fun _ : set => V) p HpXV). }
  claim Hp1Y: p 1 :e Y.
  { exact (HVsub (p 1) Hp1V). }
  claim HpXY: p :e setprod X Y.
  { claim Heta: p = (p 0, p 1).
    { exact (setprod_eta X V p HpXV). }
    rewrite Heta.
    exact (tuple_2_setprod X Y (p 0) Hp0X (p 1) Hp1Y). }
  claim Hprop: apply_fun (projection2 X Y) p :e V.
  { claim Happ: apply_fun (projection2 X Y) p = p 1.
    { exact (projection2_apply X Y p HpXY). }
    rewrite Happ.
    exact Hp1V. }
  exact (SepI (setprod X Y) (fun q => apply_fun (projection2 X Y) q :e V) p HpXY Hprop).
Qed.

(** SUSPICIOUS DEFINITION: `continuous_map` relies on `function_on` (which is defined via `apply_fun`/`Eps_i`);
    thus continuity is formulated purely via preimages of opens, and totality of the graph (existence of some y with (x,y) :e f)
    is not available unless it is assumed separately. Use `total_function_on` when totality is needed. **)
Definition continuous_map : set -> set -> set -> set -> set -> prop :=
  fun X Tx Y Ty f =>
    topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y /\
    forall V:set, V :e Ty -> preimage_of X f V :e Tx.

(** Helper: subbasis criterion for continuity into generated_topology_from_subbasis **)
(** LATEX VERSION: If preimages of all subbasis elements are open, then f is continuous for the topology generated by the subbasis. **)
Theorem continuous_map_from_subbasis : forall X Tx Y S f:set,
  topology_on X Tx ->
  function_on f X Y ->
  subbasis_on Y S ->
  (forall s:set, s :e S -> preimage_of X f s :e Tx) ->
  continuous_map X Tx Y (generated_topology_from_subbasis Y S) f.
let X Tx Y S f.
assume HTx: topology_on X Tx.
assume Hfun: function_on f X Y.
assume HS: subbasis_on Y S.
assume HpreS: forall s:set, s :e S -> preimage_of X f s :e Tx.
set Ty := generated_topology_from_subbasis Y S.
claim HTy: topology_on Y Ty.
{ exact (topology_from_subbasis_is_topology Y S HS). }
(** Define Tpre as sets whose preimages are open. **)
set TpreFam : set := {U0 :e Power Y| preimage_of X f U0 :e Tx}.
claim HTpre: topology_on Y TpreFam.
{ claim HsubPow: TpreFam c= Power Y.
  { let U. assume HU: U :e TpreFam.
    exact (SepE1 (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) U HU). }
  claim Hempty: Empty :e TpreFam.
  { apply (SepI (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) Empty (Empty_In_Power Y)).
    rewrite (preimage_of_Empty X f).
    exact (topology_has_empty X Tx HTx). }
  claim HYin: Y :e TpreFam.
  { apply (SepI (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) Y (Self_In_Power Y)).
    rewrite (preimage_of_whole X Y f Hfun).
    exact (topology_has_X X Tx HTx). }
  claim Hunion: forall UFam :e Power TpreFam, Union UFam :e TpreFam.
  { let UFam. assume HUFamPow: UFam :e Power TpreFam.
    claim HUFsub: UFam c= TpreFam.
    { exact (PowerE TpreFam UFam HUFamPow). }
    claim HUnionPowY: Union UFam :e Power Y.
    { apply PowerI.
      let y. assume Hy: y :e Union UFam.
      apply (UnionE_impred UFam y Hy).
      let U. assume HyU: y :e U. assume HUUF: U :e UFam.
      claim HUTpre: U :e TpreFam.
      { exact (HUFsub U HUUF). }
      claim HUPowY: U :e Power Y.
      { exact (SepE1 (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) U HUTpre). }
      exact (PowerE Y U HUPowY y HyU). }
    apply (SepI (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) (Union UFam) HUnionPowY).
    rewrite (preimage_of_Union X f UFam).
    set PreFam : set := {preimage_of X f U|U :e UFam}.
    claim HPreFamSub: PreFam c= Tx.
    { let W. assume HW: W :e PreFam.
      apply (ReplE_impred UFam (fun U0:set => preimage_of X f U0) W HW (W :e Tx)).
      let U. assume HUUF: U :e UFam. assume HWU: W = preimage_of X f U.
      claim HUTpre: U :e TpreFam.
      { exact (HUFsub U HUUF). }
      claim HpreU: preimage_of X f U :e Tx.
      { exact (SepE2 (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) U HUTpre). }
      rewrite HWU.
      exact HpreU. }
    exact (topology_union_closed X Tx PreFam HTx HPreFamSub). }
  claim Hinter: forall U :e TpreFam, forall V :e TpreFam, U :/\: V :e TpreFam.
  { let U. assume HU: U :e TpreFam.
    let V. assume HV: V :e TpreFam.
    claim HUPow: U :e Power Y.
    { exact (SepE1 (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) U HU). }
    claim HVPow: V :e Power Y.
    { exact (SepE1 (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) V HV). }
    claim HUVPow: U :/\: V :e Power Y.
    { exact (binintersect_Power Y U V HUPow HVPow). }
    apply (SepI (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) (U :/\: V) HUVPow).
    rewrite (preimage_of_binintersect X f U V).
    claim HpreU: preimage_of X f U :e Tx.
    { exact (SepE2 (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) U HU). }
    claim HpreV: preimage_of X f V :e Tx.
    { exact (SepE2 (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) V HV). }
    exact (topology_binintersect_closed X Tx (preimage_of X f U) (preimage_of X f V) HTx HpreU HpreV). }
  claim HTpre_def: topology_on Y TpreFam =
    (TpreFam c= Power Y
     /\ Empty :e TpreFam
     /\ Y :e TpreFam
     /\ (forall UFam :e Power TpreFam, Union UFam :e TpreFam)
     /\ (forall U :e TpreFam, forall V :e TpreFam, U :/\: V :e TpreFam)).
  { reflexivity. }
  rewrite HTpre_def.
  apply andI.
  - apply andI.
    + apply andI.
      * apply andI.
        - exact HsubPow.
        - exact Hempty.
      * exact HYin.
    + exact Hunion.
  - exact Hinter. }
(** S is contained in Tpre, so generated topology is contained in Tpre by minimality. **)
claim HSsub: S c= TpreFam.
{ let s. assume Hs: s :e S.
  prove s :e TpreFam.
  claim HSsubPow: S c= Power Y.
  { exact (andEL (S c= Power Y) (Union S = Y) HS). }
  claim HsPowY: s :e Power Y.
  { exact (HSsubPow s Hs). }
  exact (SepI (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) s HsPowY (HpreS s Hs)). }
claim Hmin: Ty c= TpreFam.
{ exact (topology_generated_by_basis_is_minimal Y S TpreFam HS HTpre HSsub). }
prove continuous_map X Tx Y Ty f.
prove topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y /\ forall V:set, V :e Ty -> preimage_of X f V :e Tx.
apply andI.
- prove (topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y).
  apply andI.
  + prove topology_on X Tx /\ topology_on Y Ty.
    apply andI.
    * exact HTx.
    * exact HTy.
  + exact Hfun.
- let V. assume HV: V :e Ty.
  prove preimage_of X f V :e Tx.
  claim HVTpre: V :e TpreFam.
  { exact (Hmin V HV). }
  exact (SepE2 (Power Y) (fun U0:set => preimage_of X f U0 :e Tx) V HVTpre).
Qed.

(** Helper: continuous_map variant with totality of the graph **)
Definition continuous_map_total : set -> set -> set -> set -> set -> prop :=
  fun X Tx Y Ty f =>
    topology_on X Tx /\ topology_on Y Ty /\ total_function_on f X Y /\
    forall V:set, V :e Ty -> preimage_of X f V :e Tx.

(** Helper: continuous_map_total implies continuous_map **)
Theorem continuous_map_total_imp : forall X Tx Y Ty f:set,
  continuous_map_total X Tx Y Ty f -> continuous_map X Tx Y Ty f.
let X Tx Y Ty f.
assume H: continuous_map_total X Tx Y Ty f.
prove continuous_map X Tx Y Ty f.
prove ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y) /\
  (forall V:set, V :e Ty -> preimage_of X f V :e Tx).
claim Hcore: ((topology_on X Tx /\ topology_on Y Ty) /\ total_function_on f X Y) /\
  (forall V:set, V :e Ty -> preimage_of X f V :e Tx).
{ exact H. }
claim Hleft: (topology_on X Tx /\ topology_on Y Ty) /\ total_function_on f X Y.
{ exact (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ total_function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx) Hcore). }
claim Hright: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
{ exact (andER ((topology_on X Tx /\ topology_on Y Ty) /\ total_function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx) Hcore). }
claim Htops: topology_on X Tx /\ topology_on Y Ty.
{ exact (andEL (topology_on X Tx /\ topology_on Y Ty) (total_function_on f X Y) Hleft). }
claim Htot: total_function_on f X Y.
{ exact (andER (topology_on X Tx /\ topology_on Y Ty) (total_function_on f X Y) Hleft). }
claim Hfun: function_on f X Y.
{ exact (total_function_on_function_on f X Y Htot). }
apply andI.
- apply andI.
  + exact Htops.
  + exact Hfun.
- exact Hright.
Qed.

(** Helper: constant maps are continuous **)
Theorem const_fun_continuous : forall X Tx Y Ty x:set,
  topology_on X Tx -> topology_on Y Ty -> x :e Y ->
  continuous_map X Tx Y Ty (const_fun X x).
let X Tx Y Ty x.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
assume HxY: x :e Y.
prove continuous_map X Tx Y Ty (const_fun X x).
prove topology_on X Tx /\ topology_on Y Ty /\ function_on (const_fun X x) X Y /\
      forall V:set, V :e Ty -> preimage_of X (const_fun X x) V :e Tx.
apply andI.
- (** left: (topology_on X Tx /\ topology_on Y Ty) /\ function_on ... **)
  apply andI.
  + apply andI.
    * exact HTx.
    * exact HTy.
  + (** function_on **)
    let a. assume HaX: a :e X.
    prove apply_fun (const_fun X x) a :e Y.
    claim Happ: apply_fun (const_fun X x) a = x.
    { exact (const_fun_apply X x a HaX). }
    rewrite Happ.
    exact HxY.
- (** preimage condition **)
  let V. assume HV: V :e Ty.
  claim Hcases: x :e V \/ x /:e V.
  { exact (xm (x :e V)). }
  apply (Hcases (preimage_of X (const_fun X x) V :e Tx)).
  + (** case x  V: preimage = X **)
    assume HxV: x :e V.
    claim Heq: preimage_of X (const_fun X x) V = X.
    { apply set_ext.
      - let a. assume Ha: a :e preimage_of X (const_fun X x) V.
        prove a :e X.
        apply (SepE X (fun u => apply_fun (const_fun X x) u :e V) a Ha).
        assume HaX. assume _. exact HaX.
      - let a. assume HaX: a :e X.
        prove a :e preimage_of X (const_fun X x) V.
        prove a :e {u :e X | apply_fun (const_fun X x) u :e V}.
        apply (SepI X (fun u => apply_fun (const_fun X x) u :e V) a HaX).
        claim Happ: apply_fun (const_fun X x) a = x.
        { exact (const_fun_apply X x a HaX). }
        rewrite Happ.
        exact HxV.
    }
    rewrite Heq.
    exact (topology_has_X X Tx HTx).
  + (** case x  V: preimage = Empty **)
    assume HxVn: x /:e V.
    claim Heq: preimage_of X (const_fun X x) V = Empty.
    { apply set_ext.
      - let a. assume Ha: a :e preimage_of X (const_fun X x) V.
        prove a :e Empty.
        apply FalseE.
        apply (SepE X (fun u => apply_fun (const_fun X x) u :e V) a Ha).
        assume HaX. assume Hav.
        claim Happ: apply_fun (const_fun X x) a = x.
        { exact (const_fun_apply X x a HaX). }
        claim HxV: x :e V.
        { rewrite <- Happ. exact Hav. }
        exact (HxVn HxV).
      - let a. assume HaE: a :e Empty.
        prove a :e preimage_of X (const_fun X x) V.
        apply FalseE.
        exact (EmptyE a HaE).
    }
    rewrite Heq.
    exact (topology_has_empty X Tx HTx).
Qed.

(** Helper: constant maps are continuous (total variant) **)
Theorem const_fun_continuous_total : forall X Tx Y Ty x:set,
  topology_on X Tx -> topology_on Y Ty -> x :e Y ->
  continuous_map_total X Tx Y Ty (const_fun X x).
let X Tx Y Ty x.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
assume HxY: x :e Y.
prove continuous_map_total X Tx Y Ty (const_fun X x).
prove ((topology_on X Tx /\ topology_on Y Ty) /\ total_function_on (const_fun X x) X Y) /\
  forall V:set, V :e Ty -> preimage_of X (const_fun X x) V :e Tx.
apply andI.
- apply andI.
  + apply andI.
    * exact HTx.
    * exact HTy.
  + exact (const_fun_total_function_on X Y x HxY).
- claim Hc: continuous_map X Tx Y Ty (const_fun X x).
  { exact (const_fun_continuous X Tx Y Ty x HTx HTy HxY). }
  exact (andER ((topology_on X Tx /\ topology_on Y Ty) /\ function_on (const_fun X x) X Y)
               (forall V:set, V :e Ty -> preimage_of X (const_fun X x) V :e Tx)
               Hc).
Qed.

(** Helper: continuity preserves closed sets **)
Theorem continuous_preserves_closed : forall X Tx Y Ty f:set,
  continuous_map X Tx Y Ty f ->
  forall C:set, closed_in Y Ty C -> closed_in X Tx (preimage_of X f C).
let X Tx Y Ty f.
assume Hcont: continuous_map X Tx Y Ty f.
claim Hpreimg: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
{ exact (andER ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx) Hcont). }
claim Hleft: (topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y.
{ exact (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx) Hcont). }
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (topology_on Y Ty)
               (andEL (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y) Hleft)). }
claim HTy: topology_on Y Ty.
{ exact (andER (topology_on X Tx) (topology_on Y Ty)
               (andEL (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y) Hleft)). }
claim Hf: function_on f X Y.
{ exact (andER (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y) Hleft). }
let C. assume HC: closed_in Y Ty C.
claim Hright: C c= Y /\ exists U :e Ty, C = Y :\: U.
{ exact (andER (topology_on Y Ty) (C c= Y /\ exists U :e Ty, C = Y :\: U) HC). }
claim HCsub: C c= Y.
{ exact (andEL (C c= Y) (exists U :e Ty, C = Y :\: U) Hright). }
claim HU: exists U :e Ty, C = Y :\: U.
{ exact (andER (C c= Y) (exists U :e Ty, C = Y :\: U) Hright). }
apply HU.
let U. assume HU.
apply HU.
assume HUTy: U :e Ty.
assume HCeq: C = Y :\: U.
prove closed_in X Tx (preimage_of X f C).
prove topology_on X Tx /\ (preimage_of X f C c= X /\ exists V :e Tx, preimage_of X f C = X :\: V).
apply andI.
- exact HTx.
- prove preimage_of X f C c= X /\ exists V :e Tx, preimage_of X f C = X :\: V.
  apply andI.
  + prove preimage_of X f C c= X.
    let x. assume Hx: x :e preimage_of X f C.
    prove x :e X.
    exact (SepE1 X (fun x => apply_fun f x :e C) x Hx).
  + prove exists V :e Tx, preimage_of X f C = X :\: V.
    witness (preimage_of X f U).
    apply andI.
  + exact (Hpreimg U HUTy).
  + prove preimage_of X f C = X :\: preimage_of X f U.
    rewrite HCeq.
    prove preimage_of X f (Y :\: U) = X :\: preimage_of X f U.
    apply set_ext.
    * let x. assume Hx: x :e preimage_of X f (Y :\: U).
      prove x :e X :\: preimage_of X f U.
      apply (SepE X (fun x => apply_fun f x :e Y :\: U) x Hx).
      assume HxX: x :e X.
      assume Hfx: apply_fun f x :e Y :\: U.
      apply (setminusE Y U (apply_fun f x) Hfx).
      assume HfxY: apply_fun f x :e Y.
      assume HfxU: apply_fun f x /:e U.
      apply setminusI.
      { exact HxX. }
      { prove x /:e preimage_of X f U.
        assume Hxpre: x :e preimage_of X f U.
        apply (SepE X (fun x => apply_fun f x :e U) x Hxpre).
        assume _. assume HfxU2: apply_fun f x :e U.
        exact (HfxU HfxU2). }
    * let x. assume Hx: x :e X :\: preimage_of X f U.
      prove x :e preimage_of X f (Y :\: U).
      apply (setminusE X (preimage_of X f U) x Hx).
      assume HxX: x :e X.
      assume Hxpre: x /:e preimage_of X f U.
      prove x :e {x :e X | apply_fun f x :e Y :\: U}.
      apply SepI.
      { exact HxX. }
      { prove apply_fun f x :e Y :\: U.
        apply setminusI.
        { exact (Hf x HxX). }
        { prove apply_fun f x /:e U.
          assume HfxU: apply_fun f x :e U.
          claim Hxpre2: x :e preimage_of X f U.
          { exact (SepI X (fun x => apply_fun f x :e U) x HxX HfxU). }
          exact (Hxpre Hxpre2). } }
Qed.

(** Helper: continuity local neighborhood characterization **)
Theorem continuous_local_neighborhood : forall X Tx Y Ty f:set,
  topology_on X Tx -> topology_on Y Ty -> function_on f X Y ->
  (forall V:set, V :e Ty -> preimage_of X f V :e Tx) ->
  forall x:set, x :e X ->
    forall V:set, V :e Ty -> apply_fun f x :e V ->
      exists U:set, U :e Tx /\ x :e U /\ forall u:set, u :e U -> apply_fun f u :e V.
let X Tx Y Ty f.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
assume Hf: function_on f X Y.
assume Hcont: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
let x. assume Hx: x :e X.
let V. assume HV: V :e Ty.
assume Hfx: apply_fun f x :e V.
witness (preimage_of X f V).
apply and3I.
- exact (Hcont V HV).
- prove x :e preimage_of X f V.
  prove x :e {x :e X | apply_fun f x :e V}.
  exact (SepI X (fun x => apply_fun f x :e V) x Hx Hfx).
- let u. assume Hu: u :e preimage_of X f V.
  prove apply_fun f u :e V.
  apply (SepE X (fun x => apply_fun f x :e V) u Hu).
  assume _. assume H. exact H.
Qed.

(** continuity at a point **)
(** LATEX VERSION: f is continuous at x if for every neighborhood V of f(x), there exists neighborhood U of x with f(U)V. **)
(** FIXED: Formalized using open-set neighborhood criterion in the standard topology on R. **)
Definition continuous_at : set -> set -> prop := fun f x =>
  function_on f R R /\ x :e R /\
  forall V:set, V :e R_standard_topology -> apply_fun f x :e V ->
    exists U:set, U :e R_standard_topology /\ x :e U /\ forall u:set, u :e U -> apply_fun f u :e V.

(** from 18 Theorem 18.1: equivalent formulations of continuity **) 
(** LATEX VERSION: Equivalent characterizations of continuity: open-preimage, closed-preimage, neighborhood criterion. **)
Theorem continuity_equiv_forms : forall X Tx Y Ty f:set,
  topology_on X Tx -> topology_on Y Ty ->
  (continuous_map X Tx Y Ty f <->
    function_on f X Y /\
    (forall V:set, V :e Ty -> preimage_of X f V :e Tx) /\
    (forall C:set, closed_in Y Ty C -> closed_in X Tx (preimage_of X f C)) /\
    (forall x:set, x :e X ->
       forall V:set, V :e Ty -> apply_fun f x :e V ->
         exists U:set, U :e Tx /\ x :e U /\ forall u:set, u :e U -> apply_fun f u :e V)).
let X Tx Y Ty f.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove continuous_map X Tx Y Ty f <->
    function_on f X Y /\
    (forall V:set, V :e Ty -> preimage_of X f V :e Tx) /\
    (forall C:set, closed_in Y Ty C -> closed_in X Tx (preimage_of X f C)) /\
    (forall x:set, x :e X ->
       forall V:set, V :e Ty -> apply_fun f x :e V ->
         exists U:set, U :e Tx /\ x :e U /\ forall u:set, u :e U -> apply_fun f u :e V).
apply iffI.
- (** Forward direction: continuous_map implies all three conditions **)
  assume Hf: continuous_map X Tx Y Ty f.
  prove function_on f X Y /\
        (forall V:set, V :e Ty -> preimage_of X f V :e Tx) /\
        (forall C:set, closed_in Y Ty C -> closed_in X Tx (preimage_of X f C)) /\
        (forall x:set, x :e X ->
           forall V:set, V :e Ty -> apply_fun f x :e V ->
             exists U:set, U :e Tx /\ x :e U /\ forall u:set, u :e U -> apply_fun f u :e V).
  (** Extract components from continuous_map definition **)
  claim Hpreimage: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
  { exact (andER (topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y)
                 (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
                 Hf). }
  claim Hfun: function_on f X Y.
  { exact (andER (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y)
                 (andEL (topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y)
                        (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
                        Hf)). }
  (** Build (((Hfun /\ Hpreimage) /\ closed-preimage) /\ neighborhood) **)
  apply andI.
  - apply andI.
    + apply andI.
      * exact Hfun.
      * exact Hpreimage.
    + exact (continuous_preserves_closed X Tx Y Ty f Hf).
  - exact (continuous_local_neighborhood X Tx Y Ty f HTx HTy Hfun Hpreimage).
- (** Backward direction: three conditions imply continuous_map **)
  assume Hconds.
  prove continuous_map X Tx Y Ty f.
  (** Extract function_on and preimage condition from the left-associative conjunction:
      Hconds : (((A /\ B) /\ C) /\ D) where
      A = function_on f X Y
      B = forall V, V :e Ty -> preimage_of X f V :e Tx
      C = forall C, closed_in Y Ty C -> closed_in X Tx (preimage_of X f C)
      D = forall x, ... neighborhood condition **)
  claim Habc:
    (function_on f X Y /\ (forall V:set, V :e Ty -> preimage_of X f V :e Tx)) /\
    (forall C:set, closed_in Y Ty C -> closed_in X Tx (preimage_of X f C)).
  { exact (andEL (((function_on f X Y /\ (forall V:set, V :e Ty -> preimage_of X f V :e Tx)) /\
                   (forall C:set, closed_in Y Ty C -> closed_in X Tx (preimage_of X f C))))
                 (forall x:set, x :e X ->
                    forall V:set, V :e Ty -> apply_fun f x :e V ->
                      exists U:set, U :e Tx /\ x :e U /\ forall u:set, u :e U -> apply_fun f u :e V)
                 Hconds). }
  claim Hab:
    function_on f X Y /\ (forall V:set, V :e Ty -> preimage_of X f V :e Tx).
  { exact (andEL (function_on f X Y /\ (forall V:set, V :e Ty -> preimage_of X f V :e Tx))
                 (forall C:set, closed_in Y Ty C -> closed_in X Tx (preimage_of X f C))
                 Habc). }
  claim Hfun: function_on f X Y.
  { exact (andEL (function_on f X Y) (forall V:set, V :e Ty -> preimage_of X f V :e Tx) Hab). }
  claim Hpreimage: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
  { exact (andER (function_on f X Y) (forall V:set, V :e Ty -> preimage_of X f V :e Tx) Hab). }
  (** Build continuous_map from components **)
  prove topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y /\
        (forall V:set, V :e Ty -> preimage_of X f V :e Tx).
  apply andI.
  + apply andI.
    * apply andI.
      - exact HTx.
      - exact HTy.
    * exact Hfun.
  + exact Hpreimage.
Qed.

(** from 18: identity map is continuous **) 
(** LATEX VERSION: Identity map on any space is continuous. **)
(** FIXED: Identity function must use ordered pairs (tuple notation), not UPair. **)
Theorem identity_continuous : forall X Tx:set,
  topology_on X Tx ->
  let id := {(x,x)|x :e X} in
  continuous_map X Tx X Tx id.
let X Tx.
assume HTx: topology_on X Tx.
prove let id := {(x,x)|x :e X} in continuous_map X Tx X Tx id.
set id := {(x,x)|x :e X}.
prove continuous_map X Tx X Tx id.
(** Strategy: Unfold continuous_map definition and show:
    1. topology_on X Tx (given)
    2. function_on id X X (identity is a function)
    3. For all V :e Tx, preimage_of X id V :e Tx
    Key insight: preimage_of X id V = V for V :e Tx **)
(** Unfold: continuous_map = topology_on X Tx /\ topology_on X Tx /\ function_on id X X /\ (forall V:set, V :e Tx -> preimage_of X id V :e Tx)
    This is left-associative: (((A /\ B) /\ C) /\ D) **)
prove topology_on X Tx /\ topology_on X Tx /\ function_on id X X /\
  forall V:set, V :e Tx -> preimage_of X id V :e Tx.
(** Build the conjunction left-to-right **)
claim Hpart1: topology_on X Tx /\ topology_on X Tx.
{ apply andI. exact HTx. exact HTx. }
claim Hpart2: (topology_on X Tx /\ topology_on X Tx) /\ function_on id X X.
{ apply andI.
  - exact Hpart1.
  - (** function_on id X X **)
    prove function_on id X X.
    prove forall x:set, x :e X -> apply_fun id x :e X.
    let x. assume Hx: x :e X.
    prove apply_fun id x :e X.
    (** For x :e X, we have (x,x) :e id, so apply_fun id x = x by Eps_i.
        Therefore apply_fun id x :e X. This requires showing uniqueness of y in (x,y) :e id. **)
    claim Hid_x: apply_fun id x = x.
    { exact (identity_function_apply X x Hx). }
    rewrite Hid_x.
    exact Hx. }
apply andI.
- exact Hpart2.
- (** forall V:set, V :e Tx -> preimage_of X id V :e Tx **)
  let V. assume HV: V :e Tx.
  prove preimage_of X id V :e Tx.
  (** preimage_of X id V = {x :e X | apply_fun id x :e V} = {x :e X | x :e V} = V (when V c= X) **)
  claim HVsub: V c= X.
  { exact (topology_elem_subset X Tx V HTx HV). }
  claim Hpreimg_eq: preimage_of X id V = V.
  { apply set_ext.
    - let x. assume Hx: x :e preimage_of X id V.
      prove x :e V.
      claim HxX: x :e X.
      { exact (SepE1 X (fun y => apply_fun id y :e V) x Hx). }
      claim Hidx_in_V: apply_fun id x :e V.
      { exact (SepE2 X (fun y => apply_fun id y :e V) x Hx). }
      claim Hidx_eq: apply_fun id x = x.
      { exact (identity_function_apply X x HxX). }
      rewrite <- Hidx_eq.
      exact Hidx_in_V.
    - let x. assume Hx: x :e V.
      prove x :e preimage_of X id V.
      prove x :e {y :e X | apply_fun id y :e V}.
      claim HxX: x :e X.
      { exact (HVsub x Hx). }
      apply SepI.
      + exact HxX.
      + prove apply_fun id x :e V.
        claim Hidx_eq: apply_fun id x = x.
        { exact (identity_function_apply X x HxX). }
        rewrite Hidx_eq.
        exact Hx. }
  rewrite Hpreimg_eq.
  exact HV.
Qed.

 (** from 18: composition of continuous maps is continuous **)
 (** LATEX VERSION: Composition of continuous functions remains continuous. **)
 (** FIXED: Function composition must use ordered pairs (tuple notation), not UPair. **)
Definition compose_fun : set -> set -> set -> set := fun X f g =>
  {(x, apply_fun g (apply_fun f x))|x :e X}.

(** Helper: apply_fun on composed functions **)
Theorem compose_fun_apply : forall X f g x:set,
  x :e X -> apply_fun (compose_fun X f g) x = apply_fun g (apply_fun f x).
let X f g x. assume Hx.
prove apply_fun (compose_fun X f g) x = apply_fun g (apply_fun f x).
prove apply_fun {(y, apply_fun g (apply_fun f y)) | y :e X} x = apply_fun g (apply_fun f x).
prove Eps_i (fun z => (x, z) :e {(y, apply_fun g (apply_fun f y)) | y :e X}) = apply_fun g (apply_fun f x).
claim H1: (x, apply_fun g (apply_fun f x)) :e {(y, apply_fun g (apply_fun f y)) | y :e X}.
{ exact (ReplI X (fun y => (y, apply_fun g (apply_fun f y))) x Hx). }
claim H2: (x, Eps_i (fun z => (x, z) :e {(y, apply_fun g (apply_fun f y)) | y :e X})) :e {(y, apply_fun g (apply_fun f y)) | y :e X}.
{ exact (Eps_i_ax (fun z => (x, z) :e {(y, apply_fun g (apply_fun f y)) | y :e X}) (apply_fun g (apply_fun f x)) H1). }
apply (ReplE_impred X (fun y => (y, apply_fun g (apply_fun f y))) (x, Eps_i (fun z => (x, z) :e {(y, apply_fun g (apply_fun f y)) | y :e X})) H2).
let y.
assume Hy: y :e X.
assume Heq: (x, Eps_i (fun z => (x, z) :e {(y0, apply_fun g (apply_fun f y0)) | y0 :e X})) = (y, apply_fun g (apply_fun f y)).
claim Hx_eq: x = y.
{ rewrite <- (tuple_2_0_eq x (Eps_i (fun z => (x, z) :e {(y0, apply_fun g (apply_fun f y0)) | y0 :e X}))).
  rewrite <- (tuple_2_0_eq y (apply_fun g (apply_fun f y))).
  rewrite Heq.
  reflexivity. }
claim Hz_eq: Eps_i (fun z => (x, z) :e {(y0, apply_fun g (apply_fun f y0)) | y0 :e X}) = apply_fun g (apply_fun f y).
{ rewrite <- (tuple_2_1_eq x (Eps_i (fun z => (x, z) :e {(y0, apply_fun g (apply_fun f y0)) | y0 :e X}))).
  rewrite <- (tuple_2_1_eq y (apply_fun g (apply_fun f y))).
  rewrite Heq.
  reflexivity. }
rewrite Hz_eq.
rewrite <- Hx_eq.
reflexivity.
Qed.

(** Helper: preimage composition under function_on assumption **)
Theorem preimage_compose_fun : forall X Y f g W:set,
  function_on f X Y ->
  preimage_of X (compose_fun X f g) W = preimage_of X f (preimage_of Y g W).
let X Y f g W.
assume Hfun: function_on f X Y.
apply set_ext.
- let x. assume HxL: x :e preimage_of X (compose_fun X f g) W.
  prove x :e preimage_of X f (preimage_of Y g W).
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0:set => apply_fun (compose_fun X f g) x0 :e W) x HxL). }
  claim HxW: apply_fun (compose_fun X f g) x :e W.
  { exact (SepE2 X (fun x0:set => apply_fun (compose_fun X f g) x0 :e W) x HxL). }
  claim Hcomp: apply_fun (compose_fun X f g) x = apply_fun g (apply_fun f x).
  { exact (compose_fun_apply X f g x HxX). }
  claim HfxY: apply_fun f x :e Y.
  { exact (Hfun x HxX). }
  prove x :e {x0 :e X | apply_fun f x0 :e preimage_of Y g W}.
  claim HfxInPre: apply_fun f x :e preimage_of Y g W.
  { prove apply_fun f x :e {y :e Y | apply_fun g y :e W}.
    claim HgfxW: apply_fun g (apply_fun f x) :e W.
    { rewrite <- Hcomp.
      exact HxW. }
    exact (SepI Y (fun y0:set => apply_fun g y0 :e W) (apply_fun f x) HfxY HgfxW). }
  exact (SepI X (fun x0:set => apply_fun f x0 :e preimage_of Y g W) x HxX HfxInPre).
- let x. assume HxR: x :e preimage_of X f (preimage_of Y g W).
  prove x :e preimage_of X (compose_fun X f g) W.
  claim HxX: x :e X.
  { exact (SepE1 X (fun x0:set => apply_fun f x0 :e preimage_of Y g W) x HxR). }
  claim HfxPre: apply_fun f x :e preimage_of Y g W.
  { exact (SepE2 X (fun x0:set => apply_fun f x0 :e preimage_of Y g W) x HxR). }
  claim HfxY: apply_fun f x :e Y.
  { exact (SepE1 Y (fun y0:set => apply_fun g y0 :e W) (apply_fun f x) HfxPre). }
  claim HgW: apply_fun g (apply_fun f x) :e W.
  { exact (SepE2 Y (fun y0:set => apply_fun g y0 :e W) (apply_fun f x) HfxPre). }
  claim Hcomp: apply_fun (compose_fun X f g) x = apply_fun g (apply_fun f x).
  { exact (compose_fun_apply X f g x HxX). }
  claim HcompW: apply_fun (compose_fun X f g) x :e W.
  { rewrite Hcomp.
    exact HgW. }
  exact (SepI X (fun x0:set => apply_fun (compose_fun X f g) x0 :e W) x HxX HcompW).
Qed.

 Theorem composition_continuous : forall X Tx Y Ty Z Tz f g:set,
   continuous_map X Tx Y Ty f ->
   continuous_map Y Ty Z Tz g ->
   continuous_map X Tx Z Tz (compose_fun X f g).
let X Tx Y Ty Z Tz f g.
assume Hf: continuous_map X Tx Y Ty f.
assume Hg: continuous_map Y Ty Z Tz g.
prove continuous_map X Tx Z Tz (compose_fun X f g).
set gf := compose_fun X f g.
(** Strategy: Show gf is continuous by proving preimages of open sets are open.
    Key insight: preimage of W under gf equals preimage of (preimage of W under g) under f.
    Since g continuous: g(W) is open in Y
    Since f continuous: f(g(W)) is open in X **)
(** Extract components from continuous_map definitions **)
(** Hf: topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y /\ (forall V...) **)
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (topology_on Y Ty)
          (andEL (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y)
            (andEL (topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y)
                   (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
                   Hf))). }
claim HTy_from_f: topology_on Y Ty.
{ exact (andER (topology_on X Tx) (topology_on Y Ty)
          (andEL (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y)
            (andEL (topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y)
                   (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
                   Hf))). }
claim Hfun_f: function_on f X Y.
{ exact (andER (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y)
          (andEL (topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y)
                 (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
                 Hf)). }
claim Hpreimg_f: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
{ exact (andER (topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               Hf). }
(** Hg: topology_on Y Ty /\ topology_on Z Tz /\ function_on g Y Z /\ (forall W...) **)
claim HTy: topology_on Y Ty.
{ exact (andEL (topology_on Y Ty) (topology_on Z Tz)
          (andEL (topology_on Y Ty /\ topology_on Z Tz) (function_on g Y Z)
            (andEL (topology_on Y Ty /\ topology_on Z Tz /\ function_on g Y Z)
                   (forall W:set, W :e Tz -> preimage_of Y g W :e Ty)
                   Hg))). }
claim HTz: topology_on Z Tz.
{ exact (andER (topology_on Y Ty) (topology_on Z Tz)
          (andEL (topology_on Y Ty /\ topology_on Z Tz) (function_on g Y Z)
            (andEL (topology_on Y Ty /\ topology_on Z Tz /\ function_on g Y Z)
                   (forall W:set, W :e Tz -> preimage_of Y g W :e Ty)
                   Hg))). }
claim Hfun_g: function_on g Y Z.
{ exact (andER (topology_on Y Ty /\ topology_on Z Tz) (function_on g Y Z)
          (andEL (topology_on Y Ty /\ topology_on Z Tz /\ function_on g Y Z)
                 (forall W:set, W :e Tz -> preimage_of Y g W :e Ty)
                 Hg)). }
claim Hpreimg_g: forall W:set, W :e Tz -> preimage_of Y g W :e Ty.
{ exact (andER (topology_on Y Ty /\ topology_on Z Tz /\ function_on g Y Z)
               (forall W:set, W :e Tz -> preimage_of Y g W :e Ty)
               Hg). }
(** Show gf = gf is continuous **)
(** Need: topology_on X Tx /\ topology_on Z Tz /\ function_on gf X Z /\ (forall W:set, W :e Tz -> preimage_of X gf W :e Tx) **)
(** Build the conjunction left-to-right due to left associativity **)
prove topology_on X Tx /\ topology_on Z Tz /\ function_on gf X Z /\
  (forall W:set, W :e Tz -> preimage_of X gf W :e Tx).
claim Hpart1: topology_on X Tx /\ topology_on Z Tz.
{ apply andI. exact HTx. exact HTz. }
claim Hpart2: (topology_on X Tx /\ topology_on Z Tz) /\ function_on gf X Z.
{ apply andI.
  - exact Hpart1.
  - (** Prove function_on gf X Z **)
    prove forall x:set, x :e X -> apply_fun gf x :e Z.
    let x. assume Hx: x :e X.
    prove apply_fun gf x :e Z.
    (** gf = {(x, apply_fun g (apply_fun f x))|x :e X} **)
    (** So apply_fun gf x should be apply_fun g (apply_fun f x) **)
    (** Since f: X -> Y, we have apply_fun f x :e Y **)
    claim Hfx: apply_fun f x :e Y.
    { exact (Hfun_f x Hx). }
    (** Since g: Y -> Z, we have apply_fun g (apply_fun f x) :e Z **)
    claim Hgfx: apply_fun g (apply_fun f x) :e Z.
    { exact (Hfun_g (apply_fun f x) Hfx). }
    (** Show apply_fun gf x :e Z using compose_fun_apply axiom **)
    claim Hgf_eq: apply_fun gf x = apply_fun g (apply_fun f x).
    { exact (compose_fun_apply X f g x Hx). }
    rewrite Hgf_eq.
    exact Hgfx.
}
apply andI.
- exact Hpart2.
- (** Prove preimages of open sets in Z are open in X **)
  let W. assume HW: W :e Tz.
  prove preimage_of X gf W :e Tx.
  (** Since g is continuous, preimage_of Y g W is open in Ty **)
  claim HgW_open: preimage_of Y g W :e Ty.
  { exact (Hpreimg_g W HW). }
  (** Since f is continuous, preimage_of X f (preimage_of Y g W) is open in Tx **)
  claim HfgW_open: preimage_of X f (preimage_of Y g W) :e Tx.
  { exact (Hpreimg_f (preimage_of Y g W) HgW_open). }
	  (** Show that preimage_of X gf W = preimage_of X f (preimage_of Y g W) **)
	  claim Hpreimg_eq: preimage_of X gf W = preimage_of X f (preimage_of Y g W).
	  { (** Use preimage composition property **)
	    exact (preimage_compose_fun X Y f g W Hfun_f).
	  }
  rewrite Hpreimg_eq.
  exact HfgW_open.
Qed.

(** from 18 Theorem 18.2: rules for constructing continuous functions **) 
(** LATEX VERSION: Theorem 18.2: Constant maps, inclusions, composites, domain restriction, range restriction/expansion, and local continuity formulation. **)
Theorem continuous_construction_rules : forall X Tx Y Ty Z Tz:set,
  topology_on X Tx -> topology_on Y Ty -> topology_on Z Tz ->
  (forall y0:set, y0 :e Y -> continuous_map X Tx Y Ty (const_fun X y0))
  /\
  (forall A:set, A c= X -> continuous_map A (subspace_topology X Tx A) X Tx {(y,y) | y :e A})
  /\
  (forall f g:set, continuous_map X Tx Y Ty f -> continuous_map Y Ty Z Tz g ->
    continuous_map X Tx Z Tz (compose_fun X f g))
  /\
  (forall f A:set, A c= X -> continuous_map X Tx Y Ty f ->
    continuous_map A (subspace_topology X Tx A) Y Ty f)
  /\
  ((forall f Z0:set, continuous_map X Tx Y Ty f -> Z0 c= Y ->
     (forall x:set, x :e X -> apply_fun f x :e Z0) ->
     continuous_map X Tx Z0 (subspace_topology Y Ty Z0) f)
   /\
   (forall f Z0 Tz0:set, continuous_map X Tx Y Ty f -> Y c= Z0 ->
     topology_on Z0 Tz0 -> Ty = subspace_topology Z0 Tz0 Y ->
     continuous_map X Tx Z0 Tz0 f))
  /\
  (forall f:set,
    (exists UFam:set, UFam c= Tx /\ Union UFam = X /\
      (forall U:set, U :e UFam -> continuous_map U (subspace_topology X Tx U) Y Ty f))
    -> continuous_map X Tx Y Ty f).
let X Tx Y Ty Z Tz.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
assume HTz: topology_on Z Tz.
prove (forall y0:set, y0 :e Y -> continuous_map X Tx Y Ty (const_fun X y0))
  /\ (forall A:set, A c= X -> continuous_map A (subspace_topology X Tx A) X Tx {(y,y) | y :e A})
  /\ (forall f g:set, continuous_map X Tx Y Ty f -> continuous_map Y Ty Z Tz g ->
       continuous_map X Tx Z Tz (compose_fun X f g))
  /\ (forall f A:set, A c= X -> continuous_map X Tx Y Ty f ->
       continuous_map A (subspace_topology X Tx A) Y Ty f)
  /\ ((forall f Z0:set, continuous_map X Tx Y Ty f -> Z0 c= Y ->
        (forall x:set, x :e X -> apply_fun f x :e Z0) ->
        continuous_map X Tx Z0 (subspace_topology Y Ty Z0) f)
      /\
      (forall f Z0 Tz0:set, continuous_map X Tx Y Ty f -> Y c= Z0 ->
        topology_on Z0 Tz0 -> Ty = subspace_topology Z0 Tz0 Y ->
        continuous_map X Tx Z0 Tz0 f))
  /\ (forall f:set,
       (exists UFam:set, UFam c= Tx /\ Union UFam = X /\
         (forall U:set, U :e UFam -> continuous_map U (subspace_topology X Tx U) Y Ty f))
       -> continuous_map X Tx Y Ty f).
apply andI.
- (** left: (a) through (e) **)
  apply andI.
  + (** left: (a) through (d) **)
    apply andI.
    * (** left: (a) through (c) **)
      apply andI.
      { (** left: (a) and (b) **)
        apply andI.
        - (** (a) constant functions **)
          let y0. assume Hy0: y0 :e Y.
          exact (const_fun_continuous X Tx Y Ty y0 HTx HTy Hy0).
        - (** (b) inclusion of a subspace is continuous **)
          let A. assume HA: A c= X.
          set j := {(y,y) | y :e A}.
          prove continuous_map A (subspace_topology X Tx A) X Tx j.
          prove topology_on A (subspace_topology X Tx A) /\ topology_on X Tx /\ function_on j A X /\
                forall V:set, V :e Tx -> preimage_of A j V :e subspace_topology X Tx A.
          apply andI.
          - apply andI.
            + apply andI.
              * exact (subspace_topology_is_topology X Tx A HTx HA).
              * exact HTx.
            + let a. assume HaA: a :e A.
              prove apply_fun j a :e X.
              claim Haj: apply_fun j a = a.
              { exact (identity_function_apply A a HaA). }
              rewrite Haj.
              exact (HA a HaA).
          - let V. assume HV: V :e Tx.
            prove preimage_of A j V :e subspace_topology X Tx A.
            claim Heq: preimage_of A j V = V :/\: A.
            { apply set_ext.
              - let a. assume Ha: a :e preimage_of A j V.
                prove a :e V :/\: A.
                claim HaA: a :e A.
                { exact (SepE1 A (fun u:set => apply_fun j u :e V) a Ha). }
                claim Haj: apply_fun j a = a.
                { exact (identity_function_apply A a HaA). }
                claim HaV: a :e V.
                { rewrite <- Haj.
                  exact (SepE2 A (fun u:set => apply_fun j u :e V) a Ha). }
                exact (binintersectI V A a HaV HaA).
              - let a. assume Ha: a :e V :/\: A.
                prove a :e preimage_of A j V.
                claim HaV: a :e V.
                { exact (binintersectE1 V A a Ha). }
                claim HaA: a :e A.
                { exact (binintersectE2 V A a Ha). }
                prove a :e {u :e A | apply_fun j u :e V}.
                apply (SepI A (fun u:set => apply_fun j u :e V) a HaA).
                claim Haj: apply_fun j a = a.
                { exact (identity_function_apply A a HaA). }
                rewrite Haj.
                exact HaV.
            }
            rewrite Heq.
	            claim HVpow: (V :/\: A) :e Power A.
	            { apply PowerI.
	              let a. assume Ha: a :e V :/\: A.
	              exact (binintersectE2 V A a Ha). }
	            claim HexW: exists W :e Tx, V :/\: A = W :/\: A.
	            { witness V.
	              apply andI.
	              - exact HV.
	              - reflexivity. }
	            exact (SepI (Power A) (fun U0:set => exists W :e Tx, U0 = W :/\: A) (V :/\: A) HVpow HexW).
	      }
      { (** (c) composites **)
        let f. let g. assume Hf. assume Hg.
        exact (composition_continuous X Tx Y Ty Z Tz f g Hf Hg).
      }
	    * (** (d) restricting the domain **)
	      let f. let A. assume HA. assume Hf.
	      prove continuous_map A (subspace_topology X Tx A) Y Ty f.
	      claim HTA: topology_on A (subspace_topology X Tx A).
	      { exact (subspace_topology_is_topology X Tx A HTx HA). }
	      claim HpreX: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
	      { exact (andER (((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y))
	                     (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
	                     Hf). }
	      claim Htmp: (topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y.
	      { exact (andEL (((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y))
	                     (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
	                     Hf). }
	      claim HfunXY: function_on f X Y.
	      { exact (andER (topology_on X Tx /\ topology_on Y Ty)
	                     (function_on f X Y)
	                     Htmp). }
	      prove (topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty /\ function_on f A Y)
	            /\ forall V:set, V :e Ty -> preimage_of A f V :e subspace_topology X Tx A.
	      apply andI.
	      - (** topology_on A /\ topology_on Y /\ function_on f A Y **)
	        apply andI.
	        + (** topology_on A /\ topology_on Y **)
	          apply andI.
	          * exact HTA.
	          * exact HTy.
	        + (** function_on f A Y **)
	          let a. assume HaA: a :e A.
	          prove apply_fun f a :e Y.
	          claim HaX: a :e X.
	          { exact (HA a HaA). }
	          exact (HfunXY a HaX).
	      - (** preimage condition in the subspace topology **)
	        let V. assume HV: V :e Ty.
	        prove preimage_of A f V :e subspace_topology X Tx A.
	        claim HWTx: preimage_of X f V :e Tx.
	        { exact (HpreX V HV). }
	        claim Heq: preimage_of A f V = (preimage_of X f V) :/\: A.
	        { apply set_ext.
	          - let a. assume Ha: a :e preimage_of A f V.
	            prove a :e (preimage_of X f V) :/\: A.
	            claim HaA: a :e A.
	            { exact (SepE1 A (fun u:set => apply_fun f u :e V) a Ha). }
	            claim HaX: a :e X.
	            { exact (HA a HaA). }
	            claim HafV: apply_fun f a :e V.
	            { exact (SepE2 A (fun u:set => apply_fun f u :e V) a Ha). }
		            claim HaPreX: a :e preimage_of X f V.
		            { exact (SepI X (fun u:set => apply_fun f u :e V) a HaX HafV). }
	            exact (binintersectI (preimage_of X f V) A a HaPreX HaA).
	          - let a. assume Ha: a :e (preimage_of X f V) :/\: A.
	            prove a :e preimage_of A f V.
	            claim HaPreX: a :e preimage_of X f V.
	            { exact (binintersectE1 (preimage_of X f V) A a Ha). }
	            claim HaA: a :e A.
	            { exact (binintersectE2 (preimage_of X f V) A a Ha). }
	            claim HafV: apply_fun f a :e V.
	            { exact (SepE2 X (fun u:set => apply_fun f u :e V) a HaPreX). }
		            exact (SepI A (fun u:set => apply_fun f u :e V) a HaA HafV).
	        }
	        rewrite Heq.
	        claim Hpow: ((preimage_of X f V) :/\: A) :e Power A.
	        { apply PowerI.
	          let a. assume Ha: a :e (preimage_of X f V) :/\: A.
	          exact (binintersectE2 (preimage_of X f V) A a Ha). }
	        claim HexW: exists W :e Tx, (preimage_of X f V) :/\: A = W :/\: A.
	        { witness (preimage_of X f V).
	          apply andI.
	          - exact HWTx.
	          - reflexivity. }
	        exact (SepI (Power A) (fun U0:set => exists W :e Tx, U0 = W :/\: A)
	                   ((preimage_of X f V) :/\: A) Hpow HexW).
	  + (** (e) restricting or expanding the range **)
	    apply andI.
	    - (** (e) restricting the range to a subspace Z0Y containing f(X) **)
	      let f. let Z0. assume Hf. assume HZ0. assume Himg.
	      prove continuous_map X Tx Z0 (subspace_topology Y Ty Z0) f.
	      (** Extract preimage axiom for f: X -> Y **)
	      claim HpreY: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
	      { exact (andER (((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y))
	                     (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
	                     Hf). }
	      (** Z0 with the subspace topology is a topological space **)
	      claim HTz0: topology_on Z0 (subspace_topology Y Ty Z0).
	      { exact (subspace_topology_is_topology Y Ty Z0 HTy HZ0). }
	      (** function_on f X Z0 **)
	      claim HfunXZ0: function_on f X Z0.
	      { let x. assume HxX: x :e X.
	        exact (Himg x HxX). }
	      (** prove the continuity conjunction **)
	      prove (topology_on X Tx /\ topology_on Z0 (subspace_topology Y Ty Z0) /\ function_on f X Z0)
	            /\ forall B:set, B :e subspace_topology Y Ty Z0 -> preimage_of X f B :e Tx.
	      apply andI.
	      - (** topologies and function_on **)
	        apply andI.
	        + apply andI.
	          * exact HTx.
	          * exact HTz0.
	        + exact HfunXZ0.
	      - let B. assume HB: B :e subspace_topology Y Ty Z0.
	        (** B is of the form V  Z0 for some V open in Y **)
	        claim Hex: exists V :e Ty, B = V :/\: Z0.
	        { exact (SepE2 (Power Z0) (fun U0:set => exists V :e Ty, U0 = V :/\: Z0) B HB). }
	        apply Hex.
	        let V. assume HVpair.
	        claim HV: V :e Ty.
	        { exact (andEL (V :e Ty) (B = V :/\: Z0) HVpair). }
	        claim HB_eq: B = V :/\: Z0.
	        { exact (andER (V :e Ty) (B = V :/\: Z0) HVpair). }
	        claim HeqPre: preimage_of X f B = preimage_of X f V.
	        { apply set_ext.
	          - let x. assume Hx: x :e preimage_of X f B.
	            prove x :e preimage_of X f V.
	            claim HxX: x :e X.
	            { exact (SepE1 X (fun u:set => apply_fun f u :e B) x Hx). }
	            claim HfxB: apply_fun f x :e B.
	            { exact (SepE2 X (fun u:set => apply_fun f u :e B) x Hx). }
	            claim HfxVz0: apply_fun f x :e V :/\: Z0.
	            { rewrite <- HB_eq. exact HfxB. }
	            claim HfxV: apply_fun f x :e V.
	            { exact (binintersectE1 V Z0 (apply_fun f x) HfxVz0). }
	            exact (SepI X (fun u:set => apply_fun f u :e V) x HxX HfxV).
	          - let x. assume Hx: x :e preimage_of X f V.
	            prove x :e preimage_of X f B.
	            claim HxX: x :e X.
	            { exact (SepE1 X (fun u:set => apply_fun f u :e V) x Hx). }
	            claim HfxV: apply_fun f x :e V.
	            { exact (SepE2 X (fun u:set => apply_fun f u :e V) x Hx). }
	            claim HfxZ0: apply_fun f x :e Z0.
	            { exact (HfunXZ0 x HxX). }
	            claim HfxB: apply_fun f x :e B.
	            { rewrite HB_eq.
	              exact (binintersectI V Z0 (apply_fun f x) HfxV HfxZ0). }
	            exact (SepI X (fun u:set => apply_fun f u :e B) x HxX HfxB).
	        }
	        rewrite HeqPre.
	        exact (HpreY V HV).
	    - (** (e) expanding the range: if Y is a subspace of Z0, continuity as XY implies continuity as XZ0 **)
	      let f. let Z0. let Tz0.
	      assume Hf: continuous_map X Tx Y Ty f.
	      assume HYZ0: Y c= Z0.
	      assume HTz0: topology_on Z0 Tz0.
	      assume HTy_eq: Ty = subspace_topology Z0 Tz0 Y.
	      prove continuous_map X Tx Z0 Tz0 f.
	      claim HpreY: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
	      { exact (andER (((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y))
	                     (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
	                     Hf). }
	      claim Htmp: (topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y.
	      { exact (andEL (((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y))
	                     (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
	                     Hf). }
	      claim HfunXY: function_on f X Y.
	      { exact (andER (topology_on X Tx /\ topology_on Y Ty)
	                     (function_on f X Y)
	                     Htmp). }
	      claim HfunXZ0: function_on f X Z0.
	      { let x. assume HxX: x :e X.
	        exact (HYZ0 (apply_fun f x) (HfunXY x HxX)). }
	      prove (topology_on X Tx /\ topology_on Z0 Tz0 /\ function_on f X Z0) /\
	            forall W:set, W :e Tz0 -> preimage_of X f W :e Tx.
	      apply andI.
	      - apply andI.
	        + apply andI.
	          * exact HTx.
	          * exact HTz0.
	        + exact HfunXZ0.
	      - let W. assume HW: W :e Tz0.
	        set B := W :/\: Y.
	        claim HB_inTy: B :e Ty.
	        { rewrite HTy_eq.
	          (** show B is in the subspace topology on Y **)
	          claim HBpow: B :e Power Y.
	          { apply PowerI.
	            let y. assume HyB: y :e B.
	            exact (binintersectE2 W Y y HyB). }
	          claim Hex: exists V :e Tz0, B = V :/\: Y.
	          { witness W.
	            apply andI.
	            - exact HW.
	            - reflexivity. }
	          exact (SepI (Power Y) (fun U0:set => exists V :e Tz0, U0 = V :/\: Y) B HBpow Hex). }
	        claim HeqPre: preimage_of X f W = preimage_of X f B.
	        { apply set_ext.
	          - let x. assume Hx: x :e preimage_of X f W.
	            prove x :e preimage_of X f B.
	            claim HxX: x :e X.
	            { exact (SepE1 X (fun u:set => apply_fun f u :e W) x Hx). }
	            claim HfxW: apply_fun f x :e W.
	            { exact (SepE2 X (fun u:set => apply_fun f u :e W) x Hx). }
	            claim HfxY: apply_fun f x :e Y.
	            { exact (HfunXY x HxX). }
	            claim HfxB: apply_fun f x :e B.
	            { exact (binintersectI W Y (apply_fun f x) HfxW HfxY). }
	            exact (SepI X (fun u:set => apply_fun f u :e B) x HxX HfxB).
	          - let x. assume Hx: x :e preimage_of X f B.
	            prove x :e preimage_of X f W.
	            claim HxX: x :e X.
	            { exact (SepE1 X (fun u:set => apply_fun f u :e B) x Hx). }
	            claim HfxB: apply_fun f x :e B.
	            { exact (SepE2 X (fun u:set => apply_fun f u :e B) x Hx). }
	            claim HfxW: apply_fun f x :e W.
	            { exact (binintersectE1 W Y (apply_fun f x) HfxB). }
	            exact (SepI X (fun u:set => apply_fun f u :e W) x HxX HfxW).
	        }
	        rewrite HeqPre.
	        exact (HpreY B HB_inTy).
- (** (f) local formulation **)
  let f. assume Hloc.
  prove continuous_map X Tx Y Ty f.
  apply Hloc.
	  let UFam. assume HUFconj.
	  claim HUFpair: (UFam c= Tx /\ Union UFam = X) /\ (forall U:set, U :e UFam -> continuous_map U (subspace_topology X Tx U) Y Ty f).
	  { exact HUFconj. }
	  claim HUFsub_union: UFam c= Tx /\ Union UFam = X.
	  { exact (andEL (UFam c= Tx /\ Union UFam = X)
	                 (forall U:set, U :e UFam -> continuous_map U (subspace_topology X Tx U) Y Ty f)
	                 HUFpair). }
	  claim HcontU: forall U:set, U :e UFam -> continuous_map U (subspace_topology X Tx U) Y Ty f.
	  { exact (andER (UFam c= Tx /\ Union UFam = X)
	                 (forall U:set, U :e UFam -> continuous_map U (subspace_topology X Tx U) Y Ty f)
	                 HUFpair). }
	  claim HUFsub: UFam c= Tx.
	  { exact (andEL (UFam c= Tx) (Union UFam = X) HUFsub_union). }
	  claim HUnionEq: Union UFam = X.
	  { exact (andER (UFam c= Tx) (Union UFam = X) HUFsub_union). }
  (** derive function_on f X Y from the local continuity hypotheses **)
  claim HfunXY: function_on f X Y.
  { let x. assume HxX: x :e X.
	    claim HxUnion: x :e Union UFam.
	    { rewrite HUnionEq. exact HxX. }
    apply (UnionE UFam x HxUnion).
    let U. assume HxUconj.
    claim HxU: x :e U.
    { exact (andEL (x :e U) (U :e UFam) HxUconj). }
    claim HUUF: U :e UFam.
    { exact (andER (x :e U) (U :e UFam) HxUconj). }
    claim HcU: continuous_map U (subspace_topology X Tx U) Y Ty f.
    { exact (HcontU U HUUF). }
    claim Htmp: (topology_on U (subspace_topology X Tx U) /\ topology_on Y Ty) /\ function_on f U Y.
    { exact (andEL ((topology_on U (subspace_topology X Tx U) /\ topology_on Y Ty) /\ function_on f U Y)
                   (forall V:set, V :e Ty -> preimage_of U f V :e subspace_topology X Tx U)
                   HcU). }
    claim HfunUY: function_on f U Y.
    { exact (andER (topology_on U (subspace_topology X Tx U) /\ topology_on Y Ty)
                   (function_on f U Y)
                   Htmp). }
    exact (HfunUY x HxU). }
  (** now prove continuity of f by the preimage definition **)
  prove topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y /\
        forall V:set, V :e Ty -> preimage_of X f V :e Tx.
  apply andI.
  - apply andI.
    + apply andI.
      * exact HTx.
      * exact HTy.
    + exact HfunXY.
  - let V. assume HV: V :e Ty.
    set S := preimage_of X f V.
    (** define Fam = {W open in X | W  S} **)
    set Fam := {W :e Power X | W :e Tx /\ W c= S}.
    claim HFamSubTx: Fam c= Tx.
    { let W. assume HW: W :e Fam.
      claim HWpred: W :e Tx /\ W c= S.
      { exact (SepE2 (Power X) (fun W0:set => W0 :e Tx /\ W0 c= S) W HW). }
      exact (andEL (W :e Tx) (W c= S) HWpred). }
    claim HUnionFamEq: Union Fam = S.
    { apply set_ext.
      - let x. assume Hx: x :e Union Fam.
        prove x :e S.
        apply (UnionE Fam x Hx).
        let W. assume HxWconj.
        claim HxW: x :e W.
        { exact (andEL (x :e W) (W :e Fam) HxWconj). }
        claim HWFam: W :e Fam.
        { exact (andER (x :e W) (W :e Fam) HxWconj). }
        claim HWpred: W :e Tx /\ W c= S.
        { exact (SepE2 (Power X) (fun W0:set => W0 :e Tx /\ W0 c= S) W HWFam). }
        claim HWsubS: W c= S.
        { exact (andER (W :e Tx) (W c= S) HWpred). }
        exact (HWsubS x HxW).
      - let x. assume Hx: x :e S.
        prove x :e Union Fam.
        (** choose a cover element U with x  U **)
        claim HxX: x :e X.
        { exact (SepE1 X (fun u:set => apply_fun f u :e V) x Hx). }
	        claim HxUnion: x :e Union UFam.
	        { rewrite HUnionEq. exact HxX. }
        apply (UnionE UFam x HxUnion).
        let U. assume HxUconj.
        claim HxU: x :e U.
        { exact (andEL (x :e U) (U :e UFam) HxUconj). }
        claim HUUF: U :e UFam.
        { exact (andER (x :e U) (U :e UFam) HxUconj). }
        claim HUTx: U :e Tx.
        { exact (HUFsub U HUUF). }
        claim HUSubX: U c= X.
        { exact (topology_elem_subset X Tx U HTx HUTx). }
        claim HcU: continuous_map U (subspace_topology X Tx U) Y Ty f.
        { exact (HcontU U HUUF). }
        (** from continuity on U: preimage_of U f V is open in the subspace topology **)
        claim HpreU: preimage_of U f V :e subspace_topology X Tx U.
        { exact (andER (((topology_on U (subspace_topology X Tx U) /\ topology_on Y Ty) /\ function_on f U Y))
                       (forall V0:set, V0 :e Ty -> preimage_of U f V0 :e subspace_topology X Tx U)
                       HcU
                       V
                       HV). }
        claim HexW0: exists W0 :e Tx, preimage_of U f V = W0 :/\: U.
        { exact (SepE2 (Power U) (fun U0:set => exists W0 :e Tx, U0 = W0 :/\: U) (preimage_of U f V) HpreU). }
        apply HexW0.
        let W0. assume HW0pair.
        claim HW0Tx: W0 :e Tx.
        { exact (andEL (W0 :e Tx) (preimage_of U f V = W0 :/\: U) HW0pair). }
        claim HeqPreU: preimage_of U f V = W0 :/\: U.
        { exact (andER (W0 :e Tx) (preimage_of U f V = W0 :/\: U) HW0pair). }
        set W := W0 :/\: U.
        (** show x  W **)
        claim HfxV: apply_fun f x :e V.
        { exact (SepE2 X (fun u:set => apply_fun f u :e V) x Hx). }
        claim HxPreU: x :e preimage_of U f V.
        { prove x :e {u :e U | apply_fun f u :e V}.
          apply (SepI U (fun u:set => apply_fun f u :e V) x HxU).
          exact HfxV. }
        claim HxW: x :e W.
        { rewrite <- HeqPreU. exact HxPreU. }
        (** show W  Fam and then x  Union Fam by UnionI **)
        claim HWsubS: W c= S.
        { let z. assume Hz: z :e W.
          prove z :e S.
          claim HzU: z :e U.
          { exact (binintersectE2 W0 U z Hz). }
          claim HzX: z :e X.
          { exact (HUSubX z HzU). }
	          claim HzPreU: z :e preimage_of U f V.
	          { rewrite HeqPreU.
	            exact Hz. }
          claim HfzV: apply_fun f z :e V.
          { exact (SepE2 U (fun u:set => apply_fun f u :e V) z HzPreU). }
          exact (SepI X (fun u:set => apply_fun f u :e V) z HzX HfzV). }
        claim HWpow: W :e Power X.
        { apply PowerI.
          let z. assume Hz: z :e W.
          claim HzU: z :e U.
          { exact (binintersectE2 W0 U z Hz). }
          exact (HUSubX z HzU). }
        claim HWFam: W :e Fam.
        { exact (SepI (Power X) (fun W1:set => W1 :e Tx /\ W1 c= S) W HWpow
                 (andI (W :e Tx) (W c= S)
                   (topology_binintersect_closed X Tx W0 U HTx HW0Tx HUTx)
                   HWsubS)). }
        exact (UnionI Fam x W HxW HWFam).
    }
    rewrite <- HUnionFamEq.
    exact (topology_union_closed X Tx Fam HTx HFamSubTx).
Qed.

(** from 18 Definition: homeomorphism **) 
(** LATEX VERSION: A homeomorphism is a bijective continuous map whose inverse is continuous. **)
Definition homeomorphism : set -> set -> set -> set -> set -> prop :=
  fun X Tx Y Ty f =>
    continuous_map X Tx Y Ty f /\
    exists g:set, continuous_map Y Ty X Tx g /\
      (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
      (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y).

(** helper: homeomorphism implies both are topological spaces **)
Theorem homeomorphism_topology_left : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f -> topology_on X Tx.
let X Tx Y Ty f.
assume Hhom: homeomorphism X Tx Y Ty f.
claim Hcont: continuous_map X Tx Y Ty f.
{ exact (andEL (continuous_map X Tx Y Ty f)
               (exists g:set, continuous_map Y Ty X Tx g /\
                 (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
                 (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y))
               Hhom). }
claim Habc: (topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y.
{ exact (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               Hcont). }
claim Hab: topology_on X Tx /\ topology_on Y Ty.
{ exact (andEL (topology_on X Tx /\ topology_on Y Ty)
               (function_on f X Y)
               Habc). }
exact (andEL (topology_on X Tx) (topology_on Y Ty) Hab).
Qed.

Theorem homeomorphism_topology_right : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f -> topology_on Y Ty.
let X Tx Y Ty f.
assume Hhom: homeomorphism X Tx Y Ty f.
claim Hcont: continuous_map X Tx Y Ty f.
{ exact (andEL (continuous_map X Tx Y Ty f)
               (exists g:set, continuous_map Y Ty X Tx g /\
                 (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
                 (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y))
               Hhom). }
claim Habc: (topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y.
{ exact (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               Hcont). }
claim Hab: topology_on X Tx /\ topology_on Y Ty.
{ exact (andEL (topology_on X Tx /\ topology_on Y Ty)
               (function_on f X Y)
               Habc). }
exact (andER (topology_on X Tx) (topology_on Y Ty) Hab).
Qed.

(** helper: homeomorphisms are injective **)
(** LATEX VERSION: A homeomorphism is injective (as it has a two-sided inverse). **)
Theorem homeomorphism_injective : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f ->
  forall x1 x2:set, x1 :e X -> x2 :e X -> apply_fun f x1 = apply_fun f x2 -> x1 = x2.
let X Tx Y Ty f.
assume Hhom: homeomorphism X Tx Y Ty f.
let x1 x2.
assume Hx1X: x1 :e X.
assume Hx2X: x2 :e X.
assume Heq: apply_fun f x1 = apply_fun f x2.
prove x1 = x2.
claim Hexg:
  exists g:set, continuous_map Y Ty X Tx g /\
    (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
    (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y).
{ exact (andER (continuous_map X Tx Y Ty f)
               (exists g:set, continuous_map Y Ty X Tx g /\
                 (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
                 (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y))
               Hhom). }
apply Hexg.
let g. assume Hgprop.
claim Hginv: forall x:set, x :e X -> apply_fun g (apply_fun f x) = x.
{ exact (andER (continuous_map Y Ty X Tx g)
               (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x)
               (andEL (continuous_map Y Ty X Tx g /\
                      (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x))
                     (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y)
                     Hgprop)). }
rewrite <- (Hginv x1 Hx1X).
rewrite <- (Hginv x2 Hx2X).
rewrite Heq.
reflexivity.
Qed.

(** from 18: continuous maps on subspaces **) 
(** LATEX VERSION: Restricting a continuous map to a subspace remains continuous. **)
Theorem continuous_on_subspace : forall X Tx Y Ty f A:set,
  topology_on X Tx -> A c= X ->
  continuous_map X Tx Y Ty f ->
  continuous_map A (subspace_topology X Tx A) Y Ty f.
let X Tx Y Ty f A.
assume HTx: topology_on X Tx.
assume HA: A c= X.
assume Hf: continuous_map X Tx Y Ty f.
prove continuous_map A (subspace_topology X Tx A) Y Ty f.
(** Strategy: f continuous on X means f(V) open in X for each V open in Y.
    For subspace topology on A, we need f(V) to be open in subspace_topology,
    which means f(V)  A should be of the form U  A for some U open in X.
    Since f(V) is already open in X, we can take U = f(V). **)
(** Extract components from Hf - but we already have HTx as a hypothesis, so we mainly need the others **)
(** Hf: topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y /\ (forall V...) **)
claim HTy: topology_on Y Ty.
{ exact (andER (topology_on X Tx) (topology_on Y Ty)
          (andEL (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y)
            (andEL (topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y)
                   (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
                   Hf))). }
claim Hfun: function_on f X Y.
{ exact (andER (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y)
          (andEL (topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y)
                 (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
                 Hf)). }
claim Hf_preimg: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
{ exact (andER (topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               Hf). }
(** Build continuous_map A (subspace_topology X Tx A) Y Ty f **)
claim HTsubspace: topology_on A (subspace_topology X Tx A).
{ exact (subspace_topology_is_topology X Tx A HTx HA). }
claim Hfun_A: function_on f A Y.
{ prove forall x:set, x :e A -> apply_fun f x :e Y.
  let x. assume HxA: x :e A.
  claim HxX: x :e X.
  { exact (HA x HxA). }
  exact (Hfun x HxX). }
(** Show preimages are open in subspace topology **)
claim Hpreimg_subspace: forall V:set, V :e Ty -> preimage_of A f V :e subspace_topology X Tx A.
{ let V. assume HV: V :e Ty.
  prove preimage_of A f V :e subspace_topology X Tx A.
  (** preimage_of A f V = {x :e A | apply_fun f x :e V} = preimage_of X f V  A **)
  set U := preimage_of X f V.
  claim HU_open: U :e Tx.
  { exact (Hf_preimg V HV). }
  (** Show preimage_of A f V = U  A **)
  claim Hpreimg_eq: preimage_of A f V = U :/\: A.
  { apply set_ext.
    - let x. assume Hx: x :e preimage_of A f V.
      prove x :e U :/\: A.
      claim HxA: x :e A.
      { exact (SepE1 A (fun y => apply_fun f y :e V) x Hx). }
      claim Hfx_V: apply_fun f x :e V.
      { exact (SepE2 A (fun y => apply_fun f y :e V) x Hx). }
      claim HxX: x :e X.
      { exact (HA x HxA). }
      claim HxU: x :e U.
      { exact (SepI X (fun y => apply_fun f y :e V) x HxX Hfx_V). }
      exact (binintersectI U A x HxU HxA).
    - let x. assume Hx: x :e U :/\: A.
      prove x :e preimage_of A f V.
      claim HxU: x :e U.
      { exact (binintersectE1 U A x Hx). }
      claim HxA: x :e A.
      { exact (binintersectE2 U A x Hx). }
      claim Hfx_V: apply_fun f x :e V.
      { exact (SepE2 X (fun y => apply_fun f y :e V) x HxU). }
      exact (SepI A (fun y => apply_fun f y :e V) x HxA Hfx_V). }
  (** Now show preimage_of A f V is in subspace_topology **)
  prove preimage_of A f V :e {W :e Power A | exists Z :e Tx, W = Z :/\: A}.
  claim HpAV_PowerA: preimage_of A f V :e Power A.
  { apply PowerI.
    let x. assume Hx: x :e preimage_of A f V.
    exact (SepE1 A (fun y => apply_fun f y :e V) x Hx). }
  claim Hexists: exists Z :e Tx, preimage_of A f V = Z :/\: A.
  { witness U.
    apply andI.
    - exact HU_open.
    - exact Hpreimg_eq. }
  exact (SepI (Power A) (fun W => exists Z :e Tx, W = Z :/\: A) (preimage_of A f V) HpAV_PowerA Hexists). }
(** Build the full conjunction for continuous_map **)
(** Need: topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty /\ function_on f A Y /\ (forall V:set, V :e Ty -> preimage_of A f V :e subspace_topology X Tx A)
    This is left-associative: (((A /\ B) /\ C) /\ D) **)
claim Hpart1: topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty.
{ apply andI.
  - exact HTsubspace.
  - exact HTy. }
claim Hpart2: (topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty) /\ function_on f A Y.
{ apply andI.
  - exact Hpart1.
  - exact Hfun_A. }
prove (topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty /\ function_on f A Y) /\
      (forall V:set, V :e Ty -> preimage_of A f V :e subspace_topology X Tx A).
apply andI.
- exact Hpart2.
- exact Hpreimg_subspace.
Qed.

(** from 18: inverse of homeomorphism is continuous **)
(** LATEX VERSION: The inverse of a homeomorphism is continuous. **)
Theorem homeomorphism_inverse_continuous : forall X Tx Y Ty f:set,
  homeomorphism X Tx Y Ty f ->
  exists g:set, continuous_map Y Ty X Tx g /\
    (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
    (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y).
let X Tx Y Ty f.
assume Hhom: homeomorphism X Tx Y Ty f.
prove exists g:set, continuous_map Y Ty X Tx g /\
  (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
  (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y).
(** By definition of homeomorphism, the continuous inverse g exists. **)
exact (andER (continuous_map X Tx Y Ty f)
             (exists g:set, continuous_map Y Ty X Tx g /\
                (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
                (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y))
             Hhom).
Qed.

(** Helper: function union properties **)
Axiom function_union_on_disjoint : forall A B Y f g:set,
  A :/\: B = Empty ->
  function_on f A Y -> function_on g B Y ->
  function_on (f :\/: g) (A :\/: B) Y.

(** Helper: total_function_on union properties **)
(** Uses `function_union_on_disjoint` for the function_on part, and proves totality directly by cases on xAB. **)
Theorem total_function_union_on_disjoint : forall A B Y f g:set,
  A :/\: B = Empty ->
  total_function_on f A Y -> total_function_on g B Y ->
  total_function_on (f :\/: g) (A :\/: B) Y.
let A B Y f g.
assume Hdisj: A :/\: B = Empty.
assume Hf: total_function_on f A Y.
assume Hg: total_function_on g B Y.
prove function_on (f :\/: g) (A :\/: B) Y /\
  forall x:set, x :e (A :\/: B) -> exists y:set, y :e Y /\ (x,y) :e (f :\/: g).
apply andI.
- (** function_on part **)
  claim Hf_on: function_on f A Y.
  { exact (total_function_on_function_on f A Y Hf). }
  claim Hg_on: function_on g B Y.
  { exact (total_function_on_function_on g B Y Hg). }
  exact (function_union_on_disjoint A B Y f g Hdisj Hf_on Hg_on).
- (** totality part **)
  let x. assume Hx: x :e (A :\/: B).
  prove exists y:set, y :e Y /\ (x,y) :e (f :\/: g).
  apply (binunionE A B x Hx).
  + assume HxA: x :e A.
    apply (total_function_on_totality f A Y Hf x HxA).
    let y. assume Hy: y :e Y /\ (x,y) :e f.
    witness y.
    apply andI.
    * exact (andEL (y :e Y) ((x,y) :e f) Hy).
    * exact (binunionI1 f g (x,y) (andER (y :e Y) ((x,y) :e f) Hy)).
  + assume HxB: x :e B.
    apply (total_function_on_totality g B Y Hg x HxB).
    let y. assume Hy: y :e Y /\ (x,y) :e g.
    witness y.
    apply andI.
    * exact (andEL (y :e Y) ((x,y) :e g) Hy).
    * exact (binunionI2 f g (x,y) (andER (y :e Y) ((x,y) :e g) Hy)).
Qed.

Axiom preimage_of_union_functions : forall A B f g V:set,
  A :/\: B = Empty ->
  preimage_of (A :\/: B) (f :\/: g) V =
    (preimage_of A f V) :\/: (preimage_of B g V).

(** Helper: unions of open subsets of disjoint open subspaces are open in the union subspace **)
Theorem subspace_union_of_opens : forall X Tx A B U V:set,
  topology_on X Tx -> A :e Tx -> B :e Tx -> A :/\: B = Empty ->
  U :e subspace_topology X Tx A ->
  V :e subspace_topology X Tx B ->
  (U :\/: V) :e subspace_topology X Tx (A :\/: B).
let X Tx A B U V.
assume HTx: topology_on X Tx.
assume HA: A :e Tx.
assume HB: B :e Tx.
assume Hdisj: A :/\: B = Empty.
assume HU: U :e subspace_topology X Tx A.
assume HV: V :e subspace_topology X Tx B.
prove (U :\/: V) :e subspace_topology X Tx (A :\/: B).
(** Unpack U open in subspace A **)
claim HUpowA: U :e Power A.
{ exact (SepE1 (Power A) (fun U0:set => exists W :e Tx, U0 = W :/\: A) U HU). }
claim HUsubA: U c= A.
{ exact (PowerE A U HUpowA). }
claim HexWU: exists W :e Tx, U = W :/\: A.
{ exact (SepE2 (Power A) (fun U0:set => exists W :e Tx, U0 = W :/\: A) U HU). }
apply HexWU.
let WU. assume HWUpair.
claim HWUinTx: WU :e Tx.
{ exact (andEL (WU :e Tx) (U = WU :/\: A) HWUpair). }
claim HUeq: U = WU :/\: A.
{ exact (andER (WU :e Tx) (U = WU :/\: A) HWUpair). }
claim HUAinTx: WU :/\: A :e Tx.
{ exact (topology_binintersect_closed X Tx WU A HTx HWUinTx HA). }
claim HUinTx: U :e Tx.
{ rewrite HUeq. exact HUAinTx. }

(** Unpack V open in subspace B **)
claim HVpowB: V :e Power B.
{ exact (SepE1 (Power B) (fun V0:set => exists W :e Tx, V0 = W :/\: B) V HV). }
claim HVsubB: V c= B.
{ exact (PowerE B V HVpowB). }
claim HexWV: exists W :e Tx, V = W :/\: B.
{ exact (SepE2 (Power B) (fun V0:set => exists W :e Tx, V0 = W :/\: B) V HV). }
apply HexWV.
let WV. assume HWVpair.
claim HWVinTx: WV :e Tx.
{ exact (andEL (WV :e Tx) (V = WV :/\: B) HWVpair). }
claim HVeql: V = WV :/\: B.
{ exact (andER (WV :e Tx) (V = WV :/\: B) HWVpair). }
claim HVBinTx: WV :/\: B :e Tx.
{ exact (topology_binintersect_closed X Tx WV B HTx HWVinTx HB). }
claim HVinTx: V :e Tx.
{ rewrite HVeql. exact HVBinTx. }

(** Hence UV is open in X, and it lies in AB **)
claim HUVinTx: (U :\/: V) :e Tx.
{ exact (topology_binunion_closed X Tx U V HTx HUinTx HVinTx). }
claim HAsubAB: A c= A :\/: B.
{ exact (binunion_Subq_1 A B). }
claim HBsubAB: B c= A :\/: B.
{ exact (binunion_Subq_2 A B). }
claim HUsubAB: U c= A :\/: B.
{ let x. assume Hx: x :e U.
  prove x :e A :\/: B.
  exact (HAsubAB x (HUsubA x Hx)). }
claim HVsubAB: V c= A :\/: B.
{ let x. assume Hx: x :e V.
  prove x :e A :\/: B.
  exact (HBsubAB x (HVsubB x Hx)). }
claim HUVsubAB: (U :\/: V) c= A :\/: B.
{ exact (binunion_Subq_min U V (A :\/: B) HUsubAB HVsubAB). }
claim HUVpowAB: (U :\/: V) :e Power (A :\/: B).
{ exact (PowerI (A :\/: B) (U :\/: V) HUVsubAB). }

(** Apply subspace_topology definition on AB, using witness W = UV **)
claim HPred: exists W :e Tx, (U :\/: V) = W :/\: (A :\/: B).
{ witness (U :\/: V).
  apply andI.
  + exact HUVinTx.
  + prove (U :\/: V) = (U :\/: V) :/\: (A :\/: B).
    claim Heq: (U :\/: V) :/\: (A :\/: B) = (U :\/: V).
    { exact (binintersect_Subq_eq_1 (U :\/: V) (A :\/: B) HUVsubAB). }
    rewrite Heq.
    reflexivity. }
exact (SepI (Power (A :\/: B))
            (fun U0:set => exists W :e Tx, U0 = W :/\: (A :\/: B))
            (U :\/: V) HUVpowAB HPred).
Qed.

(** from 18 Theorem 18.3: pasting lemma **)
(** LATEX VERSION: Pasting lemma: continuous pieces on closed (or appropriate) sets assemble to a continuous map. **)
Theorem pasting_lemma : forall X A B Y Tx Ty f g:set,
  topology_on X Tx ->
  A :e Tx -> B :e Tx -> A :/\: B = Empty ->
  continuous_map A (subspace_topology X Tx A) Y Ty f ->
  continuous_map B (subspace_topology X Tx B) Y Ty g ->
  continuous_map (A :\/: B) (subspace_topology X Tx (A :\/: B)) Y Ty (f :\/: g).
let X A B Y Tx Ty f g.
assume HTx: topology_on X Tx.
assume HA: A :e Tx.
assume HB: B :e Tx.
assume Hdisj: A :/\: B = Empty.
assume Hf: continuous_map A (subspace_topology X Tx A) Y Ty f.
assume Hg: continuous_map B (subspace_topology X Tx B) Y Ty g.
prove continuous_map (A :\/: B) (subspace_topology X Tx (A :\/: B)) Y Ty (f :\/: g).
(** Extract components from Hf **)
claim HTy: topology_on Y Ty.
{ exact (andER (topology_on A (subspace_topology X Tx A)) (topology_on Y Ty)
          (andEL (topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty) (function_on f A Y)
            (andEL (topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty /\ function_on f A Y)
                   (forall V:set, V :e Ty -> preimage_of A f V :e subspace_topology X Tx A)
                   Hf))). }
claim Hfun_f: function_on f A Y.
{ exact (andER (topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty) (function_on f A Y)
          (andEL (topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty /\ function_on f A Y)
                 (forall V:set, V :e Ty -> preimage_of A f V :e subspace_topology X Tx A)
                 Hf)). }
claim Hpreimg_f: forall V:set, V :e Ty -> preimage_of A f V :e subspace_topology X Tx A.
{ exact (andER (topology_on A (subspace_topology X Tx A) /\ topology_on Y Ty /\ function_on f A Y)
               (forall V:set, V :e Ty -> preimage_of A f V :e subspace_topology X Tx A)
               Hf). }
(** Extract components from Hg **)
claim Hfun_g: function_on g B Y.
{ exact (andER (topology_on B (subspace_topology X Tx B) /\ topology_on Y Ty) (function_on g B Y)
          (andEL (topology_on B (subspace_topology X Tx B) /\ topology_on Y Ty /\ function_on g B Y)
                 (forall V:set, V :e Ty -> preimage_of B g V :e subspace_topology X Tx B)
                 Hg)). }
claim Hpreimg_g: forall V:set, V :e Ty -> preimage_of B g V :e subspace_topology X Tx B.
{ exact (andER (topology_on B (subspace_topology X Tx B) /\ topology_on Y Ty /\ function_on g B Y)
               (forall V:set, V :e Ty -> preimage_of B g V :e subspace_topology X Tx B)
               Hg). }
(** Build continuous_map for (f :\/: g) **)
claim HAB_sub: A :\/: B c= X.
{ apply binunion_Subq_min.
  - exact (topology_elem_subset X Tx A HTx HA).
  - exact (topology_elem_subset X Tx B HTx HB). }
claim HTsub: topology_on (A :\/: B) (subspace_topology X Tx (A :\/: B)).
{ exact (subspace_topology_is_topology X Tx (A :\/: B) HTx HAB_sub). }
claim Hfun_fg: function_on (f :\/: g) (A :\/: B) Y.
{ exact (function_union_on_disjoint A B Y f g Hdisj Hfun_f Hfun_g). }
claim Hpreimg_fg: forall V:set, V :e Ty -> preimage_of (A :\/: B) (f :\/: g) V :e subspace_topology X Tx (A :\/: B).
{ let V. assume HV: V :e Ty.
  (** Use preimage decomposition axiom **)
  claim Heq: preimage_of (A :\/: B) (f :\/: g) V = (preimage_of A f V) :\/: (preimage_of B g V).
  { exact (preimage_of_union_functions A B f g V Hdisj). }
  (** Both preimages are in their respective subspace topologies **)
  claim HfV: preimage_of A f V :e subspace_topology X Tx A.
  { exact (Hpreimg_f V HV). }
  claim HgV: preimage_of B g V :e subspace_topology X Tx B.
  { exact (Hpreimg_g V HV). }
  (** Since A and B are open in X, subspace opens are just intersections **)
  (** Apply axiom: union of subspace opens is in subspace topology of union **)
  claim Hunion: (preimage_of A f V :\/: preimage_of B g V) :e subspace_topology X Tx (A :\/: B).
  { exact (subspace_union_of_opens X Tx A B (preimage_of A f V) (preimage_of B g V) HTx HA HB Hdisj HfV HgV). }
  (** Rewrite using Heq to get the desired form **)
  prove preimage_of (A :\/: B) (f :\/: g) V :e subspace_topology X Tx (A :\/: B).
  rewrite Heq.
  exact Hunion.
}
(** Assemble the proof **)
prove topology_on (A :\/: B) (subspace_topology X Tx (A :\/: B)) /\
      topology_on Y Ty /\ function_on (f :\/: g) (A :\/: B) Y /\
      (forall V:set, V :e Ty -> preimage_of (A :\/: B) (f :\/: g) V :e subspace_topology X Tx (A :\/: B)).
apply andI.
- apply andI.
  + apply andI.
    * exact HTsub.
    * exact HTy.
  + exact Hfun_fg.
- exact Hpreimg_fg.
Qed.

(** from 18 Theorem 18.4: maps into products **) 
(** LATEX VERSION: A map into a product is continuous iff its coordinate functions are continuous. **)
Definition pair_map : set -> set -> set -> set := fun A f g =>
  {(a, (apply_fun f a, apply_fun g a)) | a :e A}.

(** Helper: apply_fun for pair_map **)
Theorem pair_map_apply : forall A X Y f g a:set,
  a :e A ->
  apply_fun (pair_map A f g) a = (apply_fun f a, apply_fun g a).
let A X Y f g a.
assume Ha: a :e A.
prove apply_fun (pair_map A f g) a = (apply_fun f a, apply_fun g a).
prove Eps_i (fun z => (a,z) :e pair_map A f g) = (apply_fun f a, apply_fun g a).
claim H1: (a, (apply_fun f a, apply_fun g a)) :e pair_map A f g.
{ exact (ReplI A (fun a0:set => (a0, (apply_fun f a0, apply_fun g a0))) a Ha). }
claim H2: (a, Eps_i (fun z => (a,z) :e pair_map A f g)) :e pair_map A f g.
{ exact (Eps_i_ax (fun z => (a,z) :e pair_map A f g) (apply_fun f a, apply_fun g a) H1). }
apply (ReplE_impred A (fun a0:set => (a0, (apply_fun f a0, apply_fun g a0)))
                     (a, Eps_i (fun z => (a,z) :e pair_map A f g)) H2).
let a0.
assume Ha0: a0 :e A.
assume Heq: (a, Eps_i (fun z => (a,z) :e pair_map A f g)) = (a0, (apply_fun f a0, apply_fun g a0)).
claim Ha_eq: a = a0.
{ rewrite <- (tuple_2_0_eq a (Eps_i (fun z => (a,z) :e pair_map A f g))).
  rewrite <- (tuple_2_0_eq a0 (apply_fun f a0, apply_fun g a0)).
  rewrite Heq.
  reflexivity. }
claim Hz_eq: Eps_i (fun z => (a,z) :e pair_map A f g) = (apply_fun f a0, apply_fun g a0).
{ rewrite <- (tuple_2_1_eq a (Eps_i (fun z => (a,z) :e pair_map A f g))) at 1.
  rewrite <- (tuple_2_1_eq a0 (apply_fun f a0, apply_fun g a0)) at 1.
  rewrite Heq.
  reflexivity. }
rewrite Hz_eq.
rewrite Ha_eq.
reflexivity.
Qed.

Theorem preimage_pair_map_rectangle : forall A X Y f g U V:set,
  preimage_of A (pair_map A f g) (rectangle_set U V) =
    (preimage_of A f U) :/\: (preimage_of A g V).
let A X Y f g U V.
apply set_ext.
- let a. assume Ha: a :e preimage_of A (pair_map A f g) (rectangle_set U V).
  prove a :e (preimage_of A f U) :/\: (preimage_of A g V).
  claim HaA: a :e A.
  { exact (SepE1 A (fun a0:set => apply_fun (pair_map A f g) a0 :e rectangle_set U V) a Ha). }
  claim Himg: apply_fun (pair_map A f g) a :e rectangle_set U V.
  { exact (SepE2 A (fun a0:set => apply_fun (pair_map A f g) a0 :e rectangle_set U V) a Ha). }
  claim Happ: apply_fun (pair_map A f g) a = (apply_fun f a, apply_fun g a).
  { exact (pair_map_apply A X Y f g a HaA). }
  claim HpairIn: (apply_fun f a, apply_fun g a) :e rectangle_set U V.
  { rewrite <- Happ.
    exact Himg. }
  claim Hfst: (apply_fun f a, apply_fun g a) 0 :e U.
  { exact (ap0_Sigma U (fun _ : set => V) (apply_fun f a, apply_fun g a) HpairIn). }
  claim Hsnd: (apply_fun f a, apply_fun g a) 1 :e V.
  { exact (ap1_Sigma U (fun _ : set => V) (apply_fun f a, apply_fun g a) HpairIn). }
  claim HfaU: apply_fun f a :e U.
  { rewrite <- (tuple_2_0_eq (apply_fun f a) (apply_fun g a)).
    exact Hfst. }
  claim HgaV: apply_fun g a :e V.
  { rewrite <- (tuple_2_1_eq (apply_fun f a) (apply_fun g a)).
    exact Hsnd. }
  apply binintersectI.
  + exact (SepI A (fun a0:set => apply_fun f a0 :e U) a HaA HfaU).
  + exact (SepI A (fun a0:set => apply_fun g a0 :e V) a HaA HgaV).
- let a. assume Ha: a :e (preimage_of A f U) :/\: (preimage_of A g V).
  prove a :e preimage_of A (pair_map A f g) (rectangle_set U V).
  claim Haf: a :e preimage_of A f U.
  { exact (binintersectE1 (preimage_of A f U) (preimage_of A g V) a Ha). }
  claim Hag: a :e preimage_of A g V.
  { exact (binintersectE2 (preimage_of A f U) (preimage_of A g V) a Ha). }
  claim HaA: a :e A.
  { exact (SepE1 A (fun a0:set => apply_fun f a0 :e U) a Haf). }
  claim HfaU: apply_fun f a :e U.
  { exact (SepE2 A (fun a0:set => apply_fun f a0 :e U) a Haf). }
  claim HgaV: apply_fun g a :e V.
  { exact (SepE2 A (fun a0:set => apply_fun g a0 :e V) a Hag). }
  claim HpairIn: (apply_fun f a, apply_fun g a) :e rectangle_set U V.
  { exact (tuple_2_setprod U V (apply_fun f a) HfaU (apply_fun g a) HgaV). }
  claim Happ: apply_fun (pair_map A f g) a = (apply_fun f a, apply_fun g a).
  { exact (pair_map_apply A X Y f g a HaA). }
  claim Himg: apply_fun (pair_map A f g) a :e rectangle_set U V.
  { rewrite Happ.
    exact HpairIn. }
  exact (SepI A (fun a0:set => apply_fun (pair_map A f g) a0 :e rectangle_set U V) a HaA Himg).
Qed.

Theorem maps_into_products_axiom : forall A Ta X Tx Y Ty f g:set,
  continuous_map A Ta X Tx f ->
  continuous_map A Ta Y Ty g ->
  continuous_map A Ta (setprod X Y) (product_topology X Tx Y Ty) (pair_map A f g).
let A Ta X Tx Y Ty f g.
assume Hf: continuous_map A Ta X Tx f.
assume Hg: continuous_map A Ta Y Ty g.
claim Hf_mid: (topology_on A Ta /\ topology_on X Tx) /\ function_on f A X.
{ exact (andEL ((topology_on A Ta /\ topology_on X Tx) /\ function_on f A X)
               (forall V:set, V :e Tx -> preimage_of A f V :e Ta)
               Hf). }
claim Hfun_f: function_on f A X.
{ exact (andER (topology_on A Ta /\ topology_on X Tx) (function_on f A X) Hf_mid). }
claim HtopAX: topology_on A Ta /\ topology_on X Tx.
{ exact (andEL (topology_on A Ta /\ topology_on X Tx) (function_on f A X) Hf_mid). }
claim HTa: topology_on A Ta.
{ exact (andEL (topology_on A Ta) (topology_on X Tx) HtopAX). }
claim HTx: topology_on X Tx.
{ exact (andER (topology_on A Ta) (topology_on X Tx) HtopAX). }
claim Hf_pre: forall U:set, U :e Tx -> preimage_of A f U :e Ta.
{ exact (andER ((topology_on A Ta /\ topology_on X Tx) /\ function_on f A X)
               (forall V:set, V :e Tx -> preimage_of A f V :e Ta)
               Hf). }

claim Hg_mid: (topology_on A Ta /\ topology_on Y Ty) /\ function_on g A Y.
{ exact (andEL ((topology_on A Ta /\ topology_on Y Ty) /\ function_on g A Y)
               (forall V:set, V :e Ty -> preimage_of A g V :e Ta)
               Hg). }
claim Hfun_g: function_on g A Y.
{ exact (andER (topology_on A Ta /\ topology_on Y Ty) (function_on g A Y) Hg_mid). }
claim HtopAY: topology_on A Ta /\ topology_on Y Ty.
{ exact (andEL (topology_on A Ta /\ topology_on Y Ty) (function_on g A Y) Hg_mid). }
claim HTy: topology_on Y Ty.
{ exact (andER (topology_on A Ta) (topology_on Y Ty) HtopAY). }
claim Hg_pre: forall V:set, V :e Ty -> preimage_of A g V :e Ta.
{ exact (andER ((topology_on A Ta /\ topology_on Y Ty) /\ function_on g A Y)
               (forall V:set, V :e Ty -> preimage_of A g V :e Ta)
               Hg). }

claim HTprod: topology_on (setprod X Y) (product_topology X Tx Y Ty).
{ exact (product_topology_is_topology X Tx Y Ty HTx HTy). }
claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
{ exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }

prove continuous_map A Ta (setprod X Y) (product_topology X Tx Y Ty) (pair_map A f g).
prove topology_on A Ta /\ topology_on (setprod X Y) (product_topology X Tx Y Ty) /\
  function_on (pair_map A f g) A (setprod X Y) /\
  forall W:set, W :e product_topology X Tx Y Ty -> preimage_of A (pair_map A f g) W :e Ta.
apply andI.
- apply andI.
  + apply andI.
    * exact HTa.
    * exact HTprod.
  + (** function_on **)
    let a. assume HaA: a :e A.
    prove apply_fun (pair_map A f g) a :e setprod X Y.
    claim Happ: apply_fun (pair_map A f g) a = (apply_fun f a, apply_fun g a).
    { exact (pair_map_apply A X Y f g a HaA). }
    rewrite Happ.
    exact (tuple_2_setprod X Y (apply_fun f a) (Hfun_f a HaA) (apply_fun g a) (Hfun_g a HaA)).
- let W. assume HW: W :e product_topology X Tx Y Ty.
  prove preimage_of A (pair_map A f g) W :e Ta.
  claim HWopen: open_in (setprod X Y) (product_topology X Tx Y Ty) W.
  { exact (andI (topology_on (setprod X Y) (product_topology X Tx Y Ty)) (W :e product_topology X Tx Y Ty) HTprod HW). }
  apply (open_sets_as_unions_of_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis W HWopen).
  let Fam. assume HFamPair.
  claim HFamPow: Fam :e Power (product_subbasis X Tx Y Ty).
  { exact (andEL (Fam :e Power (product_subbasis X Tx Y Ty)) (Union Fam = W) HFamPair). }
  claim HUnionEq: Union Fam = W.
  { exact (andER (Fam :e Power (product_subbasis X Tx Y Ty)) (Union Fam = W) HFamPair). }
  claim HFamSub: Fam c= product_subbasis X Tx Y Ty.
  { exact (PowerE (product_subbasis X Tx Y Ty) Fam HFamPow). }
  set PreFam := {preimage_of A (pair_map A f g) b|b :e Fam}.
  claim HpreEq1: preimage_of A (pair_map A f g) W = preimage_of A (pair_map A f g) (Union Fam).
  { rewrite <- HUnionEq.
    reflexivity. }
  claim HpreEq2: preimage_of A (pair_map A f g) (Union Fam) = Union PreFam.
  { rewrite (preimage_of_Union A (pair_map A f g) Fam).
    reflexivity. }
  rewrite HpreEq1.
  rewrite HpreEq2.
  claim HPreFamSub: PreFam c= Ta.
  { let P. assume HP: P :e PreFam.
    apply (ReplE_impred Fam (fun b:set => preimage_of A (pair_map A f g) b) P HP).
    let b. assume HbFam: b :e Fam.
    assume HPeq: P = preimage_of A (pair_map A f g) b.
    claim HbSub: b :e product_subbasis X Tx Y Ty.
    { exact (HFamSub b HbFam). }
    claim HexU: exists U :e Tx, b :e {rectangle_set U V|V :e Ty}.
    { exact (famunionE Tx (fun U0:set => {rectangle_set U0 V|V :e Ty}) b HbSub). }
    apply HexU.
    let U. assume HUconj: U :e Tx /\ b :e {rectangle_set U V|V :e Ty}.
    claim HU: U :e Tx.
    { exact (andEL (U :e Tx) (b :e {rectangle_set U V|V :e Ty}) HUconj). }
    claim HbRepl: b :e {rectangle_set U V|V :e Ty}.
    { exact (andER (U :e Tx) (b :e {rectangle_set U V|V :e Ty}) HUconj). }
    claim HexV: exists V :e Ty, b = rectangle_set U V.
    { exact (ReplE Ty (fun V0:set => rectangle_set U V0) b HbRepl). }
    apply HexV.
    let V. assume HVconj: V :e Ty /\ b = rectangle_set U V.
    claim HV: V :e Ty.
    { exact (andEL (V :e Ty) (b = rectangle_set U V) HVconj). }
    claim Hbeq: b = rectangle_set U V.
    { exact (andER (V :e Ty) (b = rectangle_set U V) HVconj). }
    claim HpreRect: preimage_of A (pair_map A f g) b =
      (preimage_of A f U) :/\: (preimage_of A g V).
    { rewrite Hbeq.
      exact (preimage_pair_map_rectangle A X Y f g U V). }
    rewrite HPeq.
    rewrite HpreRect.
    exact (topology_binintersect_closed A Ta (preimage_of A f U) (preimage_of A g V) HTa (Hf_pre U HU) (Hg_pre V HV)). }
  claim HPreFamPow: PreFam :e Power Ta.
  { apply PowerI.
    exact HPreFamSub. }
  exact (topology_union_axiom A Ta HTa PreFam HPreFamPow).
Qed.

Theorem maps_into_products : forall A Ta X Tx Y Ty f g:set,
  continuous_map A Ta X Tx f ->
  continuous_map A Ta Y Ty g ->
  continuous_map A Ta (setprod X Y) (product_topology X Tx Y Ty) (pair_map A f g).
let A Ta X Tx Y Ty f g.
assume Hf: continuous_map A Ta X Tx f.
assume Hg: continuous_map A Ta Y Ty g.
prove continuous_map A Ta (setprod X Y) (product_topology X Tx Y Ty) (pair_map A f g).
exact (maps_into_products_axiom A Ta X Tx Y Ty f g Hf Hg).
Qed.

(** from 19 Definition: product projections and universal property **) 
(** LATEX VERSION: Projection maps from a product space; universal property characterizes the product topology. **)
Definition projection_map1 : set -> set -> set := fun X Y => projection1 X Y.
Definition projection_map2 : set -> set -> set := fun X Y => projection2 X Y.

(** Helper: projection maps are continuous **)
Theorem projection_maps_continuous : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y) /\
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y).
let X Tx Y Ty.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y) /\
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y).
apply andI.
- (** projection_map1 **)
  prove continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y).
  prove topology_on (setprod X Y) (product_topology X Tx Y Ty) /\ topology_on X Tx /\
    function_on (projection_map1 X Y) (setprod X Y) X /\
    forall V:set, V :e Tx -> preimage_of (setprod X Y) (projection_map1 X Y) V :e product_topology X Tx Y Ty.
  apply andI.
  - apply andI.
    + apply andI.
      * exact (product_topology_is_topology X Tx Y Ty HTx HTy).
      * exact HTx.
    + (** function_on **)
      let p. assume Hp: p :e setprod X Y.
      prove apply_fun (projection_map1 X Y) p :e X.
      claim Happ: apply_fun (projection_map1 X Y) p = p 0.
      { exact (projection1_apply X Y p Hp). }
      rewrite Happ.
      exact (ap0_Sigma X (fun _ : set => Y) p Hp).
  - let V. assume HV: V :e Tx.
    prove preimage_of (setprod X Y) (projection_map1 X Y) V :e product_topology X Tx Y Ty.
    claim HVsub: V c= X.
    { exact (topology_elem_subset X Tx V HTx HV). }
    claim HpreEq: preimage_of (setprod X Y) (projection_map1 X Y) V = rectangle_set V Y.
    { exact (preimage_projection1_rectangle X Y V HVsub). }
    rewrite HpreEq.
    claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
    { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
    claim HYTy: Y :e Ty.
    { exact (topology_has_X Y Ty HTy). }
    claim HRsub: rectangle_set V Y :e product_subbasis X Tx Y Ty.
    { claim HRfam: rectangle_set V Y :e {rectangle_set V V0|V0 :e Ty}.
      { exact (ReplI Ty (fun V0:set => rectangle_set V V0) Y HYTy). }
      exact (famunionI Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) V (rectangle_set V Y) HV HRfam). }
    exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis (rectangle_set V Y) HRsub).
- (** projection_map2 **)
  prove continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y).
  prove topology_on (setprod X Y) (product_topology X Tx Y Ty) /\ topology_on Y Ty /\
    function_on (projection_map2 X Y) (setprod X Y) Y /\
    forall V:set, V :e Ty -> preimage_of (setprod X Y) (projection_map2 X Y) V :e product_topology X Tx Y Ty.
  apply andI.
  - apply andI.
    + apply andI.
      * exact (product_topology_is_topology X Tx Y Ty HTx HTy).
      * exact HTy.
    + (** function_on **)
      let p. assume Hp: p :e setprod X Y.
      prove apply_fun (projection_map2 X Y) p :e Y.
      claim Happ: apply_fun (projection_map2 X Y) p = p 1.
      { exact (projection2_apply X Y p Hp). }
      rewrite Happ.
      exact (ap1_Sigma X (fun _ : set => Y) p Hp).
  - let V. assume HV: V :e Ty.
    prove preimage_of (setprod X Y) (projection_map2 X Y) V :e product_topology X Tx Y Ty.
    claim HVsub: V c= Y.
    { exact (topology_elem_subset Y Ty V HTy HV). }
    claim HpreEq: preimage_of (setprod X Y) (projection_map2 X Y) V = rectangle_set X V.
    { exact (preimage_projection2_rectangle X Y V HVsub). }
    rewrite HpreEq.
    claim HBasis: basis_on (setprod X Y) (product_subbasis X Tx Y Ty).
    { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
    claim HXTx: X :e Tx.
    { exact (topology_has_X X Tx HTx). }
    claim HRsub: rectangle_set X V :e product_subbasis X Tx Y Ty.
    { claim HRfam: rectangle_set X V :e {rectangle_set X V0|V0 :e Ty}.
      { exact (ReplI Ty (fun V0:set => rectangle_set X V0) V HV). }
      exact (famunionI Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) X (rectangle_set X V) HXTx HRfam). }
    exact (generated_topology_contains_basis (setprod X Y) (product_subbasis X Tx Y Ty) HBasis (rectangle_set X V) HRsub).
Qed.

(** Helper: universal property of products - maps into products **)
(** LATEX VERSION: Projections from a product are continuous. **)
Theorem projections_are_continuous : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y) /\
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y).
let X Tx Y Ty.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y) /\
  continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y).
exact (projection_maps_continuous X Tx Y Ty HTx HTy).
Qed.

(** from 19: product topology is coarsest making projections continuous **) 
(** LATEX VERSION: The product topology is the coarsest topology on XY making the projections continuous. **)
Theorem product_topology_universal : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  exists Tprod:set, topology_on (setprod X Y) Tprod /\
    continuous_map (setprod X Y) Tprod X Tx (projection_map1 X Y) /\
    continuous_map (setprod X Y) Tprod Y Ty (projection_map2 X Y).
let X Tx Y Ty.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove exists Tprod:set, topology_on (setprod X Y) Tprod /\
    continuous_map (setprod X Y) Tprod X Tx (projection_map1 X Y) /\
    continuous_map (setprod X Y) Tprod Y Ty (projection_map2 X Y).
(** Witness the product topology **)
witness (product_topology X Tx Y Ty).
(** Goal is: A /\ B /\ C which is left-associative: (A /\ B) /\ C **)
apply andI.
- (** First part: topology_on (setprod X Y) (product_topology X Tx Y Ty) /\
      continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y) **)
  apply andI.
  + (** product_topology is a topology **)
    exact (product_topology_is_topology X Tx Y Ty HTx HTy).
  + (** first projection is continuous **)
    exact (andEL (continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y))
                 (continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y))
                 (projections_are_continuous X Tx Y Ty HTx HTy)).
- (** second projection is continuous **)
  exact (andER (continuous_map (setprod X Y) (product_topology X Tx Y Ty) X Tx (projection_map1 X Y))
               (continuous_map (setprod X Y) (product_topology X Tx Y Ty) Y Ty (projection_map2 X Y))
               (projections_are_continuous X Tx Y Ty HTx HTy)).
Qed.

(** from 20 Definition: metric and metric topology **) 
(** LATEX VERSION: Definition of a metric d on X and the induced metric topology generated by open balls. **)
(** FIXED: Triangle inequality must use addition (add_SNo), not intersection (:/\:)!
    Was: d(x,z) < d(x,y)  d(y,z) - completely wrong!  is set intersection.
    Now: d(x,z)  d(x,y) + d(y,z) using add_SNo from line 4171.
    Also using  (negated >), not strict < for triangle inequality. **)
(** SUSPICIOUS DEFINITION: Triangle inequality is encoded by `~ Rlt (d(x,y)+d(y,z)) d(x,z)`;
    this relies on `Rlt` being a strict total order on `R` and on the intended equivalence between `~ Rlt` and `<=`. **)
Definition metric_on : set -> set -> prop := fun X d =>
  function_on d (setprod X X) R /\
  (forall x y:set, x :e X -> y :e X ->
     apply_fun d (x,y) = apply_fun d (y,x)) /\
  (forall x:set, x :e X -> apply_fun d (x,x) = 0) /\
  (forall x y:set, x :e X -> y :e X ->
     ~(Rlt (apply_fun d (x,y)) 0)
     /\ (apply_fun d (x,y) = 0 -> x = y)) /\
  (forall x y z:set, x :e X -> y :e X -> z :e X ->
     ~(Rlt (add_SNo (apply_fun d (x,y)) (apply_fun d (y,z)))
           (apply_fun d (x,z)))).

(** Helper: metric_on plus totality of the graph on XX **)
Definition metric_on_total : set -> set -> prop := fun X d =>
  metric_on X d /\ total_function_on d (setprod X X) R.

Theorem metric_on_total_imp_metric_on : forall X d:set,
  metric_on_total X d -> metric_on X d.
let X d. assume H.
exact (andEL (metric_on X d) (total_function_on d (setprod X X) R) H).
Qed.

Theorem metric_on_total_total_function : forall X d:set,
  metric_on_total X d -> total_function_on d (setprod X X) R.
let X d. assume H.
exact (andER (metric_on X d) (total_function_on d (setprod X X) R) H).
Qed.

(** helper: triangle inequality in Rle form **)
Theorem metric_triangle_Rle : forall X d x y z:set,
  metric_on X d -> x :e X -> y :e X -> z :e X ->
  Rle (apply_fun d (x,z)) (add_SNo (apply_fun d (x,y)) (apply_fun d (y,z))).
let X d x y z.
assume Hm: metric_on X d.
assume Hx: x :e X.
assume Hy: y :e X.
assume Hz: z :e X.
claim Hfun: function_on d (setprod X X) R.
{ apply Hm.
  assume Hcore Htri.
  apply Hcore.
  assume Hcore2 Hposdef.
  apply Hcore2.
  assume Hab Hrefl.
  apply Hab.
  assume Hf Hsym.
  exact Hf. }
claim Htri: forall x0 y0 z0:set, x0 :e X -> y0 :e X -> z0 :e X ->
  ~(Rlt (add_SNo (apply_fun d (x0,y0)) (apply_fun d (y0,z0))) (apply_fun d (x0,z0))).
{ apply Hm.
  assume Hcore Htri.
  exact Htri. }

claim HxyIn: (x,y) :e setprod X X.
{ exact (tuple_2_setprod X X x Hx y Hy). }
claim HyzIn: (y,z) :e setprod X X.
{ exact (tuple_2_setprod X X y Hy z Hz). }
claim HxzIn: (x,z) :e setprod X X.
{ exact (tuple_2_setprod X X x Hx z Hz). }

claim HdxyR: apply_fun d (x,y) :e R.
{ exact (Hfun (x,y) HxyIn). }
claim HdyzR: apply_fun d (y,z) :e R.
{ exact (Hfun (y,z) HyzIn). }
claim HdxzR: apply_fun d (x,z) :e R.
{ exact (Hfun (x,z) HxzIn). }
claim HsumR: add_SNo (apply_fun d (x,y)) (apply_fun d (y,z)) :e R.
{ exact (real_add_SNo (apply_fun d (x,y)) HdxyR (apply_fun d (y,z)) HdyzR). }
exact (RleI (apply_fun d (x,z)) (add_SNo (apply_fun d (x,y)) (apply_fun d (y,z))) HdxzR HsumR (Htri x y z Hx Hy Hz)).
Qed.

(** from 20 Definition: open ball **)
(** LATEX VERSION: Open ball centered at x with radius r in metric d. **)
(** FIXED: Previous definition was semantically wrong:
    Was: {y  X | r, d(x,y) < r} = X (always true for large enough r!)
    Now: Takes radius r as parameter: B_r(x) = {y  X | d(x,y) < r}
    Signature changed from (X,d,x) to (X,d,x,r). **)
Definition open_ball : set -> set -> set -> set -> set := fun X d x r =>
  {y :e X|Rlt (apply_fun d (x,y)) r}.

Definition metric_topology : set -> set -> set := fun X d =>
  generated_topology X (famunion X (fun x => {open_ball X d x r|r :e R, Rlt 0 r})).

(** from 20: open balls form a basis **)
(** LATEX VERSION: In a metric space, open balls form a basis for the metric topology. **)
Axiom open_balls_form_basis_axiom : forall X d:set,
  metric_on X d -> basis_on X (famunion X (fun x => {open_ball X d x r|r :e R, Rlt 0 r})).
Theorem open_balls_form_basis : forall X d:set,
  metric_on X d -> basis_on X (famunion X (fun x => {open_ball X d x r|r :e R, Rlt 0 r})).
let X d.
assume Hd: metric_on X d.
prove basis_on X (famunion X (fun x => {open_ball X d x r|r :e R, Rlt 0 r})).
exact (open_balls_form_basis_axiom X d Hd).
Qed.

Theorem metric_topology_is_topology : forall X d:set,
  metric_on X d -> topology_on X (metric_topology X d).
let X d.
assume Hd: metric_on X d.
prove topology_on X (metric_topology X d).
exact (lemma_topology_from_basis X
         (famunion X (fun x => {open_ball X d x r|r :e R, Rlt 0 r}))
         (open_balls_form_basis X d Hd)).
Qed.

(** from 20: metric-induced topology equals generated topology of balls **)
Theorem metric_topology_generated_by_balls : forall X d:set,
  metric_on X d ->
  generated_topology X (famunion X (fun x => {open_ball X d x r|r :e R, Rlt 0 r})) = metric_topology X d.
let X d.
assume Hd: metric_on X d.
prove generated_topology X (famunion X (fun x => {open_ball X d x r|r :e R, Rlt 0 r})) = metric_topology X d.
(** By definition, metric_topology X d = generated_topology X (famunion X (fun x => {open_ball X d x r|r :e R, Rlt 0 r})) **)
reflexivity.
Qed.

(** from 21: epsilon-delta continuity in metric spaces **) 
Axiom metric_epsilon_delta_continuity_axiom : forall X dX Y dY f:set,
  metric_on X dX -> metric_on Y dY ->
  (continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f <->
  (forall x0:set, x0 :e X ->
     forall eps:set, eps :e R /\ Rlt 0 eps ->
       exists delta:set, delta :e R /\ Rlt 0 delta /\
         (forall x:set, x :e X ->
            Rlt (apply_fun dX (x,x0)) delta ->
            Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps))).
Theorem metric_epsilon_delta_continuity : forall X dX Y dY f:set,
  metric_on X dX -> metric_on Y dY ->
  (continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f <->
  (forall x0:set, x0 :e X ->
     forall eps:set, eps :e R /\ Rlt 0 eps ->
       exists delta:set, delta :e R /\ Rlt 0 delta /\
         (forall x:set, x :e X ->
            Rlt (apply_fun dX (x,x0)) delta ->
            Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps))).
let X dX Y dY f.
assume HdX: metric_on X dX.
assume HdY: metric_on Y dY.
prove continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f <->
  (forall x0:set, x0 :e X ->
     forall eps:set, eps :e R /\ Rlt 0 eps ->
(** FIXED: Removed extra parentheses around pair argument to dY metric.
    Was: apply_fun dY ((apply_fun f x, apply_fun f x0))
    Now: apply_fun dY (apply_fun f x, apply_fun f x0) - consistent with dX usage **)
       exists delta:set, delta :e R /\ Rlt 0 delta /\
	         (forall x:set, x :e X ->
	            Rlt (apply_fun dX (x,x0)) delta ->
	            Rlt (apply_fun dY (apply_fun f x, apply_fun f x0)) eps)).
exact (metric_epsilon_delta_continuity_axiom X dX Y dY f HdX HdY).
Qed.

(** sequences as functions from omega **) 
Definition sequence_in : set -> set -> prop := fun seq A => function_on seq omega A.
Definition sequence_on : set -> set -> prop := fun seq A => function_on seq omega A.
Definition converges_to : set -> set -> set -> set -> prop :=
  fun X Tx seq x =>
    topology_on X Tx /\ sequence_on seq X /\ x :e X /\
    forall U:set, U :e Tx -> x :e U ->
      exists N:set, N :e omega /\
        forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U.
(** map a sequence seq by a function f, giving the composed sequence n  f(seq(n)) **)
Definition map_sequence : set -> set -> set := fun f seq => compose_fun omega seq f.

(** image of a set U under a function f **)
Definition image_of : set -> set -> set := fun f U => Repl U (fun x => apply_fun f x).
Definition function_sequence_value : set -> set -> set -> set :=
  fun f_seq n x => apply_fun (apply_fun f_seq n) x.

(** FIXED: Removed extra parentheses around pair argument to d metric. **)
Definition sequence_converges_metric : set -> set -> set -> set -> prop :=
  fun X d seq x =>
    metric_on X d /\ sequence_on seq X /\ x :e X /\
    forall eps:set, eps :e R /\ Rlt 0 eps ->
      exists N:set, N :e omega /\
        forall n:set, n :e omega -> N c= n ->
          Rlt (apply_fun d (apply_fun seq n, x)) eps.

(** from 21: uniqueness of limits in metric spaces **) 
(** helper: function evaluation as graph lookup **) 
Axiom metric_limits_unique_axiom : forall X d seq x y:set,
  metric_on X d ->
  sequence_on seq X ->
  sequence_converges_metric X d seq x ->
  sequence_converges_metric X d seq y ->
  x = y.
Theorem metric_limits_unique : forall X d seq x y:set,
  metric_on X d ->
  sequence_on seq X ->
  sequence_converges_metric X d seq x ->
  sequence_converges_metric X d seq y ->
  x = y.
let X d seq x y.
assume Hd: metric_on X d.
assume Hseq: sequence_on seq X.
assume Hx: sequence_converges_metric X d seq x.
assume Hy: sequence_converges_metric X d seq y.
prove x = y.
exact (metric_limits_unique_axiom X d seq x y Hd Hseq Hx Hy).
Qed.

(** uniform convergence of function sequences between metric spaces **) 
Definition uniform_convergence_functions :
  set -> set -> set -> set -> set -> set -> prop :=
  fun X dX Y dY f_seq f =>
    metric_on X dX /\ metric_on Y dY /\
    function_on f_seq omega (function_space X Y) /\ function_on f X Y /\
    (forall n:set, n :e omega -> function_on (apply_fun f_seq n) X Y) /\
(** FIXED: Removed extra parentheses around pair argument to dY metric. **)
    forall eps:set, eps :e R /\ Rlt 0 eps ->
      exists N:set, N :e omega /\
        forall n:set, n :e omega -> N c= n ->
          forall x:set, x :e X ->
            Rlt (apply_fun dY (apply_fun (apply_fun f_seq n) x, apply_fun f x)) eps.

(** from 21: uniform limit theorem placeholder **) 
(** LATEX VERSION: Uniform limit of continuous functions between metric spaces is continuous. **)
Axiom uniform_limit_of_continuous_is_continuous_axiom :
  forall X dX Y dY f_seq f:set,
    metric_on X dX -> metric_on Y dY ->
    function_on f_seq omega (function_space X Y) ->
    (forall n:set, n :e omega -> continuous_map X (metric_topology X dX) Y (metric_topology Y dY) (apply_fun f_seq n)) ->
    uniform_convergence_functions X dX Y dY f_seq f ->
    continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f.
Theorem uniform_limit_of_continuous_is_continuous :
  forall X dX Y dY f_seq f:set,
    metric_on X dX -> metric_on Y dY ->
    function_on f_seq omega (function_space X Y) ->
    (forall n:set, n :e omega -> continuous_map X (metric_topology X dX) Y (metric_topology Y dY) (apply_fun f_seq n)) ->
    uniform_convergence_functions X dX Y dY f_seq f ->
    continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f.
let X dX Y dY f_seq f.
assume HdX: metric_on X dX.
assume HdY: metric_on Y dY.
assume Hfseq: function_on f_seq omega (function_space X Y).
assume Hcont: forall n:set, n :e omega -> continuous_map X (metric_topology X dX) Y (metric_topology Y dY) (apply_fun f_seq n).
assume Hunif: uniform_convergence_functions X dX Y dY f_seq f.
prove continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f.
exact (uniform_limit_of_continuous_is_continuous_axiom X dX Y dY f_seq f HdX HdY Hfseq Hcont Hunif).
Qed.

(** from 21: convergence of sequences in metric spaces **) 
(** LATEX VERSION: Immediate restatement of convergence (placeholder). **)
Theorem sequence_convergence_metric : forall X d seq x:set,
  sequence_converges_metric X d seq x -> sequence_converges_metric X d seq x.
let X d seq x.
assume H: sequence_converges_metric X d seq x.
prove sequence_converges_metric X d seq x.
exact H.
Qed.

(** from 21: continuity via sequences in metric spaces **)
(** LATEX VERSION: Continuity between metric spaces is equivalent to preserving limits of convergent sequences. **)
(** FIXED: Composed sequence fseq must be a function (graph of ordered pairs), not Cartesian products.
    Was: {setprod n (apply_fun f (apply_fun seq n))|n :e omega} = {n  f(seq(n)) | n  }
    Now: {(n, apply_fun f (apply_fun seq n))|n :e omega} = graph of n  f(seq(n)) **)
Axiom continuity_via_sequences_metric_axiom : forall X dX Y dY f:set,
  metric_on X dX -> metric_on Y dY ->
  (continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f <->
    forall seq x:set,
      sequence_converges_metric X dX seq x ->
      sequence_converges_metric Y dY
        ({(n, apply_fun f (apply_fun seq n))|n :e omega})
        (apply_fun f x)).
Theorem continuity_via_sequences_metric : forall X dX Y dY f:set,
  metric_on X dX -> metric_on Y dY ->
  (continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f <->
    forall seq x:set,
      sequence_converges_metric X dX seq x ->
      sequence_converges_metric Y dY
        ({(n, apply_fun f (apply_fun seq n))|n :e omega})
        (apply_fun f x)).
let X dX Y dY f.
assume HdX: metric_on X dX.
assume HdY: metric_on Y dY.
prove continuous_map X (metric_topology X dX) Y (metric_topology Y dY) f <->
    forall seq x:set,
      sequence_converges_metric X dX seq x ->
      sequence_converges_metric Y dY
        ({(n, apply_fun f (apply_fun seq n))|n :e omega})
        (apply_fun f x).
exact (continuity_via_sequences_metric_axiom X dX Y dY f HdX HdY).
Qed.

(** from 22 Definition: quotient map and quotient topology **) 
(** LATEX VERSION: Quotient topology on Y makes a surjective map f:XY continuous iff preimages of opens in Y are open in X. **)
Definition quotient_topology : set -> set -> set -> set -> set :=
  fun X Tx Y f => {V :e Power Y|{x :e X|apply_fun f x :e V} :e Tx}.

Definition quotient_map : set -> set -> set -> set -> prop := fun X Tx Y f =>
  topology_on X Tx /\
  function_on f X Y /\
  (forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun f x = y).

Theorem quotient_topology_is_topology : forall X Tx Y f:set,
  topology_on X Tx -> quotient_map X Tx Y f ->
  topology_on Y (quotient_topology X Tx Y f).
let X Tx Y f.
assume HTx: topology_on X Tx.
assume Hf: quotient_map X Tx Y f.
prove topology_on Y (quotient_topology X Tx Y f).
set Q := quotient_topology X Tx Y f.
set pre := fun V:set => preimage_of X f V.
prove Q c= Power Y
  /\ Empty :e Q
  /\ Y :e Q
  /\ (forall UFam :e Power Q, Union UFam :e Q)
  /\ (forall U :e Q, forall V :e Q, U :/\: V :e Q).
apply andI.
- apply andI.
  - apply andI.
    - apply andI.
      - (** Q subset Power Y **)
        let V. assume HV: V :e Q.
        exact (SepE1 (Power Y) (fun V0:set => pre V0 :e Tx) V HV).
      - (** Empty in Q **)
        prove Empty :e Q.
        claim HpreE: pre Empty :e Tx.
        { set Epre := pre Empty.
          claim HEsub: Epre c= Empty.
          { let x. assume Hx: x :e Epre.
            prove x :e Empty.
            claim Hxprop: apply_fun f x :e Empty.
            { exact (SepE2 X (fun x0 => apply_fun f x0 :e Empty) x Hx). }
            exact (EmptyE (apply_fun f x) Hxprop (x :e Empty)). }
          claim HEeq: Epre = Empty.
          { exact (Empty_Subq_eq Epre HEsub). }
          rewrite HEeq.
          exact (topology_has_empty X Tx HTx). }
        claim Hpow: Empty :e Power Y.
        { exact (Empty_In_Power Y). }
        exact (SepI (Power Y) (fun V0:set => pre V0 :e Tx) Empty Hpow HpreE).
    - (** Y in Q **)
      prove Y :e Q.
      claim Hf_on: function_on f X Y.
      { exact (andER (topology_on X Tx) (function_on f X Y)
          (andEL (topology_on X Tx /\ function_on f X Y)
            (forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun f x = y) Hf)). }
      claim HpreY: pre Y :e Tx.
      { set Ypre := pre Y.
        claim HYsub: Ypre c= X.
        { let x. assume Hx: x :e Ypre.
          exact (SepE1 X (fun x0 => apply_fun f x0 :e Y) x Hx). }
        claim HXsub: X c= Ypre.
        { let x. assume Hx: x :e X.
          prove x :e Ypre.
	          claim HfxY: apply_fun f x :e Y.
	          { exact (Hf_on x Hx). }
	          exact (SepI X (fun x0 => apply_fun f x0 :e Y) x Hx HfxY). }
        claim HYeq: Ypre = X.
        { apply set_ext.
          - exact HYsub.
          - exact HXsub. }
        rewrite HYeq.
        exact (topology_has_X X Tx HTx). }
      claim Hpow: Y :e Power Y.
      { apply PowerI.
        exact (fun x Hx => Hx). }
      exact (SepI (Power Y) (fun V0:set => pre V0 :e Tx) Y Hpow HpreY).
  - (** Union closure **)
    let UFam. assume HUFam: UFam :e Power Q.
    prove Union UFam :e Q.
    claim HUFamSub: UFam c= Q.
    { exact (PowerE Q UFam HUFam). }
    (** show Union UFam in Power Y **)
    claim HUnionPow: Union UFam :e Power Y.
    { apply PowerI.
      let y. assume Hy: y :e Union UFam.
      prove y :e Y.
      apply (UnionE_impred UFam y Hy).
      let V. assume HyV. assume HVUF.
      claim HVQ: V :e Q.
      { exact (HUFamSub V HVUF). }
      claim HVPow: V :e Power Y.
      { exact (SepE1 (Power Y) (fun V0:set => pre V0 :e Tx) V HVQ). }
      exact (PowerE Y V HVPow y HyV). }
    (** show preimage of Union UFam is open in Tx **)
    claim HpreU: pre (Union UFam) :e Tx.
    { set PUFam := {pre V|V :e UFam}.
      claim HPUFamPow: PUFam :e Power Tx.
      { apply PowerI.
        let W. assume HW: W :e PUFam.
        prove W :e Tx.
        apply (ReplE UFam (fun V:set => pre V) W HW).
        let V. assume HVconj.
        claim HVUF: V :e UFam.
        { exact (andEL (V :e UFam) (W = pre V) HVconj). }
        claim HWeq: W = pre V.
        { exact (andER (V :e UFam) (W = pre V) HVconj). }
        claim HVQ: V :e Q.
        { exact (HUFamSub V HVUF). }
        claim HpreV: pre V :e Tx.
        { exact (SepE2 (Power Y) (fun V0:set => pre V0 :e Tx) V HVQ). }
        rewrite HWeq.
        exact HpreV. }
      (** pre(Union UFam) = Union PUFam **)
      claim Heq: pre (Union UFam) = Union PUFam.
      { apply set_ext.
        - let x. assume Hx: x :e pre (Union UFam).
          prove x :e Union PUFam.
          claim HxX: x :e X.
          { exact (SepE1 X (fun x0 => apply_fun f x0 :e Union UFam) x Hx). }
	          claim HxU: apply_fun f x :e Union UFam.
	          { exact (SepE2 X (fun x0 => apply_fun f x0 :e Union UFam) x Hx). }
	          apply (UnionE_impred UFam (apply_fun f x) HxU).
	          let V. assume HfxV. assume HVUF.
	          claim HxpreV: x :e pre V.
	          { exact (SepI X (fun x0 => apply_fun f x0 :e V) x HxX HfxV). }
	          claim HpreVin: pre V :e PUFam.
	          { exact (ReplI UFam (fun V0:set => pre V0) V HVUF). }
	          exact (UnionI PUFam x (pre V) HxpreV HpreVin).
	        - let x. assume Hx: x :e Union PUFam.
	          prove x :e pre (Union UFam).
	          apply (UnionE_impred PUFam x Hx).
	          let W. assume HxW. assume HWPU.
	          apply (ReplE UFam (fun V:set => pre V) W HWPU).
	          let V. assume HVconj.
	          claim HVUF: V :e UFam.
	          { exact (andEL (V :e UFam) (W = pre V) HVconj). }
          claim HWeq: W = pre V.
          { exact (andER (V :e UFam) (W = pre V) HVconj). }
          claim HxpreV: x :e pre V.
          { rewrite <- HWeq.
            exact HxW. }
          claim HfxV: apply_fun f x :e V.
          { exact (SepE2 X (fun x0 => apply_fun f x0 :e V) x HxpreV). }
	          claim HfxU: apply_fun f x :e Union UFam.
	          { exact (UnionI UFam (apply_fun f x) V HfxV HVUF). }
          claim HxX: x :e X.
          { exact (SepE1 X (fun x0 => apply_fun f x0 :e V) x HxpreV). }
          exact (SepI X (fun x0 => apply_fun f x0 :e Union UFam) x HxX HfxU). }
      rewrite Heq.
      exact (topology_union_axiom X Tx HTx PUFam HPUFamPow). }
    exact (SepI (Power Y) (fun V0:set => pre V0 :e Tx) (Union UFam) HUnionPow HpreU).
- (** binary intersection closure **)
  let U. assume HU: U :e Q.
  let V. assume HV: V :e Q.
  prove U :/\: V :e Q.
  claim HUPow: U :e Power Y.
  { exact (SepE1 (Power Y) (fun V0:set => pre V0 :e Tx) U HU). }
  claim HVPow: V :e Power Y.
  { exact (SepE1 (Power Y) (fun V0:set => pre V0 :e Tx) V HV). }
  claim HpreU: pre U :e Tx.
  { exact (SepE2 (Power Y) (fun V0:set => pre V0 :e Tx) U HU). }
  claim HpreV: pre V :e Tx.
  { exact (SepE2 (Power Y) (fun V0:set => pre V0 :e Tx) V HV). }
  claim HUVPow: U :/\: V :e Power Y.
  { apply PowerI.
    let y. assume Hy: y :e U :/\: V.
    prove y :e Y.
    claim HyU: y :e U.
    { exact (binintersectE1 U V y Hy). }
    exact (PowerE Y U HUPow y HyU). }
  (** pre(UV) = pre(U)  pre(V) **)
  claim Heq: pre (U :/\: V) = pre U :/\: pre V.
  { apply set_ext.
    - let x. assume Hx: x :e pre (U :/\: V).
      prove x :e pre U :/\: pre V.
      claim HxX: x :e X.
      { exact (SepE1 X (fun x0 => apply_fun f x0 :e U :/\: V) x Hx). }
      claim Hfx: apply_fun f x :e U :/\: V.
      { exact (SepE2 X (fun x0 => apply_fun f x0 :e U :/\: V) x Hx). }
      claim HfxU: apply_fun f x :e U.
      { exact (binintersectE1 U V (apply_fun f x) Hfx). }
      claim HfxV: apply_fun f x :e V.
      { exact (binintersectE2 U V (apply_fun f x) Hfx). }
      exact (binintersectI (pre U) (pre V) x
              (SepI X (fun x0 => apply_fun f x0 :e U) x HxX HfxU)
              (SepI X (fun x0 => apply_fun f x0 :e V) x HxX HfxV)).
    - let x. assume Hx: x :e pre U :/\: pre V.
      prove x :e pre (U :/\: V).
      claim HxpreU: x :e pre U.
      { exact (binintersectE1 (pre U) (pre V) x Hx). }
      claim HxpreV: x :e pre V.
      { exact (binintersectE2 (pre U) (pre V) x Hx). }
      claim HxX: x :e X.
      { exact (SepE1 X (fun x0 => apply_fun f x0 :e U) x HxpreU). }
      claim HfxU: apply_fun f x :e U.
      { exact (SepE2 X (fun x0 => apply_fun f x0 :e U) x HxpreU). }
      claim HfxV: apply_fun f x :e V.
      { exact (SepE2 X (fun x0 => apply_fun f x0 :e V) x HxpreV). }
      claim HfxUV: apply_fun f x :e U :/\: V.
      { exact (binintersectI U V (apply_fun f x) HfxU HfxV). }
      exact (SepI X (fun x0 => apply_fun f x0 :e U :/\: V) x HxX HfxUV). }
  claim HpreUV: pre (U :/\: V) :e Tx.
  { rewrite Heq.
    exact (topology_binintersect_closed X Tx (pre U) (pre V) HTx HpreU HpreV). }
  exact (SepI (Power Y) (fun V0:set => pre V0 :e Tx) (U :/\: V) HUVPow HpreUV).
Qed.

(** from 22: universal property of quotient maps **) 
(** LATEX VERSION: Universal property: a quotient map f is continuous into any topology Ty on Y coarser than the quotient topology. **)
Theorem quotient_universal_property : forall X Tx Y Ty f:set,
  quotient_map X Tx Y f -> topology_on Y Ty -> Ty c= quotient_topology X Tx Y f ->
  continuous_map X Tx Y Ty f.
let X Tx Y Ty f.
assume Hf: quotient_map X Tx Y f.
assume HTy: topology_on Y Ty.
assume Hsub: Ty c= quotient_topology X Tx Y f.
prove continuous_map X Tx Y Ty f.
prove topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y /\ forall V:set, V :e Ty -> preimage_of X f V :e Tx.
claim Htopfun : topology_on X Tx /\ function_on f X Y.
{ exact (andEL (topology_on X Tx /\ function_on f X Y)
        (forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun f x = y) Hf). }
claim HTx : topology_on X Tx.
{ exact (andEL (topology_on X Tx) (function_on f X Y) Htopfun). }
claim Hf_on : function_on f X Y.
{ exact (andER (topology_on X Tx) (function_on f X Y) Htopfun). }
apply andI.
- apply andI.
  - apply andI.
    + exact HTx.
    + exact HTy.
  - exact Hf_on.
- let V. assume HV: V :e Ty.
  prove preimage_of X f V :e Tx.
  claim HVQ: V :e quotient_topology X Tx Y f.
  { exact (Hsub V HV). }
  exact (SepE2 (Power Y) (fun V0:set => preimage_of X f V0 :e Tx) V HVQ).
Qed.

(** from 23 Definition: separation of a space **) 
(** LATEX VERSION: A separation of X is a pair of disjoint nonempty open sets whose union is X. **)
Definition separation_of : set -> set -> set -> prop := fun X U V =>
  U :e Power X /\ V :e Power X /\ U :/\: V = Empty /\ U <> Empty /\ V <> Empty /\ U :\/: V = X.

(** from 23 Definition: connected space **) 
(** LATEX VERSION: X with topology Tx is connected if it admits no separation. **)
Definition connected_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).

(** Helper theorems for connected_iff_no_nontrivial_clopen **)
Theorem clopen_gives_separation : forall X Tx A:set,
  topology_on X Tx -> A <> Empty -> A <> X ->
  open_in X Tx A -> closed_in X Tx A ->
  exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V.
let X Tx A.
assume HTx: topology_on X Tx.
assume HAne: A <> Empty.
assume HAneX: A <> X.
assume HAopen: open_in X Tx A.
assume HAclosed: closed_in X Tx A.
claim HATx: A :e Tx.
{ exact (andER (topology_on X Tx) (A :e Tx) HAopen). }
claim HcompOpen: open_in X Tx (X :\: A).
{ exact (open_of_closed_complement X Tx A HAclosed). }
claim HcompTx: X :\: A :e Tx.
{ exact (andER (topology_on X Tx) ((X :\: A) :e Tx) HcompOpen). }
witness A.
witness (X :\: A).
apply andI.
- apply andI.
  + exact HATx.
  + exact HcompTx.
- prove separation_of X A (X :\: A).
    prove A :e Power X /\ (X :\: A) :e Power X /\ A :/\: (X :\: A) = Empty /\ A <> Empty /\ (X :\: A) <> Empty /\ A :\/: (X :\: A) = X.
    claim HAsubX: A c= X.
    { exact (open_in_subset X Tx A HAopen). }
    claim HApower: A :e Power X.
    { exact (PowerI X A HAsubX). }
    claim HcompSubX: X :\: A c= X.
    { exact (setminus_Subq X A). }
    claim HcompPower: (X :\: A) :e Power X.
    { exact (PowerI X (X :\: A) HcompSubX). }
    claim Hdisjoint: A :/\: (X :\: A) = Empty.
    { apply Empty_eq.
      let x. assume Hx: x :e A :/\: (X :\: A).
      apply (binintersectE A (X :\: A) x Hx).
      assume HxA: x :e A.
      assume HxComp: x :e X :\: A.
      apply (setminusE X A x HxComp).
      assume _. assume HxNotA: x /:e A.
      exact (HxNotA HxA). }
    claim HcompNe: (X :\: A) <> Empty.
    { assume Heq: X :\: A = Empty.
      claim HAeqX: A = X.
      { apply set_ext.
        - exact HAsubX.
        - let x. assume HxX: x :e X.
          apply (xm (x :e A)).
          + assume HxA. exact HxA.
          + assume HxNotA.
            claim Hxcomp: x :e X :\: A.
            { exact (setminusI X A x HxX HxNotA). }
            claim HxEmpty: x :e Empty.
            { rewrite <- Heq. exact Hxcomp. }
            prove x :e A.
            exact (FalseE (EmptyE x HxEmpty) (x :e A)). }
      exact (HAneX HAeqX). }
    claim Hunion: A :\/: (X :\: A) = X.
    { apply set_ext.
      - let x. assume Hx: x :e A :\/: (X :\: A).
        apply (binunionE A (X :\: A) x Hx).
        + assume HxA. exact (HAsubX x HxA).
        + assume HxComp. exact (setminusE1 X A x HxComp).
      - let x. assume HxX: x :e X.
        apply (xm (x :e A)).
        + assume HxA. exact (binunionI1 A (X :\: A) x HxA).
        + assume HxNotA. exact (binunionI2 A (X :\: A) x (setminusI X A x HxX HxNotA)). }
    prove (((((A :e Power X /\ (X :\: A) :e Power X) /\ A :/\: (X :\: A) = Empty) /\ A <> Empty) /\ (X :\: A) <> Empty) /\ A :\/: (X :\: A) = X).
    apply andI.
    * apply andI.
      { apply andI.
        - apply andI.
          + apply andI.
            { exact HApower. }
            { exact HcompPower. }
          + exact Hdisjoint.
        - exact HAne. }
      { exact HcompNe. }
    * exact Hunion.
Qed.

Theorem separation_gives_clopen : forall X Tx U V:set,
  topology_on X Tx ->
  U :e Tx -> V :e Tx -> separation_of X U V ->
  exists A:set, A <> Empty /\ A <> X /\ open_in X Tx A /\ closed_in X Tx A.
let X Tx U V.
assume HTx: topology_on X Tx.
assume HU: U :e Tx.
assume HV: V :e Tx.
assume Hsep: separation_of X U V.
witness U.
prove U <> Empty /\ U <> X /\ open_in X Tx U /\ closed_in X Tx U.
claim H1: (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty.
{ exact (andEL ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
               (U :\/: V = X) Hsep). }
claim H2: ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty.
{ exact (andEL (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty)
               (V <> Empty) H1). }
claim HUne: U <> Empty.
{ exact (andER (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty)) (U <> Empty) H2). }
claim Hunion: U :\/: V = X.
{ exact (andER ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
               (U :\/: V = X) Hsep). }
claim HUneX: U <> X.
{ assume Heq: U = X.
  claim HVempty: V = Empty.
  { apply Empty_eq.
    let x. assume Hx: x :e V.
    claim HxX: x :e X.
    { rewrite <- Hunion. exact (binunionI2 U V x Hx). }
    claim HxU: x :e U.
    { rewrite Heq. exact HxX. }
    claim Hxdisj: x :e U :/\: V.
    { exact (binintersectI U V x HxU Hx). }
    claim Hdisj: U :/\: V = Empty.
    { exact (andER (U :e Power X /\ V :e Power X) (U :/\: V = Empty)
                   (andEL ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty)
                          (U <> Empty) H2)). }
    claim Hfalse: x :e Empty.
    { rewrite <- Hdisj. exact Hxdisj. }
    exact (EmptyE x Hfalse). }
  claim HVne: V <> Empty.
  { exact (andER ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty)) (V <> Empty) H1). }
  exact (HVne HVempty). }
claim HUopen: open_in X Tx U.
{ exact (andI (topology_on X Tx) (U :e Tx) HTx HU). }
claim Hdisj: U :/\: V = Empty.
{ exact (andER (U :e Power X /\ V :e Power X) (U :/\: V = Empty)
               (andEL ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty)
                      (U <> Empty) H2)). }
claim HUpower: U :e Power X.
{ exact (andEL (U :e Power X) (V :e Power X)
               (andEL (U :e Power X /\ V :e Power X) (U :/\: V = Empty)
                      (andEL ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) (U <> Empty) H2))). }
claim HUsubX: U c= X.
{ exact (PowerE X U HUpower). }
claim Heq_comp: U = X :\: V.
{ apply set_ext.
  - let x. assume Hx: x :e U.
    prove x :e X :\: V.
    claim HxX: x :e X.
    { exact (HUsubX x Hx). }
    claim HxnotV: x /:e V.
    { assume HxV: x :e V.
      claim Hxdisj: x :e U :/\: V.
      { exact (binintersectI U V x Hx HxV). }
      claim Hfalse: x :e Empty.
      { rewrite <- Hdisj. exact Hxdisj. }
      exact (EmptyE x Hfalse). }
    exact (setminusI X V x HxX HxnotV).
  - let x. assume Hx: x :e X :\: V.
    prove x :e U.
    claim HxX: x :e X.
    { exact (setminusE1 X V x Hx). }
    claim HxnotV: x /:e V.
    { exact (setminusE2 X V x Hx). }
    claim HxUnion: x :e U :\/: V.
    { rewrite Hunion. exact HxX. }
    apply (binunionE U V x HxUnion).
    + assume HxU. exact HxU.
    + assume HxV. exact (FalseE (HxnotV HxV) (x :e U)). }
claim HUclosed: closed_in X Tx U.
{ prove topology_on X Tx /\ (U c= X /\ exists W :e Tx, U = X :\: W).
  apply andI.
  - exact HTx.
  - apply andI.
    + exact HUsubX.
    + witness V.
      apply andI.
      * exact HV.
      * exact Heq_comp. }
apply andI.
- apply andI.
  + apply andI.
    * exact HUne.
    * exact HUneX.
  + exact HUopen.
- exact HUclosed.
Qed.

(** from 23: no nontrivial clopen sets characterization **)
(** LATEX VERSION: A space is connected iff it has no nontrivial clopen subsets. **)
Theorem connected_iff_no_nontrivial_clopen : forall X Tx:set,
  topology_on X Tx ->
  (connected_space X Tx <->
  ~(exists A:set, A <> Empty /\ A <> X /\ open_in X Tx A /\ closed_in X Tx A)).
let X Tx.
assume HTx: topology_on X Tx.
prove connected_space X Tx <-> ~(exists A:set, A <> Empty /\ A <> X /\ open_in X Tx A /\ closed_in X Tx A).
apply iffI.
- (** Forward: connected implies no nontrivial clopen **)
  assume Hconn: connected_space X Tx.
  prove ~(exists A:set, A <> Empty /\ A <> X /\ open_in X Tx A /\ closed_in X Tx A).
  assume Hclopen: exists A:set, A <> Empty /\ A <> X /\ open_in X Tx A /\ closed_in X Tx A.
  (** Extract no-separation from connectedness **)
  claim Hnosep: ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).
  { exact (andER (topology_on X Tx)
                 (~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V))
                 Hconn). }
  (** Clopen exists, so by axiom we get separation **)
  apply Hclopen.
  let A. assume HA.
  (** Left-associative: (((A <> Empty /\ A <> X) /\ open_in X Tx A) /\ closed_in X Tx A) **)
  claim HAne: A <> Empty.
  { exact (andEL (A <> Empty) (A <> X)
                 (andEL (A <> Empty /\ A <> X) (open_in X Tx A)
                        (andEL ((A <> Empty /\ A <> X) /\ open_in X Tx A) (closed_in X Tx A) HA))). }
  claim HAnX: A <> X.
  { exact (andER (A <> Empty) (A <> X)
                 (andEL (A <> Empty /\ A <> X) (open_in X Tx A)
                        (andEL ((A <> Empty /\ A <> X) /\ open_in X Tx A) (closed_in X Tx A) HA))). }
  claim HAopen: open_in X Tx A.
  { exact (andER (A <> Empty /\ A <> X) (open_in X Tx A)
                 (andEL ((A <> Empty /\ A <> X) /\ open_in X Tx A) (closed_in X Tx A) HA)). }
  claim HAclosed: closed_in X Tx A.
  { exact (andER ((A <> Empty /\ A <> X) /\ open_in X Tx A) (closed_in X Tx A) HA). }
  (** Apply axiom to get separation **)
  claim Hsepexists: exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V.
  { exact (clopen_gives_separation X Tx A HTx HAne HAnX HAopen HAclosed). }
  (** Contradiction **)
  apply Hnosep.
  exact Hsepexists.
- (** Backward: no nontrivial clopen implies connected **)
  assume Hno_clopen: ~(exists A:set, A <> Empty /\ A <> X /\ open_in X Tx A /\ closed_in X Tx A).
  prove connected_space X Tx.
  prove topology_on X Tx /\ ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).
  apply andI.
  + exact HTx.
  + prove ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).
    assume Hsep: exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V.
    apply Hsep.
    let U. assume HsepV: exists V:set, U :e Tx /\ V :e Tx /\ separation_of X U V.
    apply HsepV.
    let V. assume HUV.
    (** Left-associative: ((U :e Tx /\ V :e Tx) /\ separation_of X U V) **)
    claim HU: U :e Tx.
    { exact (andEL (U :e Tx) (V :e Tx)
                   (andEL (U :e Tx /\ V :e Tx) (separation_of X U V) HUV)). }
    claim HV: V :e Tx.
    { exact (andER (U :e Tx) (V :e Tx)
                   (andEL (U :e Tx /\ V :e Tx) (separation_of X U V) HUV)). }
    claim Hsepof: separation_of X U V.
    { exact (andER (U :e Tx /\ V :e Tx) (separation_of X U V) HUV). }
    (** Apply axiom to get clopen from separation **)
    claim Hclopenexists: exists A:set, A <> Empty /\ A <> X /\ open_in X Tx A /\ closed_in X Tx A.
    { exact (separation_gives_clopen X Tx U V HTx HU HV Hsepof). }
    (** Contradiction **)
    apply Hno_clopen.
    exact Hclopenexists.
Qed.

(** from 23 Lemma 23.1: separations in subspaces via limit points **)
(** LATEX VERSION: If Y is a subspace of X, a separation of Y is a pair of disjoint nonempty sets A,B whose union is Y, neither containing a limit point of the other. **)
Theorem separation_subspace_limit_points : forall X Tx Y A B:set,
  topology_on X Tx -> Y c= X ->
  (((A :e subspace_topology X Tx Y /\ B :e subspace_topology X Tx Y) /\ separation_of Y A B)
  <->
  (separation_of Y A B
    /\ ~(exists b:set, b :e B /\ limit_point_of X Tx A b)
    /\ ~(exists a:set, a :e A /\ limit_point_of X Tx B a))).
let X Tx Y A B.
assume HTx: topology_on X Tx.
assume HY: Y c= X.
prove (((A :e subspace_topology X Tx Y /\ B :e subspace_topology X Tx Y) /\ separation_of Y A B)
  <->
  (separation_of Y A B
    /\ ~(exists b:set, b :e B /\ limit_point_of X Tx A b)
    /\ ~(exists a:set, a :e A /\ limit_point_of X Tx B a))).
apply iffI.
- (** -> direction: openness in subspace implies no cross-limit-points **)
  assume Hleft.
  claim HABsub: A :e subspace_topology X Tx Y /\ B :e subspace_topology X Tx Y.
  { exact (andEL (A :e subspace_topology X Tx Y /\ B :e subspace_topology X Tx Y) (separation_of Y A B) Hleft). }
  claim HAinTy: A :e subspace_topology X Tx Y.
  { exact (andEL (A :e subspace_topology X Tx Y) (B :e subspace_topology X Tx Y) HABsub). }
  claim HBinTy: B :e subspace_topology X Tx Y.
  { exact (andER (A :e subspace_topology X Tx Y) (B :e subspace_topology X Tx Y) HABsub). }
  claim Hsep: separation_of Y A B.
  { exact (andER (A :e subspace_topology X Tx Y /\ B :e subspace_topology X Tx Y) (separation_of Y A B) Hleft). }
  prove separation_of Y A B
    /\ ~(exists b:set, b :e B /\ limit_point_of X Tx A b)
    /\ ~(exists a:set, a :e A /\ limit_point_of X Tx B a).
  apply andI.
  + apply andI.
    - exact Hsep.
    - (** no b in B is a limit point of A **)
      prove ~(exists b:set, b :e B /\ limit_point_of X Tx A b).
      assume Hex: exists b:set, b :e B /\ limit_point_of X Tx A b.
      prove False.
      apply Hex.
      let b. assume Hbconj.
      claim HbB: b :e B.
      { exact (andEL (b :e B) (limit_point_of X Tx A b) Hbconj). }
      claim HLP: limit_point_of X Tx A b.
      { exact (andER (b :e B) (limit_point_of X Tx A b) Hbconj). }
      (** Extract B = V  Y for some V open in X **)
      claim HexV: exists V :e Tx, B = V :/\: Y.
      { exact (SepE2 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) B HBinTy). }
      apply HexV.
      let V. assume HVpair.
      claim HVTx: V :e Tx.
      { exact (andEL (V :e Tx) (B = V :/\: Y) HVpair). }
      claim HBeq: B = V :/\: Y.
      { exact (andER (V :e Tx) (B = V :/\: Y) HVpair). }
      (** Use separation_of to get A,B  Y and AB= **)
      claim Hpart1: ((((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty) /\ B <> Empty).
      { exact (andEL ((((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty) /\ B <> Empty)
                     (A :\/: B = Y) Hsep). }
      claim HAux: (((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty).
      { exact (andEL (((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty)
                     (B <> Empty) Hpart1). }
      claim Hpowdisj: (A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty.
      { exact (andEL ((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) (A <> Empty) HAux). }
      claim Hpow: A :e Power Y /\ B :e Power Y.
      { exact (andEL (A :e Power Y /\ B :e Power Y) (A :/\: B = Empty) Hpowdisj). }
      claim Hdisj: A :/\: B = Empty.
      { exact (andER (A :e Power Y /\ B :e Power Y) (A :/\: B = Empty) Hpowdisj). }
      claim HApowY: A :e Power Y.
      { exact (andEL (A :e Power Y) (B :e Power Y) Hpow). }
      claim HBpowY: B :e Power Y.
      { exact (andER (A :e Power Y) (B :e Power Y) Hpow). }
      claim HAsubY: A c= Y.
      { exact (PowerE Y A HApowY). }
      claim HBsubY: B c= Y.
      { exact (PowerE Y B HBpowY). }
      (** b  V **)
      claim HbVY: b :e V :/\: Y.
      { rewrite <- HBeq. exact HbB. }
      claim HbV: b :e V.
      { exact (binintersectE1 V Y b HbVY). }
      (** Apply limit point condition to neighborhood V **)
      claim HLPp: topology_on X Tx /\ b :e X.
      { exact (andEL (topology_on X Tx /\ b :e X) (forall U:set, U :e Tx -> b :e U -> exists y:set, y :e A /\ y <> b /\ y :e U) HLP). }
      claim HLPcond: forall U:set, U :e Tx -> b :e U -> exists y:set, y :e A /\ y <> b /\ y :e U.
      { exact (andER (topology_on X Tx /\ b :e X) (forall U:set, U :e Tx -> b :e U -> exists y:set, y :e A /\ y <> b /\ y :e U) HLP). }
      claim Hexy: exists y:set, y :e A /\ y <> b /\ y :e V.
      { exact (HLPcond V HVTx HbV). }
      apply Hexy.
      let y. assume Hyconj.
      claim HyAB: y :e A /\ y <> b.
      { exact (andEL (y :e A /\ y <> b) (y :e V) Hyconj). }
      claim HyA: y :e A.
      { exact (andEL (y :e A) (y <> b) HyAB). }
      claim HyV: y :e V.
      { exact (andER (y :e A /\ y <> b) (y :e V) Hyconj). }
      claim HyY: y :e Y.
      { exact (HAsubY y HyA). }
      claim HyB: y :e B.
      { rewrite HBeq. exact (binintersectI V Y y HyV HyY). }
      claim HyAB2: y :e A :/\: B.
      { exact (binintersectI A B y HyA HyB). }
      claim HyE: y :e Empty.
      { rewrite <- Hdisj. exact HyAB2. }
      exact (EmptyE y HyE).
  + (** no a in A is a limit point of B (symmetric) **)
    prove ~(exists a:set, a :e A /\ limit_point_of X Tx B a).
    assume Hex: exists a:set, a :e A /\ limit_point_of X Tx B a.
    prove False.
    apply Hex.
    let a. assume Haconj.
    claim HaA: a :e A.
    { exact (andEL (a :e A) (limit_point_of X Tx B a) Haconj). }
    claim HLP: limit_point_of X Tx B a.
    { exact (andER (a :e A) (limit_point_of X Tx B a) Haconj). }
      (** Extract A = U  Y for some U open in X **)
      claim HexU: exists U :e Tx, A = U :/\: Y.
      { exact (SepE2 (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) A HAinTy). }
      apply HexU.
      let U. assume HUpair.
      claim HUTx: U :e Tx.
      { exact (andEL (U :e Tx) (A = U :/\: Y) HUpair). }
      claim HAeq: A = U :/\: Y.
      { exact (andER (U :e Tx) (A = U :/\: Y) HUpair). }
      (** Use separation_of to get A,B  Y and AB= **)
      claim Hpart1: ((((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty) /\ B <> Empty).
      { exact (andEL ((((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty) /\ B <> Empty)
                     (A :\/: B = Y) Hsep). }
      claim HAux: (((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty).
      { exact (andEL (((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty)
                     (B <> Empty) Hpart1). }
      claim Hpowdisj: (A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty.
      { exact (andEL ((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) (A <> Empty) HAux). }
      claim Hpow: A :e Power Y /\ B :e Power Y.
      { exact (andEL (A :e Power Y /\ B :e Power Y) (A :/\: B = Empty) Hpowdisj). }
      claim Hdisj: A :/\: B = Empty.
      { exact (andER (A :e Power Y /\ B :e Power Y) (A :/\: B = Empty) Hpowdisj). }
      claim HApowY: A :e Power Y.
      { exact (andEL (A :e Power Y) (B :e Power Y) Hpow). }
      claim HBpowY: B :e Power Y.
      { exact (andER (A :e Power Y) (B :e Power Y) Hpow). }
      claim HAsubY: A c= Y.
      { exact (PowerE Y A HApowY). }
      claim HBsubY: B c= Y.
      { exact (PowerE Y B HBpowY). }
      (** a  U **)
      claim HaUY: a :e U :/\: Y.
      { rewrite <- HAeq. exact HaA. }
      claim HaU: a :e U.
      { exact (binintersectE1 U Y a HaUY). }
      (** Apply limit point condition to neighborhood U **)
      claim HLPcond: forall V0:set, V0 :e Tx -> a :e V0 -> exists y:set, y :e B /\ y <> a /\ y :e V0.
      { exact (andER (topology_on X Tx /\ a :e X) (forall V0:set, V0 :e Tx -> a :e V0 -> exists y:set, y :e B /\ y <> a /\ y :e V0) HLP). }
      claim Hexy: exists y:set, y :e B /\ y <> a /\ y :e U.
      { exact (HLPcond U HUTx HaU). }
      apply Hexy.
      let y. assume Hyconj.
      claim HyBA: y :e B /\ y <> a.
      { exact (andEL (y :e B /\ y <> a) (y :e U) Hyconj). }
      claim HyB: y :e B.
      { exact (andEL (y :e B) (y <> a) HyBA). }
      claim HyU: y :e U.
      { exact (andER (y :e B /\ y <> a) (y :e U) Hyconj). }
      claim HyY: y :e Y.
      { exact (HBsubY y HyB). }
      claim HyA2: y :e A.
      { rewrite HAeq. exact (binintersectI U Y y HyU HyY). }
      claim HyAB2: y :e A :/\: B.
      { exact (binintersectI A B y HyA2 HyB). }
      claim HyE: y :e Empty.
      { rewrite <- Hdisj. exact HyAB2. }
      exact (EmptyE y HyE).
- (** <- direction: no cross-limit-points implies openness in subspace **)
  assume Hright.
  claim Htmp: separation_of Y A B /\ ~(exists b:set, b :e B /\ limit_point_of X Tx A b).
  { exact (andEL (separation_of Y A B /\ ~(exists b:set, b :e B /\ limit_point_of X Tx A b))
                 (~(exists a:set, a :e A /\ limit_point_of X Tx B a)) Hright). }
  claim Hsep: separation_of Y A B.
  { exact (andEL (separation_of Y A B) (~(exists b:set, b :e B /\ limit_point_of X Tx A b)) Htmp). }
  claim HnoB: ~(exists b:set, b :e B /\ limit_point_of X Tx A b).
  { exact (andER (separation_of Y A B) (~(exists b:set, b :e B /\ limit_point_of X Tx A b)) Htmp). }
  claim HnoA: ~(exists a:set, a :e A /\ limit_point_of X Tx B a).
  { exact (andER (separation_of Y A B /\ ~(exists b:set, b :e B /\ limit_point_of X Tx A b))
                 (~(exists a:set, a :e A /\ limit_point_of X Tx B a)) Hright). }
  (** Extract basic separation facts **)
  claim Hpart1: ((((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty) /\ B <> Empty).
  { exact (andEL ((((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty) /\ B <> Empty)
                 (A :\/: B = Y) Hsep). }
  claim Hunion: A :\/: B = Y.
  { exact (andER ((((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty) /\ B <> Empty)
                 (A :\/: B = Y) Hsep). }
  claim HAux: (((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty).
  { exact (andEL (((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty)
                 (B <> Empty) Hpart1). }
  claim Hpowdisj: (A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty.
  { exact (andEL ((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) (A <> Empty) HAux). }
  claim Hpow: A :e Power Y /\ B :e Power Y.
  { exact (andEL (A :e Power Y /\ B :e Power Y) (A :/\: B = Empty) Hpowdisj). }
  claim Hdisj: A :/\: B = Empty.
  { exact (andER (A :e Power Y /\ B :e Power Y) (A :/\: B = Empty) Hpowdisj). }
  claim HApowY: A :e Power Y.
  { exact (andEL (A :e Power Y) (B :e Power Y) Hpow). }
  claim HBpowY: B :e Power Y.
  { exact (andER (A :e Power Y) (B :e Power Y) Hpow). }
  claim HAsubY: A c= Y.
  { exact (PowerE Y A HApowY). }
  claim HBsubY: B c= Y.
  { exact (PowerE Y B HBpowY). }
  (** Topology on Y **)
  claim HtopY: topology_on Y (subspace_topology X Tx Y).
  { exact (subspace_topology_is_topology X Tx Y HTx HY). }
  (** Prove A and B are open in the subspace by local openness (ex13_1). **)
  claim HAopen_in: open_in Y (subspace_topology X Tx Y) A.
  { apply (ex13_1_local_open_subset Y (subspace_topology X Tx Y) A HtopY).
    let x. assume HxA: x :e A.
    prove exists U :e subspace_topology X Tx Y, x :e U /\ U c= A.
    (** x is not a limit point of B (otherwise contradict HnoA) **)
    claim HnotLP: ~(limit_point_of X Tx B x).
    { assume HLP.
      apply HnoA.
      witness x.
      apply andI.
      - exact HxA.
      - exact HLP. }
    claim HxY: x :e Y.
    { exact (HAsubY x HxA). }
    claim HxX: x :e X.
    { exact (HY x HxY). }
    (** Not being a limit point yields an open neighborhood W with no B-point in it. **)
    claim HnotForall: ~(forall W:set, W :e Tx -> x :e W -> exists y:set, y :e B /\ y <> x /\ y :e W).
    { assume Hforall.
      apply HnotLP.
      prove topology_on X Tx /\ x :e X /\ forall U:set, U :e Tx -> x :e U -> exists y:set, y :e B /\ y <> x /\ y :e U.
      apply andI.
      - apply andI.
        + exact HTx.
        + exact HxX.
      - exact Hforall. }
    claim HexW: exists W:set, ~(W :e Tx -> x :e W -> exists y:set, y :e B /\ y <> x /\ y :e W).
    { exact (not_all_ex_demorgan_i (fun W:set => W :e Tx -> x :e W -> exists y:set, y :e B /\ y <> x /\ y :e W) HnotForall). }
    apply HexW.
    let W. assume HnImp.
    (** Derive W  Tx **)
    claim HWTx: W :e Tx.
    { apply (xm (W :e Tx)).
      - assume HW. exact HW.
      - assume HnotW.
        apply FalseE.
        apply HnImp.
        assume HW0: W :e Tx.
        assume HxW0: x :e W.
        apply FalseE.
        exact (HnotW HW0). }
    (** Derive x  W **)
    claim HxW: x :e W.
    { apply (xm (x :e W)).
      - assume Hx. exact Hx.
      - assume Hnotx.
        apply FalseE.
        apply HnImp.
        assume HW0: W :e Tx.
        assume HxW0: x :e W.
        apply FalseE.
        exact (Hnotx HxW0). }
    (** Hence no y  B with y  x in W. **)
    claim HnoY: ~(exists y:set, y :e B /\ y <> x /\ y :e W).
    { assume Hexy.
      apply HnImp.
      assume HW0: W :e Tx.
      assume HxW0: x :e W.
      exact Hexy. }
    (** Neighborhood in subspace: U = W  Y **)
    set U := W :/\: Y.
    witness U.
    (** Bounded-exists goal is UTy  (xU  UA) **)
    apply andI.
    - (** U  subspace topology with witness W **)
      prove U :e subspace_topology X Tx Y.
      claim HUpowY: U :e Power Y.
      { apply PowerI.
        let t. assume Ht: t :e U.
        exact (binintersectE2 W Y t Ht). }
      claim HexWU: exists V :e Tx, U = V :/\: Y.
      { witness W.
        apply andI.
        - exact HWTx.
        - reflexivity. }
      exact (SepI (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HUpowY HexWU).
    - (** x  U  U  A **)
      apply andI.
      + exact (binintersectI W Y x HxW HxY).
      + (** U  A since U  Y and disjoint from B, and A  B = Y **)
        prove U c= A.
        let t. assume Ht: t :e U.
        prove t :e A.
        claim HtY: t :e Y.
        { exact (binintersectE2 W Y t Ht). }
        (** show t  B using HnoY **)
        claim HtnotB: t /:e B.
        { assume HtB: t :e B.
          apply HnoY.
          witness t.
          prove (t :e B /\ t <> x) /\ t :e W.
          apply andI.
          - apply andI.
            + exact HtB.
            + (** t <> x since x  A and A  B =  **)
              assume Heq: t = x.
              claim HxB: x :e B.
              { rewrite <- Heq. exact HtB. }
              claim HxAB: x :e A :/\: B.
              { exact (binintersectI A B x HxA HxB). }
              claim HxE: x :e Empty.
              { rewrite <- Hdisj. exact HxAB. }
              exact (EmptyE x HxE).
          - (** t  W **)
            exact (binintersectE1 W Y t Ht). }
        (** From t  Y, get t  A  B, then eliminate the B case. **)
        claim HtAB: t :e A :\/: B.
        { rewrite Hunion. exact HtY. }
        apply (binunionE A B t HtAB).
        * assume HtA. exact HtA.
        * assume HtB.
          apply FalseE.
          exact (HtnotB HtB). }
  claim HATy: A :e subspace_topology X Tx Y.
  { exact (andER (topology_on Y (subspace_topology X Tx Y)) (A :e subspace_topology X Tx Y) HAopen_in). }
  claim HBopen_in: open_in Y (subspace_topology X Tx Y) B.
  { apply (ex13_1_local_open_subset Y (subspace_topology X Tx Y) B HtopY).
    let x. assume HxB: x :e B.
    prove exists U :e subspace_topology X Tx Y, x :e U /\ U c= B.
    claim HnotLP: ~(limit_point_of X Tx A x).
    { assume HLP.
      apply HnoB.
      witness x.
      apply andI.
      - exact HxB.
      - exact HLP. }
    claim HxY: x :e Y.
    { exact (HBsubY x HxB). }
    claim HxX: x :e X.
    { exact (HY x HxY). }
    claim HnotForall: ~(forall W:set, W :e Tx -> x :e W -> exists y:set, y :e A /\ y <> x /\ y :e W).
    { assume Hforall.
      apply HnotLP.
      prove topology_on X Tx /\ x :e X /\ forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
      apply andI.
      - apply andI.
        + exact HTx.
        + exact HxX.
      - exact Hforall. }
    claim HexW: exists W:set, ~(W :e Tx -> x :e W -> exists y:set, y :e A /\ y <> x /\ y :e W).
    { exact (not_all_ex_demorgan_i (fun W:set => W :e Tx -> x :e W -> exists y:set, y :e A /\ y <> x /\ y :e W) HnotForall). }
    apply HexW.
    let W. assume HnImp.
    claim HWTx: W :e Tx.
    { apply (xm (W :e Tx)).
      - assume HW. exact HW.
      - assume HnotW.
        apply FalseE.
        apply HnImp.
        assume HW0: W :e Tx.
        assume HxW0: x :e W.
        apply FalseE.
        exact (HnotW HW0). }
    claim HxW: x :e W.
    { apply (xm (x :e W)).
      - assume Hx. exact Hx.
      - assume Hnotx.
        apply FalseE.
        apply HnImp.
        assume HW0: W :e Tx.
        assume HxW0: x :e W.
        apply FalseE.
        exact (Hnotx HxW0). }
    claim HnoY: ~(exists y:set, y :e A /\ y <> x /\ y :e W).
    { assume Hexy.
      apply HnImp.
      assume HW0: W :e Tx.
      assume HxW0: x :e W.
      exact Hexy. }
    set U := W :/\: Y.
    witness U.
    (** Bounded-exists goal is UTy  (xU  UB) **)
    apply andI.
    - (** U  subspace topology **)
      prove U :e subspace_topology X Tx Y.
      claim HUpowY: U :e Power Y.
      { apply PowerI.
        let t. assume Ht: t :e U.
        exact (binintersectE2 W Y t Ht). }
      claim HexWU: exists V :e Tx, U = V :/\: Y.
      { witness W.
        apply andI.
        - exact HWTx.
        - reflexivity. }
      exact (SepI (Power Y) (fun U0:set => exists V :e Tx, U0 = V :/\: Y) U HUpowY HexWU).
    - (** x  U  U  B **)
      apply andI.
      + exact (binintersectI W Y x HxW HxY).
      + prove U c= B.
        let t. assume Ht: t :e U.
        prove t :e B.
        claim HtY: t :e Y.
        { exact (binintersectE2 W Y t Ht). }
        claim HtnotA: t /:e A.
        { assume HtA: t :e A.
          apply HnoY.
          witness t.
          prove (t :e A /\ t <> x) /\ t :e W.
          apply andI.
          - apply andI.
            + exact HtA.
            + assume Heq: t = x.
              claim HxA: x :e A.
              { rewrite <- Heq. exact HtA. }
              claim HxAB: x :e A :/\: B.
              { exact (binintersectI A B x HxA HxB). }
              claim HxE: x :e Empty.
              { rewrite <- Hdisj. exact HxAB. }
              exact (EmptyE x HxE).
          - exact (binintersectE1 W Y t Ht). }
        claim HtAB: t :e A :\/: B.
        { rewrite Hunion. exact HtY. }
        apply (binunionE A B t HtAB).
        * assume HtA.
          apply FalseE.
          exact (HtnotA HtA).
        * assume HtB. exact HtB. }
  claim HBTy: B :e subspace_topology X Tx Y.
  { exact (andER (topology_on Y (subspace_topology X Tx Y)) (B :e subspace_topology X Tx Y) HBopen_in). }
  prove (A :e subspace_topology X Tx Y /\ B :e subspace_topology X Tx Y) /\ separation_of Y A B.
  apply andI.
  + apply andI.
    * exact HATy.
    * exact HBTy.
  + exact Hsep.
Qed.

(** from 23 Lemma 23.2: connected subspace lies in one side of a separation **)
(** LATEX VERSION: If C and D form a separation of X and Y is a connected subspace of X, then Y lies entirely within either C or D. **)
Theorem connected_subset_in_separation_side : forall X Tx C D Y:set,
  topology_on X Tx -> Y c= X ->
  connected_space Y (subspace_topology X Tx Y) ->
  C :e Tx -> D :e Tx -> separation_of X C D ->
  Y c= C \/ Y c= D.
let X Tx C D Y.
assume HTx: topology_on X Tx.
assume HYX: Y c= X.
assume HY: connected_space Y (subspace_topology X Tx Y).
assume HC: C :e Tx.
assume HD: D :e Tx.
assume Hsep: separation_of X C D.
prove Y c= C \/ Y c= D.
(** Proof by contradiction: if Y meets both C and D, then (CY) and (DY) separate Y. **)
apply (xm (Y c= C)).
- assume HYC: Y c= C.
  apply orIL.
  exact HYC.
- assume HnotYcC: ~(Y c= C).
  apply (xm (Y c= D)).
  + assume HYD: Y c= D.
    apply orIR.
    exact HYD.
  + assume HnotYcD: ~(Y c= D).
    (** Get yD in YD from not(YC) and CD=X **)
    claim HexYnotC: exists y:set, y :e Y /\ y /:e C.
    { claim Hex: exists y:set, ~(y :e Y -> y :e C).
      { exact (not_all_ex_demorgan_i (fun y:set => y :e Y -> y :e C) HnotYcC). }
      apply Hex.
      let y. assume Hnotimp.
      (** From ~(P -> Q), derive P and ~Q by contradiction. **)
      claim HyY: y :e Y.
      { apply (xm (y :e Y)).
        - assume HyY. exact HyY.
        - assume HyNotY.
          apply FalseE.
          apply Hnotimp.
          assume HyY: y :e Y.
          apply FalseE.
          exact (HyNotY HyY). }
      claim HyNotC: y /:e C.
      { assume HyC: y :e C.
        apply Hnotimp.
        assume _: y :e Y.
        exact HyC. }
      witness y.
      apply andI.
      - exact HyY.
      - exact HyNotC. }
    apply HexYnotC.
    let yD. assume HyDpair.
    claim HyDY: yD :e Y.
    { exact (andEL (yD :e Y) (yD /:e C) HyDpair). }
    claim HyDnotC: yD /:e C.
    { exact (andER (yD :e Y) (yD /:e C) HyDpair). }
    (** Extract union CD=X and C,D subset X from separation_of **)
    claim Hsep_left: ((((C :e Power X /\ D :e Power X) /\ C :/\: D = Empty) /\ C <> Empty) /\ D <> Empty).
    { exact (andEL ((((C :e Power X /\ D :e Power X) /\ C :/\: D = Empty) /\ C <> Empty) /\ D <> Empty)
                   (C :\/: D = X) Hsep). }
    claim Hsep_pow_disj: (C :e Power X /\ D :e Power X) /\ C :/\: D = Empty.
    { exact (andEL ((C :e Power X /\ D :e Power X) /\ C :/\: D = Empty)
                   (C <> Empty)
                   (andEL (((C :e Power X /\ D :e Power X) /\ C :/\: D = Empty) /\ C <> Empty)
                          (D <> Empty) Hsep_left)). }
    claim HCpow: C :e Power X.
    { exact (andEL (C :e Power X) (D :e Power X)
                   (andEL (C :e Power X /\ D :e Power X) (C :/\: D = Empty) Hsep_pow_disj)). }
    claim HDpow: D :e Power X.
    { exact (andER (C :e Power X) (D :e Power X)
                   (andEL (C :e Power X /\ D :e Power X) (C :/\: D = Empty) Hsep_pow_disj)). }
    claim HCsubX: C c= X.
    { exact (PowerE X C HCpow). }
    claim HDsubX: D c= X.
    { exact (PowerE X D HDpow). }
    claim HunionCD: C :\/: D = X.
    { exact (andER ((((C :e Power X /\ D :e Power X) /\ C :/\: D = Empty) /\ C <> Empty) /\ D <> Empty)
                   (C :\/: D = X) Hsep). }
    claim HyDX: yD :e X.
    { exact (HYX yD HyDY). }
    claim HyDinCD: yD :e C :\/: D.
    { rewrite HunionCD. exact HyDX. }
    claim HyDinD: yD :e D.
    { apply (binunionE C D yD HyDinCD).
      - assume HyDC: yD :e C.
        apply FalseE.
        exact (HyDnotC HyDC).
      - assume HyDD: yD :e D.
        exact HyDD. }

    (** Get yC in YC from not(YD) and CD=X **)
    claim HexYnotD: exists y:set, y :e Y /\ y /:e D.
    { claim Hex: exists y:set, ~(y :e Y -> y :e D).
      { exact (not_all_ex_demorgan_i (fun y:set => y :e Y -> y :e D) HnotYcD). }
      apply Hex.
      let y. assume Hnotimp.
      claim HyY: y :e Y.
      { apply (xm (y :e Y)).
        - assume HyY. exact HyY.
        - assume HyNotY.
          apply FalseE.
          apply Hnotimp.
          assume HyY: y :e Y.
          apply FalseE.
          exact (HyNotY HyY). }
      claim HyNotD: y /:e D.
      { assume HyD: y :e D.
        apply Hnotimp.
        assume _: y :e Y.
        exact HyD. }
      witness y.
      apply andI.
      - exact HyY.
      - exact HyNotD. }
    apply HexYnotD.
    let yC. assume HyCpair.
    claim HyCY: yC :e Y.
    { exact (andEL (yC :e Y) (yC /:e D) HyCpair). }
    claim HyCnotD: yC /:e D.
    { exact (andER (yC :e Y) (yC /:e D) HyCpair). }
    claim HyCX: yC :e X.
    { exact (HYX yC HyCY). }
    claim HyCinCD: yC :e C :\/: D.
    { rewrite HunionCD. exact HyCX. }
    claim HyCinC: yC :e C.
    { apply (binunionE C D yC HyCinCD).
      - assume HyCC: yC :e C.
        exact HyCC.
      - assume HyCD: yC :e D.
        apply FalseE.
        exact (HyCnotD HyCD). }

    (** Define A = CY and B = DY; show they are open in the subspace topology and form a separation of Y **)
    set A := C :/\: Y.
    set B := D :/\: Y.
    claim HAYsub: A c= Y.
    { exact (binintersect_Subq_2 C Y). }
    claim HBYsub: B c= Y.
    { exact (binintersect_Subq_2 D Y). }
    claim HAopenY: open_in Y (subspace_topology X Tx Y) A.
    { apply (iffER (open_in Y (subspace_topology X Tx Y) A)
                   (exists V :e Tx, A = V :/\: Y)
                   (open_in_subspace_iff X Tx Y A HTx HYX HAYsub)).
      witness C.
      apply andI.
      - exact HC.
      - prove A = C :/\: Y.
        reflexivity. }
    claim HBopenY: open_in Y (subspace_topology X Tx Y) B.
    { apply (iffER (open_in Y (subspace_topology X Tx Y) B)
                   (exists V :e Tx, B = V :/\: Y)
                   (open_in_subspace_iff X Tx Y B HTx HYX HBYsub)).
      witness D.
      apply andI.
      - exact HD.
      - prove B = D :/\: Y.
        reflexivity. }
    claim HAinSub: A :e subspace_topology X Tx Y.
    { exact (andER (topology_on Y (subspace_topology X Tx Y)) (A :e subspace_topology X Tx Y) HAopenY). }
    claim HBinSub: B :e subspace_topology X Tx Y.
    { exact (andER (topology_on Y (subspace_topology X Tx Y)) (B :e subspace_topology X Tx Y) HBopenY). }
    (** separation_of Y A B **)
    claim HsepAB: separation_of Y A B.
    { prove A :e Power Y /\ B :e Power Y /\ A :/\: B = Empty /\ A <> Empty /\ B <> Empty /\ A :\/: B = Y.
      apply andI.
      - prove ((((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty) /\ B <> Empty).
        apply andI.
        + prove (((A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty) /\ A <> Empty).
          apply andI.
          - prove (A :e Power Y /\ B :e Power Y) /\ A :/\: B = Empty.
            apply andI.
            + prove A :e Power Y /\ B :e Power Y.
              apply andI.
              - exact (PowerI Y A HAYsub).
              - exact (PowerI Y B HBYsub).
            + prove A :/\: B = Empty.
              apply Empty_eq.
              let t. assume Ht: t :e A :/\: B.
              apply (binintersectE A B t Ht).
              assume HtA: t :e A.
              assume HtB: t :e B.
              (** t in C and D, so t in CD, contradiction **)
              claim HtC: t :e C.
              { exact (binintersectE1 C Y t HtA). }
              claim HtD: t :e D.
              { exact (binintersectE1 D Y t HtB). }
              claim HtCD: t :e C :/\: D.
              { exact (binintersectI C D t HtC HtD). }
              claim HCDdisj: C :/\: D = Empty.
              { exact (andER (C :e Power X /\ D :e Power X) (C :/\: D = Empty) Hsep_pow_disj). }
              claim Hfalse: t :e Empty.
              { rewrite <- HCDdisj. exact HtCD. }
              exact (EmptyE t Hfalse).
          - (** A <> Empty using yC **)
            assume Heq: A = Empty.
            claim HyCA: yC :e A.
            { exact (binintersectI C Y yC HyCinC HyCY). }
            claim HyCEmpty: yC :e Empty.
            { rewrite <- Heq. exact HyCA. }
            exact (EmptyE yC HyCEmpty).
        + (** B <> Empty using yD **)
          assume Heq: B = Empty.
          claim HyDB: yD :e B.
          { exact (binintersectI D Y yD HyDinD HyDY). }
          claim HyDEmpty: yD :e Empty.
          { rewrite <- Heq. exact HyDB. }
          exact (EmptyE yD HyDEmpty).
      - prove A :\/: B = Y.
        apply set_ext.
        + let t. assume Ht: t :e A :\/: B.
          prove t :e Y.
          apply (binunionE A B t Ht).
          - assume HtA: t :e A.
            exact (binintersectE2 C Y t HtA).
          - assume HtB: t :e B.
            exact (binintersectE2 D Y t HtB).
        + let t. assume HtY: t :e Y.
          prove t :e A :\/: B.
          claim HtX: t :e X.
          { exact (HYX t HtY). }
          claim HtCD: t :e C :\/: D.
          { rewrite HunionCD. exact HtX. }
          apply (binunionE C D t HtCD).
          - assume HtC: t :e C.
            apply binunionI1.
            exact (binintersectI C Y t HtC HtY).
          - assume HtD: t :e D.
            apply binunionI2.
            exact (binintersectI D Y t HtD HtY). }
    (** Contradiction with connectedness of Y **)
    claim HnosepY: ~(exists U V:set,
      U :e subspace_topology X Tx Y /\ V :e subspace_topology X Tx Y /\ separation_of Y U V).
    { exact (andER (topology_on Y (subspace_topology X Tx Y))
                   (~(exists U V:set, U :e subspace_topology X Tx Y /\ V :e subspace_topology X Tx Y /\ separation_of Y U V))
                   HY). }
    apply FalseE.
    apply HnosepY.
    witness A.
    witness B.
    prove A :e subspace_topology X Tx Y /\ B :e subspace_topology X Tx Y /\ separation_of Y A B.
    apply andI.
    - apply andI.
      + exact HAinSub.
      + exact HBinSub.
    - exact HsepAB.
Qed.

(** from 23 Theorem 23.3: union of connected sets with common point is connected **)
(** LATEX VERSION: If each A is connected and the A have a point in common, then their union is connected. **)
Theorem union_connected_common_point : forall X Tx F:set,
  topology_on X Tx ->
  (forall C:set, C :e F -> C c= X) ->
  (forall C:set, C :e F -> connected_space C (subspace_topology X Tx C)) ->
  (exists x:set, forall C:set, C :e F -> x :e C) ->
  connected_space (Union F) (subspace_topology X Tx (Union F)).
let X Tx F.
assume HTx: topology_on X Tx.
assume HFsub: forall C:set, C :e F -> C c= X.
assume HF: forall C:set, C :e F -> connected_space C (subspace_topology X Tx C).
assume Hcommon: exists x:set, forall C:set, C :e F -> x :e C.
prove connected_space (Union F) (subspace_topology X Tx (Union F)).
prove topology_on (Union F) (subspace_topology X Tx (Union F)) /\
  ~(exists U V:set, U :e subspace_topology X Tx (Union F) /\ V :e subspace_topology X Tx (Union F) /\ separation_of (Union F) U V).
(** Precompute Union(F)  X so we can use subspace topology lemmas. **)
claim HFpow: F c= Power X.
{ let C. assume HC: C :e F.
  prove C :e Power X.
  exact (PowerI X C (HFsub C HC)). }
claim HUnionSubX: Union F c= X.
{ exact (Union_Power X F HFpow). }
claim HtopUnion: topology_on (Union F) (subspace_topology X Tx (Union F)).
{ exact (subspace_topology_is_topology X Tx (Union F) HTx HUnionSubX). }
apply andI.
- exact HtopUnion.
- prove ~(exists U V:set, U :e subspace_topology X Tx (Union F) /\ V :e subspace_topology X Tx (Union F) /\ separation_of (Union F) U V).
  assume HsepExists: exists U V:set, U :e subspace_topology X Tx (Union F) /\ V :e subspace_topology X Tx (Union F) /\ separation_of (Union F) U V.
  prove False.
  (** Choose the common point x0. **)
  apply Hcommon.
  let x0. assume Hx0All: forall C:set, C :e F -> x0 :e C.
  (** Unpack the supposed separation. **)
  apply HsepExists.
  let U. assume HexV: exists V:set, U :e subspace_topology X Tx (Union F) /\ V :e subspace_topology X Tx (Union F) /\ separation_of (Union F) U V.
  apply HexV.
  let V. assume HUVsep.
  claim HUVopen: U :e subspace_topology X Tx (Union F) /\ V :e subspace_topology X Tx (Union F).
  { exact (andEL (U :e subspace_topology X Tx (Union F) /\ V :e subspace_topology X Tx (Union F))
                 (separation_of (Union F) U V) HUVsep). }
  claim HUopen: U :e subspace_topology X Tx (Union F).
  { exact (andEL (U :e subspace_topology X Tx (Union F)) (V :e subspace_topology X Tx (Union F)) HUVopen). }
  claim HVopen: V :e subspace_topology X Tx (Union F).
  { exact (andER (U :e subspace_topology X Tx (Union F)) (V :e subspace_topology X Tx (Union F)) HUVopen). }
  claim Hsep: separation_of (Union F) U V.
  { exact (andER (U :e subspace_topology X Tx (Union F) /\ V :e subspace_topology X Tx (Union F))
                 (separation_of (Union F) U V) HUVsep). }
  (** Extract useful facts from separation_of. **)
  claim Hpart1: ((((U :e Power (Union F) /\ V :e Power (Union F)) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty).
  { exact (andEL ((((U :e Power (Union F) /\ V :e Power (Union F)) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                 (U :\/: V = Union F) Hsep). }
  claim Hunion: U :\/: V = Union F.
  { exact (andER ((((U :e Power (Union F) /\ V :e Power (Union F)) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                 (U :\/: V = Union F) Hsep). }
  claim HAux: (((U :e Power (Union F) /\ V :e Power (Union F)) /\ U :/\: V = Empty) /\ U <> Empty).
  { exact (andEL (((U :e Power (Union F) /\ V :e Power (Union F)) /\ U :/\: V = Empty) /\ U <> Empty)
                 (V <> Empty) Hpart1). }
  claim HVne: V <> Empty.
  { exact (andER (((U :e Power (Union F) /\ V :e Power (Union F)) /\ U :/\: V = Empty) /\ U <> Empty)
                 (V <> Empty) Hpart1). }
  claim Hpowdisj: (U :e Power (Union F) /\ V :e Power (Union F)) /\ U :/\: V = Empty.
  { exact (andEL ((U :e Power (Union F) /\ V :e Power (Union F)) /\ U :/\: V = Empty)
                 (U <> Empty) HAux). }
  claim HUne: U <> Empty.
  { exact (andER ((U :e Power (Union F) /\ V :e Power (Union F)) /\ U :/\: V = Empty)
                 (U <> Empty) HAux). }
  claim Hpow: U :e Power (Union F) /\ V :e Power (Union F).
  { exact (andEL (U :e Power (Union F) /\ V :e Power (Union F)) (U :/\: V = Empty) Hpowdisj). }
  claim Hdisj: U :/\: V = Empty.
  { exact (andER (U :e Power (Union F) /\ V :e Power (Union F)) (U :/\: V = Empty) Hpowdisj). }
  claim HUpow: U :e Power (Union F).
  { exact (andEL (U :e Power (Union F)) (V :e Power (Union F)) Hpow). }
  claim HVpow: V :e Power (Union F).
  { exact (andER (U :e Power (Union F)) (V :e Power (Union F)) Hpow). }
  claim HUsub: U c= Union F.
  { exact (PowerE (Union F) U HUpow). }
  claim HVsub: V c= Union F.
  { exact (PowerE (Union F) V HVpow). }
  (** Get some point v0 in V, hence in Union(F), hence in some member C0 of F. **)
  claim Hexv0: exists v0:set, v0 :e V.
  { exact (nonempty_has_element V HVne). }
  apply Hexv0.
  let v0. assume Hv0V: v0 :e V.
  claim Hv0Union: v0 :e Union F.
  { exact (HVsub v0 Hv0V). }
  apply (UnionE_impred F v0 Hv0Union).
  let C0. assume Hv0C0: v0 :e C0. assume HC0F: C0 :e F.
  claim Hx0C0: x0 :e C0.
  { exact (Hx0All C0 HC0F). }
  claim Hx0Union: x0 :e Union F.
  { exact (UnionI F x0 C0 Hx0C0 HC0F). }
  (** Now x0 is in U or V, by U  V = Union(F). **)
  claim Hx0UV: x0 :e U :\/: V.
  { rewrite Hunion. exact Hx0Union. }
  apply (binunionE U V x0 Hx0UV).
  - (** Case: x0  U **)
    assume Hx0U: x0 :e U.
    (** Show Union(F)  U by showing each C  F is contained in U. **)
    claim HUnionSubU: Union F c= U.
    { let y. assume HyUnion: y :e Union F.
      prove y :e U.
      apply (UnionE_impred F y HyUnion (y :e U)).
      let C. assume HyC: y :e C. assume HC: C :e F.
      (** C  Union(F) **)
      claim HCsubUnion: C c= Union F.
      { let z. assume Hz: z :e C.
        exact (UnionI F z C Hz HC). }
      (** Connectedness of C as a subspace of Union(F) **)
      claim HeqTop: subspace_topology (Union F) (subspace_topology X Tx (Union F)) C =
                    subspace_topology X Tx C.
      { exact (ex16_1_subspace_transitive X Tx (Union F) C HTx HUnionSubX HCsubUnion). }
      claim HCconn: connected_space C (subspace_topology (Union F) (subspace_topology X Tx (Union F)) C).
      { rewrite HeqTop. exact (HF C HC). }
      claim HCside: C c= U \/ C c= V.
      { exact (connected_subset_in_separation_side (Union F) (subspace_topology X Tx (Union F)) U V C
                HtopUnion HCsubUnion HCconn HUopen HVopen Hsep). }
      apply HCside.
      + assume HCsubU: C c= U.
        exact (HCsubU y HyC).
      + assume HCsubV: C c= V.
        (** Contradiction with disjointness, since x0  C and x0  U. **)
        claim Hx0C: x0 :e C.
        { exact (Hx0All C HC). }
        claim Hx0V: x0 :e V.
        { exact (HCsubV x0 Hx0C). }
        claim Hx0UV2: x0 :e U :/\: V.
        { exact (binintersectI U V x0 Hx0U Hx0V). }
        claim Hx0E: x0 :e Empty.
        { rewrite <- Hdisj. exact Hx0UV2. }
        apply FalseE.
        exact (EmptyE x0 Hx0E). }
    (** If Union(F)  U, then V  U; but UV=, so V=, contradicting V. **)
    claim HVsubU: V c= U.
    { let y. assume HyV: y :e V.
      exact (HUnionSubU y (HVsub y HyV)). }
    claim HVsubEmpty: V c= Empty.
    { let y. assume HyV: y :e V.
      prove y :e Empty.
      claim HyU: y :e U.
      { exact (HVsubU y HyV). }
      claim HyUV: y :e U :/\: V.
      { exact (binintersectI U V y HyU HyV). }
      rewrite <- Hdisj.
      exact HyUV. }
    claim HVEmpty: V = Empty.
    { exact (Empty_Subq_eq V HVsubEmpty). }
    exact (HVne HVEmpty).
  - (** Case: x0  V (symmetric) **)
    assume Hx0V: x0 :e V.
    claim HUnionSubV: Union F c= V.
    { let y. assume HyUnion: y :e Union F.
      prove y :e V.
      apply (UnionE_impred F y HyUnion (y :e V)).
      let C. assume HyC: y :e C. assume HC: C :e F.
      claim HCsubUnion: C c= Union F.
      { let z. assume Hz: z :e C.
        exact (UnionI F z C Hz HC). }
      claim HeqTop: subspace_topology (Union F) (subspace_topology X Tx (Union F)) C =
                    subspace_topology X Tx C.
      { exact (ex16_1_subspace_transitive X Tx (Union F) C HTx HUnionSubX HCsubUnion). }
      claim HCconn: connected_space C (subspace_topology (Union F) (subspace_topology X Tx (Union F)) C).
      { rewrite HeqTop. exact (HF C HC). }
      claim HCside: C c= U \/ C c= V.
      { exact (connected_subset_in_separation_side (Union F) (subspace_topology X Tx (Union F)) U V C
                HtopUnion HCsubUnion HCconn HUopen HVopen Hsep). }
      apply HCside.
      + assume HCsubU: C c= U.
        claim Hx0C: x0 :e C.
        { exact (Hx0All C HC). }
        claim Hx0U: x0 :e U.
        { exact (HCsubU x0 Hx0C). }
        claim Hx0UV2: x0 :e U :/\: V.
        { exact (binintersectI U V x0 Hx0U Hx0V). }
        claim Hx0E: x0 :e Empty.
        { rewrite <- Hdisj. exact Hx0UV2. }
        apply FalseE.
        exact (EmptyE x0 Hx0E).
      + assume HCsubV: C c= V.
        exact (HCsubV y HyC). }
    claim HUne: U <> Empty.
    { exact HUne. }
    claim HUsubV: U c= V.
    { let y. assume HyU: y :e U.
      (** U  Union(F) by HUsub, and Union(F)  V by HUnionSubV **)
      exact (HUnionSubV y (HUsub y HyU)). }
    claim HUsubEmpty: U c= Empty.
    { let y. assume HyU: y :e U.
      prove y :e Empty.
      claim HyV: y :e V.
      { exact (HUsubV y HyU). }
      claim HyUV: y :e U :/\: V.
      { exact (binintersectI U V y HyU HyV). }
      rewrite <- Hdisj.
      exact HyUV. }
    claim HUEmpty: U = Empty.
    { exact (Empty_Subq_eq U HUsubEmpty). }
    exact (HUne HUEmpty).
Qed.

(** from 23 Theorem 23.4: adjoining limit points preserves connectedness **)
(** LATEX VERSION: If A is connected and A  B  cl(A), then B is connected. **)
Theorem connected_with_limit_points : forall X Tx A B:set,
  topology_on X Tx -> A c= X -> B c= X ->
  connected_space A (subspace_topology X Tx A) ->
  A c= B -> B c= closure_of X Tx A ->
  connected_space B (subspace_topology X Tx B).
let X Tx A B.
assume HTx: topology_on X Tx.
assume HAX: A c= X.
assume HBX: B c= X.
assume HA: connected_space A (subspace_topology X Tx A).
assume HAB: A c= B.
assume HBcl: B c= closure_of X Tx A.
prove connected_space B (subspace_topology X Tx B).
prove topology_on B (subspace_topology X Tx B) /\
  ~(exists U V:set, U :e subspace_topology X Tx B /\ V :e subspace_topology X Tx B /\ separation_of B U V).
claim HtopB: topology_on B (subspace_topology X Tx B).
{ exact (subspace_topology_is_topology X Tx B HTx HBX). }
apply andI.
- exact HtopB.
- prove ~(exists U V:set, U :e subspace_topology X Tx B /\ V :e subspace_topology X Tx B /\ separation_of B U V).
  assume HsepExists: exists U V:set, U :e subspace_topology X Tx B /\ V :e subspace_topology X Tx B /\ separation_of B U V.
  prove False.
  apply HsepExists.
  let U. assume HexV: exists V:set, U :e subspace_topology X Tx B /\ V :e subspace_topology X Tx B /\ separation_of B U V.
  apply HexV.
  let V. assume HUVsep.
  claim HUVopen: U :e subspace_topology X Tx B /\ V :e subspace_topology X Tx B.
  { exact (andEL (U :e subspace_topology X Tx B /\ V :e subspace_topology X Tx B) (separation_of B U V) HUVsep). }
  claim HUopen: U :e subspace_topology X Tx B.
  { exact (andEL (U :e subspace_topology X Tx B) (V :e subspace_topology X Tx B) HUVopen). }
  claim HVopen: V :e subspace_topology X Tx B.
  { exact (andER (U :e subspace_topology X Tx B) (V :e subspace_topology X Tx B) HUVopen). }
  claim Hsep: separation_of B U V.
  { exact (andER (U :e subspace_topology X Tx B /\ V :e subspace_topology X Tx B) (separation_of B U V) HUVsep). }
  (** Parts of the separation **)
  claim Hpart1: ((((U :e Power B /\ V :e Power B) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty).
  { exact (andEL ((((U :e Power B /\ V :e Power B) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                 (U :\/: V = B) Hsep). }
  claim HAux: (((U :e Power B /\ V :e Power B) /\ U :/\: V = Empty) /\ U <> Empty).
  { exact (andEL (((U :e Power B /\ V :e Power B) /\ U :/\: V = Empty) /\ U <> Empty)
                 (V <> Empty) Hpart1). }
  claim HVne: V <> Empty.
  { exact (andER (((U :e Power B /\ V :e Power B) /\ U :/\: V = Empty) /\ U <> Empty)
                 (V <> Empty) Hpart1). }
  claim HUne: U <> Empty.
  { exact (andER ((U :e Power B /\ V :e Power B) /\ U :/\: V = Empty) (U <> Empty) HAux). }
  claim Hpowdisj: (U :e Power B /\ V :e Power B) /\ U :/\: V = Empty.
  { exact (andEL ((U :e Power B /\ V :e Power B) /\ U :/\: V = Empty) (U <> Empty) HAux). }
  claim Hpow: U :e Power B /\ V :e Power B.
  { exact (andEL (U :e Power B /\ V :e Power B) (U :/\: V = Empty) Hpowdisj). }
  claim Hdisj: U :/\: V = Empty.
  { exact (andER (U :e Power B /\ V :e Power B) (U :/\: V = Empty) Hpowdisj). }
  claim HUpow: U :e Power B.
  { exact (andEL (U :e Power B) (V :e Power B) Hpow). }
  claim HVpow: V :e Power B.
  { exact (andER (U :e Power B) (V :e Power B) Hpow). }
  claim HUsubB: U c= B.
  { exact (PowerE B U HUpow). }
  claim HVsubB: V c= B.
  { exact (PowerE B V HVpow). }
  (** Connectedness of A as a subspace of B (rewrite via subspace transitivity). **)
  claim HeqTopA: subspace_topology B (subspace_topology X Tx B) A = subspace_topology X Tx A.
  { exact (ex16_1_subspace_transitive X Tx B A HTx HBX HAB). }
  claim HAconnB: connected_space A (subspace_topology B (subspace_topology X Tx B) A).
  { rewrite HeqTopA. exact HA. }
  (** Apply Lemma 23.2 inside the space B. **)
  claim HA_side: A c= U \/ A c= V.
  { exact (connected_subset_in_separation_side B (subspace_topology X Tx B) U V A
            HtopB HAB HAconnB HUopen HVopen Hsep). }
  apply HA_side.
  - (** Case A  U: then V must be empty using B  cl(A). **)
    assume HAU: A c= U.
    (** Pick v  V. **)
    claim Hexv: exists v:set, v :e V.
    { exact (nonempty_has_element V HVne). }
    apply Hexv.
    let v. assume HvV: v :e V.
    claim HvB: v :e B.
    { exact (HVsubB v HvV). }
    claim Hvcl: v :e closure_of X Tx A.
    { exact (HBcl v HvB). }
    (** V open in the subspace, so V = W  B for some W open in X. **)
    claim HexW: exists W :e Tx, V = W :/\: B.
    { exact (SepE2 (Power B) (fun V0:set => exists W :e Tx, V0 = W :/\: B) V HVopen). }
    apply HexW.
    let W. assume HWpair.
    claim HWopen: W :e Tx.
    { exact (andEL (W :e Tx) (V = W :/\: B) HWpair). }
    claim HVeql: V = W :/\: B.
    { exact (andER (W :e Tx) (V = W :/\: B) HWpair). }
    claim HvWB: v :e W :/\: B.
    { rewrite <- HVeql. exact HvV. }
    claim HvW: v :e W.
    { exact (binintersectE1 W B v HvWB). }
    (** Use closure definition: W  A   **)
    claim Hclcond: forall U0:set, U0 :e Tx -> v :e U0 -> U0 :/\: A <> Empty.
    { exact (SepE2 X (fun x0 => forall U0:set, U0 :e Tx -> x0 :e U0 -> U0 :/\: A <> Empty) v Hvcl). }
    claim HWAnE: W :/\: A <> Empty.
    { exact (Hclcond W HWopen HvW). }
    (** Choose a  W  A. **)
    apply (nonempty_has_element (W :/\: A) HWAnE).
    let a. assume HaWA: a :e W :/\: A.
    claim HaW: a :e W.
    { exact (binintersectE1 W A a HaWA). }
    claim HaA: a :e A.
    { exact (binintersectE2 W A a HaWA). }
    claim HaB: a :e B.
    { exact (HAB a HaA). }
    claim HaWB: a :e W :/\: B.
    { exact (binintersectI W B a HaW HaB). }
    claim HaV: a :e V.
    { rewrite HVeql. exact HaWB. }
    claim HaU: a :e U.
    { exact (HAU a HaA). }
    claim HaUV: a :e U :/\: V.
    { exact (binintersectI U V a HaU HaV). }
    claim HaE: a :e Empty.
    { rewrite <- Hdisj. exact HaUV. }
    exact (EmptyE a HaE).
  - (** Case A  V: symmetric, U must be empty. **)
    assume HAV: A c= V.
    claim Hexu: exists u:set, u :e U.
    { exact (nonempty_has_element U HUne). }
    apply Hexu.
    let u. assume HuU: u :e U.
    claim HuB: u :e B.
    { exact (HUsubB u HuU). }
    claim Hucl: u :e closure_of X Tx A.
    { exact (HBcl u HuB). }
    claim HexW: exists W :e Tx, U = W :/\: B.
    { exact (SepE2 (Power B) (fun U0:set => exists W :e Tx, U0 = W :/\: B) U HUopen). }
    apply HexW.
    let W. assume HWpair.
    claim HWopen: W :e Tx.
    { exact (andEL (W :e Tx) (U = W :/\: B) HWpair). }
    claim HUeql: U = W :/\: B.
    { exact (andER (W :e Tx) (U = W :/\: B) HWpair). }
    claim HuWB: u :e W :/\: B.
    { rewrite <- HUeql. exact HuU. }
    claim HuW: u :e W.
    { exact (binintersectE1 W B u HuWB). }
    claim Hclcond: forall U0:set, U0 :e Tx -> u :e U0 -> U0 :/\: A <> Empty.
    { exact (SepE2 X (fun x0 => forall U0:set, U0 :e Tx -> x0 :e U0 -> U0 :/\: A <> Empty) u Hucl). }
    claim HWAnE: W :/\: A <> Empty.
    { exact (Hclcond W HWopen HuW). }
    apply (nonempty_has_element (W :/\: A) HWAnE).
    let a. assume HaWA: a :e W :/\: A.
    claim HaW: a :e W.
    { exact (binintersectE1 W A a HaWA). }
    claim HaA: a :e A.
    { exact (binintersectE2 W A a HaWA). }
    claim HaB: a :e B.
    { exact (HAB a HaA). }
    claim HaWB: a :e W :/\: B.
    { exact (binintersectI W B a HaW HaB). }
    claim HaU: a :e U.
    { rewrite HUeql. exact HaWB. }
    claim HaV: a :e V.
    { exact (HAV a HaA). }
    claim HaUV: a :e U :/\: V.
    { exact (binintersectI U V a HaU HaV). }
    claim HaE: a :e Empty.
    { rewrite <- Hdisj. exact HaUV. }
    exact (EmptyE a HaE).
Qed.

(** from 23 Theorem 23.5: image of a connected space is connected **)
(** LATEX VERSION: If f:XY is continuous and X is connected, then f(X) is connected (as a subspace of Y). **)
Axiom continuous_image_connected_axiom : forall X Tx Y Ty f:set,
  connected_space X Tx ->
  continuous_map X Tx Y Ty f ->
  connected_space (image_of f X) (subspace_topology Y Ty (image_of f X)).

(** from 23 Theorem 23.5: image of a connected space is connected **)
Theorem continuous_image_connected : forall X Tx Y Ty f:set,
  connected_space X Tx ->
  continuous_map X Tx Y Ty f ->
  connected_space (image_of f X) (subspace_topology Y Ty (image_of f X)).
let X Tx Y Ty f.
assume HX: connected_space X Tx.
assume Hf: continuous_map X Tx Y Ty f.
prove connected_space (image_of f X) (subspace_topology Y Ty (image_of f X)).
exact (continuous_image_connected_axiom X Tx Y Ty f HX Hf).
Qed.

(** from 24 Corollary 24.2: the real line is connected **)
(** LATEX VERSION: Corollary 24.2: The real line R is connected (and so are intervals and rays in R). **)
Axiom interval_connected_axiom : connected_space R R_standard_topology.

(** from 24 Corollary 24.2: the real line is connected **)
Theorem interval_connected : connected_space R R_standard_topology.
exact interval_connected_axiom.
Qed.

(** from 24 Theorem 24.3: intermediate value theorem (order topology) **)
(** LATEX VERSION: If f:XY is continuous, X is connected, and r lies between f(a) and f(b), then cX with f(c)=r. **)
Definition between_in_order : set -> set -> set -> set -> prop := fun Y u r v =>
  (order_rel Y u r /\ order_rel Y r v)
  \/ (order_rel Y v r /\ order_rel Y r u)
  \/ r = u
  \/ r = v.

(** from 24 Theorem 24.3: intermediate value theorem (order topology) **)
Axiom intermediate_value_theorem_axiom : forall X Tx Y f a b r:set,
  connected_space X Tx ->
  continuous_map X Tx Y (order_topology Y) f ->
  a :e X -> b :e X -> r :e Y ->
  between_in_order Y (apply_fun f a) r (apply_fun f b) ->
  exists c:set, c :e X /\ apply_fun f c = r.

(** from 24 Theorem 24.3: intermediate value theorem (order topology) **)
Theorem intermediate_value_theorem : forall X Tx Y f a b r:set,
  connected_space X Tx ->
  continuous_map X Tx Y (order_topology Y) f ->
  a :e X -> b :e X -> r :e Y ->
  between_in_order Y (apply_fun f a) r (apply_fun f b) ->
  exists c:set, c :e X /\ apply_fun f c = r.
let X Tx Y f a b r.
assume Hconn: connected_space X Tx.
assume Hcont: continuous_map X Tx Y (order_topology Y) f.
assume Ha: a :e X.
assume Hb: b :e X.
assume Hr: r :e Y.
assume Hbetw: between_in_order Y (apply_fun f a) r (apply_fun f b).
prove exists c:set, c :e X /\ apply_fun f c = r.
exact (intermediate_value_theorem_axiom X Tx Y f a b r Hconn Hcont Ha Hb Hr Hbetw).
Qed.

(** from 24: connected subspaces of  are intervals **) 
Theorem connected_subsets_real_are_intervals : forall A:set,
  A c= R ->
  connected_space A (subspace_topology R R_standard_topology A) ->
  forall x y z:set, x :e A -> y :e A -> z :e R ->
    (Rlt x z /\ Rlt z y \/ Rlt y z /\ Rlt z x) -> z :e A.
let A.
assume HA: A c= R.
assume Hconn: connected_space A (subspace_topology R R_standard_topology A).
let x y z.
assume Hx: x :e A.
assume Hy: y :e A.
assume Hz: z :e R.
assume Hbetw: Rlt x z /\ Rlt z y \/ Rlt y z /\ Rlt z x.
prove z :e A.
apply (xm (z :e A)).
- assume HzA: z :e A.
  exact HzA.
- assume HznotA: z /:e A.
  (** If z  A, define U = A(-,z) and V = A(z,), show they separate A. **)
  set U := {t :e A|Rlt t z}.
  set V := {t :e A|Rlt z t}.
  (** Extract no separations from connectedness of A. **)
  claim Hnosep: ~(exists U0 V0:set,
      U0 :e subspace_topology R R_standard_topology A /\
      V0 :e subspace_topology R R_standard_topology A /\
      separation_of A U0 V0).
  { exact (andER (topology_on A (subspace_topology R R_standard_topology A))
                 (~(exists U0 V0:set, U0 :e subspace_topology R R_standard_topology A /\
                                   V0 :e subspace_topology R R_standard_topology A /\
                                   separation_of A U0 V0))
                 Hconn). }
  (** Show U and V are in the subspace topology on A. **)
  claim HUinTy: U :e subspace_topology R R_standard_topology A.
  { (** witness the open left ray in R **)
    set L := {t :e R|Rlt t z}.
    claim HLopen: L :e R_standard_topology.
    { exact (open_left_ray_in_R_standard_topology z Hz). }
    claim HUeq: U = L :/\: A.
    { apply set_ext.
      - let t. assume Ht: t :e U.
        prove t :e L :/\: A.
        claim HtA: t :e A.
        { exact (SepE1 A (fun t0:set => Rlt t0 z) t Ht). }
        claim HtR: t :e R.
        { exact (HA t HtA). }
        claim Htlt: Rlt t z.
        { exact (SepE2 A (fun t0:set => Rlt t0 z) t Ht). }
        claim HtL: t :e L.
        { exact (SepI R (fun t0:set => Rlt t0 z) t HtR Htlt). }
        exact (binintersectI L A t HtL HtA).
      - let t. assume Ht: t :e L :/\: A.
        prove t :e U.
        claim HtL: t :e L.
        { exact (binintersectE1 L A t Ht). }
        claim HtA: t :e A.
        { exact (binintersectE2 L A t Ht). }
        claim Htlt: Rlt t z.
        { exact (SepE2 R (fun t0:set => Rlt t0 z) t HtL). }
        exact (SepI A (fun t0:set => Rlt t0 z) t HtA Htlt). }
    (** Now package membership in the subspace topology. **)
    claim HUpow: U :e Power A.
    { apply PowerI.
      let t. assume Ht: t :e U.
      exact (SepE1 A (fun t0:set => Rlt t0 z) t Ht). }
    claim Hex: exists W :e R_standard_topology, U = W :/\: A.
    { witness L.
      apply andI.
      - exact HLopen.
      - exact HUeq. }
    exact (SepI (Power A) (fun U0:set => exists W :e R_standard_topology, U0 = W :/\: A) U HUpow Hex). }
  claim HVinTy: V :e subspace_topology R R_standard_topology A.
  { set Rray := {t :e R|Rlt z t}.
    claim HRopen: Rray :e R_standard_topology.
    { exact (open_ray_in_R_standard_topology z Hz). }
    claim HVeql: V = Rray :/\: A.
    { apply set_ext.
      - let t. assume Ht: t :e V.
        prove t :e Rray :/\: A.
        claim HtA: t :e A.
        { exact (SepE1 A (fun t0:set => Rlt z t0) t Ht). }
        claim HtR: t :e R.
        { exact (HA t HtA). }
        claim Htlt: Rlt z t.
        { exact (SepE2 A (fun t0:set => Rlt z t0) t Ht). }
        claim HtRray: t :e Rray.
        { exact (SepI R (fun t0:set => Rlt z t0) t HtR Htlt). }
        exact (binintersectI Rray A t HtRray HtA).
      - let t. assume Ht: t :e Rray :/\: A.
        prove t :e V.
        claim HtRray: t :e Rray.
        { exact (binintersectE1 Rray A t Ht). }
        claim HtA: t :e A.
        { exact (binintersectE2 Rray A t Ht). }
        claim Htlt: Rlt z t.
        { exact (SepE2 R (fun t0:set => Rlt z t0) t HtRray). }
        exact (SepI A (fun t0:set => Rlt z t0) t HtA Htlt). }
    claim HVpow: V :e Power A.
    { apply PowerI.
      let t. assume Ht: t :e V.
      exact (SepE1 A (fun t0:set => Rlt z t0) t Ht). }
    claim Hex: exists W :e R_standard_topology, V = W :/\: A.
    { witness Rray.
      apply andI.
      - exact HRopen.
      - exact HVeql. }
    exact (SepI (Power A) (fun U0:set => exists W :e R_standard_topology, U0 = W :/\: A) V HVpow Hex). }
  (** Build a separation_of A U V. **)
  claim HsepUV: separation_of A U V.
  { (** U,V  A **)
    claim HUsubA: U c= A.
    { let t. assume Ht: t :e U.
      exact (SepE1 A (fun t0:set => Rlt t0 z) t Ht). }
    claim HVsubA: V c= A.
    { let t. assume Ht: t :e V.
      exact (SepE1 A (fun t0:set => Rlt z t0) t Ht). }
    claim HUpowA: U :e Power A.
    { exact (PowerI A U HUsubA). }
    claim HVpowA: V :e Power A.
    { exact (PowerI A V HVsubA). }
    (** disjointness **)
    claim Hdisj: U :/\: V = Empty.
    { apply Empty_eq.
      let t. assume Ht: t :e U :/\: V.
      apply (binintersectE U V t Ht).
      assume HtU: t :e U.
      assume HtV: t :e V.
      claim HtA: t :e A.
      { exact (SepE1 A (fun t0:set => Rlt t0 z) t HtU). }
      claim HtR: t :e R.
      { exact (HA t HtA). }
      claim Hlt1: Rlt t z.
      { exact (SepE2 A (fun t0:set => Rlt t0 z) t HtU). }
      claim Hlt2: Rlt z t.
      { exact (SepE2 A (fun t0:set => Rlt z t0) t HtV). }
      claim Htt: Rlt t t.
      { exact (Rlt_tra t z t Hlt1 Hlt2). }
      apply FalseE.
      exact ((not_Rlt_refl t HtR) Htt). }
    (** Nonemptiness of U and V using x,y around z **)
    claim HUne: U <> Empty.
    { apply (xm (Rlt x z /\ Rlt z y)).
      - assume Hxzzy: Rlt x z /\ Rlt z y.
        claim Hxz: Rlt x z.
        { exact (andEL (Rlt x z) (Rlt z y) Hxzzy). }
        claim HxU: x :e U.
        { exact (SepI A (fun t0:set => Rlt t0 z) x Hx Hxz). }
        exact (elem_implies_nonempty U x HxU).
      - assume Hnot.
        (** then use the other disjunct from Hbetw **)
        claim Hyz: Rlt y z.
        { apply Hbetw.
          assume Hxzzy: Rlt x z /\ Rlt z y.
          apply FalseE.
          exact (Hnot Hxzzy).
          assume Hyzzx: Rlt y z /\ Rlt z x.
          exact (andEL (Rlt y z) (Rlt z x) Hyzzx). }
        claim HyU: y :e U.
        { exact (SepI A (fun t0:set => Rlt t0 z) y Hy Hyz). }
        exact (elem_implies_nonempty U y HyU). }
    claim HVne: V <> Empty.
    { apply (xm (Rlt x z /\ Rlt z y)).
      - assume Hxzzy: Rlt x z /\ Rlt z y.
        claim Hzy: Rlt z y.
        { exact (andER (Rlt x z) (Rlt z y) Hxzzy). }
        claim HyV: y :e V.
        { exact (SepI A (fun t0:set => Rlt z t0) y Hy Hzy). }
        exact (elem_implies_nonempty V y HyV).
      - assume Hnot.
        claim Hzx: Rlt z x.
        { apply Hbetw.
          assume Hxzzy: Rlt x z /\ Rlt z y.
          apply FalseE.
          exact (Hnot Hxzzy).
          assume Hyzzx: Rlt y z /\ Rlt z x.
          exact (andER (Rlt y z) (Rlt z x) Hyzzx). }
        claim HxV: x :e V.
        { exact (SepI A (fun t0:set => Rlt z t0) x Hx Hzx). }
        exact (elem_implies_nonempty V x HxV). }
    (** Union is all of A since z  A and order is trichotomous. **)
    claim Hunion: U :\/: V = A.
    { apply set_ext.
      - let t. assume Ht: t :e U :\/: V.
        prove t :e A.
        apply (binunionE U V t Ht).
        + assume HtU. exact (SepE1 A (fun t0:set => Rlt t0 z) t HtU).
        + assume HtV. exact (SepE1 A (fun t0:set => Rlt z t0) t HtV).
      - let t. assume HtA: t :e A.
        prove t :e U :\/: V.
        claim HtR: t :e R.
        { exact (HA t HtA). }
        claim HtS: SNo t.
        { exact (real_SNo t HtR). }
        claim HzS: SNo z.
        { exact (real_SNo z Hz). }
        apply (SNoLt_trichotomy_or_impred t z HtS HzS (t :e U :\/: V)).
        + (** t < z -> t in U **)
          assume Hlt: t < z.
          claim Htlt: Rlt t z.
          { exact (RltI t z HtR Hz Hlt). }
          exact (binunionI1 U V t (SepI A (fun t0:set => Rlt t0 z) t HtA Htlt)).
        + (** t = z -> contradiction since z  A **)
          assume Heq: t = z.
          claim HzA: z :e A.
          { rewrite <- Heq. exact HtA. }
          apply FalseE.
          exact (HznotA HzA).
        + (** z < t -> t in V **)
          assume Hlt: z < t.
          claim Hzt: Rlt z t.
          { exact (RltI z t Hz HtR Hlt). }
          exact (binunionI2 U V t (SepI A (fun t0:set => Rlt z t0) t HtA Hzt)). }
    (** Package separation_of A U V **)
    prove (((((U :e Power A /\ V :e Power A) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty) /\ U :\/: V = A).
    apply andI.
    - prove ((((U :e Power A /\ V :e Power A) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty).
      apply andI.
      + prove (((U :e Power A /\ V :e Power A) /\ U :/\: V = Empty) /\ U <> Empty).
        apply andI.
        * prove (U :e Power A /\ V :e Power A) /\ U :/\: V = Empty.
          apply andI.
          { apply andI.
            - exact HUpowA.
            - exact HVpowA. }
          { exact Hdisj. }
        * exact HUne.
      + exact HVne.
    - exact Hunion. }
  (** Contradict connectedness **)
  apply FalseE.
  apply Hnosep.
  witness U.
  witness V.
  (** goal is (UTy  VTy)  separation_of A U V **)
  apply andI.
  - apply andI.
    + exact HUinTy.
    + exact HVinTy.
  - exact HsepUV.
Qed.

(** Helper: image of x mapped to (x,y0) is setprod X {y0} **)
Theorem image_of_id_const_is_slice : forall X y0:set,
  image_of (pair_map X {(x,x)|x :e X} (const_fun X y0)) X = setprod X {y0}.
let X y0.
prove image_of (pair_map X {(x,x)|x :e X} (const_fun X y0)) X = setprod X {y0}.
apply set_ext.
- let p. assume Hp: p :e image_of (pair_map X {(x,x)|x :e X} (const_fun X y0)) X.
  prove p :e setprod X {y0}.
  (** unfold image_of **)
  set f := pair_map X {(x,x)|x :e X} (const_fun X y0).
  claim HpRepl: p :e Repl X (fun a => apply_fun f a).
  { exact Hp. }
  apply (ReplE_impred X (fun a:set => apply_fun f a) p HpRepl).
  let a. assume HaX: a :e X.
  assume Heq: p = apply_fun f a.
  rewrite Heq.
  claim Hfa: apply_fun f a = (apply_fun {(x,x)|x :e X} a, apply_fun (const_fun X y0) a).
  { exact (pair_map_apply X X {y0} {(x,x)|x :e X} (const_fun X y0) a HaX). }
  claim Hid: apply_fun {(x,x)|x :e X} a = a.
  { exact (identity_function_apply X a HaX). }
  claim Hc: apply_fun (const_fun X y0) a = y0.
  { exact (const_fun_apply X y0 a HaX). }
  rewrite Hfa.
  rewrite Hid.
  rewrite Hc.
  exact (tuple_2_setprod X {y0} a HaX y0 (SingI y0)).
- let p. assume Hp: p :e setprod X {y0}.
  prove p :e image_of (pair_map X {(x,x)|x :e X} (const_fun X y0)) X.
  set f := pair_map X {(x,x)|x :e X} (const_fun X y0).
  (** extract coordinates **)
  claim Hp0X: (p 0) :e X.
  { exact (ap0_Sigma X (fun _:set => {y0}) p Hp). }
  claim Hp1Sing: (p 1) :e {y0}.
  { exact (ap1_Sigma X (fun _:set => {y0}) p Hp). }
  claim Hp1eq: (p 1) = y0.
  { exact (singleton_elem (p 1) y0 Hp1Sing). }
  claim Heta: p = (p 0, p 1).
  { exact (setprod_eta X {y0} p Hp). }
  (** show p is in the image by choosing a = p0 **)
  prove p :e Repl X (fun a => apply_fun f a).
  claim Hfp0: apply_fun f (p 0) = (apply_fun {(x,x)|x :e X} (p 0), apply_fun (const_fun X y0) (p 0)).
  { exact (pair_map_apply X X {y0} {(x,x)|x :e X} (const_fun X y0) (p 0) Hp0X). }
  claim Hid0: apply_fun {(x,x)|x :e X} (p 0) = (p 0).
  { exact (identity_function_apply X (p 0) Hp0X). }
  claim Hc0: apply_fun (const_fun X y0) (p 0) = y0.
  { exact (const_fun_apply X y0 (p 0) Hp0X). }
	  claim Hfp0eq: apply_fun f (p 0) = (p 0, p 1).
	  { rewrite Hfp0.
	    rewrite Hid0.
	    rewrite Hc0.
	    rewrite Hp1eq.
	    reflexivity. }
  claim Hp_as_image: p = apply_fun f (p 0).
  { rewrite Heta at 1.
    rewrite Hfp0eq.
    reflexivity. }
  rewrite Hp_as_image.
  exact (ReplI X (fun a:set => apply_fun f a) (p 0) Hp0X).
Qed.

(** Helper: slice X times {y0} is connected when X is connected **)
Theorem slice_X_connected : forall X Tx Y Ty y0:set,
  connected_space X Tx -> topology_on Y Ty -> y0 :e Y ->
  connected_space (setprod X {y0})
    (subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod X {y0})).
let X Tx Y Ty y0.
assume HX: connected_space X Tx.
assume HTy: topology_on Y Ty.
assume Hy0: y0 :e Y.
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
              (~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V))
              HX). }
set idX := {(x,x)|x :e X}.
set c := const_fun X y0.
set f := pair_map X idX c.
claim Hid: continuous_map X Tx X Tx idX.
{ exact (identity_continuous X Tx HTx). }
claim Hc: continuous_map X Tx Y Ty c.
{ exact (const_fun_continuous X Tx Y Ty y0 HTx HTy Hy0). }
claim Hf: continuous_map X Tx (setprod X Y) (product_topology X Tx Y Ty) f.
{ exact (maps_into_products X Tx X Tx Y Ty idX c Hid Hc). }
claim Himg: connected_space (image_of f X)
  (subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (image_of f X)).
{ exact (continuous_image_connected X Tx (setprod X Y) (product_topology X Tx Y Ty) f HX Hf). }
prove connected_space (setprod X {y0})
    (subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod X {y0})).
rewrite <- (image_of_id_const_is_slice X y0).
exact Himg.
Qed.

(** Helper: image of y mapped to (x0,y) is setprod {x0} Y **)
Theorem image_of_const_id_is_slice : forall Y x0:set,
  image_of (pair_map Y (const_fun Y x0) {(y,y)|y :e Y}) Y = setprod {x0} Y.
let Y x0.
set idY := {(y,y)|y :e Y}.
prove image_of (pair_map Y (const_fun Y x0) idY) Y = setprod {x0} Y.
apply set_ext.
- let p. assume Hp: p :e image_of (pair_map Y (const_fun Y x0) idY) Y.
  prove p :e setprod {x0} Y.
  set f := pair_map Y (const_fun Y x0) idY.
  claim HpRepl: p :e Repl Y (fun a => apply_fun f a).
  { exact Hp. }
  apply (ReplE_impred Y (fun a:set => apply_fun f a) p HpRepl).
  let a. assume HaY: a :e Y.
  assume Heq: p = apply_fun f a.
  rewrite Heq.
  claim Hfa: apply_fun f a = (apply_fun (const_fun Y x0) a, apply_fun idY a).
  { exact (pair_map_apply Y {x0} Y (const_fun Y x0) idY a HaY). }
  claim Hc: apply_fun (const_fun Y x0) a = x0.
  { exact (const_fun_apply Y x0 a HaY). }
  claim Hid: apply_fun idY a = a.
  { exact (identity_function_apply Y a HaY). }
  rewrite Hfa.
  rewrite Hc.
  rewrite Hid.
  exact (tuple_2_setprod {x0} Y x0 (SingI x0) a HaY).
- let p. assume Hp: p :e setprod {x0} Y.
  prove p :e image_of (pair_map Y (const_fun Y x0) idY) Y.
  set f := pair_map Y (const_fun Y x0) idY.
  claim Hp0Sing: (p 0) :e {x0}.
  { exact (ap0_Sigma {x0} (fun _:set => Y) p Hp). }
  claim Hp1Y: (p 1) :e Y.
  { exact (ap1_Sigma {x0} (fun _:set => Y) p Hp). }
  claim Hp0eq: (p 0) = x0.
  { exact (singleton_elem (p 0) x0 Hp0Sing). }
  claim Heta: p = (p 0, p 1).
  { exact (setprod_eta {x0} Y p Hp). }
  prove p :e Repl Y (fun a => apply_fun f a).
  claim Hfp1: apply_fun f (p 1) = (apply_fun (const_fun Y x0) (p 1), apply_fun idY (p 1)).
  { exact (pair_map_apply Y {x0} Y (const_fun Y x0) idY (p 1) Hp1Y). }
  claim Hc1: apply_fun (const_fun Y x0) (p 1) = x0.
  { exact (const_fun_apply Y x0 (p 1) Hp1Y). }
  claim Hid1: apply_fun idY (p 1) = (p 1).
  { exact (identity_function_apply Y (p 1) Hp1Y). }
  claim Hfp1eq: apply_fun f (p 1) = (p 0, p 1).
  { rewrite Hfp1.
    rewrite Hc1.
    rewrite Hid1.
    rewrite <- Hp0eq at 1.
    reflexivity. }
  claim Hp_as_image: p = apply_fun f (p 1).
  { rewrite Heta at 1.
    rewrite <- Hfp1eq.
    reflexivity. }
  rewrite Hp_as_image.
  exact (ReplI Y (fun a:set => apply_fun f a) (p 1) Hp1Y).
Qed.

(** Helper: slice {x0} times Y is connected when Y is connected **)
Theorem slice_Y_connected : forall X Tx Y Ty x0:set,
  connected_space Y Ty -> topology_on X Tx -> x0 :e X ->
  connected_space (setprod {x0} Y)
    (subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod {x0} Y)).
let X Tx Y Ty x0.
assume HY: connected_space Y Ty.
assume HTx: topology_on X Tx.
assume Hx0: x0 :e X.
claim HTy: topology_on Y Ty.
{ exact (andEL (topology_on Y Ty)
              (~(exists U V:set, U :e Ty /\ V :e Ty /\ separation_of Y U V))
              HY). }
set idY := {(y,y)|y :e Y}.
set c := const_fun Y x0.
set f := pair_map Y c idY.
claim Hc: continuous_map Y Ty X Tx c.
{ exact (const_fun_continuous Y Ty X Tx x0 HTy HTx Hx0). }
claim Hid: continuous_map Y Ty Y Ty idY.
{ exact (identity_continuous Y Ty HTy). }
claim Hf: continuous_map Y Ty (setprod X Y) (product_topology X Tx Y Ty) f.
{ exact (maps_into_products Y Ty X Tx Y Ty c idY Hc Hid). }
claim Himg: connected_space (image_of f Y)
  (subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (image_of f Y)).
{ exact (continuous_image_connected Y Ty (setprod X Y) (product_topology X Tx Y Ty) f HY Hf). }
prove connected_space (setprod {x0} Y)
    (subspace_topology (setprod X Y) (product_topology X Tx Y Ty) (setprod {x0} Y)).
rewrite <- (image_of_const_id_is_slice Y x0).
exact Himg.
Qed.

(** from 23 Theorem 23.6: finite products of connected spaces are connected **) 
Theorem finite_product_connected : forall X Tx Y Ty:set,
  connected_space X Tx -> connected_space Y Ty ->
  connected_space (setprod X Y) (product_topology X Tx Y Ty).
let X Tx Y Ty.
assume HX: connected_space X Tx.
assume HY: connected_space Y Ty.
prove connected_space (setprod X Y) (product_topology X Tx Y Ty).
(** Helper: product with empty set is empty (left) **)
claim Hsetprod_empty_left: forall Y0:set, setprod Empty Y0 = Empty.
{ let Y0.
  apply set_ext.
  - let p. assume Hp: p :e setprod Empty Y0.
    prove p :e Empty.
    apply FalseE.
    claim Hp0: (p 0) :e Empty.
    { exact (ap0_Sigma Empty (fun _:set => Y0) p Hp). }
    exact (EmptyE (p 0) Hp0).
  - let p. assume Hp: p :e Empty.
    prove p :e setprod Empty Y0.
    apply FalseE.
    exact (EmptyE p Hp). }
(** Helper: product with empty set is empty (right) **)
claim Hsetprod_empty_right: forall X0:set, setprod X0 Empty = Empty.
{ let X0.
  apply set_ext.
  - let p. assume Hp: p :e setprod X0 Empty.
    prove p :e Empty.
    apply FalseE.
    claim Hp1: (p 1) :e Empty.
    { exact (ap1_Sigma X0 (fun _:set => Empty) p Hp). }
    exact (EmptyE (p 1) Hp1).
  - let p. assume Hp: p :e Empty.
    prove p :e setprod X0 Empty.
    apply FalseE.
    exact (EmptyE p Hp). }

(** Extract the topology parts **)
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
              (~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V))
              HX). }
claim HTy: topology_on Y Ty.
{ exact (andEL (topology_on Y Ty)
              (~(exists U V:set, U :e Ty /\ V :e Ty /\ separation_of Y U V))
              HY). }

(** Case split on emptiness of X and Y **)
apply xm (X = Empty).
- assume HXEmpty: X = Empty.
  rewrite HXEmpty.
  rewrite (Hsetprod_empty_left Y).
  prove topology_on Empty (product_topology Empty Tx Y Ty) /\
    ~(exists U V:set,
      U :e product_topology Empty Tx Y Ty /\
      V :e product_topology Empty Tx Y Ty /\
      separation_of Empty U V).
  apply andI.
  - (** topology_on Empty (...) **)
    claim HTx0: topology_on Empty Tx.
    { rewrite <- HXEmpty. exact HTx. }
    prove topology_on Empty (product_topology Empty Tx Y Ty).
    rewrite <- (Hsetprod_empty_left Y) at 1.
    exact (product_topology_is_topology Empty Tx Y Ty HTx0 HTy).
  - (** no separation of Empty **)
    prove ~(exists U V:set,
      U :e product_topology Empty Tx Y Ty /\
      V :e product_topology Empty Tx Y Ty /\
      separation_of Empty U V).
    assume Hsep: exists U V:set,
      U :e product_topology Empty Tx Y Ty /\
      V :e product_topology Empty Tx Y Ty /\
      separation_of Empty U V.
    apply Hsep.
    let U. assume HexV: exists V:set,
      U :e product_topology Empty Tx Y Ty /\
      V :e product_topology Empty Tx Y Ty /\
      separation_of Empty U V.
    apply HexV.
    let V. assume HUVsep.
    claim HsepUV: separation_of Empty U V.
    { exact (andER (U :e product_topology Empty Tx Y Ty /\ V :e product_topology Empty Tx Y Ty)
                   (separation_of Empty U V) HUVsep). }
    claim Hpart1: ((((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty).
    { exact (andEL ((((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                   (U :\/: V = Empty) HsepUV). }
    claim Hpart2: ((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) /\ U <> Empty.
    { exact (andEL (((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) /\ U <> Empty)
                   (V <> Empty) Hpart1). }
    claim HUne: U <> Empty.
    { exact (andER ((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) (U <> Empty) Hpart2). }
    claim Hpow: (U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty.
    { exact (andEL ((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) (U <> Empty) Hpart2). }
    claim HpowUV: U :e Power Empty /\ V :e Power Empty.
    { exact (andEL (U :e Power Empty /\ V :e Power Empty) (U :/\: V = Empty) Hpow). }
    claim HUsub: U c= Empty.
    { exact (PowerE Empty U (andEL (U :e Power Empty) (V :e Power Empty) HpowUV)). }
    claim HUeq: U = Empty.
    { exact (Empty_Subq_eq U HUsub). }
    exact (HUne HUeq).
- assume HXNonEmpty: X <> Empty.
  apply xm (Y = Empty).
  + assume HYEmpty: Y = Empty.
    rewrite HYEmpty.
    rewrite (Hsetprod_empty_right X).
    prove topology_on Empty (product_topology X Tx Empty Ty) /\
      ~(exists U V:set,
        U :e product_topology X Tx Empty Ty /\
        V :e product_topology X Tx Empty Ty /\
        separation_of Empty U V).
    apply andI.
    - (** topology_on Empty (...) **)
      claim HTy0: topology_on Empty Ty.
      { rewrite <- HYEmpty. exact HTy. }
      prove topology_on Empty (product_topology X Tx Empty Ty).
      rewrite <- (Hsetprod_empty_right X) at 1.
      exact (product_topology_is_topology X Tx Empty Ty HTx HTy0).
    - (** no separation of Empty **)
      prove ~(exists U V:set,
        U :e product_topology X Tx Empty Ty /\
        V :e product_topology X Tx Empty Ty /\
        separation_of Empty U V).
      assume Hsep: exists U V:set,
        U :e product_topology X Tx Empty Ty /\
        V :e product_topology X Tx Empty Ty /\
        separation_of Empty U V.
      apply Hsep.
      let U. assume HexV: exists V:set,
        U :e product_topology X Tx Empty Ty /\
        V :e product_topology X Tx Empty Ty /\
        separation_of Empty U V.
      apply HexV.
      let V. assume HUVsep.
      claim HsepUV: separation_of Empty U V.
      { exact (andER (U :e product_topology X Tx Empty Ty /\ V :e product_topology X Tx Empty Ty)
                     (separation_of Empty U V) HUVsep). }
      claim Hpart1: ((((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty).
      { exact (andEL ((((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                     (U :\/: V = Empty) HsepUV). }
      claim Hpart2: ((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) /\ U <> Empty.
      { exact (andEL (((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) /\ U <> Empty)
                     (V <> Empty) Hpart1). }
      claim HUne: U <> Empty.
      { exact (andER ((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) (U <> Empty) Hpart2). }
      claim Hpow: (U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty.
      { exact (andEL ((U :e Power Empty /\ V :e Power Empty) /\ U :/\: V = Empty) (U <> Empty) Hpart2). }
      claim HpowUV: U :e Power Empty /\ V :e Power Empty.
      { exact (andEL (U :e Power Empty /\ V :e Power Empty) (U :/\: V = Empty) Hpow). }
      claim HUsub: U c= Empty.
      { exact (PowerE Empty U (andEL (U :e Power Empty) (V :e Power Empty) HpowUV)). }
      claim HUeq: U = Empty.
      { exact (Empty_Subq_eq U HUsub). }
      exact (HUne HUeq).
  + assume HYNonEmpty: Y <> Empty.
    (** Nonempty X and Y: union of connected slices with a common point **)
    apply (nonempty_has_element X HXNonEmpty).
    let x0. assume Hx0X: x0 :e X.
    apply (nonempty_has_element Y HYNonEmpty).
    let y0. assume Hy0Y: y0 :e Y.
    set Top := product_topology X Tx Y Ty.
    set Hhor := setprod X {y0}.
    set F := {setprod {x} Y :\/: Hhor|x :e X}.

    claim HTprod: topology_on (setprod X Y) Top.
    { exact (product_topology_is_topology X Tx Y Ty HTx HTy). }

    (** Each member of F is a subset of XY **)
    claim HFsub: forall C:set, C :e F -> C c= setprod X Y.
    { let C. assume HC: C :e F.
      apply (ReplE_impred X (fun x:set => setprod {x} Y :\/: Hhor) C HC).
      let x. assume HxX: x :e X.
      assume HCeq: C = setprod {x} Y :\/: Hhor.
      rewrite HCeq.
      prove (setprod {x} Y :\/: Hhor) c= setprod X Y.
      let p. assume Hp: p :e setprod {x} Y :\/: Hhor.
      prove p :e setprod X Y.
      apply (binunionE' (setprod {x} Y) Hhor p (p :e setprod X Y)).
      - assume HpA: p :e setprod {x} Y.
        claim Hxsub: {x} c= X.
        { exact (singleton_subset x X HxX). }
        claim HYsub: Y c= Y.
        { exact (Subq_ref Y). }
        exact (setprod_Subq {x} Y X Y Hxsub HYsub p HpA).
      - assume HpB: p :e Hhor.
        claim HXsub: X c= X.
        { exact (Subq_ref X). }
        claim Hy0sub: {y0} c= Y.
        { exact (singleton_subset y0 Y Hy0Y). }
        exact (setprod_Subq X {y0} X Y HXsub Hy0sub p HpB).
      - exact Hp. }

    (** Each member of F is connected **)
    claim HFconn: forall C:set, C :e F ->
      connected_space C (subspace_topology (setprod X Y) Top C).
    { let C. assume HC: C :e F.
      apply (ReplE_impred X (fun x:set => setprod {x} Y :\/: Hhor) C HC).
      let x. assume HxX: x :e X.
      assume HCeq: C = setprod {x} Y :\/: Hhor.
      rewrite HCeq.
      set A := setprod {x} Y.
      set B := Hhor.
      claim HAconn: connected_space A (subspace_topology (setprod X Y) Top A).
      { exact (slice_Y_connected X Tx Y Ty x HY HTx HxX). }
      claim HBconn: connected_space B (subspace_topology (setprod X Y) Top B).
      { exact (slice_X_connected X Tx Y Ty y0 HX HTy Hy0Y). }
      claim HABsub: forall D:set, D :e {A,B} -> D c= setprod X Y.
      { let D. assume HD: D :e {A,B}.
        apply (UPairE D A B HD (D c= setprod X Y)).
        - assume HDa: D = A. rewrite HDa.
          claim Hxsub: {x} c= X.
          { exact (singleton_subset x X HxX). }
          claim HYsub: Y c= Y.
          { exact (Subq_ref Y). }
          exact (setprod_Subq {x} Y X Y Hxsub HYsub).
        - assume HDb: D = B. rewrite HDb.
          claim HXsub: X c= X.
          { exact (Subq_ref X). }
          claim Hy0sub: {y0} c= Y.
          { exact (singleton_subset y0 Y Hy0Y). }
          exact (setprod_Subq X {y0} X Y HXsub Hy0sub). }

      (** Use union_connected_common_point on {A,B} with common point (x,y0) **)
      claim HunionAB: connected_space (Union {A,B})
        (subspace_topology (setprod X Y) Top (Union {A,B})).
      { apply (union_connected_common_point (setprod X Y) Top {A,B} HTprod).
        - exact HABsub.
        - let D. assume HD: D :e {A,B}.
          apply (UPairE D A B HD (connected_space D (subspace_topology (setprod X Y) Top D))).
          + assume HDa: D = A. rewrite HDa. exact HAconn.
          + assume HDb: D = B. rewrite HDb. exact HBconn.
        - witness (x,y0).
          let D. assume HD: D :e {A,B}.
          apply (UPairE D A B HD ((x,y0) :e D)).
          + assume HDa: D = A.
            rewrite HDa.
            exact (tuple_2_setprod {x} Y x (SingI x) y0 Hy0Y).
          + assume HDb: D = B.
            rewrite HDb.
            exact (tuple_2_setprod X {y0} x HxX y0 (SingI y0)). }

      (** Rewrite Union {A,B} into A :\/: B **)
      rewrite (binunion_eq_Union_pair A B).
      exact HunionAB. }

    (** Common point for all members of F: (x0,y0) lies in the horizontal slice **)
    claim Hcommon: exists p:set, forall C:set, C :e F -> p :e C.
    { witness (x0,y0).
      let C. assume HC: C :e F.
      apply (ReplE_impred X (fun x:set => setprod {x} Y :\/: Hhor) C HC).
      let x. assume HxX: x :e X.
      assume HCeq: C = setprod {x} Y :\/: Hhor.
      rewrite HCeq.
      prove (x0,y0) :e setprod {x} Y :\/: Hhor.
      apply binunionI2.
      exact (tuple_2_setprod X {y0} x0 Hx0X y0 (SingI y0)). }

    (** Connectedness of the union Union F **)
    claim HconnUnion: connected_space (Union F)
      (subspace_topology (setprod X Y) Top (Union F)).
    { exact (union_connected_common_point (setprod X Y) Top F HTprod HFsub HFconn Hcommon). }

    (** Union F is all of XY **)
    claim HFpow: F c= Power (setprod X Y).
    { let C. assume HC: C :e F.
      prove C :e Power (setprod X Y).
      exact (PowerI (setprod X Y) C (HFsub C HC)). }
    claim HUnionSub: Union F c= setprod X Y.
    { exact (Union_Power (setprod X Y) F HFpow). }
    claim HSubUnion: setprod X Y c= Union F.
    { let p. assume Hp: p :e setprod X Y.
      claim Hp0X: (p 0) :e X.
      { exact (ap0_Sigma X (fun _:set => Y) p Hp). }
      claim Hp1Y: (p 1) :e Y.
      { exact (ap1_Sigma X (fun _:set => Y) p Hp). }
      set C0 := setprod {p 0} Y :\/: Hhor.
      claim HC0F: C0 :e F.
      { exact (ReplI X (fun x:set => setprod {x} Y :\/: Hhor) (p 0) Hp0X). }
      prove p :e Union F.
      apply (UnionI F p C0).
      - prove p :e C0.
        apply binunionI1.
      claim Heta: p = (p 0, p 1).
      { exact (setprod_eta X Y p Hp). }
      rewrite Heta at 1.
      exact (tuple_2_setprod {p 0} Y (p 0) (SingI (p 0)) (p 1) Hp1Y).
      - exact HC0F. }
    claim HUnionEq: Union F = setprod X Y.
    { apply set_ext.
      - exact HUnionSub.
      - exact HSubUnion. }

    (** Transfer connectedness from the union to XY, then collapse subspace topology **)
    claim HconnAmbientSub: connected_space (setprod X Y)
      (subspace_topology (setprod X Y) Top (setprod X Y)).
    { rewrite <- HUnionEq.
      exact HconnUnion. }
    claim Hsubeq: subspace_topology (setprod X Y) Top (setprod X Y) = Top.
    { exact (subspace_topology_whole (setprod X Y) Top HTprod). }
    rewrite <- Hsubeq.
    exact HconnAmbientSub.
Qed.

(** from 23 Example 6: R^ in the box topology is not connected **) 
(** LATEX VERSION: Partition R^ into bounded and unbounded sequences; each is open in the box topology using (a_i-1,a_i+1). **)
Definition R_omega_space : set :=
  product_space omega (const_space_family omega R R_standard_topology).
Definition R_omega_box_topology : set :=
  box_topology omega (const_space_family omega R R_standard_topology).
Definition R_omega_product_topology : set :=
  product_topology_full omega (const_space_family omega R R_standard_topology).

Definition bounded_sequence_Romega : set -> prop := fun f =>
  exists M:set, M :e R /\ forall n:set, n :e omega -> apply_fun f n :e open_interval (minus_SNo M) M.

Definition bounded_sequences_Romega : set :=
  {f :e R_omega_space | bounded_sequence_Romega f}.

Definition unbounded_sequence_Romega : set -> prop := fun f =>
  forall M:set, M :e R -> exists n:set, n :e omega /\ ~(apply_fun f n :e open_interval (minus_SNo M) M).

Definition unbounded_sequences_Romega : set :=
  {f :e R_omega_space | unbounded_sequence_Romega f}.

(** Helper: coordinates of a point in R_omega_space are real numbers **)
Theorem Romega_coord_in_R : forall f i:set,
  f :e R_omega_space ->
  i :e omega ->
  apply_fun f i :e R.
let f i.
assume Hf: f :e R_omega_space.
assume Hi: i :e omega.
prove apply_fun f i :e R.
set Xi := const_space_family omega R R_standard_topology.
claim Hfprop: function_on f omega (space_family_union omega Xi) /\
              forall j:set, j :e omega -> apply_fun f j :e space_family_set Xi j.
{ exact (SepE2 (Power (setprod omega (space_family_union omega Xi)))
               (fun f0:set => function_on f0 omega (space_family_union omega Xi) /\
                 forall j:set, j :e omega -> apply_fun f0 j :e space_family_set Xi j)
               f
               Hf). }
claim Hcoords: forall j:set, j :e omega -> apply_fun f j :e space_family_set Xi j.
{ exact (andER (function_on f omega (space_family_union omega Xi))
               (forall j:set, j :e omega -> apply_fun f j :e space_family_set Xi j)
               Hfprop). }
claim Hfi: apply_fun f i :e space_family_set Xi i.
{ exact (Hcoords i Hi). }
claim HXi: apply_fun Xi i = (R, R_standard_topology).
{ exact (const_space_family_apply omega R R_standard_topology i Hi). }
claim Hset: space_family_set Xi i = R.
{ claim Hdef: space_family_set Xi i = (apply_fun Xi i) 0.
  { reflexivity. }
  rewrite Hdef.
  rewrite HXi.
  exact (tuple_2_0_eq R R_standard_topology). }
 rewrite <- Hset.
 exact Hfi.
Qed.

(** Helper: bounded and unbounded sequence collections lie in Power R_omega_space **)
Theorem bounded_sequences_Romega_in_Power : bounded_sequences_Romega :e Power R_omega_space.
prove bounded_sequences_Romega :e Power R_omega_space.
apply PowerI.
let f. assume Hf: f :e bounded_sequences_Romega.
prove f :e R_omega_space.
exact (SepE1 R_omega_space (fun f0:set => bounded_sequence_Romega f0) f Hf).
Qed.

Theorem unbounded_sequences_Romega_in_Power : unbounded_sequences_Romega :e Power R_omega_space.
prove unbounded_sequences_Romega :e Power R_omega_space.
apply PowerI.
let f. assume Hf: f :e unbounded_sequences_Romega.
prove f :e R_omega_space.
exact (SepE1 R_omega_space (fun f0:set => unbounded_sequence_Romega f0) f Hf).
Qed.

(** Helper: bounded/unbounded sets are intended to form a separation in the box topology **)
Theorem bounded_sequences_in_Romega_box_topology :
  bounded_sequences_Romega :e R_omega_box_topology.
prove bounded_sequences_Romega :e R_omega_box_topology.
set Xi := const_space_family omega R R_standard_topology.
set X := product_space omega Xi.
set B := box_basis omega Xi.
set TU := topology_family_union omega Xi.
prove bounded_sequences_Romega :e generated_topology X B.
claim Hpow: bounded_sequences_Romega :e Power X.
{ exact bounded_sequences_Romega_in_Power. }
claim Hcond: forall f :e bounded_sequences_Romega, exists b :e B, f :e b /\ b c= bounded_sequences_Romega.
{ let f. assume Hf: f :e bounded_sequences_Romega.
  claim HfX: f :e X.
  { exact (SepE1 R_omega_space (fun f0:set => bounded_sequence_Romega f0) f Hf). }
  claim Hb: bounded_sequence_Romega f.
  { exact (SepE2 R_omega_space (fun f0:set => bounded_sequence_Romega f0) f Hf). }
  apply Hb.
  let M. assume HMconj.
  claim HMR: M :e R.
  { exact (andEL (M :e R) (forall n:set, n :e omega -> apply_fun f n :e open_interval (minus_SNo M) M) HMconj). }
  claim Hbnd: forall n:set, n :e omega -> apply_fun f n :e open_interval (minus_SNo M) M.
  { exact (andER (M :e R) (forall n:set, n :e omega -> apply_fun f n :e open_interval (minus_SNo M) M) HMconj). }

  claim H0omega: 0 :e omega.
  { exact (nat_p_omega 0 nat_0). }
  claim Hf0In: apply_fun f 0 :e open_interval (minus_SNo M) M.
  { exact (Hbnd 0 H0omega). }
  claim Hf0prop: Rlt (minus_SNo M) (apply_fun f 0) /\ Rlt (apply_fun f 0) M.
  { exact (SepE2 R (fun x0:set => Rlt (minus_SNo M) x0 /\ Rlt x0 M) (apply_fun f 0) Hf0In). }
  claim Hm0: Rlt (minus_SNo M) (apply_fun f 0).
  { exact (andEL (Rlt (minus_SNo M) (apply_fun f 0)) (Rlt (apply_fun f 0) M) Hf0prop). }
  claim H0m: Rlt (apply_fun f 0) M.
  { exact (andER (Rlt (minus_SNo M) (apply_fun f 0)) (Rlt (apply_fun f 0) M) Hf0prop). }
  claim HMlt: Rlt (minus_SNo M) M.
  { exact (Rlt_tra (minus_SNo M) (apply_fun f 0) M Hm0 H0m). }
  claim HopenI: open_interval (minus_SNo M) M :e R_standard_topology.
  { exact (open_interval_in_R_standard_topology (minus_SNo M) M HMlt). }

  claim HX0: apply_fun Xi 0 = (R, R_standard_topology).
  { exact (const_space_family_apply omega R R_standard_topology 0 H0omega). }
  claim HT0: space_family_topology Xi 0 = R_standard_topology.
  { claim Hdef: space_family_topology Xi 0 = (apply_fun Xi 0) 1.
    { reflexivity. }
    rewrite Hdef.
    rewrite HX0.
    exact (tuple_2_1_eq R R_standard_topology). }
  claim HTfam: R_standard_topology :e {space_family_topology Xi i|i :e omega}.
  { apply ReplEq omega (fun i:set => space_family_topology Xi i) R_standard_topology.
    assume _ H2. apply H2.
    prove exists i :e omega, R_standard_topology = space_family_topology Xi i.
    witness 0.
    apply andI.
    - exact H0omega.
    - symmetry.
      exact HT0. }
  claim HintervalTU: open_interval (minus_SNo M) M :e TU.
  { exact (UnionI {space_family_topology Xi i|i :e omega}
                 (open_interval (minus_SNo M) M)
                 R_standard_topology
                 HopenI
                 HTfam). }

  set Um := const_fun omega (open_interval (minus_SNo M) M).
  set bM := {g :e X | forall i:set, i :e omega -> apply_fun g i :e apply_fun Um i}.

  witness bM.
  apply andI.
  - (** bM :e box_basis omega Xi **)
    prove bM :e B.
    claim HbMsub: bM c= X.
    { let g. assume Hg: g :e bM.
      prove g :e X.
      exact (SepE1 X (fun g0:set => forall i:set, i :e omega -> apply_fun g0 i :e apply_fun Um i) g Hg). }
    claim HbMpow: bM :e Power X.
    { exact (PowerI X bM HbMsub). }
    claim HUmfun: function_on Um omega TU.
    { claim Htot: total_function_on Um omega TU.
      { exact (const_fun_total_function_on omega TU (open_interval (minus_SNo M) M) HintervalTU). }
      exact (total_function_on_function_on Um omega TU Htot). }
    claim HUmcoords: forall i:set, i :e omega -> apply_fun Um i :e space_family_topology Xi i.
    { let i. assume Hi: i :e omega.
      prove apply_fun Um i :e space_family_topology Xi i.
      claim Happ: apply_fun Um i = open_interval (minus_SNo M) M.
      { exact (const_fun_apply omega (open_interval (minus_SNo M) M) i Hi). }
      rewrite Happ.
      claim HXi: apply_fun Xi i = (R, R_standard_topology).
      { exact (const_space_family_apply omega R R_standard_topology i Hi). }
      claim HTi: space_family_topology Xi i = R_standard_topology.
      { claim Hdef: space_family_topology Xi i = (apply_fun Xi i) 1.
        { reflexivity. }
        rewrite Hdef.
        rewrite HXi.
        exact (tuple_2_1_eq R R_standard_topology). }
      rewrite HTi.
      exact HopenI. }
    claim HexU: exists U:set, function_on U omega TU /\
      (forall i:set, i :e omega -> apply_fun U i :e space_family_topology Xi i) /\
      bM = {f :e X | forall i:set, i :e omega -> apply_fun f i :e apply_fun U i}.
    { witness Um.
      apply andI.
      - apply andI.
        + exact HUmfun.
        + exact HUmcoords.
      - reflexivity. }
    exact (SepI (Power X)
                (fun B0:set => exists U:set, function_on U omega TU /\
                  (forall i:set, i :e omega -> apply_fun U i :e space_family_topology Xi i) /\
                  B0 = {f :e X | forall i:set, i :e omega -> apply_fun f i :e apply_fun U i})
                bM
                HbMpow
                HexU).
  - apply andI.
    + (** f :e bM **)
      prove f :e bM.
      apply (SepI X (fun g0:set => forall i:set, i :e omega -> apply_fun g0 i :e apply_fun Um i) f HfX).
      let i. assume Hi: i :e omega.
      prove apply_fun f i :e apply_fun Um i.
      claim Happ: apply_fun Um i = open_interval (minus_SNo M) M.
      { exact (const_fun_apply omega (open_interval (minus_SNo M) M) i Hi). }
      rewrite Happ.
      exact (Hbnd i Hi).
    + (** bM c= bounded_sequences_Romega **)
      let g. assume Hg: g :e bM.
      prove g :e bounded_sequences_Romega.
      claim HgX: g :e X.
      { exact (SepE1 X (fun g0:set => forall i:set, i :e omega -> apply_fun g0 i :e apply_fun Um i) g Hg). }
      claim Hgprop: forall i:set, i :e omega -> apply_fun g i :e apply_fun Um i.
      { exact (SepE2 X (fun g0:set => forall i:set, i :e omega -> apply_fun g0 i :e apply_fun Um i) g Hg). }
      claim Hbseqg: bounded_sequence_Romega g.
      { claim Hbndg: forall n:set, n :e omega -> apply_fun g n :e open_interval (minus_SNo M) M.
        { let n. assume HnO: n :e omega.
          claim Hgn: apply_fun g n :e apply_fun Um n.
          { exact (Hgprop n HnO). }
          claim Happ: apply_fun Um n = open_interval (minus_SNo M) M.
          { exact (const_fun_apply omega (open_interval (minus_SNo M) M) n HnO). }
          rewrite <- Happ.
          exact Hgn. }
        exact (fun P Hp => Hp M (andI (M :e R)
                                      (forall n:set, n :e omega -> apply_fun g n :e open_interval (minus_SNo M) M)
                                      HMR
                                      Hbndg)). }
      exact (SepI R_omega_space (fun h:set => bounded_sequence_Romega h) g HgX Hbseqg). }
exact (SepI (Power X)
            (fun U0:set => forall x :e U0, exists b :e B, x :e b /\ b c= U0)
            bounded_sequences_Romega
            Hpow
            Hcond).
Qed.

Theorem unbounded_sequences_in_Romega_box_topology :
  unbounded_sequences_Romega :e R_omega_box_topology.
prove unbounded_sequences_Romega :e R_omega_box_topology.
set Xi := const_space_family omega R R_standard_topology.
set X := product_space omega Xi.
set B := box_basis omega Xi.
set TU := topology_family_union omega Xi.
prove unbounded_sequences_Romega :e generated_topology X B.
claim Hpow: unbounded_sequences_Romega :e Power X.
{ exact unbounded_sequences_Romega_in_Power. }
claim Hcond: forall f :e unbounded_sequences_Romega, exists b :e B, f :e b /\ b c= unbounded_sequences_Romega.
{ let f. assume Hf: f :e unbounded_sequences_Romega.
  claim HfX: f :e X.
  { exact (SepE1 R_omega_space (fun f0:set => unbounded_sequence_Romega f0) f Hf). }
  claim Huf: unbounded_sequence_Romega f.
  { exact (SepE2 R_omega_space (fun f0:set => unbounded_sequence_Romega f0) f Hf). }

  claim H0omega: 0 :e omega.
  { exact (nat_p_omega 0 nat_0). }
  claim HX0: apply_fun Xi 0 = (R, R_standard_topology).
  { exact (const_space_family_apply omega R R_standard_topology 0 H0omega). }
  claim HT0: space_family_topology Xi 0 = R_standard_topology.
  { claim Hdef: space_family_topology Xi 0 = (apply_fun Xi 0) 1.
    { reflexivity. }
    rewrite Hdef.
    rewrite HX0.
    exact (tuple_2_1_eq R R_standard_topology). }
  claim HTfam: R_standard_topology :e {space_family_topology Xi i|i :e omega}.
  { apply ReplEq omega (fun i:set => space_family_topology Xi i) R_standard_topology.
    assume _ H2. apply H2.
    prove exists i :e omega, R_standard_topology = space_family_topology Xi i.
    witness 0.
    apply andI.
    - exact H0omega.
    - symmetry.
      exact HT0. }

  claim Hm1R : minus_SNo 1 :e R.
  { exact (real_minus_SNo 1 real_1). }
  claim Hm1S : SNo (minus_SNo 1).
  { exact (real_SNo (minus_SNo 1) Hm1R). }
  claim Hm1lt1 : minus_SNo 1 < 1.
  { exact (SNoLt_tra (minus_SNo 1) 0 1 Hm1S SNo_0 SNo_1 minus_1_lt_0 SNoLt_0_1). }

  set U := {(i, open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                              (add_SNo (apply_fun f i) 1)) | i :e omega}.
  set bU := {g :e X | forall i:set, i :e omega -> apply_fun g i :e apply_fun U i}.

  claim HUapply: forall i:set, i :e omega ->
    apply_fun U i = open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                                 (add_SNo (apply_fun f i) 1).
  { let i. assume Hi: i :e omega.
    prove apply_fun U i = open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                                     (add_SNo (apply_fun f i) 1).
    prove Eps_i (fun z => (i, z) :e U) =
      open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                    (add_SNo (apply_fun f i) 1).
    claim H1: (i, open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                               (add_SNo (apply_fun f i) 1)) :e U.
    { exact (ReplI omega (fun i0:set =>
              (i0, open_interval (add_SNo (apply_fun f i0) (minus_SNo 1))
                                 (add_SNo (apply_fun f i0) 1))) i Hi). }
    claim H2: (i, Eps_i (fun z => (i, z) :e U)) :e U.
    { exact (Eps_i_ax (fun z => (i, z) :e U)
                      (open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                                     (add_SNo (apply_fun f i) 1))
                      H1). }
    apply (ReplE_impred omega (fun i0:set =>
              (i0, open_interval (add_SNo (apply_fun f i0) (minus_SNo 1))
                                 (add_SNo (apply_fun f i0) 1)))
              (i, Eps_i (fun z => (i, z) :e U)) H2).
    let i0.
    assume Hi0: i0 :e omega.
    assume Heq: (i, Eps_i (fun z => (i, z) :e U)) =
                (i0, open_interval (add_SNo (apply_fun f i0) (minus_SNo 1))
                                   (add_SNo (apply_fun f i0) 1)).
    claim Hi_eq: i = i0.
    { rewrite <- (tuple_2_0_eq i (Eps_i (fun z => (i, z) :e U))).
      rewrite <- (tuple_2_0_eq i0 (open_interval (add_SNo (apply_fun f i0) (minus_SNo 1))
                                                 (add_SNo (apply_fun f i0) 1))).
      rewrite Heq.
      reflexivity. }
    claim Hz_eq: Eps_i (fun z => (i, z) :e U) =
                 open_interval (add_SNo (apply_fun f i0) (minus_SNo 1))
                               (add_SNo (apply_fun f i0) 1).
    { rewrite <- (tuple_2_1_eq i (Eps_i (fun z => (i, z) :e U))).
      rewrite <- (tuple_2_1_eq i0 (open_interval (add_SNo (apply_fun f i0) (minus_SNo 1))
                                                 (add_SNo (apply_fun f i0) 1))).
      rewrite Heq.
      reflexivity. }
    rewrite Hz_eq.
    rewrite <- Hi_eq.
    reflexivity. }

  witness bU.
  apply andI.
  - (** bU :e box_basis omega Xi **)
    prove bU :e B.
    claim HbUsub: bU c= X.
    { let g. assume Hg: g :e bU.
      prove g :e X.
      exact (SepE1 X (fun g0:set => forall i:set, i :e omega -> apply_fun g0 i :e apply_fun U i) g Hg). }
    claim HbUpow: bU :e Power X.
    { exact (PowerI X bU HbUsub). }
    claim HUfun: function_on U omega TU.
    { let i. assume Hi: i :e omega.
      prove apply_fun U i :e TU.
      claim HfRi: apply_fun f i :e R.
      { exact (Romega_coord_in_R f i HfX Hi). }
      claim HfSi: SNo (apply_fun f i).
      { exact (real_SNo (apply_fun f i) HfRi). }
      claim HaR: add_SNo (apply_fun f i) (minus_SNo 1) :e R.
      { exact (real_add_SNo (apply_fun f i) HfRi (minus_SNo 1) Hm1R). }
      claim HbR: add_SNo (apply_fun f i) 1 :e R.
      { exact (real_add_SNo (apply_fun f i) HfRi 1 real_1). }
      claim HaS: SNo (add_SNo (apply_fun f i) (minus_SNo 1)).
      { exact (real_SNo (add_SNo (apply_fun f i) (minus_SNo 1)) HaR). }
      claim HbS: SNo (add_SNo (apply_fun f i) 1).
      { exact (real_SNo (add_SNo (apply_fun f i) 1) HbR). }
      claim Hlt: add_SNo (apply_fun f i) (minus_SNo 1) < add_SNo (apply_fun f i) 1.
      { exact (add_SNo_Lt2 (apply_fun f i) (minus_SNo 1) 1 HfSi Hm1S SNo_1 Hm1lt1). }
      claim HRlt: Rlt (add_SNo (apply_fun f i) (minus_SNo 1)) (add_SNo (apply_fun f i) 1).
      { exact (RltI (add_SNo (apply_fun f i) (minus_SNo 1))
                    (add_SNo (apply_fun f i) 1)
                    HaR
                    HbR
                    Hlt). }
      claim HopenI: open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                                  (add_SNo (apply_fun f i) 1) :e R_standard_topology.
      { exact (open_interval_in_R_standard_topology
                (add_SNo (apply_fun f i) (minus_SNo 1))
                (add_SNo (apply_fun f i) 1)
                HRlt). }
      claim HappUi: apply_fun U i =
        open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                      (add_SNo (apply_fun f i) 1).
      { exact (HUapply i Hi). }
      rewrite HappUi.
      exact (UnionI {space_family_topology Xi j|j :e omega}
                    (open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                                   (add_SNo (apply_fun f i) 1))
                    R_standard_topology
                    HopenI
                    HTfam). }
    claim HUcoords: forall i:set, i :e omega -> apply_fun U i :e space_family_topology Xi i.
    { let i. assume Hi: i :e omega.
      prove apply_fun U i :e space_family_topology Xi i.
      claim HXi: apply_fun Xi i = (R, R_standard_topology).
      { exact (const_space_family_apply omega R R_standard_topology i Hi). }
      claim HTi: space_family_topology Xi i = R_standard_topology.
      { claim Hdef: space_family_topology Xi i = (apply_fun Xi i) 1.
        { reflexivity. }
        rewrite Hdef.
        rewrite HXi.
        exact (tuple_2_1_eq R R_standard_topology). }
      rewrite HTi.
      claim HfRi: apply_fun f i :e R.
      { exact (Romega_coord_in_R f i HfX Hi). }
      claim HfSi: SNo (apply_fun f i).
      { exact (real_SNo (apply_fun f i) HfRi). }
      claim HaR: add_SNo (apply_fun f i) (minus_SNo 1) :e R.
      { exact (real_add_SNo (apply_fun f i) HfRi (minus_SNo 1) Hm1R). }
      claim HbR: add_SNo (apply_fun f i) 1 :e R.
      { exact (real_add_SNo (apply_fun f i) HfRi 1 real_1). }
      claim Hlt: add_SNo (apply_fun f i) (minus_SNo 1) < add_SNo (apply_fun f i) 1.
      { exact (add_SNo_Lt2 (apply_fun f i) (minus_SNo 1) 1 HfSi Hm1S SNo_1 Hm1lt1). }
      claim HRlt: Rlt (add_SNo (apply_fun f i) (minus_SNo 1)) (add_SNo (apply_fun f i) 1).
      { exact (RltI (add_SNo (apply_fun f i) (minus_SNo 1))
                    (add_SNo (apply_fun f i) 1)
                    HaR
                    HbR
                    Hlt). }
      claim HopenI: open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                                  (add_SNo (apply_fun f i) 1) :e R_standard_topology.
      { exact (open_interval_in_R_standard_topology
                (add_SNo (apply_fun f i) (minus_SNo 1))
                (add_SNo (apply_fun f i) 1)
                HRlt). }
      claim HappUi: apply_fun U i =
        open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                      (add_SNo (apply_fun f i) 1).
      { exact (HUapply i Hi). }
      rewrite HappUi.
      exact HopenI. }
    claim HexU: exists U0:set, function_on U0 omega TU /\
      (forall i:set, i :e omega -> apply_fun U0 i :e space_family_topology Xi i) /\
      bU = {f0 :e X | forall i:set, i :e omega -> apply_fun f0 i :e apply_fun U0 i}.
    { witness U.
      apply andI.
      - apply andI.
        + exact HUfun.
        + exact HUcoords.
      - reflexivity. }
    exact (SepI (Power X)
                (fun B0:set => exists U0:set, function_on U0 omega TU /\
                  (forall i:set, i :e omega -> apply_fun U0 i :e space_family_topology Xi i) /\
                  B0 = {f0 :e X | forall i:set, i :e omega -> apply_fun f0 i :e apply_fun U0 i})
                bU
                HbUpow
                HexU).
  - apply andI.
    + (** f :e bU **)
      prove f :e bU.
      apply (SepI X (fun g0:set => forall i:set, i :e omega -> apply_fun g0 i :e apply_fun U i) f HfX).
      let i. assume Hi: i :e omega.
      prove apply_fun f i :e apply_fun U i.
      claim HfRi: apply_fun f i :e R.
      { exact (Romega_coord_in_R f i HfX Hi). }
      claim HfSi: SNo (apply_fun f i).
      { exact (real_SNo (apply_fun f i) HfRi). }
      claim HaR: add_SNo (apply_fun f i) (minus_SNo 1) :e R.
      { exact (real_add_SNo (apply_fun f i) HfRi (minus_SNo 1) Hm1R). }
      claim HbR: add_SNo (apply_fun f i) 1 :e R.
      { exact (real_add_SNo (apply_fun f i) HfRi 1 real_1). }
      claim Hx0eq : add_SNo (apply_fun f i) 0 = apply_fun f i.
      { exact (add_SNo_0R (apply_fun f i) HfSi). }
      claim Haxlt0 : add_SNo (apply_fun f i) (minus_SNo 1) < add_SNo (apply_fun f i) 0.
      { exact (add_SNo_Lt2 (apply_fun f i) (minus_SNo 1) 0 HfSi Hm1S SNo_0 minus_1_lt_0). }
      claim Haxlt : add_SNo (apply_fun f i) (minus_SNo 1) < apply_fun f i.
      { rewrite <- Hx0eq at 2. exact Haxlt0. }
      claim Hxltb0 : add_SNo (apply_fun f i) 0 < add_SNo (apply_fun f i) 1.
      { exact (add_SNo_Lt2 (apply_fun f i) 0 1 HfSi SNo_0 SNo_1 SNoLt_0_1). }
      claim Hxltb : apply_fun f i < add_SNo (apply_fun f i) 1.
      { rewrite <- Hx0eq at 1. exact Hxltb0. }
      claim HaRltx : Rlt (add_SNo (apply_fun f i) (minus_SNo 1)) (apply_fun f i).
      { exact (RltI (add_SNo (apply_fun f i) (minus_SNo 1)) (apply_fun f i) HaR HfRi Haxlt). }
      claim HxRltb : Rlt (apply_fun f i) (add_SNo (apply_fun f i) 1).
      { exact (RltI (apply_fun f i) (add_SNo (apply_fun f i) 1) HfRi HbR Hxltb). }
      claim HxIn: apply_fun f i :e open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                                           (add_SNo (apply_fun f i) 1).
      { exact (SepI R (fun z : set => Rlt (add_SNo (apply_fun f i) (minus_SNo 1)) z /\ Rlt z (add_SNo (apply_fun f i) 1))
                    (apply_fun f i) HfRi (andI (Rlt (add_SNo (apply_fun f i) (minus_SNo 1)) (apply_fun f i))
                                               (Rlt (apply_fun f i) (add_SNo (apply_fun f i) 1))
                                               HaRltx
                                               HxRltb)). }
      claim HappUi: apply_fun U i =
        open_interval (add_SNo (apply_fun f i) (minus_SNo 1))
                      (add_SNo (apply_fun f i) 1).
      { exact (HUapply i Hi). }
      rewrite HappUi.
      exact HxIn.
    + (** bU c= unbounded_sequences_Romega **)
      let g. assume Hg: g :e bU.
      prove g :e unbounded_sequences_Romega.
      claim HgX: g :e X.
      { exact (SepE1 X (fun g0:set => forall i:set, i :e omega -> apply_fun g0 i :e apply_fun U i) g Hg). }
      claim Hgprop: forall i:set, i :e omega -> apply_fun g i :e apply_fun U i.
      { exact (SepE2 X (fun g0:set => forall i:set, i :e omega -> apply_fun g0 i :e apply_fun U i) g Hg). }
      apply (SepI R_omega_space (fun h:set => unbounded_sequence_Romega h) g HgX).
      prove unbounded_sequence_Romega g.
      let M. assume HM: M :e R.
      set K := add_SNo M 1.
      claim HKR: K :e R.
      { exact (real_add_SNo M HM 1 real_1). }
      claim Hexn: exists n:set, n :e omega /\ ~(apply_fun f n :e open_interval (minus_SNo K) K).
      { exact (Huf K HKR). }
      apply Hexn.
      let n. assume Hnconj.
      claim HnO: n :e omega.
      { exact (andEL (n :e omega) (~(apply_fun f n :e open_interval (minus_SNo K) K)) Hnconj). }
      claim Hfnot: ~(apply_fun f n :e open_interval (minus_SNo K) K).
      { exact (andER (n :e omega) (~(apply_fun f n :e open_interval (minus_SNo K) K)) Hnconj). }
      witness n.
      apply andI.
      - exact HnO.
      - prove ~(apply_fun g n :e open_interval (minus_SNo M) M).
        assume HgnIn: apply_fun g n :e open_interval (minus_SNo M) M.
        prove False.
        apply Hfnot.
        (** show apply_fun f n is in open_interval (minus_SNo K) K from HgnIn and box membership **)
        claim HfnR: apply_fun f n :e R.
        { exact (Romega_coord_in_R f n HfX HnO). }
        claim HgnR: apply_fun g n :e R.
        { exact (Romega_coord_in_R g n HgX HnO). }
        claim HfnS: SNo (apply_fun f n).
        { exact (real_SNo (apply_fun f n) HfnR). }
        claim HgnS: SNo (apply_fun g n).
        { exact (real_SNo (apply_fun g n) HgnR). }
        claim HM_S: SNo M.
        { exact (real_SNo M HM). }
        claim HK_S: SNo K.
        { exact (real_SNo K HKR). }

        claim HgnBox: apply_fun g n :e open_interval (add_SNo (apply_fun f n) (minus_SNo 1))
                                               (add_SNo (apply_fun f n) 1).
        { claim HgnU: apply_fun g n :e apply_fun U n.
          { exact (Hgprop n HnO). }
          claim HappUn: apply_fun U n =
            open_interval (add_SNo (apply_fun f n) (minus_SNo 1))
                          (add_SNo (apply_fun f n) 1).
          { exact (HUapply n HnO). }
          rewrite <- HappUn.
          exact HgnU. }

        claim HgnInProp: Rlt (minus_SNo M) (apply_fun g n) /\ Rlt (apply_fun g n) M.
        { exact (SepE2 R (fun z:set => Rlt (minus_SNo M) z /\ Rlt z M) (apply_fun g n) HgnIn). }
        claim Hgn_gt_mM: Rlt (minus_SNo M) (apply_fun g n).
        { exact (andEL (Rlt (minus_SNo M) (apply_fun g n)) (Rlt (apply_fun g n) M) HgnInProp). }
        claim Hgn_lt_M: Rlt (apply_fun g n) M.
        { exact (andER (Rlt (minus_SNo M) (apply_fun g n)) (Rlt (apply_fun g n) M) HgnInProp). }

        claim HgnBoxProp: Rlt (add_SNo (apply_fun f n) (minus_SNo 1)) (apply_fun g n)
                          /\ Rlt (apply_fun g n) (add_SNo (apply_fun f n) 1).
        { exact (SepE2 R (fun z:set => Rlt (add_SNo (apply_fun f n) (minus_SNo 1)) z /\ Rlt z (add_SNo (apply_fun f n) 1))
                     (apply_fun g n) HgnBox). }
        claim HxL_lt_y: Rlt (add_SNo (apply_fun f n) (minus_SNo 1)) (apply_fun g n).
        { exact (andEL (Rlt (add_SNo (apply_fun f n) (minus_SNo 1)) (apply_fun g n))
                       (Rlt (apply_fun g n) (add_SNo (apply_fun f n) 1))
                       HgnBoxProp). }
        claim Hy_lt_xR: Rlt (apply_fun g n) (add_SNo (apply_fun f n) 1).
        { exact (andER (Rlt (add_SNo (apply_fun f n) (minus_SNo 1)) (apply_fun g n))
                       (Rlt (apply_fun g n) (add_SNo (apply_fun f n) 1))
                       HgnBoxProp). }

        (** derive apply_fun f n < apply_fun g n + 1 **)
        claim HxL_lt_y_lt: add_SNo (apply_fun f n) (minus_SNo 1) < apply_fun g n.
        { exact (RltE_lt (add_SNo (apply_fun f n) (minus_SNo 1)) (apply_fun g n) HxL_lt_y). }
        claim HxL1_lt_y1: add_SNo (add_SNo (apply_fun f n) (minus_SNo 1)) 1 < add_SNo (apply_fun g n) 1.
        { exact (add_SNo_Lt1 (add_SNo (apply_fun f n) (minus_SNo 1)) 1 (apply_fun g n)
                             (SNo_add_SNo (apply_fun f n) (minus_SNo 1) HfnS Hm1S)
                             SNo_1
                             HgnS
                             HxL_lt_y_lt). }
        claim Hx_to_xL1: add_SNo (add_SNo (apply_fun f n) (minus_SNo 1)) 1 = apply_fun f n.
        { exact (add_SNo_minus_R2' (apply_fun f n) 1 HfnS SNo_1). }
        claim Hx_lt_y1_lt: apply_fun f n < add_SNo (apply_fun g n) 1.
        { rewrite <- Hx_to_xL1 at 1. exact HxL1_lt_y1. }
        claim Hy1R: add_SNo (apply_fun g n) 1 :e R.
        { exact (real_add_SNo (apply_fun g n) HgnR 1 real_1). }
        claim Hx_lt_y1: Rlt (apply_fun f n) (add_SNo (apply_fun g n) 1).
        { exact (RltI (apply_fun f n) (add_SNo (apply_fun g n) 1) HfnR Hy1R Hx_lt_y1_lt). }

        (** derive add_SNo (apply_fun g n) 1 < K **)
        claim Hy_lt_M_lt: apply_fun g n < M.
        { exact (RltE_lt (apply_fun g n) M Hgn_lt_M). }
        claim Hy1_lt_M1: add_SNo (apply_fun g n) 1 < add_SNo M 1.
        { exact (add_SNo_Lt1 (apply_fun g n) 1 M HgnS SNo_1 HM_S Hy_lt_M_lt). }
        claim Hy1_Rlt_K: Rlt (add_SNo (apply_fun g n) 1) K.
        { exact (RltI (add_SNo (apply_fun g n) 1) K Hy1R HKR Hy1_lt_M1). }

        (** combine for upper bound: apply_fun f n < K **)
        claim Hx_lt_K: Rlt (apply_fun f n) K.
        { exact (Rlt_tra (apply_fun f n) (add_SNo (apply_fun g n) 1) K Hx_lt_y1 Hy1_Rlt_K). }

        (** derive minus_SNo K < apply_fun f n **)
        claim Hy_gt_mM_lt: minus_SNo M < apply_fun g n.
        { exact (RltE_lt (minus_SNo M) (apply_fun g n) Hgn_gt_mM). }
        claim Hy_m1_lt_x: add_SNo (apply_fun g n) (minus_SNo 1) < apply_fun f n.
        { claim Hy_lt_xR_lt: apply_fun g n < add_SNo (apply_fun f n) 1.
          { exact (RltE_lt (apply_fun g n) (add_SNo (apply_fun f n) 1) Hy_lt_xR). }
          claim Hy_m1_lt_x0: add_SNo (apply_fun g n) (minus_SNo 1) < add_SNo (add_SNo (apply_fun f n) 1) (minus_SNo 1).
          { exact (add_SNo_Lt1 (apply_fun g n) (minus_SNo 1) (add_SNo (apply_fun f n) 1)
                               HgnS
                               Hm1S
                               (SNo_add_SNo (apply_fun f n) 1 HfnS SNo_1)
                               Hy_lt_xR_lt). }
          claim Hx1m1_eq: add_SNo (add_SNo (apply_fun f n) 1) (minus_SNo 1) = apply_fun f n.
          { exact (add_SNo_minus_R2 (apply_fun f n) 1 HfnS SNo_1). }
          rewrite <- Hx1m1_eq.
          exact Hy_m1_lt_x0. }

        claim HmM_m1_lt_y_m1: add_SNo (minus_SNo M) (minus_SNo 1) < add_SNo (apply_fun g n) (minus_SNo 1).
        { exact (add_SNo_Lt1 (minus_SNo M) (minus_SNo 1) (apply_fun g n)
                             (real_SNo (minus_SNo M) (real_minus_SNo M HM))
                             Hm1S
                             HgnS
                             Hy_gt_mM_lt). }

        claim HmM_m1_R: add_SNo (minus_SNo M) (minus_SNo 1) :e R.
        { exact (real_add_SNo (minus_SNo M) (real_minus_SNo M HM) (minus_SNo 1) Hm1R). }
        claim HKneg: minus_SNo K = add_SNo (minus_SNo M) (minus_SNo 1).
        { claim Hdist: minus_SNo (add_SNo M 1) = add_SNo (minus_SNo M) (minus_SNo 1).
          { exact (minus_add_SNo_distr M 1 (real_SNo M HM) SNo_1). }
          exact Hdist. }

        claim HmK_lt_x: Rlt (minus_SNo K) (apply_fun f n).
        { rewrite HKneg.
          claim Htmp: Rlt (add_SNo (minus_SNo M) (minus_SNo 1)) (apply_fun f n).
          { claim Hmid: Rlt (add_SNo (minus_SNo M) (minus_SNo 1)) (add_SNo (apply_fun g n) (minus_SNo 1)).
            { exact (RltI (add_SNo (minus_SNo M) (minus_SNo 1))
                          (add_SNo (apply_fun g n) (minus_SNo 1))
                          HmM_m1_R
                          (real_add_SNo (apply_fun g n) HgnR (minus_SNo 1) Hm1R)
                          HmM_m1_lt_y_m1). }
            claim Hmid2: Rlt (add_SNo (apply_fun g n) (minus_SNo 1)) (apply_fun f n).
            { exact (RltI (add_SNo (apply_fun g n) (minus_SNo 1)) (apply_fun f n)
                          (real_add_SNo (apply_fun g n) HgnR (minus_SNo 1) Hm1R)
                          HfnR
                          Hy_m1_lt_x). }
            exact (Rlt_tra (add_SNo (minus_SNo M) (minus_SNo 1))
                           (add_SNo (apply_fun g n) (minus_SNo 1))
                           (apply_fun f n)
                           Hmid
                           Hmid2). }
          exact Htmp. }

        (** package membership in open_interval (minus_SNo K) K **)
        exact (SepI R (fun z:set => Rlt (minus_SNo K) z /\ Rlt z K)
                     (apply_fun f n)
                     HfnR
                     (andI (Rlt (minus_SNo K) (apply_fun f n))
                           (Rlt (apply_fun f n) K)
                           HmK_lt_x
                           Hx_lt_K)).
  }
exact (SepI (Power X)
            (fun U0:set => forall x :e U0, exists b :e B, x :e b /\ b c= U0)
            unbounded_sequences_Romega
            Hpow
            Hcond).
Qed.

Theorem bounded_unbounded_disjoint_Romega :
  bounded_sequences_Romega :/\: unbounded_sequences_Romega = Empty.
prove bounded_sequences_Romega :/\: unbounded_sequences_Romega = Empty.
apply set_ext.
- let f. assume Hf: f :e bounded_sequences_Romega :/\: unbounded_sequences_Romega.
  prove f :e Empty.
  claim Hb: f :e bounded_sequences_Romega.
  { exact (binintersectE1 bounded_sequences_Romega unbounded_sequences_Romega f Hf). }
  claim Hu: f :e unbounded_sequences_Romega.
  { exact (binintersectE2 bounded_sequences_Romega unbounded_sequences_Romega f Hf). }
  claim Hbprop: bounded_sequence_Romega f.
  { exact (SepE2 R_omega_space (fun f0:set => bounded_sequence_Romega f0) f Hb). }
  claim Huprop: unbounded_sequence_Romega f.
  { exact (SepE2 R_omega_space (fun f0:set => unbounded_sequence_Romega f0) f Hu). }
  apply Hbprop.
  let M. assume HMconj.
  claim HMR: M :e R.
  { exact (andEL (M :e R) (forall n:set, n :e omega -> apply_fun f n :e open_interval (minus_SNo M) M) HMconj). }
  claim Hbnd: forall n:set, n :e omega -> apply_fun f n :e open_interval (minus_SNo M) M.
  { exact (andER (M :e R) (forall n:set, n :e omega -> apply_fun f n :e open_interval (minus_SNo M) M) HMconj). }
  claim Hexn: exists n :e omega, ~(apply_fun f n :e open_interval (minus_SNo M) M).
  { exact (Huprop M HMR). }
  apply Hexn.
  let n. assume Hnconj.
  claim HnO: n :e omega.
  { exact (andEL (n :e omega) (~(apply_fun f n :e open_interval (minus_SNo M) M)) Hnconj). }
  claim Hnnot: ~(apply_fun f n :e open_interval (minus_SNo M) M).
  { exact (andER (n :e omega) (~(apply_fun f n :e open_interval (minus_SNo M) M)) Hnconj). }
  claim Hfalse: False.
  { exact (Hnnot (Hbnd n HnO)). }
  exact (FalseE Hfalse (f :e Empty)).
- exact (Subq_Empty (bounded_sequences_Romega :/\: unbounded_sequences_Romega)).
Qed.

Theorem bounded_union_unbounded_Romega :
  bounded_sequences_Romega :\/: unbounded_sequences_Romega = R_omega_space.
prove bounded_sequences_Romega :\/: unbounded_sequences_Romega = R_omega_space.
apply set_ext.
- let f. assume Hf: f :e bounded_sequences_Romega :\/: unbounded_sequences_Romega.
  prove f :e R_omega_space.
  apply (binunionE bounded_sequences_Romega unbounded_sequences_Romega f Hf).
  - assume Hb: f :e bounded_sequences_Romega.
    exact (SepE1 R_omega_space (fun f0:set => bounded_sequence_Romega f0) f Hb).
  - assume Hu: f :e unbounded_sequences_Romega.
    exact (SepE1 R_omega_space (fun f0:set => unbounded_sequence_Romega f0) f Hu).
- let f. assume Hf: f :e R_omega_space.
  prove f :e bounded_sequences_Romega :\/: unbounded_sequences_Romega.
  apply (xm (bounded_sequence_Romega f) (f :e bounded_sequences_Romega :\/: unbounded_sequences_Romega)).
  - assume Hbseq: bounded_sequence_Romega f.
    prove f :e bounded_sequences_Romega :\/: unbounded_sequences_Romega.
    apply binunionI1.
    exact (SepI R_omega_space (fun f0:set => bounded_sequence_Romega f0) f Hf Hbseq).
  - assume HnotBound: ~(bounded_sequence_Romega f).
    prove f :e bounded_sequences_Romega :\/: unbounded_sequences_Romega.
    apply binunionI2.
    prove f :e unbounded_sequences_Romega.
    apply (SepI R_omega_space (fun f0:set => unbounded_sequence_Romega f0) f Hf).
    prove unbounded_sequence_Romega f.
    let M. assume HM: M :e R.
    apply (xm (exists n:set, n :e omega /\ ~(apply_fun f n :e open_interval (minus_SNo M) M))).
    - assume Hex. exact Hex.
    - assume Hnone: ~(exists n:set, n :e omega /\ ~(apply_fun f n :e open_interval (minus_SNo M) M)).
      prove exists n:set, n :e omega /\ ~(apply_fun f n :e open_interval (minus_SNo M) M).
      apply FalseE.
      prove False.
      apply HnotBound.
      prove bounded_sequence_Romega f.
      claim HbndM: forall n:set, n :e omega -> apply_fun f n :e open_interval (minus_SNo M) M.
      { let n. assume HnO: n :e omega.
        prove apply_fun f n :e open_interval (minus_SNo M) M.
        apply dneg.
        assume Hnnot: ~(apply_fun f n :e open_interval (minus_SNo M) M).
        prove False.
        apply Hnone.
        witness n.
        apply andI.
        - exact HnO.
        - exact Hnnot. }
      exact (fun P Hp => Hp M (andI (M :e R)
                                    (forall n:set, n :e omega -> apply_fun f n :e open_interval (minus_SNo M) M)
                                    HM
                                    HbndM)).
Qed.

(** Helper: both halves of the separation are nonempty **)
Theorem bounded_sequences_Romega_nonempty : bounded_sequences_Romega <> Empty.
prove bounded_sequences_Romega <> Empty.
assume Heq: bounded_sequences_Romega = Empty.
prove False.
set Xi := const_space_family omega R R_standard_topology.
set U := space_family_union omega Xi.
set f0 := const_fun omega 0.
claim H0omega: 0 :e omega.
{ exact (nat_p_omega 0 nat_0). }
claim HR0: 0 :e R.
{ exact real_0. }
claim HX0: apply_fun Xi 0 = (R, R_standard_topology).
{ exact (const_space_family_apply omega R R_standard_topology 0 H0omega). }
claim Hset0: space_family_set Xi 0 = R.
{ claim Hdef: space_family_set Xi 0 = (apply_fun Xi 0) 0.
  { reflexivity. }
  rewrite Hdef.
  rewrite HX0.
  exact (tuple_2_0_eq R R_standard_topology). }
claim HRfam: R :e {space_family_set Xi i|i :e omega}.
{ apply ReplEq omega (fun i:set => space_family_set Xi i) R.
  assume _ H2. apply H2.
  prove exists i :e omega, R = space_family_set Xi i.
  witness 0.
  apply andI.
  - exact H0omega.
  - prove R = space_family_set Xi 0.
    symmetry.
    exact Hset0. }
claim H0U: 0 :e U.
{ exact (UnionI {space_family_set Xi i|i :e omega} 0 R HR0 HRfam). }

(** show f0 :e R_omega_space **)
claim Hf0: f0 :e R_omega_space.
{ prove f0 :e product_space omega Xi.
  prove f0 :e {f :e Power (setprod omega (space_family_union omega Xi))|
     function_on f omega (space_family_union omega Xi) /\
     forall i:set, i :e omega -> apply_fun f i :e space_family_set Xi i}.
  set U0 := space_family_union omega Xi.
  claim Hsub: f0 c= setprod omega U0.
  { let p. assume Hp: p :e f0.
    prove p :e setprod omega U0.
    apply (ReplE_impred omega (fun a:set => (a,0)) p Hp (p :e setprod omega U0)).
    let a. assume HaO: a :e omega. assume Hpeq: p = (a,0).
    rewrite Hpeq.
    exact (tuple_2_setprod omega U0 a HaO 0 H0U). }
  claim Hpow: f0 :e Power (setprod omega U0).
  { exact (PowerI (setprod omega U0) f0 Hsub). }
  claim Hfun: function_on f0 omega U0.
  { let i. assume Hi: i :e omega.
    prove apply_fun f0 i :e U0.
    claim Happ: apply_fun f0 i = 0.
    { exact (const_fun_apply omega 0 i Hi). }
    rewrite Happ.
    exact H0U. }
  claim Hcoords: forall i:set, i :e omega -> apply_fun f0 i :e space_family_set Xi i.
  { let i. assume Hi: i :e omega.
    prove apply_fun f0 i :e space_family_set Xi i.
    claim Happ: apply_fun f0 i = 0.
    { exact (const_fun_apply omega 0 i Hi). }
    rewrite Happ.
    claim HX: apply_fun Xi i = (R, R_standard_topology).
    { exact (const_space_family_apply omega R R_standard_topology i Hi). }
    claim Hset: space_family_set Xi i = R.
    { claim Hdef: space_family_set Xi i = (apply_fun Xi i) 0.
      { reflexivity. }
      rewrite Hdef.
      rewrite HX.
      exact (tuple_2_0_eq R R_standard_topology). }
    rewrite Hset.
    exact real_0. }
  claim Hprop: function_on f0 omega U0 /\ forall i:set, i :e omega -> apply_fun f0 i :e space_family_set Xi i.
  { apply andI.
    - exact Hfun.
    - exact Hcoords. }
  exact (SepI (Power (setprod omega U0))
              (fun f:set => function_on f omega U0 /\ forall i:set, i :e omega -> apply_fun f i :e space_family_set Xi i)
              f0
              Hpow
              Hprop). }

(** show bounded_sequence_Romega f0 by the bound 1 **)
claim Hbseq: bounded_sequence_Romega f0.
{ claim Hbnd1: forall n:set, n :e omega -> apply_fun f0 n :e open_interval (minus_SNo 1) 1.
  { let n. assume HnO: n :e omega.
    prove apply_fun f0 n :e open_interval (minus_SNo 1) 1.
    claim Happ: apply_fun f0 n = 0.
    { exact (const_fun_apply omega 0 n HnO). }
    rewrite Happ.
    claim Hm1R: minus_SNo 1 :e R.
    { exact (real_minus_SNo 1 real_1). }
    claim Hm1lt0: Rlt (minus_SNo 1) 0.
    { exact (RltI (minus_SNo 1) 0 Hm1R real_0 minus_1_lt_0). }
    claim H0lt1: Rlt 0 1.
    { exact Rlt_0_1. }
    claim Hconj: Rlt (minus_SNo 1) 0 /\ Rlt 0 1.
    { apply andI.
      - exact Hm1lt0.
      - exact H0lt1. }
    exact (SepI R (fun x0:set => Rlt (minus_SNo 1) x0 /\ Rlt x0 1) 0 real_0 Hconj). }
  exact (fun P Hp => Hp 1 (andI (1 :e R)
                                (forall n:set, n :e omega -> apply_fun f0 n :e open_interval (minus_SNo 1) 1)
                                real_1
                                Hbnd1)). }

claim Hf0B: f0 :e bounded_sequences_Romega.
{ exact (SepI R_omega_space (fun f:set => bounded_sequence_Romega f) f0 Hf0 Hbseq). }
claim Hf0E: f0 :e Empty.
{ rewrite <- Heq at 2.
  exact Hf0B. }
exact (EmptyE f0 Hf0E).
Qed.

Theorem unbounded_sequences_Romega_nonempty : unbounded_sequences_Romega <> Empty.
prove unbounded_sequences_Romega <> Empty.
assume Heq: unbounded_sequences_Romega = Empty.
prove False.
set Xi := const_space_family omega R R_standard_topology.
set U := space_family_union omega Xi.
set fid := {(i,i)|i :e omega}.

(** show fid :e R_omega_space **)
claim Hfid: fid :e R_omega_space.
{ prove fid :e product_space omega Xi.
  prove fid :e {f :e Power (setprod omega (space_family_union omega Xi))|
     function_on f omega (space_family_union omega Xi) /\
     forall i:set, i :e omega -> apply_fun f i :e space_family_set Xi i}.
  claim H0omega: 0 :e omega.
  { exact (nat_p_omega 0 nat_0). }
  claim HX0: apply_fun Xi 0 = (R, R_standard_topology).
  { exact (const_space_family_apply omega R R_standard_topology 0 H0omega). }
  claim Hset0: space_family_set Xi 0 = R.
  { claim Hdef: space_family_set Xi 0 = (apply_fun Xi 0) 0.
    { reflexivity. }
    rewrite Hdef.
    rewrite HX0.
    exact (tuple_2_0_eq R R_standard_topology). }
  claim HRfam: R :e {space_family_set Xi i|i :e omega}.
  { apply ReplEq omega (fun i:set => space_family_set Xi i) R.
    assume _ H2. apply H2.
    prove exists i :e omega, R = space_family_set Xi i.
    witness 0.
    apply andI.
    - exact H0omega.
    - symmetry.
      exact Hset0. }
	  claim HomegaU: forall i:set, i :e omega -> i :e U.
	  { let i. assume Hi: i :e omega.
	    prove i :e U.
	    claim HiR: i :e R.
	    { claim HiSNoS: i :e SNoS_ omega.
	      { exact (omega_SNoS_omega i Hi). }
	      exact (SNoS_omega_real i HiSNoS). }
	    exact (UnionI {space_family_set Xi i0|i0 :e omega} i R HiR HRfam). }

  claim Hsub: fid c= setprod omega U.
  { let p. assume Hp: p :e fid.
    prove p :e setprod omega U.
    apply (ReplE_impred omega (fun i:set => (i,i)) p Hp (p :e setprod omega U)).
    let i. assume Hi: i :e omega. assume Hpeq: p = (i,i).
    rewrite Hpeq.
    exact (tuple_2_setprod omega U i Hi i (HomegaU i Hi)). }
  claim Hpow: fid :e Power (setprod omega U).
  { exact (PowerI (setprod omega U) fid Hsub). }

  claim Hfun: function_on fid omega U.
  { let i. assume Hi: i :e omega.
    prove apply_fun fid i :e U.
    claim Happ: apply_fun fid i = i.
    { exact (identity_function_apply omega i Hi). }
    rewrite Happ.
    exact (HomegaU i Hi). }
  claim Hcoords: forall i:set, i :e omega -> apply_fun fid i :e space_family_set Xi i.
  { let i. assume Hi: i :e omega.
    prove apply_fun fid i :e space_family_set Xi i.
    claim Happ: apply_fun fid i = i.
    { exact (identity_function_apply omega i Hi). }
    rewrite Happ.
    claim Hset: space_family_set Xi i = R.
    { claim HXi: apply_fun Xi i = (R, R_standard_topology).
      { exact (const_space_family_apply omega R R_standard_topology i Hi). }
      claim Hdef: space_family_set Xi i = (apply_fun Xi i) 0.
      { reflexivity. }
      rewrite Hdef.
      rewrite HXi.
      exact (tuple_2_0_eq R R_standard_topology). }
	    rewrite Hset.
	    claim HiSNoS: i :e SNoS_ omega.
	    { exact (omega_SNoS_omega i Hi). }
	    exact (SNoS_omega_real i HiSNoS). }

  claim Hprop: function_on fid omega U /\ forall i:set, i :e omega -> apply_fun fid i :e space_family_set Xi i.
  { apply andI.
    - exact Hfun.
    - exact Hcoords. }
  exact (SepI (Power (setprod omega U))
              (fun f:set => function_on f omega U /\ forall i:set, i :e omega -> apply_fun f i :e space_family_set Xi i)
              fid
              Hpow
              Hprop). }

(** show unbounded_sequence_Romega fid **)
claim Huseq: unbounded_sequence_Romega fid.
{ let M. assume HM: M :e R.
  claim HMS: SNo M.
  { exact (real_SNo M HM). }
  claim Hor: M < 0 \/ 0 <= M.
  { exact (SNoLtLe_or M 0 HMS SNo_0). }
  claim Hcase1: M < 0 ->
    exists n:set, n :e omega /\ ~(apply_fun fid n :e open_interval (minus_SNo M) M).
  { assume HMlt0: M < 0.
    witness 0.
    apply andI.
    - exact (nat_p_omega 0 nat_0).
    - prove ~(apply_fun fid 0 :e open_interval (minus_SNo M) M).
      assume Hin: apply_fun fid 0 :e open_interval (minus_SNo M) M.
      claim Happ: apply_fun fid 0 = 0.
      { exact (identity_function_apply omega 0 (nat_p_omega 0 nat_0)). }
      claim Hprop: Rlt (minus_SNo M) (apply_fun fid 0) /\ Rlt (apply_fun fid 0) M.
      { exact (SepE2 R (fun x0:set => Rlt (minus_SNo M) x0 /\ Rlt x0 M) (apply_fun fid 0) Hin). }
      claim HRlt0M: Rlt 0 M.
      { rewrite <- Happ.
        exact (andER (Rlt (minus_SNo M) (apply_fun fid 0)) (Rlt (apply_fun fid 0) M) Hprop). }
      claim HRltM0: Rlt M 0.
      { exact (RltI M 0 HM real_0 HMlt0). }
      claim Hnot: ~(Rlt 0 M).
      { exact (not_Rlt_sym M 0 HRltM0). }
      exact (Hnot HRlt0M). }
  claim Hcase2: 0 <= M ->
    exists n:set, n :e omega /\ ~(apply_fun fid n :e open_interval (minus_SNo M) M).
  { assume HMnonneg: 0 <= M.
    claim Hexn0: exists n :e omega, n <= M /\ M < ordsucc n.
    { exact (nonneg_real_nat_interval M HM HMnonneg). }
    apply Hexn0.
    let n0. assume Hn0conj.
    claim Hn0: n0 :e omega.
    { exact (andEL (n0 :e omega) (n0 <= M /\ M < ordsucc n0) Hn0conj). }
    claim Hn0prop: n0 <= M /\ M < ordsucc n0.
    { exact (andER (n0 :e omega) (n0 <= M /\ M < ordsucc n0) Hn0conj). }
    claim HMltS: M < ordsucc n0.
    { exact (andER (n0 <= M) (M < ordsucc n0) Hn0prop). }
    set n := ordsucc n0.
    witness n.
    apply andI.
    - exact (omega_ordsucc n0 Hn0).
    - prove ~(apply_fun fid n :e open_interval (minus_SNo M) M).
      assume Hin: apply_fun fid n :e open_interval (minus_SNo M) M.
      claim Happ: apply_fun fid n = n.
      { exact (identity_function_apply omega n (omega_ordsucc n0 Hn0)). }
      claim HnR: n :e R.
      { claim HnO: n :e omega.
        { exact (omega_ordsucc n0 Hn0). }
        claim HnSNoS: n :e SNoS_ omega.
        { exact (omega_SNoS_omega n HnO). }
        exact (SNoS_omega_real n HnSNoS). }
      claim HRltMn: Rlt M n.
      { exact (RltI M n HM HnR HMltS). }
      claim HnotnM: ~(Rlt n M).
      { exact (not_Rlt_sym M n HRltMn). }
      claim Hprop: Rlt (minus_SNo M) (apply_fun fid n) /\ Rlt (apply_fun fid n) M.
      { exact (SepE2 R (fun x0:set => Rlt (minus_SNo M) x0 /\ Rlt x0 M) (apply_fun fid n) Hin). }
      claim HRltnM: Rlt n M.
      { rewrite <- Happ.
        exact (andER (Rlt (minus_SNo M) (apply_fun fid n)) (Rlt (apply_fun fid n) M) Hprop). }
      exact (HnotnM HRltnM). }
  exact (Hor (exists n:set, n :e omega /\ ~(apply_fun fid n :e open_interval (minus_SNo M) M)) Hcase1 Hcase2).
}

claim HfidU: fid :e unbounded_sequences_Romega.
{ exact (SepI R_omega_space (fun f:set => unbounded_sequence_Romega f) fid Hfid Huseq). }
claim HeqE: Empty = unbounded_sequences_Romega.
{ symmetry. exact Heq. }
claim Hsubst: forall S T:set, S = T -> fid :e T -> fid :e S.
{ let S T.
  assume HeqST: S = T.
  assume HfidT: fid :e T.
  prove fid :e S.
  rewrite HeqST.
  exact HfidT. }
claim HfidE: fid :e Empty.
{ exact (Hsubst Empty unbounded_sequences_Romega HeqE HfidU). }
exact (EmptyE fid HfidE).
Qed.

Theorem R_omega_box_not_connected :
  ~ connected_space (product_space omega (const_space_family omega R R_standard_topology))
    (box_topology omega (const_space_family omega R R_standard_topology)).
prove ~ connected_space (product_space omega (const_space_family omega R R_standard_topology))
  (box_topology omega (const_space_family omega R R_standard_topology)).
assume Hconn: connected_space R_omega_space R_omega_box_topology.
prove False.
claim Hnosep: ~(exists U V:set, U :e R_omega_box_topology /\ V :e R_omega_box_topology /\ separation_of R_omega_space U V).
{ exact (andER (topology_on R_omega_space R_omega_box_topology)
               (~(exists U V:set, U :e R_omega_box_topology /\ V :e R_omega_box_topology /\ separation_of R_omega_space U V))
               Hconn). }
claim Hsep: exists U V:set, U :e R_omega_box_topology /\ V :e R_omega_box_topology /\ separation_of R_omega_space U V.
{ witness bounded_sequences_Romega.
  witness unbounded_sequences_Romega.
  apply andI.
  - apply andI.
    + exact bounded_sequences_in_Romega_box_topology.
    + exact unbounded_sequences_in_Romega_box_topology.
  - prove separation_of R_omega_space bounded_sequences_Romega unbounded_sequences_Romega.
    prove bounded_sequences_Romega :e Power R_omega_space /\
          unbounded_sequences_Romega :e Power R_omega_space /\
          bounded_sequences_Romega :/\: unbounded_sequences_Romega = Empty /\
          bounded_sequences_Romega <> Empty /\
          unbounded_sequences_Romega <> Empty /\
          bounded_sequences_Romega :\/: unbounded_sequences_Romega = R_omega_space.
    (** Conjunction is left-associative: (((((A /\ B) /\ C) /\ D) /\ E) /\ F) **)
    apply andI.
    - (** ((((A /\ B) /\ C) /\ D) /\ E) **)
      apply andI.
      + (** (((A /\ B) /\ C) /\ D) **)
        apply andI.
        * (** ((A /\ B) /\ C) **)
          apply andI.
          - (** (A /\ B) **)
            apply andI.
            + exact bounded_sequences_Romega_in_Power.
            + exact unbounded_sequences_Romega_in_Power.
          - exact bounded_unbounded_disjoint_Romega.
        * exact bounded_sequences_Romega_nonempty.
      + exact unbounded_sequences_Romega_nonempty.
    - exact bounded_union_unbounded_Romega.
}
exact (Hnosep Hsep).
Qed.

(** from 23 Example 7: R^ in the product topology is connected **) 
(** LATEX VERSION: Let R^ be sequences eventually 0; it is connected as union of R^n; its closure is all of R^ in product topology. **)
Definition Romega_tilde : set -> set := fun n =>
  {f :e R_omega_space | forall i:set, i :e omega -> n :e i -> apply_fun f i = 0}.

Definition Romega_infty : set := Union {Romega_tilde n|n :e omega}.

Theorem Romega_tilde_sub_Romega : forall n:set,
  Romega_tilde n c= R_omega_space.
let n.
let f. assume Hf: f :e Romega_tilde n.
prove f :e R_omega_space.
exact (SepE1 R_omega_space (fun f0:set => forall i:set, i :e omega -> n :e i -> apply_fun f0 i = 0) f Hf).
Qed.

Theorem Romega_infty_sub_Romega : Romega_infty c= R_omega_space.
let f. assume Hf: f :e Romega_infty.
prove f :e R_omega_space.
apply (UnionE_impred {Romega_tilde n|n :e omega} f Hf).
let Y. assume HfY: f :e Y. assume HY: Y :e {Romega_tilde n|n :e omega}.
apply (ReplE_impred omega (fun n:set => Romega_tilde n) Y HY (f :e R_omega_space)).
let n. assume Hn: n :e omega. assume HYeq: Y = Romega_tilde n.
claim HfY2: f :e Romega_tilde n.
{ rewrite <- HYeq.
  exact HfY. }
exact (Romega_tilde_sub_Romega n f HfY2).
Qed.

(** from 23 Example 7: the constant zero sequence in R^omega **)
Definition Romega_zero : set := const_fun omega 0.

Theorem Romega_zero_in_Romega_space : Romega_zero :e R_omega_space.
prove Romega_zero :e R_omega_space.
set Xi := const_space_family omega R R_standard_topology.
set U0 := space_family_union omega Xi.
claim H0omega: 0 :e omega.
{ exact (nat_p_omega 0 nat_0). }
claim HR0: 0 :e R.
{ exact real_0. }
claim HX0: apply_fun Xi 0 = (R, R_standard_topology).
{ exact (const_space_family_apply omega R R_standard_topology 0 H0omega). }
claim Hset0: space_family_set Xi 0 = R.
{ claim Hdef: space_family_set Xi 0 = (apply_fun Xi 0) 0.
  { reflexivity. }
  rewrite Hdef.
  rewrite HX0.
  exact (tuple_2_0_eq R R_standard_topology). }
claim HRfam: R :e {space_family_set Xi i|i :e omega}.
{ apply ReplEq omega (fun i:set => space_family_set Xi i) R.
  assume _ H2. apply H2.
  prove exists i :e omega, R = space_family_set Xi i.
  witness 0.
  apply andI.
  - exact H0omega.
  - prove R = space_family_set Xi 0.
    symmetry.
    exact Hset0. }
claim H0U0: 0 :e U0.
{ exact (UnionI {space_family_set Xi i|i :e omega} 0 R HR0 HRfam). }

prove Romega_zero :e product_space omega Xi.
prove Romega_zero :e {f :e Power (setprod omega (space_family_union omega Xi))|
   function_on f omega (space_family_union omega Xi) /\
   forall i:set, i :e omega -> apply_fun f i :e space_family_set Xi i}.
claim Hsub: Romega_zero c= setprod omega U0.
{ let p. assume Hp: p :e Romega_zero.
  prove p :e setprod omega U0.
  apply (ReplE_impred omega (fun a:set => (a,0)) p Hp (p :e setprod omega U0)).
  let a. assume HaO: a :e omega. assume Hpeq: p = (a,0).
  rewrite Hpeq.
  exact (tuple_2_setprod omega U0 a HaO 0 H0U0). }
claim Hpow: Romega_zero :e Power (setprod omega U0).
{ exact (PowerI (setprod omega U0) Romega_zero Hsub). }
claim Htot: total_function_on Romega_zero omega U0.
{ exact (const_fun_total_function_on omega U0 0 H0U0). }
claim Hfun: function_on Romega_zero omega U0.
{ exact (total_function_on_function_on Romega_zero omega U0 Htot). }
claim Hcoords: forall i:set, i :e omega -> apply_fun Romega_zero i :e space_family_set Xi i.
{ let i. assume Hi: i :e omega.
  prove apply_fun Romega_zero i :e space_family_set Xi i.
  claim Happ: apply_fun Romega_zero i = 0.
  { exact (const_fun_apply omega 0 i Hi). }
  rewrite Happ.
  claim HX: apply_fun Xi i = (R, R_standard_topology).
  { exact (const_space_family_apply omega R R_standard_topology i Hi). }
  claim Hset: space_family_set Xi i = R.
  { claim Hdef: space_family_set Xi i = (apply_fun Xi i) 0.
    { reflexivity. }
    rewrite Hdef.
    rewrite HX.
    exact (tuple_2_0_eq R R_standard_topology). }
  rewrite Hset.
  exact real_0. }
claim Hprop: function_on Romega_zero omega U0 /\ forall i:set, i :e omega -> apply_fun Romega_zero i :e space_family_set Xi i.
{ apply andI.
  - exact Hfun.
  - exact Hcoords. }
exact (SepI (Power (setprod omega U0))
            (fun f:set => function_on f omega U0 /\ forall i:set, i :e omega -> apply_fun f i :e space_family_set Xi i)
            Romega_zero
            Hpow
            Hprop).
Qed.

Theorem Romega_zero_in_Romega_tilde : forall n:set,
  n :e omega -> Romega_zero :e Romega_tilde n.
let n. assume HnO: n :e omega.
prove Romega_zero :e Romega_tilde n.
claim Hbase: Romega_zero :e R_omega_space.
{ exact Romega_zero_in_Romega_space. }
claim Hprop: forall i:set, i :e omega -> n :e i -> apply_fun Romega_zero i = 0.
{ let i. assume Hi: i :e omega.
  assume Hni: n :e i.
  prove apply_fun Romega_zero i = 0.
  exact (const_fun_apply omega 0 i Hi). }
exact (SepI R_omega_space
           (fun f0:set => forall i:set, i :e omega -> n :e i -> apply_fun f0 i = 0)
           Romega_zero
           Hbase
           Hprop).
Qed.

Theorem Romega_tilde_nonempty : forall n:set,
  n :e omega -> Romega_tilde n <> Empty.
let n. assume HnO: n :e omega.
prove Romega_tilde n <> Empty.
assume HEmpty: Romega_tilde n = Empty.
prove False.
claim H0in: Romega_zero :e Romega_tilde n.
{ exact (Romega_zero_in_Romega_tilde n HnO). }
claim H0E: Romega_zero :e Empty.
{ rewrite <- HEmpty.
  exact H0in. }
exact (EmptyE Romega_zero H0E).
Qed.

(** from 23 Example 7: product topology on R^omega is a topology **)
Theorem Romega_product_topology_is_topology : topology_on R_omega_space R_omega_product_topology.
prove topology_on R_omega_space R_omega_product_topology.
set Xi := const_space_family omega R R_standard_topology.
set X := product_space omega Xi.
set S := product_subbasis_full omega Xi.
set Tx := generated_topology_from_subbasis X S.

claim H0omega: 0 :e omega.
{ exact (nat_p_omega 0 nat_0). }

claim HcompTop: forall i:set, i :e omega -> topology_on (space_family_set Xi i) (space_family_topology Xi i).
{ let i. assume Hi: i :e omega.
  prove topology_on (space_family_set Xi i) (space_family_topology Xi i).
  claim HXi: apply_fun Xi i = (R, R_standard_topology).
  { exact (const_space_family_apply omega R R_standard_topology i Hi). }
  claim Hset: space_family_set Xi i = R.
  { claim Hdef: space_family_set Xi i = (apply_fun Xi i) 0.
    { reflexivity. }
    rewrite Hdef.
    rewrite HXi.
    exact (tuple_2_0_eq R R_standard_topology). }
  claim HTi: space_family_topology Xi i = R_standard_topology.
  { claim Hdef: space_family_topology Xi i = (apply_fun Xi i) 1.
    { reflexivity. }
    rewrite Hdef.
    rewrite HXi.
    exact (tuple_2_1_eq R R_standard_topology). }
  rewrite Hset.
  rewrite HTi.
  exact R_standard_topology_is_topology_local. }

claim HSsub: S c= Power X.
{ let s. assume Hs: s :e S.
  prove s :e Power X.
  apply PowerI.
  let f. assume Hf: f :e s.
  prove f :e X.
  set F := (fun i:set => {product_cylinder omega Xi i U|U :e space_family_topology Xi i}).
  claim HsF: s :e (\/_ i :e omega, F i).
  { exact Hs. }
  apply (famunionE_impred omega F s HsF).
  let i. assume Hi: i :e omega. assume HsFi: s :e F i.
  apply (ReplE_impred (space_family_topology Xi i) (fun U0:set => product_cylinder omega Xi i U0) s HsFi (f :e X)).
  let U0. assume HU0: U0 :e space_family_topology Xi i.
  assume Hseq: s = product_cylinder omega Xi i U0.
  claim HfCyl: f :e product_cylinder omega Xi i U0.
  { rewrite <- Hseq.
    exact Hf. }
  exact (SepE1 X
              (fun g0:set => i :e omega /\ U0 :e space_family_topology Xi i /\ apply_fun g0 i :e U0)
              f
              HfCyl). }

claim HUnionS: Union S = X.
{ apply set_ext.
  - let f. assume Hf: f :e Union S.
    prove f :e X.
    apply UnionE_impred S f Hf.
    let s. assume Hfs: f :e s. assume HsS: s :e S.
    claim HsPow: s :e Power X.
    { exact (HSsub s HsS). }
    exact (PowerE X s HsPow f Hfs).
  - let f. assume Hf: f :e X.
    prove f :e Union S.
    set i0 := 0.
    set U0 := space_family_set Xi i0.
    set s0 := product_cylinder omega Xi i0 U0.
    claim Hi0: i0 :e omega.
    { exact H0omega. }
    claim HTi0: topology_on (space_family_set Xi i0) (space_family_topology Xi i0).
    { exact (HcompTop i0 Hi0). }
    claim HU0top: U0 :e space_family_topology Xi i0.
    { exact (topology_has_X (space_family_set Xi i0) (space_family_topology Xi i0) HTi0). }
    claim Hs0S: s0 :e S.
    { set F := (fun i:set => {product_cylinder omega Xi i U|U :e space_family_topology Xi i}).
      claim Hs0Fi0: s0 :e F i0.
      { exact (ReplI (space_family_topology Xi i0)
                     (fun U:set => product_cylinder omega Xi i0 U)
                     U0
                     HU0top). }
      exact (famunionI omega F i0 s0 Hi0 Hs0Fi0). }
    prove f :e Union S.
    apply (UnionI S f s0).
    - prove f :e s0.
      prove f :e {g :e X | i0 :e omega /\ U0 :e space_family_topology Xi i0 /\ apply_fun g i0 :e U0}.
      apply (SepI X
               (fun g0:set => i0 :e omega /\ U0 :e space_family_topology Xi i0 /\ apply_fun g0 i0 :e U0)
               f
               Hf).
      prove i0 :e omega /\ U0 :e space_family_topology Xi i0 /\ apply_fun f i0 :e U0.
      apply andI.
      + prove i0 :e omega /\ U0 :e space_family_topology Xi i0.
        apply andI.
        - exact Hi0.
        - exact HU0top.
      + claim Hfprop: function_on f omega (space_family_union omega Xi) /\
            forall i:set, i :e omega -> apply_fun f i :e space_family_set Xi i.
          { exact (SepE2 (Power (setprod omega (space_family_union omega Xi)))
                         (fun f0:set => function_on f0 omega (space_family_union omega Xi) /\
                           forall i:set, i :e omega -> apply_fun f0 i :e space_family_set Xi i)
                         f
                         Hf). }
          claim Hcoords: forall i:set, i :e omega -> apply_fun f i :e space_family_set Xi i.
          { exact (andER (function_on f omega (space_family_union omega Xi))
                         (forall i:set, i :e omega -> apply_fun f i :e space_family_set Xi i)
                         Hfprop). }
          exact (Hcoords i0 Hi0).
    - exact Hs0S. }

claim HS: subbasis_on X S.
{ prove S c= Power X /\ Union S = X.
  apply andI.
  - exact HSsub.
  - exact HUnionS. }
claim HTx: topology_on X Tx.
{ exact (topology_from_subbasis_is_topology X S HS). }
claim HXe: X = R_omega_space.
{ reflexivity. }
claim HTXe: Tx = R_omega_product_topology.
{ reflexivity. }
rewrite <- HXe.
rewrite <- HTXe.
exact HTx.
Qed.

(** from 23: dense set meets every nonempty open set **)
Theorem dense_in_meets_nonempty_open : forall A X Tx U:set,
  topology_on X Tx ->
  closure_of X Tx A = X ->
  U :e Tx ->
  U <> Empty ->
  U :/\: A <> Empty.
let A X Tx U.
assume HTx: topology_on X Tx.
assume Hdense: closure_of X Tx A = X.
assume HU: U :e Tx.
assume HUne: U <> Empty.
claim Hexx: exists x:set, x :e U.
{ exact (nonempty_has_element U HUne). }
apply Hexx.
let x. assume HxU: x :e U.
claim HTsub: Tx c= Power X.
{ exact (topology_subset_axiom X Tx HTx). }
claim HUpow: U :e Power X.
{ exact (HTsub U HU). }
claim HxX: x :e X.
{ exact (PowerE X U HUpow x HxU). }
claim Hcl: x :e closure_of X Tx A.
{ rewrite Hdense.
  exact HxX. }
claim Hcliff: x :e closure_of X Tx A <-> (forall V :e Tx, x :e V -> V :/\: A <> Empty).
{ exact (closure_characterization X Tx A x HTx HxX). }
claim Hneigh: forall V :e Tx, x :e V -> V :/\: A <> Empty.
{ exact (iffEL (x :e closure_of X Tx A) (forall V :e Tx, x :e V -> V :/\: A <> Empty) Hcliff Hcl). }
exact (Hneigh U HU HxU).
Qed.

(** from 23: dense connected subset implies connected space **)
Theorem connected_space_if_dense_connected_subset : forall X Tx A:set,
  topology_on X Tx ->
  A c= X ->
  connected_space A (subspace_topology X Tx A) ->
  closure_of X Tx A = X ->
  connected_space X Tx.
let X Tx A.
assume HTx: topology_on X Tx.
assume HAsub: A c= X.
assume HAconn: connected_space A (subspace_topology X Tx A).
assume Hdense: closure_of X Tx A = X.
prove connected_space X Tx.
prove topology_on X Tx /\ ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).
apply andI.
- exact HTx.
- prove ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).
  assume Hsep: exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V.
  apply Hsep.
  let U. assume HexV: exists V:set, U :e Tx /\ V :e Tx /\ separation_of X U V.
  apply HexV.
  let V. assume HUVsep.
  claim HUV12: U :e Tx /\ V :e Tx.
  { exact (andEL (U :e Tx /\ V :e Tx) (separation_of X U V) HUVsep). }
  claim HU: U :e Tx.
  { exact (andEL (U :e Tx) (V :e Tx) HUV12). }
  claim HV: V :e Tx.
  { exact (andER (U :e Tx) (V :e Tx) HUV12). }
  claim HsepUV: separation_of X U V.
  { exact (andER (U :e Tx /\ V :e Tx) (separation_of X U V) HUVsep). }
  claim HsepL: ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty).
  { exact (andEL ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                 (U :\/: V = X)
                 HsepUV). }
  claim HUVdisj: (U :e Power X /\ V :e Power X) /\ U :/\: V = Empty.
  { exact (andEL ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty)
                 (U <> Empty)
                 (andEL (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty)
                        (V <> Empty)
                        HsepL)). }
  claim HUVempty: U :/\: V = Empty.
  { exact (andER (U :e Power X /\ V :e Power X) (U :/\: V = Empty) HUVdisj). }
  claim HU0: U <> Empty.
  { exact (andER ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) (U <> Empty)
                 (andEL (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty)
                        (V <> Empty)
                        HsepL)). }
  claim HV0: V <> Empty.
  { exact (andER (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty)
                 (V <> Empty)
                 HsepL). }
  claim Hside: A c= U \/ A c= V.
  { exact (connected_subset_in_separation_side X Tx U V A HTx HAsub HAconn HU HV HsepUV). }
  apply Hside.
  - assume HAU: A c= U.
    claim HVneA: V :/\: A <> Empty.
    { exact (dense_in_meets_nonempty_open A X Tx V HTx Hdense HV HV0). }
    claim HVAsubEmpty: V :/\: A c= Empty.
    { let x. assume Hx: x :e V :/\: A.
      prove x :e Empty.
      claim HxV: x :e V.
      { exact (binintersectE1 V A x Hx). }
      claim HxA: x :e A.
      { exact (binintersectE2 V A x Hx). }
      claim HxU: x :e U.
      { exact (HAU x HxA). }
      claim HxUV: x :e U :/\: V.
      { exact (binintersectI U V x HxU HxV). }
      claim HxE: x :e Empty.
      { rewrite <- HUVempty.
        exact HxUV. }
      exact HxE. }
    claim HVAEq: V :/\: A = Empty.
    { exact (Empty_Subq_eq (V :/\: A) HVAsubEmpty). }
    apply HVneA.
    exact HVAEq.
  - assume HAV: A c= V.
    claim HUneA: U :/\: A <> Empty.
    { exact (dense_in_meets_nonempty_open A X Tx U HTx Hdense HU HU0). }
    claim HUAsubEmpty: U :/\: A c= Empty.
    { let x. assume Hx: x :e U :/\: A.
      prove x :e Empty.
      claim HxU: x :e U.
      { exact (binintersectE1 U A x Hx). }
      claim HxA: x :e A.
      { exact (binintersectE2 U A x Hx). }
      claim HxV: x :e V.
      { exact (HAV x HxA). }
      claim HxUV: x :e U :/\: V.
      { exact (binintersectI U V x HxU HxV). }
      claim HxE: x :e Empty.
      { rewrite <- HUVempty.
        exact HxUV. }
      exact HxE. }
    claim HUAEq: U :/\: A = Empty.
    { exact (Empty_Subq_eq (U :/\: A) HUAsubEmpty). }
    apply HUneA.
    exact HUAEq.
Qed.

(** from 23 Example 7: each Romega_tilde n is connected in the product topology **) 
(** LATEX VERSION: Each R^n is connected, hence the subspace of sequences supported on {0,...,n} is connected. **)
Theorem Romega_tilde_connected : forall n:set,
  n :e omega ->
  connected_space (Romega_tilde n)
    (subspace_topology R_omega_space R_omega_product_topology (Romega_tilde n)).
let n. assume HnO: n :e omega.
set X := R_omega_space.
set Tx := R_omega_product_topology.
prove connected_space (Romega_tilde n) (subspace_topology X Tx (Romega_tilde n)).
claim HTx: topology_on X Tx.
{ exact Romega_product_topology_is_topology. }
claim HnNat: nat_p n.
{ exact (omega_nat_p n HnO). }
(** Induction on n. Romega_tilde n corresponds to sequences supported on {0,...,n}. **)
apply (nat_ind (fun k:set => connected_space (Romega_tilde k) (subspace_topology X Tx (Romega_tilde k)))).
- (** Base: k = 0. This should be homeomorphic to R. **)
  (** First prove the subspace topology is a topology. **)
  claim Hsub0: Romega_tilde 0 c= X.
  { exact (Romega_tilde_sub_Romega 0). }
  claim HT0: topology_on (Romega_tilde 0) (subspace_topology X Tx (Romega_tilde 0)).
  { exact (subspace_topology_is_topology X Tx (Romega_tilde 0) HTx Hsub0). }
  (** Connectedness proof is postponed. **)
  apply andI.
  - exact HT0.
  - admit.
- (** Step: k -> ordsucc k. This should be homeomorphic to (Romega_tilde k) times R. **)
  let k. assume HkNat: nat_p k.
  assume IHk: connected_space (Romega_tilde k) (subspace_topology X Tx (Romega_tilde k)).
  prove connected_space (Romega_tilde (ordsucc k)) (subspace_topology X Tx (Romega_tilde (ordsucc k))).
  (** First prove the subspace topology is a topology. **)
  claim HsubS: Romega_tilde (ordsucc k) c= X.
  { exact (Romega_tilde_sub_Romega (ordsucc k)). }
  claim HTS: topology_on (Romega_tilde (ordsucc k)) (subspace_topology X Tx (Romega_tilde (ordsucc k))).
  { exact (subspace_topology_is_topology X Tx (Romega_tilde (ordsucc k)) HTx HsubS). }
  (** Connectedness step is postponed. **)
  apply andI.
  - exact HTS.
  - admit.
- exact HnNat.
Qed.

(** from 23 Example 7: Romega_infty is connected as a union of connected sets with a common point **) 
(** LATEX VERSION: R^infty is the union of the connected subspaces R^n and they share the zero sequence. **)
Theorem Romega_infty_connected :
  connected_space Romega_infty
    (subspace_topology R_omega_space R_omega_product_topology Romega_infty).
prove connected_space Romega_infty (subspace_topology R_omega_space R_omega_product_topology Romega_infty).
set X := R_omega_space.
set Tx := R_omega_product_topology.
set F := {Romega_tilde n|n :e omega}.
claim HTx: topology_on X Tx.
{ exact Romega_product_topology_is_topology. }
claim HFsub: forall C:set, C :e F -> C c= X.
{ let C. assume HC: C :e F.
  prove C c= X.
  apply (ReplE_impred omega (fun n:set => Romega_tilde n) C HC (C c= X)).
  let n. assume Hn: n :e omega. assume HCeq: C = Romega_tilde n.
  rewrite HCeq.
  exact (Romega_tilde_sub_Romega n). }
claim HFconn: forall C:set, C :e F -> connected_space C (subspace_topology X Tx C).
{ let C. assume HC: C :e F.
  prove connected_space C (subspace_topology X Tx C).
  apply (ReplE_impred omega (fun n:set => Romega_tilde n) C HC (connected_space C (subspace_topology X Tx C))).
  let n. assume Hn: n :e omega. assume HCeq: C = Romega_tilde n.
  rewrite HCeq.
  exact (Romega_tilde_connected n Hn). }
claim Hcommon: exists x:set, forall C:set, C :e F -> x :e C.
{ witness Romega_zero.
  let C. assume HC: C :e F.
  prove Romega_zero :e C.
  apply (ReplE_impred omega (fun n:set => Romega_tilde n) C HC (Romega_zero :e C)).
  let n. assume Hn: n :e omega. assume HCeq: C = Romega_tilde n.
  rewrite HCeq.
  exact (Romega_zero_in_Romega_tilde n Hn). }
claim HconnUnion: connected_space (Union F) (subspace_topology X Tx (Union F)).
{ exact (union_connected_common_point X Tx F HTx HFsub HFconn Hcommon). }
claim HUnionEq: Union F = Romega_infty.
{ reflexivity. }
rewrite HUnionEq.
rewrite HUnionEq at 1.
exact HconnUnion.
Qed.

(** Helper: any omega indexed real map gives an element of R_omega_space **)
Theorem graph_omega_in_Romega_space : forall h:set->set,
  (forall i:set, i :e omega -> h i :e R) ->
  graph omega h :e R_omega_space.
let h.
assume HhR: forall i:set, i :e omega -> h i :e R.
prove graph omega h :e R_omega_space.
set Xi := const_space_family omega R R_standard_topology.
set U0 := space_family_union omega Xi.
claim H0omega: 0 :e omega.
{ exact (nat_p_omega 0 nat_0). }
claim HXi0: apply_fun Xi 0 = (R, R_standard_topology).
{ exact (const_space_family_apply omega R R_standard_topology 0 H0omega). }
claim Hset0: space_family_set Xi 0 = R.
{ claim Hdef: space_family_set Xi 0 = (apply_fun Xi 0) 0.
  { reflexivity. }
  rewrite Hdef.
  rewrite HXi0.
  exact (tuple_2_0_eq R R_standard_topology). }
claim HRfam: R :e {space_family_set Xi i|i :e omega}.
{ apply ReplEq omega (fun i:set => space_family_set Xi i) R.
  assume _ H2. apply H2.
  prove exists i :e omega, R = space_family_set Xi i.
  witness 0.
  apply andI.
  - exact H0omega.
  - prove R = space_family_set Xi 0.
    symmetry.
    exact Hset0. }
claim HRinU0: forall r:set, r :e R -> r :e U0.
{ let r. assume Hr: r :e R.
  exact (UnionI {space_family_set Xi i|i :e omega} r R Hr HRfam). }
claim Hsub: graph omega h c= setprod omega U0.
{ let p. assume Hp: p :e graph omega h.
  prove p :e setprod omega U0.
  apply (ReplE_impred omega (fun i:set => (i, h i)) p Hp (p :e setprod omega U0)).
  let i. assume Hi: i :e omega. assume Heq: p = (i, h i).
  rewrite Heq.
  claim HhiR: h i :e R.
  { exact (HhR i Hi). }
  claim HhiU0: h i :e U0.
  { exact (HRinU0 (h i) HhiR). }
  exact (tuple_2_setprod omega U0 i Hi (h i) HhiU0). }
claim Hpow: graph omega h :e Power (setprod omega U0).
{ exact (PowerI (setprod omega U0) (graph omega h) Hsub). }
claim Hfun: function_on (graph omega h) omega U0.
{ let i. assume Hi: i :e omega.
  prove apply_fun (graph omega h) i :e U0.
  claim Happ: apply_fun (graph omega h) i = h i.
  { exact (apply_fun_graph omega h i Hi). }
  rewrite Happ.
  exact (HRinU0 (h i) (HhR i Hi)). }
claim Hcoords: forall i:set, i :e omega -> apply_fun (graph omega h) i :e space_family_set Xi i.
{ let i. assume Hi: i :e omega.
  prove apply_fun (graph omega h) i :e space_family_set Xi i.
  claim Happ: apply_fun (graph omega h) i = h i.
  { exact (apply_fun_graph omega h i Hi). }
  rewrite Happ.
  claim HXi: apply_fun Xi i = (R, R_standard_topology).
  { exact (const_space_family_apply omega R R_standard_topology i Hi). }
  claim Hset: space_family_set Xi i = R.
  { claim Hdef: space_family_set Xi i = (apply_fun Xi i) 0.
    { reflexivity. }
    rewrite Hdef.
    rewrite HXi.
    exact (tuple_2_0_eq R R_standard_topology). }
  rewrite Hset.
  exact (HhR i Hi). }
claim Hprop: function_on (graph omega h) omega U0 /\
  forall i:set, i :e omega -> apply_fun (graph omega h) i :e space_family_set Xi i.
{ apply andI.
  - exact Hfun.
  - exact Hcoords. }
exact (SepI (Power (setprod omega U0))
            (fun f0:set => function_on f0 omega U0 /\
              forall i:set, i :e omega -> apply_fun f0 i :e space_family_set Xi i)
            (graph omega h)
            Hpow
            Hprop).
Qed.

(** Helper: a sequence supported at coordinate 0 **)
Definition Romega_singleton_seq : set -> set := fun r =>
  graph omega (fun i:set => If_i (0 :e i) 0 r).

(** Helper: singleton sequence is in the ambient product space **)
Theorem Romega_singleton_seq_in_Romega_space : forall r:set,
  r :e R -> Romega_singleton_seq r :e R_omega_space.
let r. assume Hr: r :e R.
prove Romega_singleton_seq r :e R_omega_space.
claim Hdef: Romega_singleton_seq r = graph omega (fun i:set => If_i (0 :e i) 0 r).
{ reflexivity. }
rewrite Hdef.
apply (graph_omega_in_Romega_space (fun i:set => If_i (0 :e i) 0 r)).
let i. assume Hi: i :e omega.
prove If_i (0 :e i) 0 r :e R.
apply (xm (0 :e i)).
- assume H0i: 0 :e i.
  rewrite (If_i_1 (0 :e i) 0 r H0i).
  exact real_0.
- assume Hn0i: ~(0 :e i).
  rewrite (If_i_0 (0 :e i) 0 r Hn0i).
  exact Hr.
Qed.

(** Helper: coordinate evaluation of the singleton sequence **)
(** LATEX VERSION: For the singleton sequence r  (r,0,0,...), the i-th coordinate is If(0 in i) then 0 else r. **)
Theorem Romega_singleton_seq_apply : forall r i:set,
  r :e R ->
  i :e omega ->
  apply_fun (Romega_singleton_seq r) i = If_i (0 :e i) 0 r.
let r i.
assume Hr: r :e R.
assume Hi: i :e omega.
prove apply_fun (Romega_singleton_seq r) i = If_i (0 :e i) 0 r.
claim Hdef: Romega_singleton_seq r = graph omega (fun j:set => If_i (0 :e j) 0 r).
{ reflexivity. }
rewrite Hdef.
exact (apply_fun_graph omega (fun j:set => If_i (0 :e j) 0 r) i Hi).
Qed.

(** Helper: singleton sequence is in Romega_tilde 0 **)
Theorem Romega_singleton_seq_in_Romega_tilde0 : forall r:set,
  r :e R -> Romega_singleton_seq r :e Romega_tilde 0.
let r. assume Hr: r :e R.
prove Romega_singleton_seq r :e Romega_tilde 0.
claim HdefT: Romega_tilde 0 =
  {f :e R_omega_space | forall i:set, i :e omega -> 0 :e i -> apply_fun f i = 0}.
{ reflexivity. }
rewrite HdefT.
apply (SepI R_omega_space (fun f0:set => forall i:set, i :e omega -> 0 :e i -> apply_fun f0 i = 0)).
- exact (Romega_singleton_seq_in_Romega_space r Hr).
- let i. assume Hi: i :e omega.
  assume H0i: 0 :e i.
  prove apply_fun (Romega_singleton_seq r) i = 0.
  claim Happ: apply_fun (Romega_singleton_seq r) i = If_i (0 :e i) 0 r.
  { claim Hdef: Romega_singleton_seq r = graph omega (fun j:set => If_i (0 :e j) 0 r).
    { reflexivity. }
    rewrite Hdef.
    exact (apply_fun_graph omega (fun j:set => If_i (0 :e j) 0 r) i Hi). }
  rewrite Happ.
  rewrite (If_i_1 (0 :e i) 0 r H0i).
  reflexivity.
Qed.

(** Helper: map r in R to the singleton sequence **)
Definition Romega_singleton_map : set := graph R Romega_singleton_seq.

(** Helper: apply_fun for Romega_singleton_map **)
Theorem Romega_singleton_map_apply : forall r:set,
  r :e R -> apply_fun Romega_singleton_map r = Romega_singleton_seq r.
let r. assume Hr: r :e R.
prove apply_fun Romega_singleton_map r = Romega_singleton_seq r.
claim Hdef: Romega_singleton_map = graph R Romega_singleton_seq.
{ reflexivity. }
rewrite Hdef.
exact (apply_fun_graph R Romega_singleton_seq r Hr).
Qed.

(** Helper: singleton map is a function into the ambient product space **)
Theorem Romega_singleton_map_function_on :
  function_on Romega_singleton_map R R_omega_space.
prove function_on Romega_singleton_map R R_omega_space.
let r. assume Hr: r :e R.
prove apply_fun Romega_singleton_map r :e R_omega_space.
rewrite (Romega_singleton_map_apply r Hr).
exact (Romega_singleton_seq_in_Romega_space r Hr).
Qed.

(** Helper: singleton map is continuous into the product topology on R_omega_space **)
(** LATEX VERSION: The coordinate-inclusion map r  (r,0,0,...) is continuous in the product topology. **)
Theorem Romega_singleton_map_continuous_prod :
  continuous_map R R_standard_topology R_omega_space R_omega_product_topology Romega_singleton_map.
prove continuous_map R R_standard_topology R_omega_space R_omega_product_topology Romega_singleton_map.
set Xi := const_space_family omega R R_standard_topology.
set S := product_subbasis_full omega Xi.
claim HtopR: topology_on R R_standard_topology.
{ exact R_standard_topology_is_topology. }
claim Hfun: function_on Romega_singleton_map R R_omega_space.
{ exact Romega_singleton_map_function_on. }
claim Hone: omega <> Empty.
{ claim H0o: 0 :e omega.
  { exact (nat_p_omega 0 nat_0). }
  exact (elem_implies_nonempty omega 0 H0o). }
claim Hcomp: forall i:set, i :e omega -> topology_on (space_family_set Xi i) (space_family_topology Xi i).
{ let i. assume Hi: i :e omega.
  claim HXi: apply_fun Xi i = (R, R_standard_topology).
  { exact (const_space_family_apply omega R R_standard_topology i Hi). }
  claim Hset: space_family_set Xi i = R.
  { claim Hdef: space_family_set Xi i = (apply_fun Xi i) 0.
    { reflexivity. }
    rewrite Hdef.
    rewrite HXi.
    exact (tuple_2_0_eq R R_standard_topology). }
  claim Htop: space_family_topology Xi i = R_standard_topology.
  { claim Hdef: space_family_topology Xi i = (apply_fun Xi i) 1.
    { reflexivity. }
    rewrite Hdef.
    rewrite HXi.
    exact (tuple_2_1_eq R R_standard_topology). }
  rewrite Hset.
  rewrite Htop.
  exact R_standard_topology_is_topology. }
claim HS: subbasis_on R_omega_space S.
{ prove S c= Power R_omega_space /\ Union S = R_omega_space.
  apply andI.
  - let s. assume Hs: s :e S.
    prove s :e Power R_omega_space.
    apply PowerI.
    let f. assume Hf: f :e s.
    prove f :e R_omega_space.
    set F := (fun i:set => {product_cylinder omega Xi i U|U :e space_family_topology Xi i}).
    claim HsF: s :e (\/_ i :e omega, F i).
    { exact Hs. }
    apply (famunionE_impred omega F s HsF (f :e R_omega_space)).
    let i. assume Hi: i :e omega.
    assume HsFi: s :e F i.
    apply (ReplE_impred (space_family_topology Xi i) (fun U0:set => product_cylinder omega Xi i U0) s HsFi
                        (f :e R_omega_space)).
    let U.
    assume HU: U :e space_family_topology Xi i.
    assume Hseq: s = product_cylinder omega Xi i U.
    claim HfCyl: f :e product_cylinder omega Xi i U.
    { rewrite <- Hseq.
      exact Hf. }
    claim Hfprod: f :e product_space omega Xi.
    { exact (SepE1 (product_space omega Xi)
                   (fun g:set => i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U)
                   f
                   HfCyl). }
    exact Hfprod.
  - (** Union S = R_omega_space **)
    apply set_ext.
    - let f. assume Hf: f :e Union S.
      prove f :e R_omega_space.
      claim HSsubPow: S c= Power R_omega_space.
      { let s. assume Hs: s :e S.
        prove s :e Power R_omega_space.
        apply PowerI.
        let g. assume Hg: g :e s.
        prove g :e R_omega_space.
        set F := (fun i:set => {product_cylinder omega Xi i U|U :e space_family_topology Xi i}).
        claim HsF: s :e (\/_ i :e omega, F i).
        { exact Hs. }
        apply (famunionE_impred omega F s HsF (g :e R_omega_space)).
        let i. assume Hi: i :e omega.
        assume HsFi: s :e F i.
        apply (ReplE_impred (space_family_topology Xi i) (fun U0:set => product_cylinder omega Xi i U0) s HsFi
                            (g :e R_omega_space)).
        let U.
        assume HU: U :e space_family_topology Xi i.
        assume Hseq: s = product_cylinder omega Xi i U.
        claim HgCyl: g :e product_cylinder omega Xi i U.
        { rewrite <- Hseq.
          exact Hg. }
        exact (SepE1 (product_space omega Xi)
                     (fun h:set => i :e omega /\ U :e space_family_topology Xi i /\ apply_fun h i :e U)
                     g
                     HgCyl). }
      apply (UnionE_impred S f Hf).
      let s. assume Hfs: f :e s. assume Hs: s :e S.
      claim HsPow: s :e Power R_omega_space.
      { exact (HSsubPow s Hs). }
      claim HsSub: s c= R_omega_space.
      { exact (PowerE R_omega_space s HsPow). }
      exact (HsSub f Hfs).
    - let f. assume Hf: f :e R_omega_space.
      prove f :e Union S.
      claim H0o: 0 :e omega.
      { exact (nat_p_omega 0 nat_0). }
      claim HXi0: apply_fun Xi 0 = (R, R_standard_topology).
      { exact (const_space_family_apply omega R R_standard_topology 0 H0o). }
      claim Htop0: space_family_topology Xi 0 = R_standard_topology.
      { claim Hdef: space_family_topology Xi 0 = (apply_fun Xi 0) 1.
        { reflexivity. }
        rewrite Hdef.
        rewrite HXi0.
        exact (tuple_2_1_eq R R_standard_topology). }
      claim HRin: R :e space_family_topology Xi 0.
      { rewrite Htop0.
        exact (topology_has_X R R_standard_topology R_standard_topology_is_topology). }
      set s0 := product_cylinder omega Xi 0 R.
      claim Hs0S: s0 :e S.
      { set F := (fun i:set => {product_cylinder omega Xi i U|U :e space_family_topology Xi i}).
        claim Hs0F0: s0 :e F 0.
        { exact (ReplI (space_family_topology Xi 0) (fun U0:set => product_cylinder omega Xi 0 U0) R HRin). }
        exact (famunionI omega F 0 s0 H0o Hs0F0). }
      claim Hf0R: apply_fun f 0 :e R.
      { exact (Romega_coord_in_R f 0 Hf H0o). }
      claim HXdef: R_omega_space = product_space omega Xi.
      { reflexivity. }
      claim Hfprod: f :e product_space omega Xi.
      { rewrite <- HXdef.
        exact Hf. }
      claim Hfs0: f :e s0.
      { claim Hs0def: s0 = product_cylinder omega Xi 0 R.
        { reflexivity. }
        rewrite Hs0def.
        claim Hcyl_def: product_cylinder omega Xi 0 R =
          {g :e product_space omega Xi | 0 :e omega /\ R :e space_family_topology Xi 0 /\ apply_fun g 0 :e R}.
        { reflexivity. }
        rewrite Hcyl_def.
        apply (SepI (product_space omega Xi)
                    (fun g:set => 0 :e omega /\ R :e space_family_topology Xi 0 /\ apply_fun g 0 :e R)
                    f
                    Hfprod).
        apply andI.
        - apply andI.
          + exact H0o.
          + exact HRin.
        - exact Hf0R. }
      exact (UnionI S f s0 Hfs0 Hs0S).
}
claim Hpre: forall s:set, s :e S -> preimage_of R Romega_singleton_map s :e R_standard_topology.
{ let s. assume Hs: s :e S.
  set F := (fun i:set => {product_cylinder omega Xi i U|U :e space_family_topology Xi i}).
  claim HsF: s :e (\/_ i :e omega, F i).
  { exact Hs. }
  apply (famunionE_impred omega F s HsF (preimage_of R Romega_singleton_map s :e R_standard_topology)).
  let i. assume Hi: i :e omega.
  assume HsFi: s :e F i.
  apply (ReplE_impred (space_family_topology Xi i) (fun U0:set => product_cylinder omega Xi i U0) s HsFi
                      (preimage_of R Romega_singleton_map s :e R_standard_topology)).
  let U. assume HUtop: U :e space_family_topology Xi i.
  assume Hseq: s = product_cylinder omega Xi i U.
  rewrite Hseq.
  claim HXi: apply_fun Xi i = (R, R_standard_topology).
  { exact (const_space_family_apply omega R R_standard_topology i Hi). }
  claim Htopi: space_family_topology Xi i = R_standard_topology.
  { claim Hdef: space_family_topology Xi i = (apply_fun Xi i) 1.
    { reflexivity. }
    rewrite Hdef.
    rewrite HXi.
    exact (tuple_2_1_eq R R_standard_topology). }
  claim HUstd: U :e R_standard_topology.
  { rewrite <- Htopi.
    exact HUtop. }
  claim HUsubR: U c= R.
  { claim HtopSub: R_standard_topology c= Power R.
    { exact (topology_subset_axiom R R_standard_topology R_standard_topology_is_topology). }
    claim HUpow: U :e Power R.
    { exact (HtopSub U HUstd). }
    exact (PowerE R U HUpow). }
  apply (xm (0 :e i)).
  + assume H0i: 0 :e i.
    apply (xm (0 :e U)).
    - assume H0U: 0 :e U.
      claim Heq: preimage_of R Romega_singleton_map (product_cylinder omega Xi i U) = R.
      { apply set_ext.
        - let r. assume Hrpre: r :e preimage_of R Romega_singleton_map (product_cylinder omega Xi i U).
          prove r :e R.
          claim Hrpre2: r :e {x0 :e R | apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U}.
          { claim Hpre_def: preimage_of R Romega_singleton_map (product_cylinder omega Xi i U) =
              {x0 :e R | apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U}.
            { reflexivity. }
            rewrite <- Hpre_def.
            exact Hrpre. }
          exact (SepE1 R (fun x0:set => apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U) r Hrpre2).
        - let r. assume HrR: r :e R.
          prove r :e preimage_of R Romega_singleton_map (product_cylinder omega Xi i U).
          claim Hpre_def: preimage_of R Romega_singleton_map (product_cylinder omega Xi i U) =
            {x0 :e R | apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U}.
          { reflexivity. }
          rewrite Hpre_def.
          apply (SepI R (fun x0:set => apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U) r HrR).
          prove apply_fun Romega_singleton_map r :e product_cylinder omega Xi i U.
          claim Happmap: apply_fun Romega_singleton_map r = Romega_singleton_seq r.
          { exact (Romega_singleton_map_apply r HrR). }
          rewrite Happmap.
          claim HXdef: R_omega_space = product_space omega Xi.
          { reflexivity. }
          claim Hrseq: Romega_singleton_seq r :e product_space omega Xi.
          { rewrite <- HXdef.
            exact (Romega_singleton_seq_in_Romega_space r HrR). }
          claim Hcyl_def: product_cylinder omega Xi i U =
            {g :e product_space omega Xi | i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U}.
          { reflexivity. }
          rewrite Hcyl_def.
          apply (SepI (product_space omega Xi)
                      (fun g:set => i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U)
                      (Romega_singleton_seq r)
                      Hrseq).
          apply andI.
          + apply andI.
            * exact Hi.
            * exact HUtop.
          + claim Happi: apply_fun (Romega_singleton_seq r) i = If_i (0 :e i) 0 r.
            { exact (Romega_singleton_seq_apply r i HrR Hi). }
            rewrite Happi.
            rewrite (If_i_1 (0 :e i) 0 r H0i).
            exact H0U. }
      rewrite Heq.
      exact (topology_has_X R R_standard_topology R_standard_topology_is_topology).
    - assume Hn0U: ~(0 :e U).
      claim Heq: preimage_of R Romega_singleton_map (product_cylinder omega Xi i U) = Empty.
      { apply set_ext.
        - let r. assume Hrpre: r :e preimage_of R Romega_singleton_map (product_cylinder omega Xi i U).
          prove r :e Empty.
          apply FalseE.
          claim Hrpre2: r :e {x0 :e R | apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U}.
          { claim Hpre_def: preimage_of R Romega_singleton_map (product_cylinder omega Xi i U) =
              {x0 :e R | apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U}.
            { reflexivity. }
            rewrite <- Hpre_def.
            exact Hrpre. }
          claim HrR: r :e R.
          { exact (SepE1 R (fun x0:set => apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U) r Hrpre2). }
          claim Hcond: apply_fun Romega_singleton_map r :e product_cylinder omega Xi i U.
          { exact (SepE2 R (fun x0:set => apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U) r Hrpre2). }
          claim Happmap: apply_fun Romega_singleton_map r = Romega_singleton_seq r.
          { exact (Romega_singleton_map_apply r HrR). }
          claim Hcond2: Romega_singleton_seq r :e product_cylinder omega Xi i U.
          { rewrite <- Happmap.
            exact Hcond. }
          claim Hcyl_def: product_cylinder omega Xi i U =
            {g :e product_space omega Xi | i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U}.
          { reflexivity. }
          claim Hcond3: Romega_singleton_seq r :e
            {g :e product_space omega Xi | i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U}.
          { rewrite <- Hcyl_def.
            exact Hcond2. }
          claim Hprop: i :e omega /\ U :e space_family_topology Xi i /\ apply_fun (Romega_singleton_seq r) i :e U.
          { exact (SepE2 (product_space omega Xi)
                         (fun g:set => i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U)
                         (Romega_singleton_seq r)
                         Hcond3). }
          claim Hri: apply_fun (Romega_singleton_seq r) i :e U.
          { exact (andER (i :e omega /\ U :e space_family_topology Xi i)
                         (apply_fun (Romega_singleton_seq r) i :e U)
                         Hprop). }
          claim Happi: apply_fun (Romega_singleton_seq r) i = If_i (0 :e i) 0 r.
          { exact (Romega_singleton_seq_apply r i HrR Hi). }
          claim HriIf: If_i (0 :e i) 0 r :e U.
          { rewrite <- Happi.
            exact Hri. }
          claim Hif1: If_i (0 :e i) 0 r = 0.
          { exact (If_i_1 (0 :e i) 0 r H0i). }
          claim H0U: 0 :e U.
          { rewrite <- Hif1.
            exact HriIf. }
          exact (Hn0U H0U).
        - let r. assume HrE: r :e Empty.
          prove r :e preimage_of R Romega_singleton_map (product_cylinder omega Xi i U).
          apply FalseE.
          exact (EmptyE r HrE). }
      rewrite Heq.
      exact (topology_has_empty R R_standard_topology R_standard_topology_is_topology).
  + assume Hn0i: ~(0 :e i).
    claim Heq: preimage_of R Romega_singleton_map (product_cylinder omega Xi i U) = U.
    { apply set_ext.
      - let r. assume Hrpre: r :e preimage_of R Romega_singleton_map (product_cylinder omega Xi i U).
        prove r :e U.
        claim Hrpre2: r :e {x0 :e R | apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U}.
        { claim Hpre_def: preimage_of R Romega_singleton_map (product_cylinder omega Xi i U) =
            {x0 :e R | apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U}.
          { reflexivity. }
          rewrite <- Hpre_def.
          exact Hrpre. }
        claim HrR: r :e R.
        { exact (SepE1 R (fun x0:set => apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U) r Hrpre2). }
        claim Hcond: apply_fun Romega_singleton_map r :e product_cylinder omega Xi i U.
        { exact (SepE2 R (fun x0:set => apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U) r Hrpre2). }
        claim Happmap: apply_fun Romega_singleton_map r = Romega_singleton_seq r.
        { exact (Romega_singleton_map_apply r HrR). }
        claim Hcond2: Romega_singleton_seq r :e product_cylinder omega Xi i U.
        { rewrite <- Happmap.
          exact Hcond. }
        claim Hcyl_def: product_cylinder omega Xi i U =
          {g :e product_space omega Xi | i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U}.
        { reflexivity. }
        claim Hcond3: Romega_singleton_seq r :e
          {g :e product_space omega Xi | i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U}.
        { rewrite <- Hcyl_def.
          exact Hcond2. }
        claim Hprop: i :e omega /\ U :e space_family_topology Xi i /\ apply_fun (Romega_singleton_seq r) i :e U.
        { exact (SepE2 (product_space omega Xi)
                       (fun g:set => i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U)
                       (Romega_singleton_seq r)
                       Hcond3). }
        claim Hri: apply_fun (Romega_singleton_seq r) i :e U.
        { exact (andER (i :e omega /\ U :e space_family_topology Xi i)
                       (apply_fun (Romega_singleton_seq r) i :e U)
                       Hprop). }
        claim Happi: apply_fun (Romega_singleton_seq r) i = If_i (0 :e i) 0 r.
        { exact (Romega_singleton_seq_apply r i HrR Hi). }
        claim HriIf: If_i (0 :e i) 0 r :e U.
        { rewrite <- Happi.
          exact Hri. }
        claim Hif0: If_i (0 :e i) 0 r = r.
        { exact (If_i_0 (0 :e i) 0 r Hn0i). }
        rewrite <- Hif0.
        exact HriIf.
      - let r. assume HrU: r :e U.
        prove r :e preimage_of R Romega_singleton_map (product_cylinder omega Xi i U).
        claim HrR: r :e R.
        { exact (HUsubR r HrU). }
        claim Hpre_def: preimage_of R Romega_singleton_map (product_cylinder omega Xi i U) =
          {x0 :e R | apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U}.
        { reflexivity. }
        rewrite Hpre_def.
        apply (SepI R (fun x0:set => apply_fun Romega_singleton_map x0 :e product_cylinder omega Xi i U) r HrR).
        prove apply_fun Romega_singleton_map r :e product_cylinder omega Xi i U.
        claim Happmap: apply_fun Romega_singleton_map r = Romega_singleton_seq r.
        { exact (Romega_singleton_map_apply r HrR). }
        rewrite Happmap.
        claim HXdef: R_omega_space = product_space omega Xi.
        { reflexivity. }
        claim Hrseq: Romega_singleton_seq r :e product_space omega Xi.
        { rewrite <- HXdef.
          exact (Romega_singleton_seq_in_Romega_space r HrR). }
        claim Hcyl_def: product_cylinder omega Xi i U =
          {g :e product_space omega Xi | i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U}.
        { reflexivity. }
        rewrite Hcyl_def.
        apply (SepI (product_space omega Xi)
                    (fun g:set => i :e omega /\ U :e space_family_topology Xi i /\ apply_fun g i :e U)
                    (Romega_singleton_seq r)
                    Hrseq).
        apply andI.
        + apply andI.
          * exact Hi.
          * exact HUtop.
        + claim Happi: apply_fun (Romega_singleton_seq r) i = If_i (0 :e i) 0 r.
          { exact (Romega_singleton_seq_apply r i HrR Hi). }
          rewrite Happi.
          rewrite (If_i_0 (0 :e i) 0 r Hn0i).
          exact HrU. }
    rewrite Heq.
    exact HUstd. }
claim HdefTy: R_omega_product_topology = generated_topology_from_subbasis R_omega_space S.
{ reflexivity. }
rewrite HdefTy.
exact (continuous_map_from_subbasis R R_standard_topology R_omega_space S Romega_singleton_map
        HtopR Hfun HS Hpre).
Qed.

(** Helper: image of the singleton map lies in Romega_tilde 0 **)
Theorem image_of_Romega_singleton_map_sub_Romega_tilde0 :
  image_of Romega_singleton_map R c= Romega_tilde 0.
let f. assume Hf: f :e image_of Romega_singleton_map R.
prove f :e Romega_tilde 0.
apply (ReplE_impred R (fun r0:set => apply_fun Romega_singleton_map r0) f Hf (f :e Romega_tilde 0)).
let r. assume Hr: r :e R. assume Hfeq: f = apply_fun Romega_singleton_map r.
rewrite Hfeq.
rewrite (Romega_singleton_map_apply r Hr).
exact (Romega_singleton_seq_in_Romega_tilde0 r Hr).
Qed.

(** Helper: extend an element of Romega_tilde k with one more real coordinate at ordsucc k **)
Definition Romega_extend_seq : set -> set -> set := fun k p =>
  graph omega (fun i:set =>
    If_i (ordsucc k :e i) 0
      (If_i (i = ordsucc k) (p 1) (apply_fun (p 0) i))).

(** Helper: extension lands in Romega_tilde (ordsucc k) **)
Theorem Romega_extend_seq_in_Romega_tilde_succ : forall k p:set,
  k :e omega ->
  p :e setprod (Romega_tilde k) R ->
  Romega_extend_seq k p :e Romega_tilde (ordsucc k).
let k p.
assume HkO: k :e omega.
assume Hp: p :e setprod (Romega_tilde k) R.
prove Romega_extend_seq k p :e Romega_tilde (ordsucc k).
set h := (fun i:set =>
    If_i (ordsucc k :e i) 0
      (If_i (i = ordsucc k) (p 1) (apply_fun (p 0) i))).
claim Hdef: Romega_extend_seq k p = graph omega h.
{ reflexivity. }
rewrite Hdef.
claim HdefT: Romega_tilde (ordsucc k) =
  {f :e R_omega_space | forall i:set, i :e omega -> ordsucc k :e i -> apply_fun f i = 0}.
{ reflexivity. }
rewrite HdefT.
apply (SepI R_omega_space (fun f0:set => forall i:set, i :e omega -> ordsucc k :e i -> apply_fun f0 i = 0)).
- (** graph omega h is in the ambient product space **)
  apply (graph_omega_in_Romega_space h).
  let i. assume Hi: i :e omega.
  prove h i :e R.
  claim Hhi: h i = If_i (ordsucc k :e i) 0 (If_i (i = ordsucc k) (p 1) (apply_fun (p 0) i)).
  { reflexivity. }
  rewrite Hhi.
  apply (xm (ordsucc k :e i)).
  + assume Hki: ordsucc k :e i.
    rewrite (If_i_1 (ordsucc k :e i) 0 (If_i (i = ordsucc k) (p 1) (apply_fun (p 0) i)) Hki).
    exact real_0.
  + assume Hnki: ~(ordsucc k :e i).
    rewrite (If_i_0 (ordsucc k :e i) 0 (If_i (i = ordsucc k) (p 1) (apply_fun (p 0) i)) Hnki).
    apply (xm (i = ordsucc k)).
    * assume Hieq.
      rewrite (If_i_1 (i = ordsucc k) (p 1) (apply_fun (p 0) i) Hieq).
      (** second coordinate of p lies in R **)
      claim Hp1: p 1 :e R.
      { claim Hp1raw: p 1 :e (fun _ : set => R) (p 0).
        { exact (ap1_Sigma (Romega_tilde k) (fun _ : set => R) p Hp). }
        exact Hp1raw. }
      exact Hp1.
    * assume Hineq.
      rewrite (If_i_0 (i = ordsucc k) (p 1) (apply_fun (p 0) i) Hineq).
      (** first coordinate of p lies in Romega_tilde k, hence in R_omega_space **)
      claim Hp0: p 0 :e Romega_tilde k.
      { exact (ap0_Sigma (Romega_tilde k) (fun _ : set => R) p Hp). }
      claim Hp0X: p 0 :e R_omega_space.
      { exact (Romega_tilde_sub_Romega k (p 0) Hp0). }
      exact (Romega_coord_in_R (p 0) i Hp0X Hi).
- (** verify the defining property of Romega_tilde (ordsucc k) **)
  let i. assume Hi: i :e omega.
  assume Hki: ordsucc k :e i.
  prove apply_fun (graph omega h) i = 0.
  claim Happ: apply_fun (graph omega h) i = h i.
  { exact (apply_fun_graph omega h i Hi). }
  rewrite Happ.
  claim Hhi: h i = If_i (ordsucc k :e i) 0 (If_i (i = ordsucc k) (p 1) (apply_fun (p 0) i)).
  { reflexivity. }
  rewrite Hhi.
  rewrite (If_i_1 (ordsucc k :e i) 0 (If_i (i = ordsucc k) (p 1) (apply_fun (p 0) i)) Hki).
  reflexivity.
Qed.

(** Helper: map extending Romega_tilde k by one coordinate **)
Definition Romega_extend_map : set -> set := fun k =>
  graph (setprod (Romega_tilde k) R) (fun p:set => Romega_extend_seq k p).

(** Helper: apply_fun for Romega_extend_map **)
Theorem Romega_extend_map_apply : forall k p:set,
  k :e omega ->
  p :e setprod (Romega_tilde k) R ->
  apply_fun (Romega_extend_map k) p = Romega_extend_seq k p.
let k p.
assume HkO: k :e omega.
assume Hp: p :e setprod (Romega_tilde k) R.
prove apply_fun (Romega_extend_map k) p = Romega_extend_seq k p.
claim Hdef: Romega_extend_map k = graph (setprod (Romega_tilde k) R) (fun q:set => Romega_extend_seq k q).
{ reflexivity. }
rewrite Hdef.
exact (apply_fun_graph (setprod (Romega_tilde k) R) (fun q:set => Romega_extend_seq k q) p Hp).
Qed.

(** Helper: extension map is a function into the ambient product space **)
Theorem Romega_extend_map_function_on : forall k:set,
  k :e omega ->
  function_on (Romega_extend_map k) (setprod (Romega_tilde k) R) R_omega_space.
let k. assume HkO: k :e omega.
prove function_on (Romega_extend_map k) (setprod (Romega_tilde k) R) R_omega_space.
let p. assume Hp: p :e setprod (Romega_tilde k) R.
prove apply_fun (Romega_extend_map k) p :e R_omega_space.
rewrite (Romega_extend_map_apply k p HkO Hp).
claim Htilde: Romega_extend_seq k p :e Romega_tilde (ordsucc k).
{ exact (Romega_extend_seq_in_Romega_tilde_succ k p HkO Hp). }
exact (Romega_tilde_sub_Romega (ordsucc k) (Romega_extend_seq k p) Htilde).
Qed.

(** Helper: image of the extension map lies in Romega_tilde (ordsucc k) **)
Theorem image_of_Romega_extend_map_sub_Romega_tilde_succ : forall k:set,
  k :e omega ->
  image_of (Romega_extend_map k) (setprod (Romega_tilde k) R) c= Romega_tilde (ordsucc k).
let k. assume HkO: k :e omega.
let f. assume Hf: f :e image_of (Romega_extend_map k) (setprod (Romega_tilde k) R).
prove f :e Romega_tilde (ordsucc k).
apply (ReplE_impred (setprod (Romega_tilde k) R) (fun p0:set => apply_fun (Romega_extend_map k) p0) f Hf
       (f :e Romega_tilde (ordsucc k))).
let p. assume Hp: p :e setprod (Romega_tilde k) R.
assume Hfeq: f = apply_fun (Romega_extend_map k) p.
rewrite Hfeq.
rewrite (Romega_extend_map_apply k p HkO Hp).
exact (Romega_extend_seq_in_Romega_tilde_succ k p HkO Hp).
Qed.

(** Helper: every finite subset of omega is bounded by some n in omega **)
Theorem finite_subset_of_omega_bounded : forall F:set,
  F c= omega -> finite F -> exists n :e omega, forall m :e F, m :e n.
let F.
assume HFsub: F c= omega.
assume HFfin: finite F.
prove exists n :e omega, forall m :e F, m :e n.
claim Hp0: (Empty c= omega -> exists n :e omega, forall m :e Empty, m :e n).
{ assume Hsub0: Empty c= omega.
  prove exists n :e omega, forall m :e Empty, m :e n.
  witness 0.
  apply andI.
  - exact (nat_p_omega 0 nat_0).
  - let m. assume Hm: m :e Empty.
    apply FalseE.
    exact (EmptyE m Hm). }
claim Hpstep: forall A y, finite A -> y /:e A ->
  (A c= omega -> exists n :e omega, forall m :e A, m :e n) ->
  (A :\/: {y} c= omega -> exists n0 :e omega, forall m:set, m :e A :\/: {y} -> m :e n0).
{ let A y.
  assume HAfin: finite A.
  assume HyA: y /:e A.
  assume HpA: (A c= omega -> exists n :e omega, forall m :e A, m :e n).
  assume HsubAy: A :\/: {y} c= omega.
  claim HsubA: A c= omega.
  { exact (Subq_tra A (A :\/: {y}) omega (binunion_Subq_1 A {y}) HsubAy). }
  claim Hexn: exists n :e omega, forall m :e A, m :e n.
  { exact (HpA HsubA). }
  apply Hexn.
  let n.
  assume Hnand.
  claim Hn: n :e omega.
  { exact (andEL (n :e omega) (forall m :e A, m :e n) Hnand). }
  claim Hnprop: forall m :e A, m :e n.
  { exact (andER (n :e omega) (forall m :e A, m :e n) Hnand). }
  prove exists n0 :e omega, forall m:set, m :e A :\/: {y} -> m :e n0.
  claim Hy_in_union: y :e A :\/: {y}.
  { apply binunionI2. exact (SingI y). }
  claim Hy_omega: y :e omega.
  { exact (HsubAy y Hy_in_union). }
  claim Hysucc_omega: ordsucc y :e omega.
  { exact (omega_ordsucc y Hy_omega). }
  claim Hn_union_omega: n :\/: ordsucc y :e omega.
  { exact (omega_binunion n (ordsucc y) Hn Hysucc_omega). }
  set n0 := ordsucc (n :\/: ordsucc y).
  claim Hn0_omega: n0 :e omega.
  { exact (omega_ordsucc (n :\/: ordsucc y) Hn_union_omega). }
  witness n0.
  apply andI.
  - exact Hn0_omega.
  - let m. assume Hm: m :e A :\/: {y}.
    prove m :e n0.
    apply (binunionE A {y} m Hm).
    + assume HmA: m :e A.
      claim Hmn: m :e n.
      { exact (Hnprop m HmA). }
      claim HmnU: m :e n :\/: ordsucc y.
      { exact (binunionI1 n (ordsucc y) m Hmn). }
      exact (ordsuccI1 (n :\/: ordsucc y) m HmnU).
    + assume HmY: m :e {y}.
      claim Hmy: m = y.
      { exact (SingE y m HmY). }
      rewrite Hmy.
      claim Hy_in_succ: y :e ordsucc y.
      { exact (ordsuccI2 y). }
      claim Hy_in_U: y :e n :\/: ordsucc y.
      { exact (binunionI2 n (ordsucc y) y Hy_in_succ). }
      exact (ordsuccI1 (n :\/: ordsucc y) y Hy_in_U). }
claim HpF: (F c= omega -> exists n :e omega, forall m :e F, m :e n).
{ exact (finite_ind (fun A => A c= omega -> exists n :e omega, forall m :e A, m :e n)
                    Hp0 Hpstep F HFfin). }
exact (HpF HFsub).
Qed.

(** Helper: basis neighborhoods in the product topology meet Romega_infty **)
(** LATEX VERSION: Any basic open neighborhood in the product topology contains a point of R^infty by truncating outside finitely many constrained coordinates. **)
Theorem Romega_infty_meets_product_basis : forall b x:set,
  b :e basis_of_subbasis R_omega_space (product_subbasis_full omega (const_space_family omega R R_standard_topology)) ->
  x :e b ->
  b :/\: Romega_infty <> Empty.
let b x.
assume Hb: b :e basis_of_subbasis R_omega_space (product_subbasis_full omega (const_space_family omega R R_standard_topology)).
assume Hxb: x :e b.
prove b :/\: Romega_infty <> Empty.
set X := R_omega_space.
set Xi := const_space_family omega R R_standard_topology.
set S := product_subbasis_full omega Xi.
set B := basis_of_subbasis X S.
claim HbB: b :e B.
{ exact Hb. }
(** Unpack basis_of_subbasis membership. **)
claim Hbfin: b :e finite_intersections_of X S.
{ exact (SepE1 (finite_intersections_of X S) (fun b0:set => b0 <> Empty) b HbB). }
claim Hbne: b <> Empty.
{ exact (SepE2 (finite_intersections_of X S) (fun b0:set => b0 <> Empty) b HbB). }
(** Choose finite subcollection F of S with b = intersection_of_family X F. **)
apply (ReplE_impred (finite_subcollections S) (fun F0:set => intersection_of_family X F0) b Hbfin (b :/\: Romega_infty <> Empty)).
let F.
assume HF: F :e finite_subcollections S.
assume Hbeq: b = intersection_of_family X F.
rewrite Hbeq at 1.
(** Extract basic properties of F. **)
claim HFpow: F :e Power S.
{ exact (SepE1 (Power S) (fun F0:set => finite F0) F HF). }
claim HFsubS: F c= S.
{ exact (PowerE S F HFpow). }
claim HFfin: finite F.
{ exact (SepE2 (Power S) (fun F0:set => finite F0) F HF). }
(** x lies in the intersection, hence in X and in every s in F. **)
claim HxInt: x :e intersection_of_family X F.
{ rewrite <- Hbeq.
  exact Hxb. }
claim HxX: x :e X.
{ exact (SepE1 X (fun x0:set => forall U:set, U :e F -> x0 :e U) x HxInt). }
claim HxAll: forall s:set, s :e F -> x :e s.
{ exact (SepE2 X (fun x0:set => forall U:set, U :e F -> x0 :e U) x HxInt). }

(** Pick for each s :e F a coordinate index in omega witnessing s :e S. **)
set CylFam := fun i:set => {product_cylinder omega Xi i U|U :e space_family_topology Xi i}.
set pick_i := fun s:set => Eps_i (fun i:set => i :e omega /\ s :e CylFam i).

claim Hpick_omega: forall s:set, s :e F -> pick_i s :e omega.
{ let s. assume HsF: s :e F.
  prove pick_i s :e omega.
  claim HsS: s :e S.
  { exact (HFsubS s HsF). }
  claim Hex: exists i:set, i :e omega /\ s :e CylFam i.
  { exact (famunionE omega (fun i:set => CylFam i) s HsS). }
  claim Hpick: pick_i s :e omega /\ s :e CylFam (pick_i s).
  { exact (Eps_i_ex (fun i:set => i :e omega /\ s :e CylFam i) Hex). }
  exact (andEL (pick_i s :e omega) (s :e CylFam (pick_i s)) Hpick). }

claim Hpick_in: forall s:set, s :e F -> s :e CylFam (pick_i s).
{ let s. assume HsF: s :e F.
  prove s :e CylFam (pick_i s).
  claim HsS: s :e S.
  { exact (HFsubS s HsF). }
  claim Hex: exists i:set, i :e omega /\ s :e CylFam i.
  { exact (famunionE omega (fun i:set => CylFam i) s HsS). }
  claim Hpick: pick_i s :e omega /\ s :e CylFam (pick_i s).
  { exact (Eps_i_ex (fun i:set => i :e omega /\ s :e CylFam i) Hex). }
  exact (andER (pick_i s :e omega) (s :e CylFam (pick_i s)) Hpick). }

(** The set of picked indices is finite and contained in omega. **)
set J := {pick_i s|s :e F}.
claim HJfin: finite J.
{ exact (Repl_finite (fun s:set => pick_i s) F HFfin). }
claim HJsub: J c= omega.
{ let j. assume Hj: j :e J.
  prove j :e omega.
  apply (ReplE_impred F (fun s:set => pick_i s) j Hj (j :e omega)).
  let s. assume HsF: s :e F.
  assume Hjeq: j = pick_i s.
  rewrite Hjeq.
  exact (Hpick_omega s HsF). }

(** Choose n bounding all picked indices. **)
claim Hexn: exists n :e omega, forall m :e J, m :e n.
{ exact (finite_subset_of_omega_bounded J HJsub HJfin). }
apply Hexn.
let n.
assume Hnand.
claim HnO: n :e omega.
{ exact (andEL (n :e omega) (forall m :e J, m :e n) Hnand). }
claim Hnprop: forall m :e J, m :e n.
{ exact (andER (n :e omega) (forall m :e J, m :e n) Hnand). }

(** Define a truncation of x: keep x on indices in n, and 0 beyond n. **)
set h := fun i:set => If_i (n :e i) 0 (apply_fun x i).
set f := graph omega h.

claim HhR: forall i:set, i :e omega -> h i :e R.
{ let i. assume Hi: i :e omega.
  prove h i :e R.
  claim Hhdef: h i = If_i (n :e i) 0 (apply_fun x i).
  { reflexivity. }
  apply (xm (n :e i)).
  - assume Hni: n :e i.
    rewrite Hhdef.
    rewrite (If_i_1 (n :e i) 0 (apply_fun x i) Hni).
    exact real_0.
  - assume Hnni: ~(n :e i).
    rewrite Hhdef.
    rewrite (If_i_0 (n :e i) 0 (apply_fun x i) Hnni).
    exact (Romega_coord_in_R x i HxX Hi). }

claim HfX: f :e X.
{ exact (graph_omega_in_Romega_space h HhR). }

(** f is eventually zero from index n onward, hence lies in Romega_infty. **)
claim Hftilde: f :e Romega_tilde n.
{ prove f :e Romega_tilde n.
  prove f :e {f0 :e X | forall i:set, i :e omega -> n :e i -> apply_fun f0 i = 0}.
  apply (SepI X (fun f0:set => forall i:set, i :e omega -> n :e i -> apply_fun f0 i = 0) f HfX).
  let i. assume Hi: i :e omega. assume Hni: n :e i.
  prove apply_fun f i = 0.
  claim Happ: apply_fun f i = h i.
  { exact (apply_fun_graph omega h i Hi). }
  rewrite Happ.
  claim Hhdef: h i = If_i (n :e i) 0 (apply_fun x i).
  { reflexivity. }
  rewrite Hhdef.
  rewrite (If_i_1 (n :e i) 0 (apply_fun x i) Hni).
  reflexivity. }
claim HfA: f :e Romega_infty.
{ prove f :e Romega_infty.
  set Y := Romega_tilde n.
  claim HYn: Y :e {Romega_tilde k|k :e omega}.
  { exact (ReplI omega (fun k:set => Romega_tilde k) n HnO). }
  exact (UnionI {Romega_tilde k|k :e omega} f Y Hftilde HYn). }

(** Show f lies in the intersection_of_family X F, hence in b. **)
claim HfInt: f :e intersection_of_family X F.
{ prove f :e intersection_of_family X F.
  prove f :e {x0 :e X|forall U:set, U :e F -> x0 :e U}.
  apply (SepI X (fun x0:set => forall U:set, U :e F -> x0 :e U) f HfX).
  let s. assume HsF: s :e F.
  prove f :e s.
  (** Expand s as a product_cylinder at coordinate pick_i s. **)
  claim HsCyl: s :e CylFam (pick_i s).
  { exact (Hpick_in s HsF). }
  apply (ReplE_impred (space_family_topology Xi (pick_i s))
          (fun U:set => product_cylinder omega Xi (pick_i s) U)
          s
          HsCyl
          (f :e s)).
  let U.
  assume HU: U :e space_family_topology Xi (pick_i s).
  assume Hseq: s = product_cylinder omega Xi (pick_i s) U.
  rewrite Hseq.
  (** Extract that x satisfies this cylinder, hence x(pick_i s) :e U. **)
  claim Hxs: x :e s.
  { exact (HxAll s HsF). }
  claim HxCyl: x :e product_cylinder omega Xi (pick_i s) U.
  { rewrite <- Hseq.
    exact Hxs. }
  claim Hxcylprop: (pick_i s :e omega /\ U :e space_family_topology Xi (pick_i s)) /\ apply_fun x (pick_i s) :e U.
  { exact (SepE2 (product_space omega Xi)
                 (fun f0:set => (pick_i s :e omega /\ U :e space_family_topology Xi (pick_i s)) /\ apply_fun f0 (pick_i s) :e U)
                 x
                 HxCyl). }
  claim HxUi: apply_fun x (pick_i s) :e U.
  { exact (andER (pick_i s :e omega /\ U :e space_family_topology Xi (pick_i s))
                 (apply_fun x (pick_i s) :e U)
                 Hxcylprop). }
  (** Show apply_fun f (pick_i s) equals apply_fun x (pick_i s). **)
  claim Hidx: pick_i s :e omega.
  { exact (Hpick_omega s HsF). }
  claim HidxJ: pick_i s :e J.
  { exact (ReplI F (fun s0:set => pick_i s0) s HsF). }
  claim Hidxn: pick_i s :e n.
  { exact (Hnprop (pick_i s) HidxJ). }
  claim Hnot_nin: ~(n :e pick_i s).
  { assume Hnin: n :e pick_i s.
    exact (In_no2cycle (pick_i s) n Hidxn Hnin). }
  (** Conclude f is in the cylinder by the defining Sep predicate. **)
  prove f :e product_cylinder omega Xi (pick_i s) U.
  prove f :e {f0 :e product_space omega Xi | pick_i s :e omega /\ U :e space_family_topology Xi (pick_i s) /\ apply_fun f0 (pick_i s) :e U}.
  claim HfProd: f :e product_space omega Xi.
  { exact HfX. }
  claim Hpropf: pick_i s :e omega /\ U :e space_family_topology Xi (pick_i s) /\ apply_fun f (pick_i s) :e U.
  { apply andI.
    - apply andI.
      + exact Hidx.
      + exact HU.
    - prove apply_fun f (pick_i s) :e U.
      claim Happf: apply_fun f (pick_i s) = h (pick_i s).
      { exact (apply_fun_graph omega h (pick_i s) Hidx). }
      rewrite Happf.
      claim Hhdef: h (pick_i s) = If_i (n :e pick_i s) 0 (apply_fun x (pick_i s)).
      { reflexivity. }
      rewrite Hhdef.
      claim Hif: If_i (n :e pick_i s) 0 (apply_fun x (pick_i s)) = apply_fun x (pick_i s).
      { exact (If_i_0 (n :e pick_i s) 0 (apply_fun x (pick_i s)) Hnot_nin). }
      rewrite Hif.
      exact HxUi. }
  exact (SepI (product_space omega Xi)
        (fun f0:set => pick_i s :e omega /\ U :e space_family_topology Xi (pick_i s) /\ apply_fun f0 (pick_i s) :e U)
        f
        HfProd
        Hpropf). }

(** Conclude the intersection b meets Romega_infty by exhibiting f. **)
assume Hempty: (intersection_of_family X F) :/\: Romega_infty = Empty.
prove False.
claim HfB: f :e intersection_of_family X F.
{ exact HfInt. }
claim HfBA: f :e (intersection_of_family X F) :/\: Romega_infty.
{ exact (binintersectI (intersection_of_family X F) Romega_infty f HfB HfA). }
claim HfE: f :e Empty.
{ claim HsubE: (intersection_of_family X F) :/\: Romega_infty c= Empty.
  { rewrite Hempty.
    exact (Subq_ref Empty). }
  exact (HsubE f HfBA). }
exact (EmptyE f HfE).
Qed.

(** from 23 Example 7: Romega_infty is dense in the product topology **) 
(** LATEX VERSION: Every basic open set in the product topology meets R^infty by modifying only finitely many coordinates. **)
Theorem Romega_infty_dense :
  closure_of R_omega_space R_omega_product_topology Romega_infty = R_omega_space.
prove closure_of R_omega_space R_omega_product_topology Romega_infty = R_omega_space.
apply set_ext.
- exact (closure_in_space R_omega_space R_omega_product_topology Romega_infty Romega_product_topology_is_topology).
- let x. assume Hx: x :e R_omega_space.
  prove x :e closure_of R_omega_space R_omega_product_topology Romega_infty.
  (** Use the defining Sep condition for closure_of. **)
  claim Hcond: forall U:set, U :e R_omega_product_topology -> x :e U -> U :/\: Romega_infty <> Empty.
  { let U. assume HU: U :e R_omega_product_topology.
    assume HxU: x :e U.
    prove U :/\: Romega_infty <> Empty.
    (** Reduce to a basis element b inside U containing x. **)
    set S := product_subbasis_full omega (const_space_family omega R R_standard_topology).
    set B := basis_of_subbasis R_omega_space S.
    claim HUpow: U :e Power R_omega_space.
    { exact (SepE1 (Power R_omega_space)
                  (fun U0:set => forall y :e U0, exists b0 :e B, y :e b0 /\ b0 c= U0)
                  U
                  HU). }
    claim HUl: forall y :e U, exists b0 :e B, y :e b0 /\ b0 c= U.
    { exact (SepE2 (Power R_omega_space)
                  (fun U0:set => forall y :e U0, exists b0 :e B, y :e b0 /\ b0 c= U0)
                  U
                  HU). }
    apply (HUl x HxU).
    let b0. assume Hb0pair.
    claim Hb0B: b0 :e B.
    { exact (andEL (b0 :e B) (x :e b0 /\ b0 c= U) Hb0pair). }
    claim Hb0xu: x :e b0 /\ b0 c= U.
    { exact (andER (b0 :e B) (x :e b0 /\ b0 c= U) Hb0pair). }
    claim Hxb0: x :e b0.
    { exact (andEL (x :e b0) (b0 c= U) Hb0xu). }
    claim Hb0subU: b0 c= U.
    { exact (andER (x :e b0) (b0 c= U) Hb0xu). }
    claim Hb0neA: b0 :/\: Romega_infty <> Empty.
    { exact (Romega_infty_meets_product_basis b0 x Hb0B Hxb0). }
    (** If b0  A is nonempty and b0  U then U  A is nonempty. **)
    assume HUAempty: U :/\: Romega_infty = Empty.
    claim Hb0A_sub: b0 :/\: Romega_infty c= U :/\: Romega_infty.
    { let y. assume Hy: y :e b0 :/\: Romega_infty.
      claim Hyb0: y :e b0.
      { exact (binintersectE1 b0 Romega_infty y Hy). }
      claim HyA: y :e Romega_infty.
      { exact (binintersectE2 b0 Romega_infty y Hy). }
      claim HyU: y :e U.
      { exact (Hb0subU y Hyb0). }
      exact (binintersectI U Romega_infty y HyU HyA). }
    claim Hb0A_empty: b0 :/\: Romega_infty = Empty.
    { apply Empty_Subq_eq.
      claim HUAE: U :/\: Romega_infty c= Empty.
      { let y. assume Hy: y :e U :/\: Romega_infty.
        prove y :e Empty.
        rewrite <- HUAempty.
        exact Hy. }
      exact (Subq_tra (b0 :/\: Romega_infty) (U :/\: Romega_infty) Empty Hb0A_sub HUAE). }
    exact (Hb0neA Hb0A_empty). }
exact (SepI R_omega_space
            (fun x0 => forall U:set, U :e R_omega_product_topology -> x0 :e U -> U :/\: Romega_infty <> Empty)
            x
            Hx
            Hcond).
Qed.

Theorem R_omega_product_connected :
  connected_space (product_space omega (const_space_family omega R R_standard_topology))
    (product_topology_full omega (const_space_family omega R R_standard_topology)).
prove connected_space (product_space omega (const_space_family omega R R_standard_topology))
    (product_topology_full omega (const_space_family omega R R_standard_topology)).
set Xi := const_space_family omega R R_standard_topology.
set X := product_space omega Xi.
set Tx := product_topology_full omega Xi.
set A := Romega_infty.
claim HTx: topology_on X Tx.
{ exact Romega_product_topology_is_topology. }
claim HAsub: A c= X.
{ exact Romega_infty_sub_Romega. }
claim HAconn: connected_space A (subspace_topology X Tx A).
{ exact Romega_infty_connected. }
claim Hdense: closure_of X Tx A = X.
{ exact Romega_infty_dense. }
exact (connected_space_if_dense_connected_subset X Tx A HTx HAsub HAconn Hdense).
Qed.

(** from 24 Definition: path and path connectedness **) 
Definition path_between : set -> set -> set -> set -> prop := fun X x y p =>
  function_on p unit_interval X /\
  apply_fun p 0 = x /\ apply_fun p 1 = y.
Definition path_connected_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall x y:set, x :e X -> y :e X ->
    exists p:set, path_between X x y p /\ continuous_map unit_interval R_standard_topology X Tx p.

(** Helper axioms for path_connected_implies_connected **)
Axiom unit_interval_connected : connected_space unit_interval R_standard_topology.

Theorem zero_one_in_unit_interval : 0 :e unit_interval /\ 1 :e unit_interval.
claim H0R: 0 :e R.
{ exact real_0. }
claim H1R: 1 :e R.
{ exact real_1. }
claim Hnot_Rlt_1_0: ~(Rlt 1 0).
{ assume HRlt10: Rlt 1 0.
  claim Hlt10: 1 < 0.
  { exact (RltE_lt 1 0 HRlt10). }
  claim Hlt01: 0 < 1.
  { exact (RltE_lt 0 1 Rlt_0_1). }
  claim Hlt11: 1 < 1.
  { exact (SNoLt_tra 1 0 1 SNo_1 SNo_0 SNo_1 Hlt10 Hlt01). }
  exact (SNoLt_irref 1 Hlt11). }
apply andI.
- prove 0 :e unit_interval.
  prove 0 :e {x :e R | ~(Rlt x 0) /\ ~(Rlt 1 x)}.
  exact (SepI R (fun x => ~(Rlt x 0) /\ ~(Rlt 1 x)) 0 H0R
         (andI (~(Rlt 0 0)) (~(Rlt 1 0)) (not_Rlt_refl 0 H0R) Hnot_Rlt_1_0)).
- prove 1 :e unit_interval.
  prove 1 :e {x :e R | ~(Rlt x 0) /\ ~(Rlt 1 x)}.
  exact (SepI R (fun x => ~(Rlt x 0) /\ ~(Rlt 1 x)) 1 H1R
         (andI (~(Rlt 1 0)) (~(Rlt 1 1)) Hnot_Rlt_1_0 (not_Rlt_refl 1 H1R))).
Qed.

(** helper: for any two points in X there exists a path_between witness **)
(** LATEX VERSION: For any x,y in X there is a path (as a function) from x to y. **)
Theorem path_between_exists : forall X x y:set,
  x :e X -> y :e X -> exists p:set, path_between X x y p.
let X x y.
assume HxX: x :e X.
assume HyX: y :e X.
prove exists p:set, path_between X x y p.
set p := {(t, If_i (t = 0) x y)|t :e unit_interval}.
witness p.
prove path_between X x y p.
prove function_on p unit_interval X /\ apply_fun p 0 = x /\ apply_fun p 1 = y.
apply andI.
- (** function_on p unit_interval X /\ apply_fun p 0 = x **)
  apply andI.
  + (** function_on **)
    let t. assume HtI: t :e unit_interval.
    prove apply_fun p t :e X.
    claim Happ: apply_fun p t = If_i (t = 0) x y.
    { prove apply_fun p t = If_i (t = 0) x y.
      prove Eps_i (fun u:set => (t,u) :e p) = If_i (t = 0) x y.
      claim Hpair: (t, If_i (t = 0) x y) :e p.
      { exact (ReplI unit_interval (fun t0:set => (t0, If_i (t0 = 0) x y)) t HtI). }
      claim Heps: (t, Eps_i (fun u:set => (t,u) :e p)) :e p.
      { exact (Eps_i_ax (fun u:set => (t,u) :e p) (If_i (t = 0) x y) Hpair). }
      apply (ReplE_impred unit_interval (fun t0:set => (t0, If_i (t0 = 0) x y))
              (t, Eps_i (fun u:set => (t,u) :e p)) Heps
              (Eps_i (fun u:set => (t,u) :e p) = If_i (t = 0) x y)).
      let t0. assume Ht0: t0 :e unit_interval.
      assume Heq: (t, Eps_i (fun u:set => (t,u) :e p)) = (t0, If_i (t0 = 0) x y).
      claim Ht_eq: t = t0.
      { rewrite <- (tuple_2_0_eq t (Eps_i (fun u:set => (t,u) :e p))).
        rewrite <- (tuple_2_0_eq t0 (If_i (t0 = 0) x y)).
        rewrite Heq.
        reflexivity. }
      claim Hu_eq: Eps_i (fun u:set => (t,u) :e p) = If_i (t0 = 0) x y.
      { rewrite <- (tuple_2_1_eq t (Eps_i (fun u:set => (t,u) :e p))).
        rewrite <- (tuple_2_1_eq t0 (If_i (t0 = 0) x y)).
        rewrite Heq.
        reflexivity. }
      rewrite Hu_eq.
      rewrite <- Ht_eq.
      reflexivity. }
    rewrite Happ.
    apply (xm (t = 0)).
    - assume Ht0: t = 0.
      rewrite (If_i_1 (t = 0) x y Ht0).
      exact HxX.
    - assume Hnt0: ~(t = 0).
      rewrite (If_i_0 (t = 0) x y Hnt0).
      exact HyX.
  + (** apply_fun p 0 = x **)
    claim H01: 0 :e unit_interval /\ 1 :e unit_interval.
    { exact zero_one_in_unit_interval. }
    claim H0I: 0 :e unit_interval.
    { exact (andEL (0 :e unit_interval) (1 :e unit_interval) H01). }
    claim Happ0: apply_fun p 0 = If_i (0 = 0) x y.
    { prove apply_fun p 0 = If_i (0 = 0) x y.
      prove Eps_i (fun u:set => (0,u) :e p) = If_i (0 = 0) x y.
      claim Hpair: (0, If_i (0 = 0) x y) :e p.
      { exact (ReplI unit_interval (fun t0:set => (t0, If_i (t0 = 0) x y)) 0 H0I). }
      claim Heps: (0, Eps_i (fun u:set => (0,u) :e p)) :e p.
      { exact (Eps_i_ax (fun u:set => (0,u) :e p) (If_i (0 = 0) x y) Hpair). }
      apply (ReplE_impred unit_interval (fun t0:set => (t0, If_i (t0 = 0) x y))
              (0, Eps_i (fun u:set => (0,u) :e p)) Heps
              (Eps_i (fun u:set => (0,u) :e p) = If_i (0 = 0) x y)).
      let t0. assume Ht0: t0 :e unit_interval.
      assume Heq: (0, Eps_i (fun u:set => (0,u) :e p)) = (t0, If_i (t0 = 0) x y).
      claim Ht_eq: 0 = t0.
      { rewrite <- (tuple_2_0_eq 0 (Eps_i (fun u:set => (0,u) :e p))).
        rewrite <- (tuple_2_0_eq t0 (If_i (t0 = 0) x y)).
        rewrite Heq.
        reflexivity. }
      claim Hu_eq: Eps_i (fun u:set => (0,u) :e p) = If_i (t0 = 0) x y.
      { rewrite <- (tuple_2_1_eq 0 (Eps_i (fun u:set => (0,u) :e p))).
        rewrite <- (tuple_2_1_eq t0 (If_i (t0 = 0) x y)).
        rewrite Heq.
        reflexivity. }
      rewrite Hu_eq.
      rewrite <- Ht_eq.
      reflexivity. }
    rewrite Happ0.
    claim H00: 0 = 0.
    { reflexivity. }
    rewrite (If_i_1 (0 = 0) x y H00).
    reflexivity.
- (** apply_fun p 1 = y **)
  claim H01: 0 :e unit_interval /\ 1 :e unit_interval.
  { exact zero_one_in_unit_interval. }
  claim H1I: 1 :e unit_interval.
  { exact (andER (0 :e unit_interval) (1 :e unit_interval) H01). }
  claim Happ1: apply_fun p 1 = If_i (1 = 0) x y.
  { prove apply_fun p 1 = If_i (1 = 0) x y.
    prove Eps_i (fun u:set => (1,u) :e p) = If_i (1 = 0) x y.
    claim Hpair: (1, If_i (1 = 0) x y) :e p.
    { exact (ReplI unit_interval (fun t0:set => (t0, If_i (t0 = 0) x y)) 1 H1I). }
    claim Heps: (1, Eps_i (fun u:set => (1,u) :e p)) :e p.
    { exact (Eps_i_ax (fun u:set => (1,u) :e p) (If_i (1 = 0) x y) Hpair). }
    apply (ReplE_impred unit_interval (fun t0:set => (t0, If_i (t0 = 0) x y))
            (1, Eps_i (fun u:set => (1,u) :e p)) Heps
            (Eps_i (fun u:set => (1,u) :e p) = If_i (1 = 0) x y)).
    let t0. assume Ht0: t0 :e unit_interval.
    assume Heq: (1, Eps_i (fun u:set => (1,u) :e p)) = (t0, If_i (t0 = 0) x y).
    claim Ht_eq: 1 = t0.
    { rewrite <- (tuple_2_0_eq 1 (Eps_i (fun u:set => (1,u) :e p))).
      rewrite <- (tuple_2_0_eq t0 (If_i (t0 = 0) x y)).
      rewrite Heq.
      reflexivity. }
    claim Hu_eq: Eps_i (fun u:set => (1,u) :e p) = If_i (t0 = 0) x y.
    { rewrite <- (tuple_2_1_eq 1 (Eps_i (fun u:set => (1,u) :e p))).
      rewrite <- (tuple_2_1_eq t0 (If_i (t0 = 0) x y)).
      rewrite Heq.
      reflexivity. }
    rewrite Hu_eq.
    rewrite <- Ht_eq.
    reflexivity. }
  rewrite Happ1.
  claim Hneq: ~(1 = 0).
  { assume H10: 1 = 0.
    apply neq_0_1.
    rewrite H10.
    reflexivity. }
  rewrite (If_i_0 (1 = 0) x y Hneq).
  reflexivity.
Qed.

Theorem separation_has_elements : forall X U V:set,
  separation_of X U V ->
  (exists x:set, x :e U) /\ (exists y:set, y :e V).
let X U V. assume Hsep.
claim H1: (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty.
{ exact (andEL ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
               (U :\/: V = X) Hsep). }
claim H2: ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty.
{ exact (andEL (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty)
               (V <> Empty) H1). }
claim HUne: U <> Empty.
{ exact (andER (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty)) (U <> Empty) H2). }
claim HVne: V <> Empty.
{ exact (andER ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty)) (V <> Empty) H1). }
apply andI.
- exact (nonempty_has_element U HUne).
- exact (nonempty_has_element V HVne).
Qed.

Theorem separation_subsets : forall X U V:set,
  separation_of X U V ->
  U c= X /\ V c= X.
let X U V. assume Hsep.
claim H1: (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty.
{ exact (andEL ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
               (U :\/: V = X) Hsep). }
claim H2: ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty.
{ exact (andEL (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty)
               (V <> Empty) H1). }
claim H3: (U :e Power X /\ V :e Power X) /\ U :/\: V = Empty.
{ exact (andEL ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty)
               (U <> Empty) H2). }
claim Hleft: U :e Power X /\ V :e Power X.
{ exact (andEL (U :e Power X /\ V :e Power X) (U :/\: V = Empty) H3). }
apply andI.
- exact (PowerE X U (andEL (U :e Power X) (V :e Power X) Hleft)).
- exact (PowerE X V (andER (U :e Power X) (V :e Power X) Hleft)).
Qed.

Theorem subset_elem : forall A B x:set,
  A c= B -> x :e A -> x :e B.
let A B x. assume HAB Hx. exact (HAB x Hx).
Qed.

(** from 24: path connected implies connected **) 
Theorem path_connected_implies_connected : forall X Tx:set,
  path_connected_space X Tx -> connected_space X Tx.
let X Tx.
assume Hpath: path_connected_space X Tx.
prove connected_space X Tx.
(** Extract components from path_connected_space **)
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x y:set, x :e X -> y :e X -> exists p:set, path_between X x y p /\ continuous_map unit_interval R_standard_topology X Tx p)
               Hpath). }
claim Hpath_prop: forall x y:set, x :e X -> y :e X -> exists p:set, path_between X x y p /\ continuous_map unit_interval R_standard_topology X Tx p.
{ exact (andER (topology_on X Tx)
               (forall x y:set, x :e X -> y :e X -> exists p:set, path_between X x y p /\ continuous_map unit_interval R_standard_topology X Tx p)
               Hpath). }
(** Prove X is connected by contradiction **)
prove topology_on X Tx /\ ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).
apply andI.
- exact HTx.
- prove ~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V).
  assume HsepX: exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V.
  (** Extract the separation of X **)
  apply HsepX.
  let U. assume HsepX_V: exists V:set, U :e Tx /\ V :e Tx /\ separation_of X U V.
  apply HsepX_V.
  let V. assume HUV.
  (** Extract components from nested conjunction **)
  claim HU: U :e Tx.
  { exact (andEL (U :e Tx) (V :e Tx)
                 (andEL (U :e Tx /\ V :e Tx) (separation_of X U V) HUV)). }
  claim HV: V :e Tx.
  { exact (andER (U :e Tx) (V :e Tx)
                 (andEL (U :e Tx /\ V :e Tx) (separation_of X U V) HUV)). }
  claim HsepXUV: separation_of X U V.
  { exact (andER (U :e Tx /\ V :e Tx) (separation_of X U V) HUV). }
  (** Get elements from the separation **)
  claim Helems: (exists x:set, x :e U) /\ (exists y:set, y :e V).
  { exact (separation_has_elements X U V HsepXUV). }
  claim HexU: exists x:set, x :e U.
  { exact (andEL (exists x:set, x :e U) (exists y:set, y :e V) Helems). }
  claim HexV: exists y:set, y :e V.
  { exact (andER (exists x:set, x :e U) (exists y:set, y :e V) Helems). }
  (** Pick specific elements **)
  apply HexU.
  let x. assume Hx: x :e U.
  apply HexV.
  let y. assume Hy: y :e V.
  (** Show x, y are in X **)
  claim Hsubsets: U c= X /\ V c= X.
  { exact (separation_subsets X U V HsepXUV). }
  claim HU_sub: U c= X.
  { exact (andEL (U c= X) (V c= X) Hsubsets). }
  claim HV_sub: V c= X.
  { exact (andER (U c= X) (V c= X) Hsubsets). }
  claim HxinX: x :e X.
  { exact (subset_elem U X x HU_sub Hx). }
  claim HyinX: y :e X.
  { exact (subset_elem V X y HV_sub Hy). }
  (** Get continuous path from x to y **)
  claim Hpathxy: exists p:set, path_between X x y p /\ continuous_map unit_interval R_standard_topology X Tx p.
  { exact (Hpath_prop x y HxinX HyinX). }
  apply Hpathxy.
  let p. assume Hp_and_cont.
  (** Extract path_between and continuity **)
  claim Hp: path_between X x y p.
  { exact (andEL (path_between X x y p) (continuous_map unit_interval R_standard_topology X Tx p) Hp_and_cont). }
  claim Hpcont: continuous_map unit_interval R_standard_topology X Tx p.
  { exact (andER (path_between X x y p) (continuous_map unit_interval R_standard_topology X Tx p) Hp_and_cont). }
  (** Extract function and endpoints from Hp (left-associative /\) **)
  claim Hp_pair0: function_on p unit_interval X /\ apply_fun p 0 = x.
  { exact (andEL (function_on p unit_interval X /\ apply_fun p 0 = x) (apply_fun p 1 = y) Hp). }
  claim Hpfunc: function_on p unit_interval X.
  { exact (andEL (function_on p unit_interval X) (apply_fun p 0 = x) Hp_pair0). }
  claim Hp0eq: apply_fun p 0 = x.
  { exact (andER (function_on p unit_interval X) (apply_fun p 0 = x) Hp_pair0). }
  claim Hp1eq: apply_fun p 1 = y.
  { exact (andER (function_on p unit_interval X /\ apply_fun p 0 = x) (apply_fun p 1 = y) Hp). }

  (** Extract disjointness and union from separation_of X U V **)
  claim Hsep_left: ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty).
  { exact (andEL ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                 (U :\/: V = X) HsepXUV). }
  claim Hsep_mid: ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty.
  { exact (andEL (((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty)
                 (V <> Empty) Hsep_left). }
  claim Hsep_pow_disj: (U :e Power X /\ V :e Power X) /\ U :/\: V = Empty.
  { exact (andEL ((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty)
                 (U <> Empty) Hsep_mid). }
  claim HdisjUV: U :/\: V = Empty.
  { exact (andER (U :e Power X /\ V :e Power X) (U :/\: V = Empty) Hsep_pow_disj). }
  claim HunionUV: U :\/: V = X.
  { exact (andER ((((U :e Power X /\ V :e Power X) /\ U :/\: V = Empty) /\ U <> Empty) /\ V <> Empty)
                 (U :\/: V = X) HsepXUV). }

  (** Show preimages form a separation of the unit interval **)
  set preU := preimage_of unit_interval p U.
  set preV := preimage_of unit_interval p V.
  claim Hsep_UV: separation_of unit_interval preU preV.
  { prove preU :e Power unit_interval /\ preV :e Power unit_interval /\ preU :/\: preV = Empty /\ preU <> Empty /\ preV <> Empty /\ preU :\/: preV = unit_interval.
    apply andI.
    - prove ((((preU :e Power unit_interval /\ preV :e Power unit_interval) /\ preU :/\: preV = Empty) /\ preU <> Empty) /\ preV <> Empty).
      apply andI.
      + prove (((preU :e Power unit_interval /\ preV :e Power unit_interval) /\ preU :/\: preV = Empty) /\ preU <> Empty).
        apply andI.
        - prove ((preU :e Power unit_interval /\ preV :e Power unit_interval) /\ preU :/\: preV = Empty).
          apply andI.
          + prove preU :e Power unit_interval /\ preV :e Power unit_interval.
            apply andI.
            - prove preU :e Power unit_interval.
              apply PowerI.
              let t. assume Ht: t :e preU.
              exact (SepE1 unit_interval (fun t0:set => apply_fun p t0 :e U) t Ht).
            - prove preV :e Power unit_interval.
              apply PowerI.
              let t. assume Ht: t :e preV.
              exact (SepE1 unit_interval (fun t0:set => apply_fun p t0 :e V) t Ht).
          + prove preU :/\: preV = Empty.
            apply Empty_eq.
            let t. assume Ht: t :e preU :/\: preV.
            apply (binintersectE preU preV t Ht).
            assume HtU: t :e preU.
            assume HtV: t :e preV.
            claim HpU: apply_fun p t :e U.
            { exact (SepE2 unit_interval (fun t0:set => apply_fun p t0 :e U) t HtU). }
            claim HpV: apply_fun p t :e V.
            { exact (SepE2 unit_interval (fun t0:set => apply_fun p t0 :e V) t HtV). }
            claim HpUV: apply_fun p t :e U :/\: V.
            { exact (binintersectI U V (apply_fun p t) HpU HpV). }
            claim Hfalse: apply_fun p t :e Empty.
            { rewrite <- HdisjUV. exact HpUV. }
            exact (EmptyE (apply_fun p t) Hfalse).
        - (** preU <> Empty **)
          assume Heq: preU = Empty.
          claim H01: 0 :e unit_interval /\ 1 :e unit_interval.
          { exact zero_one_in_unit_interval. }
          claim H0I: 0 :e unit_interval.
          { exact (andEL (0 :e unit_interval) (1 :e unit_interval) H01). }
          claim HxU: apply_fun p 0 :e U.
          { rewrite Hp0eq. exact Hx. }
          claim H0pre: 0 :e preU.
          { exact (SepI unit_interval (fun t0:set => apply_fun p t0 :e U) 0 H0I HxU). }
          claim Hsub: preU c= Empty.
          { rewrite Heq. exact (Subq_ref Empty). }
          claim H0Empty: 0 :e Empty.
          { exact (Hsub 0 H0pre). }
          exact (EmptyE 0 H0Empty).
      + (** preV <> Empty **)
        assume Heq: preV = Empty.
        claim H01: 0 :e unit_interval /\ 1 :e unit_interval.
        { exact zero_one_in_unit_interval. }
        claim H1I: 1 :e unit_interval.
        { exact (andER (0 :e unit_interval) (1 :e unit_interval) H01). }
        claim HyV: apply_fun p 1 :e V.
        { rewrite Hp1eq. exact Hy. }
        claim H1pre: 1 :e preV.
        { exact (SepI unit_interval (fun t0:set => apply_fun p t0 :e V) 1 H1I HyV). }
        claim Hsub: preV c= Empty.
        { rewrite Heq. exact (Subq_ref Empty). }
        claim H1Empty: 1 :e Empty.
        { exact (Hsub 1 H1pre). }
        exact (EmptyE 1 H1Empty).
    - prove preU :\/: preV = unit_interval.
      apply set_ext.
      + let t. assume Ht: t :e preU :\/: preV.
        prove t :e unit_interval.
        apply (binunionE preU preV t Ht).
        - assume HtU: t :e preU.
          exact (SepE1 unit_interval (fun t0:set => apply_fun p t0 :e U) t HtU).
        - assume HtV: t :e preV.
          exact (SepE1 unit_interval (fun t0:set => apply_fun p t0 :e V) t HtV).
      + let t. assume HtI: t :e unit_interval.
        prove t :e preU :\/: preV.
        claim HptX: apply_fun p t :e X.
        { exact (Hpfunc t HtI). }
        claim HptUV: apply_fun p t :e U :\/: V.
        { rewrite HunionUV. exact HptX. }
        apply (binunionE U V (apply_fun p t) HptUV).
        - assume HptU: apply_fun p t :e U.
          apply binunionI1.
          exact (SepI unit_interval (fun t0:set => apply_fun p t0 :e U) t HtI HptU).
        - assume HptV: apply_fun p t :e V.
          apply binunionI2.
          exact (SepI unit_interval (fun t0:set => apply_fun p t0 :e V) t HtI HptV). }
  (** Preimages are open in R_standard_topology **)
  claim HpreimgU: preU :e R_standard_topology.
  { exact (andER (topology_on unit_interval R_standard_topology /\ topology_on X Tx /\ function_on p unit_interval X)
                 (forall V0:set, V0 :e Tx -> preimage_of unit_interval p V0 :e R_standard_topology)
                 Hpcont U HU). }
  claim HpreimgV: preV :e R_standard_topology.
  { exact (andER (topology_on unit_interval R_standard_topology /\ topology_on X Tx /\ function_on p unit_interval X)
                 (forall V0:set, V0 :e Tx -> preimage_of unit_interval p V0 :e R_standard_topology)
                 Hpcont V HV). }
  (** This gives a separation of unit_interval **)
  claim Hsep_exists: exists U0 V0:set, U0 :e R_standard_topology /\ V0 :e R_standard_topology /\ separation_of unit_interval U0 V0.
  { witness preU. witness preV.
    prove preU :e R_standard_topology /\ preV :e R_standard_topology /\ separation_of unit_interval preU preV.
    apply andI.
    - apply andI.
      + exact HpreimgU.
      + exact HpreimgV.
    - exact Hsep_UV. }
  (** Contradiction with connectedness of unit_interval **)
  claim Hunit_nosep: ~(exists U0 V0:set, U0 :e R_standard_topology /\ V0 :e R_standard_topology /\ separation_of unit_interval U0 V0).
  { exact (andER (topology_on unit_interval R_standard_topology)
                 (~(exists U0 V0:set, U0 :e R_standard_topology /\ V0 :e R_standard_topology /\ separation_of unit_interval U0 V0))
                 unit_interval_connected). }
  apply Hunit_nosep.
  exact Hsep_exists.
Qed.

(** from 24 Example: punctured euclidean space is path connected (placeholder) **)
(** FIXED: Origin is the ordered pair (0,0), not Cartesian product 00.
    Was: {setprod 0 0} = {0  0} = {} (singleton containing empty set)
    Now: {(0,0)} (singleton containing origin point)
    Note: In set theory, 0 = , so setprod 0 0 =    = , not the origin! **)
Theorem punctured_space_path_connected :
  path_connected_space (EuclidPlane :\: {(0,0)})
    (subspace_topology EuclidPlane R2_standard_topology (EuclidPlane :\: {(0,0)})).
prove path_connected_space (EuclidPlane :\: {(0,0)}) (subspace_topology EuclidPlane R2_standard_topology (EuclidPlane :\: {(0,0)})).
admit. (** connect any two points via path avoiding origin; use arc around origin if needed **)
Qed.

(** from 24: continuous surjective image of a path connected space is path connected **) 
(** LATEX VERSION: If f:XY is continuous and surjective and X is path connected, then Y is path connected. **)
Theorem continuous_image_path_connected : forall X Tx Y Ty f:set,
  path_connected_space X Tx ->
  continuous_map X Tx Y Ty f ->
  (forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun f x = y) ->
  path_connected_space Y Ty.
let X Tx Y Ty f.
assume Hpath: path_connected_space X Tx.
assume Hf: continuous_map X Tx Y Ty f.
assume Hsurj: forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun f x = y.
prove path_connected_space Y Ty.
(** Extract topology on Y from continuity hypothesis **)
claim Hf_left: (topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y.
{ exact (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
              (forall V:set, V :e Ty -> preimage_of X f V :e Tx) Hf). }
claim HTy: topology_on Y Ty.
{ exact (andER (topology_on X Tx) (topology_on Y Ty)
              (andEL (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y) Hf_left)). }
claim Hpath_prop: forall x y:set, x :e X -> y :e X ->
  exists p:set, path_between X x y p /\ continuous_map unit_interval R_standard_topology X Tx p.
{ exact (andER (topology_on X Tx)
              (forall x y:set, x :e X -> y :e X ->
                exists p:set, path_between X x y p /\ continuous_map unit_interval R_standard_topology X Tx p)
              Hpath). }

prove topology_on Y Ty /\
  forall y1 y2:set, y1 :e Y -> y2 :e Y ->
    exists p:set, path_between Y y1 y2 p /\ continuous_map unit_interval R_standard_topology Y Ty p.
apply andI.
- exact HTy.
- let y1 y2.
  assume Hy1: y1 :e Y.
  assume Hy2: y2 :e Y.
  prove exists p:set, path_between Y y1 y2 p /\ continuous_map unit_interval R_standard_topology Y Ty p.
  (** Choose preimages x1,x2 in X with f(xi)=yi **)
  apply (Hsurj y1 Hy1).
  let x1. assume Hx1pair: x1 :e X /\ apply_fun f x1 = y1.
  apply (Hsurj y2 Hy2).
  let x2. assume Hx2pair: x2 :e X /\ apply_fun f x2 = y2.
  claim Hx1X: x1 :e X.
  { exact (andEL (x1 :e X) (apply_fun f x1 = y1) Hx1pair). }
  claim Hfx1: apply_fun f x1 = y1.
  { exact (andER (x1 :e X) (apply_fun f x1 = y1) Hx1pair). }
  claim Hx2X: x2 :e X.
  { exact (andEL (x2 :e X) (apply_fun f x2 = y2) Hx2pair). }
  claim Hfx2: apply_fun f x2 = y2.
  { exact (andER (x2 :e X) (apply_fun f x2 = y2) Hx2pair). }

  (** Get a path p in X from x1 to x2 **)
  apply (Hpath_prop x1 x2 Hx1X Hx2X).
  let p. assume Hp_pair: path_between X x1 x2 p /\ continuous_map unit_interval R_standard_topology X Tx p.
  claim Hp_between: path_between X x1 x2 p.
  { exact (andEL (path_between X x1 x2 p)
                 (continuous_map unit_interval R_standard_topology X Tx p) Hp_pair). }
  claim Hp_cont: continuous_map unit_interval R_standard_topology X Tx p.
  { exact (andER (path_between X x1 x2 p)
                 (continuous_map unit_interval R_standard_topology X Tx p) Hp_pair). }

  (** Define the composed path q = f  p **)
  set q := compose_fun unit_interval p f.
  claim Hq_cont: continuous_map unit_interval R_standard_topology Y Ty q.
  { exact (composition_continuous unit_interval R_standard_topology X Tx Y Ty p f Hp_cont Hf). }
  claim Hq_left: (topology_on unit_interval R_standard_topology /\ topology_on Y Ty) /\ function_on q unit_interval Y.
  { exact (andEL ((topology_on unit_interval R_standard_topology /\ topology_on Y Ty) /\ function_on q unit_interval Y)
                (forall V:set, V :e Ty -> preimage_of unit_interval q V :e R_standard_topology) Hq_cont). }
  claim Hq_fun: function_on q unit_interval Y.
  { exact (andER (topology_on unit_interval R_standard_topology /\ topology_on Y Ty)
                (function_on q unit_interval Y) Hq_left). }

  (** Endpoints of q **)
  claim H01: 0 :e unit_interval /\ 1 :e unit_interval.
  { exact zero_one_in_unit_interval. }
  claim H0: 0 :e unit_interval.
  { exact (andEL (0 :e unit_interval) (1 :e unit_interval) H01). }
  claim H1: 1 :e unit_interval.
  { exact (andER (0 :e unit_interval) (1 :e unit_interval) H01). }

  claim Hp_left: function_on p unit_interval X /\ apply_fun p 0 = x1.
  { exact (andEL (function_on p unit_interval X /\ apply_fun p 0 = x1)
                 (apply_fun p 1 = x2) Hp_between). }
  claim Hp0: apply_fun p 0 = x1.
  { exact (andER (function_on p unit_interval X) (apply_fun p 0 = x1) Hp_left). }
  claim Hp1: apply_fun p 1 = x2.
  { exact (andER (function_on p unit_interval X /\ apply_fun p 0 = x1)
                 (apply_fun p 1 = x2) Hp_between). }

  claim Hq0: apply_fun q 0 = y1.
  { claim Hq0a: apply_fun q 0 = apply_fun f (apply_fun p 0).
    { exact (compose_fun_apply unit_interval p f 0 H0). }
    rewrite Hq0a.
    rewrite Hp0.
    rewrite Hfx1.
    reflexivity. }
  claim Hq1: apply_fun q 1 = y2.
  { claim Hq1a: apply_fun q 1 = apply_fun f (apply_fun p 1).
    { exact (compose_fun_apply unit_interval p f 1 H1). }
    rewrite Hq1a.
    rewrite Hp1.
    rewrite Hfx2.
    reflexivity. }

  witness q.
  prove path_between Y y1 y2 q /\ continuous_map unit_interval R_standard_topology Y Ty q.
  apply andI.
  - (** path_between **)
    prove function_on q unit_interval Y /\ apply_fun q 0 = y1 /\ apply_fun q 1 = y2.
    apply andI.
    + apply andI.
      * exact Hq_fun.
      * exact Hq0.
    + exact Hq1.
  - exact Hq_cont.
Qed.

(** from 24 Definition: path components equivalence relation **) 
Definition path_component_of : set -> set -> set -> set := fun X Tx x =>
  {y :e X | exists p:set,
     function_on p unit_interval X /\
     continuous_map unit_interval R_standard_topology X Tx p /\
     apply_fun p 0 = x /\ apply_fun p 1 = y}.

(** Helper: path component is reflexive **)
(** LATEX VERSION: Any point is path connectible to itself via the constant path. **)
Theorem path_component_reflexive : forall X Tx x:set,
  topology_on X Tx -> x :e X -> x :e path_component_of X Tx x.
let X Tx x.
assume HTx: topology_on X Tx.
assume HxX: x :e X.
prove x :e path_component_of X Tx x.
prove x :e {y :e X | exists p:set,
     function_on p unit_interval X /\
     continuous_map unit_interval R_standard_topology X Tx p /\
     apply_fun p 0 = x /\ apply_fun p 1 = y}.
apply SepI.
- exact HxX.
- (** constant path p(t)=x **)
  prove exists p:set, function_on p unit_interval X /\
    continuous_map unit_interval R_standard_topology X Tx p /\
    apply_fun p 0 = x /\ apply_fun p 1 = x.
  set p := const_fun unit_interval x.
  witness p.
  prove function_on p unit_interval X /\
    continuous_map unit_interval R_standard_topology X Tx p /\
    apply_fun p 0 = x /\ apply_fun p 1 = x.
  (** Conjunction is left-associative: (((A /\ B) /\ C) /\ D) **)
  apply andI.
  - (** (function_on /\ continuous_map) /\ (apply_fun p 0 = x) **)
    apply andI.
    + (** function_on /\ continuous_map **)
      apply andI.
      * (** function_on **)
        let t. assume HtI: t :e unit_interval.
        prove apply_fun p t :e X.
        claim Hpt: apply_fun p t = x.
        { exact (const_fun_apply unit_interval x t HtI). }
        rewrite Hpt.
        exact HxX.
      * (** continuous_map **)
        claim HtopI: topology_on unit_interval R_standard_topology.
        { exact (andEL (topology_on unit_interval R_standard_topology)
                       (~(exists U V:set, U :e R_standard_topology /\ V :e R_standard_topology /\ separation_of unit_interval U V))
                       unit_interval_connected). }
        exact (const_fun_continuous unit_interval R_standard_topology X Tx x HtopI HTx HxX).
    + (** apply_fun p 0 = x **)
      claim H01: 0 :e unit_interval /\ 1 :e unit_interval.
      { exact zero_one_in_unit_interval. }
      claim H0: 0 :e unit_interval.
      { exact (andEL (0 :e unit_interval) (1 :e unit_interval) H01). }
      exact (const_fun_apply unit_interval x 0 H0).
  - (** apply_fun p 1 = x **)
    claim H01: 0 :e unit_interval /\ 1 :e unit_interval.
    { exact zero_one_in_unit_interval. }
    claim H1: 1 :e unit_interval.
    { exact (andER (0 :e unit_interval) (1 :e unit_interval) H01). }
    exact (const_fun_apply unit_interval x 1 H1).
Qed.

(** from 24: path components form equivalence classes **) 
(** LATEX VERSION: Path components are equivalence classes under path-connectibility. **)
Theorem path_components_equivalence_relation : forall X Tx:set,
  topology_on X Tx ->
  (forall x:set, x :e X -> x :e path_component_of X Tx x) /\
  (forall x y:set, x :e X -> y :e X -> y :e path_component_of X Tx x -> x :e path_component_of X Tx y) /\
  (forall x y z:set, x :e X -> y :e X -> z :e X ->
     y :e path_component_of X Tx x -> z :e path_component_of X Tx y ->
     z :e path_component_of X Tx x).
let X Tx.
assume HTx: topology_on X Tx.
prove (forall x:set, x :e X -> x :e path_component_of X Tx x) /\
  (forall x y:set, x :e X -> y :e X -> y :e path_component_of X Tx x -> x :e path_component_of X Tx y) /\
  (forall x y z:set, x :e X -> y :e X -> z :e X ->
     y :e path_component_of X Tx x -> z :e path_component_of X Tx y ->
     z :e path_component_of X Tx x).
(** Conjunction is left-associative: (P1 /\ P2) /\ P3 **)
  apply andI.
  - (** P1 /\ P2 **)
    apply andI.
    * (** reflexive **)
      let x. assume HxX: x :e X.
      exact (path_component_reflexive X Tx x HTx HxX).
    * (** symmetric: reverse path **)
      admit. (** reverse a continuous path; requires reparametrization/continuity infrastructure **)
  - (** transitive: concatenate paths **)
  admit. (** concatenate two continuous paths; needs piecewise and reparametrization lemmas **)
Qed.

(** from 25 Definition: components and local connectedness **) 
(** LATEX VERSION: Component_of X Tx x is the union of connected subspaces containing x; locally_connected means every neighborhood contains a connected open neighborhood of the point. **)
Definition component_of : set -> set -> set -> set := fun X Tx x =>
  {y :e X | exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y :e C}.
Definition locally_connected : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall x:set, x :e X ->
    forall U:set, U :e Tx -> x :e U ->
      exists V:set, V :e Tx /\ x :e V /\ V c= U /\ connected_space V (subspace_topology X Tx V).

(** from 25 Definition: locally path connected **)
(** LATEX VERSION: Locally path connected means each point has a neighborhood basis of path-connected sets. **)
Definition locally_path_connected : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall x:set, x :e X ->
    forall U:set, U :e Tx -> x :e U ->
      exists V:set, V :e Tx /\ x :e V /\ V c= U /\ path_connected_space V (subspace_topology X Tx V).

(** helper: in a connected space, the component of any point is the whole space **)
(** LATEX VERSION: If X is connected then the component of any point is X. **)
Theorem component_of_whole : forall X Tx x:set,
  connected_space X Tx -> x :e X -> component_of X Tx x = X.
let X Tx x.
assume Hconn: connected_space X Tx.
assume HxX: x :e X.
prove component_of X Tx x = X.
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (~(exists U V:set, U :e Tx /\ V :e Tx /\ separation_of X U V)) Hconn). }
apply set_ext.
- let y. assume Hy: y :e component_of X Tx x.
  prove y :e X.
  exact (SepE1 X (fun y0:set => exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y0 :e C) y Hy).
- let y. assume HyX: y :e X.
  prove y :e component_of X Tx x.
  prove y :e {y0 :e X | exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y0 :e C}.
  apply SepI.
  - exact HyX.
  - claim Hsubeq: subspace_topology X Tx X = Tx.
    { exact (subspace_topology_whole X Tx HTx). }
    claim HconnSub: connected_space X (subspace_topology X Tx X).
    { rewrite Hsubeq.
      exact Hconn. }
    prove exists C:set, connected_space C (subspace_topology X Tx C) /\ x :e C /\ y :e C.
    witness X.
    apply andI.
    - apply andI.
      + exact HconnSub.
      + exact HxX.
    - exact HyX.
Qed.

(** helper: in a path connected space, the path component of any point is the whole space **)
(** LATEX VERSION: If X is path connected then the path component of any point is X. **)
Theorem path_component_of_whole : forall X Tx x:set,
  path_connected_space X Tx -> x :e X -> path_component_of X Tx x = X.
let X Tx x.
assume Hpath: path_connected_space X Tx.
assume HxX: x :e X.
prove path_component_of X Tx x = X.
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x y:set, x :e X -> y :e X ->
                 exists p:set, path_between X x y p /\ continuous_map unit_interval R_standard_topology X Tx p)
               Hpath). }
claim Hpathprop: forall x0 y0:set, x0 :e X -> y0 :e X ->
  exists p:set, path_between X x0 y0 p /\ continuous_map unit_interval R_standard_topology X Tx p.
{ exact (andER (topology_on X Tx)
               (forall x y:set, x :e X -> y :e X ->
                 exists p:set, path_between X x y p /\ continuous_map unit_interval R_standard_topology X Tx p)
               Hpath). }
apply set_ext.
- (** path_component_of subset X **)
  let y. assume Hy: y :e path_component_of X Tx x.
  prove y :e X.
  exact (SepE1 X (fun y0:set => exists p:set,
                    function_on p unit_interval X /\
                    continuous_map unit_interval R_standard_topology X Tx p /\
                    apply_fun p 0 = x /\ apply_fun p 1 = y0) y Hy).
- (** X subset path_component_of **)
  let y. assume HyX: y :e X.
  prove y :e path_component_of X Tx x.
  prove y :e {y0 :e X | exists p:set,
     function_on p unit_interval X /\
     continuous_map unit_interval R_standard_topology X Tx p /\
     apply_fun p 0 = x /\ apply_fun p 1 = y0}.
  apply SepI.
  - exact HyX.
  - claim Hex: exists p:set, path_between X x y p /\ continuous_map unit_interval R_standard_topology X Tx p.
    { exact (Hpathprop x y HxX HyX). }
    apply Hex.
    let p.
    assume Hp: path_between X x y p /\ continuous_map unit_interval R_standard_topology X Tx p.
    claim Hpb: path_between X x y p.
    { exact (andEL (path_between X x y p) (continuous_map unit_interval R_standard_topology X Tx p) Hp). }
    claim Hcont: continuous_map unit_interval R_standard_topology X Tx p.
    { exact (andER (path_between X x y p) (continuous_map unit_interval R_standard_topology X Tx p) Hp). }
    prove exists q:set, function_on q unit_interval X /\
      continuous_map unit_interval R_standard_topology X Tx q /\
      apply_fun q 0 = x /\ apply_fun q 1 = y.
    witness p.
    prove function_on p unit_interval X /\
      continuous_map unit_interval R_standard_topology X Tx p /\
      apply_fun p 0 = x /\ apply_fun p 1 = y.
    claim Hpb1: (function_on p unit_interval X /\ apply_fun p 0 = x) /\ apply_fun p 1 = y.
    { exact Hpb. }
    claim HpbL: function_on p unit_interval X /\ apply_fun p 0 = x.
    { exact (andEL (function_on p unit_interval X /\ apply_fun p 0 = x) (apply_fun p 1 = y) Hpb1). }
    claim Hp1: apply_fun p 1 = y.
    { exact (andER (function_on p unit_interval X /\ apply_fun p 0 = x) (apply_fun p 1 = y) Hpb1). }
    claim Hp0: apply_fun p 0 = x.
    { exact (andER (function_on p unit_interval X) (apply_fun p 0 = x) HpbL). }
    claim Hfun: function_on p unit_interval X.
    { exact (andEL (function_on p unit_interval X) (apply_fun p 0 = x) HpbL). }
    apply andI.
    - apply andI.
      + apply andI.
        * exact Hfun.
        * exact Hcont.
      + exact Hp0.
    - exact Hp1.
Qed.

Definition pairwise_disjoint : set -> prop := fun Fam =>
  forall U V:set, U :e Fam -> V :e Fam -> U <> V -> U :/\: V = Empty.
Definition covers : set -> set -> prop :=
  fun X U => forall x:set, x :e X -> exists u:set, u :e U /\ x :e u.

(** from 25: path components open in locally path connected spaces **) 
(** LATEX VERSION: In a locally path connected space, every path component is open. **)
Theorem path_components_open : forall X Tx:set,
  locally_path_connected X Tx ->
  forall x:set, x :e X ->
    open_in X Tx (path_component_of X Tx x).
let X Tx.
assume Hlpc: locally_path_connected X Tx.
let x.
assume Hx: x :e X.
prove open_in X Tx (path_component_of X Tx x).
admit. (** each point in path component has path connected neighborhood; union of these neighborhoods is path component and is open
        aby: In_5Find locally_path_connectedf conj_myprob_9449_1_20251124_033641 separation_subspace_limit_points prop_ext_2 . **)
Qed.

(** from 25: components equal path components when locally path connected **) 
(** LATEX VERSION: In a locally path connected space, components coincide with path components. **)
Theorem components_equal_path_components : forall X Tx:set,
  locally_path_connected X Tx ->
  forall x:set, x :e X ->
    path_component_of X Tx x = component_of X Tx x.
let X Tx.
assume Hlpc: locally_path_connected X Tx.
let x.
assume Hx: x :e X.
prove path_component_of X Tx x = component_of X Tx x.
admit. (** path component is connected and open; component is maximal connected; local path connectivity ensures equality **)
Qed.

Theorem components_are_closed : forall X Tx:set,
  topology_on X Tx ->
  forall x:set, x :e X -> closed_in X Tx (component_of X Tx x).
let X Tx.
assume HTx: topology_on X Tx.
let x.
assume Hx: x :e X.
prove closed_in X Tx (component_of X Tx x).
admit. (** component is union of all connected sets containing x; closure is connected; component = closure **)
Qed.

(** from 25: components partition the space **) 
(** LATEX VERSION: Components cover X and are pairwise disjoint. **)
Theorem components_partition_space : forall X Tx:set,
  topology_on X Tx ->
  covers X {component_of X Tx x | x :e X} /\
  pairwise_disjoint {component_of X Tx x | x :e X}.
let X Tx.
assume HTx: topology_on X Tx.
prove covers X {component_of X Tx x | x :e X} /\ pairwise_disjoint {component_of X Tx x | x :e X}.
admit. (** every point in its component; distinct components either equal or disjoint by connectedness **)
Qed.

(** from 25: quotient of locally connected space is locally connected **) 
(** LATEX VERSION: Quotients of locally connected spaces remain locally connected. **)
Theorem quotient_preserves_local_connectedness : forall X Tx Y f:set,
  quotient_map X Tx Y f ->
  locally_connected X Tx ->
  locally_connected Y (quotient_topology X Tx Y f).
let X Tx Y f.
assume Hquot: quotient_map X Tx Y f.
assume Hloc: locally_connected X Tx.
prove locally_connected Y (quotient_topology X Tx Y f).
admit. (** open connected nbhd in X maps to open connected nbhd in Y via quotient; use continuity and surjectivity **)
Qed.

(** from 25 Definition: quasicomponent equivalence relation **) 
Definition quasicomponent_of : set -> set -> set -> set := fun X Tx x =>
  {y :e X | forall U:set, open_in X Tx U -> closed_in X Tx U -> x :e U -> y :e U}.

(** from 25: components vs quasicomponents **) 
Theorem components_vs_quasicomponents : forall X Tx:set,
  topology_on X Tx ->
  (forall x:set, component_of X Tx x c= quasicomponent_of X Tx x) /\
  (locally_connected X Tx -> forall x:set, component_of X Tx x = quasicomponent_of X Tx x).
let X Tx.
assume HTx: topology_on X Tx.
prove (forall x:set, component_of X Tx x c= quasicomponent_of X Tx x) /\
  (locally_connected X Tx -> forall x:set, component_of X Tx x = quasicomponent_of X Tx x).
admit. (** component always in quasicomponent; equality when locally connected via open component neighborhoods
        aby: Sep_5FEmpty SepE conj_myprob_9494_1_20251124_090101 separation_subspace_limit_points prop_ext_2 . **)
Qed.

(** from 23 Exercise: components and path components of  **) 
Theorem ex23_Rl_components :
  component_of R R_lower_limit_topology 0 = {0} /\
  (forall x:set, x :e R -> component_of R R_lower_limit_topology x = {x}).
prove component_of R R_lower_limit_topology 0 = {0} /\ (forall x:set, x :e R -> component_of R R_lower_limit_topology x = {x}).
admit. (** lower-limit topology totally disconnected; every point is its own component **)
Qed.

(** from 23 Exercise: components of ^ in product/uniform/box topologies **) 
Theorem ex23_Romega_components :
  component_of (product_space omega (const_space_family omega R R_standard_topology)) (product_topology_full omega (const_space_family omega R R_standard_topology)) (const_family omega 0) =
    product_space omega (const_space_family omega R R_standard_topology) /\
  component_of (product_space omega (const_space_family omega R R_standard_topology)) (box_topology omega (const_space_family omega R R_standard_topology)) (const_family omega 0) =
    {f :e product_space omega (const_space_family omega R R_standard_topology) | exists F:set, finite F /\ forall i:set, i :e omega :\: F -> apply_fun f i = 0}.
prove component_of (product_space omega (const_space_family omega R R_standard_topology)) (product_topology_full omega (const_space_family omega R R_standard_topology)) (const_family omega 0) = product_space omega (const_space_family omega R R_standard_topology) /\ component_of (product_space omega (const_space_family omega R R_standard_topology)) (box_topology omega (const_space_family omega R R_standard_topology)) (const_family omega 0) = {f :e product_space omega (const_space_family omega R R_standard_topology) | exists F:set, finite F /\ forall i:set, i :e omega :\: F -> apply_fun f i = 0}.
admit. (** product topology: entire space connected; box topology: component consists of functions finite-different from 0 **)
Qed.

(** from 23 Exercise: ordered square locally connected but not locally path connected **) 
Theorem ex23_ordered_square_locally_conn_not_pathconn :
  locally_connected ordered_square ordered_square_topology /\
  ~ locally_path_connected ordered_square ordered_square_topology.
prove locally_connected ordered_square ordered_square_topology /\ ~ locally_path_connected ordered_square ordered_square_topology.
admit. (** order topology basis gives local connectedness; vertical lines prevent local path-connectedness **)
Qed.

(** from 23 Exercise: connected open subsets of locally path connected spaces are path connected **) 
Theorem ex23_connected_open_sets_path_connected : forall X Tx U:set,
  locally_path_connected X Tx -> open_in X Tx U -> connected_space U (subspace_topology X Tx U) -> path_connected_space U (subspace_topology X Tx U).
let X Tx U.
assume Hlpc: locally_path_connected X Tx.
assume HU: open_in X Tx U.
assume Hconn: connected_space U (subspace_topology X Tx U).
prove path_connected_space U (subspace_topology X Tx U).
admit. (** path components are open; if >1 exist, contradicts connectedness; thus all points in one path component
        aby: open_in_subspace_iff In_5Find open_setf ex13_1_local_open_subset conj_myprob_9523_1_20251124_090409 subspace_topologyf subspace_topology_is_topology prop_ext_2 path_connected_spacef . **)
Qed.

(** from 23 Exercise: examples of path connected but not locally connected subsets of ^2 **) 
Theorem ex23_path_connected_not_locally_connected_examples :
  exists A:set,
    A c= EuclidPlane /\ path_connected_space A (subspace_topology EuclidPlane R2_standard_topology A) /\
    ~ locally_connected A (subspace_topology EuclidPlane R2_standard_topology A).
prove exists A:set,
    A c= EuclidPlane /\ path_connected_space A (subspace_topology EuclidPlane R2_standard_topology A) /\
    ~ locally_connected A (subspace_topology EuclidPlane R2_standard_topology A).
admit. (** topologist's sine curve or comb space: path connected but not locally connected at limit points **)
Qed.

(** from 26 Definition: compact space **) 
Definition open_cover_of : set -> set -> set -> prop := fun X Tx Fam =>
  topology_on X Tx /\ Fam c= Power X /\ X c= Union Fam /\ (forall U:set, U :e Fam -> U :e Tx).

Definition has_finite_subcover : set -> set -> set -> prop := fun X Tx Fam =>
  exists G:set, G c= Fam /\ finite G /\ X c= Union G.

(** Helper: introduce `has_finite_subcover` with an explicit witness. **)
Theorem has_finite_subcoverI : forall X Tx Fam G:set,
  G c= Fam /\ finite G /\ X c= Union G -> has_finite_subcover X Tx Fam.
let X Tx Fam G.
assume HG: G c= Fam /\ finite G /\ X c= Union G.
prove has_finite_subcover X Tx Fam.
prove exists G1:set, G1 c= Fam /\ finite G1 /\ X c= Union G1.
witness G.
exact HG.
Qed.

Definition compact_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\ forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam.

(** from 26: open cover characterization **) 
Theorem Heine_Borel_subcover : forall X Tx Fam:set,
  compact_space X Tx ->
  open_cover_of X Tx Fam ->
  has_finite_subcover X Tx Fam.
let X Tx Fam.
assume Hcomp: compact_space X Tx.
assume HFam: open_cover_of X Tx Fam.
prove has_finite_subcover X Tx Fam.
(** compact_space X Tx = topology_on X Tx /\ (forall Fam, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam) **)
claim Hsubcover: forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam.
{ exact (andER (topology_on X Tx) (forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam) Hcomp). }
exact (Hsubcover Fam HFam).
Qed.

(** from 26 Lemma 26.1: covering a subspace by ambient opens **)
(** FIXED: open_cover_of Y Tx Fam included topology_on Y Tx, which is wrong (Tx is topology on X, not Y).
    Now: directly state the covering condition (Fam c= Tx /\ Y c= Union Fam) without nonsensical topology_on. **)
Theorem compact_subspace_via_ambient_covers : forall X Tx Y:set,
  topology_on X Tx -> Y c= X ->
  (compact_space Y (subspace_topology X Tx Y) <->
    forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam).
let X Tx Y.
assume HTx: topology_on X Tx.
assume HY: Y c= X.
prove compact_space Y (subspace_topology X Tx Y) <->
    forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam.
set Ty := subspace_topology X Tx Y.
apply iffI.
- (** -> **)
  assume Hcomp: compact_space Y Ty.
  prove forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam.
  let Fam. assume Hcov: Fam c= Tx /\ Y c= Union Fam.
  claim HFamSub: Fam c= Tx.
  { exact (andEL (Fam c= Tx) (Y c= Union Fam) Hcov). }
  claim HYcov: Y c= Union Fam.
  { exact (andER (Fam c= Tx) (Y c= Union Fam) Hcov). }
  (** Turn the ambient cover into a subspace open cover by intersecting with Y. **)
  set FamY := {U :/\: Y|U :e Fam}.
  claim HtopY: topology_on Y Ty.
  { exact (andEL (topology_on Y Ty)
                 (forall Fam:set, open_cover_of Y Ty Fam -> has_finite_subcover Y Ty Fam)
                 Hcomp). }
  claim HcoverFamY: open_cover_of Y Ty FamY.
  { prove topology_on Y Ty /\ FamY c= Power Y /\ Y c= Union FamY /\ (forall U:set, U :e FamY -> U :e Ty).
    (** conjunction is left-associative: (((A /\ B) /\ C) /\ D) **)
    apply andI.
    - (** (A /\ B) /\ C **)
      apply andI.
      + (** A /\ B **)
        apply andI.
        * exact HtopY.
        * (** FamY c= Power Y **)
          let W. assume HW: W :e FamY.
          prove W :e Power Y.
          apply (ReplE_impred Fam (fun U:set => U :/\: Y) W HW).
          let U. assume HUfam: U :e Fam.
          assume HWeq: W = U :/\: Y.
          rewrite HWeq.
          apply PowerI.
          exact (binintersect_Subq_2 U Y).
      + (** Y c= Union FamY **)
        let y. assume HyY: y :e Y.
        prove y :e Union FamY.
        claim HyUnionFam: y :e Union Fam.
        { exact (HYcov y HyY). }
        apply (UnionE_impred Fam y HyUnionFam).
        let U. assume HyU: y :e U.
        assume HUfam: U :e Fam.
        prove y :e Union FamY.
        apply (UnionI FamY y (U :/\: Y)).
        - prove y :e U :/\: Y.
          exact (binintersectI U Y y HyU HyY).
        - prove (U :/\: Y) :e FamY.
          exact (ReplI Fam (fun V:set => V :/\: Y) U HUfam).
    - (** each cover element is open in the subspace topology **)
      let W. assume HW: W :e FamY.
      prove W :e Ty.
      apply (ReplE_impred Fam (fun U:set => U :/\: Y) W HW).
      let U. assume HUfam: U :e Fam.
      assume HWeq: W = U :/\: Y.
      rewrite HWeq.
      prove (U :/\: Y) :e subspace_topology X Tx Y.
      prove (U :/\: Y) :e {U0 :e Power Y | exists V :e Tx, U0 = V :/\: Y}.
      apply SepI.
      + apply PowerI.
        exact (binintersect_Subq_2 U Y).
      + prove exists V :e Tx, U :/\: Y = V :/\: Y.
        witness U.
        apply andI.
        * exact (HFamSub U HUfam).
        * reflexivity. }
  (** Apply compactness of Y in the subspace topology. **)
  claim Hsubcover: forall Fam0:set, open_cover_of Y Ty Fam0 -> has_finite_subcover Y Ty Fam0.
  { exact (andER (topology_on Y Ty)
                 (forall Fam0:set, open_cover_of Y Ty Fam0 -> has_finite_subcover Y Ty Fam0)
                 Hcomp). }
  claim HfinY: has_finite_subcover Y Ty FamY.
  { exact (Hsubcover FamY HcoverFamY). }
  apply HfinY.
  let GY. assume HGY: GY c= FamY /\ finite GY /\ Y c= Union GY.
  (** conjunction is left-associative: (A /\ B) /\ C **)
  claim HGYleft: GY c= FamY /\ finite GY.
  { exact (andEL (GY c= FamY /\ finite GY) (Y c= Union GY) HGY). }
  claim HGYsub: GY c= FamY.
  { exact (andEL (GY c= FamY) (finite GY) HGYleft). }
  claim HGYfin: finite GY.
  { exact (andER (GY c= FamY) (finite GY) HGYleft). }
  claim HGYcov: Y c= Union GY.
  { exact (andER (GY c= FamY /\ finite GY) (Y c= Union GY) HGY). }
	  (** Choose, for each W in GY, an ambient set U in Fam with W = U /\ Y. **)
	  set pickU := fun W:set => Eps_i (fun U:set => U :e Fam /\ W = U :/\: Y).
	  set G := {pickU W|W :e GY}.
		  prove exists G1:set, G1 c= Fam /\ finite G1 /\ Y c= Union G1.
		  witness G.
		  prove G c= Fam /\ finite G /\ Y c= Union G.
	  apply andI.
  - apply andI.
    + (** G c= Fam **)
      let U. assume HU: U :e G.
      prove U :e Fam.
      apply (ReplE_impred GY (fun W:set => pickU W) U HU).
      let W. assume HWGY: W :e GY.
      assume HeqU: U = pickU W.
      rewrite HeqU.
      (** show pickU W is in Fam using epsilon **)
      claim HWFamY: W :e FamY.
      { exact (HGYsub W HWGY). }
      claim HexU: exists U0:set, U0 :e Fam /\ W = U0 :/\: Y.
      { apply (ReplE_impred Fam (fun U1:set => U1 :/\: Y) W HWFamY).
        let U0. assume HU0fam: U0 :e Fam.
        assume HW0: W = U0 :/\: Y.
        witness U0.
        apply andI.
        - exact HU0fam.
        - exact HW0. }
      (** apply epsilon to obtain membership in Fam **)
      apply HexU.
      let U0. assume HU0pair: U0 :e Fam /\ W = U0 :/\: Y.
      claim HU0: U0 :e Fam.
      { exact (andEL (U0 :e Fam) (W = U0 :/\: Y) HU0pair). }
      exact (andEL (pickU W :e Fam) (W = pickU W :/\: Y)
                   (Eps_i_ax (fun U1:set => U1 :e Fam /\ W = U1 :/\: Y) U0 HU0pair)).
    + (** finite G **)
      exact (Repl_finite (fun W:set => pickU W) GY HGYfin).
  - (** Y c= Union G **)
    let y. assume HyY: y :e Y.
    prove y :e Union G.
    claim HyUGY: y :e Union GY.
    { exact (HGYcov y HyY). }
    apply (UnionE_impred GY y HyUGY).
    let W. assume HyW: y :e W.
    assume HWGY: W :e GY.
    prove y :e Union G.
    (** show y in pickU W **)
    claim HWFamY: W :e FamY.
    { exact (HGYsub W HWGY). }
    claim HexU: exists U0:set, U0 :e Fam /\ W = U0 :/\: Y.
    { apply (ReplE_impred Fam (fun U1:set => U1 :/\: Y) W HWFamY).
      let U0. assume HU0fam: U0 :e Fam.
      assume HW0: W = U0 :/\: Y.
      witness U0.
      apply andI.
      - exact HU0fam.
      - exact HW0. }
    claim Hpick: W = pickU W :/\: Y.
    { apply HexU.
      let U0. assume HU0pair: U0 :e Fam /\ W = U0 :/\: Y.
      exact (andER (pickU W :e Fam) (W = pickU W :/\: Y)
                   (Eps_i_ax (fun U1:set => U1 :e Fam /\ W = U1 :/\: Y) U0 HU0pair)). }
	  claim HyInPick: y :e pickU W.
	  { claim HyWY: y :e pickU W :/\: Y.
	    { rewrite <- Hpick at 1.
	      exact HyW. }
	    exact (binintersectE1 (pickU W) Y y HyWY). }
	    exact (UnionI G y (pickU W) HyInPick
	                  (ReplI GY (fun W0:set => pickU W0) W HWGY)).

- (** <- **)
  assume Hprop: forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam.
  prove compact_space Y Ty.
  prove topology_on Y Ty /\ forall Fam:set, open_cover_of Y Ty Fam -> has_finite_subcover Y Ty Fam.
  apply andI.
  - exact (subspace_topology_is_topology X Tx Y HTx HY).
	  - let Fam0. assume Hcov0: open_cover_of Y Ty Fam0.
	    prove has_finite_subcover Y Ty Fam0.
	    (** Extract cover facts **)
	    (** open_cover_of Y Ty Fam0 is left-associative: (((A /\ B) /\ C) /\ D) **)
	    claim Hcov0_ABC: (topology_on Y Ty /\ Fam0 c= Power Y) /\ Y c= Union Fam0.
	    { exact (andEL ((topology_on Y Ty /\ Fam0 c= Power Y) /\ Y c= Union Fam0)
	                   (forall U:set, U :e Fam0 -> U :e Ty) Hcov0). }
	    claim Hcov0_AB: topology_on Y Ty /\ Fam0 c= Power Y.
	    { exact (andEL (topology_on Y Ty /\ Fam0 c= Power Y) (Y c= Union Fam0) Hcov0_ABC). }
	    claim HF0subPow: Fam0 c= Power Y.
	    { exact (andER (topology_on Y Ty) (Fam0 c= Power Y) Hcov0_AB). }
	    claim HYcov0: Y c= Union Fam0.
	    { exact (andER (topology_on Y Ty /\ Fam0 c= Power Y) (Y c= Union Fam0) Hcov0_ABC). }
	    claim HF0open: forall U:set, U :e Fam0 -> U :e Ty.
	    { exact (andER ((topology_on Y Ty /\ Fam0 c= Power Y) /\ Y c= Union Fam0)
	                   (forall U:set, U :e Fam0 -> U :e Ty) Hcov0). }

    (** For each W in Fam0 choose an ambient open V in Tx with W = V /\ Y. **)
    set Vof := fun W:set => Eps_i (fun V:set => V :e Tx /\ W = V :/\: Y).
    set Fam := {Vof W|W :e Fam0}.
    claim HFamSub: Fam c= Tx.
    { let V. assume HV: V :e Fam.
      prove V :e Tx.
      apply (ReplE_impred Fam0 (fun W:set => Vof W) V HV).
      let W. assume HW: W :e Fam0.
      assume HVeq: V = Vof W.
      rewrite HVeq.
      (** epsilon yields Vof W in Tx **)
      claim HexV: exists V0:set, V0 :e Tx /\ W = V0 :/\: Y.
      { claim HWty: W :e Ty.
        { exact (HF0open W HW). }
        exact (SepE2 (Power Y) (fun U0:set => exists V0 :e Tx, U0 = V0 :/\: Y) W HWty). }
      apply HexV.
      let V0. assume HV0pair: V0 :e Tx /\ W = V0 :/\: Y.
      exact (andEL (Vof W :e Tx) (W = Vof W :/\: Y)
                   (Eps_i_ax (fun V1:set => V1 :e Tx /\ W = V1 :/\: Y) V0 HV0pair)). }

    claim HYcovFam: Y c= Union Fam.
    { let y. assume HyY: y :e Y.
      prove y :e Union Fam.
      claim HyUF0: y :e Union Fam0.
      { exact (HYcov0 y HyY). }
      apply (UnionE_impred Fam0 y HyUF0).
      let W. assume HyW: y :e W.
      assume HW: W :e Fam0.
      prove y :e Union Fam.
      claim HyV: y :e Vof W.
      { (** y in Vof W **)
        claim HexV: exists V0:set, V0 :e Tx /\ W = V0 :/\: Y.
        { claim HWty: W :e Ty.
          { exact (HF0open W HW). }
          exact (SepE2 (Power Y) (fun U0:set => exists V0 :e Tx, U0 = V0 :/\: Y) W HWty). }
        claim Hpick: W = Vof W :/\: Y.
        { apply HexV.
          let V0. assume HV0pair: V0 :e Tx /\ W = V0 :/\: Y.
          exact (andER (Vof W :e Tx) (W = Vof W :/\: Y)
                       (Eps_i_ax (fun V1:set => V1 :e Tx /\ W = V1 :/\: Y) V0 HV0pair)). }
        claim HyWY: y :e Vof W :/\: Y.
        { rewrite <- Hpick at 1.
          exact HyW. }
        exact (binintersectE1 (Vof W) Y y HyWY). }
      claim HVFam: (Vof W) :e Fam.
      { exact (ReplI Fam0 (fun W0:set => Vof W0) W HW). }
      exact (UnionI Fam y (Vof W) HyV HVFam). }

    (** Apply the ambient-cover property to get finite subcover G of Fam **)
    claim Hfin: has_finite_subcover Y Tx Fam.
    { exact (Hprop Fam (andI (Fam c= Tx) (Y c= Union Fam) HFamSub HYcovFam)). }
	    apply Hfin.
	    let G. assume HG: G c= Fam /\ finite G /\ Y c= Union G.
	    (** conjunction is left-associative: (A /\ B) /\ C **)
	    claim HGleft: G c= Fam /\ finite G.
	    { exact (andEL (G c= Fam /\ finite G) (Y c= Union G) HG). }
	    claim HGsub: G c= Fam.
	    { exact (andEL (G c= Fam) (finite G) HGleft). }
	    claim HGfin: finite G.
	    { exact (andER (G c= Fam) (finite G) HGleft). }
	    claim HGcov: Y c= Union G.
	    { exact (andER (G c= Fam /\ finite G) (Y c= Union G) HG). }

	    (** Convert G back to a finite subfamily of Fam0. **)
	    set Wof := fun V:set => Eps_i (fun W:set => W :e Fam0 /\ V = Vof W).
	    set G0 := {Wof V|V :e G}.
	    prove exists G1:set, G1 c= Fam0 /\ finite G1 /\ Y c= Union G1.
	    witness G0.
	    prove G0 c= Fam0 /\ finite G0 /\ Y c= Union G0.
    apply andI.
    - apply andI.
      + (** G0 c= Fam0 **)
        let W. assume HW: W :e G0.
        prove W :e Fam0.
        apply (ReplE_impred G (fun V:set => Wof V) W HW).
        let V. assume HVG: V :e G.
        assume HWof: W = Wof V.
        rewrite HWof.
        (** epsilon picks W in Fam0 **)
        claim HVFam: V :e Fam.
        { exact (HGsub V HVG). }
        claim HexW: exists W0:set, W0 :e Fam0 /\ V = Vof W0.
        { apply (ReplE_impred Fam0 (fun W0:set => Vof W0) V HVFam).
          let W0. assume HW0: W0 :e Fam0.
          assume HVeq: V = Vof W0.
          witness W0.
          apply andI.
          - exact HW0.
          - exact HVeq. }
        apply HexW.
        let W0. assume HW0pair: W0 :e Fam0 /\ V = Vof W0.
        exact (andEL (Wof V :e Fam0) (V = Vof (Wof V))
                     (Eps_i_ax (fun W1:set => W1 :e Fam0 /\ V = Vof W1) W0 HW0pair)).
      + (** finite G0 **)
        exact (Repl_finite (fun V:set => Wof V) G HGfin).
    - (** Y c= Union G0 **)
      let y. assume HyY: y :e Y.
      prove y :e Union G0.
      claim HyUG: y :e Union G.
      { exact (HGcov y HyY). }
      apply (UnionE_impred G y HyUG).
      let V. assume HyV: y :e V.
      assume HVG: V :e G.
      prove y :e Union G0.
      (** show y in Wof V, using that V = Vof (Wof V) and Wof V = (Vof (Wof V)) /\ Y **)
      claim HVFam: V :e Fam.
      { exact (HGsub V HVG). }
      claim HexW: exists W0:set, W0 :e Fam0 /\ V = Vof W0.
      { apply (ReplE_impred Fam0 (fun W0:set => Vof W0) V HVFam).
        let W0. assume HW0: W0 :e Fam0.
        assume HVeq: V = Vof W0.
        witness W0.
        apply andI.
        - exact HW0.
        - exact HVeq. }
      claim HVeq: V = Vof (Wof V).
      { apply HexW.
        let W0. assume HW0pair: W0 :e Fam0 /\ V = Vof W0.
        exact (andER (Wof V :e Fam0) (V = Vof (Wof V))
                     (Eps_i_ax (fun W1:set => W1 :e Fam0 /\ V = Vof W1) W0 HW0pair)). }
      claim HWty: (Wof V) :e Ty.
      { claim HWinFam0: (Wof V) :e Fam0.
        { apply HexW.
          let W0. assume HW0pair: W0 :e Fam0 /\ V = Vof W0.
          exact (andEL (Wof V :e Fam0) (V = Vof (Wof V))
                       (Eps_i_ax (fun W1:set => W1 :e Fam0 /\ V = Vof W1) W0 HW0pair)). }
        exact (HF0open (Wof V) HWinFam0). }
      claim HexV: exists V0:set, V0 :e Tx /\ (Wof V) = V0 :/\: Y.
      { exact (SepE2 (Power Y) (fun U0:set => exists V0 :e Tx, U0 = V0 :/\: Y) (Wof V) HWty). }
      claim HWrepr: (Wof V) = (Vof (Wof V)) :/\: Y.
      { apply HexV.
        let V0. assume HV0pair: V0 :e Tx /\ (Wof V) = V0 :/\: Y.
        exact (andER (Vof (Wof V) :e Tx) ((Wof V) = (Vof (Wof V)) :/\: Y)
                     (Eps_i_ax (fun V1:set => V1 :e Tx /\ (Wof V) = V1 :/\: Y) V0 HV0pair)). }
      claim HyInWof: y :e (Wof V).
      { rewrite HWrepr at 1.
        rewrite <- HVeq at 1.
        exact (binintersectI V Y y HyV HyY). }
      exact (UnionI G0 y (Wof V) HyInWof
                    (ReplI G (fun V0:set => Wof V0) V HVG)).
Qed.

(** from 26 Theorem 26.2: closed subspaces of compact spaces are compact **) 
Theorem closed_subspace_compact : forall X Tx Y:set,
  compact_space X Tx -> closed_in X Tx Y -> compact_space Y (subspace_topology X Tx Y).
let X Tx Y.
assume Hcomp: compact_space X Tx.
assume HY: closed_in X Tx Y.
prove compact_space Y (subspace_topology X Tx Y).
set Ty := subspace_topology X Tx Y.
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam) Hcomp). }
claim HsubcoverX: forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam.
{ exact (andER (topology_on X Tx) (forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam) Hcomp). }
claim HYsub: Y c= X.
{ exact (closed_in_subset X Tx Y HY). }
(** Choose an open complement U of Y in X. **)
claim HexU: exists U :e Tx, Y = X :\: U.
{ claim HYparts: Y c= X /\ exists U :e Tx, Y = X :\: U.
  { exact (andER (topology_on X Tx) (Y c= X /\ exists U :e Tx, Y = X :\: U) HY). }
  exact (andER (Y c= X) (exists U :e Tx, Y = X :\: U) HYparts). }
apply HexU.
let U.
assume HUpair: U :e Tx /\ Y = X :\: U.
claim HUu: U :e Tx.
{ exact (andEL (U :e Tx) (Y = X :\: U) HUpair). }
claim HYeq: Y = X :\: U.
{ exact (andER (U :e Tx) (Y = X :\: U) HUpair). }

(** Use the characterization via ambient open covers. **)
claim Hequiv:
  (compact_space Y Ty <->
    forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam).
{ exact (compact_subspace_via_ambient_covers X Tx Y HTx HYsub). }
apply (iffER (compact_space Y Ty)
             (forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam)
             Hequiv).

let Fam. assume HFamcov: Fam c= Tx /\ Y c= Union Fam.
claim HFamSub: Fam c= Tx.
{ exact (andEL (Fam c= Tx) (Y c= Union Fam) HFamcov). }
claim HYcovFam: Y c= Union Fam.
{ exact (andER (Fam c= Tx) (Y c= Union Fam) HFamcov). }

(** Extend the cover of Y by adding U; this covers X. **)
set CoverX := Fam :\/: {U}.
claim HcoverX: open_cover_of X Tx CoverX.
{ prove topology_on X Tx /\ CoverX c= Power X /\ X c= Union CoverX /\ (forall V:set, V :e CoverX -> V :e Tx).
  apply andI.
  - (** (CoverX c= Power X) /\ X c= Union CoverX **)
    apply andI.
    + (** topology_on X Tx /\ CoverX c= Power X **)
      apply andI.
      * exact HTx.
      * (** CoverX c= Power X **)
	        let V. assume HV: V :e CoverX.
	        prove V :e Power X.
	        apply (binunionE Fam {U} V HV).
	        - assume HVF: V :e Fam.
	           claim HVTx: V :e Tx.
	           { exact (HFamSub V HVF). }
	           claim HVsub: V c= X.
	           { exact (topology_elem_subset X Tx V HTx HVTx). }
	           exact (PowerI X V HVsub).
	        - assume HVU: V :e {U}.
	           claim HVe: V = U.
	           { exact (SingE U V HVU). }
	           rewrite HVe.
	           claim HUsub: U c= X.
	           { exact (topology_elem_subset X Tx U HTx HUu). }
	           exact (PowerI X U HUsub).
    + (** X c= Union CoverX **)
      let x. assume HxX: x :e X.
      prove x :e Union CoverX.
      apply (xm (x :e U)).
      * assume HxU: x :e U.
        exact (UnionI CoverX x U HxU (binunionI2 Fam {U} U (SingI U))).
      * assume HxnotU: ~ x :e U.
        claim HxY: x :e Y.
        { rewrite HYeq.
          exact (setminusI X U x HxX HxnotU). }
        claim HxUFam: x :e Union Fam.
        { exact (HYcovFam x HxY). }
        apply (UnionE_impred Fam x HxUFam).
        let V. assume HxV: x :e V.
        assume HVF: V :e Fam.
        prove x :e Union CoverX.
        exact (UnionI CoverX x V HxV (binunionI1 Fam {U} V HVF)).
  - (** each element of CoverX is open in Tx **)
    let V. assume HV: V :e CoverX.
    prove V :e Tx.
    apply (binunionE Fam {U} V HV).
    + assume HVF: V :e Fam.
      exact (HFamSub V HVF).
    + assume HVU: V :e {U}.
      claim HVe: V = U.
      { exact (SingE U V HVU). }
      rewrite HVe.
      exact HUu. }

(** Compactness of X gives a finite subcover of CoverX. **)
claim HfinCoverX: has_finite_subcover X Tx CoverX.
{ exact (HsubcoverX CoverX HcoverX). }
apply HfinCoverX.
let G. assume HG: G c= CoverX /\ finite G /\ X c= Union G.
claim HGleft: G c= CoverX /\ finite G.
{ exact (andEL (G c= CoverX /\ finite G) (X c= Union G) HG). }
claim HGsub: G c= CoverX.
{ exact (andEL (G c= CoverX) (finite G) HGleft). }
claim HGfin: finite G.
{ exact (andER (G c= CoverX) (finite G) HGleft). }
claim HGcovX: X c= Union G.
{ exact (andER (G c= CoverX /\ finite G) (X c= Union G) HG). }

(** Remove U from G to obtain a finite subcover drawn from Fam. **)
set G1 := G :\: {U}.
claim HG1subG: G1 c= G.
{ exact (setminus_Subq G {U}). }
claim HG1fin: finite G1.
{ exact (Subq_finite G HGfin G1 HG1subG). }
claim HG1subFam: G1 c= Fam.
{ let V. assume HVG1: V :e G1.
  prove V :e Fam.
  claim HVG: V :e G.
  { exact (setminusE1 G {U} V HVG1). }
  claim HVnotU: V /:e {U}.
  { exact (setminusE2 G {U} V HVG1). }
  claim HVinCover: V :e CoverX.
  { exact (HGsub V HVG). }
  apply (binunionE Fam {U} V HVinCover).
  - assume HVF: V :e Fam.
    exact HVF.
  - assume HVU: V :e {U}.
    prove V :e Fam.
    prove False.
    apply HVnotU.
    exact HVU. }
claim HYcovG1: Y c= Union G1.
{ let y. assume HyY: y :e Y.
  prove y :e Union G1.
  claim HyX: y :e X.
  { exact (HYsub y HyY). }
  claim HyUG: y :e Union G.
  { exact (HGcovX y HyX). }
  apply (UnionE_impred G y HyUG).
  let V. assume HyV: y :e V.
  assume HVG: V :e G.
  prove y :e Union G1.
  claim HVinCover: V :e CoverX.
  { exact (HGsub V HVG). }
  claim HVnotU: V /:e {U}.
  { apply (binunionE Fam {U} V HVinCover).
    - assume HVF: V :e Fam.
      prove V /:e {U}.
      assume HVU: V :e {U}.
      claim HVe: V = U.
      { exact (SingE U V HVU). }
	      (** y in Y implies y not in U **)
	      claim HyNotU: y /:e U.
	      { claim HyYU: y :e X :\: U.
	        { rewrite <- HYeq at 1.
	          exact HyY. }
	        exact (setminusE2 X U y HyYU). }
	      apply HyNotU.
	      rewrite <- HVe.
	      exact HyV.
	    - assume HVU: V :e {U}.
	      prove V /:e {U}.
	      assume HVU2: V :e {U}.
	      claim HVe: V = U.
	      { exact (SingE U V HVU2). }
	      claim HyNotU: y /:e U.
	      { claim HyYU: y :e X :\: U.
	        { rewrite <- HYeq at 1.
	          exact HyY. }
	        exact (setminusE2 X U y HyYU). }
	      apply HyNotU.
	      rewrite <- HVe.
	      exact HyV. }
  claim HVG1: V :e G1.
  { exact (setminusI G {U} V HVG HVnotU). }
  exact (UnionI G1 y V HyV HVG1). }

claim HG1left: G1 c= Fam /\ finite G1.
{ apply andI.
  - exact HG1subFam.
  - exact HG1fin. }
claim HG1triple: G1 c= Fam /\ finite G1 /\ Y c= Union G1.
{ apply andI.
  - exact HG1left.
  - exact HYcovG1. }
exact (has_finite_subcoverI Y Tx Fam G1 HG1triple).
Qed.

(** helper: separating point and compact set in Hausdorff space **)
(** This duplicates the proof of 26 Lemma 26.4, placed here so 26 Theorem 26.3 can use it without forward references. **)
Theorem Hausdorff_separate_point_compact_set_aux : forall X Tx Y x:set,
  Hausdorff_space X Tx -> Y c= X -> compact_space Y (subspace_topology X Tx Y) -> x :e X -> x /:e Y ->
  exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ Y c= V /\ U :/\: V = Empty.
let X Tx Y x.
assume HH: Hausdorff_space X Tx.
assume HYsub: Y c= X.
assume Hcomp: compact_space Y (subspace_topology X Tx Y).
assume HxX: x :e X.
assume Hx: x /:e Y.
prove exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ Y c= V /\ U :/\: V = Empty.
set Ty := subspace_topology X Tx Y.
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }
claim Hsep: forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
  exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
{ exact (andER (topology_on X Tx)
               (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }

(** Choose V_y and U_y for each y in Y. **)
set Vof := fun y:set =>
  Eps_i (fun V:set => exists U:set, U :e Tx /\ V :e Tx /\ x :e U /\ y :e V /\ U :/\: V = Empty).
set Uof := fun y:set =>
  Eps_i (fun U:set => U :e Tx /\ x :e U /\ U :/\: (Vof y) = Empty).

claim Vof_exists: forall y:set, y :e Y ->
  exists U:set, U :e Tx /\ (Vof y) :e Tx /\ x :e U /\ y :e (Vof y) /\ U :/\: (Vof y) = Empty.
{ let y. assume HyY: y :e Y.
  claim HyX: y :e X.
  { exact (HYsub y HyY). }
  claim Hneq: x <> y.
  { assume Heq: x = y.
    apply Hx.
    rewrite Heq.
    exact HyY. }
  claim Hex: exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ y :e V /\ U :/\: V = Empty.
  { exact (Hsep x y HxX HyX Hneq). }
  apply Hex.
  let U0. assume HexV0: exists V0:set, U0 :e Tx /\ V0 :e Tx /\ x :e U0 /\ y :e V0 /\ U0 :/\: V0 = Empty.
  apply HexV0.
  let V0. assume HUV0: U0 :e Tx /\ V0 :e Tx /\ x :e U0 /\ y :e V0 /\ U0 :/\: V0 = Empty.
  claim HpV0: exists U:set, U :e Tx /\ V0 :e Tx /\ x :e U /\ y :e V0 /\ U :/\: V0 = Empty.
  { witness U0.
    exact HUV0. }
  exact (Eps_i_ax (fun V:set => exists U:set, U :e Tx /\ V :e Tx /\ x :e U /\ y :e V /\ U :/\: V = Empty) V0 HpV0). }

claim Vof_in_Tx: forall y:set, y :e Y -> (Vof y) :e Tx.
{ let y. assume HyY: y :e Y.
  apply (Vof_exists y HyY).
  let U0. assume HU0: U0 :e Tx /\ (Vof y) :e Tx /\ x :e U0 /\ y :e (Vof y) /\ U0 :/\: (Vof y) = Empty.
  (** conjunction is left-associative **)
  claim HU0A: ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y).
  { exact (andEL (((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y))
                 (U0 :/\: (Vof y) = Empty) HU0). }
  claim HU0A1: (U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0.
  { exact (andEL ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) (y :e (Vof y)) HU0A). }
  claim HU0AB: U0 :e Tx /\ (Vof y) :e Tx.
  { exact (andEL (U0 :e Tx /\ (Vof y) :e Tx) (x :e U0) HU0A1). }
  exact (andER (U0 :e Tx) ((Vof y) :e Tx) HU0AB). }

claim y_in_Vof: forall y:set, y :e Y -> y :e (Vof y).
{ let y. assume HyY: y :e Y.
  apply (Vof_exists y HyY).
  let U0. assume HU0: U0 :e Tx /\ (Vof y) :e Tx /\ x :e U0 /\ y :e (Vof y) /\ U0 :/\: (Vof y) = Empty.
  claim HU0A: ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y).
  { exact (andEL (((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y))
                 (U0 :/\: (Vof y) = Empty) HU0). }
  exact (andER ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) (y :e (Vof y)) HU0A). }

claim Uof_props: forall y:set, y :e Y ->
  (Uof y) :e Tx /\ x :e (Uof y) /\ (Uof y) :/\: (Vof y) = Empty.
{ let y. assume HyY: y :e Y.
  claim HexU: exists U0:set, U0 :e Tx /\ x :e U0 /\ U0 :/\: (Vof y) = Empty.
  { apply (Vof_exists y HyY).
    let U0. assume HU0: U0 :e Tx /\ (Vof y) :e Tx /\ x :e U0 /\ y :e (Vof y) /\ U0 :/\: (Vof y) = Empty.
    witness U0.
    claim HU0A: ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y).
    { exact (andEL (((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y))
                   (U0 :/\: (Vof y) = Empty) HU0). }
    claim HU0A1: (U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0.
    { exact (andEL ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) (y :e (Vof y)) HU0A). }
    claim HU0AB: U0 :e Tx /\ (Vof y) :e Tx.
    { exact (andEL (U0 :e Tx /\ (Vof y) :e Tx) (x :e U0) HU0A1). }
    claim HU0Tx: U0 :e Tx.
    { exact (andEL (U0 :e Tx) ((Vof y) :e Tx) HU0AB). }
    claim HxU0: x :e U0.
    { exact (andER (U0 :e Tx /\ (Vof y) :e Tx) (x :e U0) HU0A1). }
    claim HU0disj: U0 :/\: (Vof y) = Empty.
    { exact (andER (((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y))
                   (U0 :/\: (Vof y) = Empty) HU0). }
    claim HU0pair: U0 :e Tx /\ x :e U0.
    { apply andI.
      - exact HU0Tx.
      - exact HxU0. }
    exact (andI (U0 :e Tx /\ x :e U0) (U0 :/\: (Vof y) = Empty) HU0pair HU0disj). }
  apply HexU.
  let U0. assume HU0: U0 :e Tx /\ x :e U0 /\ U0 :/\: (Vof y) = Empty.
  exact (Eps_i_ax (fun U:set => U :e Tx /\ x :e U /\ U :/\: (Vof y) = Empty) U0 HU0). }

(** Finite open cover of Y by the ambient opens Vof y. **)
set VFam := {Vof y|y :e Y}.
claim HVFamSub: VFam c= Tx.
{ let V. assume HV: V :e VFam.
  apply (ReplE_impred Y (fun y0:set => Vof y0) V HV).
  let y. assume HyY: y :e Y.
  assume HVe: V = Vof y.
  rewrite HVe.
  exact (Vof_in_Tx y HyY). }
claim HYcovVFam: Y c= Union VFam.
{ let y. assume HyY: y :e Y.
  prove y :e Union VFam.
  exact (UnionI VFam y (Vof y) (y_in_Vof y HyY) (ReplI Y (fun y0:set => Vof y0) y HyY)). }

(** Use compactness of Y in the subspace topology to obtain a finite subcover from VFam. **)
claim Hcovprop: forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam.
{ exact (iffEL (compact_space Y Ty)
               (forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam)
               (compact_subspace_via_ambient_covers X Tx Y HTx HYsub) Hcomp). }
claim Hfin: has_finite_subcover Y Tx VFam.
{ exact (Hcovprop VFam (andI (VFam c= Tx) (Y c= Union VFam) HVFamSub HYcovVFam)). }
apply Hfin.
let G. assume HG: G c= VFam /\ finite G /\ Y c= Union G.
claim HGleft: G c= VFam /\ finite G.
{ exact (andEL (G c= VFam /\ finite G) (Y c= Union G) HG). }
claim HGsub: G c= VFam.
{ exact (andEL (G c= VFam) (finite G) HGleft). }
claim HGfin: finite G.
{ exact (andER (G c= VFam) (finite G) HGleft). }
claim HGcov: Y c= Union G.
{ exact (andER (G c= VFam /\ finite G) (Y c= Union G) HG). }

(** Build the separating open sets U and V from the finite subcover G. **)
set V := Union G.
claim HGTX: G c= Tx.
{ let W. assume HW: W :e G.
  claim HWVFam: W :e VFam.
  { exact (HGsub W HW). }
  exact (HVFamSub W HWVFam). }
claim HVopen: V :e Tx.
{ exact (topology_union_closed X Tx G HTx HGTX). }
claim HYsubV: Y c= V.
{ exact HGcov. }

set pickY := fun V0:set => Eps_i (fun y0:set => y0 :e Y /\ V0 = Vof y0).
set UFam := {Uof (pickY V0)|V0 :e G}.
set U := intersection_of_family X UFam.

claim HUFamSub: UFam c= Tx.
{ let U0. assume HU0: U0 :e UFam.
  apply (ReplE_impred G (fun V0:set => Uof (pickY V0)) U0 HU0).
  let V0. assume HV0G: V0 :e G.
  assume HU0eq: U0 = Uof (pickY V0).
  rewrite HU0eq.
  claim Hpick: pickY V0 :e Y.
  { claim HV0VFam: V0 :e VFam.
    { exact (HGsub V0 HV0G). }
    apply (ReplE_impred Y (fun y0:set => Vof y0) V0 HV0VFam).
    let y0. assume Hy0Y: y0 :e Y.
    assume HV0eq: V0 = Vof y0.
    claim Hp: (y0 :e Y /\ V0 = Vof y0).
    { exact (andI (y0 :e Y) (V0 = Vof y0) Hy0Y HV0eq). }
    exact (andEL (pickY V0 :e Y) (V0 = Vof (pickY V0))
                 (Eps_i_ax (fun y:set => y :e Y /\ V0 = Vof y) y0 Hp)). }
  claim HUof: (Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)) /\ (Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty.
  { exact (Uof_props (pickY V0) Hpick). }
  claim HUof1: (Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)).
  { exact (andEL ((Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)))
                 ((Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty) HUof). }
  exact (andEL ((Uof (pickY V0)) :e Tx) (x :e (Uof (pickY V0))) HUof1). }

claim HUFamFin: finite UFam.
{ exact (Repl_finite (fun V0:set => Uof (pickY V0)) G HGfin). }
claim HUFamPow: UFam :e Power Tx.
{ exact (PowerI Tx UFam HUFamSub). }
claim HUopen: U :e Tx.
{ exact (finite_intersection_in_topology X Tx UFam HTx HUFamPow HUFamFin). }

claim HxU: x :e U.
{ prove x :e intersection_of_family X UFam.
  prove x :e {z :e X | forall T:set, T :e UFam -> z :e T}.
  apply SepI.
  - exact HxX.
  - let W. assume HW: W :e UFam.
    apply (ReplE_impred G (fun V0:set => Uof (pickY V0)) W HW).
    let V0. assume HV0G: V0 :e G.
    assume HWeq: W = Uof (pickY V0).
    rewrite HWeq.
    claim Hpick: pickY V0 :e Y.
    { claim HV0VFam: V0 :e VFam.
      { exact (HGsub V0 HV0G). }
      apply (ReplE_impred Y (fun y0:set => Vof y0) V0 HV0VFam).
      let y0. assume Hy0Y: y0 :e Y.
      assume HV0eq: V0 = Vof y0.
      claim Hp: (y0 :e Y /\ V0 = Vof y0).
      { exact (andI (y0 :e Y) (V0 = Vof y0) Hy0Y HV0eq). }
      exact (andEL (pickY V0 :e Y) (V0 = Vof (pickY V0))
                   (Eps_i_ax (fun y:set => y :e Y /\ V0 = Vof y) y0 Hp)). }
    claim HUof: (Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)) /\ (Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty.
    { exact (Uof_props (pickY V0) Hpick). }
    claim HUof1: (Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)).
    { exact (andEL ((Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)))
                   ((Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty) HUof). }
    exact (andER ((Uof (pickY V0)) :e Tx) (x :e (Uof (pickY V0))) HUof1). }

claim HUVdisj: U :/\: V = Empty.
{ apply Empty_Subq_eq.
  let z. assume Hz: z :e U :/\: V.
  prove False.
  claim HzU: z :e U.
  { exact (binintersectE1 U V z Hz). }
  claim HzV: z :e V.
  { exact (binintersectE2 U V z Hz). }
  claim HzUG: z :e Union G.
  { exact HzV. }
  apply (UnionE_impred G z HzUG).
  let V0. assume HzV0: z :e V0.
  assume HV0G: V0 :e G.
  claim HV0VFam: V0 :e VFam.
  { exact (HGsub V0 HV0G). }
  apply (ReplE_impred Y (fun y0:set => Vof y0) V0 HV0VFam).
  let y0. assume Hy0Y: y0 :e Y.
  assume HV0eq: V0 = Vof y0.
  claim Hp: y0 :e Y /\ V0 = Vof y0.
  { exact (andI (y0 :e Y) (V0 = Vof y0) Hy0Y HV0eq). }
  claim HpickY: pickY V0 :e Y /\ V0 = Vof (pickY V0).
  { exact (Eps_i_ax (fun y:set => y :e Y /\ V0 = Vof y) y0 Hp). }
  claim Hpick: pickY V0 :e Y.
  { exact (andEL (pickY V0 :e Y) (V0 = Vof (pickY V0)) HpickY). }
  claim HV0rep: V0 = Vof (pickY V0).
  { exact (andER (pickY V0 :e Y) (V0 = Vof (pickY V0)) HpickY). }
  claim HUof: (Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)) /\ (Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty.
  { exact (Uof_props (pickY V0) Hpick). }
  claim HUofdisj: (Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty.
  { exact (andER ((Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)))
                 ((Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty) HUof). }
  claim HzUof: z :e (Uof (pickY V0)).
  { claim Hall: forall T:set, T :e UFam -> z :e T.
    { exact (SepE2 X (fun z0:set => forall T:set, T :e UFam -> z0 :e T) z HzU). }
    apply Hall.
    exact (ReplI G (fun V1:set => Uof (pickY V1)) V0 HV0G). }
  claim HzVof: z :e (Vof (pickY V0)).
  { rewrite <- HV0rep at 1.
    exact HzV0. }
  claim HzInt: z :e (Uof (pickY V0)) :/\: (Vof (pickY V0)).
  { exact (binintersectI (Uof (pickY V0)) (Vof (pickY V0)) z HzUof HzVof). }
  claim HzEmpty: z :e Empty.
  { rewrite <- HUofdisj at 1.
    exact HzInt. }
  exact (EmptyE z HzEmpty False). }

witness U.
witness V.
prove U :e Tx /\ V :e Tx /\ x :e U /\ Y c= V /\ U :/\: V = Empty.
apply andI.
- apply andI.
  + apply andI.
    * apply andI.
      - exact HUopen.
      - exact HVopen.
    * exact HxU.
  + exact HYsubV.
- exact HUVdisj.
Qed.

(** from 26 Theorem 26.3: compact subspaces of Hausdorff spaces are closed **) 
Theorem compact_subspace_in_Hausdorff_closed : forall X Tx Y:set,
  Hausdorff_space X Tx -> Y c= X -> compact_space Y (subspace_topology X Tx Y) -> closed_in X Tx Y.
let X Tx Y.
assume HH: Hausdorff_space X Tx.
assume HYsub: Y c= X.
assume Hcomp: compact_space Y (subspace_topology X Tx Y).
prove closed_in X Tx Y.
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }
prove topology_on X Tx /\ (Y c= X /\ exists U :e Tx, Y = X :\: U).
apply andI.
- exact HTx.
- prove Y c= X /\ exists U :e Tx, Y = X :\: U.
  apply andI.
  + exact HYsub.
  + (** show X \\ Y is open and use double complement **)
    witness (X :\: Y).
    apply andI.
    * (** X\\Y :e Tx **)
      set UFam := {U :e Tx | exists x0:set, x0 :e X :\: Y /\ x0 :e U /\ U :/\: Y = Empty}.
      claim HUFamSub: UFam c= Tx.
      { let U. assume HU: U :e UFam.
        exact (SepE1 Tx (fun U0:set => exists x0:set, x0 :e X :\: Y /\ x0 :e U0 /\ U0 :/\: Y = Empty) U HU). }
      claim HUnionEq: Union UFam = X :\: Y.
      { apply set_ext.
        - let z. assume Hz: z :e Union UFam.
          prove z :e X :\: Y.
          apply (UnionE_impred UFam z Hz).
          let U. assume HzU: z :e U.
          assume HU: U :e UFam.
          claim HUtx: U :e Tx.
          { exact (SepE1 Tx (fun U0:set => exists x0:set, x0 :e X :\: Y /\ x0 :e U0 /\ U0 :/\: Y = Empty) U HU). }
          claim HUsubX: U c= X.
          { exact (topology_elem_subset X Tx U HTx HUtx). }
          claim HzX: z :e X.
          { exact (HUsubX z HzU). }
          claim Hpred: exists x0:set, x0 :e X :\: Y /\ x0 :e U /\ U :/\: Y = Empty.
          { exact (SepE2 Tx (fun U0:set => exists x0:set, x0 :e X :\: Y /\ x0 :e U0 /\ U0 :/\: Y = Empty) U HU). }
          apply Hpred.
          let x0. assume Hx0: x0 :e X :\: Y /\ x0 :e U /\ U :/\: Y = Empty.
          claim HUYempty: U :/\: Y = Empty.
          { exact (andER (x0 :e X :\: Y /\ x0 :e U) (U :/\: Y = Empty) Hx0). }
          claim HzNotY: z /:e Y.
          { assume HzY: z :e Y.
            claim HzInt: z :e U :/\: Y.
            { exact (binintersectI U Y z HzU HzY). }
	            claim HzEmpty: z :e Empty.
	            { rewrite <- HUYempty at 1.
	              exact HzInt. }
	            exact (EmptyE z HzEmpty False). }
	          exact (setminusI X Y z HzX HzNotY).
        - let z. assume Hz: z :e X :\: Y.
          prove z :e Union UFam.
          claim HzX: z :e X.
          { exact (setminusE1 X Y z Hz). }
          claim HzNotY: z /:e Y.
          { exact (setminusE2 X Y z Hz). }
          claim HexUV: exists U V:set, U :e Tx /\ V :e Tx /\ z :e U /\ Y c= V /\ U :/\: V = Empty.
          { exact (Hausdorff_separate_point_compact_set_aux X Tx Y z HH HYsub Hcomp HzX HzNotY). }
          apply HexUV.
          let U. assume HexV: exists V:set, U :e Tx /\ V :e Tx /\ z :e U /\ Y c= V /\ U :/\: V = Empty.
          apply HexV.
          let V. assume Hconj: U :e Tx /\ V :e Tx /\ z :e U /\ Y c= V /\ U :/\: V = Empty.
          claim HconjA: ((U :e Tx /\ V :e Tx) /\ z :e U) /\ Y c= V.
          { exact (andEL (((U :e Tx /\ V :e Tx) /\ z :e U) /\ Y c= V) (U :/\: V = Empty) Hconj). }
          claim HUVempty: U :/\: V = Empty.
          { exact (andER (((U :e Tx /\ V :e Tx) /\ z :e U) /\ Y c= V) (U :/\: V = Empty) Hconj). }
          claim HUVz: (U :e Tx /\ V :e Tx) /\ z :e U.
          { exact (andEL ((U :e Tx /\ V :e Tx) /\ z :e U) (Y c= V) HconjA). }
          claim HUtx: U :e Tx.
          { exact (andEL (U :e Tx) (V :e Tx)
                         (andEL (U :e Tx /\ V :e Tx) (z :e U) HUVz)). }
          claim HzU: z :e U.
          { exact (andER (U :e Tx /\ V :e Tx) (z :e U) HUVz). }
          claim HYsubV: Y c= V.
          { exact (andER ((U :e Tx /\ V :e Tx) /\ z :e U) (Y c= V) HconjA). }
          (** show U /\\ Y = Empty using Y c= V and U /\\ V = Empty **)
          claim HUYsub: U :/\: Y c= U :/\: V.
          { let t. assume Ht: t :e U :/\: Y.
            prove t :e U :/\: V.
            claim HtU: t :e U.
            { exact (binintersectE1 U Y t Ht). }
            claim HtY: t :e Y.
            { exact (binintersectE2 U Y t Ht). }
            claim HtV: t :e V.
            { exact (HYsubV t HtY). }
            exact (binintersectI U V t HtU HtV). }
          claim HUYempty: U :/\: Y = Empty.
          { apply Empty_Subq_eq.
            let t. assume Ht: t :e U :/\: Y.
            prove False.
            claim HtUV: t :e U :/\: V.
            { exact (HUYsub t Ht). }
            claim HtEmpty: t :e Empty.
            { rewrite <- HUVempty at 1.
              exact HtUV. }
            exact (EmptyE t HtEmpty False). }
          claim HzXY: z :e X :\: Y.
          { exact (setminusI X Y z HzX HzNotY). }
          claim HUinUFam: U :e UFam.
          { apply (SepI Tx
                        (fun U0:set => exists x0:set, x0 :e X :\: Y /\ x0 :e U0 /\ U0 :/\: Y = Empty)
                        U
                        HUtx).
            witness z.
            (** conjunction is left-associative **)
            apply andI.
            + apply andI.
              * exact HzXY.
              * exact HzU.
            + exact HUYempty. }
          exact (UnionI UFam z U HzU HUinUFam). }
      (** Union UFam is open, hence X\\Y is open **)
      rewrite <- HUnionEq at 1.
      exact (topology_union_closed X Tx UFam HTx HUFamSub).
	    * (** Y = X \\ (X \\ Y) **)
	      symmetry.
	      exact (setminus_setminus_eq X Y HYsub).
Qed.

(** from 26 Lemma 26.4: separating point and compact set in Hausdorff space **)
(** FIXED: Point x should be disjoint from Y, not intersect as sets.
    Was: x :/\: Y = Empty (treating point x as a set, intersecting with Y)
    Now: x /:e Y (point x is not an element of set Y)
    The conclusion x :e U confirms x is a point, so disjointness should be x  Y. **)
Theorem Hausdorff_separate_point_compact_set : forall X Tx Y x:set,
  Hausdorff_space X Tx -> Y c= X -> compact_space Y (subspace_topology X Tx Y) -> x :e X -> x /:e Y ->
  exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ Y c= V /\ U :/\: V = Empty.
let X Tx Y x.
assume HH: Hausdorff_space X Tx.
assume HYsub: Y c= X.
assume Hcomp: compact_space Y (subspace_topology X Tx Y).
assume HxX: x :e X.
assume Hx: x /:e Y.
prove exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ Y c= V /\ U :/\: V = Empty.
set Ty := subspace_topology X Tx Y.
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }
claim Hsep: forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
  exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
{ exact (andER (topology_on X Tx)
               (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }

(** Choose V_y and U_y for each y in Y. **)
set Vof := fun y:set =>
  Eps_i (fun V:set => exists U:set, U :e Tx /\ V :e Tx /\ x :e U /\ y :e V /\ U :/\: V = Empty).
set Uof := fun y:set =>
  Eps_i (fun U:set => U :e Tx /\ x :e U /\ U :/\: (Vof y) = Empty).

claim Vof_exists: forall y:set, y :e Y ->
  exists U:set, U :e Tx /\ (Vof y) :e Tx /\ x :e U /\ y :e (Vof y) /\ U :/\: (Vof y) = Empty.
{ let y. assume HyY: y :e Y.
  claim HyX: y :e X.
  { exact (HYsub y HyY). }
  claim Hneq: x <> y.
  { assume Heq: x = y.
    apply Hx.
    rewrite Heq.
    exact HyY. }
  claim Hex: exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ y :e V /\ U :/\: V = Empty.
  { exact (Hsep x y HxX HyX Hneq). }
  apply Hex.
  let U0. assume HexV0: exists V0:set, U0 :e Tx /\ V0 :e Tx /\ x :e U0 /\ y :e V0 /\ U0 :/\: V0 = Empty.
  apply HexV0.
  let V0. assume HUV0: U0 :e Tx /\ V0 :e Tx /\ x :e U0 /\ y :e V0 /\ U0 :/\: V0 = Empty.
  claim HpV0: exists U:set, U :e Tx /\ V0 :e Tx /\ x :e U /\ y :e V0 /\ U :/\: V0 = Empty.
  { witness U0.
    exact HUV0. }
  exact (Eps_i_ax (fun V:set => exists U:set, U :e Tx /\ V :e Tx /\ x :e U /\ y :e V /\ U :/\: V = Empty) V0 HpV0). }

claim Vof_in_Tx: forall y:set, y :e Y -> (Vof y) :e Tx.
{ let y. assume HyY: y :e Y.
  apply (Vof_exists y HyY).
  let U0. assume HU0: U0 :e Tx /\ (Vof y) :e Tx /\ x :e U0 /\ y :e (Vof y) /\ U0 :/\: (Vof y) = Empty.
  (** conjunction is left-associative **)
  claim HU0A: ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y).
  { exact (andEL (((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y))
                 (U0 :/\: (Vof y) = Empty) HU0). }
  claim HU0A1: (U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0.
  { exact (andEL ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) (y :e (Vof y)) HU0A). }
  claim HU0AB: U0 :e Tx /\ (Vof y) :e Tx.
  { exact (andEL (U0 :e Tx /\ (Vof y) :e Tx) (x :e U0) HU0A1). }
  exact (andER (U0 :e Tx) ((Vof y) :e Tx) HU0AB). }

claim y_in_Vof: forall y:set, y :e Y -> y :e (Vof y).
{ let y. assume HyY: y :e Y.
  apply (Vof_exists y HyY).
  let U0. assume HU0: U0 :e Tx /\ (Vof y) :e Tx /\ x :e U0 /\ y :e (Vof y) /\ U0 :/\: (Vof y) = Empty.
  claim HU0A: ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y).
  { exact (andEL (((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y))
                 (U0 :/\: (Vof y) = Empty) HU0). }
  exact (andER ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) (y :e (Vof y)) HU0A). }

claim Uof_props: forall y:set, y :e Y ->
  (Uof y) :e Tx /\ x :e (Uof y) /\ (Uof y) :/\: (Vof y) = Empty.
{ let y. assume HyY: y :e Y.
  claim HexU: exists U0:set, U0 :e Tx /\ x :e U0 /\ U0 :/\: (Vof y) = Empty.
  { apply (Vof_exists y HyY).
	    let U0. assume HU0: U0 :e Tx /\ (Vof y) :e Tx /\ x :e U0 /\ y :e (Vof y) /\ U0 :/\: (Vof y) = Empty.
	    witness U0.
	    claim HU0A: ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y).
	    { exact (andEL (((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y))
	                   (U0 :/\: (Vof y) = Empty) HU0). }
	    claim HU0A1: (U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0.
	    { exact (andEL ((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) (y :e (Vof y)) HU0A). }
	    claim HU0AB: U0 :e Tx /\ (Vof y) :e Tx.
	    { exact (andEL (U0 :e Tx /\ (Vof y) :e Tx) (x :e U0) HU0A1). }
	    claim HU0Tx: U0 :e Tx.
	    { exact (andEL (U0 :e Tx) ((Vof y) :e Tx) HU0AB). }
	    claim HxU0: x :e U0.
	    { exact (andER (U0 :e Tx /\ (Vof y) :e Tx) (x :e U0) HU0A1). }
		    claim HU0disj: U0 :/\: (Vof y) = Empty.
		    { exact (andER (((U0 :e Tx /\ (Vof y) :e Tx) /\ x :e U0) /\ y :e (Vof y))
		                   (U0 :/\: (Vof y) = Empty) HU0). }
		    claim HU0pair: U0 :e Tx /\ x :e U0.
		    { apply andI.
		      - exact HU0Tx.
		      - exact HxU0. }
		    exact (andI (U0 :e Tx /\ x :e U0) (U0 :/\: (Vof y) = Empty) HU0pair HU0disj). }
  apply HexU.
  let U0. assume HU0: U0 :e Tx /\ x :e U0 /\ U0 :/\: (Vof y) = Empty.
  exact (Eps_i_ax (fun U:set => U :e Tx /\ x :e U /\ U :/\: (Vof y) = Empty) U0 HU0). }

(** Finite open cover of Y by the ambient opens Vof y. **)
set VFam := {Vof y|y :e Y}.
claim HVFamSub: VFam c= Tx.
{ let V. assume HV: V :e VFam.
  apply (ReplE_impred Y (fun y0:set => Vof y0) V HV).
  let y. assume HyY: y :e Y.
  assume HVe: V = Vof y.
  rewrite HVe.
  exact (Vof_in_Tx y HyY). }
claim HYcovVFam: Y c= Union VFam.
{ let y. assume HyY: y :e Y.
  prove y :e Union VFam.
  exact (UnionI VFam y (Vof y) (y_in_Vof y HyY) (ReplI Y (fun y0:set => Vof y0) y HyY)). }

(** Use compactness of Y in the subspace topology to obtain a finite subcover from VFam. **)
claim Hcovprop: forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam.
{ exact (iffEL (compact_space Y Ty)
               (forall Fam:set, (Fam c= Tx /\ Y c= Union Fam) -> has_finite_subcover Y Tx Fam)
               (compact_subspace_via_ambient_covers X Tx Y HTx HYsub) Hcomp). }
claim Hfin: has_finite_subcover Y Tx VFam.
{ exact (Hcovprop VFam (andI (VFam c= Tx) (Y c= Union VFam) HVFamSub HYcovVFam)). }
apply Hfin.
let G. assume HG: G c= VFam /\ finite G /\ Y c= Union G.
claim HGleft: G c= VFam /\ finite G.
{ exact (andEL (G c= VFam /\ finite G) (Y c= Union G) HG). }
claim HGsub: G c= VFam.
{ exact (andEL (G c= VFam) (finite G) HGleft). }
claim HGfin: finite G.
{ exact (andER (G c= VFam) (finite G) HGleft). }
claim HGcov: Y c= Union G.
{ exact (andER (G c= VFam /\ finite G) (Y c= Union G) HG). }

(** Build the separating open sets U and V from the finite subcover G. **)
set V := Union G.
claim HGTX: G c= Tx.
{ let W. assume HW: W :e G.
  claim HWVFam: W :e VFam.
  { exact (HGsub W HW). }
  exact (HVFamSub W HWVFam). }
claim HVopen: V :e Tx.
{ exact (topology_union_closed X Tx G HTx HGTX). }
claim HYsubV: Y c= V.
{ exact HGcov. }

set pickY := fun V0:set => Eps_i (fun y0:set => y0 :e Y /\ V0 = Vof y0).
set UFam := {Uof (pickY V0)|V0 :e G}.
set U := intersection_of_family X UFam.

claim HUFamSub: UFam c= Tx.
{ let U0. assume HU0: U0 :e UFam.
  apply (ReplE_impred G (fun V0:set => Uof (pickY V0)) U0 HU0).
  let V0. assume HV0G: V0 :e G.
  assume HU0eq: U0 = Uof (pickY V0).
  rewrite HU0eq.
  claim Hpick: pickY V0 :e Y.
  { claim HV0VFam: V0 :e VFam.
    { exact (HGsub V0 HV0G). }
    apply (ReplE_impred Y (fun y0:set => Vof y0) V0 HV0VFam).
    let y0. assume Hy0Y: y0 :e Y.
    assume HV0eq: V0 = Vof y0.
    claim Hp: (y0 :e Y /\ V0 = Vof y0).
    { exact (andI (y0 :e Y) (V0 = Vof y0) Hy0Y HV0eq). }
    exact (andEL (pickY V0 :e Y) (V0 = Vof (pickY V0))
                 (Eps_i_ax (fun y:set => y :e Y /\ V0 = Vof y) y0 Hp)). }
  claim HUof: (Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)) /\ (Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty.
  { exact (Uof_props (pickY V0) Hpick). }
  claim HUof1: (Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)).
  { exact (andEL ((Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)))
                 ((Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty) HUof). }
  exact (andEL ((Uof (pickY V0)) :e Tx) (x :e (Uof (pickY V0))) HUof1). }

claim HUFamFin: finite UFam.
{ exact (Repl_finite (fun V0:set => Uof (pickY V0)) G HGfin). }
claim HUFamPow: UFam :e Power Tx.
{ exact (PowerI Tx UFam HUFamSub). }
claim HUopen: U :e Tx.
{ exact (finite_intersection_in_topology X Tx UFam HTx HUFamPow HUFamFin). }

claim HxU: x :e U.
{ prove x :e intersection_of_family X UFam.
  prove x :e {z :e X | forall T:set, T :e UFam -> z :e T}.
  apply SepI.
  - exact HxX.
  - let W. assume HW: W :e UFam.
    apply (ReplE_impred G (fun V0:set => Uof (pickY V0)) W HW).
    let V0. assume HV0G: V0 :e G.
    assume HWeq: W = Uof (pickY V0).
    rewrite HWeq.
    claim Hpick: pickY V0 :e Y.
    { claim HV0VFam: V0 :e VFam.
      { exact (HGsub V0 HV0G). }
      apply (ReplE_impred Y (fun y0:set => Vof y0) V0 HV0VFam).
      let y0. assume Hy0Y: y0 :e Y.
      assume HV0eq: V0 = Vof y0.
      claim Hp: (y0 :e Y /\ V0 = Vof y0).
      { exact (andI (y0 :e Y) (V0 = Vof y0) Hy0Y HV0eq). }
      exact (andEL (pickY V0 :e Y) (V0 = Vof (pickY V0))
                   (Eps_i_ax (fun y:set => y :e Y /\ V0 = Vof y) y0 Hp)). }
    claim HUof: (Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)) /\ (Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty.
    { exact (Uof_props (pickY V0) Hpick). }
    claim HUof1: (Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)).
    { exact (andEL ((Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)))
                   ((Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty) HUof). }
    exact (andER ((Uof (pickY V0)) :e Tx) (x :e (Uof (pickY V0))) HUof1). }

claim HUVdisj: U :/\: V = Empty.
{ apply Empty_Subq_eq.
  let z. assume Hz: z :e U :/\: V.
  prove False.
  claim HzU: z :e U.
  { exact (binintersectE1 U V z Hz). }
  claim HzV: z :e V.
  { exact (binintersectE2 U V z Hz). }
  claim HzUG: z :e Union G.
  { exact HzV. }
  apply (UnionE_impred G z HzUG).
  let V0. assume HzV0: z :e V0.
  assume HV0G: V0 :e G.
  claim HV0VFam: V0 :e VFam.
  { exact (HGsub V0 HV0G). }
  apply (ReplE_impred Y (fun y0:set => Vof y0) V0 HV0VFam).
  let y0. assume Hy0Y: y0 :e Y.
  assume HV0eq: V0 = Vof y0.
  claim Hp: y0 :e Y /\ V0 = Vof y0.
  { exact (andI (y0 :e Y) (V0 = Vof y0) Hy0Y HV0eq). }
  claim HpickY: pickY V0 :e Y /\ V0 = Vof (pickY V0).
  { exact (Eps_i_ax (fun y:set => y :e Y /\ V0 = Vof y) y0 Hp). }
  claim Hpick: pickY V0 :e Y.
  { exact (andEL (pickY V0 :e Y) (V0 = Vof (pickY V0)) HpickY). }
  claim HV0rep: V0 = Vof (pickY V0).
  { exact (andER (pickY V0 :e Y) (V0 = Vof (pickY V0)) HpickY). }
  claim HUof: (Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)) /\ (Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty.
  { exact (Uof_props (pickY V0) Hpick). }
  claim HUofdisj: (Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty.
  { exact (andER ((Uof (pickY V0)) :e Tx /\ x :e (Uof (pickY V0)))
                 ((Uof (pickY V0)) :/\: (Vof (pickY V0)) = Empty) HUof). }
  claim HzUof: z :e (Uof (pickY V0)).
  { claim Hall: forall T:set, T :e UFam -> z :e T.
    { exact (SepE2 X (fun z0:set => forall T:set, T :e UFam -> z0 :e T) z HzU). }
    apply Hall.
    exact (ReplI G (fun V1:set => Uof (pickY V1)) V0 HV0G). }
  claim HzVof: z :e (Vof (pickY V0)).
  { rewrite <- HV0rep at 1.
    exact HzV0. }
  claim HzInt: z :e (Uof (pickY V0)) :/\: (Vof (pickY V0)).
  { exact (binintersectI (Uof (pickY V0)) (Vof (pickY V0)) z HzUof HzVof). }
  claim HzEmpty: z :e Empty.
  { rewrite <- HUofdisj at 1.
    exact HzInt. }
  exact (EmptyE z HzEmpty False). }

witness U.
witness V.
prove U :e Tx /\ V :e Tx /\ x :e U /\ Y c= V /\ U :/\: V = Empty.
apply andI.
- apply andI.
  + apply andI.
    * apply andI.
      - exact HUopen.
      - exact HVopen.
    * exact HxU.
  + exact HYsubV.
- exact HUVdisj.
Qed.

(** from 26 Theorem 26.5: compactness preserved under continuous maps **) 
Definition image_of_fun : set -> set -> set := fun f X => {apply_fun f x|x :e X}.

Theorem continuous_image_compact : forall X Tx Y Ty f:set,
  compact_space X Tx -> continuous_map X Tx Y Ty f ->
  compact_space (image_of_fun f X) (subspace_topology Y Ty (image_of_fun f X)).
let X Tx Y Ty f.
assume Hcomp: compact_space X Tx.
assume Hf: continuous_map X Tx Y Ty f.
prove compact_space (image_of_fun f X) (subspace_topology Y Ty (image_of_fun f X)).
set Img := image_of_fun f X.
set Timg := subspace_topology Y Ty Img.
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam) Hcomp). }
claim HsubcoverX: forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam.
{ exact (andER (topology_on X Tx) (forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam) Hcomp). }

claim Hf_left: ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y) /\ (forall V:set, V :e Ty -> preimage_of X f V :e Tx).
{ exact Hf. }
claim Hf_mid: (topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y.
{ exact (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               Hf_left). }
claim Hf_pre: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
{ exact (andER ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               Hf_left). }
claim HtopXY: topology_on X Tx /\ topology_on Y Ty.
{ exact (andEL (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y) Hf_mid). }
claim HTy: topology_on Y Ty.
{ exact (andER (topology_on X Tx) (topology_on Y Ty) HtopXY). }
claim Hfun: function_on f X Y.
{ exact (andER (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y) Hf_mid). }

claim HImgSubY: Img c= Y.
{ let y. assume Hy: y :e Img.
  apply (ReplE_impred X (fun x0:set => apply_fun f x0) y Hy).
  let x0. assume Hx0X: x0 :e X.
  assume Heq: y = apply_fun f x0.
  rewrite Heq.
  exact (Hfun x0 Hx0X). }

claim Hprop: forall Fam:set, (Fam c= Ty /\ Img c= Union Fam) -> has_finite_subcover Img Ty Fam.
{ let Fam. assume Hcov: Fam c= Ty /\ Img c= Union Fam.
  claim HFamSub: Fam c= Ty.
  { exact (andEL (Fam c= Ty) (Img c= Union Fam) Hcov). }
  claim HImgCov: Img c= Union Fam.
  { exact (andER (Fam c= Ty) (Img c= Union Fam) Hcov). }

  set PreFam := {preimage_of X f V|V :e Fam}.

  claim HPrePow: PreFam c= Power X.
  { let W. assume HW: W :e PreFam.
    apply (ReplE_impred Fam (fun V0:set => preimage_of X f V0) W HW).
    let V0. assume HV0: V0 :e Fam.
    assume HWeq: W = preimage_of X f V0.
    rewrite HWeq.
    prove preimage_of X f V0 :e Power X.
    apply PowerI.
    let x0. assume Hx0: x0 :e preimage_of X f V0.
    apply (SepE X (fun u:set => apply_fun f u :e V0) x0 Hx0).
    assume Hx0X. assume _. exact Hx0X. }

  claim HPreOpen: forall W:set, W :e PreFam -> W :e Tx.
  { let W. assume HW: W :e PreFam.
    apply (ReplE_impred Fam (fun V0:set => preimage_of X f V0) W HW).
    let V0. assume HV0: V0 :e Fam.
    assume HWeq: W = preimage_of X f V0.
    claim HV0Ty: V0 :e Ty.
    { exact (HFamSub V0 HV0). }
    rewrite HWeq.
    exact (Hf_pre V0 HV0Ty). }

  claim HXcov: X c= Union PreFam.
  { let x0. assume Hx0X: x0 :e X.
    prove x0 :e Union PreFam.
    claim HyImg: apply_fun f x0 :e Img.
    { exact (ReplI X (fun x1:set => apply_fun f x1) x0 Hx0X). }
    claim HyUnion: apply_fun f x0 :e Union Fam.
    { exact (HImgCov (apply_fun f x0) HyImg). }
    apply (UnionE_impred Fam (apply_fun f x0) HyUnion).
    let V0. assume HyV0: apply_fun f x0 :e V0.
    assume HV0: V0 :e Fam.
    claim Hx0Pre: x0 :e preimage_of X f V0.
    { prove x0 :e {u :e X | apply_fun f u :e V0}.
      apply SepI.
      - exact Hx0X.
      - exact HyV0. }
    exact (UnionI PreFam x0 (preimage_of X f V0) Hx0Pre
                 (ReplI Fam (fun V1:set => preimage_of X f V1) V0 HV0)). }

  claim HopenCov: open_cover_of X Tx PreFam.
  { prove topology_on X Tx /\ PreFam c= Power X /\ X c= Union PreFam /\ (forall U:set, U :e PreFam -> U :e Tx).
    apply andI.
    - (** left-associative: ((A /\ B) /\ C) **)
      apply andI.
      + apply andI.
        * exact HTx.
        * exact HPrePow.
      + exact HXcov.
    - exact HPreOpen. }

  claim HfinPre: has_finite_subcover X Tx PreFam.
  { exact (HsubcoverX PreFam HopenCov). }

  apply HfinPre.
  let Gpre. assume HGpre: Gpre c= PreFam /\ finite Gpre /\ X c= Union Gpre.
  claim HGpreLeft: Gpre c= PreFam /\ finite Gpre.
  { exact (andEL (Gpre c= PreFam /\ finite Gpre) (X c= Union Gpre) HGpre). }
  claim HGpreSub: Gpre c= PreFam.
  { exact (andEL (Gpre c= PreFam) (finite Gpre) HGpreLeft). }
  claim HGpreFin: finite Gpre.
  { exact (andER (Gpre c= PreFam) (finite Gpre) HGpreLeft). }
  claim HXcovGpre: X c= Union Gpre.
  { exact (andER (Gpre c= PreFam /\ finite Gpre) (X c= Union Gpre) HGpre). }

  set pickV := fun W:set => Eps_i (fun V0:set => V0 :e Fam /\ W = preimage_of X f V0).
  set G := {pickV W|W :e Gpre}.

  claim HGsubFam: G c= Fam.
  { let V0. assume HV0: V0 :e G.
    apply (ReplE_impred Gpre (fun W0:set => pickV W0) V0 HV0).
    let W0. assume HW0G: W0 :e Gpre.
    assume HV0eq: V0 = pickV W0.
    claim HW0Pre: W0 :e PreFam.
    { exact (HGpreSub W0 HW0G). }
    claim Hex: exists V1:set, V1 :e Fam /\ W0 = preimage_of X f V1.
    { apply (ReplE_impred Fam (fun V2:set => preimage_of X f V2) W0 HW0Pre).
      let V2. assume HV2: V2 :e Fam.
      assume HW0eq2: W0 = preimage_of X f V2.
      witness V2.
      exact (andI (V2 :e Fam) (W0 = preimage_of X f V2) HV2 HW0eq2). }
    apply Hex.
    let V1. assume HV1: V1 :e Fam /\ W0 = preimage_of X f V1.
    claim Hpick: pickV W0 :e Fam /\ W0 = preimage_of X f (pickV W0).
    { exact (Eps_i_ax (fun V:set => V :e Fam /\ W0 = preimage_of X f V) V1 HV1). }
    rewrite HV0eq.
    exact (andEL (pickV W0 :e Fam) (W0 = preimage_of X f (pickV W0)) Hpick). }

  claim HGfin: finite G.
  { exact (Repl_finite (fun W0:set => pickV W0) Gpre HGpreFin). }

  claim HImgCovG: Img c= Union G.
  { let y. assume Hy: y :e Img.
    prove y :e Union G.
    apply (ReplE_impred X (fun x0:set => apply_fun f x0) y Hy).
    let x0. assume Hx0X: x0 :e X.
    assume Heq: y = apply_fun f x0.
    claim Hx0UG: x0 :e Union Gpre.
    { exact (HXcovGpre x0 Hx0X). }
    apply (UnionE_impred Gpre x0 Hx0UG).
    let W0. assume Hx0W0: x0 :e W0.
    assume HW0G: W0 :e Gpre.
    claim HW0Pre: W0 :e PreFam.
    { exact (HGpreSub W0 HW0G). }
    claim Hex: exists V1:set, V1 :e Fam /\ W0 = preimage_of X f V1.
    { apply (ReplE_impred Fam (fun V2:set => preimage_of X f V2) W0 HW0Pre).
      let V2. assume HV2: V2 :e Fam.
      assume HW0eq2: W0 = preimage_of X f V2.
      witness V2.
      exact (andI (V2 :e Fam) (W0 = preimage_of X f V2) HV2 HW0eq2). }
    apply Hex.
    let V1. assume HV1: V1 :e Fam /\ W0 = preimage_of X f V1.
    claim Hpick: pickV W0 :e Fam /\ W0 = preimage_of X f (pickV W0).
    { exact (Eps_i_ax (fun V:set => V :e Fam /\ W0 = preimage_of X f V) V1 HV1). }
    claim HW0eq: W0 = preimage_of X f (pickV W0).
    { exact (andER (pickV W0 :e Fam) (W0 = preimage_of X f (pickV W0)) Hpick). }
    claim Hx0Pre: x0 :e preimage_of X f (pickV W0).
    { rewrite <- HW0eq at 1.
      exact Hx0W0. }
    claim HyV: apply_fun f x0 :e pickV W0.
    { apply (SepE X (fun u:set => apply_fun f u :e pickV W0) x0 Hx0Pre).
      assume _. assume Hy0. exact Hy0. }
    rewrite Heq.
    exact (UnionI G (apply_fun f x0) (pickV W0) HyV (ReplI Gpre (fun W1:set => pickV W1) W0 HW0G)). }

  exact (has_finite_subcoverI Img Ty Fam G (andI (G c= Fam /\ finite G) (Img c= Union G)
                                                 (andI (G c= Fam) (finite G) HGsubFam HGfin)
                                                 HImgCovG)). }

exact (iffER (compact_space Img Timg)
             (forall Fam:set, (Fam c= Ty /\ Img c= Union Fam) -> has_finite_subcover Img Ty Fam)
             (compact_subspace_via_ambient_covers Y Ty Img HTy HImgSubY)
             Hprop).
Qed.

(** from 26: tube lemma used in product compactness **)
(** LATEX VERSION: Tube lemma: in XY with X compact, a neighborhood of {x0}Y contains some UY. **)
(** FIXED: Tube lemma should state U{y}  N for all y, not Uy  N.
    Was: setprod U y :e N (Cartesian product Uy as element)
    Now: setprod U {y} c= N (Cartesian product U{y} as subset)
    The tube lemma says UY  N, which is equivalent to yY. U{y}  N. **)
Theorem tube_lemma : forall X Tx Y Ty:set,
  topology_on X Tx -> topology_on Y Ty ->
  compact_space Y Ty ->
  forall x0:set, x0 :e X ->
  forall N:set, N :e product_topology X Tx Y Ty /\ setprod {x0} Y c= N ->
    exists U:set, U :e Tx /\ x0 :e U /\
      setprod U Y c= N.
let X Tx Y Ty.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
assume Hcomp: compact_space Y Ty.
let x0.
assume Hx0: x0 :e X.
let N.
assume HN: N :e product_topology X Tx Y Ty /\ setprod {x0} Y c= N.
prove exists U:set, U :e Tx /\ x0 :e U /\ setprod U Y c= N.
(** Use that N is open in the topology generated by the product basis, then cover Y by suitable open slices. **)
set B := product_subbasis X Tx Y Ty.
claim HBasis: basis_on (setprod X Y) B.
{ exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
claim HNtop: N :e generated_topology (setprod X Y) B.
{ exact (andEL (N :e product_topology X Tx Y Ty) (setprod {x0} Y c= N) HN). }
claim HNsub: setprod {x0} Y c= N.
{ exact (andER (N :e product_topology X Tx Y Ty) (setprod {x0} Y c= N) HN). }
claim HNrefine: forall p :e N, exists b :e B, p :e b /\ b c= N.
{ exact (SepE2 (Power (setprod X Y))
               (fun U0:set => forall x :e U0, exists b :e B, x :e b /\ b c= U0)
               N HNtop). }
set VFam := {V :e Ty|exists U:set, U :e Tx /\ x0 :e U /\ setprod U V c= N}.
claim HVFamSubTy: VFam c= Ty.
{ let V. assume HV: V :e VFam.
  exact (SepE1 Ty (fun V0:set => exists U:set, U :e Tx /\ x0 :e U /\ setprod U V0 c= N) V HV). }
claim HtopY: topology_on Y Ty.
{ exact (andEL (topology_on Y Ty) (forall Fam:set, open_cover_of Y Ty Fam -> has_finite_subcover Y Ty Fam) Hcomp). }
claim HTyPow: Ty c= Power Y.
{ exact (topology_subset_axiom Y Ty HtopY). }
claim HVFamPowY: VFam c= Power Y.
{ let V. assume HV: V :e VFam.
  claim HVTy: V :e Ty.
  { exact (HVFamSubTy V HV). }
  exact (HTyPow V HVTy). }
claim HYcov: Y c= Union VFam.
{ let y. assume Hy: y :e Y.
  prove y :e Union VFam.
  set p := (x0,y).
  claim HpXY: p :e setprod {x0} Y.
  { exact (tuple_2_setprod {x0} Y x0 (SingI x0) y Hy). }
  claim HpN: p :e N.
  { exact (HNsub p HpXY). }
  claim Hrect: exists b :e B, p :e b /\ b c= N.
  { exact (HNrefine p HpN). }
  apply Hrect.
  let b. assume Hbpair.
  claim HbB: b :e B.
  { exact (andEL (b :e B) (p :e b /\ b c= N) Hbpair). }
  claim Hbprop: p :e b /\ b c= N.
  { exact (andER (b :e B) (p :e b /\ b c= N) Hbpair). }
  claim Hpb: p :e b.
  { exact (andEL (p :e b) (b c= N) Hbprop). }
  claim HbsubN: b c= N.
  { exact (andER (p :e b) (b c= N) Hbprop). }
  apply (famunionE_impred Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) b HbB).
  let U0. assume HU0Tx: U0 :e Tx.
  assume HbIn: b :e {rectangle_set U0 V0|V0 :e Ty}.
  apply (ReplE_impred Ty (fun V0:set => rectangle_set U0 V0) b HbIn).
  let V0. assume HV0Ty: V0 :e Ty.
  assume HbEq: b = rectangle_set U0 V0.
  claim HpUV: p :e setprod U0 V0.
  { prove p :e rectangle_set U0 V0.
    rewrite <- HbEq at 1.
    exact Hpb. }
  claim HpXY0: p :e setprod {x0} {y}.
  { exact (tuple_2_setprod {x0} {y} x0 (SingI x0) y (SingI y)). }
  claim Hcoords: x0 :e U0 /\ y :e V0.
  { exact (setprod_coords_in x0 y U0 V0 p HpXY0 HpUV). }
  claim Hx0U0: x0 :e U0.
  { exact (andEL (x0 :e U0) (y :e V0) Hcoords). }
  claim HyV0: y :e V0.
  { exact (andER (x0 :e U0) (y :e V0) Hcoords). }
  claim HrectSub: setprod U0 V0 c= N.
  { rewrite <- HbEq at 1.
    exact HbsubN. }
  claim HV0Fam: V0 :e VFam.
  { apply (SepI Ty (fun V1:set => exists U1:set, U1 :e Tx /\ x0 :e U1 /\ setprod U1 V1 c= N) V0 HV0Ty).
    witness U0.
    exact (andI (U0 :e Tx /\ x0 :e U0) (setprod U0 V0 c= N)
                (andI (U0 :e Tx) (x0 :e U0) HU0Tx Hx0U0)
                HrectSub). }
  exact (UnionI VFam y V0 HyV0 HV0Fam). }
claim HVFamCover: open_cover_of Y Ty VFam.
{ prove topology_on Y Ty /\ VFam c= Power Y /\ Y c= Union VFam /\ (forall U:set, U :e VFam -> U :e Ty).
  (** conjunction is left-associative: (((A /\ B) /\ C) /\ D) **)
  apply andI.
  - apply andI.
    + apply andI.
      * exact HtopY.
      * exact HVFamPowY.
    + exact HYcov.
  - let V. assume HV: V :e VFam.
    exact (HVFamSubTy V HV). }
claim Hfin: has_finite_subcover Y Ty VFam.
{ exact (Heine_Borel_subcover Y Ty VFam Hcomp HVFamCover). }
apply Hfin.
let G. assume HGtriple: G c= VFam /\ finite G /\ Y c= Union G.
set pickU := fun V:set => Eps_i (fun U0:set => U0 :e Tx /\ x0 :e U0 /\ setprod U0 V c= N).
claim HpickU: forall V:set, V :e VFam -> pickU V :e Tx /\ x0 :e pickU V /\ setprod (pickU V) V c= N.
{ let V. assume HV: V :e VFam.
  claim Hex: exists U0:set, U0 :e Tx /\ x0 :e U0 /\ setprod U0 V c= N.
  { exact (SepE2 Ty (fun V0:set => exists U0:set, U0 :e Tx /\ x0 :e U0 /\ setprod U0 V0 c= N) V HV). }
  apply Hex.
  let U0. assume HU0: U0 :e Tx /\ x0 :e U0 /\ setprod U0 V c= N.
  claim Hax: pickU V :e Tx /\ x0 :e pickU V /\ setprod (pickU V) V c= N.
  { exact (Eps_i_ax (fun U1:set => U1 :e Tx /\ x0 :e U1 /\ setprod U1 V c= N) U0 HU0). }
  exact Hax. }
claim HGsub: G c= VFam.
{ exact (andEL (G c= VFam) (finite G) (andEL (G c= VFam /\ finite G) (Y c= Union G) HGtriple)). }
claim HGfin: finite G.
{ exact (andER (G c= VFam) (finite G) (andEL (G c= VFam /\ finite G) (Y c= Union G) HGtriple)). }
claim HYcovG: Y c= Union G.
{ exact (andER (G c= VFam /\ finite G) (Y c= Union G) HGtriple). }
set UFam := {pickU V|V :e G}.
claim HUFamFin: finite UFam.
{ exact (Repl_finite (fun V:set => pickU V) G HGfin). }
claim HUFamPow: UFam :e Power Tx.
{ apply PowerI Tx UFam.
  let U0. assume HU0: U0 :e UFam.
  prove U0 :e Tx.
  apply (ReplE_impred G (fun V0:set => pickU V0) U0 HU0).
  let V0. assume HV0G: V0 :e G.
  assume HU0Eq: U0 = pickU V0.
  claim HV0Fam: V0 :e VFam.
  { exact (HGsub V0 HV0G). }
  claim HU0Prop: pickU V0 :e Tx /\ x0 :e pickU V0 /\ setprod (pickU V0) V0 c= N.
  { exact (HpickU V0 HV0Fam). }
  claim HU0AB: pickU V0 :e Tx /\ x0 :e pickU V0.
  { exact (andEL (pickU V0 :e Tx /\ x0 :e pickU V0) (setprod (pickU V0) V0 c= N) HU0Prop). }
  claim HU0Tx: pickU V0 :e Tx.
  { exact (andEL (pickU V0 :e Tx) (x0 :e pickU V0) HU0AB). }
  rewrite HU0Eq.
  exact HU0Tx. }
set U := intersection_of_family X UFam.
claim HUinTx: U :e Tx.
{ exact (finite_intersection_in_topology X Tx UFam HTx HUFamPow HUFamFin). }
claim Hx0U: x0 :e U.
{ prove x0 :e intersection_of_family X UFam.
  claim Hall: forall W:set, W :e UFam -> x0 :e W.
  { let W. assume HW: W :e UFam.
    prove x0 :e W.
    apply (ReplE_impred G (fun V0:set => pickU V0) W HW).
    let V0. assume HV0G: V0 :e G.
    assume HWEq: W = pickU V0.
    claim HV0Fam: V0 :e VFam.
    { exact (HGsub V0 HV0G). }
    claim HWProp: pickU V0 :e Tx /\ x0 :e pickU V0 /\ setprod (pickU V0) V0 c= N.
    { exact (HpickU V0 HV0Fam). }
    claim HWPropAB: pickU V0 :e Tx /\ x0 :e pickU V0.
    { exact (andEL (pickU V0 :e Tx /\ x0 :e pickU V0) (setprod (pickU V0) V0 c= N) HWProp). }
    claim Hx0Pick: x0 :e pickU V0.
    { exact (andER (pickU V0 :e Tx) (x0 :e pickU V0) HWPropAB). }
    rewrite HWEq.
    exact Hx0Pick. }
  exact (SepI X (fun x:set => forall W:set, W :e UFam -> x :e W) x0 Hx0 Hall). }
claim HUsubN: setprod U Y c= N.
{ let p. assume Hp: p :e setprod U Y.
  prove p :e N.
  claim Hp0: p 0 :e U.
  { exact (ap0_Sigma U (fun u:set => Y) p Hp). }
  claim Hp1: p 1 :e Y.
  { exact (ap1_Sigma U (fun u:set => Y) p Hp). }
  claim HpEta: p = (p 0, p 1).
  { exact (setprod_eta U Y p Hp). }
  claim Hp1InUnion: p 1 :e Union G.
  { exact (HYcovG (p 1) Hp1). }
  apply (UnionE_impred G (p 1) Hp1InUnion).
  let V0. assume Hp1V0: p 1 :e V0.
  assume HV0G: V0 :e G.
  claim HV0Fam: V0 :e VFam.
  { exact (HGsub V0 HV0G). }
  claim HV0Ty: V0 :e Ty.
  { exact (HVFamSubTy V0 HV0Fam). }
  claim Hpick: pickU V0 :e Tx /\ x0 :e pickU V0 /\ setprod (pickU V0) V0 c= N.
  { exact (HpickU V0 HV0Fam). }
  claim HrectSubN: setprod (pickU V0) V0 c= N.
  { exact (andER (pickU V0 :e Tx /\ x0 :e pickU V0) (setprod (pickU V0) V0 c= N) Hpick). }
  claim Hp0Pick: p 0 :e pickU V0.
  { claim Hp0All: forall W:set, W :e UFam -> p 0 :e W.
    { exact (SepE2 X (fun x:set => forall W:set, W :e UFam -> x :e W) (p 0) Hp0). }
    claim Hmem: pickU V0 :e UFam.
    { exact (ReplI G (fun V1:set => pickU V1) V0 HV0G). }
    exact (Hp0All (pickU V0) Hmem). }
  claim HpairIn: (p 0, p 1) :e setprod (pickU V0) V0.
  { exact (tuple_2_setprod (pickU V0) V0 (p 0) Hp0Pick (p 1) Hp1V0). }
  claim HpN: (p 0, p 1) :e N.
  { exact (HrectSubN (p 0, p 1) HpairIn). }
  rewrite HpEta.
  exact HpN. }
witness U.
exact (andI (U :e Tx /\ x0 :e U) (setprod U Y c= N)
            (andI (U :e Tx) (x0 :e U) HUinTx Hx0U)
            HUsubN).
Qed.

(** from 26 Theorem 26.6: compact-to-Hausdorff bijection is a homeomorphism **) 
(** LATEX VERSION: A continuous bijection from compact space to Hausdorff space is a homeomorphism. **)
Definition bijection : set -> set -> set -> prop := fun X Y f =>
  function_on f X Y /\
  (forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun f x = y /\
     (forall x':set, x' :e X -> apply_fun f x' = y -> x' = x)).

Definition inv_fun_graph : set -> set -> set -> set := fun X f Y =>
  {(y, inv X (fun x:set => apply_fun f x) y)|y :e Y}.

Theorem inv_fun_graph_apply : forall X Y f y:set,
  y :e Y -> apply_fun (inv_fun_graph X f Y) y = inv X (fun x:set => apply_fun f x) y.
let X Y f y.
assume Hy: y :e Y.
prove apply_fun (inv_fun_graph X f Y) y = inv X (fun x:set => apply_fun f x) y.
prove apply_fun {(y0, inv X (fun x:set => apply_fun f x) y0) | y0 :e Y} y = inv X (fun x:set => apply_fun f x) y.
prove Eps_i (fun z => (y,z) :e {(y0, inv X (fun x:set => apply_fun f x) y0) | y0 :e Y}) =
      inv X (fun x:set => apply_fun f x) y.
claim H1: (y, inv X (fun x:set => apply_fun f x) y) :e {(y0, inv X (fun x:set => apply_fun f x) y0) | y0 :e Y}.
{ exact (ReplI Y (fun y0:set => (y0, inv X (fun x:set => apply_fun f x) y0)) y Hy). }
claim H2: (y, Eps_i (fun z => (y,z) :e {(y0, inv X (fun x:set => apply_fun f x) y0) | y0 :e Y})) :e
          {(y0, inv X (fun x:set => apply_fun f x) y0) | y0 :e Y}.
{ exact (Eps_i_ax (fun z => (y,z) :e {(y0, inv X (fun x:set => apply_fun f x) y0) | y0 :e Y})
                  (inv X (fun x:set => apply_fun f x) y) H1). }
apply (ReplE_impred Y (fun y0:set => (y0, inv X (fun x:set => apply_fun f x) y0))
                    (y, Eps_i (fun z => (y,z) :e {(y0, inv X (fun x:set => apply_fun f x) y0) | y0 :e Y})) H2).
let y0.
assume Hy0: y0 :e Y.
assume Heq: (y, Eps_i (fun z => (y,z) :e {(y1, inv X (fun x:set => apply_fun f x) y1) | y1 :e Y})) =
            (y0, inv X (fun x:set => apply_fun f x) y0).
claim Hy_eq: y = y0.
{ rewrite <- (tuple_2_0_eq y (Eps_i (fun z => (y,z) :e {(y1, inv X (fun x:set => apply_fun f x) y1) | y1 :e Y}))).
  rewrite <- (tuple_2_0_eq y0 (inv X (fun x:set => apply_fun f x) y0)).
  rewrite Heq.
  reflexivity. }
claim Hz_eq: Eps_i (fun z => (y,z) :e {(y1, inv X (fun x:set => apply_fun f x) y1) | y1 :e Y}) =
             inv X (fun x:set => apply_fun f x) y0.
{ rewrite <- (tuple_2_1_eq y (Eps_i (fun z => (y,z) :e {(y1, inv X (fun x:set => apply_fun f x) y1) | y1 :e Y}))).
  rewrite <- (tuple_2_1_eq y0 (inv X (fun x:set => apply_fun f x) y0)).
  rewrite Heq.
  reflexivity. }
rewrite Hz_eq.
rewrite <- Hy_eq.
reflexivity.
Qed.

Theorem bijection_surj : forall X Y f y:set,
  bijection X Y f -> y :e Y -> exists x:set, x :e X /\ apply_fun f x = y.
let X Y f y.
assume Hbij: bijection X Y f.
assume Hy: y :e Y.
apply Hbij.
assume Hfun: function_on f X Y.
assume Huniq.
apply (Huniq y Hy).
let x.
assume Hx: x :e X /\ apply_fun f x = y /\ (forall x':set, x' :e X -> apply_fun f x' = y -> x' = x).
witness x.
claim Hx0: x :e X /\ apply_fun f x = y.
{ exact (andEL (x :e X /\ apply_fun f x = y)
               (forall x':set, x' :e X -> apply_fun f x' = y -> x' = x) Hx). }
exact Hx0.
Qed.

Theorem bijection_inj : forall X Y f u v:set,
  bijection X Y f -> u :e X -> v :e X -> apply_fun f u = apply_fun f v -> u = v.
let X Y f u v.
assume Hbij: bijection X Y f.
assume HuX: u :e X.
assume HvX: v :e X.
assume Heq: apply_fun f u = apply_fun f v.
apply Hbij.
assume Hfun: function_on f X Y.
assume Huniq.
claim HyY: apply_fun f u :e Y.
{ exact (Hfun u HuX). }
apply (Huniq (apply_fun f u) HyY).
let x.
assume Hx: x :e X /\ apply_fun f x = apply_fun f u /\
           (forall x':set, x' :e X -> apply_fun f x' = apply_fun f u -> x' = x).
claim Hxuniq: forall x':set, x' :e X -> apply_fun f x' = apply_fun f u -> x' = x.
{ exact (andER (x :e X /\ apply_fun f x = apply_fun f u)
               (forall x':set, x' :e X -> apply_fun f x' = apply_fun f u -> x' = x)
               Hx). }
claim Hu: u = x.
{ apply (Hxuniq u HuX).
  reflexivity. }
claim Hv: v = x.
{ apply (Hxuniq v HvX).
  symmetry.
  exact Heq. }
rewrite Hu.
rewrite Hv.
reflexivity.
Qed.

Theorem inv_fun_graph_right_inverse : forall X Y f y:set,
  bijection X Y f -> y :e Y -> apply_fun f (apply_fun (inv_fun_graph X f Y) y) = y.
let X Y f y.
assume Hbij: bijection X Y f.
assume Hy: y :e Y.
prove apply_fun f (apply_fun (inv_fun_graph X f Y) y) = y.
claim Hginv: apply_fun (inv_fun_graph X f Y) y = inv X (fun u:set => apply_fun f u) y.
{ exact (inv_fun_graph_apply X Y f y Hy). }
rewrite Hginv.
claim Hsurj: forall w :e Y, exists u :e X, apply_fun f u = w.
{ let w. assume Hw: w :e Y.
  claim Hex: exists u:set, u :e X /\ apply_fun f u = w.
  { exact (bijection_surj X Y f w Hbij Hw). }
  exact Hex. }
claim Hpair: inv X (fun u:set => apply_fun f u) y :e X /\
             apply_fun f (inv X (fun u:set => apply_fun f u) y) = y.
{ exact (surj_rinv X Y (fun u:set => apply_fun f u) Hsurj y Hy). }
exact (andER (inv X (fun u:set => apply_fun f u) y :e X)
             (apply_fun f (inv X (fun u:set => apply_fun f u) y) = y)
             Hpair).
Qed.

Theorem inv_fun_graph_left_inverse : forall X Y f x:set,
  bijection X Y f -> x :e X -> apply_fun (inv_fun_graph X f Y) (apply_fun f x) = x.
let X Y f x.
assume Hbij: bijection X Y f.
assume Hx: x :e X.
prove apply_fun (inv_fun_graph X f Y) (apply_fun f x) = x.
claim Hfun: function_on f X Y.
{ exact (andEL (function_on f X Y)
               (forall y:set, y :e Y -> exists x0:set, x0 :e X /\ apply_fun f x0 = y /\ (forall x':set, x' :e X -> apply_fun f x' = y -> x' = x0))
               Hbij). }
claim HyY: apply_fun f x :e Y.
{ exact (Hfun x Hx). }
claim Hginv: apply_fun (inv_fun_graph X f Y) (apply_fun f x) =
             inv X (fun u:set => apply_fun f u) (apply_fun f x).
{ exact (inv_fun_graph_apply X Y f (apply_fun f x) HyY). }
rewrite Hginv.
claim Hinj: forall u v :e X, apply_fun f u = apply_fun f v -> u = v.
{ let u. assume Hu: u :e X.
  let v. assume Hv: v :e X.
  assume Heq.
  exact (bijection_inj X Y f u v Hbij Hu Hv Heq). }
exact (inj_linv X (fun u:set => apply_fun f u) Hinj x Hx).
Qed.

Theorem inv_fun_graph_preimage_eq_image : forall X Y f A:set,
  bijection X Y f -> A c= X ->
  preimage_of Y (inv_fun_graph X f Y) A = image_of_fun f A.
let X Y f A.
assume Hbij: bijection X Y f.
assume HA: A c= X.
set g := inv_fun_graph X f Y.
apply set_ext.
- let y. assume Hy: y :e preimage_of Y g A.
  prove y :e image_of_fun f A.
  claim HyY: y :e Y.
  { exact (SepE1 Y (fun u:set => apply_fun g u :e A) y Hy). }
  claim HgyA: apply_fun g y :e A.
  { exact (SepE2 Y (fun u:set => apply_fun g u :e A) y Hy). }
  claim Heq: apply_fun f (apply_fun g y) = y.
  { exact (inv_fun_graph_right_inverse X Y f y Hbij HyY). }
  claim HyImg: apply_fun f (apply_fun g y) :e image_of_fun f A.
  { exact (ReplI A (fun x0:set => apply_fun f x0) (apply_fun g y) HgyA). }
  rewrite <- Heq.
  exact HyImg.
- let y. assume Hy: y :e image_of_fun f A.
  prove y :e preimage_of Y g A.
  apply (ReplE_impred A (fun x0:set => apply_fun f x0) y Hy).
  let x.
  assume HxA: x :e A.
  assume Heq: y = apply_fun f x.
  prove y :e {u :e Y | apply_fun g u :e A}.
  apply SepI.
  + claim HxX: x :e X.
    { exact (HA x HxA). }
    claim Hfun: function_on f X Y.
    { exact (andEL (function_on f X Y)
                   (forall y0:set, y0 :e Y -> exists x0:set, x0 :e X /\ apply_fun f x0 = y0 /\ (forall x':set, x' :e X -> apply_fun f x' = y0 -> x' = x0))
                   Hbij). }
    rewrite Heq.
    exact (Hfun x HxX).
  + prove apply_fun g y :e A.
    rewrite Heq.
    claim HxX: x :e X.
    { exact (HA x HxA). }
    claim Hinv: apply_fun g (apply_fun f x) = x.
    { exact (inv_fun_graph_left_inverse X Y f x Hbij HxX). }
    rewrite Hinv.
    exact HxA.
Qed.

Definition Abs : set -> set := abs_SNo.

Theorem compact_to_Hausdorff_inverse_continuous : forall X Tx Y Ty f:set,
  compact_space X Tx -> Hausdorff_space Y Ty ->
  continuous_map X Tx Y Ty f -> bijection X Y f ->
  continuous_map Y Ty X Tx (inv_fun_graph X f Y).
let X Tx Y Ty f.
assume Hcomp: compact_space X Tx.
assume HH: Hausdorff_space Y Ty.
assume Hcont: continuous_map X Tx Y Ty f.
assume Hbij: bijection X Y f.
set g := inv_fun_graph X f Y.
prove continuous_map Y Ty X Tx g.
prove topology_on Y Ty /\ topology_on X Tx /\ function_on g Y X /\
      forall V:set, V :e Tx -> preimage_of Y g V :e Ty.
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam) Hcomp). }
claim HTy: topology_on Y Ty.
{ exact (andEL (topology_on Y Ty)
               (forall x1 x2:set, x1 :e Y -> x2 :e Y -> x1 <> x2 ->
                 exists U V:set, U :e Ty /\ V :e Ty /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }
claim Hfun: function_on f X Y.
{ exact (andEL (function_on f X Y)
               (forall y:set, y :e Y -> exists x0:set, x0 :e X /\ apply_fun f x0 = y /\ (forall x':set, x' :e X -> apply_fun f x' = y -> x' = x0))
               Hbij). }
claim Hgfun: function_on g Y X.
{ let y. assume Hy: y :e Y.
  prove apply_fun g y :e X.
  claim Hginv: apply_fun g y = inv X (fun u:set => apply_fun f u) y.
  { exact (inv_fun_graph_apply X Y f y Hy). }
  rewrite Hginv.
  claim Hsurj: forall w :e Y, exists u :e X, apply_fun f u = w.
  { let w. assume Hw: w :e Y.
    claim Hex: exists u:set, u :e X /\ apply_fun f u = w.
    { exact (bijection_surj X Y f w Hbij Hw). }
    exact Hex. }
  claim Hpair: inv X (fun u:set => apply_fun f u) y :e X /\
               apply_fun f (inv X (fun u:set => apply_fun f u) y) = y.
  { exact (surj_rinv X Y (fun u:set => apply_fun f u) Hsurj y Hy). }
  exact (andEL (inv X (fun u:set => apply_fun f u) y :e X)
               (apply_fun f (inv X (fun u:set => apply_fun f u) y) = y)
               Hpair). }

apply andI.
- apply andI.
  + apply andI.
    * exact HTy.
    * exact HTx.
  + exact Hgfun.
- let V. assume HV: V :e Tx.
  prove preimage_of Y g V :e Ty.
  set C := X :\: V.
  claim HCclosed: closed_in X Tx C.
  { exact (closed_of_open_complement X Tx V HTx HV). }
  claim HCsub: C c= X.
  { exact (closed_in_subset X Tx C HCclosed). }
  claim HpreCeq: preimage_of Y g C = image_of_fun f C.
  { exact (inv_fun_graph_preimage_eq_image X Y f C Hbij HCsub). }
  claim HimgSubY: image_of_fun f C c= Y.
  { let y. assume Hy: y :e image_of_fun f C.
    apply (ReplE_impred C (fun x0:set => apply_fun f x0) y Hy).
    let x0. assume Hx0C: x0 :e C.
    assume Heq: y = apply_fun f x0.
    claim Hx0X: x0 :e X.
    { exact (HCsub x0 Hx0C). }
    rewrite Heq.
    exact (Hfun x0 Hx0X). }
  claim HcompC: compact_space C (subspace_topology X Tx C).
  { exact (closed_subspace_compact X Tx C Hcomp HCclosed). }
  claim HcontC: continuous_map C (subspace_topology X Tx C) Y Ty f.
  { exact (continuous_on_subspace X Tx Y Ty f C HTx HCsub Hcont). }
  claim HimgComp: compact_space (image_of_fun f C) (subspace_topology Y Ty (image_of_fun f C)).
  { exact (continuous_image_compact C (subspace_topology X Tx C) Y Ty f HcompC HcontC). }
  claim HimgClosed: closed_in Y Ty (image_of_fun f C).
  { exact (compact_subspace_in_Hausdorff_closed Y Ty (image_of_fun f C) HH HimgSubY HimgComp). }
  claim HpreClosed: closed_in Y Ty (preimage_of Y g C).
  { rewrite HpreCeq at 1.
    exact HimgClosed. }
  claim Hop: open_in Y Ty (Y :\: preimage_of Y g C).
  { exact (open_of_closed_complement Y Ty (preimage_of Y g C) HpreClosed). }
  claim HopTy: (Y :\: preimage_of Y g C) :e Ty.
  { exact (andER (topology_on Y Ty) ((Y :\: preimage_of Y g C) :e Ty) Hop). }
  claim HpreEq: preimage_of Y g V = Y :\: preimage_of Y g C.
  { apply set_ext.
    - let y. assume Hy: y :e preimage_of Y g V.
      prove y :e Y :\: preimage_of Y g C.
      claim HyY: y :e Y.
      { exact (SepE1 Y (fun u:set => apply_fun g u :e V) y Hy). }
      claim HgyV: apply_fun g y :e V.
      { exact (SepE2 Y (fun u:set => apply_fun g u :e V) y Hy). }
      apply setminusI.
      + exact HyY.
      + assume HyC: y :e preimage_of Y g C.
        claim HgyC: apply_fun g y :e C.
        { exact (SepE2 Y (fun u:set => apply_fun g u :e C) y HyC). }
        apply (setminusE X V (apply_fun g y) HgyC).
        assume _. assume HnotV.
        exact (HnotV HgyV).
    - let y. assume Hy: y :e Y :\: preimage_of Y g C.
      prove y :e preimage_of Y g V.
      apply (setminusE Y (preimage_of Y g C) y Hy).
      assume HyY: y :e Y.
      assume HyNot: y /:e preimage_of Y g C.
      prove y :e {u :e Y | apply_fun g u :e V}.
      apply SepI.
      + exact HyY.
      + prove apply_fun g y :e V.
        claim HgyX: apply_fun g y :e X.
        { exact (Hgfun y HyY). }
        apply (xm (apply_fun g y :e V)).
        - assume HVin. exact HVin.
        - assume HnotV: ~(apply_fun g y :e V).
          claim HnotVin: apply_fun g y /:e V.
          { assume H0. exact (HnotV H0). }
          claim HgyC: apply_fun g y :e C.
          { exact (setminusI X V (apply_fun g y) HgyX HnotVin). }
          claim HyC: y :e preimage_of Y g C.
          { prove y :e {u :e Y | apply_fun g u :e C}.
            apply SepI.
            - exact HyY.
            - exact HgyC. }
          apply FalseE.
          exact (HyNot HyC). }
  rewrite HpreEq.
  exact HopTy.
Qed.

Theorem compact_to_Hausdorff_bijection_homeomorphism : forall X Tx Y Ty f:set,
  compact_space X Tx -> Hausdorff_space Y Ty ->
  continuous_map X Tx Y Ty f -> bijection X Y f ->
  homeomorphism X Tx Y Ty f.
let X Tx Y Ty f.
assume Hcomp: compact_space X Tx.
assume HH: Hausdorff_space Y Ty.
assume Hcont: continuous_map X Tx Y Ty f.
assume Hbij: bijection X Y f.
prove homeomorphism X Tx Y Ty f.
prove continuous_map X Tx Y Ty f /\
      exists g:set, continuous_map Y Ty X Tx g /\
        (forall x:set, x :e X -> apply_fun g (apply_fun f x) = x) /\
        (forall y:set, y :e Y -> apply_fun f (apply_fun g y) = y).
apply andI.
- exact Hcont.
- set g := inv_fun_graph X f Y.
  witness g.
  apply andI.
  + apply andI.
    * exact (compact_to_Hausdorff_inverse_continuous X Tx Y Ty f Hcomp HH Hcont Hbij).
    * let x. assume Hx: x :e X.
      prove apply_fun g (apply_fun f x) = x.
      claim Hfun: function_on f X Y.
      { exact (andEL (function_on f X Y)
                     (forall y:set, y :e Y -> exists x0:set, x0 :e X /\ apply_fun f x0 = y /\ (forall x':set, x' :e X -> apply_fun f x' = y -> x' = x0))
                     Hbij). }
      claim HyY: apply_fun f x :e Y.
      { exact (Hfun x Hx). }
      claim Hginv: apply_fun g (apply_fun f x) = inv X (fun u:set => apply_fun f u) (apply_fun f x).
      { exact (inv_fun_graph_apply X Y f (apply_fun f x) HyY). }
      rewrite Hginv.
      claim Hinj: forall u v :e X, apply_fun f u = apply_fun f v -> u = v.
      { let u. assume Hu: u :e X.
        let v. assume Hv: v :e X.
        assume Heq.
        exact (bijection_inj X Y f u v Hbij Hu Hv Heq). }
      exact (inj_linv X (fun u:set => apply_fun f u) Hinj x Hx).
  + let y. assume Hy: y :e Y.
    prove apply_fun f (apply_fun g y) = y.
    claim Hginv: apply_fun g y = inv X (fun u:set => apply_fun f u) y.
    { exact (inv_fun_graph_apply X Y f y Hy). }
    rewrite Hginv.
    claim Hsurj: forall w :e Y, exists u :e X, apply_fun f u = w.
    { let w. assume Hw: w :e Y.
      claim Hex: exists u:set, u :e X /\ apply_fun f u = w.
      { exact (bijection_surj X Y f w Hbij Hw). }
      exact Hex. }
    claim Hpair: inv X (fun u:set => apply_fun f u) y :e X /\
                 apply_fun f (inv X (fun u:set => apply_fun f u) y) = y.
    { exact (surj_rinv X Y (fun u:set => apply_fun f u) Hsurj y Hy). }
    exact (andER (inv X (fun u:set => apply_fun f u) y :e X)
                 (apply_fun f (inv X (fun u:set => apply_fun f u) y) = y)
                 Hpair).
Qed.

(** LATEX VERSION: A subset A is bounded if |x|M for some real M. **)
Definition bounded_subset_of_reals : set -> prop := fun A =>
  exists M:set, M :e R /\ forall x:set, x :e A -> ~(Rlt M (Abs x)).

(** helper: elements of omega are reals **)
Theorem omega_in_R : forall n:set, n :e omega -> n :e R.
let n. assume Hn: n :e omega.
claim HnSNoS: n :e SNoS_ omega.
{ exact (omega_SNoS_omega n Hn). }
exact (SNoS_omega_real n HnSNoS).
Qed.

(** helper: successors of naturals are reals **)
Theorem ordsucc_in_R : forall n:set, n :e omega -> ordsucc n :e R.
let n. assume Hn: n :e omega.
exact (omega_in_R (ordsucc n) (omega_ordsucc n Hn)).
Qed.

(** helper: an interval around 0 bounds Abs **)
Theorem interval_bounds_Abs : forall M x:set,
  M :e R -> x :e R ->
  Rlt (minus_SNo M) x -> Rlt x M ->
  ~(Rlt M (Abs x)).
let M x.
assume HM: M :e R.
assume HxR: x :e R.
assume Hlx: Rlt (minus_SNo M) x.
assume HxM: Rlt x M.
assume HMAbs: Rlt M (Abs x).
claim HAbsR: Abs x :e R.
{ exact (RltE_right M (Abs x) HMAbs). }
claim HxS: SNo x.
{ exact (real_SNo x HxR). }
apply (SNoLt_trichotomy_or_impred x 0 HxS SNo_0 False).
- assume Hxlt0: x < 0.
  claim Habseq: Abs x = minus_SNo x.
  { exact (neg_abs_SNo x HxS Hxlt0). }
  claim HMltAbs: M < Abs x.
  { exact (RltE_lt M (Abs x) HMAbs). }
  claim HMltnegx: M < minus_SNo x.
  { rewrite <- Habseq.
    exact HMltAbs. }
  claim Hlxs: minus_SNo M < x.
  { exact (RltE_lt (minus_SNo M) x Hlx). }
  claim HmR: minus_SNo M :e R.
  { exact (real_minus_SNo M HM). }
  claim HmS: SNo (minus_SNo M).
  { exact (real_SNo (minus_SNo M) HmR). }
  claim Hnegxlt: minus_SNo x < minus_SNo (minus_SNo M).
  { exact (minus_SNo_Lt_contra (minus_SNo M) x HmS HxS Hlxs). }
  claim Hminv: minus_SNo (minus_SNo M) = M.
  { exact (minus_SNo_invol M (real_SNo M HM)). }
  claim HnegxltM: minus_SNo x < M.
  { rewrite <- Hminv.
    exact Hnegxlt. }
  claim HAbsltM: Abs x < M.
  { rewrite Habseq at 1.
    exact HnegxltM. }
  claim HRltAbsM: Rlt (Abs x) M.
  { exact (RltI (Abs x) M HAbsR HM HAbsltM). }
  claim HMM: Rlt M M.
  { exact (Rlt_tra M (Abs x) M HMAbs HRltAbsM). }
  exact ((not_Rlt_refl M HM) HMM).
- assume Hxeq0: x = 0.
  claim H0le0: 0 <= 0.
  { apply (SNoLtLe_or 0 0 SNo_0 SNo_0 (0 <= 0)).
    - assume H00: 0 < 0.
      exact (SNoLtLe 0 0 H00).
    - assume H. exact H. }
  claim Habseq: Abs 0 = 0.
  { exact (nonneg_abs_SNo 0 H0le0). }
  claim Hx0M: Rlt 0 M.
  { rewrite <- Hxeq0.
    exact HxM. }
  claim HMlt0: Rlt M 0.
  { claim HAbsx0: Abs x = 0.
    { rewrite Hxeq0 at 1.
      exact Habseq. }
    rewrite <- HAbsx0.
    exact HMAbs. }
  claim HMM: Rlt M M.
  { exact (Rlt_tra M 0 M HMlt0 Hx0M). }
  exact ((not_Rlt_refl M HM) HMM).
- assume H0ltx: 0 < x.
  claim H0lex: 0 <= x.
  { exact (SNoLtLe 0 x H0ltx). }
  claim Habseq: Abs x = x.
  { exact (nonneg_abs_SNo x H0lex). }
  claim HMltAbs: M < Abs x.
  { exact (RltE_lt M (Abs x) HMAbs). }
  claim HMltx: M < x.
  { rewrite <- Habseq.
    exact HMltAbs. }
  claim HxltM: x < M.
  { exact (RltE_lt x M HxM). }
  claim HRltMx: Rlt M x.
  { exact (RltI M x HM HxR HMltx). }
  claim HRltxM: Rlt x M.
  { exact HxM. }
  claim HMM: Rlt M M.
  { exact (Rlt_tra M x M HRltMx HRltxM). }
  exact ((not_Rlt_refl M HM) HMM).
Qed.

(** from 26 Theorem 26.7: finite products of compact spaces are compact **) 
(** LATEX VERSION: Finite product of compact spaces is compact. **)
Theorem finite_product_compact : forall X Tx Y Ty:set,
  compact_space X Tx -> compact_space Y Ty ->
  compact_space (setprod X Y) (product_topology X Tx Y Ty).
let X Tx Y Ty.
assume HX: compact_space X Tx.
assume HY: compact_space Y Ty.
prove compact_space (setprod X Y) (product_topology X Tx Y Ty).
prove topology_on (setprod X Y) (product_topology X Tx Y Ty) /\
      forall Fam:set,
        open_cover_of (setprod X Y) (product_topology X Tx Y Ty) Fam ->
        has_finite_subcover (setprod X Y) (product_topology X Tx Y Ty) Fam.
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam) HX). }
claim HTy: topology_on Y Ty.
{ exact (andEL (topology_on Y Ty) (forall Fam:set, open_cover_of Y Ty Fam -> has_finite_subcover Y Ty Fam) HY). }
apply andI.
- exact (product_topology_is_topology X Tx Y Ty HTx HTy).
- let Fam. assume HFam: open_cover_of (setprod X Y) (product_topology X Tx Y Ty) Fam.
  prove has_finite_subcover (setprod X Y) (product_topology X Tx Y Ty) Fam.
  set UFam := {U :e Tx|exists H:set, H c= Fam /\ finite H /\ setprod U Y c= Union H}.
  claim HcovUFam: open_cover_of X Tx UFam.
  { prove topology_on X Tx /\ UFam c= Power X /\ X c= Union UFam /\ (forall U:set, U :e UFam -> U :e Tx).
    claim HUFamSubTx: UFam c= Tx.
    { let U. assume HU: U :e UFam.
      exact (SepE1 Tx (fun U0:set => exists H:set, H c= Fam /\ finite H /\ setprod U0 Y c= Union H) U HU). }
    claim HTxPow: Tx c= Power X.
    { exact (topology_subset_axiom X Tx HTx). }
    claim HUFamPow: UFam c= Power X.
    { let U. assume HU: U :e UFam.
      claim HUTx: U :e Tx.
      { exact (HUFamSubTx U HU). }
      exact (HTxPow U HUTx). }
    apply andI.
    - apply andI.
      + apply andI.
        * exact HTx.
        * exact HUFamPow.
      + prove X c= Union UFam.
        let x. assume Hx: x :e X.
        prove x :e Union UFam.
        claim HexTube: exists U:set,
          U :e Tx /\ x :e U /\
          exists H:set, H c= Fam /\ finite H /\ setprod U Y c= Union H.
        { (** Reduce to producing a finite subfamily H of Fam that covers {x}Y, then apply tube_lemma to N = Union H. **)
          claim HFamOpen: forall U0:set, U0 :e Fam -> U0 :e product_topology X Tx Y Ty.
          { exact (andER ((topology_on (setprod X Y) (product_topology X Tx Y Ty) /\ Fam c= Power (setprod X Y)) /\ setprod X Y c= Union Fam)
                         (forall U0:set, U0 :e Fam -> U0 :e product_topology X Tx Y Ty)
                         HFam). }
          claim HexSlice: exists H:set, H c= Fam /\ finite H /\ setprod {x} Y c= Union H.
          { (** Build an open cover of Y by second-coordinate slices coming from rectangles inside members of Fam. **)
            claim HFamABC: (topology_on (setprod X Y) (product_topology X Tx Y Ty) /\ Fam c= Power (setprod X Y)) /\ setprod X Y c= Union Fam.
            { exact (andEL ((topology_on (setprod X Y) (product_topology X Tx Y Ty) /\ Fam c= Power (setprod X Y)) /\ setprod X Y c= Union Fam)
                           (forall U0:set, U0 :e Fam -> U0 :e product_topology X Tx Y Ty)
                           HFam). }
            claim HcovXY: setprod X Y c= Union Fam.
            { exact (andER (topology_on (setprod X Y) (product_topology X Tx Y Ty) /\ Fam c= Power (setprod X Y))
                           (setprod X Y c= Union Fam)
                           HFamABC). }
            set B := product_subbasis X Tx Y Ty.
            claim HBasis: basis_on (setprod X Y) B.
            { exact (product_subbasis_is_basis X Tx Y Ty HTx HTy). }
            set VFam := {V :e Ty|exists U0:set, U0 :e Tx /\ x :e U0 /\ exists N0:set, N0 :e Fam /\ setprod U0 V c= N0}.
            claim HVFamSubTy: VFam c= Ty.
            { let V. assume HV: V :e VFam.
              exact (SepE1 Ty (fun V0:set => exists U0:set, U0 :e Tx /\ x :e U0 /\ exists N0:set, N0 :e Fam /\ setprod U0 V0 c= N0) V HV). }
            claim HTyPow: Ty c= Power Y.
            { exact (topology_subset_axiom Y Ty HTy). }
            claim HVFamPow: VFam c= Power Y.
            { let V. assume HV: V :e VFam.
              claim HVTy: V :e Ty.
              { exact (HVFamSubTy V HV). }
              exact (HTyPow V HVTy). }
            claim HYcovV: Y c= Union VFam.
            { let y. assume Hy: y :e Y.
              prove y :e Union VFam.
              set p := (x,y).
              claim HpXY: p :e setprod X Y.
              { exact (tuple_2_setprod X Y x Hx y Hy). }
              claim HpInUnion: p :e Union Fam.
              { exact (HcovXY p HpXY). }
              apply (UnionE_impred Fam p HpInUnion).
              let N0. assume HpN0: p :e N0.
              assume HN0Fam: N0 :e Fam.
              claim HN0Top: N0 :e generated_topology (setprod X Y) B.
              { exact (HFamOpen N0 HN0Fam). }
              claim HN0refine: forall q :e N0, exists b :e B, q :e b /\ b c= N0.
              { exact (SepE2 (Power (setprod X Y))
                             (fun U0:set => forall q :e U0, exists b :e B, q :e b /\ b c= U0)
                             N0 HN0Top). }
              claim Hexb: exists b :e B, p :e b /\ b c= N0.
              { exact (HN0refine p HpN0). }
              apply Hexb.
              let b. assume Hbpair.
              claim HbB: b :e B.
              { exact (andEL (b :e B) (p :e b /\ b c= N0) Hbpair). }
              claim Hbprop: p :e b /\ b c= N0.
              { exact (andER (b :e B) (p :e b /\ b c= N0) Hbpair). }
              claim Hpb: p :e b.
              { exact (andEL (p :e b) (b c= N0) Hbprop). }
              claim HbsubN0: b c= N0.
              { exact (andER (p :e b) (b c= N0) Hbprop). }
              apply (famunionE_impred Tx (fun U0:set => {rectangle_set U0 V0|V0 :e Ty}) b HbB).
              let U0. assume HU0Tx: U0 :e Tx.
              assume HbIn: b :e {rectangle_set U0 V0|V0 :e Ty}.
              apply (ReplE_impred Ty (fun V0:set => rectangle_set U0 V0) b HbIn).
              let V0. assume HV0Ty: V0 :e Ty.
              assume HbEq: b = rectangle_set U0 V0.
              claim HpUV: p :e setprod U0 V0.
              { prove p :e rectangle_set U0 V0.
                rewrite <- HbEq at 1.
                exact Hpb. }
              claim HpXY0: p :e setprod {x} {y}.
              { exact (tuple_2_setprod {x} {y} x (SingI x) y (SingI y)). }
              claim Hcoords: x :e U0 /\ y :e V0.
              { exact (setprod_coords_in x y U0 V0 p HpXY0 HpUV). }
              claim HxU0: x :e U0.
              { exact (andEL (x :e U0) (y :e V0) Hcoords). }
              claim HyV0: y :e V0.
              { exact (andER (x :e U0) (y :e V0) Hcoords). }
              claim HrectSub: setprod U0 V0 c= N0.
              { rewrite <- HbEq at 1.
                exact HbsubN0. }
              claim HV0Fam: V0 :e VFam.
              { apply (SepI Ty (fun V1:set => exists U1:set, U1 :e Tx /\ x :e U1 /\ exists N1:set, N1 :e Fam /\ setprod U1 V1 c= N1) V0 HV0Ty).
                witness U0.
                prove U0 :e Tx /\ x :e U0 /\ exists N1:set, N1 :e Fam /\ setprod U0 V0 c= N1.
                apply andI.
                - exact (andI (U0 :e Tx) (x :e U0) HU0Tx HxU0).
                - witness N0.
                  exact (andI (N0 :e Fam) (setprod U0 V0 c= N0) HN0Fam HrectSub). }
              exact (UnionI VFam y V0 HyV0 HV0Fam). }
            claim HVFamCover: open_cover_of Y Ty VFam.
            { prove topology_on Y Ty /\ VFam c= Power Y /\ Y c= Union VFam /\ (forall U0:set, U0 :e VFam -> U0 :e Ty).
              apply andI.
              - apply andI.
                + apply andI.
                  * exact HTy.
                  * exact HVFamPow.
                + exact HYcovV.
              - let V. assume HV: V :e VFam.
                exact (HVFamSubTy V HV). }
            claim HfinV: has_finite_subcover Y Ty VFam.
            { exact (Heine_Borel_subcover Y Ty VFam HY HVFamCover). }
            apply HfinV.
            let G. assume HG: G c= VFam /\ finite G /\ Y c= Union G.
            claim HGsub: G c= VFam.
            { exact (andEL (G c= VFam) (finite G) (andEL (G c= VFam /\ finite G) (Y c= Union G) HG)). }
            claim HGfin: finite G.
            { exact (andER (G c= VFam) (finite G) (andEL (G c= VFam /\ finite G) (Y c= Union G) HG)). }
            claim HYcovG: Y c= Union G.
            { exact (andER (G c= VFam /\ finite G) (Y c= Union G) HG). }
            set pickU := fun V:set => Eps_i (fun U0:set => U0 :e Tx /\ x :e U0 /\ exists N0:set, N0 :e Fam /\ setprod U0 V c= N0).
            claim HpickU: forall V:set, V :e VFam -> pickU V :e Tx /\ x :e pickU V /\ exists N0:set, N0 :e Fam /\ setprod (pickU V) V c= N0.
            { let V. assume HV: V :e VFam.
              claim Hex: exists U0:set, U0 :e Tx /\ x :e U0 /\ exists N0:set, N0 :e Fam /\ setprod U0 V c= N0.
              { exact (SepE2 Ty (fun V0:set => exists U0:set, U0 :e Tx /\ x :e U0 /\ exists N0:set, N0 :e Fam /\ setprod U0 V0 c= N0) V HV). }
              apply Hex.
              let U0. assume HU0: U0 :e Tx /\ x :e U0 /\ exists N0:set, N0 :e Fam /\ setprod U0 V c= N0.
              exact (Eps_i_ax (fun U1:set => U1 :e Tx /\ x :e U1 /\ exists N0:set, N0 :e Fam /\ setprod U1 V c= N0) U0 HU0). }
            set pickN := fun V:set => Eps_i (fun N0:set => N0 :e Fam /\ setprod (pickU V) V c= N0).
            claim HpickN: forall V:set, V :e VFam -> pickN V :e Fam /\ setprod (pickU V) V c= pickN V.
            { let V. assume HV: V :e VFam.
              claim Hprop: pickU V :e Tx /\ x :e pickU V /\ exists N0:set, N0 :e Fam /\ setprod (pickU V) V c= N0.
              { exact (HpickU V HV). }
              claim HpropAB: pickU V :e Tx /\ x :e pickU V.
              { exact (andEL (pickU V :e Tx /\ x :e pickU V) (exists N0:set, N0 :e Fam /\ setprod (pickU V) V c= N0) Hprop). }
              claim HexN: exists N0:set, N0 :e Fam /\ setprod (pickU V) V c= N0.
              { exact (andER (pickU V :e Tx /\ x :e pickU V) (exists N0:set, N0 :e Fam /\ setprod (pickU V) V c= N0) Hprop). }
              apply HexN.
              let N0. assume HN0: N0 :e Fam /\ setprod (pickU V) V c= N0.
              exact (Eps_i_ax (fun N1:set => N1 :e Fam /\ setprod (pickU V) V c= N1) N0 HN0). }
            set H := {pickN V|V :e G}.
            witness H.
            apply andI.
            - apply andI.
              + prove H c= Fam.
                let N0. assume HN0: N0 :e H.
                apply (ReplE_impred G (fun V0:set => pickN V0) N0 HN0).
                let V0. assume HV0G: V0 :e G.
                assume HN0Eq: N0 = pickN V0.
                claim HV0Fam: V0 :e VFam.
                { exact (HGsub V0 HV0G). }
                claim HNprop: pickN V0 :e Fam /\ setprod (pickU V0) V0 c= pickN V0.
                { exact (HpickN V0 HV0Fam). }
                claim HN0Fam: pickN V0 :e Fam.
                { exact (andEL (pickN V0 :e Fam) (setprod (pickU V0) V0 c= pickN V0) HNprop). }
                rewrite HN0Eq.
                exact HN0Fam.
              + exact (Repl_finite (fun V0:set => pickN V0) G HGfin).
            - prove setprod {x} Y c= Union H.
              let p. assume Hp: p :e setprod {x} Y.
              prove p :e Union H.
                  claim Hp0: p 0 :e {x}.
                  { exact (ap0_Sigma {x} (fun _:set => Y) p Hp). }
                  claim Hp1: p 1 :e Y.
                  { exact (ap1_Sigma {x} (fun _:set => Y) p Hp). }
                  claim Hp0eq: p 0 = x.
                  { exact (SingE x (p 0) Hp0). }
                  claim HpEta: p = (p 0, p 1).
                  { exact (setprod_eta {x} Y p Hp). }
                  claim Hp1InUnion: p 1 :e Union G.
                  { exact (HYcovG (p 1) Hp1). }
                  apply (UnionE_impred G (p 1) Hp1InUnion).
                  let V0. assume Hp1V0: p 1 :e V0.
                  assume HV0G: V0 :e G.
                  claim HV0Fam: V0 :e VFam.
                  { exact (HGsub V0 HV0G). }
                  claim HUN: pickU V0 :e Tx /\ x :e pickU V0 /\ exists N0:set, N0 :e Fam /\ setprod (pickU V0) V0 c= N0.
                  { exact (HpickU V0 HV0Fam). }
                  claim HUNAB: pickU V0 :e Tx /\ x :e pickU V0.
                  { exact (andEL (pickU V0 :e Tx /\ x :e pickU V0) (exists N0:set, N0 :e Fam /\ setprod (pickU V0) V0 c= N0) HUN). }
                  claim HxPick: x :e pickU V0.
                  { exact (andER (pickU V0 :e Tx) (x :e pickU V0) HUNAB). }
                  claim HNprop: pickN V0 :e Fam /\ setprod (pickU V0) V0 c= pickN V0.
                  { exact (HpickN V0 HV0Fam). }
                  claim HrectSub: setprod (pickU V0) V0 c= pickN V0.
                  { exact (andER (pickN V0 :e Fam) (setprod (pickU V0) V0 c= pickN V0) HNprop). }
                  claim HpInRect: (x, p 1) :e setprod (pickU V0) V0.
                  { exact (tuple_2_setprod (pickU V0) V0 x HxPick (p 1) Hp1V0). }
                  claim HpInN: (x, p 1) :e pickN V0.
                  { exact (HrectSub (x, p 1) HpInRect). }
                  claim HNinH: pickN V0 :e H.
                  { exact (ReplI G (fun V1:set => pickN V1) V0 HV0G). }
                  rewrite HpEta.
                  rewrite Hp0eq at 1.
	                  exact (UnionI H (x, p 1) (pickN V0) HpInN HNinH).
	          }
	          apply HexSlice.
          let H. assume HH: H c= Fam /\ finite H /\ setprod {x} Y c= Union H.
          claim HHsub: H c= Fam.
          { exact (andEL (H c= Fam) (finite H) (andEL (H c= Fam /\ finite H) (setprod {x} Y c= Union H) HH)). }
          claim HHfin: finite H.
          { exact (andER (H c= Fam) (finite H) (andEL (H c= Fam /\ finite H) (setprod {x} Y c= Union H) HH)). }
          claim HHcov: setprod {x} Y c= Union H.
          { exact (andER (H c= Fam /\ finite H) (setprod {x} Y c= Union H) HH). }
          claim HHsubTop: H c= product_topology X Tx Y Ty.
          { let N0. assume HN0: N0 :e H.
            claim HN0Fam: N0 :e Fam.
            { exact (HHsub N0 HN0). }
            exact (HFamOpen N0 HN0Fam). }
          claim HtopProd: topology_on (setprod X Y) (product_topology X Tx Y Ty).
          { exact (product_topology_is_topology X Tx Y Ty HTx HTy). }
          claim HNtop: Union H :e product_topology X Tx Y Ty.
          { exact (topology_union_closed (setprod X Y) (product_topology X Tx Y Ty) H HtopProd HHsubTop). }
          claim Htube: exists U:set, U :e Tx /\ x :e U /\ setprod U Y c= Union H.
          { exact (tube_lemma X Tx Y Ty HTx HTy HY x Hx (Union H)
                 (andI ((Union H) :e product_topology X Tx Y Ty) (setprod {x} Y c= Union H) HNtop HHcov)). }
          apply Htube.
          let U. assume HU: U :e Tx /\ x :e U /\ setprod U Y c= Union H.
          claim HUAB0: U :e Tx /\ x :e U.
          { exact (andEL (U :e Tx /\ x :e U) (setprod U Y c= Union H) HU). }
          witness U.
          apply andI.
          - exact HUAB0.
          - witness H.
            exact (andI (H c= Fam /\ finite H) (setprod U Y c= Union H)
                        (andI (H c= Fam) (finite H) HHsub HHfin)
                        (andER (U :e Tx /\ x :e U) (setprod U Y c= Union H) HU)). }
        apply HexTube.
        let U. assume HU: U :e Tx /\ x :e U /\ exists H:set, H c= Fam /\ finite H /\ setprod U Y c= Union H.
        claim HUAB: U :e Tx /\ x :e U.
        { exact (andEL (U :e Tx /\ x :e U) (exists H:set, H c= Fam /\ finite H /\ setprod U Y c= Union H) HU). }
        claim HUtx: U :e Tx.
        { exact (andEL (U :e Tx) (x :e U) HUAB). }
        claim HxU: x :e U.
        { exact (andER (U :e Tx) (x :e U) HUAB). }
        claim HexH: exists H:set, H c= Fam /\ finite H /\ setprod U Y c= Union H.
        { exact (andER (U :e Tx /\ x :e U) (exists H:set, H c= Fam /\ finite H /\ setprod U Y c= Union H) HU). }
        claim HUinUFam: U :e UFam.
        { apply (SepI Tx (fun U0:set => exists H:set, H c= Fam /\ finite H /\ setprod U0 Y c= Union H) U HUtx).
          exact HexH. }
        exact (UnionI UFam x U HxU HUinUFam).
    - let U. assume HU: U :e UFam.
      exact (HUFamSubTx U HU). }
  claim HfinUFam: has_finite_subcover X Tx UFam.
  { exact (Heine_Borel_subcover X Tx UFam HX HcovUFam). }
  apply HfinUFam.
  let K. assume HK: K c= UFam /\ finite K /\ X c= Union K.
  claim HKsub: K c= UFam.
  { exact (andEL (K c= UFam) (finite K) (andEL (K c= UFam /\ finite K) (X c= Union K) HK)). }
  claim HKfin: finite K.
  { exact (andER (K c= UFam) (finite K) (andEL (K c= UFam /\ finite K) (X c= Union K) HK)). }
  claim HXcovK: X c= Union K.
  { exact (andER (K c= UFam /\ finite K) (X c= Union K) HK). }
  set pickH := fun U:set => Eps_i (fun H:set => H c= Fam /\ finite H /\ setprod U Y c= Union H).
  claim HpickH: forall U:set, U :e UFam -> pickH U c= Fam /\ finite (pickH U) /\ setprod U Y c= Union (pickH U).
  { let U. assume HU: U :e UFam.
    claim Hex: exists H:set, H c= Fam /\ finite H /\ setprod U Y c= Union H.
    { exact (SepE2 Tx (fun U0:set => exists H:set, H c= Fam /\ finite H /\ setprod U0 Y c= Union H) U HU). }
    apply Hex.
    let H0. assume HH0: H0 c= Fam /\ finite H0 /\ setprod U Y c= Union H0.
    exact (Eps_i_ax (fun H:set => H c= Fam /\ finite H /\ setprod U Y c= Union H) H0 HH0). }
  set G := \/_ U :e K, pickH U.
  prove has_finite_subcover (setprod X Y) (product_topology X Tx Y Ty) Fam.
  prove exists G0:set, G0 c= Fam /\ finite G0 /\ setprod X Y c= Union G0.
  witness G.
  apply andI.
  - prove G c= Fam /\ finite G.
    apply andI.
    + prove G c= Fam.
      let N. assume HN: N :e G.
      prove N :e Fam.
      apply (famunionE_impred K (fun U0:set => pickH U0) N HN).
      let U0. assume HU0K: U0 :e K.
      assume HNin: N :e pickH U0.
      claim HU0UFam: U0 :e UFam.
      { exact (HKsub U0 HU0K). }
      claim Hprop: pickH U0 c= Fam /\ finite (pickH U0) /\ setprod U0 Y c= Union (pickH U0).
      { exact (HpickH U0 HU0UFam). }
      claim HpropAB: pickH U0 c= Fam /\ finite (pickH U0).
      { exact (andEL (pickH U0 c= Fam /\ finite (pickH U0)) (setprod U0 Y c= Union (pickH U0)) Hprop). }
      claim HsubFam: pickH U0 c= Fam.
      { exact (andEL (pickH U0 c= Fam) (finite (pickH U0)) HpropAB). }
      exact (HsubFam N HNin).
    + prove finite G.
      claim HpEmpty: Empty c= UFam -> finite (\/_ U :e Empty, pickH U).
      { assume _.
        rewrite (famunion_Empty (fun U:set => pickH U)).
        exact finite_Empty. }
      claim HpStep: forall K0 y:set,
        finite K0 -> y /:e K0 ->
        (K0 c= UFam -> finite (\/_ U :e K0, pickH U)) ->
        ((K0 :\/: {y}) c= UFam -> finite (\/_ U :e (K0 :\/: {y}), pickH U)).
      { let K0 y.
        assume HK0fin HyNotin IH.
        assume Hsub: (K0 :\/: {y}) c= UFam.
        claim HK0sub: K0 c= UFam.
        { let U. assume HU: U :e K0.
          exact (Hsub U (binunionI1 K0 {y} U HU)). }
        claim HyUFam: y :e UFam.
        { exact (Hsub y (binunionI2 K0 {y} y (SingI y))). }
        claim Hfin0: finite (\/_ U :e K0, pickH U).
        { exact (IH HK0sub). }
        claim HpropY: pickH y c= Fam /\ finite (pickH y) /\ setprod y Y c= Union (pickH y).
        { exact (HpickH y HyUFam). }
        claim HpropYAB: pickH y c= Fam /\ finite (pickH y).
        { exact (andEL (pickH y c= Fam /\ finite (pickH y)) (setprod y Y c= Union (pickH y)) HpropY). }
        claim HfinY: finite (pickH y).
        { exact (andER (pickH y c= Fam) (finite (pickH y)) HpropYAB). }
        claim Heq: (\/_ U :e (K0 :\/: {y}), pickH U) = (\/_ U :e K0, pickH U) :\/: pickH y.
        { apply set_ext.
          - let N. assume HN: N :e (\/_ U :e (K0 :\/: {y}), pickH U).
            prove N :e (\/_ U :e K0, pickH U) :\/: pickH y.
            apply (famunionE_impred (K0 :\/: {y}) (fun U1:set => pickH U1) N HN).
            let U1. assume HU1: U1 :e K0 :\/: {y}.
            assume HNin: N :e pickH U1.
            apply (binunionE' K0 {y} U1 (N :e (\/_ U :e K0, pickH U) :\/: pickH y)).
            + assume HU1K0: U1 :e K0.
              apply binunionI1.
              exact (famunionI K0 (fun U2:set => pickH U2) U1 N HU1K0 HNin).
            + assume HU1y: U1 :e {y}.
              claim HU1eq: U1 = y.
              { exact (SingE y U1 HU1y). }
              claim HNy: N :e pickH y.
              { prove N :e pickH y.
                rewrite <- HU1eq at 1.
                exact HNin. }
              exact (binunionI2 (\/_ U :e K0, pickH U) (pickH y) N HNy).
            + exact HU1.
          - let N. assume HN: N :e (\/_ U :e K0, pickH U) :\/: pickH y.
            prove N :e (\/_ U :e (K0 :\/: {y}), pickH U).
            apply (binunionE' (\/_ U :e K0, pickH U) (pickH y) N (N :e (\/_ U :e (K0 :\/: {y}), pickH U))).
            + assume HN0: N :e (\/_ U :e K0, pickH U).
              apply (famunionE_impred K0 (fun U1:set => pickH U1) N HN0).
              let U1. assume HU1K0: U1 :e K0.
              assume HN1: N :e pickH U1.
              exact (famunionI (K0 :\/: {y}) (fun U2:set => pickH U2) U1 N (binunionI1 K0 {y} U1 HU1K0) HN1).
            + assume HNy: N :e pickH y.
              exact (famunionI (K0 :\/: {y}) (fun U2:set => pickH U2) y N (binunionI2 K0 {y} y (SingI y)) HNy).
            + exact HN. }
        rewrite Heq.
        exact (binunion_finite (\/_ U :e K0, pickH U) Hfin0 (pickH y) HfinY). }
      claim Hall: K c= UFam -> finite (\/_ U :e K, pickH U).
      { exact (finite_ind (fun K0:set => K0 c= UFam -> finite (\/_ U :e K0, pickH U)) HpEmpty HpStep K HKfin). }
      exact (Hall HKsub).
  - let p. assume Hp: p :e setprod X Y.
    prove p :e Union G.
    claim Hp0X: p 0 :e X.
    { exact (ap0_Sigma X (fun _:set => Y) p Hp). }
    claim Hp1Y: p 1 :e Y.
    { exact (ap1_Sigma X (fun _:set => Y) p Hp). }
    claim HpEta: p = (p 0, p 1).
    { exact (setprod_eta X Y p Hp). }
    claim Hp0InUnion: p 0 :e Union K.
    { exact (HXcovK (p 0) Hp0X). }
    apply (UnionE_impred K (p 0) Hp0InUnion).
    let U0. assume Hp0U0: p 0 :e U0.
    assume HU0K: U0 :e K.
    claim HU0UFam: U0 :e UFam.
    { exact (HKsub U0 HU0K). }
    claim Hprop: pickH U0 c= Fam /\ finite (pickH U0) /\ setprod U0 Y c= Union (pickH U0).
    { exact (HpickH U0 HU0UFam). }
    claim HcovU0: setprod U0 Y c= Union (pickH U0).
    { exact (andER (pickH U0 c= Fam /\ finite (pickH U0)) (setprod U0 Y c= Union (pickH U0)) Hprop). }
    claim HpInU0Y: (p 0, p 1) :e setprod U0 Y.
    { exact (tuple_2_setprod U0 Y (p 0) Hp0U0 (p 1) Hp1Y). }
    claim HpInUnionPick: (p 0, p 1) :e Union (pickH U0).
    { exact (HcovU0 (p 0, p 1) HpInU0Y). }
    apply (UnionE_impred (pickH U0) (p 0, p 1) HpInUnionPick).
    let N. assume HpN: (p 0, p 1) :e N.
    assume HNpick: N :e pickH U0.
    claim HNinG: N :e G.
    { exact (famunionI K (fun U1:set => pickH U1) U0 N HU0K HNpick). }
    rewrite HpEta.
    exact (UnionI G (p 0, p 1) N HpN HNinG).
Qed.

(** from 26 Exercises: compactness examples and properties **) 
(** LATEX VERSION: Exercises: unit interval closed in , unit interval compact, etc. **)
Theorem ex26_compactness_exercises :
  forall X Tx:set, compact_space X Tx ->
  (closed_in R R_standard_topology unit_interval) /\
  (compact_space unit_interval R_standard_topology).
let X Tx.
assume HX: compact_space X Tx.
prove closed_in R R_standard_topology unit_interval /\ compact_space unit_interval R_standard_topology.
apply andI.
- (** unit interval is closed in R **)
  prove closed_in R R_standard_topology unit_interval.
  claim HT: topology_on R R_standard_topology.
  { exact R_standard_topology_is_topology_local. }
  prove topology_on R R_standard_topology /\ (unit_interval c= R /\ exists U :e R_standard_topology, unit_interval = R :\: U).
  apply andI.
  - exact HT.
  - apply andI.
    + (** unit_interval c= R **)
      let x. assume Hx: x :e unit_interval.
      prove x :e R.
      exact (SepE1 R (fun x0:set => ~(Rlt x0 0) /\ ~(Rlt 1 x0)) x Hx).
    + (** witness the open complement **)
      set L0 := {x :e R|Rlt x 0}.
      set R1 := {x :e R|Rlt 1 x}.
      set U := L0 :\/: R1.
      witness U.
      apply andI.
      * (** U is open in R_standard_topology **)
        claim HL0: L0 :e R_standard_topology.
        { exact (open_left_ray_in_R_standard_topology 0 real_0). }
        claim HR1: R1 :e R_standard_topology.
        { exact (open_ray_in_R_standard_topology 1 real_1). }
        exact (topology_binunion_closed R R_standard_topology L0 R1 HT HL0 HR1).
      * (** unit_interval = R \\ U **)
        apply set_ext.
        { let x. assume Hx: x :e unit_interval.
          prove x :e R :\: U.
          claim HxR: x :e R.
          { exact (SepE1 R (fun x0:set => ~(Rlt x0 0) /\ ~(Rlt 1 x0)) x Hx). }
          claim Hxprop: ~(Rlt x 0) /\ ~(Rlt 1 x).
          { exact (SepE2 R (fun x0:set => ~(Rlt x0 0) /\ ~(Rlt 1 x0)) x Hx). }
          claim Hnx0: ~(Rlt x 0).
          { exact (andEL (~(Rlt x 0)) (~(Rlt 1 x)) Hxprop). }
          claim Hn1x: ~(Rlt 1 x).
          { exact (andER (~(Rlt x 0)) (~(Rlt 1 x)) Hxprop). }
          apply (setminusI R U x HxR).
          assume Hxu: x :e U.
          apply (binunionE L0 R1 x Hxu).
          - assume HxL: x :e L0.
            claim Hlt: Rlt x 0.
            { exact (SepE2 R (fun x0:set => Rlt x0 0) x HxL). }
            exact (Hnx0 Hlt).
          - assume HxR1: x :e R1.
            claim Hlt: Rlt 1 x.
            { exact (SepE2 R (fun x0:set => Rlt 1 x0) x HxR1). }
            exact (Hn1x Hlt). }
        { let x. assume Hx: x :e R :\: U.
          prove x :e unit_interval.
          claim HxR: x :e R.
          { exact (setminusE1 R U x Hx). }
          claim HxnotU: x /:e U.
          { exact (setminusE2 R U x Hx). }
          apply (SepI R (fun x0:set => ~(Rlt x0 0) /\ ~(Rlt 1 x0)) x HxR).
          apply andI.
          - (** ~(x < 0) **)
            assume Hlt: Rlt x 0.
            prove False.
            claim HxL0: x :e L0.
            { exact (SepI R (fun x0:set => Rlt x0 0) x HxR Hlt). }
            claim HxU: x :e U.
            { exact (binunionI1 L0 R1 x HxL0). }
            exact (HxnotU HxU).
          - (** ~(1 < x) **)
            assume Hlt: Rlt 1 x.
            prove False.
            claim HxR1: x :e R1.
            { exact (SepI R (fun x0:set => Rlt 1 x0) x HxR Hlt). }
            claim HxU: x :e U.
            { exact (binunionI2 L0 R1 x HxR1). }
            exact (HxnotU HxU). }
- (** compactness part remains open **)
  admit. (** unit interval compactness proof to be supplied later **)
Qed.

(** from 26/27: Heine-Borel on  (closed and bounded sets) **) 
(** LATEX VERSION: HeineBorel: compact subsets of  are closed and bounded; converses addressed. **)
Theorem Heine_Borel_closed_bounded : forall A:set,
  A c= R ->
  compact_space A (subspace_topology R R_standard_topology A) ->
  closed_in R R_standard_topology A /\ bounded_subset_of_reals A.
let A.
assume HA: A c= R.
assume Hcomp: compact_space A (subspace_topology R R_standard_topology A).
prove closed_in R R_standard_topology A /\ bounded_subset_of_reals A.
apply andI.
- exact (compact_subspace_in_Hausdorff_closed R R_standard_topology A R_standard_topology_Hausdorff HA Hcomp).
- (** boundedness **)
	  apply (xm (A = Empty)).
	  + assume HA0: A = Empty.
	    prove exists M:set, M :e R /\ forall x:set, x :e A -> ~(Rlt M (Abs x)).
	    witness 0.
	    apply andI.
	    * exact real_0.
	    * let x. assume HxA: x :e A.
	      prove ~(Rlt 0 (Abs x)).
	      assume H.
	      claim HxE: x :e Empty.
	      { rewrite <- HA0.
	        exact HxA. }
	      exact (EmptyE x HxE).
	  + assume HAne: ~(A = Empty).
	    prove exists M:set, M :e R /\ forall x:set, x :e A -> ~(Rlt M (Abs x)).
	    claim HTtop: topology_on R R_standard_topology.
	    { exact R_standard_topology_is_topology_local. }
    claim Hiff:
      compact_space A (subspace_topology R R_standard_topology A) <->
        forall Fam:set, (Fam c= R_standard_topology /\ A c= Union Fam) ->
          has_finite_subcover A R_standard_topology Fam.
    { exact (compact_subspace_via_ambient_covers R R_standard_topology A HTtop HA). }
    claim Hcovprop:
      forall Fam:set, (Fam c= R_standard_topology /\ A c= Union Fam) ->
        has_finite_subcover A R_standard_topology Fam.
    { exact (iffEL (compact_space A (subspace_topology R R_standard_topology A))
                   (forall Fam:set, (Fam c= R_standard_topology /\ A c= Union Fam) ->
                      has_finite_subcover A R_standard_topology Fam)
                   Hiff Hcomp). }
    set f := fun n:set => open_interval (minus_SNo (ordsucc n)) (ordsucc n).
    set Fam0 := {f n|n :e omega}.
    claim HFam0sub: Fam0 c= R_standard_topology.
    { let U. assume HU: U :e Fam0.
      apply (ReplE_impred omega (fun n0:set => f n0) U HU (U :e R_standard_topology)).
      let n0. assume Hn0: n0 :e omega.
      assume Heq: U = f n0.
      rewrite Heq.
      prove f n0 :e R_standard_topology.
      claim Hbasis: basis_on R R_standard_basis.
      { exact R_standard_basis_is_basis_local. }
      claim Hn0s: ordsucc n0 :e R.
      { exact (ordsucc_in_R n0 Hn0). }
      claim Hmn0R: minus_SNo (ordsucc n0) :e R.
      { exact (real_minus_SNo (ordsucc n0) Hn0s). }
      claim HfInBasis: f n0 :e R_standard_basis.
      { set a := minus_SNo (ordsucc n0).
        set b := ordsucc n0.
        claim HaR: a :e R.
        { exact Hmn0R. }
        claim HbR: b :e R.
        { exact Hn0s. }
        claim Hinner: open_interval a b :e {open_interval a bb|bb :e R}.
        { exact (ReplI R (fun bb:set => open_interval a bb) b HbR). }
        exact (famunionI R (fun aa:set => {open_interval aa bb|bb :e R}) a (open_interval a b) HaR Hinner). }
      exact (basis_in_generated R R_standard_basis (f n0) Hbasis HfInBasis). }
    claim HAcover: A c= Union Fam0.
    { let x. assume HxA: x :e A.
      prove x :e Union Fam0.
      claim HxR: x :e R.
      { exact (HA x HxA). }
      (** Find an index n with x in f n. **)
      claim Hup: exists N:set, N :e omega /\ x < N.
      { apply (real_E x HxR (exists N:set, N :e omega /\ x < N)).
        assume HxS: SNo x.
        assume Hlev: SNoLev x :e ordsucc omega.
        assume HxSNoS: x :e SNoS_ (ordsucc omega).
        assume HmOmLt: minus_SNo omega < x.
        assume HxLtOm: x < omega.
        assume Huniq.
        assume Happrox.
        exact (SNoS_ordsucc_omega_bdd_above x HxSNoS HxLtOm). }
      claim Hlow: exists N:set, N :e omega /\ minus_SNo N < x.
      { apply (real_E x HxR (exists N:set, N :e omega /\ minus_SNo N < x)).
        assume HxS: SNo x.
        assume Hlev: SNoLev x :e ordsucc omega.
        assume HxSNoS: x :e SNoS_ (ordsucc omega).
        assume HmOmLt: minus_SNo omega < x.
        assume HxLtOm: x < omega.
        assume Huniq.
        assume Happrox.
        exact (SNoS_ordsucc_omega_bdd_below x HxSNoS HmOmLt). }
      apply Hup.
      let Nup. assume Hupconj.
      claim HNup: Nup :e omega.
      { exact (andEL (Nup :e omega) (x < Nup) Hupconj). }
      claim HxNup: x < Nup.
      { exact (andER (Nup :e omega) (x < Nup) Hupconj). }
      apply Hlow.
      let Nlow. assume Hlowconj.
      claim HNlow: Nlow :e omega.
      { exact (andEL (Nlow :e omega) (minus_SNo Nlow < x) Hlowconj). }
      claim HNlowx: minus_SNo Nlow < x.
      { exact (andER (Nlow :e omega) (minus_SNo Nlow < x) Hlowconj). }
      set n := Nup :\/: Nlow.
      claim HnO: n :e omega.
      { exact (omega_binunion Nup Nlow HNup HNlow). }
      claim Hordomega: ordinal omega.
      { exact omega_ordinal. }
      claim HordNup: ordinal Nup.
      { exact (ordinal_Hered omega Hordomega Nup HNup). }
      claim HordNlow: ordinal Nlow.
      { exact (ordinal_Hered omega Hordomega Nlow HNlow). }
      claim Hordn: ordinal n.
      { exact (ordinal_Hered omega Hordomega n HnO). }
      claim HNupSub: Nup c= n.
      { let t. assume Ht: t :e Nup.
        exact (binunionI1 Nup Nlow t Ht). }
      claim HNlowSub: Nlow c= n.
      { let t. assume Ht: t :e Nlow.
        exact (binunionI2 Nup Nlow t Ht). }
      claim HNupLe: Nup <= n.
      { exact (ordinal_Subq_SNoLe Nup n HordNup Hordn HNupSub). }
      claim HNlowLe: Nlow <= n.
      { exact (ordinal_Subq_SNoLe Nlow n HordNlow Hordn HNlowSub). }
      claim HxS: SNo x.
      { exact (real_SNo x HxR). }
      claim HNupS: SNo Nup.
      { exact (omega_SNo Nup HNup). }
      claim HnS: SNo n.
      { exact (omega_SNo n HnO). }
      claim Hxlt_n: x < n.
      { exact (SNoLtLe_tra x Nup n HxS HNupS HnS HxNup HNupLe). }
      claim Hn_in_ordsucc: n :e ordsucc n.
      { exact (ordsuccI2 n). }
      claim Hord_ordsucc: ordinal (ordsucc n).
      { exact (ordinal_ordsucc n Hordn). }
      claim Hnlt_ordsucc: n < ordsucc n.
      { exact (ordinal_In_SNoLt (ordsucc n) Hord_ordsucc n Hn_in_ordsucc). }
      claim HordS: SNo (ordsucc n).
      { exact (omega_SNo (ordsucc n) (omega_ordsucc n HnO)). }
      claim Hxlt_ordsucc: x < ordsucc n.
      { exact (SNoLt_tra x n (ordsucc n) HxS HnS HordS Hxlt_n Hnlt_ordsucc). }
      (** Lower bound: - ordsucc n < x. **)
      claim HNlowS: SNo Nlow.
      { exact (omega_SNo Nlow HNlow). }
      claim Hneg_nS: SNo (minus_SNo n).
      { exact (SNo_minus_SNo n HnS). }
      claim Hneg_NlowS: SNo (minus_SNo Nlow).
      { exact (SNo_minus_SNo Nlow HNlowS). }
      claim Hle_neg: minus_SNo n <= minus_SNo Nlow.
      { exact (minus_SNo_Le_contra Nlow n HNlowS HnS HNlowLe). }
      claim Hneglow_lt_x: minus_SNo Nlow < x.
      { exact HNlowx. }
      claim Hneg_n_lt_x: minus_SNo n < x.
      { exact (SNoLeLt_tra (minus_SNo n) (minus_SNo Nlow) x Hneg_nS Hneg_NlowS HxS Hle_neg Hneglow_lt_x). }
      claim Hnlt_ordsucc_neg: minus_SNo (ordsucc n) < minus_SNo n.
      { exact (minus_SNo_Lt_contra n (ordsucc n) HnS HordS Hnlt_ordsucc). }
      claim Hneg_ordsucc_lt_x: minus_SNo (ordsucc n) < x.
      { exact (SNoLt_tra (minus_SNo (ordsucc n)) (minus_SNo n) x
                         (SNo_minus_SNo (ordsucc n) HordS)
                         Hneg_nS
                         HxS
                         Hnlt_ordsucc_neg
                         Hneg_n_lt_x). }
      (** Now x is in the open interval. **)
      claim HordsuccR: ordsucc n :e R.
      { exact (ordsucc_in_R n HnO). }
      claim HnegordsuccR: minus_SNo (ordsucc n) :e R.
      { exact (real_minus_SNo (ordsucc n) HordsuccR). }
      claim HRltL: Rlt (minus_SNo (ordsucc n)) x.
      { exact (RltI (minus_SNo (ordsucc n)) x HnegordsuccR HxR Hneg_ordsucc_lt_x). }
      claim HRltR: Rlt x (ordsucc n).
      { exact (RltI x (ordsucc n) HxR HordsuccR Hxlt_ordsucc). }
      claim HxIn: x :e f n.
      { exact (SepI R (fun x0:set => Rlt (minus_SNo (ordsucc n)) x0 /\ Rlt x0 (ordsucc n))
                   x HxR (andI (Rlt (minus_SNo (ordsucc n)) x) (Rlt x (ordsucc n)) HRltL HRltR)). }
      claim HfnFam: f n :e Fam0.
      { exact (ReplI omega (fun n0:set => f n0) n HnO). }
      exact (UnionI Fam0 x (f n) HxIn HfnFam). }
    claim Hfincover: has_finite_subcover A R_standard_topology Fam0.
    { exact (Hcovprop Fam0 (andI (Fam0 c= R_standard_topology) (A c= Union Fam0) HFam0sub HAcover)). }
    apply Hfincover.
    let G. assume HGtriple.
    claim HGsub: G c= Fam0.
    { exact (andEL (G c= Fam0) (finite G) (andEL (G c= Fam0 /\ finite G) (A c= Union G) HGtriple)). }
    claim HGfin: finite G.
    { exact (andER (G c= Fam0) (finite G) (andEL (G c= Fam0 /\ finite G) (A c= Union G) HGtriple)). }
    claim HAcovG: A c= Union G.
    { exact (andER (G c= Fam0 /\ finite G) (A c= Union G) HGtriple). }
    set pickN := fun U:set => Eps_i (fun n0:set => n0 :e omega /\ U = f n0).
    set Nset := {pickN U|U :e G}.
    claim HNsetFin: finite Nset.
    { exact (Repl_finite (fun U0:set => pickN U0) G HGfin). }
    claim HexA: exists x:set, x :e A.
    { exact (nonempty_has_element A HAne). }
    apply HexA.
    let x0. assume Hx0A: x0 :e A.
    claim Hx0UG: x0 :e Union G.
    { exact (HAcovG x0 Hx0A). }
    claim HexU0: exists U0:set, x0 :e U0 /\ U0 :e G.
    { exact (iffEL (x0 :e Union G)
                   (exists Y:set, x0 :e Y /\ Y :e G)
                   (UnionEq G x0) Hx0UG). }
    apply HexU0.
    let U0. assume HU0conj.
    claim HU0G: U0 :e G.
    { exact (andER (x0 :e U0) (U0 :e G) HU0conj). }
    claim HU0Fam0: U0 :e Fam0.
    { exact (HGsub U0 HU0G). }
    claim Hexn0: exists n0:set, n0 :e omega /\ U0 = f n0.
    { exact (ReplE omega (fun n0:set => f n0) U0 HU0Fam0). }
    claim HpickU0: pickN U0 :e omega /\ U0 = f (pickN U0).
    { exact (Eps_i_ex (fun n0:set => n0 :e omega /\ U0 = f n0) Hexn0). }
    claim HpickU0O: pickN U0 :e omega.
    { exact (andEL (pickN U0 :e omega) (U0 = f (pickN U0)) HpickU0). }
    claim HNsetNe: Nset <> Empty.
    { apply (elem_implies_nonempty Nset (pickN U0)).
      exact (ReplI G (fun U:set => pickN U) U0 HU0G). }
    claim HAllSNo: forall y :e Nset, SNo y.
    { let y. assume Hy: y :e Nset.
      apply (ReplE_impred G (fun U:set => pickN U) y Hy (SNo y)).
      let U. assume HU: U :e G.
      assume Hey: y = pickN U.
      rewrite Hey.
      claim HUfam: U :e Fam0.
      { exact (HGsub U HU). }
      claim Hexn: exists n0:set, n0 :e omega /\ U = f n0.
      { exact (ReplE omega (fun n0:set => f n0) U HUfam). }
      claim Hpick: pickN U :e omega /\ U = f (pickN U).
      { exact (Eps_i_ex (fun n0:set => n0 :e omega /\ U = f n0) Hexn). }
      claim HpickO: pickN U :e omega.
      { exact (andEL (pickN U :e omega) (U = f (pickN U)) Hpick). }
      exact (omega_SNo (pickN U) HpickO). }
    claim Hexmax: exists nmax:set, SNo_max_of Nset nmax.
    { exact (finite_max_exists Nset (fun y Hy => HAllSNo y Hy) HNsetFin HNsetNe). }
    apply Hexmax.
    let nmax. assume Hmax.
    claim HnmaxIn: nmax :e Nset.
    { exact (andEL (nmax :e Nset) (SNo nmax) (andEL (nmax :e Nset /\ SNo nmax) (forall y :e Nset, SNo y -> y <= nmax) Hmax)). }
    claim HnmaxS: SNo nmax.
    { exact (andER (nmax :e Nset) (SNo nmax) (andEL (nmax :e Nset /\ SNo nmax) (forall y :e Nset, SNo y -> y <= nmax) Hmax)). }
    claim Hmaxprop: forall y :e Nset, SNo y -> y <= nmax.
    { exact (andER (nmax :e Nset /\ SNo nmax) (forall y :e Nset, SNo y -> y <= nmax) Hmax). }
    (** The bound is M = ordsucc nmax. **)
    set M := ordsucc nmax.
    witness M.
    apply andI.
    * claim HnmaxO: nmax :e omega.
      { apply (ReplE_impred G (fun U:set => pickN U) nmax HnmaxIn (nmax :e omega)).
        let U. assume HU: U :e G.
        assume Heq: nmax = pickN U.
        rewrite Heq.
        claim HUfam: U :e Fam0.
        { exact (HGsub U HU). }
        claim Hexn: exists n0:set, n0 :e omega /\ U = f n0.
        { exact (ReplE omega (fun n0:set => f n0) U HUfam). }
        claim Hpick: pickN U :e omega /\ U = f (pickN U).
        { exact (Eps_i_ex (fun n0:set => n0 :e omega /\ U = f n0) Hexn). }
        exact (andEL (pickN U :e omega) (U = f (pickN U)) Hpick). }
      exact (ordsucc_in_R nmax HnmaxO).
    * let x. assume HxA: x :e A.
      prove ~(Rlt M (Abs x)).
      claim HxUG: x :e Union G.
      { exact (HAcovG x HxA). }
      (** Use UnionEq via iff to extract a witness. **)
      claim HexU: exists U:set, x :e U /\ U :e G.
      { exact (iffEL (x :e Union G) (exists Y:set, x :e Y /\ Y :e G) (UnionEq G x) HxUG). }
      apply HexU.
      let U. assume HUconj.
      claim HUinG: U :e G.
      { exact (andER (x :e U) (U :e G) HUconj). }
      claim HxU: x :e U.
      { exact (andEL (x :e U) (U :e G) HUconj). }
      claim HUfam: U :e Fam0.
      { exact (HGsub U HUinG). }
      claim Hexn: exists n0:set, n0 :e omega /\ U = f n0.
      { exact (ReplE omega (fun n0:set => f n0) U HUfam). }
      claim Hpick: pickN U :e omega /\ U = f (pickN U).
      { exact (Eps_i_ex (fun n0:set => n0 :e omega /\ U = f n0) Hexn). }
      claim HnU: pickN U :e omega.
      { exact (andEL (pickN U :e omega) (U = f (pickN U)) Hpick). }
      claim HUeq: U = f (pickN U).
      { exact (andER (pickN U :e omega) (U = f (pickN U)) Hpick). }
      claim HNin: pickN U :e Nset.
      { exact (ReplI G (fun U0:set => pickN U0) U HUinG). }
      claim HNle: pickN U <= nmax.
      { exact (Hmaxprop (pickN U) HNin (omega_SNo (pickN U) HnU)). }
      claim HordsuccLe: ordsucc (pickN U) <= M.
      { (** use n<=nmax implies n+1 <= nmax+1 **)
        claim HnU_S: SNo (pickN U).
        { exact (omega_SNo (pickN U) HnU). }
        claim HnmaxO: nmax :e omega.
        { apply (ReplE_impred G (fun U0:set => pickN U0) nmax HnmaxIn (nmax :e omega)).
          let U1. assume HU1: U1 :e G.
          assume Heq: nmax = pickN U1.
          rewrite Heq.
          claim HU1fam: U1 :e Fam0.
          { exact (HGsub U1 HU1). }
          claim Hexn1: exists n0:set, n0 :e omega /\ U1 = f n0.
          { exact (ReplE omega (fun n0:set => f n0) U1 HU1fam). }
          claim Hpick1: pickN U1 :e omega /\ U1 = f (pickN U1).
          { exact (Eps_i_ex (fun n0:set => n0 :e omega /\ U1 = f n0) Hexn1). }
          exact (andEL (pickN U1 :e omega) (U1 = f (pickN U1)) Hpick1). }
        claim Hnmax_S: SNo nmax.
        { exact (omega_SNo nmax HnmaxO). }
        claim H1S: SNo 1.
        { exact SNo_1. }
        claim Hadd: add_SNo (pickN U) 1 <= add_SNo nmax 1.
        { exact (add_SNo_Le1 (pickN U) 1 nmax HnU_S H1S Hnmax_S HNle). }
        claim Hm1: add_SNo (pickN U) 1 = ordsucc (pickN U).
        { exact (add_SNo_1_ordsucc (pickN U) HnU). }
        claim Hm2: add_SNo nmax 1 = ordsucc nmax.
        { exact (add_SNo_1_ordsucc nmax HnmaxO). }
        rewrite <- Hm1.
        rewrite <- Hm2.
        exact Hadd. }
      claim HxUfn: x :e f (pickN U).
      { rewrite <- HUeq.
        exact HxU. }
      claim HxR: x :e R.
      { exact (HA x HxA). }
      claim Hxconj: Rlt (minus_SNo (ordsucc (pickN U))) x /\ Rlt x (ordsucc (pickN U)).
      { exact (SepE2 R (fun x0:set => Rlt (minus_SNo (ordsucc (pickN U))) x0 /\ Rlt x0 (ordsucc (pickN U))) x HxUfn). }
      claim HxL: Rlt (minus_SNo (ordsucc (pickN U))) x.
      { exact (andEL (Rlt (minus_SNo (ordsucc (pickN U))) x) (Rlt x (ordsucc (pickN U))) Hxconj). }
      claim HxRgt: Rlt x (ordsucc (pickN U)).
      { exact (andER (Rlt (minus_SNo (ordsucc (pickN U))) x) (Rlt x (ordsucc (pickN U))) Hxconj). }
      (** Strengthen bounds to M. **)
      (** Use interval_bounds_Abs with endpoints -M and M. **)
      claim HNsetSubOmega: Nset c= omega.
      { let y. assume Hy: y :e Nset.
        apply (ReplE_impred G (fun U0:set => pickN U0) y Hy (y :e omega)).
        let U0. assume HU0: U0 :e G.
        assume Hey: y = pickN U0.
        rewrite Hey.
        claim HU0fam: U0 :e Fam0.
        { exact (HGsub U0 HU0). }
        claim Hexn0: exists n0:set, n0 :e omega /\ U0 = f n0.
        { exact (ReplE omega (fun n0:set => f n0) U0 HU0fam). }
        claim Hpick0: pickN U0 :e omega /\ U0 = f (pickN U0).
        { exact (Eps_i_ex (fun n0:set => n0 :e omega /\ U0 = f n0) Hexn0). }
        exact (andEL (pickN U0 :e omega) (U0 = f (pickN U0)) Hpick0). }
      claim HnmaxO: nmax :e omega.
      { exact (HNsetSubOmega nmax HnmaxIn). }
      claim HM: M :e R.
      { exact (ordsucc_in_R nmax HnmaxO). }
      claim HxS: SNo x.
      { exact (real_SNo x HxR). }
      claim HM_S: SNo M.
      { exact (real_SNo M HM). }
      claim HmU: ordsucc (pickN U) :e R.
      { exact (ordsucc_in_R (pickN U) HnU). }
      claim HmU_S: SNo (ordsucc (pickN U)).
      { exact (omega_SNo (ordsucc (pickN U)) (omega_ordsucc (pickN U) HnU)). }
      claim HxltmU: x < ordsucc (pickN U).
      { exact (RltE_lt x (ordsucc (pickN U)) HxRgt). }
      claim HxltM: x < M.
      { exact (SNoLtLe_tra x (ordsucc (pickN U)) M HxS HmU_S HM_S HxltmU HordsuccLe). }
      claim HRltxM: Rlt x M.
      { exact (RltI x M HxR HM HxltM). }
      claim HnegM_R: minus_SNo M :e R.
      { exact (real_minus_SNo M HM). }
      claim HnegM_S: SNo (minus_SNo M).
      { exact (SNo_minus_SNo M HM_S). }
      claim HnegmU_S: SNo (minus_SNo (ordsucc (pickN U))).
      { exact (SNo_minus_SNo (ordsucc (pickN U)) HmU_S). }
      claim Hxgt_negmU: minus_SNo (ordsucc (pickN U)) < x.
      { exact (RltE_lt (minus_SNo (ordsucc (pickN U))) x HxL). }
      claim Hle_neg: minus_SNo M <= minus_SNo (ordsucc (pickN U)).
      { exact (minus_SNo_Le_contra (ordsucc (pickN U)) M HmU_S HM_S HordsuccLe). }
      claim HnegM_lt_x: minus_SNo M < x.
      { exact (SNoLeLt_tra (minus_SNo M) (minus_SNo (ordsucc (pickN U))) x HnegM_S HnegmU_S HxS Hle_neg Hxgt_negmU). }
      claim HRltnegMx: Rlt (minus_SNo M) x.
      { exact (RltI (minus_SNo M) x HnegM_R HxR HnegM_lt_x). }
      exact (interval_bounds_Abs M x HM HxR HRltnegMx HRltxM).
Qed.

(** from 27: compact subspaces of  are closed and bounded **) 
(** LATEX VERSION: Any compact subspace of  is closed and bounded. **)
Theorem compact_real_closed_bounded : forall A:set,
  compact_space A (subspace_topology R R_standard_topology A) ->
  closed_in R R_standard_topology A /\ bounded_subset_of_reals A.
let A.
assume Hcomp: compact_space A (subspace_topology R R_standard_topology A).
prove closed_in R R_standard_topology A /\ bounded_subset_of_reals A.
claim HtopA: topology_on A (subspace_topology R R_standard_topology A).
{ exact (andEL (topology_on A (subspace_topology R R_standard_topology A))
               (forall Fam:set, open_cover_of A (subspace_topology R R_standard_topology A) Fam ->
                  has_finite_subcover A (subspace_topology R R_standard_topology A) Fam)
               Hcomp). }
claim HAin: A :e subspace_topology R R_standard_topology A.
{ exact (topology_has_X A (subspace_topology R R_standard_topology A) HtopA). }
claim HexV: exists V :e R_standard_topology, A = V :/\: A.
{ exact (SepE2 (Power A)
               (fun U0:set => exists V :e R_standard_topology, U0 = V :/\: A)
               A HAin). }
apply HexV.
let V. assume HVpair.
claim HV: V :e R_standard_topology.
{ exact (andEL (V :e R_standard_topology) (A = V :/\: A) HVpair). }
claim HAeq: A = V :/\: A.
{ exact (andER (V :e R_standard_topology) (A = V :/\: A) HVpair). }
claim HT: topology_on R R_standard_topology.
{ exact R_standard_topology_is_topology_local. }
claim HVsubR: V c= R.
{ exact (topology_elem_subset R R_standard_topology V HT HV). }
claim HA: A c= R.
{ let x. assume HxA: x :e A.
  claim HxVA: x :e V :/\: A.
  { rewrite <- HAeq.
    exact HxA. }
  claim HxV: x :e V.
  { exact (binintersectE1 V A x HxVA). }
  exact (HVsubR x HxV). }
exact (Heine_Borel_closed_bounded A HA Hcomp).
Qed.

(** from 28 Definition: limit point compactness **) 
(** LATEX VERSION: Limit point compact means every infinite subset has a limit point in X. **)
Definition limit_point_compact : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall A:set, A c= X -> infinite A -> exists x:set, limit_point_of X Tx A x.

(** LATEX VERSION: Compact  limit point compact. **)
Theorem compact_implies_limit_point_compact : forall X Tx:set,
  compact_space X Tx -> limit_point_compact X Tx.
let X Tx.
assume Hcomp: compact_space X Tx.
prove limit_point_compact X Tx.
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam) Hcomp). }
prove topology_on X Tx /\
  forall A:set, A c= X -> infinite A -> exists x:set, limit_point_of X Tx A x.
apply andI.
- exact HTx.
- let A.
  assume HA: A c= X.
  assume HinfA: infinite A.
  prove exists x:set, limit_point_of X Tx A x.
  apply (xm (exists x:set, limit_point_of X Tx A x)).
  + assume Hex: exists x:set, limit_point_of X Tx A x.
    exact Hex.
  + assume Hnone: ~(exists x:set, limit_point_of X Tx A x).
    prove exists x:set, limit_point_of X Tx A x.
    apply FalseE.
    prove False.

    set Fam := {U :e Tx | exists x:set, x :e X /\ x :e U /\ ~(exists y:set, y :e A /\ y <> x /\ y :e U)}.

    claim HFam_in_Tx: forall U:set, U :e Fam -> U :e Tx.
    { let U. assume HU: U :e Fam.
      exact (SepE1 Tx (fun U0:set => exists x:set, x :e X /\ x :e U0 /\ ~(exists y:set, y :e A /\ y <> x /\ y :e U0)) U HU). }

    claim HFam_sub_PowX: Fam c= Power X.
    { let U. assume HU: U :e Fam.
      prove U :e Power X.
      claim HUinTx: U :e Tx.
      { exact (HFam_in_Tx U HU). }
      claim HUsubX: U c= X.
      { exact (topology_elem_subset X Tx U HTx HUinTx). }
      exact (PowerI X U HUsubX). }

    claim HX_sub_UnionFam: X c= Union Fam.
    { let x. assume HxX: x :e X.
      prove x :e Union Fam.
      claim HnotLp: ~ limit_point_of X Tx A x.
      { assume Hlp: limit_point_of X Tx A x.
        apply Hnone.
        witness x.
        exact Hlp. }

      claim HnotForall: ~(forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U).
      { assume Hall: forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
        apply HnotLp.
        prove topology_on X Tx /\ x :e X /\ forall U:set, U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
        apply andI.
        - apply andI.
          + exact HTx.
          + exact HxX.
        - exact Hall. }

      claim HexU: exists U:set, ~(U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U).
      { exact (not_all_ex_demorgan_i (fun U:set => U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U) HnotForall). }
      apply HexU.
      let U.
      assume HnotImp: ~(U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U).

      claim HUinTx: U :e Tx.
      { apply (xm (U :e Tx)).
        - assume HU: U :e Tx.
          exact HU.
        - assume HUn: U /:e Tx.
          prove U :e Tx.
          apply FalseE.
          prove False.
          claim Himp: U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
          { assume HU0: U :e Tx.
            assume _.
            apply FalseE.
            exact (HUn HU0). }
          exact (HnotImp Himp). }

      claim HxU: x :e U.
      { apply (xm (x :e U)).
        - assume Hxu: x :e U.
          exact Hxu.
        - assume HxUn: x /:e U.
          prove x :e U.
          apply FalseE.
          prove False.
          claim Himp: U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
          { assume _.
            assume Hxu: x :e U.
            apply FalseE.
            exact (HxUn Hxu). }
          exact (HnotImp Himp). }

      claim HnoY: ~(exists y:set, y :e A /\ y <> x /\ y :e U).
      { assume Hexy: exists y:set, y :e A /\ y <> x /\ y :e U.
        prove False.
        claim Himp: U :e Tx -> x :e U -> exists y:set, y :e A /\ y <> x /\ y :e U.
        { assume _. assume _. exact Hexy. }
        exact (HnotImp Himp). }

      claim HUinFam: U :e Fam.
      { apply (SepI Tx
                    (fun U0:set => exists x0:set, x0 :e X /\ x0 :e U0 /\ ~(exists y:set, y :e A /\ y <> x0 /\ y :e U0))
                    U HUinTx).
        witness x.
        apply andI.
        - apply andI.
          + exact HxX.
          + exact HxU.
        - exact HnoY. }

      exact (UnionI Fam x U HxU HUinFam). }

    claim HFam_cover: open_cover_of X Tx Fam.
    { prove topology_on X Tx /\ Fam c= Power X /\ X c= Union Fam /\ (forall U:set, U :e Fam -> U :e Tx).
      apply andI.
      - prove (topology_on X Tx /\ Fam c= Power X) /\ X c= Union Fam.
        apply andI.
        + prove topology_on X Tx /\ Fam c= Power X.
          apply andI.
          * exact HTx.
          * exact HFam_sub_PowX.
        + exact HX_sub_UnionFam.
      - exact HFam_in_Tx. }

    claim Hsub: has_finite_subcover X Tx Fam.
    { exact (Heine_Borel_subcover X Tx Fam Hcomp HFam_cover). }
    apply Hsub.
    let G.
    assume HG: G c= Fam /\ finite G /\ X c= Union G.

    claim HG1: G c= Fam /\ finite G.
    { exact (andEL (G c= Fam /\ finite G) (X c= Union G) HG). }
    claim HGsub: G c= Fam.
    { exact (andEL (G c= Fam) (finite G) HG1). }
    claim HGfin: finite G.
    { exact (andER (G c= Fam) (finite G) HG1). }
    claim HXcovG: X c= Union G.
    { exact (andER (G c= Fam /\ finite G) (X c= Union G) HG). }

    set pickX := fun U:set => Eps_i (fun x:set => x :e X /\ x :e U /\ ~(exists y:set, y :e A /\ y <> x /\ y :e U)).
    set Ximg := {pickX U|U :e G}.

    claim HXimgFin: finite Ximg.
    { exact (Repl_finite (fun U:set => pickX U) G HGfin). }

    claim HAsubXimg: A c= Ximg.
    { let a. assume HaA: a :e A.
      prove a :e Ximg.
      claim HaX: a :e X.
      { exact (HA a HaA). }
      claim HaUnionG: a :e Union G.
      { exact (HXcovG a HaX). }
      apply (UnionE_impred G a HaUnionG).
      let U.
      assume HaU: a :e U.
      assume HUinG: U :e G.

      claim HUinFam: U :e Fam.
      { exact (HGsub U HUinG). }
      claim HexxU: exists x:set, x :e X /\ x :e U /\ ~(exists y:set, y :e A /\ y <> x /\ y :e U).
      { exact (SepE2 Tx
                    (fun U0:set => exists x:set, x :e X /\ x :e U0 /\ ~(exists y:set, y :e A /\ y <> x /\ y :e U0))
                    U HUinFam). }
      claim HpickProp: pickX U :e X /\ pickX U :e U /\ ~(exists y:set, y :e A /\ y <> pickX U /\ y :e U).
      { apply HexxU.
        let x0.
        assume Hx0: x0 :e X /\ x0 :e U /\ ~(exists y:set, y :e A /\ y <> x0 /\ y :e U).
        exact (Eps_i_ax (fun x:set => x :e X /\ x :e U /\ ~(exists y:set, y :e A /\ y <> x /\ y :e U)) x0 Hx0). }

      claim HnoOther: ~(exists y:set, y :e A /\ y <> pickX U /\ y :e U).
      { exact (andER (pickX U :e X /\ pickX U :e U) (~(exists y:set, y :e A /\ y <> pickX U /\ y :e U)) HpickProp). }

      claim HaEq: a = pickX U.
      { apply (xm (a = pickX U)).
        - assume Heq: a = pickX U.
          exact Heq.
        - assume Hneq: a <> pickX U.
          prove a = pickX U.
          apply FalseE.
          prove False.
          claim Hexy: exists y:set, y :e A /\ y <> pickX U /\ y :e U.
          { witness a.
            apply andI.
            - apply andI.
              + exact HaA.
              + exact Hneq.
            - exact HaU. }
          exact (HnoOther Hexy). }

      claim HpickInImg: pickX U :e Ximg.
      { exact (ReplI G (fun U0:set => pickX U0) U HUinG). }
      rewrite HaEq.
      exact HpickInImg. }

    claim HfinA: finite A.
    { exact (Subq_finite Ximg HXimgFin A HAsubXimg). }
    exact (HinfA HfinA).
Qed.

(** from 28: limit point compactness vs compactness **) 
(** LATEX VERSION: Limit point compact need not imply compact; provides counterexample placeholder. **)
Theorem limit_point_compact_not_necessarily_compact :
  exists X Tx:set, limit_point_compact X Tx /\ ~ compact_space X Tx.
prove exists X Tx:set, limit_point_compact X Tx /\ ~ compact_space X Tx.
admit. (** standard example: the first uncountable ordinal with the order topology is limit point compact but not compact **)
Qed.

(** from 29 Definition: local compactness **) 
(** LATEX VERSION: Locally compact means each point has a neighborhood whose closure is compact. **)
Definition locally_compact : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall x:set, x :e X ->
    exists U:set, U :e Tx /\ x :e U /\
      compact_space (closure_of X Tx U) (subspace_topology X Tx (closure_of X Tx U)).

(** LATEX VERSION: In Hausdorff spaces, compact subsets are closed. **)
Theorem Hausdorff_compact_sets_closed : forall X Tx A:set,
  Hausdorff_space X Tx ->
  A c= X ->
  compact_space A (subspace_topology X Tx A) ->
  closed_in X Tx A.
let X Tx A.
assume HH: Hausdorff_space X Tx.
assume HA: A c= X.
assume Hcomp: compact_space A (subspace_topology X Tx A).
prove closed_in X Tx A.
exact (compact_subspace_in_Hausdorff_closed X Tx A HH HA Hcomp).
Qed.

(** from 29: one-point compactification placeholder **) 
(** LATEX VERSION: One-point compactification of a locally compact Hausdorff space. **)
Definition one_point_compactification : set -> set -> set -> set -> prop := fun X Tx Y Ty =>
  compact_space Y Ty /\ Hausdorff_space Y Ty /\ X c= Y /\
  exists p:set, p :e Y /\ ~ p :e X /\
    subspace_topology Y Ty X = Tx /\
    (forall y:set, y :e Y -> y :e X \/ y = p).

Theorem one_point_compactification_exists : forall X Tx:set,
  locally_compact X Tx -> Hausdorff_space X Tx ->
  exists Y Ty:set, one_point_compactification X Tx Y Ty.
let X Tx.
assume Hlc: locally_compact X Tx.
assume HH: Hausdorff_space X Tx.
prove exists Y Ty:set, one_point_compactification X Tx Y Ty.
admit. (** add point  to X; topology: opens of X plus complements of compact closed sets; verify Hausdorff and compact
        aby: ex13_2_compare_nine_topologies separation_subspace_limit_points ReplSepE conj_myprob_9697_1_20251124_035437 . **)
Qed.

(** from 29 Exercises: local compactness and compactification **) 
(** LATEX VERSION: Exercises on constructing one-point compactifications. **)
Theorem ex29_local_compactness_exercises :
  forall X Tx:set, locally_compact X Tx -> Hausdorff_space X Tx ->
  exists Y Ty:set, one_point_compactification X Tx Y Ty.
let X Tx.
assume Hlc: locally_compact X Tx.
assume HH: Hausdorff_space X Tx.
prove exists Y Ty:set, one_point_compactification X Tx Y Ty.
exact (one_point_compactification_exists X Tx Hlc HH).
Qed.

(** from exercises after 29: directed sets **)
(** LATEX VERSION: Directed set definition (nonempty, every pair has an upper bound). **)
(** FIXED: Upper bound condition was missing.
    Was: exists k:set, k :e J (k not related to i,j at all!)
    Now: exists k:set, k :e J /\ (i :e k \/ i = k) /\ (j :e k \/ j = k)
    The comment requires "every pair has an upper bound", so k must satisfy ik and jk.
    Using von Neumann ordinal ordering: ik means (i :e k \/ i = k). **)
(** SUSPICIOUS DEFINITION: This encodes the preorder on indices using membership `i :e k \/ i = k`;
    this is natural for ordinal-indexed nets, but directed sets in general topology are usually abstract posets,
    so later results may need witness translations when indices are not literal ordinals. **)
Definition directed_set : set -> prop := fun J =>
  (J <> Empty /\ forall i:set, i :e J -> ordinal i)
  /\ forall i j:set, i :e J -> j :e J ->
    exists k:set, k :e J /\ (i :e k \/ i = k) /\ (j :e k \/ j = k).

(** helper: directed sets are nonempty **)
Theorem directed_set_nonempty : forall J:set, directed_set J -> J <> Empty.
let J. assume HJ: directed_set J.
prove J <> Empty.
claim Hleft: J <> Empty /\ forall i:set, i :e J -> ordinal i.
{ exact (andEL (J <> Empty /\ forall i:set, i :e J -> ordinal i)
               (forall i j:set, i :e J -> j :e J ->
                 exists k:set, k :e J /\ (i :e k \/ i = k) /\ (j :e k \/ j = k))
               HJ). }
exact (andEL (J <> Empty) (forall i:set, i :e J -> ordinal i) Hleft).
Qed.

(** helper: elements of a directed set are ordinals **)
Theorem directed_set_ordinals : forall J:set,
  directed_set J -> forall i:set, i :e J -> ordinal i.
let J. assume HJ: directed_set J.
prove forall i:set, i :e J -> ordinal i.
let i. assume HiJ: i :e J.
claim Hleft: J <> Empty /\ forall i0:set, i0 :e J -> ordinal i0.
{ exact (andEL (J <> Empty /\ forall i0:set, i0 :e J -> ordinal i0)
               (forall i j:set, i :e J -> j :e J ->
                 exists k:set, k :e J /\ (i :e k \/ i = k) /\ (j :e k \/ j = k))
               HJ). }
claim Hord: forall i0:set, i0 :e J -> ordinal i0.
{ exact (andER (J <> Empty) (forall i0:set, i0 :e J -> ordinal i0) Hleft). }
exact (Hord i HiJ).
Qed.

(** helper: upper bound property of a directed set **)
Theorem directed_set_upper_bound_property : forall J:set,
  directed_set J ->
  forall i j:set, i :e J -> j :e J ->
    exists k:set, k :e J /\ (i :e k \/ i = k) /\ (j :e k \/ j = k).
let J. assume HJ: directed_set J.
prove forall i j:set, i :e J -> j :e J ->
  exists k:set, k :e J /\ (i :e k \/ i = k) /\ (j :e k \/ j = k).
let i j. assume HiJ: i :e J. assume HjJ: j :e J.
claim Hright:
  forall i0 j0:set, i0 :e J -> j0 :e J ->
    exists k:set, k :e J /\ (i0 :e k \/ i0 = k) /\ (j0 :e k \/ j0 = k).
{ exact (andER (J <> Empty /\ forall t:set, t :e J -> ordinal t)
               (forall i0 j0:set, i0 :e J -> j0 :e J ->
                 exists k:set, k :e J /\ (i0 :e k \/ i0 = k) /\ (j0 :e k \/ j0 = k))
               HJ). }
exact (Hright i j HiJ HjJ).
Qed.

(** helper: every element in a directed set has an upper bound in the set **)
(** LATEX VERSION: In a directed set J, for each i in J there exists k in J with i  k. **)
Theorem directed_set_upper_bound : forall J i:set,
  directed_set J -> i :e J -> exists k:set, k :e J /\ (i :e k \/ i = k).
let J i.
assume HJ: directed_set J.
assume HiJ: i :e J.
prove exists k:set, k :e J /\ (i :e k \/ i = k).
claim Hdir: forall a b:set, a :e J -> b :e J ->
  exists k:set, k :e J /\ (a :e k \/ a = k) /\ (b :e k \/ b = k).
{ exact (directed_set_upper_bound_property J HJ). }
claim Hexk: exists k:set, k :e J /\ (i :e k \/ i = k) /\ (i :e k \/ i = k).
{ exact (Hdir i i HiJ HiJ). }
apply Hexk.
let k.
assume Hk: k :e J /\ (i :e k \/ i = k) /\ (i :e k \/ i = k).
witness k.
prove k :e J /\ (i :e k \/ i = k).
claim Hk1: k :e J /\ (i :e k \/ i = k).
{ exact (andEL (k :e J /\ (i :e k \/ i = k)) (i :e k \/ i = k) Hk). }
exact Hk1.
Qed.

(** helper: upper bound for two elements in a directed set **)
(** LATEX VERSION: In a directed set J, for i,j in J there exists k in J with i  k and j  k. **)
Theorem directed_set_pair_upper_bound : forall J i j:set,
  directed_set J -> i :e J -> j :e J ->
  exists k:set, k :e J /\ (i :e k \/ i = k) /\ (j :e k \/ j = k).
let J i j.
assume HJ: directed_set J.
assume HiJ: i :e J.
assume HjJ: j :e J.
prove exists k:set, k :e J /\ (i :e k \/ i = k) /\ (j :e k \/ j = k).
claim Hdir: forall a b:set, a :e J -> b :e J ->
  exists k:set, k :e J /\ (a :e k \/ a = k) /\ (b :e k \/ b = k).
{ exact (directed_set_upper_bound_property J HJ). }
exact (Hdir i j HiJ HjJ).
Qed.

(** from exercises after 29: examples of directed sets **) 
(** LATEX VERSION: Simple closure properties/examples of directed sets (placeholder). **)
Theorem examples_of_directed_sets : forall J:set,
  directed_set J -> directed_set J.
let J.
assume H: directed_set J.
prove directed_set J.
exact H.
Qed.

(** from exercises after 29: cofinal subsets of directed sets are directed **)
(** LATEX VERSION: Cofinal subset of a directed set is directed. **)
(** FIXED: Cofinality condition was trivially true.
    Was: exists k, (k :e K /\ i :e K) \/ i :e J (trivially true since i :e J assumed)
    Now: exists k, k :e K /\ (i :e k \/ i = k) (k in K is upper bound of i)
    Cofinality means every element of J has an upper bound in K. **)
Theorem cofinal_subset_directed : forall J K:set,
  directed_set J -> K c= J ->
  (forall i:set, i :e J -> exists k:set, k :e K /\ (i :e k \/ i = k)) ->
  directed_set K.
let J K.
assume HJ: directed_set J.
assume HK: K c= J.
assume Hcofinal: forall i:set, i :e J -> exists k:set, k :e K /\ (i :e k \/ i = k).
prove directed_set K.
prove (K <> Empty /\ forall i:set, i :e K -> ordinal i)
  /\ forall i j:set, i :e K -> j :e K ->
    exists k:set, k :e K /\ (i :e k \/ i = k) /\ (j :e k \/ j = k).
apply andI.
- (** K is nonempty and all its elements are ordinals **)
  prove K <> Empty /\ forall i:set, i :e K -> ordinal i.
  apply andI.
  + (** nonempty **)
    assume HK0: K = Empty.
    prove False.
    claim HJ0: J <> Empty.
    { exact (directed_set_nonempty J HJ). }
    claim Hexj: exists j0:set, j0 :e J.
    { exact (nonempty_has_element J HJ0). }
    apply Hexj.
    let j0. assume Hj0: j0 :e J.
    claim Hexk: exists k:set, k :e K /\ (j0 :e k \/ j0 = k).
    { exact (Hcofinal j0 Hj0). }
    apply Hexk.
    let k. assume Hkpair.
    claim HkK: k :e K.
    { exact (andEL (k :e K) (j0 :e k \/ j0 = k) Hkpair). }
    claim HkE: k :e Empty.
    { rewrite <- HK0. exact HkK. }
    exact (EmptyE k HkE).
  + (** ordinals **)
    let i. assume HiK: i :e K.
    claim HiJ: i :e J.
    { exact (HK i HiK). }
    exact (directed_set_ordinals J HJ i HiJ).
- (** upper bound in K from directedness in J and cofinality **)
  let i j.
  assume HiK: i :e K.
  assume HjK: j :e K.
  prove exists k:set, k :e K /\ (i :e k \/ i = k) /\ (j :e k \/ j = k).
  claim HiJ: i :e J.
  { exact (HK i HiK). }
  claim HjJ: j :e J.
  { exact (HK j HjK). }
  claim Hexm: exists m:set, m :e J /\ (i :e m \/ i = m) /\ (j :e m \/ j = m).
  { exact (directed_set_upper_bound_property J HJ i j HiJ HjJ). }
  apply Hexm.
  let m. assume Hmpair.
  claim Hmleft: (m :e J /\ (i :e m \/ i = m)).
  { exact (andEL (m :e J /\ (i :e m \/ i = m))
                 (j :e m \/ j = m)
                 Hmpair). }
  claim HmJ: m :e J.
  { exact (andEL (m :e J) (i :e m \/ i = m) Hmleft). }
  claim Him: i :e m \/ i = m.
  { exact (andER (m :e J) (i :e m \/ i = m) Hmleft). }
  claim Hjm: j :e m \/ j = m.
  { exact (andER (m :e J /\ (i :e m \/ i = m))
                 (j :e m \/ j = m)
                 Hmpair). }
  claim Hexk0: exists k0:set, k0 :e K /\ (m :e k0 \/ m = k0).
  { exact (Hcofinal m HmJ). }
  apply Hexk0.
  let k0. assume Hk0pair.
  claim Hk0K: k0 :e K.
  { exact (andEL (k0 :e K) (m :e k0 \/ m = k0) Hk0pair). }
  claim Hmk0: m :e k0 \/ m = k0.
  { exact (andER (k0 :e K) (m :e k0 \/ m = k0) Hk0pair). }
  witness k0.
  prove k0 :e K /\ (i :e k0 \/ i = k0) /\ (j :e k0 \/ j = k0).
  apply andI.
  - (** k0 in K and i  k0 **)
    apply andI.
    + exact Hk0K.
    + (** i  k0 **)
      apply (Him (i :e k0 \/ i = k0)).
      * (** case i :e m **)
        assume Himem: i :e m.
        apply (Hmk0 (i :e k0 \/ i = k0)).
        { assume Hmink0: m :e k0.
          claim Hk0J: k0 :e J.
          { exact (HK k0 Hk0K). }
          claim Hordk0: ordinal k0.
          { exact (directed_set_ordinals J HJ k0 Hk0J). }
          claim Htransk0: TransSet k0.
          { exact (ordinal_TransSet k0 Hordk0). }
          claim HmSub: m c= k0.
          { exact (Htransk0 m Hmink0). }
          exact (orIL (i :e k0) (i = k0) (HmSub i Himem)). }
        { assume Hmeq: m = k0.
          rewrite <- Hmeq.
          exact (orIL (i :e m) (i = m) Himem). }
      * (** case i = m **)
        assume Hieq: i = m.
        apply (Hmk0 (i :e k0 \/ i = k0)).
        { assume Hmink0: m :e k0.
          rewrite Hieq.
          exact (orIL (m :e k0) (m = k0) Hmink0). }
        { assume Hmeq: m = k0.
          rewrite Hieq.
          exact (orIR (m :e k0) (m = k0) Hmeq). }
  - (** j  k0 **)
    apply (Hjm (j :e k0 \/ j = k0)).
      * (** case j :e m **)
        assume Hjmem: j :e m.
        apply (Hmk0 (j :e k0 \/ j = k0)).
        { assume Hmink0: m :e k0.
          claim Hk0J: k0 :e J.
          { exact (HK k0 Hk0K). }
          claim Hordk0: ordinal k0.
          { exact (directed_set_ordinals J HJ k0 Hk0J). }
          claim Htransk0: TransSet k0.
          { exact (ordinal_TransSet k0 Hordk0). }
          claim HmSub: m c= k0.
          { exact (Htransk0 m Hmink0). }
          exact (orIL (j :e k0) (j = k0) (HmSub j Hjmem)). }
        { assume Hmeq: m = k0.
          rewrite <- Hmeq.
          exact (orIL (j :e m) (j = m) Hjmem). }
      * (** case j = m **)
        assume Hjeq: j = m.
        apply (Hmk0 (j :e k0 \/ j = k0)).
        { assume Hmink0: m :e k0.
          rewrite Hjeq.
          exact (orIL (m :e k0) (m = k0) Hmink0). }
        { assume Hmeq: m = k0.
          rewrite Hjeq.
          exact (orIR (m :e k0) (m = k0) Hmeq). }
Qed.

(** from exercises after 29: nets as functions from directed sets **) 
(** LATEX VERSION: A net is a function from a directed set into a space. **)
Definition net_on : set -> prop := fun net =>
  exists J X:set, directed_set J /\ function_on net J X.

(** from exercises after 29: subnet definition placeholder **)
(** LATEX VERSION: Definition of subnet (Exercise, placeholder formalization). **)
(** FIXED: Lines 16152-16153 had nonsensical condition making phi constant.
    Was: forall k1 k2:set, k1 :e K -> k2 :e K -> exists k3:set,
           k3 :e K /\ apply_fun phi k3 = apply_fun phi k1 /\ apply_fun phi k3 = apply_fun phi k2
         This says phi(k3) = phi(k1) AND phi(k3) = phi(k2), so phi(k1) = phi(k2) for ALL k1, k2,
         making phi constant!
    Now: forall j:set, j :e J -> exists k0:set, k0 :e K /\
           forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
             (j :e apply_fun phi k \/ j = apply_fun phi k)
         This is the cofinality condition: for every j  J, eventually phi(k)  j.
    Also: subnet values are forced to land in the same space X as the original net:
      apply_fun sub k = apply_fun net (apply_fun phi k). **)
(** SUSPICIOUS DEFINITION: `subnet_of` packages a shared codomain and a cofinal map;
    since `net_converges` existentially quantifies the index set, connecting convergence and subnet data can require a witness-alignment lemma. **)
Definition subnet_of : set -> set -> prop := fun net sub =>
  exists J K X phi:set,
    directed_set J /\ directed_set K /\
    function_on net J X /\ function_on sub K X /\
    function_on phi K J /\
    (forall j:set, j :e J -> exists k0:set, k0 :e K /\
      forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
        (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
    (forall k:set, k :e K ->
      apply_fun sub k = apply_fun net (apply_fun phi k)).

(** helper: a subnet is a net **)
(** LATEX VERSION: Any subnet is itself a net on some directed set. **)
Theorem subnet_implies_net_on : forall net sub:set, subnet_of net sub -> net_on sub.
let net sub.
assume Hsub: subnet_of net sub.
prove net_on sub.
apply Hsub.
let J. assume Hrest: exists K X phi:set,
  directed_set J /\ directed_set K /\
  function_on net J X /\ function_on sub K X /\
  function_on phi K J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).
apply Hrest.
let K. assume Hrest2: exists X phi:set,
  directed_set J /\ directed_set K /\
  function_on net J X /\ function_on sub K X /\
  function_on phi K J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).
apply Hrest2.
let X. assume Hrest3: exists phi:set,
  directed_set J /\ directed_set K /\
  function_on net J X /\ function_on sub K X /\
  function_on phi K J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).
apply Hrest3.
let phi. assume Hdata:
  directed_set J /\ directed_set K /\
  function_on net J X /\ function_on sub K X /\
  function_on phi K J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).
prove exists J0 X0:set, directed_set J0 /\ function_on sub J0 X0.
witness K.
witness X.
prove directed_set K /\ function_on sub K X.
(** destruct subnet_of data by repeated conjunction elimination **)
apply Hdata.
assume Hcore Heq.
apply Hcore.
assume Hcore2 Hcofinal.
apply Hcore2.
assume Hcore3 Hphi_on.
apply Hcore3.
assume Hcore4 Hsubfun.
apply Hcore4.
assume HJK Hnetfun.
apply HJK.
assume HdirJ HdirK.
apply andI.
- exact HdirK.
- exact Hsubfun.
Qed.

(** helper: if sub is a subnet, net is a net **)
(** LATEX VERSION: The original function in a subnet pair is also a net. **)
Theorem subnet_implies_net_on_source : forall net sub:set, subnet_of net sub -> net_on net.
let net sub.
assume Hsub: subnet_of net sub.
prove net_on net.
apply Hsub.
let J. assume Hrest: exists K X phi:set,
  directed_set J /\ directed_set K /\
  function_on net J X /\ function_on sub K X /\
  function_on phi K J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).
apply Hrest.
let K. assume Hrest2: exists X phi:set,
  directed_set J /\ directed_set K /\
  function_on net J X /\ function_on sub K X /\
  function_on phi K J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).
apply Hrest2.
let X. assume Hrest3: exists phi:set,
  directed_set J /\ directed_set K /\
  function_on net J X /\ function_on sub K X /\
  function_on phi K J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).
apply Hrest3.
let phi. assume Hdata:
  directed_set J /\ directed_set K /\
  function_on net J X /\ function_on sub K X /\
  function_on phi K J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).
prove exists J0 X0:set, directed_set J0 /\ function_on net J0 X0.
witness J.
witness X.
prove directed_set J /\ function_on net J X.
apply Hdata.
assume Hcore Heq.
apply Hcore.
assume Hcore2 Hcofinal.
apply Hcore2.
assume Hcore3 Hphi_on.
apply Hcore3.
assume Hcore4 Hsubfun.
apply Hcore4.
assume HJK Hnetfun.
apply HJK.
assume HdirJ HdirK.
apply andI.
- exact HdirJ.
- exact Hnetfun.
Qed.

(** helper: a net is a subnet of itself **)
(** LATEX VERSION: Every net is a subnet of itself via the identity index map. **)
Theorem subnet_of_refl_witnessed : forall J X net:set,
  directed_set J -> function_on net J X -> subnet_of net net.
let J X net.
assume HdirJ: directed_set J.
assume Hnetfun: function_on net J X.
prove subnet_of net net.
prove exists J0 K0 X0 phi:set,
  directed_set J0 /\ directed_set K0 /\
  function_on net J0 X0 /\ function_on net K0 X0 /\
  function_on phi K0 J0 /\
  (forall j:set, j :e J0 -> exists k0:set, k0 :e K0 /\
    forall k:set, k :e K0 -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K0 ->
    apply_fun net k = apply_fun net (apply_fun phi k)).
witness J.
witness J.
witness X.
set phi := {(y,y) | y :e J}.
witness phi.
prove directed_set J /\ directed_set J /\
  function_on net J X /\ function_on net J X /\
  function_on phi J J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e J /\
    forall k:set, k :e J -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e J ->
    apply_fun net k = apply_fun net (apply_fun phi k)).
apply andI.
- (** P: ((((directed_set /\ directed_set) /\ fun /\ fun) /\ phi_on) /\ cofinal) **)
  apply andI.
  + (** R: (((directed_set /\ directed_set) /\ fun /\ fun) /\ phi_on) **)
    apply andI.
    * (** S: ((directed_set /\ directed_set) /\ fun) /\ fun **)
      apply andI.
      { (** T: (directed_set /\ directed_set) /\ fun **)
        apply andI.
        - (** U: directed_set /\ directed_set **)
          apply andI.
          + exact HdirJ.
          + exact HdirJ.
        - exact Hnetfun. }
      { exact Hnetfun. }
    * (** function_on phi J J **)
      let k. assume HkJ: k :e J.
      prove apply_fun phi k :e J.
      claim Hphi: apply_fun phi k = k.
      { exact (identity_function_apply J k HkJ). }
      rewrite Hphi.
      exact HkJ.
  + (** cofinality via identity **)
    let j. assume HjJ: j :e J.
    witness j.
    prove j :e J /\
      forall k:set, k :e J -> (j :e k \/ j = k) ->
        (j :e apply_fun phi k \/ j = apply_fun phi k).
    apply andI.
    - exact HjJ.
    - let k. assume HkJ: k :e J. assume Hjle: j :e k \/ j = k.
      claim Hphi: apply_fun phi k = k.
      { exact (identity_function_apply J k HkJ). }
      rewrite Hphi.
      exact Hjle.
- (** pointwise equality net = net o phi **)
  let k. assume HkJ: k :e J.
  claim Hphi: apply_fun phi k = k.
  { exact (identity_function_apply J k HkJ). }
  rewrite Hphi.
  reflexivity.
Qed.

(** helper: if net_on net then subnet_of net net **)
(** LATEX VERSION: Every net admits the trivial subnet given by itself. **)
Theorem subnet_of_refl : forall net:set, net_on net -> subnet_of net net.
let net. assume Hnet: net_on net.
prove subnet_of net net.
apply Hnet.
let J. assume Hrest: exists X:set, directed_set J /\ function_on net J X.
apply Hrest.
let X. assume HJX: directed_set J /\ function_on net J X.
claim HdirJ: directed_set J.
{ exact (andEL (directed_set J) (function_on net J X) HJX). }
claim Hfun: function_on net J X.
{ exact (andER (directed_set J) (function_on net J X) HJX). }
exact (subnet_of_refl_witnessed J X net HdirJ Hfun).
Qed.

(** from exercises after 29: accumulation point of a net **)
(** LATEX VERSION: An accumulation point of a net means every neighborhood contains infinitely many (or cofinal) net points; placeholder formalization. **)
(** FIXED: Multiple critical errors:
    1. Missing topology parameter Tx (was 3-ary, now 4-ary)
    2. Was quantifying over all sets U (x :e U), not just open sets (U :e Tx -> x :e U)
    3. Was saying "exists one i", not "cofinally many i" (now: forall j0, exists j  j0)
    Was: fun X net x => ... forall U:set, x :e U -> exists i:set, ...
    Now: fun X Tx net x => ... forall U:set, U :e Tx -> x :e U ->
                                  forall j0:set, j0 :e J -> exists j:set, j :e J /\ (j0 :e j \/ j0 = j) /\ ...
    This captures "cofinally many net points in every neighborhood".
    Also: the net is treated as a function into the ambient space X (no extra codomain parameter). **)
(** SUSPICIOUS DEFINITION: The order on directed sets is represented using membership `j0 :e j \/ j0 = j`;
    this is convenient for ordinal index sets, but can make later subnet arguments need witness alignment lemmas. **)
Definition accumulation_point_of_net : set -> set -> set -> set -> prop := fun X Tx net x =>
  exists J:set, topology_on X Tx /\ directed_set J /\ function_on net J X /\ x :e X /\
    forall U:set, U :e Tx -> x :e U ->
      forall j0:set, j0 :e J ->
        exists j:set, j :e J /\ (j0 :e j \/ j0 = j) /\ apply_fun net j :e U.

(** from exercises after 29: net convergence **)
(** LATEX VERSION: A net converges to x if eventually in every neighborhood U of x. **)
(** FIXED: Definition was wrong - said "exists i such that net(i)  U" instead of
    "eventually all net(i) are in U".
    Was: forall U:set, U :e Tx -> x :e U -> exists i:set, i :e J /\ apply_fun net i :e U
         (for every open U containing x, there exists ONE point net(i) in U)
    Now: forall U:set, U :e Tx -> x :e U ->
           exists i0:set, i0 :e J /\ forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U
         (for every open U containing x, eventually all net(i) for i  i0 are in U)
    The ordering i0  i is von Neumann: (i0 :e i \/ i0 = i). **)
(** SUSPICIOUS DEFINITION: As above, this uses membership-based comparison on the index set; it is adequate for ordinal-indexed nets but may require extra axioms for arbitrary directed sets. **)
Definition net_converges : set -> set -> set -> set -> prop := fun X Tx net x =>
  exists J:set, topology_on X Tx /\ directed_set J /\ function_on net J X /\ x :e X /\
    forall U:set, U :e Tx -> x :e U ->
      exists i0:set, i0 :e J /\
        forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U.

(** helper: convergent nets have accumulation points at the limit **)
(** LATEX VERSION: If a net converges to x, then x is an accumulation point of the net. **)
Theorem net_converges_implies_accumulation_point : forall X Tx net x:set,
  net_converges X Tx net x -> accumulation_point_of_net X Tx net x.
let X Tx net x.
assume Hconv: net_converges X Tx net x.
prove accumulation_point_of_net X Tx net x.
apply Hconv.
let J.
assume HJ:
  topology_on X Tx /\ directed_set J /\ function_on net J X /\ x :e X /\
    forall U:set, U :e Tx -> x :e U ->
      exists i0:set, i0 :e J /\
        forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U.
prove accumulation_point_of_net X Tx net x.
prove exists J0:set, topology_on X Tx /\ directed_set J0 /\ function_on net J0 X /\ x :e X /\
  forall U:set, U :e Tx -> x :e U ->
    forall j0:set, j0 :e J0 ->
      exists j:set, j :e J0 /\ (j0 :e j \/ j0 = j) /\ apply_fun net j :e U.
witness J.
claim Hcore:
  topology_on X Tx /\ directed_set J /\ function_on net J X /\ x :e X.
{ exact (andEL (topology_on X Tx /\ directed_set J /\ function_on net J X /\ x :e X)
               (forall U:set, U :e Tx -> x :e U ->
                 exists i0:set, i0 :e J /\
                   forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U)
               HJ). }
claim Htail:
  forall U:set, U :e Tx -> x :e U ->
    exists i0:set, i0 :e J /\
      forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U.
{ exact (andER (topology_on X Tx /\ directed_set J /\ function_on net J X /\ x :e X)
               (forall U:set, U :e Tx -> x :e U ->
                 exists i0:set, i0 :e J /\
                   forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U)
               HJ). }
claim Htopdirfun:
  topology_on X Tx /\ directed_set J /\ function_on net J X.
{ exact (andEL (topology_on X Tx /\ directed_set J /\ function_on net J X)
               (x :e X)
               Hcore). }
claim HTd: topology_on X Tx /\ directed_set J.
{ exact (andEL (topology_on X Tx /\ directed_set J)
               (function_on net J X)
               Htopdirfun). }
claim HdirJ: directed_set J.
{ exact (andER (topology_on X Tx) (directed_set J) HTd). }
claim HfunJ: function_on net J X.
{ exact (andER (topology_on X Tx /\ directed_set J)
               (function_on net J X)
               Htopdirfun). }
claim HxX: x :e X.
{ exact (andER (topology_on X Tx /\ directed_set J /\ function_on net J X)
               (x :e X)
               Hcore). }
prove topology_on X Tx /\ directed_set J /\ function_on net J X /\ x :e X /\
  forall U:set, U :e Tx -> x :e U ->
    forall j0:set, j0 :e J ->
      exists j:set, j :e J /\ (j0 :e j \/ j0 = j) /\ apply_fun net j :e U.
apply andI.
- exact Hcore.
- let U.
  assume HU: U :e Tx.
  assume HxU: x :e U.
  prove forall j0:set, j0 :e J ->
    exists j:set, j :e J /\ (j0 :e j \/ j0 = j) /\ apply_fun net j :e U.
  let j0. assume Hj0: j0 :e J.
  claim Hexi0:
    exists i0:set, i0 :e J /\
      forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U.
  { exact (Htail U HU HxU). }
  apply Hexi0.
  let i0. assume Hi0pair.
  claim Hi0J: i0 :e J.
  { exact (andEL (i0 :e J)
                 (forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U)
                 Hi0pair). }
  claim Hi0tail:
    forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U.
  { exact (andER (i0 :e J)
                 (forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U)
                 Hi0pair). }
  claim Hexk: exists k:set, k :e J /\ (i0 :e k \/ i0 = k) /\ (j0 :e k \/ j0 = k).
  { exact (directed_set_pair_upper_bound J i0 j0 HdirJ Hi0J Hj0). }
  apply Hexk.
  let k. assume Hkpair.
  claim Hkleft: k :e J /\ (i0 :e k \/ i0 = k).
  { exact (andEL (k :e J /\ (i0 :e k \/ i0 = k))
                 (j0 :e k \/ j0 = k)
                 Hkpair). }
  claim HkJ: k :e J.
  { exact (andEL (k :e J) (i0 :e k \/ i0 = k) Hkleft). }
  claim Hi0k: i0 :e k \/ i0 = k.
  { exact (andER (k :e J) (i0 :e k \/ i0 = k) Hkleft). }
  claim Hj0k: j0 :e k \/ j0 = k.
  { exact (andER (k :e J /\ (i0 :e k \/ i0 = k))
                 (j0 :e k \/ j0 = k)
                 Hkpair). }
  witness k.
  prove (k :e J /\ (j0 :e k \/ j0 = k)) /\ apply_fun net k :e U.
  apply andI.
  - apply andI.
    + exact HkJ.
    + exact Hj0k.
  - exact (Hi0tail k HkJ Hi0k).
Qed.

(** helper: any convergent net is a net_on **)
(** LATEX VERSION: If a net converges, then it is a net (it has some directed index set). **)
Theorem net_converges_implies_net_on : forall X Tx net x:set,
  net_converges X Tx net x -> net_on net.
let X Tx net x.
assume H: net_converges X Tx net x.
prove net_on net.
apply H.
let J.
assume HJ: topology_on X Tx /\ directed_set J /\ function_on net J X /\ x :e X /\
  forall U:set, U :e Tx -> x :e U ->
    exists i0:set, i0 :e J /\
      forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U.
prove net_on net.
prove exists J0 X0:set, directed_set J0 /\ function_on net J0 X0.
witness J.
witness X.
claim HJJ: topology_on X Tx /\ directed_set J /\ function_on net J X /\ x :e X.
{ exact (andEL (topology_on X Tx /\ directed_set J /\ function_on net J X /\ x :e X)
               (forall U:set, U :e Tx -> x :e U ->
                 exists i0:set, i0 :e J /\
                   forall i:set, i :e J -> (i0 :e i \/ i0 = i) -> apply_fun net i :e U)
               HJ). }
claim HJdirfun: topology_on X Tx /\ directed_set J /\ function_on net J X.
{ exact (andEL (topology_on X Tx /\ directed_set J /\ function_on net J X) (x :e X) HJJ). }
claim HJdir: topology_on X Tx /\ directed_set J.
{ exact (andEL (topology_on X Tx /\ directed_set J) (function_on net J X) HJdirfun). }
claim HdirJ: directed_set J.
{ exact (andER (topology_on X Tx) (directed_set J) HJdir). }
claim HfunJ: function_on net J X.
{ exact (andER (topology_on X Tx /\ directed_set J) (function_on net J X) HJdirfun). }
exact (andI (directed_set J) (function_on net J X) HdirJ HfunJ).
Qed.

(** from exercises after 29: convergence of subnets **) 
(** LATEX VERSION: Convergent nets have convergent subnets to same limit. **)
Theorem subnet_preserves_convergence : forall X Tx net sub x:set,
  net_converges X Tx net x -> subnet_of net sub -> net_converges X Tx sub x.
let X Tx net sub x.
assume Hnet: net_converges X Tx net x.
assume Hsub: subnet_of net sub.
prove net_converges X Tx sub x.
(** We prove the subnet convergence once convergence and subnet data share the same index set J.
    With the current encoding, a net does not store its index set, so Hnet and Hsub may
    produce unrelated J-witnesses; the missing bridge is isolated below. **)
apply Hsub.
let J.
assume HKXphi: exists K X0 phi:set,
  directed_set J /\ directed_set K /\
  function_on net J X0 /\ function_on sub K X0 /\
  function_on phi K J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).
apply HKXphi.
let K.
assume HXphi: exists X0 phi:set,
  directed_set J /\ directed_set K /\
  function_on net J X0 /\ function_on sub K X0 /\
  function_on phi K J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).
apply HXphi.
let X0.
assume Hphi: exists phi:set,
  directed_set J /\ directed_set K /\
  function_on net J X0 /\ function_on sub K X0 /\
  function_on phi K J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).
apply Hphi.
let phi.
assume Hsubdata:
  directed_set J /\ directed_set K /\
  function_on net J X0 /\ function_on sub K X0 /\
  function_on phi K J /\
  (forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k)) /\
  (forall k:set, k :e K ->
    apply_fun sub k = apply_fun net (apply_fun phi k)).

(** Missing bridge:
    derive a convergence witness on the J coming from the subnet data. **)
admit. (** ADMITTED: witness index mismatch between net_converges and subnet_of **)
Qed.

(** helper: subnet preserves convergence for fixed index set witnesses **)
(** LATEX VERSION: If net converges along J and sub is obtained by a cofinal map phi:KJ, then sub converges. **)
Theorem subnet_preserves_convergence_witnessed :
  forall X Tx net sub x J K phi:set,
    topology_on X Tx ->
    directed_set J ->
    directed_set K ->
    function_on net J X ->
    function_on phi K J ->
    (forall j:set, j :e J -> exists k0:set, k0 :e K /\
      forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
        (j :e apply_fun phi k \/ j = apply_fun phi k)) ->
    (forall k:set, k :e K ->
      apply_fun sub k = apply_fun net (apply_fun phi k)) ->
    x :e X ->
    (forall U:set, U :e Tx -> x :e U ->
      exists j0:set, j0 :e J /\
        forall j:set, j :e J -> (j0 :e j \/ j0 = j) ->
          apply_fun net j :e U) ->
    net_converges X Tx sub x.
let X Tx net sub x J K phi.
assume HTx: topology_on X Tx.
assume HdirJ: directed_set J.
assume HdirK: directed_set K.
assume Hnetfun: function_on net J X.
assume Hphi: function_on phi K J.
assume Hcofinal:
  forall j:set, j :e J -> exists k0:set, k0 :e K /\
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j :e apply_fun phi k \/ j = apply_fun phi k).
assume Hsubeq:
  forall k:set, k :e K -> apply_fun sub k = apply_fun net (apply_fun phi k).
assume HxX: x :e X.
assume Htail:
  forall U:set, U :e Tx -> x :e U ->
    exists j0:set, j0 :e J /\
      forall j:set, j :e J -> (j0 :e j \/ j0 = j) ->
        apply_fun net j :e U.
prove net_converges X Tx sub x.
prove exists J0:set, topology_on X Tx /\ directed_set J0 /\ function_on sub J0 X /\ x :e X /\
  forall U:set, U :e Tx -> x :e U ->
    exists i0:set, i0 :e J0 /\
      forall i:set, i :e J0 -> (i0 :e i \/ i0 = i) -> apply_fun sub i :e U.
witness K.
apply andI.
- apply andI.
  * apply andI.
    { apply andI.
      - exact HTx.
      - exact HdirK. }
    { (** function_on sub K X **)
      let k. assume HkK: k :e K.
      prove apply_fun sub k :e X.
      claim Hsubk: apply_fun sub k = apply_fun net (apply_fun phi k).
      { exact (Hsubeq k HkK). }
      rewrite Hsubk.
      claim HphikJ: apply_fun phi k :e J.
      { exact (Hphi k HkK). }
      exact (Hnetfun (apply_fun phi k) HphikJ). }
  * exact HxX.
- let U.
  assume HU: U :e Tx.
  assume HxU: x :e U.
  prove exists i0:set, i0 :e K /\
    forall i:set, i :e K -> (i0 :e i \/ i0 = i) -> apply_fun sub i :e U.
  claim Hexj0:
    exists j0:set, j0 :e J /\
      forall j:set, j :e J -> (j0 :e j \/ j0 = j) -> apply_fun net j :e U.
  { exact (Htail U HU HxU). }
  apply Hexj0.
  let j0. assume Hj0pair.
  claim Hj0J: j0 :e J.
  { exact (andEL (j0 :e J)
                 (forall j:set, j :e J -> (j0 :e j \/ j0 = j) -> apply_fun net j :e U)
                 Hj0pair). }
  claim Hj0tail:
    forall j:set, j :e J -> (j0 :e j \/ j0 = j) -> apply_fun net j :e U.
  { exact (andER (j0 :e J)
                 (forall j:set, j :e J -> (j0 :e j \/ j0 = j) -> apply_fun net j :e U)
                 Hj0pair). }
  claim Hexk0:
    exists k0:set, k0 :e K /\
      forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
        (j0 :e apply_fun phi k \/ j0 = apply_fun phi k).
  { exact (Hcofinal j0 Hj0J). }
  apply Hexk0.
  let k0. assume Hk0pair.
  claim Hk0K: k0 :e K.
  { exact (andEL (k0 :e K)
                 (forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
                    (j0 :e apply_fun phi k \/ j0 = apply_fun phi k))
                 Hk0pair). }
  claim Hk0prop:
    forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
      (j0 :e apply_fun phi k \/ j0 = apply_fun phi k).
  { exact (andER (k0 :e K)
                 (forall k:set, k :e K -> (k0 :e k \/ k0 = k) ->
                    (j0 :e apply_fun phi k \/ j0 = apply_fun phi k))
                 Hk0pair). }
  witness k0.
  apply andI.
  - exact Hk0K.
  - let k. assume HkK: k :e K.
    assume Hk0k: k0 :e k \/ k0 = k.
    prove apply_fun sub k :e U.
    claim Hj0phik: j0 :e apply_fun phi k \/ j0 = apply_fun phi k.
    { exact (Hk0prop k HkK Hk0k). }
    claim HphikJ: apply_fun phi k :e J.
    { exact (Hphi k HkK). }
    claim HnetU: apply_fun net (apply_fun phi k) :e U.
    { exact (Hj0tail (apply_fun phi k) HphikJ Hj0phik). }
    claim Hsubk: apply_fun sub k = apply_fun net (apply_fun phi k).
    { exact (Hsubeq k HkK). }
    rewrite Hsubk.
    exact HnetU.
Qed.

(** from exercises after 29: closure via nets **) 
(** LATEX VERSION: Closure characterized by existence of a convergent net. **)
Theorem closure_via_nets : forall X Tx A x:set,
  topology_on X Tx ->
  (x :e closure_of X Tx A <-> exists net:set, net_on net /\ net_converges X Tx net x).
let X Tx A x.
assume HTx: topology_on X Tx.
prove x :e closure_of X Tx A <-> exists net:set, net_on net /\ net_converges X Tx net x.
admit. (** x in closure iff every nbhd meets A; construct net from A; converges to x **)
Qed.

(** from exercises after 29: continuity via nets **)
(** LATEX VERSION: Continuity iff every convergent net's image converges. **)
(** FIXED: Net composition and convergence point errors.
    Was: forall net, net_on net -> ... -> net_converges Y Ty net (Empty)
    Issues: (1) net : JX but should be fnet : JY
            (2) converges to Empty instead of f(x)
    Now: Make J explicit to use compose_fun J net f, and converge to apply_fun f x
    The comment confirms: "f continuous iff for all nets x_ix, have f(x_i)f(x)" **)
Theorem continuity_via_nets : forall X Tx Y Ty f:set,
  topology_on X Tx -> topology_on Y Ty ->
  (continuous_map X Tx Y Ty f <->
    forall J X0 net:set, directed_set J -> function_on net J X0 ->
      forall x:set, net_converges X Tx net x ->
        net_converges Y Ty (compose_fun J net f) (apply_fun f x)).
let X Tx Y Ty f.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove continuous_map X Tx Y Ty f <->
    forall J X0 net:set, directed_set J -> function_on net J X0 ->
      forall x:set, net_converges X Tx net x ->
        net_converges Y Ty (compose_fun J net f) (apply_fun f x).
admit. (** f continuous iff for all nets x_ix, have f(x_i)f(x); use net characterization of convergence **)
Qed.

(** from exercises after 29: accumulation points and subnets **)
(** LATEX VERSION: Every accumulation point of a net has a subnet converging to it. **)
Theorem subnet_converges_to_accumulation : forall X Tx net x:set,
  accumulation_point_of_net X Tx net x -> exists sub:set, subnet_of net sub /\ net_converges X Tx sub x.
let X Tx net x.
assume Hacc: accumulation_point_of_net X Tx net x.
prove exists sub:set, subnet_of net sub /\ net_converges X Tx sub x.
admit. (** accumulation point: net frequently in every nbhd; construct subnet converging to x **)
Qed.

(** from exercises after 29: compactness via nets **) 
(** LATEX VERSION: Compactness characterized by every net having a convergent subnet. **)
Theorem compact_iff_every_net_has_convergent_subnet : forall X Tx:set,
  topology_on X Tx ->
  (compact_space X Tx <-> forall net:set, net_on net -> exists sub x:set, subnet_of net sub /\ net_converges X Tx sub x).
let X Tx.
assume HTx: topology_on X Tx.
prove compact_space X Tx <-> forall net:set, net_on net -> exists sub x:set, subnet_of net sub /\ net_converges X Tx sub x.
admit. (** use Alexander subbase lemma or direct: accumulation points exist in compact spaces **)
Qed.

(** from 30 Definition 30.1: countable basis at a point / first countable **) 
(** LATEX VERSION: Countable sets and related notions from 30 (countability axioms). **)
Definition countable_set : set -> prop := fun A => countable A.

(** LATEX VERSION: Countable subcollection V of U. **)
Definition countable_subcollection : set -> set -> prop := fun V U => V c= U /\ countable_set V.

(** LATEX VERSION: Countable index set. **)
Definition countable_index_set : set -> prop := fun I => countable_set I.

(** Helper for 30 Theorem 30.2: product topology from a cylinder subbasis. **)
(** LATEX VERSION: The product topology is generated by the cylinder subbasis. **)
Definition countable_product_topology_subbasis : set -> set -> set := fun I Xi =>
  generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi).

(** Helper: cylinder family is a subbasis on nonempty products. **)
Theorem product_subbasis_full_subbasis_on : forall I Xi:set,
  I <> Empty ->
  (forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i)) ->
  subbasis_on (product_space I Xi) (product_subbasis_full I Xi).
let I Xi.
assume HIne: I <> Empty.
assume HcompTop: forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i).
prove subbasis_on (product_space I Xi) (product_subbasis_full I Xi).
prove product_subbasis_full I Xi c= Power (product_space I Xi) /\ Union (product_subbasis_full I Xi) = product_space I Xi.
apply andI.
- (** product_subbasis_full I Xi c= Power (product_space I Xi) **)
  let s. assume Hs: s :e product_subbasis_full I Xi.
  prove s :e Power (product_space I Xi).
  apply PowerI.
  let f. assume Hf: f :e s.
  prove f :e product_space I Xi.
  set F := (fun i:set => {product_cylinder I Xi i U|U :e space_family_topology Xi i}).
  claim HsF: s :e (\/_ i :e I, F i).
  { exact Hs. }
  apply (famunionE_impred I F s HsF (f :e product_space I Xi)).
  let i.
  assume HiI: i :e I.
  assume HsFi: s :e F i.
  claim HexU: exists U :e space_family_topology Xi i, s = product_cylinder I Xi i U.
  { exact (ReplE (space_family_topology Xi i) (fun U0:set => product_cylinder I Xi i U0) s HsFi). }
  apply HexU.
  let U.
  assume HUand: U :e space_family_topology Xi i /\ s = product_cylinder I Xi i U.
  claim Hseq: s = product_cylinder I Xi i U.
  { exact (andER (U :e space_family_topology Xi i) (s = product_cylinder I Xi i U) HUand). }
  claim HfCyl: f :e product_cylinder I Xi i U.
  { rewrite <- Hseq. exact Hf. }
  exact (SepE1 (product_space I Xi)
               (fun f0:set => i :e I /\ U :e space_family_topology Xi i /\ apply_fun f0 i :e U)
               f HfCyl).
- (** Union (product_subbasis_full I Xi) = product_space I Xi **)
  apply set_ext.
  + let f. assume HfU: f :e Union (product_subbasis_full I Xi).
    prove f :e product_space I Xi.
    apply (UnionE_impred (product_subbasis_full I Xi) f HfU (f :e product_space I Xi)).
    let s. assume Hfs: f :e s. assume Hs: s :e product_subbasis_full I Xi.
    claim HsPow: s :e Power (product_space I Xi).
    { apply PowerI.
      let g. assume Hg: g :e s.
      prove g :e product_space I Xi.
      set F := (fun i:set => {product_cylinder I Xi i U|U :e space_family_topology Xi i}).
      claim HsF: s :e (\/_ i :e I, F i).
      { exact Hs. }
      apply (famunionE_impred I F s HsF (g :e product_space I Xi)).
      let i.
      assume HiI: i :e I.
      assume HsFi: s :e F i.
      claim HexU: exists U :e space_family_topology Xi i, s = product_cylinder I Xi i U.
      { exact (ReplE (space_family_topology Xi i) (fun U0:set => product_cylinder I Xi i U0) s HsFi). }
      apply HexU.
      let U.
      assume HUand: U :e space_family_topology Xi i /\ s = product_cylinder I Xi i U.
      claim Hseq: s = product_cylinder I Xi i U.
      { exact (andER (U :e space_family_topology Xi i) (s = product_cylinder I Xi i U) HUand). }
      claim HgCyl: g :e product_cylinder I Xi i U.
      { rewrite <- Hseq. exact Hg. }
      exact (SepE1 (product_space I Xi)
                   (fun f0:set => i :e I /\ U :e space_family_topology Xi i /\ apply_fun f0 i :e U)
                   g HgCyl).
    }
    exact (PowerE (product_space I Xi) s HsPow f Hfs).
  + let f. assume HfX: f :e product_space I Xi.
    prove f :e Union (product_subbasis_full I Xi).
    apply (xm (exists i:set, i :e I)).
    * assume Hexi: exists i:set, i :e I.
      apply Hexi.
      let i. assume HiI: i :e I.
      claim Htopi: topology_on (space_family_set Xi i) (space_family_topology Xi i).
      { exact (HcompTop i HiI). }
      claim Ht1: (((space_family_topology Xi i c= Power (space_family_set Xi i) /\ Empty :e space_family_topology Xi i) /\ space_family_set Xi i :e space_family_topology Xi i) /\ (forall UFam :e Power (space_family_topology Xi i), Union UFam :e space_family_topology Xi i)) /\ (forall U :e space_family_topology Xi i, forall V :e space_family_topology Xi i, U :/\: V :e space_family_topology Xi i).
      { exact Htopi. }
      claim Ht2: ((space_family_topology Xi i c= Power (space_family_set Xi i) /\ Empty :e space_family_topology Xi i) /\ space_family_set Xi i :e space_family_topology Xi i) /\ (forall UFam :e Power (space_family_topology Xi i), Union UFam :e space_family_topology Xi i).
      { exact (andEL (((space_family_topology Xi i c= Power (space_family_set Xi i) /\ Empty :e space_family_topology Xi i) /\ space_family_set Xi i :e space_family_topology Xi i) /\ (forall UFam :e Power (space_family_topology Xi i), Union UFam :e space_family_topology Xi i))
                     (forall U :e space_family_topology Xi i, forall V :e space_family_topology Xi i, U :/\: V :e space_family_topology Xi i)
                     Ht1). }
      claim Ht3: (space_family_topology Xi i c= Power (space_family_set Xi i) /\ Empty :e space_family_topology Xi i) /\ space_family_set Xi i :e space_family_topology Xi i.
      { exact (andEL ((space_family_topology Xi i c= Power (space_family_set Xi i) /\ Empty :e space_family_topology Xi i) /\ space_family_set Xi i :e space_family_topology Xi i)
                     (forall UFam :e Power (space_family_topology Xi i), Union UFam :e space_family_topology Xi i)
                     Ht2). }
      claim HUopen: space_family_set Xi i :e space_family_topology Xi i.
      { exact (andER (space_family_topology Xi i c= Power (space_family_set Xi i) /\ Empty :e space_family_topology Xi i)
                     (space_family_set Xi i :e space_family_topology Xi i)
                     Ht3). }
      set s := product_cylinder I Xi i (space_family_set Xi i).
      claim HsRepl: s :e {product_cylinder I Xi i U|U :e space_family_topology Xi i}.
      { exact (ReplI (space_family_topology Xi i) (fun U0:set => product_cylinder I Xi i U0)
                     (space_family_set Xi i) HUopen). }
      claim HsSub: s :e product_subbasis_full I Xi.
      { exact (famunionI I (fun i0:set => {product_cylinder I Xi i0 U|U :e space_family_topology Xi i0})
                       i s HiI HsRepl). }
      claim HfProp: function_on f I (space_family_union I Xi) /\ forall j:set, j :e I -> apply_fun f j :e space_family_set Xi j.
      { exact (SepE2 (Power (setprod I (space_family_union I Xi)))
                     (fun f0:set => function_on f0 I (space_family_union I Xi) /\ forall j:set, j :e I -> apply_fun f0 j :e space_family_set Xi j)
                     f HfX). }
      claim HfCoord: forall j:set, j :e I -> apply_fun f j :e space_family_set Xi j.
      { exact (andER (function_on f I (space_family_union I Xi))
                     (forall j:set, j :e I -> apply_fun f j :e space_family_set Xi j)
                     HfProp). }
      claim Hfi: apply_fun f i :e space_family_set Xi i.
      { exact (HfCoord i HiI). }
      claim HfInS: f :e s.
      { exact (SepI (product_space I Xi)
                    (fun f0:set => i :e I /\ space_family_set Xi i :e space_family_topology Xi i /\ apply_fun f0 i :e space_family_set Xi i)
                    f HfX
                    (andI (i :e I /\ space_family_set Xi i :e space_family_topology Xi i)
                          (apply_fun f i :e space_family_set Xi i)
                          (andI (i :e I) (space_family_set Xi i :e space_family_topology Xi i) HiI HUopen)
                          Hfi)). }
      exact (UnionI (product_subbasis_full I Xi) f s HfInS HsSub).
    * assume Hnex: ~(exists i:set, i :e I).
      prove f :e Union (product_subbasis_full I Xi).
      claim Hall: forall i:set, i /:e I.
      { let i. assume HiI: i :e I.
        prove False.
        apply Hnex.
        witness i.
        exact HiI. }
      claim HIeq: I = Empty.
      { exact (Empty_eq I Hall). }
      claim Hfalse: False.
      { apply HIne. exact HIeq. }
      exact (FalseE Hfalse (f :e Union (product_subbasis_full I Xi))).
Qed.

(** Helper: cartesian product with Empty is Empty. **)
Theorem setprod_Empty_left : forall Y:set, setprod Empty Y = Empty.
let Y.
apply set_ext.
- let p. assume Hp: p :e setprod Empty Y.
  prove p :e Empty.
  claim Hp0: (p 0) :e Empty.
  { exact (ap0_Sigma Empty (fun _:set => Y) p Hp). }
  exact (EmptyE (p 0) Hp0 (p :e Empty)).
- let p. assume Hp: p :e Empty.
  prove p :e setprod Empty Y.
  exact (EmptyE p Hp (p :e setprod Empty Y)).
Qed.

(** Helper: basis on X from the singleton {X}. **)
Theorem basis_on_singleton : forall X:set, basis_on X {X}.
let X.
prove {X} c= Power X
  /\ (forall x :e X, exists b :e {X}, x :e b)
  /\ (forall b1 :e {X}, forall b2 :e {X}, forall x:set,
        x :e b1 -> x :e b2 ->
        exists b3 :e {X}, x :e b3 /\ b3 c= b1 :/\: b2).
apply andI.
- apply andI.
  + (** {X} c= Power X **)
    let b. assume Hb: b :e {X}.
    prove b :e Power X.
    claim HbX: b = X.
    { exact (SingE X b Hb). }
    rewrite HbX.
    exact (Self_In_Power X).
  + (** covering property **)
    let x. assume HxX: x :e X.
    prove exists b :e {X}, x :e b.
    witness X.
    apply andI.
    * exact (SingI X).
    * exact HxX.
- (** intersection property **)
  let b1. assume Hb1: b1 :e {X}.
  let b2. assume Hb2: b2 :e {X}.
  let x. assume Hxb1: x :e b1. assume Hxb2: x :e b2.
  prove exists b3 :e {X}, x :e b3 /\ b3 c= b1 :/\: b2.
  claim Hb1X: b1 = X.
  { exact (SingE X b1 Hb1). }
  claim Hb2X: b2 = X.
  { exact (SingE X b2 Hb2). }
  witness X.
  apply andI.
  + exact (SingI X).
	  + prove x :e X /\ X c= b1 :/\: b2.
	    apply andI.
	    * rewrite <- Hb1X. exact Hxb1.
	    * let y. assume HyX: y :e X.
      prove y :e b1 :/\: b2.
      claim Hyb1: y :e b1.
      { rewrite Hb1X. exact HyX. }
      claim Hyb2: y :e b2.
      { rewrite Hb2X. exact HyX. }
      exact (binintersectI b1 b2 y Hyb1 Hyb2).
Qed.

(** Helper: the product space indexed by Empty has exactly the empty function. **)
Theorem product_space_empty_index : forall Xi:set, product_space Empty Xi = {Empty}.
let Xi.
apply set_ext.
- let f. assume Hf: f :e product_space Empty Xi.
  prove f :e {Empty}.
  claim HfPow: f :e Power (setprod Empty (space_family_union Empty Xi)).
  { exact (SepE1 (Power (setprod Empty (space_family_union Empty Xi)))
                 (fun f0:set => function_on f0 Empty (space_family_union Empty Xi) /\
                   forall i:set, i :e Empty -> apply_fun f0 i :e space_family_set Xi i)
                 f Hf). }
  claim Heqprod: setprod Empty (space_family_union Empty Xi) = Empty.
  { exact (setprod_Empty_left (space_family_union Empty Xi)). }
	  claim HfPowE: f :e Power Empty.
	  { rewrite <- Heqprod. exact HfPow. }
  claim Hsub: f c= Empty.
  { exact (PowerE Empty f HfPowE). }
  claim Hall: forall x:set, x /:e f.
  { let x. assume Hx: x :e f.
    prove False.
    claim HxE: x :e Empty.
    { exact (Hsub x Hx). }
    exact (EmptyE x HxE False). }
  claim HfEq: f = Empty.
  { exact (Empty_eq f Hall). }
  rewrite HfEq.
  exact (SingI Empty).
- let f. assume Hf: f :e {Empty}.
  prove f :e product_space Empty Xi.
  claim Hfeq: f = Empty.
  { exact (SingE Empty f Hf). }
  rewrite Hfeq.
  claim Hpow: Empty :e Power (setprod Empty (space_family_union Empty Xi)).
  { claim Heqprod: setprod Empty (space_family_union Empty Xi) = Empty.
    { exact (setprod_Empty_left (space_family_union Empty Xi)). }
    rewrite Heqprod.
    exact (Empty_In_Power Empty). }
  claim Hpred: function_on Empty Empty (space_family_union Empty Xi) /\
    forall i:set, i :e Empty -> apply_fun Empty i :e space_family_set Xi i.
  { apply andI.
    - let x. assume Hx: x :e Empty.
      prove apply_fun Empty x :e space_family_union Empty Xi.
      exact (EmptyE x Hx (apply_fun Empty x :e space_family_union Empty Xi)).
    - let i. assume Hi: i :e Empty.
      prove apply_fun Empty i :e space_family_set Xi i.
      exact (EmptyE i Hi (apply_fun Empty i :e space_family_set Xi i)). }
  exact (SepI (Power (setprod Empty (space_family_union Empty Xi)))
              (fun f0:set => function_on f0 Empty (space_family_union Empty Xi) /\
                forall i:set, i :e Empty -> apply_fun f0 i :e space_family_set Xi i)
              Empty Hpow Hpred).
Qed.

(** Helper: nonempty empty-subbasis gives singleton basis {X}. **)
Theorem basis_of_subbasis_empty_eq : forall X:set,
  X <> Empty ->
  basis_of_subbasis X Empty = {X}.
let X.
assume HXne: X <> Empty.
apply set_ext.
- let b. assume Hb: b :e basis_of_subbasis X Empty.
  prove b :e {X}.
  claim Hbfin: b :e finite_intersections_of X Empty.
  { exact (SepE1 (finite_intersections_of X Empty) (fun b0:set => b0 <> Empty) b Hb). }
  claim HexF: exists F :e finite_subcollections Empty, b = intersection_of_family X F.
  { exact (ReplE (finite_subcollections Empty) (fun F0:set => intersection_of_family X F0) b Hbfin). }
  apply HexF.
  let F. assume HFpair. apply HFpair.
  assume HF: F :e finite_subcollections Empty.
  assume Hbeq: b = intersection_of_family X F.
  claim HFpow: F :e Power Empty.
  { exact (SepE1 (Power Empty) (fun F0:set => finite F0) F HF). }
  claim HFsub: F c= Empty.
  { exact (PowerE Empty F HFpow). }
  claim Hall: forall x:set, x /:e F.
  { let x. assume Hx: x :e F.
    prove False.
    claim HxE: x :e Empty.
    { exact (HFsub x Hx). }
    exact (EmptyE x HxE False). }
  claim HFeq: F = Empty.
  { exact (Empty_eq F Hall). }
  claim HbX: b = X.
  { rewrite Hbeq.
    rewrite HFeq.
    exact (intersection_of_family_empty_eq X). }
  rewrite HbX.
  exact (SingI X).
- let b. assume Hb: b :e {X}.
  prove b :e basis_of_subbasis X Empty.
  claim HbX: b = X.
  { exact (SingE X b Hb). }
  rewrite HbX.
  claim HF: Empty :e finite_subcollections Empty.
  { exact (SepI (Power Empty) (fun F0:set => finite F0)
                Empty (Empty_In_Power Empty) finite_Empty). }
  claim Hfin: intersection_of_family X Empty :e finite_intersections_of X Empty.
  { exact (ReplI (finite_subcollections Empty) (fun F0:set => intersection_of_family X F0) Empty HF). }
  claim HXfin: X :e finite_intersections_of X Empty.
	{ claim Heq: X = intersection_of_family X Empty.
	  { rewrite (intersection_of_family_empty_eq X).
	    reflexivity. }
	  rewrite Heq at 1.
	  exact Hfin. }
  exact (SepI (finite_intersections_of X Empty) (fun b0:set => b0 <> Empty)
              X HXfin HXne).
Qed.

(** Helper for 30 Theorem 30.2: empty-index product topology is a topology. **)
(** LATEX VERSION: The empty product carries the topology generated by the empty cylinder family, which is a topology. **)
Theorem countable_product_topology_subbasis_empty_is_topology : forall Xi:set,
  topology_on (product_space Empty Xi) (countable_product_topology_subbasis Empty Xi).
let Xi.
prove topology_on (product_space Empty Xi) (countable_product_topology_subbasis Empty Xi).
claim HTdef: countable_product_topology_subbasis Empty Xi =
  generated_topology_from_subbasis (product_space Empty Xi) (product_subbasis_full Empty Xi).
{ reflexivity. }
rewrite HTdef.
				          claim HS0: product_subbasis_full Empty Xi = Empty.
				          { exact (famunion_Empty (fun i:set => {product_cylinder Empty Xi i U|U :e space_family_topology Xi i})). }
				          rewrite HS0.
				          claim HGTS0: generated_topology_from_subbasis (product_space Empty Xi) Empty =
				            generated_topology (product_space Empty Xi) (basis_of_subbasis (product_space Empty Xi) Empty).
				          { reflexivity. }
				          rewrite HGTS0.
				          claim HX0ne: product_space Empty Xi <> Empty.
				          { assume HX0E: product_space Empty Xi = Empty.
				            claim Hem: Empty :e product_space Empty Xi.
				            { rewrite (product_space_empty_index Xi).
    exact (SingI Empty). }
	  claim HemE: Empty :e Empty.
	  { rewrite <- HX0E at 2. exact Hem. }
	  exact (EmptyE Empty HemE False). }
claim HB0eq: basis_of_subbasis (product_space Empty Xi) Empty = {product_space Empty Xi}.
{ exact (basis_of_subbasis_empty_eq (product_space Empty Xi) HX0ne). }
claim HB0: basis_on (product_space Empty Xi) (basis_of_subbasis (product_space Empty Xi) Empty).
{ rewrite HB0eq.
  exact (basis_on_singleton (product_space Empty Xi)). }
exact (lemma_topology_from_basis (product_space Empty Xi) (basis_of_subbasis (product_space Empty Xi) Empty) HB0).
Qed.

(** Helper: power set of a natural has finite size **)
(** LATEX VERSION: For n in omega, Power n is equipotent to 2^n. **)
Theorem equip_Power_nat : forall n:set, nat_p n -> equip (Power n) (exp_nat 2 n).
let n.
assume Hn: nat_p n.
claim Hnn: equip n n.
{ exact (equip_ref n). }
exact (equip_finite_Power n Hn n Hnn).
Qed.

(** helper: image of countable set is countable **)
Theorem countable_image : forall X:set, countable_set X ->
  forall F:set->set, countable_set {F x|x :e X}.
let X.
assume HX: countable_set X.
let F.
prove countable_set {F x|x :e X}.
prove countable {F x|x :e X}.
prove atleastp {F x|x :e X} omega.
prove exists g : set->set, inj {F x|x :e X} omega g.
apply HX.
let h : set->set.
assume Hh: inj X omega h.
set pre : set->set := fun y => Eps_i (fun x => x :e X /\ y = F x).
set g : set->set := fun y => h (pre y).
witness g.
apply (injI {F x|x :e X} omega g).
- let y. assume Hy: y :e {F x|x :e X}.
  prove g y :e omega.
  apply (ReplE_impred X F y Hy).
  let x.
  assume HxX: x :e X.
  assume HyFx: y = F x.
  claim Hpreprop: pre y :e X /\ y = F (pre y).
  { exact (Eps_i_ax (fun x0 => x0 :e X /\ y = F x0) x (andI (x :e X) (y = F x) HxX HyFx)). }
  claim HpreX: pre y :e X.
  { exact (andEL (pre y :e X) (y = F (pre y)) Hpreprop). }
  claim Hhmap: forall u :e X, h u :e omega.
  { exact (andEL (forall u :e X, h u :e omega) (forall u v :e X, h u = h v -> u = v) Hh). }
  claim Hgy: g y = h (pre y).
  { reflexivity. }
  rewrite Hgy.
  exact (Hhmap (pre y) HpreX).
- let y1. assume Hy1: y1 :e {F x|x :e X}.
  let y2. assume Hy2: y2 :e {F x|x :e X}.
  assume Hg: g y1 = g y2.
  prove y1 = y2.
  claim Hhinj: forall u v :e X, h u = h v -> u = v.
  { exact (andER (forall u :e X, h u :e omega) (forall u v :e X, h u = h v -> u = v) Hh). }
  apply (ReplE_impred X F y1 Hy1).
  let x1.
  assume Hx1X: x1 :e X.
  assume Hy1Fx1: y1 = F x1.
  apply (ReplE_impred X F y2 Hy2).
  let x2.
  assume Hx2X: x2 :e X.
  assume Hy2Fx2: y2 = F x2.
  claim Hpre1: pre y1 :e X /\ y1 = F (pre y1).
  { exact (Eps_i_ax (fun x0 => x0 :e X /\ y1 = F x0) x1 (andI (x1 :e X) (y1 = F x1) Hx1X Hy1Fx1)). }
  claim Hpre2: pre y2 :e X /\ y2 = F (pre y2).
  { exact (Eps_i_ax (fun x0 => x0 :e X /\ y2 = F x0) x2 (andI (x2 :e X) (y2 = F x2) Hx2X Hy2Fx2)). }
  claim Hpre1X: pre y1 :e X.
  { exact (andEL (pre y1 :e X) (y1 = F (pre y1)) Hpre1). }
  claim Hpre2X: pre y2 :e X.
  { exact (andEL (pre y2 :e X) (y2 = F (pre y2)) Hpre2). }
  claim Hg1: g y1 = h (pre y1).
  { reflexivity. }
  claim Hg2: g y2 = h (pre y2).
  { reflexivity. }
  claim Heqh: h (pre y1) = h (pre y2).
  { rewrite <- Hg1. rewrite <- Hg2. exact Hg. }
  claim Heqpre: pre y1 = pre y2.
  { exact (Hhinj (pre y1) Hpre1X (pre y2) Hpre2X Heqh). }
  claim Hy1pre: y1 = F (pre y1).
  { exact (andER (pre y1 :e X) (y1 = F (pre y1)) Hpre1). }
  claim Hy2pre: y2 = F (pre y2).
  { exact (andER (pre y2 :e X) (y2 = F (pre y2)) Hpre2). }
  rewrite Hy1pre.
  rewrite Hy2pre.
  rewrite Heqpre.
  reflexivity.
Qed.

(** Helper: finite subsets of omega are countable as a family **)
(** LATEX VERSION: The collection of all finite subsets of omega is countable. **)
Theorem finite_subcollections_omega_countable : countable (finite_subcollections omega).
prove exists code : set -> set, inj (finite_subcollections omega) omega code.

(** Step 1: countability of Sigma_ n :e omega, Power n **)
set S := Sigma_ n :e omega, Power n.

claim Homega_countable: countable omega.
{ prove exists f : set -> set, inj omega omega f.
	  witness (fun n => n).
	  apply (injI omega omega (fun n => n)).
	  - let n. assume Hn: n :e omega.
	    prove (fun n0:set => n0) n :e omega.
	    exact Hn.
	  - let a. assume Ha: a :e omega.
	    let b. assume Hb: b :e omega.
	    assume Heq: (fun n0:set => n0) a = (fun n0:set => n0) b.
	    prove a = b.
	    exact Heq. }

claim Hpow_countable: forall n:set, n :e omega -> countable (Power n).
{ let n.
  assume Hn: n :e omega.
  prove countable (Power n).
  apply (finite_countable (Power n)).
  prove finite (Power n).
  prove exists m :e omega, equip (Power n) m.
  claim Hn_nat: nat_p n.
  { exact (omega_nat_p n Hn). }
  claim HequipPow: equip (Power n) (exp_nat 2 n).
  { exact (equip_Power_nat n Hn_nat). }
  claim Hpow_nat: nat_p (exp_nat 2 n).
  { exact (exp_nat_p 2 nat_2 n Hn_nat). }
  claim Hpow_omega: (exp_nat 2 n) :e omega.
  { exact (nat_p_omega (exp_nat 2 n) Hpow_nat). }
  witness (exp_nat 2 n).
  apply andI.
  - exact Hpow_omega.
  - exact HequipPow. }

claim HS_countable: countable S.
{ exact (Sigma_countable omega Homega_countable (fun n:set => Power n) Hpow_countable). }

(** Step 2: boundedness of finite subsets of omega **)
claim finite_sub_omega_bounded:
  forall F:set, F c= omega -> finite F -> exists n :e omega, forall m :e F, m :e n.
{ let F.
  assume HFsub: F c= omega.
  assume HFfin: finite F.
  claim Hp0: (Empty c= omega -> exists n :e omega, forall m :e Empty, m :e n).
  { assume Hsub0: Empty c= omega.
    prove exists n :e omega, forall m :e Empty, m :e n.
    witness 0.
    apply andI.
    - exact (nat_p_omega 0 nat_0).
    - let m. assume Hm: m :e Empty.
      apply FalseE.
      exact (EmptyE m Hm). }
  claim Hpstep: forall A y, finite A -> y /:e A ->
    (A c= omega -> exists n :e omega, forall m :e A, m :e n) ->
    (A :\/: {y} c= omega -> exists n0 :e omega, forall m:set, m :e A :\/: {y} -> m :e n0).
  { let A y.
    assume HAfin: finite A.
    assume HyA: y /:e A.
    assume HpA: (A c= omega -> exists n :e omega, forall m :e A, m :e n).
    assume HsubAy: A :\/: {y} c= omega.
    claim HsubA: A c= omega.
    { exact (Subq_tra A (A :\/: {y}) omega (binunion_Subq_1 A {y}) HsubAy). }
    claim Hexn: exists n :e omega, forall m :e A, m :e n.
    { exact (HpA HsubA). }
    apply Hexn.
    let n.
    assume Hnand.
    claim Hn: n :e omega.
    { exact (andEL (n :e omega) (forall m :e A, m :e n) Hnand). }
    claim Hnprop: forall m :e A, m :e n.
    { exact (andER (n :e omega) (forall m :e A, m :e n) Hnand). }
    prove exists n0 :e omega, forall m:set, m :e A :\/: {y} -> m :e n0.
    claim Hy_in_union: y :e A :\/: {y}.
    { apply binunionI2. exact (SingI y). }
    claim Hy_omega: y :e omega.
    { exact (HsubAy y Hy_in_union). }
    claim Hysucc_omega: ordsucc y :e omega.
    { exact (omega_ordsucc y Hy_omega). }
    claim Hn_union_omega: n :\/: ordsucc y :e omega.
    { exact (omega_binunion n (ordsucc y) Hn Hysucc_omega). }
    set n0 := ordsucc (n :\/: ordsucc y).
    claim Hn0_omega: n0 :e omega.
    { exact (omega_ordsucc (n :\/: ordsucc y) Hn_union_omega). }
    witness n0.
    apply andI.
    - exact Hn0_omega.
    - let m. assume Hm: m :e A :\/: {y}.
      prove m :e n0.
      apply (binunionE A {y} m Hm).
      + assume HmA: m :e A.
        claim Hmn: m :e n.
        { exact (Hnprop m HmA). }
        claim HmnU: m :e n :\/: ordsucc y.
        { exact (binunionI1 n (ordsucc y) m Hmn). }
        exact (ordsuccI1 (n :\/: ordsucc y) m HmnU).
      + assume HmY: m :e {y}.
        claim Hmy: m = y.
        { exact (SingE y m HmY). }
        rewrite Hmy.
        claim Hy_in_succ: y :e ordsucc y.
        { exact (ordsuccI2 y). }
        claim Hy_in_U: y :e n :\/: ordsucc y.
        { exact (binunionI2 n (ordsucc y) y Hy_in_succ). }
        exact (ordsuccI1 (n :\/: ordsucc y) y Hy_in_U). }
  claim HpF: (F c= omega -> exists n :e omega, forall m :e F, m :e n).
  { exact (finite_ind (fun A => A c= omega -> exists n :e omega, forall m :e A, m :e n)
                      Hp0 Hpstep F HFfin). }
  apply HpF.
  exact HFsub. }

(** Step 3: build an injection into S and compose with the countable injection of S **)
apply HS_countable.
let codeS : set -> set.
assume HcodeS: inj S omega codeS.
set bound : set -> set := fun F =>
  Eps_i (fun n => n :e omega /\ forall m:set, m :e F -> m :e n).
set emb : set -> set := fun F => (bound F, F).
set code : set -> set := fun F => codeS (emb F).
witness code.

apply (injI (finite_subcollections omega) omega code).
- let F.
  assume HF: F :e finite_subcollections omega.
  prove code F :e omega.
  claim HFpow: F :e Power omega.
  { exact (SepE1 (Power omega) (fun F0:set => finite F0) F HF). }
  claim HFsub: F c= omega.
  { exact (PowerE omega F HFpow). }
  claim HFfin: finite F.
  { exact (SepE2 (Power omega) (fun F0:set => finite F0) F HF). }
  claim Hexb: exists n :e omega, forall m :e F, m :e n.
  { exact (finite_sub_omega_bounded F HFsub HFfin). }
  claim Hboundprop: bound F :e omega /\ forall m:set, m :e F -> m :e bound F.
  { exact (Eps_i_ex (fun n => n :e omega /\ forall m:set, m :e F -> m :e n) Hexb). }
  claim Hbound_omega: bound F :e omega.
  { exact (andEL (bound F :e omega) (forall m:set, m :e F -> m :e bound F) Hboundprop). }
  claim Hbound_sub: forall m:set, m :e F -> m :e bound F.
  { exact (andER (bound F :e omega) (forall m:set, m :e F -> m :e bound F) Hboundprop). }
  claim HFpowB: F :e Power (bound F).
  { claim Hsub: F c= bound F.
    { let m. assume Hm: m :e F.
      exact (Hbound_sub m Hm). }
    exact (PowerI (bound F) F Hsub). }
  claim HembS: emb F :e S.
  { exact (tuple_2_Sigma omega (fun n:set => Power n) (bound F) Hbound_omega F HFpowB). }
  claim Hmap: forall u :e S, codeS u :e omega.
  { exact (andEL (forall u :e S, codeS u :e omega)
                 (forall u v :e S, codeS u = codeS v -> u = v)
                 HcodeS). }
  claim Hdef: code F = codeS (emb F).
  { reflexivity. }
  rewrite Hdef.
  exact (Hmap (emb F) HembS).
- let F1.
  assume HF1: F1 :e finite_subcollections omega.
  let F2.
  assume HF2: F2 :e finite_subcollections omega.
  assume Heq: code F1 = code F2.
  prove F1 = F2.
  claim HF1pow: F1 :e Power omega.
  { exact (SepE1 (Power omega) (fun F0:set => finite F0) F1 HF1). }
  claim HF2pow: F2 :e Power omega.
  { exact (SepE1 (Power omega) (fun F0:set => finite F0) F2 HF2). }
  claim HF1sub: F1 c= omega.
  { exact (PowerE omega F1 HF1pow). }
  claim HF2sub: F2 c= omega.
  { exact (PowerE omega F2 HF2pow). }
  claim HF1fin: finite F1.
  { exact (SepE2 (Power omega) (fun F0:set => finite F0) F1 HF1). }
  claim HF2fin: finite F2.
  { exact (SepE2 (Power omega) (fun F0:set => finite F0) F2 HF2). }
  claim Hexb1: exists n :e omega, forall m :e F1, m :e n.
  { exact (finite_sub_omega_bounded F1 HF1sub HF1fin). }
  claim Hexb2: exists n :e omega, forall m :e F2, m :e n.
  { exact (finite_sub_omega_bounded F2 HF2sub HF2fin). }
  claim Hb1: bound F1 :e omega /\ forall m:set, m :e F1 -> m :e bound F1.
  { exact (Eps_i_ex (fun n => n :e omega /\ forall m:set, m :e F1 -> m :e n) Hexb1). }
  claim Hb2: bound F2 :e omega /\ forall m:set, m :e F2 -> m :e bound F2.
  { exact (Eps_i_ex (fun n => n :e omega /\ forall m:set, m :e F2 -> m :e n) Hexb2). }
  claim Hbound1: bound F1 :e omega.
  { exact (andEL (bound F1 :e omega) (forall m:set, m :e F1 -> m :e bound F1) Hb1). }
  claim Hbound2: bound F2 :e omega.
  { exact (andEL (bound F2 :e omega) (forall m:set, m :e F2 -> m :e bound F2) Hb2). }
  claim HF1powB: F1 :e Power (bound F1).
  { claim Hsub: F1 c= bound F1.
    { let m. assume Hm: m :e F1.
      claim Hsubm: forall m0:set, m0 :e F1 -> m0 :e bound F1.
      { exact (andER (bound F1 :e omega) (forall m0:set, m0 :e F1 -> m0 :e bound F1) Hb1). }
      exact (Hsubm m Hm). }
    exact (PowerI (bound F1) F1 Hsub). }
  claim HF2powB: F2 :e Power (bound F2).
  { claim Hsub: F2 c= bound F2.
    { let m. assume Hm: m :e F2.
      claim Hsubm: forall m0:set, m0 :e F2 -> m0 :e bound F2.
      { exact (andER (bound F2 :e omega) (forall m0:set, m0 :e F2 -> m0 :e bound F2) Hb2). }
      exact (Hsubm m Hm). }
    exact (PowerI (bound F2) F2 Hsub). }
  claim Hemb1: emb F1 :e S.
  { exact (tuple_2_Sigma omega (fun n:set => Power n) (bound F1) Hbound1 F1 HF1powB). }
  claim Hemb2: emb F2 :e S.
  { exact (tuple_2_Sigma omega (fun n:set => Power n) (bound F2) Hbound2 F2 HF2powB). }
  claim Hcodeinj: forall u v :e S, codeS u = codeS v -> u = v.
  { exact (andER (forall u :e S, codeS u :e omega)
                 (forall u v :e S, codeS u = codeS v -> u = v)
                 HcodeS). }
  claim Hdef1: code F1 = codeS (emb F1).
  { reflexivity. }
  claim Hdef2: code F2 = codeS (emb F2).
  { reflexivity. }
  claim HeqS: codeS (emb F1) = codeS (emb F2).
  { rewrite <- Hdef1.
    rewrite <- Hdef2.
    exact Heq. }
  claim HembEq: emb F1 = emb F2.
  { exact (Hcodeinj (emb F1) Hemb1 (emb F2) Hemb2 HeqS). }
  claim HF1Eq: F1 = F2.
  { claim Hemb1def: emb F1 = (bound F1, F1).
    { reflexivity. }
    claim Hemb2def: emb F2 = (bound F2, F2).
    { reflexivity. }
    claim Hproj1: (emb F1) 1 = F1.
    { rewrite Hemb1def.
      exact (tuple_2_1_eq (bound F1) F1). }
    claim Hproj2: (emb F2) 1 = F2.
    { rewrite Hemb2def.
      exact (tuple_2_1_eq (bound F2) F2). }
    claim HapEq: (emb F1) 1 = (emb F2) 1.
    { rewrite HembEq.
      reflexivity. }
    rewrite <- Hproj1.
    rewrite <- Hproj2.
    exact HapEq. }
  exact HF1Eq.
Qed.

(** Helper: finite subcollections of a countable set are countable **)
(** LATEX VERSION: The set of all finite subcollections of a countable set is countable. **)
Theorem finite_subcollections_countable : forall S:set,
  countable_set S -> countable_set (finite_subcollections S).
let S. assume HS: countable_set S.
prove countable_set (finite_subcollections S).
prove countable (finite_subcollections S).
prove exists h : set -> set, inj (finite_subcollections S) omega h.
apply HS.
let f : set -> set.
assume Hf: inj S omega f.
(** It is standard that the family of finite subsets of omega is countable. **)
claim HFinOmega: countable (finite_subcollections omega).
{ exact finite_subcollections_omega_countable. }
apply HFinOmega.
let code : set -> set.
assume Hcode: inj (finite_subcollections omega) omega code.
set ImgF : set -> set := fun F => {f x|x :e F}.
set h : set -> set := fun F => code (ImgF F).
witness h.
apply (injI (finite_subcollections S) omega h).
- let F. assume HF: F :e finite_subcollections S.
  prove h F :e omega.
  claim HFpow: F :e Power S.
  { exact (SepE1 (Power S) (fun F0:set => finite F0) F HF). }
  claim HFfin: finite F.
  { exact (SepE2 (Power S) (fun F0:set => finite F0) F HF). }
  claim Hfmap: forall a :e S, f a :e omega.
  { exact (andEL (forall a :e S, f a :e omega)
                 (forall a b :e S, f a = f b -> a = b)
                 Hf). }
  claim HImgPow: ImgF F :e Power omega.
  { exact (image_In_Power S omega f Hfmap F HFpow). }
  claim HImgFin: finite (ImgF F).
  { exact (Repl_finite f F HFfin). }
  claim HImg: ImgF F :e finite_subcollections omega.
  { exact (SepI (Power omega) (fun F0:set => finite F0) (ImgF F) HImgPow HImgFin). }
  claim Hcodemap: forall u :e finite_subcollections omega, code u :e omega.
  { exact (andEL (forall u :e finite_subcollections omega, code u :e omega)
                 (forall u v :e finite_subcollections omega, code u = code v -> u = v)
                 Hcode). }
  claim Hhdef: h F = code (ImgF F).
  { reflexivity. }
  rewrite Hhdef.
  exact (Hcodemap (ImgF F) HImg).
- let F1. assume HF1: F1 :e finite_subcollections S.
  let F2. assume HF2: F2 :e finite_subcollections S.
  assume Heq: h F1 = h F2.
  prove F1 = F2.
  claim HF1pow: F1 :e Power S.
  { exact (SepE1 (Power S) (fun F0:set => finite F0) F1 HF1). }
  claim HF2pow: F2 :e Power S.
  { exact (SepE1 (Power S) (fun F0:set => finite F0) F2 HF2). }
  claim HF1sub: F1 c= S.
  { exact (PowerE S F1 HF1pow). }
  claim HF2sub: F2 c= S.
  { exact (PowerE S F2 HF2pow). }
  claim Hf_inj: forall a b :e S, f a = f b -> a = b.
  { exact (andER (forall a :e S, f a :e omega)
                 (forall a b :e S, f a = f b -> a = b)
                 Hf). }
  claim Hfmap: forall a :e S, f a :e omega.
  { exact (andEL (forall a :e S, f a :e omega)
                 (forall a b :e S, f a = f b -> a = b)
                 Hf). }
  claim HImg1: ImgF F1 :e finite_subcollections omega.
  { claim HF1fin: finite F1.
    { exact (SepE2 (Power S) (fun F0:set => finite F0) F1 HF1). }
    claim HImgPow: ImgF F1 :e Power omega.
    { exact (image_In_Power S omega f Hfmap F1 HF1pow). }
    claim HImgFin: finite (ImgF F1).
    { exact (Repl_finite f F1 HF1fin). }
    exact (SepI (Power omega) (fun F0:set => finite F0) (ImgF F1) HImgPow HImgFin). }
  claim HImg2: ImgF F2 :e finite_subcollections omega.
  { claim HF2fin: finite F2.
    { exact (SepE2 (Power S) (fun F0:set => finite F0) F2 HF2). }
    claim HImgPow: ImgF F2 :e Power omega.
    { exact (image_In_Power S omega f Hfmap F2 HF2pow). }
    claim HImgFin: finite (ImgF F2).
    { exact (Repl_finite f F2 HF2fin). }
    exact (SepI (Power omega) (fun F0:set => finite F0) (ImgF F2) HImgPow HImgFin). }
  claim Hcodeinj: forall u v :e finite_subcollections omega, code u = code v -> u = v.
  { exact (andER (forall u :e finite_subcollections omega, code u :e omega)
                 (forall u v :e finite_subcollections omega, code u = code v -> u = v)
                 Hcode). }
  claim Hhdef1: h F1 = code (ImgF F1).
  { reflexivity. }
  claim Hhdef2: h F2 = code (ImgF F2).
  { reflexivity. }
  claim HeqImg: ImgF F1 = ImgF F2.
  { apply (Hcodeinj (ImgF F1) HImg1 (ImgF F2) HImg2).
    claim Hcodeeq: code (ImgF F1) = code (ImgF F2).
    { claim Hc1: code (ImgF F1) = h F1.
      { symmetry. exact Hhdef1. }
      claim Hc2: h F2 = code (ImgF F2).
      { exact Hhdef2. }
      claim Hmid: code (ImgF F1) = h F2.
      { exact (eq_i_tra (code (ImgF F1)) (h F1) (h F2) Hc1 Heq). }
      exact (eq_i_tra (code (ImgF F1)) (h F2) (code (ImgF F2)) Hmid Hc2). }
    exact Hcodeeq. }
  apply set_ext.
  + let x. assume Hx1: x :e F1.
    prove x :e F2.
    claim HxS: x :e S.
    { exact (HF1sub x Hx1). }
    claim Hfx1: f x :e ImgF F1.
    { exact (ReplI F1 f x Hx1). }
    claim Hfx2: f x :e ImgF F2.
    { rewrite <- HeqImg. exact Hfx1. }
    apply (ReplE_impred F2 f (f x) Hfx2).
    let y. assume Hy2: y :e F2.
    assume Hfxy: f x = f y.
    claim HyS: y :e S.
    { exact (HF2sub y Hy2). }
    claim Heqxy: x = y.
    { exact (Hf_inj x HxS y HyS Hfxy). }
    rewrite Heqxy.
    exact Hy2.
  + let x. assume Hx2: x :e F2.
    prove x :e F1.
    claim HxS: x :e S.
    { exact (HF2sub x Hx2). }
    claim Hfx2: f x :e ImgF F2.
    { exact (ReplI F2 f x Hx2). }
    claim Hfx1: f x :e ImgF F1.
    { rewrite HeqImg. exact Hfx2. }
    apply (ReplE_impred F1 f (f x) Hfx1).
    let y. assume Hy1: y :e F1.
    assume Hfxy: f x = f y.
    claim HyS: y :e S.
    { exact (HF1sub y Hy1). }
    claim Heqxy: x = y.
    { exact (Hf_inj x HxS y HyS Hfxy). }
    rewrite Heqxy.
    exact Hy1.
Qed.

(** Helper: finite intersections of a countable family form a countable family **)
(** LATEX VERSION: The family of finite intersections of members of a countable family is countable. **)
Theorem finite_intersections_of_countable : forall X S:set,
  countable_set S -> countable_set (finite_intersections_of X S).
let X S. assume HS: countable_set S.
prove countable_set (finite_intersections_of X S).
set FS := finite_subcollections S.
claim HFS: countable_set FS.
{ exact (finite_subcollections_countable S HS). }
exact (countable_image FS HFS (fun F0:set => intersection_of_family X F0)).
Qed.

(** Helper: the basis from a countable subbasis is countable **)
(** LATEX VERSION: If a subbasis is countable, then the associated basis of nonempty finite intersections is countable. **)
Theorem basis_of_subbasis_countable : forall X S:set,
  countable_set S -> countable_set (basis_of_subbasis X S).
let X S. assume HS: countable_set S.
prove countable_set (basis_of_subbasis X S).
claim Hfin: countable_set (finite_intersections_of X S).
{ exact (finite_intersections_of_countable X S HS). }
prove countable (basis_of_subbasis X S).
apply (Subq_countable (basis_of_subbasis X S) (finite_intersections_of X S)).
- exact Hfin.
- let b. assume Hb: b :e basis_of_subbasis X S.
  prove b :e finite_intersections_of X S.
  exact (SepE1 (finite_intersections_of X S) (fun b0:set => b0 <> Empty) b Hb).
Qed.
(** LATEX VERSION: Real sequences and uniform metric/topology on R^ (setup). **)
(** FIXED: Real sequences are functions omega  R, not subsets of R!
    Was: Power R (set of all subsets of R)
    Now: setexp R omega (R^omega, the set of all functions omega  R)
    Using setexp from line 2804 of TRUSTED_DEFS.txt. **)
Definition real_sequences : set := setexp R omega.
Definition uniform_metric_Romega : set := Eps_i (fun d => metric_on real_sequences d).
Definition uniform_topology : set := metric_topology real_sequences uniform_metric_Romega.
(** LATEX VERSION: Open cover and Lindelf space definitions. **)
Definition open_cover : set -> set -> set -> prop :=
  fun X Tx U => (forall u:set, u :e U -> u :e Tx) /\ covers X U.
Definition Lindelof_space : set -> set -> prop :=
  fun X Tx => topology_on X Tx /\ forall U:set, open_cover X Tx U -> exists V:set, countable_subcollection V U /\ covers X V.
(** LATEX VERSION: Sorgenfrey line and its lower limit topology. **)
Definition Sorgenfrey_line : set := R.
Definition Sorgenfrey_topology : set := R_lower_limit_topology.


(** LATEX VERSION: Countable basis at x (Definition 30.1). **)
(** FIXED: Required global basis instead of local basis at x.
    Was: exists B:set, basis_on X B /\ countable_set B /\ ...
         (B is a countable BASIS FOR THE ENTIRE SPACE X!)
    Issue: This would make first countable imply second countable (wrong!).
           A countable basis at x should be a countable LOCAL basis at x, not a global basis.
    Now: exists B:set, B c= Tx /\ countable_set B /\
           (forall b:set, b :e B -> x :e b) /\
           (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e B /\ b c= U)
         (B is a countable collection of open sets containing x that form a local basis at x) **)
Definition countable_basis_at : set -> set -> set -> prop := fun X Tx x =>
  topology_on X Tx /\ x :e X /\
  exists B:set, B c= Tx /\ countable_set B /\
    (forall b:set, b :e B -> x :e b) /\
    (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e B /\ b c= U).

(** from 30 Definition 30.1: first-countable space **) 
(** LATEX VERSION: First countable means each point has a countable neighborhood basis. **)
Definition first_countable_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\ forall x:set, x :e X -> countable_basis_at X Tx x.

(** helper: countable local basis at a point in a nonempty countable product of first-countable spaces **)
(** LATEX VERSION: The usual product argument produces a countable neighborhood basis at a point. **)
Theorem product_countable_basis_at_point_if_components_first_countable : forall I Xi f:set,
  countable_index_set I ->
  I <> Empty ->
  (forall i:set, i :e I -> first_countable_space (space_family_set Xi i) (space_family_topology Xi i)) ->
  f :e product_space I Xi ->
  countable_basis_at (product_space I Xi) (countable_product_topology_subbasis I Xi) f.
let I Xi f.
assume HIcount.
assume HIn0.
assume Hcomp.
assume Hf.
prove countable_basis_at (product_space I Xi) (countable_product_topology_subbasis I Xi) f.
set X := product_space I Xi.
set Tx := countable_product_topology_subbasis I Xi.
set Sfull := product_subbasis_full I Xi.
claim Hfprop: function_on f I (space_family_union I Xi) /\ forall i:set, i :e I -> apply_fun f i :e space_family_set Xi i.
{ exact (SepE2 (Power (setprod I (space_family_union I Xi)))
               (fun f0:set => function_on f0 I (space_family_union I Xi) /\
                 forall i:set, i :e I -> apply_fun f0 i :e space_family_set Xi i)
               f
               Hf). }
claim Hcompf: forall i:set, i :e I -> apply_fun f i :e space_family_set Xi i.
{ exact (andER (function_on f I (space_family_union I Xi))
               (forall i:set, i :e I -> apply_fun f i :e space_family_set Xi i)
               Hfprop). }
claim HcompTop: forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i).
{ let i. assume HiI: i :e I.
  exact (andEL (topology_on (space_family_set Xi i) (space_family_topology Xi i))
               (forall x:set, x :e space_family_set Xi i -> countable_basis_at (space_family_set Xi i) (space_family_topology Xi i) x)
               (Hcomp i HiI)). }
claim HSfull: subbasis_on X Sfull.
{ exact (product_subbasis_full_subbasis_on I Xi HIn0 HcompTop). }
claim HBasisFull: basis_on X (basis_of_subbasis X Sfull).
{ exact (finite_intersections_basis_of_subbasis X Sfull HSfull). }
claim HTprod: topology_on X Tx.
{ claim HTdef: Tx = generated_topology_from_subbasis X Sfull.
  { reflexivity. }
  rewrite HTdef.
  exact (topology_from_subbasis_is_topology X Sfull HSfull). }

set Bsel : set -> set := fun i =>
  Eps_i (fun B0:set =>
    B0 c= space_family_topology Xi i /\ countable_set B0 /\
      (forall b:set, b :e B0 -> apply_fun f i :e b) /\
      (forall U:set, U :e space_family_topology Xi i -> apply_fun f i :e U -> exists b:set, b :e B0 /\ b c= U)).

claim HBsel: forall i:set, i :e I ->
  (Bsel i) c= space_family_topology Xi i /\ countable_set (Bsel i) /\
    (forall b:set, b :e (Bsel i) -> apply_fun f i :e b) /\
    (forall U:set, U :e space_family_topology Xi i -> apply_fun f i :e U -> exists b:set, b :e (Bsel i) /\ b c= U).
{ let i. assume HiI: i :e I.
  claim Hfc_i: first_countable_space (space_family_set Xi i) (space_family_topology Xi i).
  { exact (Hcomp i HiI). }
  claim Hcb_all: forall x:set, x :e space_family_set Xi i ->
    countable_basis_at (space_family_set Xi i) (space_family_topology Xi i) x.
  { exact (andER (topology_on (space_family_set Xi i) (space_family_topology Xi i))
                 (forall x:set, x :e space_family_set Xi i -> countable_basis_at (space_family_set Xi i) (space_family_topology Xi i) x)
                 Hfc_i). }
  claim Hfi: apply_fun f i :e space_family_set Xi i.
  { exact (Hcompf i HiI). }
  claim Hcbi: countable_basis_at (space_family_set Xi i) (space_family_topology Xi i) (apply_fun f i).
  { exact (Hcb_all (apply_fun f i) Hfi). }
  claim HexB0: exists B0:set,
    B0 c= space_family_topology Xi i /\ countable_set B0 /\
      (forall b:set, b :e B0 -> apply_fun f i :e b) /\
      (forall U:set, U :e space_family_topology Xi i -> apply_fun f i :e U -> exists b:set, b :e B0 /\ b c= U).
  { exact (andER (topology_on (space_family_set Xi i) (space_family_topology Xi i) /\ apply_fun f i :e space_family_set Xi i)
                 (exists B0:set,
                   B0 c= space_family_topology Xi i /\ countable_set B0 /\
                     (forall b:set, b :e B0 -> apply_fun f i :e b) /\
                     (forall U:set, U :e space_family_topology Xi i -> apply_fun f i :e U -> exists b:set, b :e B0 /\ b c= U))
                 Hcbi). }
  apply HexB0.
  let B0. assume HB0.
  exact (Eps_i_ax (fun B1:set =>
      B1 c= space_family_topology Xi i /\ countable_set B1 /\
        (forall b:set, b :e B1 -> apply_fun f i :e b) /\
        (forall U:set, U :e space_family_topology Xi i -> apply_fun f i :e U -> exists b:set, b :e B1 /\ b c= U))
    B0 HB0). }

set Ssmall : set := \/_ i :e I, {product_cylinder I Xi i U|U :e Bsel i}.
set FSsmall := finite_subcollections Ssmall.
set B : set := {intersection_of_family X F0|F0 :e FSsmall}.

claim HSsmall_count: countable_set Ssmall.
{ claim HIc: countable I.
  { exact HIcount. }
  claim HBsel_count: forall i:set, i :e I -> countable (Bsel i).
  { let i. assume HiI: i :e I.
    claim HBi: (Bsel i) c= space_family_topology Xi i /\ countable_set (Bsel i) /\
      (forall b:set, b :e (Bsel i) -> apply_fun f i :e b) /\
      (forall U:set, U :e space_family_topology Xi i -> apply_fun f i :e U -> exists b:set, b :e (Bsel i) /\ b c= U).
    { exact (HBsel i HiI). }
    claim Hcore: ((Bsel i) c= space_family_topology Xi i /\ countable_set (Bsel i)) /\
      (forall b:set, b :e (Bsel i) -> apply_fun f i :e b).
    { exact (andEL (((Bsel i) c= space_family_topology Xi i /\ countable_set (Bsel i)) /\
                    (forall b:set, b :e (Bsel i) -> apply_fun f i :e b))
                   (forall U:set, U :e space_family_topology Xi i -> apply_fun f i :e U -> exists b:set, b :e (Bsel i) /\ b c= U)
                   HBi). }
    claim Hpair: (Bsel i) c= space_family_topology Xi i /\ countable_set (Bsel i).
    { exact (andEL ((Bsel i) c= space_family_topology Xi i /\ countable_set (Bsel i))
                   (forall b:set, b :e (Bsel i) -> apply_fun f i :e b)
                   Hcore). }
    exact (andER ((Bsel i) c= space_family_topology Xi i) (countable_set (Bsel i)) Hpair). }
  claim HSig: countable (Sigma_ i :e I, Bsel i).
  { exact (Sigma_countable I HIc Bsel HBsel_count). }
  claim HSig_set: countable_set (Sigma_ i :e I, Bsel i).
  { exact HSig. }
  set F : set -> set := fun p => product_cylinder I Xi (p 0) (p 1).
  set Img := {F p|p :e Sigma_ i :e I, Bsel i}.
  claim HImg_count: countable_set Img.
  { exact (countable_image (Sigma_ i :e I, Bsel i) HSig_set F). }
  apply (Subq_countable Ssmall Img).
  - exact HImg_count.
  - let s. assume Hs: s :e Ssmall.
    prove s :e Img.
    apply (famunionE_impred I (fun i0:set => {product_cylinder I Xi i0 U|U :e Bsel i0}) s Hs).
    let i0. assume Hi0I: i0 :e I.
    assume HsFi0: s :e {product_cylinder I Xi i0 U|U :e Bsel i0}.
    apply (ReplE_impred (Bsel i0) (fun U0:set => product_cylinder I Xi i0 U0) s HsFi0).
    let U0. assume HU0B: U0 :e Bsel i0.
    assume HsEq: s = product_cylinder I Xi i0 U0.
    claim HpSig: (i0,U0) :e Sigma_ i :e I, Bsel i.
    { exact (tuple_2_Sigma I Bsel i0 Hi0I U0 HU0B). }
    claim HFp: F (i0,U0) = product_cylinder I Xi i0 U0.
    { claim HFdef: F (i0,U0) = product_cylinder I Xi ((i0,U0) 0) ((i0,U0) 1).
      { reflexivity. }
      rewrite HFdef.
      rewrite (tuple_2_0_eq i0 U0).
      rewrite (tuple_2_1_eq i0 U0).
      reflexivity. }
    rewrite HsEq.
    rewrite <- HFp.
    exact (ReplI (Sigma_ i :e I, Bsel i) F (i0,U0) HpSig). }

claim HFSsmall: countable_set FSsmall.
{ exact (finite_subcollections_countable Ssmall HSsmall_count). }
claim HBcount: countable_set B.
{ exact (countable_image FSsmall HFSsmall (fun F0:set => intersection_of_family X F0)). }

claim HSsmall_in_Tx: forall s:set, s :e Ssmall -> s :e Tx.
{ let s. assume Hs: s :e Ssmall.
  apply (famunionE_impred I (fun i0:set => {product_cylinder I Xi i0 U|U :e Bsel i0}) s Hs).
  let i0. assume Hi0I: i0 :e I.
  assume HsFi0: s :e {product_cylinder I Xi i0 U|U :e Bsel i0}.
  apply (ReplE_impred (Bsel i0) (fun U0:set => product_cylinder I Xi i0 U0) s HsFi0).
  let U0. assume HU0B: U0 :e Bsel i0.
  assume HsEq: s = product_cylinder I Xi i0 U0.
  claim HBU0: (Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0) /\
    (forall b:set, b :e (Bsel i0) -> apply_fun f i0 :e b) /\
    (forall V:set, V :e space_family_topology Xi i0 -> apply_fun f i0 :e V -> exists b:set, b :e (Bsel i0) /\ b c= V).
  { exact (HBsel i0 Hi0I). }
  claim Hcore: ((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0)) /\
    (forall b:set, b :e (Bsel i0) -> apply_fun f i0 :e b).
  { exact (andEL (((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0)) /\
                  (forall b:set, b :e (Bsel i0) -> apply_fun f i0 :e b))
                 (forall V:set, V :e space_family_topology Xi i0 -> apply_fun f i0 :e V -> exists b:set, b :e (Bsel i0) /\ b c= V)
                 HBU0). }
  claim HsubTop: (Bsel i0) c= space_family_topology Xi i0.
  { exact (andEL ((Bsel i0) c= space_family_topology Xi i0)
                 (countable_set (Bsel i0))
                 (andEL ((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0))
                        (forall b:set, b :e (Bsel i0) -> apply_fun f i0 :e b)
                        Hcore)). }
  claim HU0Top: U0 :e space_family_topology Xi i0.
  { exact (HsubTop U0 HU0B). }
  set cyl := product_cylinder I Xi i0 U0.
  claim HcylSfull: cyl :e Sfull.
  { exact (famunionI I (fun i1:set => {product_cylinder I Xi i1 U|U :e space_family_topology Xi i1})
                   i0 cyl Hi0I (ReplI (space_family_topology Xi i0) (fun U:set => product_cylinder I Xi i0 U) U0 HU0Top)). }
  claim HfiU0: apply_fun f i0 :e U0.
  { exact ((andER ((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0))
                  (forall b:set, b :e (Bsel i0) -> apply_fun f i0 :e b)
                  Hcore) U0 HU0B). }
  claim HfCyl: f :e cyl.
  { exact (SepI X (fun f0:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f0 i0 :e U0)
               f Hf (andI (i0 :e I /\ U0 :e space_family_topology Xi i0) (apply_fun f i0 :e U0)
                        (andI (i0 :e I) (U0 :e space_family_topology Xi i0) Hi0I HU0Top) HfiU0)). }
  claim HcylNe: cyl <> Empty.
  { assume HCeq: cyl = Empty.
    claim HfEmp: f :e Empty.
    { rewrite <- HCeq. exact HfCyl. }
    exact (EmptyE f HfEmp False). }
  claim HcylInBasis: cyl :e basis_of_subbasis X Sfull.
  { exact (subbasis_elem_in_basis X Sfull cyl HSfull HcylSfull HcylNe). }
  claim HcylOpen: cyl :e generated_topology X (basis_of_subbasis X Sfull).
  { exact (generated_topology_contains_basis X (basis_of_subbasis X Sfull) HBasisFull cyl HcylInBasis). }
  claim HTdef: Tx = generated_topology X (basis_of_subbasis X Sfull).
  { reflexivity. }
  rewrite HTdef.
  rewrite HsEq.
  claim HcylDef: cyl = product_cylinder I Xi i0 U0.
  { reflexivity. }
  rewrite <- HcylDef.
  exact HcylOpen. }

prove topology_on X Tx /\ f :e X /\
  exists B0:set, B0 c= Tx /\ countable_set B0 /\
    (forall b:set, b :e B0 -> f :e b) /\
    (forall U:set, U :e Tx -> f :e U -> exists b:set, b :e B0 /\ b c= U).
apply andI.
 - apply andI.
   + exact HTprod.
   + exact Hf.
 - witness B.
   prove B c= Tx /\ countable_set B /\
     (forall b:set, b :e B -> f :e b) /\
     (forall U:set, U :e Tx -> f :e U -> exists b:set, b :e B /\ b c= U).
   apply andI.
   - apply andI.
     + (** B c= Tx and countable_set B **)
       apply andI.
       * let b. assume Hb: b :e B.
         prove b :e Tx.
         apply (ReplE_impred FSsmall (fun F0:set => intersection_of_family X F0) b Hb).
         let F0. assume HF0: F0 :e FSsmall.
         assume HbEq: b = intersection_of_family X F0.
         claim HF0pow: F0 :e Power Ssmall.
         { exact (SepE1 (Power Ssmall) (fun F1:set => finite F1) F0 HF0). }
         claim HF0subS: F0 c= Ssmall.
         { exact (PowerE Ssmall F0 HF0pow). }
         claim HF0fin: finite F0.
         { exact (SepE2 (Power Ssmall) (fun F1:set => finite F1) F0 HF0). }
         claim HF0subT: F0 c= Tx.
         { let s. assume HsF0: s :e F0.
           claim HsS: s :e Ssmall.
           { exact (HF0subS s HsF0). }
           exact (HSsmall_in_Tx s HsS). }
         claim HF0PowT: F0 :e Power Tx.
         { apply PowerI. exact HF0subT. }
         claim Hinter: intersection_of_family X F0 :e Tx.
         { exact (finite_intersection_in_topology X Tx F0 HTprod HF0PowT HF0fin). }
         rewrite HbEq.
         exact Hinter.
       * exact HBcount.
     + (** every b in B contains f **)
       let b. assume Hb: b :e B.
       prove f :e b.
       apply (ReplE_impred FSsmall (fun F0:set => intersection_of_family X F0) b Hb).
       let F0. assume HF0: F0 :e FSsmall.
       assume HbEq: b = intersection_of_family X F0.
       claim HF0pow: F0 :e Power Ssmall.
       { exact (SepE1 (Power Ssmall) (fun F1:set => finite F1) F0 HF0). }
       claim HF0subS: F0 c= Ssmall.
       { exact (PowerE Ssmall F0 HF0pow). }
       rewrite HbEq.
       claim Hprop: forall s:set, s :e F0 -> f :e s.
       { let s. assume HsF0: s :e F0.
         claim HsS: s :e Ssmall.
         { exact (HF0subS s HsF0). }
         apply (famunionE_impred I (fun i0:set => {product_cylinder I Xi i0 U|U :e Bsel i0}) s HsS).
         let i0. assume Hi0I: i0 :e I.
         assume HsFi0: s :e {product_cylinder I Xi i0 U|U :e Bsel i0}.
         apply (ReplE_impred (Bsel i0) (fun U0:set => product_cylinder I Xi i0 U0) s HsFi0).
         let U0. assume HU0B: U0 :e Bsel i0.
         assume HsEq: s = product_cylinder I Xi i0 U0.
         claim HBU0: (Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0) /\
           (forall b0:set, b0 :e (Bsel i0) -> apply_fun f i0 :e b0) /\
           (forall V:set, V :e space_family_topology Xi i0 -> apply_fun f i0 :e V -> exists b0:set, b0 :e (Bsel i0) /\ b0 c= V).
         { exact (HBsel i0 Hi0I). }
         claim Hcore: ((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0)) /\
           (forall b0:set, b0 :e (Bsel i0) -> apply_fun f i0 :e b0).
         { exact (andEL (((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0)) /\
                         (forall b0:set, b0 :e (Bsel i0) -> apply_fun f i0 :e b0))
                        (forall V:set, V :e space_family_topology Xi i0 -> apply_fun f i0 :e V -> exists b0:set, b0 :e (Bsel i0) /\ b0 c= V)
                        HBU0). }
         claim HU0Top: U0 :e space_family_topology Xi i0.
         { exact ((andEL ((Bsel i0) c= space_family_topology Xi i0) (countable_set (Bsel i0))
                         (andEL ((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0))
                                (forall b0:set, b0 :e (Bsel i0) -> apply_fun f i0 :e b0)
                                Hcore)) U0 HU0B). }
         claim HfiU0: apply_fun f i0 :e U0.
         { exact ((andER ((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0))
                         (forall b0:set, b0 :e (Bsel i0) -> apply_fun f i0 :e b0)
                         Hcore) U0 HU0B). }
         rewrite HsEq.
         exact (SepI X (fun f0:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f0 i0 :e U0)
                  f Hf (andI (i0 :e I /\ U0 :e space_family_topology Xi i0) (apply_fun f i0 :e U0)
                           (andI (i0 :e I) (U0 :e space_family_topology Xi i0) Hi0I HU0Top)
                           HfiU0)). }
       exact (SepI X (fun x0:set => forall U:set, U :e F0 -> x0 :e U) f Hf Hprop).
   - (** neighborhood refinement **)
     let U. assume HU: U :e Tx.
     assume HfU: f :e U.
     prove exists b:set, b :e B /\ b c= U.
      claim HTdef: Tx = generated_topology X (basis_of_subbasis X Sfull).
      { reflexivity. }
      claim HUgen: U :e generated_topology X (basis_of_subbasis X Sfull).
      { rewrite <- HTdef. exact HU. }
      claim HUlocal: forall x :e U, exists b0 :e basis_of_subbasis X Sfull, x :e b0 /\ b0 c= U.
      { exact (SepE2 (Power X)
                     (fun U0:set => forall x0 :e U0, exists b0 :e basis_of_subbasis X Sfull, x0 :e b0 /\ b0 c= U0)
                     U HUgen). }
      claim Hexb0: exists b0 :e basis_of_subbasis X Sfull, f :e b0 /\ b0 c= U.
      { exact (HUlocal f HfU). }
      apply Hexb0.
      let b0. assume Hb0pair.
      claim Hb0B: b0 :e basis_of_subbasis X Sfull.
      { exact (andEL (b0 :e basis_of_subbasis X Sfull) (f :e b0 /\ b0 c= U) Hb0pair). }
      claim Hb0prop: f :e b0 /\ b0 c= U.
      { exact (andER (b0 :e basis_of_subbasis X Sfull) (f :e b0 /\ b0 c= U) Hb0pair). }
      claim Hfb0: f :e b0.
      { exact (andEL (f :e b0) (b0 c= U) Hb0prop). }
      claim Hb0subU: b0 c= U.
      { exact (andER (f :e b0) (b0 c= U) Hb0prop). }
      claim Hb0fin: b0 :e finite_intersections_of X Sfull.
      { exact (SepE1 (finite_intersections_of X Sfull) (fun b1:set => b1 <> Empty) b0 Hb0B). }
      claim HexF0: exists F0 :e finite_subcollections Sfull, b0 = intersection_of_family X F0.
      { exact (ReplE (finite_subcollections Sfull) (fun F0:set => intersection_of_family X F0) b0 Hb0fin). }
      apply HexF0.
      let F0. assume HF0pair.
      claim HF0: F0 :e finite_subcollections Sfull.
      { exact (andEL (F0 :e finite_subcollections Sfull) (b0 = intersection_of_family X F0) HF0pair). }
      claim Hb0eq: b0 = intersection_of_family X F0.
      { exact (andER (F0 :e finite_subcollections Sfull) (b0 = intersection_of_family X F0) HF0pair). }
      claim HF0pow: F0 :e Power Sfull.
      { exact (SepE1 (Power Sfull) (fun F1:set => finite F1) F0 HF0). }
      claim HF0sub: F0 c= Sfull.
      { exact (PowerE Sfull F0 HF0pow). }
      claim HF0fin: finite F0.
      { exact (SepE2 (Power Sfull) (fun F1:set => finite F1) F0 HF0). }
      claim HfIntF0: f :e intersection_of_family X F0.
      { rewrite <- Hb0eq. exact Hfb0. }

      set p : set -> prop := fun F:set =>
        F c= Sfull -> f :e intersection_of_family X F ->
          exists G:set, G :e finite_subcollections Ssmall /\
            f :e intersection_of_family X G /\ intersection_of_family X G c= intersection_of_family X F.

      claim HpEmpty: p Empty.
      { prove Empty c= Sfull -> f :e intersection_of_family X Empty ->
          exists G:set, G :e finite_subcollections Ssmall /\
            f :e intersection_of_family X G /\ intersection_of_family X G c= intersection_of_family X Empty.
        assume Hsub0. assume Hf0.
        witness Empty.
        apply andI.
        - apply andI.
          + claim HEmptyPow: Empty :e Power Ssmall.
            { apply PowerI.
              let x. assume Hx: x :e Empty.
              exact (EmptyE x Hx (x :e Ssmall)). }
            exact (SepI (Power Ssmall) (fun F1:set => finite F1) Empty HEmptyPow finite_Empty).
          + exact Hf0.
        - exact (Subq_ref (intersection_of_family X Empty)). }

      claim HpStep: forall F y:set, finite F -> y /:e F -> p F -> p (F :\/: {y}).
      { let F y. assume HFfin: finite F. assume HyNot: y /:e F. assume HpF: p F.
        prove p (F :\/: {y}).
        assume HsubFY: (F :\/: {y}) c= Sfull.
        assume HfIntFY: f :e intersection_of_family X (F :\/: {y}).
        claim HsubF: F c= Sfull.
        { let s. assume HsF: s :e F.
          exact (HsubFY s (binunionI1 F {y} s HsF)). }
        claim HySfull: y :e Sfull.
        { exact (HsubFY y (binunionI2 F {y} y (SingI y))). }
        claim HfInY: f :e y.
        { claim Hall: forall U0:set, U0 :e (F :\/: {y}) -> f :e U0.
          { exact (SepE2 X (fun x0:set => forall U0:set, U0 :e (F :\/: {y}) -> x0 :e U0) f HfIntFY). }
          exact (Hall y (binunionI2 F {y} y (SingI y))). }
        claim HfIntF: f :e intersection_of_family X F.
        { claim HpropF: forall s:set, s :e F -> f :e s.
          { let s. assume HsF: s :e F.
            claim HsFY: s :e (F :\/: {y}).
            { exact (binunionI1 F {y} s HsF). }
            exact ((SepE2 X (fun x0:set => forall U0:set, U0 :e (F :\/: {y}) -> x0 :e U0) f HfIntFY) s HsFY). }
          exact (SepI X (fun x0:set => forall U0:set, U0 :e F -> x0 :e U0) f Hf HpropF). }
        claim HexG0: exists G0:set, G0 :e finite_subcollections Ssmall /\
          f :e intersection_of_family X G0 /\ intersection_of_family X G0 c= intersection_of_family X F.
        { exact (HpF HsubF HfIntF). }
        apply HexG0.
        let G0. assume HG0pair.
        claim HG0core: G0 :e finite_subcollections Ssmall /\ f :e intersection_of_family X G0.
        { exact (andEL (G0 :e finite_subcollections Ssmall /\ f :e intersection_of_family X G0)
                       (intersection_of_family X G0 c= intersection_of_family X F)
                       HG0pair). }
        claim HG0: G0 :e finite_subcollections Ssmall.
        { exact (andEL (G0 :e finite_subcollections Ssmall) (f :e intersection_of_family X G0) HG0core). }
        claim HfIntG0: f :e intersection_of_family X G0.
        { exact (andER (G0 :e finite_subcollections Ssmall) (f :e intersection_of_family X G0) HG0core). }
        claim HG0sub: intersection_of_family X G0 c= intersection_of_family X F.
        { exact (andER (G0 :e finite_subcollections Ssmall /\ f :e intersection_of_family X G0)
                       (intersection_of_family X G0 c= intersection_of_family X F)
                       HG0pair). }

        claim HexRef: exists y0:set, y0 :e Ssmall /\ y0 c= y /\ f :e y0.
        { apply (famunionE_impred I (fun i0:set => {product_cylinder I Xi i0 U|U :e space_family_topology Xi i0}) y HySfull).
          let i0. assume Hi0I: i0 :e I.
          assume HyFi0: y :e {product_cylinder I Xi i0 U|U :e space_family_topology Xi i0}.
          apply (ReplE_impred (space_family_topology Xi i0) (fun U0:set => product_cylinder I Xi i0 U0) y HyFi0).
          let V0. assume HV0Top: V0 :e space_family_topology Xi i0.
          assume HyEq: y = product_cylinder I Xi i0 V0.
          claim HfCyl: f :e product_cylinder I Xi i0 V0.
          { rewrite <- HyEq. exact HfInY. }
          claim HfiV0: apply_fun f i0 :e V0.
          { exact (andER (i0 :e I /\ V0 :e space_family_topology Xi i0)
                         (apply_fun f i0 :e V0)
                         (SepE2 X (fun f0:set => i0 :e I /\ V0 :e space_family_topology Xi i0 /\ apply_fun f0 i0 :e V0) f HfCyl)). }
          claim HBi0: (Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0) /\
            (forall b0:set, b0 :e (Bsel i0) -> apply_fun f i0 :e b0) /\
            (forall U0:set, U0 :e space_family_topology Xi i0 -> apply_fun f i0 :e U0 -> exists b0:set, b0 :e (Bsel i0) /\ b0 c= U0).
          { exact (HBsel i0 Hi0I). }
          claim Href_i0: forall U0:set, U0 :e space_family_topology Xi i0 -> apply_fun f i0 :e U0 -> exists b0:set, b0 :e (Bsel i0) /\ b0 c= U0.
          { exact (andER (((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0)) /\
                          (forall b0:set, b0 :e (Bsel i0) -> apply_fun f i0 :e b0))
                         (forall U0:set, U0 :e space_family_topology Xi i0 -> apply_fun f i0 :e U0 -> exists b0:set, b0 :e (Bsel i0) /\ b0 c= U0)
                         HBi0). }
          claim Hexb0: exists b0:set, b0 :e (Bsel i0) /\ b0 c= V0.
          { exact (Href_i0 V0 HV0Top HfiV0). }
	          apply Hexb0.
	          let b0. assume Hb0pair.
	          claim Hb0B: b0 :e (Bsel i0).
	          { exact (andEL (b0 :e (Bsel i0)) (b0 c= V0) Hb0pair). }
	          claim Hb0sub: b0 c= V0.
	          { exact (andER (b0 :e (Bsel i0)) (b0 c= V0) Hb0pair). }
	          claim Hcore_i0: ((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0)) /\
	            (forall b1:set, b1 :e (Bsel i0) -> apply_fun f i0 :e b1).
	          { exact (andEL (((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0)) /\
	                          (forall b0:set, b0 :e (Bsel i0) -> apply_fun f i0 :e b0))
	                         (forall U0:set, U0 :e space_family_topology Xi i0 -> apply_fun f i0 :e U0 -> exists b0:set, b0 :e (Bsel i0) /\ b0 c= U0)
	                         HBi0). }
	          claim HsubTop: (Bsel i0) c= space_family_topology Xi i0.
	          { exact (andEL ((Bsel i0) c= space_family_topology Xi i0)
	                         (countable_set (Bsel i0))
	                         (andEL ((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0))
	                                (forall b1:set, b1 :e (Bsel i0) -> apply_fun f i0 :e b1)
	                                Hcore_i0)). }
	          claim Hb0Top: b0 :e space_family_topology Xi i0.
	          { exact (HsubTop b0 Hb0B). }
	          claim Hforallb: forall b1:set, b1 :e (Bsel i0) -> apply_fun f i0 :e b1.
	          { exact (andER ((Bsel i0) c= space_family_topology Xi i0 /\ countable_set (Bsel i0))
	                         (forall b1:set, b1 :e (Bsel i0) -> apply_fun f i0 :e b1)
	                         Hcore_i0). }
	          claim Hfb0: apply_fun f i0 :e b0.
	          { exact (Hforallb b0 Hb0B). }
	          set y0 := product_cylinder I Xi i0 b0.
	          witness y0.
	          apply andI.
	          - apply andI.
	            + exact (famunionI I (fun i1:set => {product_cylinder I Xi i1 U|U :e Bsel i1})
	                         i0 y0 Hi0I (ReplI (Bsel i0) (fun U0:set => product_cylinder I Xi i0 U0) b0 Hb0B)).
	            + let g. assume Hg: g :e y0.
	              prove g :e y.
	              claim HgCyl: g :e product_cylinder I Xi i0 b0.
	              { exact Hg. }
	              claim Hgprop: i0 :e I /\ b0 :e space_family_topology Xi i0 /\ apply_fun g i0 :e b0.
	              { exact (SepE2 X (fun g0:set => i0 :e I /\ b0 :e space_family_topology Xi i0 /\ apply_fun g0 i0 :e b0) g HgCyl). }
	              claim Hgi0: apply_fun g i0 :e b0.
	              { exact (andER (i0 :e I /\ b0 :e space_family_topology Xi i0) (apply_fun g i0 :e b0) Hgprop). }
	              claim Hgi0V0: apply_fun g i0 :e V0.
	              { exact (Hb0sub (apply_fun g i0) Hgi0). }
	              rewrite HyEq.
	              exact (SepI X (fun g0:set => i0 :e I /\ V0 :e space_family_topology Xi i0 /\ apply_fun g0 i0 :e V0)
	                       g (SepE1 X (fun g0:set => i0 :e I /\ b0 :e space_family_topology Xi i0 /\ apply_fun g0 i0 :e b0) g HgCyl)
	                       (andI (i0 :e I /\ V0 :e space_family_topology Xi i0) (apply_fun g i0 :e V0)
	                            (andI (i0 :e I) (V0 :e space_family_topology Xi i0) Hi0I HV0Top) Hgi0V0)).
	          - exact (SepI X (fun f0:set => i0 :e I /\ b0 :e space_family_topology Xi i0 /\ apply_fun f0 i0 :e b0)
	                   f Hf (andI (i0 :e I /\ b0 :e space_family_topology Xi i0) (apply_fun f i0 :e b0)
	                            (andI (i0 :e I) (b0 :e space_family_topology Xi i0) Hi0I Hb0Top)
	                            Hfb0)). }
 

        apply HexRef.
        let y0. assume Hy0pair.
        claim Hy0S: y0 :e Ssmall.
        { claim Hy0core: (y0 :e Ssmall /\ y0 c= y).
          { exact (andEL (y0 :e Ssmall /\ y0 c= y) (f :e y0) Hy0pair). }
          exact (andEL (y0 :e Ssmall) (y0 c= y) Hy0core). }
        claim Hy0suby: y0 c= y.
        { claim Hy0core: (y0 :e Ssmall /\ y0 c= y).
          { exact (andEL (y0 :e Ssmall /\ y0 c= y) (f :e y0) Hy0pair). }
          exact (andER (y0 :e Ssmall) (y0 c= y) Hy0core). }
        claim Hfy0: f :e y0.
        { exact (andER (y0 :e Ssmall /\ y0 c= y) (f :e y0) Hy0pair). }

        set G := G0 :\/: {y0}.
        witness G.
        apply andI.
        - apply andI.
          + (** G in finite_subcollections Ssmall **)
            claim HG0pow: G0 :e Power Ssmall.
            { exact (SepE1 (Power Ssmall) (fun F1:set => finite F1) G0 HG0). }
            claim HG0subS: G0 c= Ssmall.
            { exact (PowerE Ssmall G0 HG0pow). }
            claim HG0fin: finite G0.
            { exact (SepE2 (Power Ssmall) (fun F1:set => finite F1) G0 HG0). }
            claim HGsub: G c= Ssmall.
            { let s. assume HsG: s :e G.
              apply (binunionE' G0 {y0} s (s :e Ssmall)).
              - assume HsG0: s :e G0.
                exact (HG0subS s HsG0).
              - assume Hsy0: s :e {y0}.
                rewrite (SingE y0 s Hsy0).
                exact Hy0S.
              - exact HsG. }
            claim HGpow: G :e Power Ssmall.
            { apply PowerI. exact HGsub. }
	            claim HGfin: finite G.
	            { exact (adjoin_finite G0 y0 HG0fin). }
	            exact (SepI (Power Ssmall) (fun F1:set => finite F1) G HGpow HGfin).
	          + (** f in intersection_of_family X G **)
	            claim HpropG: forall s:set, s :e G -> f :e s.
	            { let s. assume HsG: s :e G.
	              apply (binunionE' G0 {y0} s (f :e s)).
	              - assume HsG0: s :e G0.
	                exact ((SepE2 X (fun x0:set => forall U0:set, U0 :e G0 -> x0 :e U0) f HfIntG0) s HsG0).
	              - assume Hsy0: s :e {y0}.
	                rewrite (SingE y0 s Hsy0).
	                exact Hfy0.
	              - exact HsG. }
	            exact (SepI X (fun x0:set => forall U0:set, U0 :e G -> x0 :e U0) f Hf HpropG).
	        - (** inclusion: intersection_of_family X G c= intersection_of_family X (F :\/: {y}) **)
	          let z. assume Hz: z :e intersection_of_family X G.
	          prove z :e intersection_of_family X (F :\/: {y}).
	          claim HzX: z :e X.
	          { exact (SepE1 X (fun x0:set => forall U0:set, U0 :e G -> x0 :e U0) z Hz). }
	          claim HzG: forall U0:set, U0 :e G -> z :e U0.
	          { exact (SepE2 X (fun x0:set => forall U0:set, U0 :e G -> x0 :e U0) z Hz). }
	          claim HzG0: z :e intersection_of_family X G0.
	          { claim HzG0prop: forall s:set, s :e G0 -> z :e s.
	            { let s. assume HsG0: s :e G0.
	              exact (HzG s (binunionI1 G0 {y0} s HsG0)). }
	            exact (SepI X (fun x0:set => forall U0:set, U0 :e G0 -> x0 :e U0) z HzX HzG0prop). }
	          claim HzF: z :e intersection_of_family X F.
	          { exact (HG0sub z HzG0). }
	          claim Hzy0: z :e y0.
	          { exact (HzG y0 (binunionI2 G0 {y0} y0 (SingI y0))). }
	          claim Hzy: z :e y.
	          { exact (Hy0suby z Hzy0). }
	          claim HzFYprop: forall s:set, s :e (F :\/: {y}) -> z :e s.
	          { let s. assume HsFY: s :e (F :\/: {y}).
	            apply (binunionE' F {y} s (z :e s)).
	            - assume HsF: s :e F.
	              exact ((SepE2 X (fun x0:set => forall U0:set, U0 :e F -> x0 :e U0) z HzF) s HsF).
	            - assume Hsy: s :e {y}.
	              rewrite (SingE y s Hsy).
	              exact Hzy.
	            - exact HsFY. }
		          exact (SepI X (fun x0:set => forall U0:set, U0 :e (F :\/: {y}) -> x0 :e U0) z HzX HzFYprop).
	      }

	      claim Hpref: p F0.
	      { exact (finite_ind p HpEmpty HpStep F0 HF0fin). }
      claim HexG: exists G:set, G :e finite_subcollections Ssmall /\
        f :e intersection_of_family X G /\ intersection_of_family X G c= intersection_of_family X F0.
      { exact (Hpref HF0sub HfIntF0). }
      apply HexG.
      let G. assume HGpair.
      claim HGcore: G :e finite_subcollections Ssmall /\ f :e intersection_of_family X G.
      { exact (andEL (G :e finite_subcollections Ssmall /\ f :e intersection_of_family X G)
                     (intersection_of_family X G c= intersection_of_family X F0)
                     HGpair). }
      claim HG: G :e finite_subcollections Ssmall.
      { exact (andEL (G :e finite_subcollections Ssmall) (f :e intersection_of_family X G) HGcore). }
      claim HGsub: intersection_of_family X G c= intersection_of_family X F0.
      { exact (andER (G :e finite_subcollections Ssmall /\ f :e intersection_of_family X G)
                     (intersection_of_family X G c= intersection_of_family X F0)
                     HGpair). }
      set b := intersection_of_family X G.
      witness b.
      apply andI.
      - exact (ReplI FSsmall (fun F1:set => intersection_of_family X F1) G HG).
      - let z. assume Hz: z :e b.
        prove z :e U.
        claim HzF0: z :e intersection_of_family X F0.
        { exact (HGsub z Hz). }
        claim Hzb0: z :e b0.
        { rewrite Hb0eq.
          exact HzF0. }
        exact (Hb0subU z Hzb0).
Qed.

(** from 30 Theorem 30.1(a): sequences and closure in first-countable spaces **) 
(** LATEX VERSION: In first-countable spaces, sequential closure detects topological closure. **)
Theorem first_countable_sequences_detect_closure : forall X Tx A x:set,
  topology_on X Tx ->
  (exists seq:set, sequence_in seq A /\ converges_to X Tx seq x) ->
  x :e closure_of X Tx A.
let X Tx A x.
assume HTx: topology_on X Tx.
assume Hseq: exists seq:set, sequence_in seq A /\ converges_to X Tx seq x.
prove x :e closure_of X Tx A.
apply Hseq.
let seq. assume Hseqpair.
claim Hseqin: sequence_in seq A.
{ exact (andEL (sequence_in seq A) (converges_to X Tx seq x) Hseqpair). }
claim Hconv: converges_to X Tx seq x.
{ exact (andER (sequence_in seq A) (converges_to X Tx seq x) Hseqpair). }
claim HxX: x :e X.
{ claim Hleft: (topology_on X Tx /\ sequence_on seq X) /\ x :e X.
  { exact (andEL ((topology_on X Tx /\ sequence_on seq X) /\ x :e X)
                 (forall U:set, U :e Tx -> x :e U -> exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U)
                 Hconv). }
  exact (andER (topology_on X Tx /\ sequence_on seq X) (x :e X) Hleft). }
claim Hcliff: x :e closure_of X Tx A <-> (forall U :e Tx, x :e U -> U :/\: A <> Empty).
{ exact (closure_characterization X Tx A x HTx HxX). }
apply (iffER (x :e closure_of X Tx A) (forall U :e Tx, x :e U -> U :/\: A <> Empty) Hcliff).
prove forall U :e Tx, x :e U -> U :/\: A <> Empty.
let U. assume HU: U :e Tx. assume HxU: x :e U.
claim Hevent: exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U.
{ claim Htail0: forall V:set, V :e Tx -> x :e V ->
    exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e V.
  { exact (andER ((topology_on X Tx /\ sequence_on seq X) /\ x :e X)
                 (forall V:set, V :e Tx -> x :e V -> exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e V)
                 Hconv). }
  exact (Htail0 U HU HxU). }
apply Hevent.
let N. assume HNpair.
claim HNomega: N :e omega.
{ exact (andEL (N :e omega) (forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U) HNpair). }
claim Htail: forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U.
{ exact (andER (N :e omega) (forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U) HNpair). }
claim HyU: apply_fun seq N :e U.
{ exact (Htail N HNomega (Subq_ref N)). }
claim HyA: apply_fun seq N :e A.
{ exact (Hseqin N HNomega). }
prove U :/\: A <> Empty.
assume HUAEq: U :/\: A = Empty.
claim HyUA: apply_fun seq N :e U :/\: A.
{ exact (binintersectI U A (apply_fun seq N) HyU HyA). }
claim HyEmp: apply_fun seq N :e Empty.
{ rewrite <- HUAEq. exact HyUA. }
exact (EmptyE (apply_fun seq N) HyEmp False).
Qed.

(** from 30 Theorem 30.1(b): sequences and continuity in first-countable spaces **)
(** LATEX VERSION: Sequential criterion for continuity in first-countable spaces. **)
(** FIXED: Multiple errors in the earlier draft of this theorem.
    Issues included: wrong convergence target (Empty instead of a point) and wrong image limit (f instead of f(x)).
    The intended statement is: if x_nx then f(x_n)f(x). **)
Theorem first_countable_sequences_detect_continuity : forall X Tx Y Ty f:set,
  topology_on X Tx -> topology_on Y Ty ->
  (continuous_map X Tx Y Ty f ->
    forall x seq:set, sequence_on seq X -> converges_to X Tx seq x -> converges_to Y Ty (map_sequence f seq) (apply_fun f x)).
let X Tx Y Ty f.
assume HTx: topology_on X Tx.
assume HTy: topology_on Y Ty.
prove continuous_map X Tx Y Ty f ->
    forall x seq:set, sequence_on seq X -> converges_to X Tx seq x -> converges_to Y Ty (map_sequence f seq) (apply_fun f x).
assume Hcont: continuous_map X Tx Y Ty f.
let x seq.
assume Hseqon: sequence_on seq X.
assume Hconv: converges_to X Tx seq x.
prove converges_to Y Ty (map_sequence f seq) (apply_fun f x).
claim Hcont_left: (topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y.
{ exact (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               Hcont). }
claim Hfun: function_on f X Y.
{ exact (andER (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y) Hcont_left). }
claim Hpre: forall V:set, V :e Ty -> preimage_of X f V :e Tx.
{ exact (andER ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
               (forall V:set, V :e Ty -> preimage_of X f V :e Tx)
               Hcont). }
claim Hconv_left: (topology_on X Tx /\ sequence_on seq X) /\ x :e X.
{ exact (andEL ((topology_on X Tx /\ sequence_on seq X) /\ x :e X)
               (forall U:set, U :e Tx -> x :e U -> exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U)
               Hconv). }
claim HxX: x :e X.
{ exact (andER (topology_on X Tx /\ sequence_on seq X) (x :e X) Hconv_left). }
claim HfxY: apply_fun f x :e Y.
{ exact (Hfun x HxX). }
prove topology_on Y Ty /\ sequence_on (map_sequence f seq) Y /\ apply_fun f x :e Y /\
      forall V:set, V :e Ty -> apply_fun f x :e V ->
        exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun (map_sequence f seq) n :e V.
apply andI.
- (** left: (topology_on Y Ty /\ sequence_on ...) /\ apply_fun f x :e Y **)
  apply andI.
  + (** topology_on Y Ty /\ sequence_on (map_sequence f seq) Y **)
    apply andI.
    * exact HTy.
    * prove sequence_on (map_sequence f seq) Y.
      let n. assume Hn: n :e omega.
      prove apply_fun (map_sequence f seq) n :e Y.
      claim HseqnX: apply_fun seq n :e X.
      { exact (Hseqon n Hn). }
      claim Hcomp: apply_fun (map_sequence f seq) n = apply_fun f (apply_fun seq n).
      { exact (compose_fun_apply omega seq f n Hn). }
      rewrite Hcomp.
      exact (Hfun (apply_fun seq n) HseqnX).
  + exact HfxY.
- (** right: neighborhood condition **)
  let V. assume HV: V :e Ty. assume HfxV: apply_fun f x :e V.
  set U := preimage_of X f V.
  claim HUDef: U = preimage_of X f V.
  { reflexivity. }
  claim HUopen: U :e Tx.
  { rewrite HUDef. exact (Hpre V HV). }
  claim HxU: x :e U.
  { rewrite HUDef.
    exact (SepI X (fun x0:set => apply_fun f x0 :e V) x HxX HfxV). }
  claim Htail0: forall W:set, W :e Tx -> x :e W ->
    exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e W.
  { exact (andER ((topology_on X Tx /\ sequence_on seq X) /\ x :e X)
                 (forall W:set, W :e Tx -> x :e W -> exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e W)
                 Hconv). }
  claim Hevent: exists N:set, N :e omega /\ forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U.
  { exact (Htail0 U HUopen HxU). }
  apply Hevent.
  let N. assume HNpair.
  claim HNomega: N :e omega.
  { exact (andEL (N :e omega) (forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U) HNpair). }
  claim Htail: forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U.
  { exact (andER (N :e omega) (forall n:set, n :e omega -> N c= n -> apply_fun seq n :e U) HNpair). }
  witness N.
  apply andI.
  + exact HNomega.
  + let n. assume Hn: n :e omega. assume HNsub: N c= n.
    claim HseqnU: apply_fun seq n :e U.
    { exact (Htail n Hn HNsub). }
    claim HseqnU0: apply_fun seq n :e preimage_of X f V.
    { rewrite <- HUDef. exact HseqnU. }
    claim HfnV: apply_fun f (apply_fun seq n) :e V.
    { exact (SepE2 X (fun x0:set => apply_fun f x0 :e V) (apply_fun seq n) HseqnU0). }
    claim Hcomp: apply_fun (map_sequence f seq) n = apply_fun f (apply_fun seq n).
    { exact (compose_fun_apply omega seq f n Hn). }
    rewrite Hcomp.
    exact HfnV.
Qed.

(** from 30 Definition: second-countable space **) 
(** LATEX VERSION: Second countable means existence of a countable basis for the topology. **)
Definition second_countable_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\ exists B:set, basis_on X B /\ countable_set B /\ basis_generates X B Tx.

(** from 30 Example 1: R^n has countable basis **) 
Theorem euclidean_spaces_second_countable : forall n:set,
  second_countable_space (euclidean_space n) (euclidean_topology n).
let n.
prove second_countable_space (euclidean_space n) (euclidean_topology n).
admit. (** rational rectangles form countable basis for R^n **)
Qed.

(** from 30 Example 2: uniform topology on R^omega not second countable **) 
Theorem Romega_uniform_first_not_second_countable :
  first_countable_space real_sequences uniform_topology /\
  ~ second_countable_space real_sequences uniform_topology.
prove first_countable_space real_sequences uniform_topology /\ ~ second_countable_space real_sequences uniform_topology.
admit. (** balls at each point form countable basis; but uncountably many separated open sets **)
Qed.

(** from 30 Theorem 30.2: countability axioms preserved by subspaces and countable products **)
(** LATEX VERSION: First/second countability are inherited by subspaces and countable products (Theorem 30.2). **)
(** FIXED: Quantifier scope error in product clauses.
    Was: forall i:set, first_countable_space Xi ... (i ranges over ALL sets!)
    Now: forall i:set, i :e I -> first_countable_space Xi ... (i restricted to index set I)
    The product should only require spaces indexed by iI to be first/second countable. **)
Theorem countability_axioms_subspace_product : forall X Tx:set,
  topology_on X Tx ->
  (forall A:set, A c= X -> first_countable_space X Tx -> first_countable_space A (subspace_topology X Tx A)) /\
  (forall A:set, A c= X -> second_countable_space X Tx -> second_countable_space A (subspace_topology X Tx A)) /\
  (forall I Xi:set, countable_index_set I ->
    (forall i:set, i :e I -> first_countable_space (space_family_set Xi i) (space_family_topology Xi i)) ->
    first_countable_space (countable_product_space I Xi) (countable_product_topology_subbasis I Xi)) /\
  (forall I Xi:set, countable_index_set I ->
    (forall i:set, i :e I -> second_countable_space (space_family_set Xi i) (space_family_topology Xi i)) ->
    second_countable_space (countable_product_space I Xi) (countable_product_topology_subbasis I Xi)).
let X Tx.
assume HTx: topology_on X Tx.
prove (forall A:set, A c= X -> first_countable_space X Tx -> first_countable_space A (subspace_topology X Tx A)) /\
  (forall A:set, A c= X -> second_countable_space X Tx -> second_countable_space A (subspace_topology X Tx A)) /\
  (forall I Xi:set, countable_index_set I ->
    (forall i:set, i :e I -> first_countable_space (space_family_set Xi i) (space_family_topology Xi i)) ->
    first_countable_space (countable_product_space I Xi) (countable_product_topology_subbasis I Xi)) /\
  (forall I Xi:set, countable_index_set I ->
    (forall i:set, i :e I -> second_countable_space (space_family_set Xi i) (space_family_topology Xi i)) ->
    second_countable_space (countable_product_space I Xi) (countable_product_topology_subbasis I Xi)).
apply andI.
- (** first three clauses **)
  apply andI.
  + (** first two clauses **)
    apply andI.
    * (** first countable preserved by subspaces **)
      let A. assume HA: A c= X.
      assume Hfc: first_countable_space X Tx.
      prove first_countable_space A (subspace_topology X Tx A).
      claim HtopSub: topology_on A (subspace_topology X Tx A).
      { exact (subspace_topology_is_topology X Tx A HTx HA). }
      claim HfcTop: topology_on X Tx.
      { exact (andEL (topology_on X Tx) (forall x:set, x :e X -> countable_basis_at X Tx x) Hfc). }
      claim HfcAt: forall x:set, x :e X -> countable_basis_at X Tx x.
      { exact (andER (topology_on X Tx) (forall x:set, x :e X -> countable_basis_at X Tx x) Hfc). }
      prove topology_on A (subspace_topology X Tx A) /\
           forall x:set, x :e A -> countable_basis_at A (subspace_topology X Tx A) x.
      apply andI.
      { exact HtopSub. }
      { let x. assume HxA: x :e A.
        prove countable_basis_at A (subspace_topology X Tx A) x.
        claim HxX: x :e X.
        { exact (HA x HxA). }
        claim Hcbx: countable_basis_at X Tx x.
        { exact (HfcAt x HxX). }
        claim Hcbx_left: (topology_on X Tx /\ x :e X) /\ exists Bx:set,
          Bx c= Tx /\ countable_set Bx /\ (forall b:set, b :e Bx -> x :e b) /\
          (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e Bx /\ b c= U).
        { exact Hcbx. }
        claim HexBx: exists Bx:set,
          Bx c= Tx /\ countable_set Bx /\ (forall b:set, b :e Bx -> x :e b) /\
          (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e Bx /\ b c= U).
        { exact (andER (topology_on X Tx /\ x :e X)
                       (exists Bx:set, Bx c= Tx /\ countable_set Bx /\ (forall b:set, b :e Bx -> x :e b) /\
                                        (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e Bx /\ b c= U))
                       Hcbx_left). }
        prove topology_on A (subspace_topology X Tx A) /\ x :e A /\
          exists BxA:set,
            BxA c= subspace_topology X Tx A /\ countable_set BxA /\
              (forall b:set, b :e BxA -> x :e b) /\
              (forall U0:set, U0 :e subspace_topology X Tx A -> x :e U0 -> exists b:set, b :e BxA /\ b c= U0).
        apply andI.
        - apply andI.
          + exact HtopSub.
          + exact HxA.
        - apply HexBx.
            let Bx. assume HBxpair.
            claim Htmp1: (Bx c= Tx /\ countable_set Bx) /\ (forall b:set, b :e Bx -> x :e b).
            { exact (andEL ((Bx c= Tx /\ countable_set Bx) /\ (forall b:set, b :e Bx -> x :e b))
                           (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e Bx /\ b c= U)
                           HBxpair). }
            claim HBxref: forall U:set, U :e Tx -> x :e U -> exists b:set, b :e Bx /\ b c= U.
            { exact (andER ((Bx c= Tx /\ countable_set Bx) /\ (forall b:set, b :e Bx -> x :e b))
                           (forall U:set, U :e Tx -> x :e U -> exists b:set, b :e Bx /\ b c= U)
                           HBxpair). }
            claim Htmp2: Bx c= Tx /\ countable_set Bx.
            { exact (andEL (Bx c= Tx /\ countable_set Bx)
                           (forall b:set, b :e Bx -> x :e b)
                           Htmp1). }
            claim HBxmem: forall b:set, b :e Bx -> x :e b.
            { exact (andER (Bx c= Tx /\ countable_set Bx)
                           (forall b:set, b :e Bx -> x :e b)
                           Htmp1). }
            claim HBxsub: Bx c= Tx.
            { exact (andEL (Bx c= Tx) (countable_set Bx) Htmp2). }
            claim HBxcount: countable_set Bx.
            { exact (andER (Bx c= Tx) (countable_set Bx) Htmp2). }
            set BxA := {b :/\: A | b :e Bx}.
            witness BxA.
            apply andI.
            - (** left: (subset and countable) and neighborhood membership **)
              apply andI.
              + (** subset and countable_set **)
                apply andI.
                * prove BxA c= subspace_topology X Tx A.
                  let c. assume Hc: c :e BxA.
                  prove c :e subspace_topology X Tx A.
                  apply (ReplE_impred Bx (fun b0:set => b0 :/\: A) c Hc).
                  let b. assume HbBx: b :e Bx. assume Hceq: c = b :/\: A.
                  claim HbTx: b :e Tx.
                  { exact (HBxsub b HbBx). }
                  claim HcPowA: c :e Power A.
                  { apply PowerI A c.
                    let y. assume Hyc: y :e c.
                    claim HybA: y :e b :/\: A.
                    { rewrite <- Hceq. exact Hyc. }
                    exact (binintersectE2 b A y HybA). }
                  claim HcProp: exists V :e Tx, c = V :/\: A.
                  { witness b.
                    apply andI.
                    - exact HbTx.
                    - exact Hceq. }
                  exact (SepI (Power A) (fun U0:set => exists V :e Tx, U0 = V :/\: A) c HcPowA HcProp).
                * exact (countable_image Bx HBxcount (fun b0:set => b0 :/\: A)).
              + (** each element contains x **)
                let c. assume Hc: c :e BxA.
                prove x :e c.
                apply (ReplE_impred Bx (fun b0:set => b0 :/\: A) c Hc).
                let b. assume HbBx: b :e Bx. assume Hceq: c = b :/\: A.
                claim Hxb: x :e b.
                { exact (HBxmem b HbBx). }
                claim HxBA: x :e b :/\: A.
                { exact (binintersectI b A x Hxb HxA). }
                rewrite Hceq.
                exact HxBA.
            - (** refinement for subspace neighborhoods **)
              let U0.
              assume HU0: U0 :e subspace_topology X Tx A.
              assume HxU0: x :e U0.
              claim HU0prop: exists V :e Tx, U0 = V :/\: A.
              { exact (SepE2 (Power A) (fun U1:set => exists V :e Tx, U1 = V :/\: A) U0 HU0). }
              apply HU0prop.
              let V. assume HVpair.
              claim HVTx: V :e Tx.
              { exact (andEL (V :e Tx) (U0 = V :/\: A) HVpair). }
              claim HU0eq: U0 = V :/\: A.
              { exact (andER (V :e Tx) (U0 = V :/\: A) HVpair). }
              claim HxVA: x :e V :/\: A.
              { rewrite <- HU0eq. exact HxU0. }
              claim HxV: x :e V.
              { exact (binintersectE1 V A x HxVA). }
              claim Hexb: exists b:set, b :e Bx /\ b c= V.
              { exact (HBxref V HVTx HxV). }
              apply Hexb.
              let b. assume Hbpair3.
              claim HbBx: b :e Bx.
              { exact (andEL (b :e Bx) (b c= V) Hbpair3). }
              claim HbsubV: b c= V.
              { exact (andER (b :e Bx) (b c= V) Hbpair3). }
              set c := b :/\: A.
              witness c.
              apply andI.
              - prove c :e BxA.
                exact (ReplI Bx (fun b0:set => b0 :/\: A) b HbBx).
              - prove c c= U0.
                let y. assume Hyc: y :e c.
                claim Hyb: y :e b.
                { exact (binintersectE1 b A y Hyc). }
                claim HyA: y :e A.
                { exact (binintersectE2 b A y Hyc). }
                claim HyV: y :e V.
                { exact (HbsubV y Hyb). }
                claim HyVA: y :e V :/\: A.
                { exact (binintersectI V A y HyV HyA). }
                rewrite HU0eq.
                exact HyVA.
      }
    * (** second countable preserved by subspaces **)
      let A. assume HA: A c= X.
      assume Hsc: second_countable_space X Tx.
      prove second_countable_space A (subspace_topology X Tx A).
      claim HtopSub: topology_on A (subspace_topology X Tx A).
      { exact (subspace_topology_is_topology X Tx A HTx HA). }
      claim HexB: exists B:set, basis_on X B /\ countable_set B /\ basis_generates X B Tx.
      { exact (andER (topology_on X Tx) (exists B:set, basis_on X B /\ countable_set B /\ basis_generates X B Tx) Hsc). }
      apply HexB.
      let B. assume HBpair.
      claim HBmid: (basis_on X B /\ countable_set B) /\ basis_generates X B Tx.
      { exact HBpair. }
      claim HBasisCount: basis_on X B /\ countable_set B.
      { exact (andEL (basis_on X B /\ countable_set B) (basis_generates X B Tx) HBmid). }
      claim HBgener: basis_generates X B Tx.
      { exact (andER (basis_on X B /\ countable_set B) (basis_generates X B Tx) HBmid). }
      claim HBasis: basis_on X B.
      { exact (andEL (basis_on X B) (countable_set B) HBasisCount). }
      claim HBcount: countable_set B.
      { exact (andER (basis_on X B) (countable_set B) HBasisCount). }
      claim HgenEq: generated_topology X B = Tx.
      { exact (andER (basis_on X B) (generated_topology X B = Tx) HBgener). }
      claim HBgen: basis_on X B /\ generated_topology X B = Tx.
      { apply andI.
        - exact HBasis.
        - exact HgenEq. }
      claim HsubB: basis_on A {b :/\: A | b :e B} /\ generated_topology A {b :/\: A | b :e B} = subspace_topology X Tx A.
      { exact (subspace_basis X Tx A B HTx HA HBgen). }
      claim HBsubA: basis_on A {b :/\: A | b :e B}.
      { exact (andEL (basis_on A {b :/\: A | b :e B})
                     (generated_topology A {b :/\: A | b :e B} = subspace_topology X Tx A)
                     HsubB). }
      claim HgenSubEq: generated_topology A {b :/\: A | b :e B} = subspace_topology X Tx A.
      { exact (andER (basis_on A {b :/\: A | b :e B})
                     (generated_topology A {b :/\: A | b :e B} = subspace_topology X Tx A)
                     HsubB). }
      prove topology_on A (subspace_topology X Tx A) /\
           exists B0:set, basis_on A B0 /\ countable_set B0 /\ basis_generates A B0 (subspace_topology X Tx A).
      apply andI.
      { exact HtopSub. }
      { witness {b :/\: A | b :e B}.
        apply andI.
        - (** basis_on and countable_set **)
          apply andI.
          + exact HBsubA.
          + exact (countable_image B HBcount (fun b0:set => b0 :/\: A)).
        - (** basis_generates **)
          prove basis_on A {b :/\: A | b :e B} /\
                generated_topology A {b :/\: A | b :e B} = subspace_topology X Tx A.
          apply andI.
          + exact HBsubA.
          + exact HgenSubEq. }
	  + (** first countable for countable products **)
	    let I Xi.
	    assume HIcount: countable_index_set I.
	    assume Hcomp: forall i:set, i :e I -> first_countable_space (space_family_set Xi i) (space_family_topology Xi i).
	    prove first_countable_space (countable_product_space I Xi) (countable_product_topology_subbasis I Xi).
	    prove topology_on (countable_product_space I Xi) (countable_product_topology_subbasis I Xi) /\
	         forall f:set, f :e countable_product_space I Xi -> countable_basis_at (countable_product_space I Xi) (countable_product_topology_subbasis I Xi) f.
	    apply andI.
		    - (** topology_on for product **)
		      apply (xm (I = Empty)).
		      + assume HI0: I = Empty.
		        rewrite HI0.
		        exact (countable_product_topology_subbasis_empty_is_topology Xi).
		      + assume HIn0: ~(I = Empty).
		        claim HcompTop: forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i).
		        { let i. assume HiI: i :e I.
		          exact (andEL (topology_on (space_family_set Xi i) (space_family_topology Xi i))
		                       (forall x:set, x :e space_family_set Xi i -> countable_basis_at (space_family_set Xi i) (space_family_topology Xi i) x)
		                       (Hcomp i HiI)). }
		        claim HS: subbasis_on (product_space I Xi) (product_subbasis_full I Xi).
		        { exact (product_subbasis_full_subbasis_on I Xi HIn0 HcompTop). }
		        claim HB: basis_on (product_space I Xi) (basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi)).
		        { exact (finite_intersections_basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi) HS). }
		        exact (lemma_topology_from_basis (product_space I Xi) (basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi)) HB).
		    - (** local countable basis at points **)
		      let f. assume Hf: f :e countable_product_space I Xi.
		      prove countable_basis_at (countable_product_space I Xi) (countable_product_topology_subbasis I Xi) f.
		      apply (xm (I = Empty)).
		      + assume HI0: I = Empty.
		        claim Hf0: f :e product_space Empty Xi.
		        { rewrite <- HI0. exact Hf. }
		        rewrite HI0.
		        prove countable_basis_at (product_space Empty Xi) (countable_product_topology_subbasis Empty Xi) f.
		        claim HT0: topology_on (product_space Empty Xi) (countable_product_topology_subbasis Empty Xi).
		        { exact (countable_product_topology_subbasis_empty_is_topology Xi). }
			        prove topology_on (product_space Empty Xi) (countable_product_topology_subbasis Empty Xi) /\ f :e product_space Empty Xi /\
			          exists B:set, B c= countable_product_topology_subbasis Empty Xi /\ countable_set B /\
			            (forall b:set, b :e B -> f :e b) /\
			            (forall U:set, U :e countable_product_topology_subbasis Empty Xi -> f :e U -> exists b:set, b :e B /\ b c= U).
			        apply andI.
			        - apply andI.
			          + exact HT0.
			          + exact Hf0.
			        - witness (Sing (product_space Empty Xi)).
			          prove ((Sing (product_space Empty Xi) c= countable_product_topology_subbasis Empty Xi /\ countable_set (Sing (product_space Empty Xi))) /\
			            (forall b:set, b :e Sing (product_space Empty Xi) -> f :e b)) /\
			              (forall U:set, U :e countable_product_topology_subbasis Empty Xi -> f :e U -> exists b:set, b :e Sing (product_space Empty Xi) /\ b c= U).
			          apply andI.
			          - apply andI.
			            + (** B c= Tx and countable_set **)
			              apply andI.
			              - (** B c= Tx **)
			                let b. assume Hb: b :e Sing (product_space Empty Xi).
			                prove b :e countable_product_topology_subbasis Empty Xi.
			                claim HbX0: b = product_space Empty Xi.
			                { exact (SingE (product_space Empty Xi) b Hb). }
			                rewrite HbX0.
			                exact (topology_has_X (product_space Empty Xi) (countable_product_topology_subbasis Empty Xi) HT0).
			              - (** countable_set B **)
			                exact (finite_countable (Sing (product_space Empty Xi)) (Sing_finite (product_space Empty Xi))).
			            + (** every b in B contains f **)
			              let b. assume Hb: b :e Sing (product_space Empty Xi).
			              prove f :e b.
			              claim HbX0: b = product_space Empty Xi.
			              { exact (SingE (product_space Empty Xi) b Hb). }
			              rewrite HbX0.
			              exact Hf0.
			          - (** neighborhood refinement **)
			            let U. assume HU: U :e countable_product_topology_subbasis Empty Xi.
			            assume HfU: f :e U.
			            prove exists b:set, b :e Sing (product_space Empty Xi) /\ b c= U.
			            witness (product_space Empty Xi).
			            apply andI.
			            + exact (SingI (product_space Empty Xi)).
			            + claim HX0eq: product_space Empty Xi = {Empty}.
			              { exact (product_space_empty_index Xi). }
			              claim Hf0eq: f = Empty.
			              { apply (SingE Empty f).
			                rewrite <- HX0eq.
			                exact Hf0. }
			              let y. assume HyX0: y :e product_space Empty Xi.
			              prove y :e U.
			              claim Hy0: y = Empty.
			              { apply (SingE Empty y).
			                rewrite <- HX0eq.
			                exact HyX0. }
			              rewrite Hy0.
			              rewrite <- Hf0eq.
			              exact HfU.
			      + assume HIn0: ~(I = Empty).
			        prove countable_basis_at (countable_product_space I Xi) (countable_product_topology_subbasis I Xi) f.
			        (** Expand the definition; only the existence of a countable local base is postponed. **)
			        claim HcompTop: forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i).
			        { let i. assume HiI: i :e I.
			          exact (andEL (topology_on (space_family_set Xi i) (space_family_topology Xi i))
			                       (forall x:set, x :e space_family_set Xi i -> countable_basis_at (space_family_set Xi i) (space_family_topology Xi i) x)
			                       (Hcomp i HiI)). }
			        claim HS: subbasis_on (product_space I Xi) (product_subbasis_full I Xi).
			        { exact (product_subbasis_full_subbasis_on I Xi HIn0 HcompTop). }
			        claim HB: basis_on (product_space I Xi) (basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi)).
			        { exact (finite_intersections_basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi) HS). }
			        claim HTprod: topology_on (product_space I Xi) (countable_product_topology_subbasis I Xi).
			        { exact (lemma_topology_from_basis (product_space I Xi) (basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi)) HB). }
			        prove topology_on (product_space I Xi) (countable_product_topology_subbasis I Xi) /\ f :e product_space I Xi /\
			          exists B:set, B c= countable_product_topology_subbasis I Xi /\ countable_set B /\
			            (forall b:set, b :e B -> f :e b) /\
			            (forall U:set, U :e countable_product_topology_subbasis I Xi -> f :e U -> exists b:set, b :e B /\ b c= U).
				        apply andI.
				        - apply andI.
				          + exact HTprod.
				          + exact Hf.
				        - claim Hcb: countable_basis_at (product_space I Xi) (countable_product_topology_subbasis I Xi) f.
				          { exact (product_countable_basis_at_point_if_components_first_countable I Xi f HIcount HIn0 Hcomp Hf). }
				          exact (andER (topology_on (product_space I Xi) (countable_product_topology_subbasis I Xi) /\ f :e product_space I Xi)
				                       (exists B:set, B c= countable_product_topology_subbasis I Xi /\ countable_set B /\
				                         (forall b:set, b :e B -> f :e b) /\
				                         (forall U:set, U :e countable_product_topology_subbasis I Xi -> f :e U -> exists b:set, b :e B /\ b c= U))
				                       Hcb).
		- (** second countable for countable products **)
		  let I Xi.
		  assume HIcount: countable_index_set I.
		  assume Hcomp: forall i:set, i :e I -> second_countable_space (space_family_set Xi i) (space_family_topology Xi i).
		  prove second_countable_space (countable_product_space I Xi) (countable_product_topology_subbasis I Xi).
	  prove topology_on (countable_product_space I Xi) (countable_product_topology_subbasis I Xi) /\
	       exists B:set, basis_on (countable_product_space I Xi) B /\ countable_set B /\ basis_generates (countable_product_space I Xi) B (countable_product_topology_subbasis I Xi).
	  apply andI.
		  - (** topology_on for product **)
		    apply (xm (I = Empty)).
		    + assume HI0: I = Empty.
		      rewrite HI0.
		      exact (countable_product_topology_subbasis_empty_is_topology Xi).
		    + assume HIn0: ~(I = Empty).
		      claim HcompTop: forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i).
		      { let i. assume HiI: i :e I.
		        exact (andEL (topology_on (space_family_set Xi i) (space_family_topology Xi i))
		                     (exists B0:set, basis_on (space_family_set Xi i) B0 /\ countable_set B0 /\ basis_generates (space_family_set Xi i) B0 (space_family_topology Xi i))
		                     (Hcomp i HiI)). }
		      claim HS: subbasis_on (product_space I Xi) (product_subbasis_full I Xi).
		      { exact (product_subbasis_full_subbasis_on I Xi HIn0 HcompTop). }
		      claim HB: basis_on (product_space I Xi) (basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi)).
		      { exact (finite_intersections_basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi) HS). }
		      exact (lemma_topology_from_basis (product_space I Xi) (basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi)) HB).
		  - (** existence of countable basis **)
			    apply (xm (I = Empty)).
			    + assume HI0: I = Empty.
			      rewrite HI0.
			      witness (Sing (product_space Empty Xi)).
			      apply andI.
			      - apply andI.
			        + exact (basis_on_singleton (product_space Empty Xi)).
			        + exact (finite_countable (Sing (product_space Empty Xi)) (Sing_finite (product_space Empty Xi))).
			      - (** basis_generates **)
			        prove basis_on (product_space Empty Xi) {product_space Empty Xi} /\
			          generated_topology (product_space Empty Xi) {product_space Empty Xi} = countable_product_topology_subbasis Empty Xi.
			        apply andI.
			        + exact (basis_on_singleton (product_space Empty Xi)).
			        + claim HTdef: countable_product_topology_subbasis Empty Xi =
			            generated_topology_from_subbasis (product_space Empty Xi) (product_subbasis_full Empty Xi).
			          { reflexivity. }
			          rewrite HTdef.
				          claim HS0: product_subbasis_full Empty Xi = Empty.
				          { exact (famunion_Empty (fun i:set => {product_cylinder Empty Xi i U|U :e space_family_topology Xi i})). }
				          rewrite HS0.
				          claim HGTS0: generated_topology_from_subbasis (product_space Empty Xi) Empty =
				            generated_topology (product_space Empty Xi) (basis_of_subbasis (product_space Empty Xi) Empty).
				          { reflexivity. }
				          rewrite HGTS0.
				          claim HX0ne: product_space Empty Xi <> Empty.
				          { assume HX0E: product_space Empty Xi = Empty.
				            claim Hem: Empty :e product_space Empty Xi.
			            { rewrite (product_space_empty_index Xi).
			              exact (SingI Empty). }
			            claim HemE: Empty :e Empty.
			            { rewrite <- HX0E at 2. exact Hem. }
			            exact (EmptyE Empty HemE False). }
			          claim HB0eq: basis_of_subbasis (product_space Empty Xi) Empty = {product_space Empty Xi}.
			          { exact (basis_of_subbasis_empty_eq (product_space Empty Xi) HX0ne). }
			          rewrite HB0eq.
			          reflexivity.
					    + assume HIn0: ~(I = Empty).
					      set Bsel : set->set := fun i =>
					        Eps_i (fun B0:set =>
					          basis_on (space_family_set Xi i) B0 /\ countable_set B0 /\ basis_generates (space_family_set Xi i) B0 (space_family_topology Xi i)).
					      set Ssmall : set := \/_ i :e I, {product_cylinder I Xi i U|U :e Bsel i}.
					      claim HBsel: forall i:set, i :e I ->
					        basis_on (space_family_set Xi i) (Bsel i) /\ countable_set (Bsel i) /\ basis_generates (space_family_set Xi i) (Bsel i) (space_family_topology Xi i).
					      { let i. assume HiI: i :e I.
					        claim HexB0: exists B0:set, basis_on (space_family_set Xi i) B0 /\ countable_set B0 /\ basis_generates (space_family_set Xi i) B0 (space_family_topology Xi i).
					        { exact (andER (topology_on (space_family_set Xi i) (space_family_topology Xi i))
					                      (exists B0:set, basis_on (space_family_set Xi i) B0 /\ countable_set B0 /\ basis_generates (space_family_set Xi i) B0 (space_family_topology Xi i))
					                      (Hcomp i HiI)). }
					        apply HexB0.
					        let B0. assume HB0: basis_on (space_family_set Xi i) B0 /\ countable_set B0 /\ basis_generates (space_family_set Xi i) B0 (space_family_topology Xi i).
					        exact (Eps_i_ax (fun B1:set => basis_on (space_family_set Xi i) B1 /\ countable_set B1 /\ basis_generates (space_family_set Xi i) B1 (space_family_topology Xi i)) B0 HB0). }
					      claim HSsmall: subbasis_on (product_space I Xi) Ssmall.
					      { prove Ssmall c= Power (product_space I Xi) /\ Union Ssmall = product_space I Xi.
					        apply andI.
					        - let s. assume Hs: s :e Ssmall.
					          prove s :e Power (product_space I Xi).
					          apply (famunionE_impred I (fun i0:set => {product_cylinder I Xi i0 U|U :e Bsel i0}) s Hs).
					          let i0. assume Hi0I. assume HsFi0: s :e {product_cylinder I Xi i0 U|U :e Bsel i0}.
					          apply (ReplE_impred (Bsel i0) (fun U0:set => product_cylinder I Xi i0 U0) s HsFi0).
					          let U0. assume HU0B: U0 :e Bsel i0.
					          assume HsEq: s = product_cylinder I Xi i0 U0.
					          rewrite HsEq.
					          apply PowerI.
					          let f0. assume Hf0: f0 :e product_cylinder I Xi i0 U0.
					          exact (SepE1 (product_space I Xi) (fun f1:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e U0) f0 Hf0).
					        - apply set_ext.
					          + let f0. assume Hf0: f0 :e Union Ssmall.
					            prove f0 :e product_space I Xi.
					            apply UnionE_impred Ssmall f0 Hf0.
					            let s. assume Hf0s: f0 :e s. assume Hs: s :e Ssmall.
						            apply (famunionE_impred I (fun i0:set => {product_cylinder I Xi i0 U|U :e Bsel i0}) s Hs).
						            let i0. assume Hi0I. assume HsFi0: s :e {product_cylinder I Xi i0 U|U :e Bsel i0}.
						            apply (ReplE_impred (Bsel i0) (fun U0:set => product_cylinder I Xi i0 U0) s HsFi0).
						            let U0. assume HU0B: U0 :e Bsel i0.
						            assume HsEq: s = product_cylinder I Xi i0 U0.
						            claim HsPow: s :e Power (product_space I Xi).
						            { rewrite HsEq.
						              apply PowerI.
						              let f1. assume Hf1: f1 :e product_cylinder I Xi i0 U0.
						              exact (SepE1 (product_space I Xi) (fun f2:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f2 i0 :e U0) f1 Hf1). }
						            claim HsSub: s c= product_space I Xi.
						            { exact (PowerE (product_space I Xi) s HsPow). }
						            exact (HsSub f0 Hf0s).
					          + let f0. assume Hf0: f0 :e product_space I Xi.
					            prove f0 :e Union Ssmall.
					            claim Hexi: exists i0:set, i0 :e I.
					            { exact (nonempty_has_element I HIn0). }
					            apply Hexi.
					            let i0. assume Hi0I: i0 :e I.
					            claim HBsel_i0c: basis_on (space_family_set Xi i0) (Bsel i0) /\ countable_set (Bsel i0).
					            { exact (andEL (basis_on (space_family_set Xi i0) (Bsel i0) /\ countable_set (Bsel i0))
					                           (basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0))
					                           (HBsel i0 Hi0I)). }
					            claim HBsel_i0: basis_on (space_family_set Xi i0) (Bsel i0).
					            { exact (andEL (basis_on (space_family_set Xi i0) (Bsel i0))
					                           (countable_set (Bsel i0))
					                           HBsel_i0c). }
					            claim HBcover: forall x :e space_family_set Xi i0, exists b :e Bsel i0, x :e b.
					            { exact (andER (Bsel i0 c= Power (space_family_set Xi i0))
					                           (forall x :e space_family_set Xi i0, exists b :e Bsel i0, x :e b)
					                           (andEL (Bsel i0 c= Power (space_family_set Xi i0) /\ (forall x :e space_family_set Xi i0, exists b :e Bsel i0, x :e b))
					                                  (forall b1 :e Bsel i0, forall b2 :e Bsel i0, forall x:set, x :e b1 -> x :e b2 -> exists b3 :e Bsel i0, x :e b3 /\ b3 c= b1 :/\: b2)
					                                  HBsel_i0)). }
					            claim Hf0prop: function_on f0 I (space_family_union I Xi) /\ forall i:set, i :e I -> apply_fun f0 i :e space_family_set Xi i.
					            { exact (SepE2 (Power (setprod I (space_family_union I Xi)))
					                         (fun f1:set => function_on f1 I (space_family_union I Xi) /\ forall i:set, i :e I -> apply_fun f1 i :e space_family_set Xi i)
					                         f0 Hf0). }
					            claim Hcompf0: forall i:set, i :e I -> apply_fun f0 i :e space_family_set Xi i.
					            { exact (andER (function_on f0 I (space_family_union I Xi))
					                           (forall i:set, i :e I -> apply_fun f0 i :e space_family_set Xi i)
					                           Hf0prop). }
					            claim Hfi0: apply_fun f0 i0 :e space_family_set Xi i0.
					            { exact (Hcompf0 i0 Hi0I). }
					            apply (HBcover (apply_fun f0 i0) Hfi0).
					            let U0. assume HU0pair.
					            claim HU0B: U0 :e Bsel i0.
					            { exact (andEL (U0 :e Bsel i0) (apply_fun f0 i0 :e U0) HU0pair). }
					            claim Hfi0U0: apply_fun f0 i0 :e U0.
					            { exact (andER (U0 :e Bsel i0) (apply_fun f0 i0 :e U0) HU0pair). }
					            claim HBgen_i0: basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0).
					            { exact (andER (basis_on (space_family_set Xi i0) (Bsel i0) /\ countable_set (Bsel i0))
					                           (basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0))
					                           (HBsel i0 Hi0I)). }
					            claim HTeq: generated_topology (space_family_set Xi i0) (Bsel i0) = space_family_topology Xi i0.
					            { exact (andER (basis_on (space_family_set Xi i0) (Bsel i0))
					                           (generated_topology (space_family_set Xi i0) (Bsel i0) = space_family_topology Xi i0)
					                           HBgen_i0). }
					            claim HU0Gen: U0 :e generated_topology (space_family_set Xi i0) (Bsel i0).
					            { exact (generated_topology_contains_basis (space_family_set Xi i0) (Bsel i0) HBsel_i0 U0 HU0B). }
					            claim HU0Top: U0 :e space_family_topology Xi i0.
					            { rewrite <- HTeq. exact HU0Gen. }
					            set C0 : set := product_cylinder I Xi i0 U0.
					            claim Hf0C0: f0 :e C0.
					            { exact (SepI (product_space I Xi) (fun f1:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e U0)
					                         f0 Hf0 (andI (i0 :e I /\ U0 :e space_family_topology Xi i0) (apply_fun f0 i0 :e U0)
					                                      (andI (i0 :e I) (U0 :e space_family_topology Xi i0) Hi0I HU0Top) Hfi0U0)). }
					            claim HC0in: C0 :e Ssmall.
					            { exact (famunionI I (fun i1:set => {product_cylinder I Xi i1 U|U :e Bsel i1})
					                             i0 C0 Hi0I (ReplI (Bsel i0) (fun U:set => product_cylinder I Xi i0 U) U0 HU0B)). }
					            exact (UnionI Ssmall f0 C0 Hf0C0 HC0in). }
					      witness (basis_of_subbasis (product_space I Xi) Ssmall).
					      apply andI.
					      - (** basis_on and countable_set **)
					        apply andI.
					        + claim HS: subbasis_on (product_space I Xi) Ssmall.
					          { exact HSsmall. }
					          exact (finite_intersections_basis_of_subbasis (product_space I Xi) Ssmall HS).
						        + (** countable_set of basis_of_subbasis from a countable subbasis **)
						          claim HSsmall_count: countable_set Ssmall.
						          { (** show Ssmall is an image of a countable dependent sum **)
						            claim HIc: countable I.
						            { exact HIcount. }
						            claim HBsel_count: forall i:set, i :e I -> countable (Bsel i).
						            { let i. assume HiI: i :e I.
						              claim HBi: basis_on (space_family_set Xi i) (Bsel i) /\ countable_set (Bsel i).
						              { exact (andEL (basis_on (space_family_set Xi i) (Bsel i) /\ countable_set (Bsel i))
						                             (basis_generates (space_family_set Xi i) (Bsel i) (space_family_topology Xi i))
						                             (HBsel i HiI)). }
						              exact (andER (basis_on (space_family_set Xi i) (Bsel i))
						                           (countable_set (Bsel i))
						                           HBi). }
						            claim HSig: countable (Sigma_ i :e I, Bsel i).
						            { exact (Sigma_countable I HIc Bsel HBsel_count). }
						            claim HSig_set: countable_set (Sigma_ i :e I, Bsel i).
						            { exact HSig. }
						            set F : set -> set := fun p => product_cylinder I Xi (p 0) (p 1).
						            set Img := {F p|p :e Sigma_ i :e I, Bsel i}.
						            claim HImg_count: countable_set Img.
						            { exact (countable_image (Sigma_ i :e I, Bsel i) HSig_set F). }
						            apply (Subq_countable Ssmall Img).
						            - exact HImg_count.
						            - let s. assume Hs: s :e Ssmall.
						              prove s :e Img.
						              apply (famunionE_impred I (fun i0:set => {product_cylinder I Xi i0 U|U :e Bsel i0}) s Hs).
						              let i0. assume Hi0I: i0 :e I.
						              assume HsFi0: s :e {product_cylinder I Xi i0 U|U :e Bsel i0}.
						              apply (ReplE_impred (Bsel i0) (fun U0:set => product_cylinder I Xi i0 U0) s HsFi0).
						              let U0. assume HU0B: U0 :e Bsel i0.
						              assume HsEq: s = product_cylinder I Xi i0 U0.
							              claim HpSig: (i0,U0) :e Sigma_ i :e I, Bsel i.
							              { exact (tuple_2_Sigma I Bsel i0 Hi0I U0 HU0B). }
							              claim HFp: F (i0,U0) = product_cylinder I Xi i0 U0.
							              { claim HFdef: F (i0,U0) = product_cylinder I Xi ((i0,U0) 0) ((i0,U0) 1).
							                { reflexivity. }
							                rewrite HFdef.
							                rewrite (tuple_2_0_eq i0 U0).
							                rewrite (tuple_2_1_eq i0 U0).
							                reflexivity. }
							              rewrite HsEq.
							              rewrite <- HFp.
							              exact (ReplI (Sigma_ i :e I, Bsel i) F (i0,U0) HpSig). }
						          exact (basis_of_subbasis_countable (product_space I Xi) Ssmall HSsmall_count).
					      - (** basis_generates **)
					        prove basis_on (product_space I Xi) (basis_of_subbasis (product_space I Xi) Ssmall) /\
					          generated_topology (product_space I Xi) (basis_of_subbasis (product_space I Xi) Ssmall) = countable_product_topology_subbasis I Xi.
					        apply andI.
					        + claim HS: subbasis_on (product_space I Xi) Ssmall.
					          { exact HSsmall. }
					          exact (finite_intersections_basis_of_subbasis (product_space I Xi) Ssmall HS).
					        + (** generated_topology equality with cylinder subbasis **)
					          claim HGTSsmall: generated_topology_from_subbasis (product_space I Xi) Ssmall =
					            generated_topology (product_space I Xi) (basis_of_subbasis (product_space I Xi) Ssmall).
					          { reflexivity. }
					          rewrite <- HGTSsmall.
					          claim HcompTop2: forall i:set, i :e I -> topology_on (space_family_set Xi i) (space_family_topology Xi i).
					          { let i. assume HiI: i :e I.
					            exact (andEL (topology_on (space_family_set Xi i) (space_family_topology Xi i))
					                         (exists B0:set, basis_on (space_family_set Xi i) B0 /\ countable_set B0 /\ basis_generates (space_family_set Xi i) B0 (space_family_topology Xi i))
					                         (Hcomp i HiI)). }
					          claim HSfull: subbasis_on (product_space I Xi) (product_subbasis_full I Xi).
					          { exact (product_subbasis_full_subbasis_on I Xi HIn0 HcompTop2). }
					          claim HTdef: countable_product_topology_subbasis I Xi =
					            generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi).
					          { reflexivity. }
					          rewrite HTdef.
					          (** Compare generated topologies from the two subbases Ssmall and product_subbasis_full **)
					          apply set_ext.
					          + let U. assume HU: U :e generated_topology_from_subbasis (product_space I Xi) Ssmall.
					            prove U :e generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi).
					            claim HTfull: topology_on (product_space I Xi)
					              (generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi)).
					            { exact (topology_from_subbasis_is_topology (product_space I Xi) (product_subbasis_full I Xi) HSfull). }
					            claim HBfull: basis_on (product_space I Xi)
					              (basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi)).
					            { exact (finite_intersections_basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi) HSfull). }
					            claim HSsmall_sub_Tfull: Ssmall c=
					              generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi).
					            { let s. assume Hs: s :e Ssmall.
					              prove s :e generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi).
					              apply (famunionE_impred I (fun i0:set => {product_cylinder I Xi i0 U0|U0 :e Bsel i0}) s Hs).
					              let i0. assume Hi0I. assume HsFi0: s :e {product_cylinder I Xi i0 U0|U0 :e Bsel i0}.
					              apply (ReplE_impred (Bsel i0) (fun U0:set => product_cylinder I Xi i0 U0) s HsFi0).
					              let U0. assume HU0B: U0 :e Bsel i0.
					              assume HsEq: s = product_cylinder I Xi i0 U0.
					              claim HBsel_i0c: basis_on (space_family_set Xi i0) (Bsel i0) /\ countable_set (Bsel i0).
					              { exact (andEL (basis_on (space_family_set Xi i0) (Bsel i0) /\ countable_set (Bsel i0))
					                             (basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0))
					                             (HBsel i0 Hi0I)). }
					              claim HBsel_i0: basis_on (space_family_set Xi i0) (Bsel i0).
					              { exact (andEL (basis_on (space_family_set Xi i0) (Bsel i0))
					                             (countable_set (Bsel i0))
					                             HBsel_i0c). }
					              claim HBgen_i0: basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0).
					              { exact (andER (basis_on (space_family_set Xi i0) (Bsel i0) /\ countable_set (Bsel i0))
					                             (basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0))
					                             (HBsel i0 Hi0I)). }
					              claim HTeq_i0: generated_topology (space_family_set Xi i0) (Bsel i0) = space_family_topology Xi i0.
					              { exact (andER (basis_on (space_family_set Xi i0) (Bsel i0))
					                             (generated_topology (space_family_set Xi i0) (Bsel i0) = space_family_topology Xi i0)
					                             HBgen_i0). }
					              claim HU0Gen: U0 :e generated_topology (space_family_set Xi i0) (Bsel i0).
					              { exact (generated_topology_contains_basis (space_family_set Xi i0) (Bsel i0) HBsel_i0 U0 HU0B). }
					              claim HU0Top: U0 :e space_family_topology Xi i0.
					              { rewrite <- HTeq_i0. exact HU0Gen. }
					              claim HsSfull: s :e product_subbasis_full I Xi.
					              { rewrite HsEq.
					                exact (famunionI I (fun i1:set => {product_cylinder I Xi i1 U|U :e space_family_topology Xi i1})
					                         i0 (product_cylinder I Xi i0 U0) Hi0I
					                         (ReplI (space_family_topology Xi i0) (fun U:set => product_cylinder I Xi i0 U) U0 HU0Top)). }
					              apply (xm (s = Empty)).
					              - assume HsE: s = Empty.
					                rewrite HsE.
					                exact (topology_has_empty (product_space I Xi)
					                      (generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi)) HTfull).
					              - assume HsNE: ~(s = Empty).
					                claim HsBasis: s :e basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi).
					                { exact (subbasis_elem_in_basis (product_space I Xi) (product_subbasis_full I Xi) s HSfull HsSfull HsNE). }
					                exact (basis_in_generated (product_space I Xi)
					                      (basis_of_subbasis (product_space I Xi) (product_subbasis_full I Xi))
					                      s HBfull HsBasis).
					            }
					            claim Hinc: generated_topology_from_subbasis (product_space I Xi) Ssmall c=
					              generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi).
					            { exact (topology_generated_by_basis_is_minimal (product_space I Xi) Ssmall
					                      (generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi))
					                      HSsmall HTfull HSsmall_sub_Tfull). }
					            exact (Hinc U HU).
					          + let U. assume HU: U :e generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi).
					            prove U :e generated_topology_from_subbasis (product_space I Xi) Ssmall.
					            claim HTsmall: topology_on (product_space I Xi)
					              (generated_topology_from_subbasis (product_space I Xi) Ssmall).
					            { exact (topology_from_subbasis_is_topology (product_space I Xi) Ssmall HSsmall). }
					            claim HSfull_sub_Tsmall: product_subbasis_full I Xi c=
					              generated_topology_from_subbasis (product_space I Xi) Ssmall.
					            { let s. assume HsSfull: s :e product_subbasis_full I Xi.
					              prove s :e generated_topology_from_subbasis (product_space I Xi) Ssmall.
					              set Bsm := basis_of_subbasis (product_space I Xi) Ssmall.
					              claim HBsmBasis: basis_on (product_space I Xi) Bsm.
					              { exact (finite_intersections_basis_of_subbasis (product_space I Xi) Ssmall HSsmall). }
					              claim HGTS: generated_topology_from_subbasis (product_space I Xi) Ssmall =
					                generated_topology (product_space I Xi) Bsm.
					              { reflexivity. }
					              rewrite HGTS.
					              (** Destructure s as a cylinder at some coordinate **)
					              apply (famunionE_impred I (fun i0:set => {product_cylinder I Xi i0 U0|U0 :e space_family_topology Xi i0}) s HsSfull).
					              let i0. assume Hi0I. assume HsFi0: s :e {product_cylinder I Xi i0 U0|U0 :e space_family_topology Xi i0}.
					              apply (ReplE_impred (space_family_topology Xi i0) (fun U0:set => product_cylinder I Xi i0 U0) s HsFi0).
					              let U0. assume HU0Top: U0 :e space_family_topology Xi i0.
					              assume HsEq: s = product_cylinder I Xi i0 U0.
					              (** Represent U0 as union of basis elements from Bsel i0 **)
					              claim HBsel_i0c: basis_on (space_family_set Xi i0) (Bsel i0) /\ countable_set (Bsel i0).
					              { exact (andEL (basis_on (space_family_set Xi i0) (Bsel i0) /\ countable_set (Bsel i0))
					                             (basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0))
					                             (HBsel i0 Hi0I)). }
					              claim HBsel_i0: basis_on (space_family_set Xi i0) (Bsel i0).
					              { exact (andEL (basis_on (space_family_set Xi i0) (Bsel i0))
					                             (countable_set (Bsel i0))
					                             HBsel_i0c). }
					              claim HBgen_i0: basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0).
					              { exact (andER (basis_on (space_family_set Xi i0) (Bsel i0) /\ countable_set (Bsel i0))
					                             (basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0))
					                             (HBsel i0 Hi0I)). }
					              claim HTeq_i0: generated_topology (space_family_set Xi i0) (Bsel i0) = space_family_topology Xi i0.
					              { exact (andER (basis_on (space_family_set Xi i0) (Bsel i0))
					                             (generated_topology (space_family_set Xi i0) (Bsel i0) = space_family_topology Xi i0)
					                             HBgen_i0). }
					              claim HU0Gen: U0 :e generated_topology (space_family_set Xi i0) (Bsel i0).
					              { rewrite HTeq_i0. exact HU0Top. }
					              claim HTgen: topology_on (space_family_set Xi i0) (generated_topology (space_family_set Xi i0) (Bsel i0)).
					              { exact (lemma_topology_from_basis (space_family_set Xi i0) (Bsel i0) HBsel_i0). }
					              claim HU0open: open_in (space_family_set Xi i0) (generated_topology (space_family_set Xi i0) (Bsel i0)) U0.
					              { exact (andI (topology_on (space_family_set Xi i0) (generated_topology (space_family_set Xi i0) (Bsel i0)))
					                           (U0 :e generated_topology (space_family_set Xi i0) (Bsel i0))
					                           HTgen HU0Gen). }
					              claim HexFam: exists Fam :e Power (Bsel i0), Union Fam = U0.
					              { exact (open_sets_as_unions_of_basis (space_family_set Xi i0) (Bsel i0) HBsel_i0 U0 HU0open). }
					              apply HexFam.
					              let Fam. assume HFampair.
					              claim HFamPow: Fam :e Power (Bsel i0).
					              { exact (andEL (Fam :e Power (Bsel i0)) (Union Fam = U0) HFampair). }
					              claim HUnionFam: Union Fam = U0.
					              { exact (andER (Fam :e Power (Bsel i0)) (Union Fam = U0) HFampair). }
					              claim HFamSub: Fam c= Bsel i0.
					              { exact (PowerE (Bsel i0) Fam HFamPow). }
					              set FamCyl := {product_cylinder I Xi i0 V|V :e Fam}.
					              claim HUnionCyl: Union FamCyl = product_cylinder I Xi i0 U0.
					              { apply set_ext.
					                - let f. assume HfU: f :e Union FamCyl.
					                  prove f :e product_cylinder I Xi i0 U0.
					                  apply (UnionE_impred FamCyl f HfU).
					                  let c. assume Hfc: f :e c. assume Hc: c :e FamCyl.
					                  apply (ReplE_impred Fam (fun V0:set => product_cylinder I Xi i0 V0) c Hc).
					                  let V0. assume HV0Fam: V0 :e Fam.
					                  assume HcEq: c = product_cylinder I Xi i0 V0.
					                  claim HV0B: V0 :e Bsel i0.
					                  { exact (HFamSub V0 HV0Fam). }
					                  claim HV0subU0: V0 c= U0.
					                  { let x. assume HxV0: x :e V0.
					                    claim HxUF: x :e Union Fam.
					                    { exact (UnionI Fam x V0 HxV0 HV0Fam). }
						                    rewrite <- HUnionFam.
						                    exact HxUF. }
					                  claim HfCylV0: f :e product_cylinder I Xi i0 V0.
					                  { rewrite <- HcEq. exact Hfc. }
					                  claim HfX: f :e product_space I Xi.
					                  { exact (SepE1 (product_space I Xi) (fun f1:set => i0 :e I /\ V0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e V0) f HfCylV0). }
					                  claim Hfcond: (i0 :e I /\ V0 :e space_family_topology Xi i0) /\ apply_fun f i0 :e V0.
					                  { exact (SepE2 (product_space I Xi) (fun f1:set => i0 :e I /\ V0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e V0) f HfCylV0). }
					                  claim Hfi0V0: apply_fun f i0 :e V0.
					                  { exact (andER (i0 :e I /\ V0 :e space_family_topology Xi i0) (apply_fun f i0 :e V0) Hfcond). }
						                  claim Hfi0U0: apply_fun f i0 :e U0.
						                  { exact (HV0subU0 (apply_fun f i0) Hfi0V0). }
						                  claim HpredU0: (i0 :e I /\ U0 :e space_family_topology Xi i0) /\ apply_fun f i0 :e U0.
						                  { apply andI.
						                    - apply andI.
						                      + exact Hi0I.
						                      + exact HU0Top.
						                    - exact Hfi0U0. }
						                  exact (SepI (product_space I Xi) (fun f1:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e U0)
						                             f HfX HpredU0).
					                - let f. assume HfC: f :e product_cylinder I Xi i0 U0.
					                  prove f :e Union FamCyl.
					                  claim Hfcond: (i0 :e I /\ U0 :e space_family_topology Xi i0) /\ apply_fun f i0 :e U0.
					                  { exact (SepE2 (product_space I Xi) (fun f1:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e U0) f HfC). }
					                  claim Hfi0U0: apply_fun f i0 :e U0.
					                  { exact (andER (i0 :e I /\ U0 :e space_family_topology Xi i0) (apply_fun f i0 :e U0) Hfcond). }
					                  claim Hfi0UF: apply_fun f i0 :e Union Fam.
					                  { rewrite HUnionFam. exact Hfi0U0. }
					                  apply (UnionE_impred Fam (apply_fun f i0) Hfi0UF).
					                  let V0. assume Hfi0V0: apply_fun f i0 :e V0. assume HV0Fam: V0 :e Fam.
					                  set C0 := product_cylinder I Xi i0 V0.
					                  claim HC0Fam: C0 :e FamCyl.
					                  { exact (ReplI Fam (fun V1:set => product_cylinder I Xi i0 V1) V0 HV0Fam). }
						                  claim HfC0: f :e C0.
						                  { claim HfX: f :e product_space I Xi.
						                    { exact (SepE1 (product_space I Xi) (fun f1:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e U0) f HfC). }
						                    claim HV0B: V0 :e Bsel i0.
						                    { exact (HFamSub V0 HV0Fam). }
						                    claim HBgen_i0T: basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0).
						                    { exact (andER (basis_on (space_family_set Xi i0) (Bsel i0) /\ countable_set (Bsel i0))
						                                   (basis_generates (space_family_set Xi i0) (Bsel i0) (space_family_topology Xi i0))
						                                   (HBsel i0 Hi0I)). }
						                    claim HTeq2: generated_topology (space_family_set Xi i0) (Bsel i0) = space_family_topology Xi i0.
						                    { exact (andER (basis_on (space_family_set Xi i0) (Bsel i0))
						                                   (generated_topology (space_family_set Xi i0) (Bsel i0) = space_family_topology Xi i0)
						                                   HBgen_i0T). }
						                    claim HV0Gen: V0 :e generated_topology (space_family_set Xi i0) (Bsel i0).
						                    { exact (generated_topology_contains_basis (space_family_set Xi i0) (Bsel i0) HBsel_i0 V0 HV0B). }
						                    claim HV0Top: V0 :e space_family_topology Xi i0.
						                    { rewrite <- HTeq2. exact HV0Gen. }
						                    claim HpredV0: (i0 :e I /\ V0 :e space_family_topology Xi i0) /\ apply_fun f i0 :e V0.
						                    { apply andI.
						                      - apply andI.
						                        + exact Hi0I.
						                        + exact HV0Top.
						                      - exact Hfi0V0. }
						                    exact (SepI (product_space I Xi) (fun f1:set => i0 :e I /\ V0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e V0)
						                               f HfX HpredV0). }
					                  exact (UnionI FamCyl f C0 HfC0 HC0Fam). }
						              (** Restrict to nonempty cylinders to get a family of basis elements **)
						              set FamCylN := {c :e FamCyl|c <> Empty}.
						              claim HFamCylNPow: FamCylN :e Power Bsm.
						              { claim HFamCylNsub: FamCylN c= Bsm.
						                { let c. assume HcN: c :e FamCylN.
						                  prove c :e Bsm.
						                  claim HcFam: c :e FamCyl.
						                  { exact (SepE1 FamCyl (fun c0:set => c0 <> Empty) c HcN). }
						                  claim HcNe: c <> Empty.
						                  { exact (SepE2 FamCyl (fun c0:set => c0 <> Empty) c HcN). }
						                  apply (ReplE_impred Fam (fun V0:set => product_cylinder I Xi i0 V0) c HcFam).
						                  let V0. assume HV0Fam: V0 :e Fam.
						                  assume HcEq: c = product_cylinder I Xi i0 V0.
						                  claim HV0B: V0 :e Bsel i0.
						                  { exact (HFamSub V0 HV0Fam). }
						                  claim HC0in: product_cylinder I Xi i0 V0 :e Ssmall.
						                  { exact (famunionI I (fun i1:set => {product_cylinder I Xi i1 U|U :e Bsel i1})
						                           i0 (product_cylinder I Xi i0 V0) Hi0I
						                           (ReplI (Bsel i0) (fun U:set => product_cylinder I Xi i0 U) V0 HV0B)). }
						                  claim HC0S: c :e Ssmall.
						                  { rewrite HcEq. exact HC0in. }
						                  exact (subbasis_elem_in_basis (product_space I Xi) Ssmall c HSsmall HC0S HcNe). }
						                exact (PowerI Bsm FamCylN HFamCylNsub). }
					              claim HUnionN: Union FamCylN = Union FamCyl.
					              { apply set_ext.
					                - let f. assume HfUN: f :e Union FamCylN.
					                  prove f :e Union FamCyl.
					                  apply (UnionE_impred FamCylN f HfUN).
					                  let c. assume Hfc: f :e c. assume HcN: c :e FamCylN.
					                  claim HcFam: c :e FamCyl.
					                  { exact (SepE1 FamCyl (fun c0:set => c0 <> Empty) c HcN). }
					                  exact (UnionI FamCyl f c Hfc HcFam).
					                - let f. assume HfU: f :e Union FamCyl.
					                  prove f :e Union FamCylN.
					                  apply (UnionE_impred FamCyl f HfU).
					                  let c. assume Hfc: f :e c. assume HcFam: c :e FamCyl.
						                  claim HcNe: c <> Empty.
						                  { assume HcE: c = Empty.
						                    claim Hbad: f :e Empty.
						                    { rewrite <- HcE. exact Hfc. }
						                    exact (EmptyE f Hbad False). }
					                  claim HcN: c :e FamCylN.
					                  { exact (SepI FamCyl (fun c0:set => c0 <> Empty) c HcFam HcNe). }
					                  exact (UnionI FamCylN f c Hfc HcN). }
							              claim HopenS: open_in (product_space I Xi) (generated_topology (product_space I Xi) Bsm) s.
							              { apply (basis_generates_open_sets (product_space I Xi) Bsm HBsmBasis s).
							                witness FamCylN.
							                apply andI.
							                - exact HFamCylNPow.
							                - apply set_ext.
							                  + let f. assume HfU: f :e Union FamCylN.
							                    prove f :e s.
							                    apply (UnionE_impred FamCylN f HfU).
							                    let c. assume Hfc: f :e c. assume HcN: c :e FamCylN.
							                    claim HcFam: c :e FamCyl.
							                    { exact (SepE1 FamCyl (fun c0:set => c0 <> Empty) c HcN). }
							                    apply (ReplE_impred Fam (fun V0:set => product_cylinder I Xi i0 V0) c HcFam).
							                    let V0. assume HV0Fam: V0 :e Fam.
							                    assume HcEq: c = product_cylinder I Xi i0 V0.
							                    claim HV0subU0: V0 c= U0.
							                    { let x. assume HxV0: x :e V0.
							                      claim HxUF: x :e Union Fam.
							                      { exact (UnionI Fam x V0 HxV0 HV0Fam). }
							                      rewrite <- HUnionFam.
							                      exact HxUF. }
							                    claim HfCylV0: f :e product_cylinder I Xi i0 V0.
							                    { rewrite <- HcEq. exact Hfc. }
							                    claim HfX: f :e product_space I Xi.
							                    { exact (SepE1 (product_space I Xi) (fun f1:set => i0 :e I /\ V0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e V0) f HfCylV0). }
							                    claim Hfcond: (i0 :e I /\ V0 :e space_family_topology Xi i0) /\ apply_fun f i0 :e V0.
							                    { exact (SepE2 (product_space I Xi) (fun f1:set => i0 :e I /\ V0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e V0) f HfCylV0). }
							                    claim Hfi0V0: apply_fun f i0 :e V0.
							                    { exact (andER (i0 :e I /\ V0 :e space_family_topology Xi i0) (apply_fun f i0 :e V0) Hfcond). }
							                    claim Hfi0U0: apply_fun f i0 :e U0.
							                    { exact (HV0subU0 (apply_fun f i0) Hfi0V0). }
							                    claim HpredU0: (i0 :e I /\ U0 :e space_family_topology Xi i0) /\ apply_fun f i0 :e U0.
							                    { apply andI.
							                      - apply andI.
							                        + exact Hi0I.
							                        + exact HU0Top.
							                      - exact Hfi0U0. }
							                    rewrite HsEq.
							                    exact (SepI (product_space I Xi) (fun f1:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e U0)
							                               f HfX HpredU0).
							                  + let f. assume HfS: f :e s.
							                    prove f :e Union FamCylN.
							                    claim HfCylU0: f :e product_cylinder I Xi i0 U0.
							                    { rewrite <- HsEq. exact HfS. }
							                    claim Hfcond: (i0 :e I /\ U0 :e space_family_topology Xi i0) /\ apply_fun f i0 :e U0.
							                    { exact (SepE2 (product_space I Xi) (fun f1:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e U0) f HfCylU0). }
							                    claim Hfi0U0: apply_fun f i0 :e U0.
							                    { exact (andER (i0 :e I /\ U0 :e space_family_topology Xi i0) (apply_fun f i0 :e U0) Hfcond). }
							                    claim Hfi0UF: apply_fun f i0 :e Union Fam.
							                    { rewrite HUnionFam. exact Hfi0U0. }
							                    apply (UnionE_impred Fam (apply_fun f i0) Hfi0UF).
							                    let V0. assume Hfi0V0: apply_fun f i0 :e V0. assume HV0Fam: V0 :e Fam.
							                    set C0 := product_cylinder I Xi i0 V0.
							                    claim HC0Fam: C0 :e FamCyl.
							                    { exact (ReplI Fam (fun V1:set => product_cylinder I Xi i0 V1) V0 HV0Fam). }
							                    claim HfC0: f :e C0.
							                    { claim HfX: f :e product_space I Xi.
							                      { exact (SepE1 (product_space I Xi) (fun f1:set => i0 :e I /\ U0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e U0) f HfCylU0). }
								                      claim HpredV0: (i0 :e I /\ V0 :e space_family_topology Xi i0) /\ apply_fun f i0 :e V0.
								                      { apply andI.
								                        - apply andI.
								                          + exact Hi0I.
								                          + claim HV0B: V0 :e Bsel i0.
								                            { exact (HFamSub V0 HV0Fam). }
								                            claim HV0Gen: V0 :e generated_topology (space_family_set Xi i0) (Bsel i0).
								                            { exact (generated_topology_contains_basis (space_family_set Xi i0) (Bsel i0) HBsel_i0 V0 HV0B). }
								                            claim HV0Top: V0 :e space_family_topology Xi i0.
								                            { rewrite <- HTeq_i0. exact HV0Gen. }
								                            exact HV0Top.
								                        - exact Hfi0V0. }
							                      exact (SepI (product_space I Xi) (fun f1:set => i0 :e I /\ V0 :e space_family_topology Xi i0 /\ apply_fun f1 i0 :e V0)
							                                 f HfX HpredV0). }
							                    claim HC0ne: C0 <> Empty.
							                    { assume HC0E: C0 = Empty.
							                      claim Hbad: f :e Empty.
							                      { rewrite <- HC0E. exact HfC0. }
							                      exact (EmptyE f Hbad False). }
							                    claim HC0N: C0 :e FamCylN.
							                    { exact (SepI FamCyl (fun c0:set => c0 <> Empty) C0 HC0Fam HC0ne). }
							                    exact (UnionI FamCylN f C0 HfC0 HC0N). }
					              exact (andER (topology_on (product_space I Xi) (generated_topology (product_space I Xi) Bsm))
					                           (s :e generated_topology (product_space I Xi) Bsm)
					                           HopenS). }
					            claim Hinc: generated_topology_from_subbasis (product_space I Xi) (product_subbasis_full I Xi) c=
					              generated_topology_from_subbasis (product_space I Xi) Ssmall.
					            { exact (topology_generated_by_basis_is_minimal (product_space I Xi) (product_subbasis_full I Xi)
					                      (generated_topology_from_subbasis (product_space I Xi) Ssmall)
					                      HSfull HTsmall HSfull_sub_Tsmall). }
					            exact (Hinc U HU).
Qed.

(** from 30 Definition: dense subset **) 
Definition dense_in : set -> set -> set -> prop := fun A X Tx => closure_of X Tx A = X.

(** from 30 Theorem 30.3(a): countable basis implies Lindelf **) 
(** LATEX VERSION: A second-countable space is Lindelf (every open cover has countable subcover). **)
Theorem countable_basis_implies_Lindelof : forall X Tx:set,
  topology_on X Tx ->
  second_countable_space X Tx ->
  forall U:set, open_cover X Tx U -> exists V:set, countable_subcollection V U /\ covers X V.
let X Tx.
assume HTx: topology_on X Tx.
assume Hscc: second_countable_space X Tx.
let U.
assume HU: open_cover X Tx U.
prove exists V:set, countable_subcollection V U /\ covers X V.
claim HUopen: forall u:set, u :e U -> u :e Tx.
{ exact (andEL (forall u:set, u :e U -> u :e Tx) (covers X U) HU). }
claim HUcov: covers X U.
{ exact (andER (forall u:set, u :e U -> u :e Tx) (covers X U) HU). }
claim HexB: exists B:set, basis_on X B /\ countable_set B /\ basis_generates X B Tx.
{ exact (andER (topology_on X Tx) (exists B:set, basis_on X B /\ countable_set B /\ basis_generates X B Tx) Hscc). }
apply HexB.
let B. assume HBpair.
claim HBmid: (basis_on X B /\ countable_set B) /\ basis_generates X B Tx.
{ exact HBpair. }
claim HBasisCount: basis_on X B /\ countable_set B.
{ exact (andEL (basis_on X B /\ countable_set B) (basis_generates X B Tx) HBmid). }
claim HBgener: basis_generates X B Tx.
{ exact (andER (basis_on X B /\ countable_set B) (basis_generates X B Tx) HBmid). }
claim HBasis: basis_on X B.
{ exact (andEL (basis_on X B) (countable_set B) HBasisCount). }
claim HBcount: countable_set B.
{ exact (andER (basis_on X B) (countable_set B) HBasisCount). }
claim HgenEq: generated_topology X B = Tx.
{ exact (andER (basis_on X B) (generated_topology X B = Tx) HBgener). }
(** basis elements that refine the cover **)
set B0 := {b :e B | exists u:set, u :e U /\ b c= u}.
set choose : set->set := fun b => Eps_i (fun u => u :e U /\ b c= u).
set V := {choose b|b :e B0}.
witness V.
apply andI.
- (** V is a countable subcollection of U **)
  prove countable_subcollection V U.
  prove V c= U /\ countable_set V.
  apply andI.
  + (** V c= U **)
    let v. assume Hv: v :e V.
    prove v :e U.
    apply (ReplE_impred B0 choose v Hv).
    let b.
    assume Hb0: b :e B0.
    assume HvEq: v = choose b.
    claim Hb0prop: exists u:set, u :e U /\ b c= u.
    { exact (SepE2 B (fun b0:set => exists u:set, u :e U /\ b0 c= u) b Hb0). }
    apply Hb0prop.
    let u.
    assume Hupair: u :e U /\ b c= u.
    claim Hchooseprop: choose b :e U /\ b c= choose b.
    { exact (Eps_i_ax (fun u0 => u0 :e U /\ b c= u0) u Hupair). }
    claim HchooseU: choose b :e U.
    { exact (andEL (choose b :e U) (b c= choose b) Hchooseprop). }
    rewrite HvEq.
    exact HchooseU.
  + (** countable_set V **)
    claim HB0sub: B0 c= B.
    { let b. assume Hb0: b :e B0.
      exact (SepE1 B (fun b0:set => exists u:set, u :e U /\ b0 c= u) b Hb0). }
    claim HB0count: countable_set B0.
    { exact (Subq_countable B0 B HBcount HB0sub). }
    exact (countable_image B0 HB0count choose).
- (** V covers X **)
  prove covers X V.
  let x. assume HxX: x :e X.
  apply (HUcov x HxX).
  let u. assume Hupair.
  claim HuU: u :e U.
  { exact (andEL (u :e U) (x :e u) Hupair). }
  claim Hxu: x :e u.
  { exact (andER (u :e U) (x :e u) Hupair). }
  claim HuTx: u :e Tx.
  { exact (HUopen u HuU). }
  claim HuGen: u :e generated_topology X B.
  { rewrite HgenEq. exact HuTx. }
  claim Href: forall z :e u, exists b :e B, z :e b /\ b c= u.
  { exact (SepE2 (Power X) (fun U0:set => forall z :e U0, exists b :e B, z :e b /\ b c= U0) u HuGen). }
  claim Hexb: exists b :e B, x :e b /\ b c= u.
  { exact (Href x Hxu). }
  apply Hexb.
  let b. assume Hbpair.
  claim HbB: b :e B.
  { exact (andEL (b :e B) (x :e b /\ b c= u) Hbpair). }
  claim Hbprop: x :e b /\ b c= u.
  { exact (andER (b :e B) (x :e b /\ b c= u) Hbpair). }
  claim Hxb: x :e b.
  { exact (andEL (x :e b) (b c= u) Hbprop). }
  claim Hbsubu: b c= u.
  { exact (andER (x :e b) (b c= u) Hbprop). }
  claim Hb0: b :e B0.
  { apply (SepI B (fun b0:set => exists u0:set, u0 :e U /\ b0 c= u0) b HbB).
    witness u.
    apply andI.
    - exact HuU.
    - exact Hbsubu. }
  claim Hchooseprop: choose b :e U /\ b c= choose b.
  { exact (Eps_i_ax (fun u0 => u0 :e U /\ b c= u0) u (andI (u :e U) (b c= u) HuU Hbsubu)). }
  claim Hbsubchoose: b c= choose b.
  { exact (andER (choose b :e U) (b c= choose b) Hchooseprop). }
  claim Hxchoose: x :e choose b.
  { exact (Hbsubchoose x Hxb). }
  witness choose b.
  apply andI.
  + exact (ReplI B0 choose b Hb0).
  + exact Hxchoose.
Qed.

(** from 30 Theorem 30.3(b): countable basis yields countable dense subset **) 
(** LATEX VERSION: Second-countable spaces are separable (have countable dense subset). **)
Theorem countable_basis_implies_separable : forall X Tx:set,
  topology_on X Tx ->
  second_countable_space X Tx ->
  exists D:set, countable_set D /\ dense_in D X Tx.
let X Tx.
assume HTx: topology_on X Tx.
assume Hscc: second_countable_space X Tx.
prove exists D:set, countable_set D /\ dense_in D X Tx.
claim HexB: exists B:set, basis_on X B /\ countable_set B /\ basis_generates X B Tx.
{ exact (andER (topology_on X Tx) (exists B:set, basis_on X B /\ countable_set B /\ basis_generates X B Tx) Hscc). }
apply HexB.
let B. assume HBpair.
claim HBmid: (basis_on X B /\ countable_set B) /\ basis_generates X B Tx.
{ exact HBpair. }
claim HBasisCount: basis_on X B /\ countable_set B.
{ exact (andEL (basis_on X B /\ countable_set B) (basis_generates X B Tx) HBmid). }
claim HBgener: basis_generates X B Tx.
{ exact (andER (basis_on X B /\ countable_set B) (basis_generates X B Tx) HBmid). }
claim HBasis: basis_on X B.
{ exact (andEL (basis_on X B) (countable_set B) HBasisCount). }
claim HBcount: countable_set B.
{ exact (andER (basis_on X B) (countable_set B) HBasisCount). }
claim HgenEq: generated_topology X B = Tx.
{ exact (andER (basis_on X B) (generated_topology X B = Tx) HBgener). }
(** pick one point from each nonempty basis element **)
set B1 := {b :e B | b <> Empty}.
set pick : set->set := fun b => Eps_i (fun x => x :e b).
set D := {pick b|b :e B1}.
witness D.
apply andI.
- (** D is countable **)
  prove countable_set D.
  claim HB1sub: B1 c= B.
  { let b. assume Hb1: b :e B1.
    exact (SepE1 B (fun b0:set => b0 <> Empty) b Hb1). }
  claim HB1count: countable_set B1.
  { exact (Subq_countable B1 B HBcount HB1sub). }
  exact (countable_image B1 HB1count pick).
- (** D is dense: closure_of X Tx D = X **)
  prove dense_in D X Tx.
  prove closure_of X Tx D = X.
  apply set_ext.
  + (** closure  X **)
    exact (closure_in_space X Tx D HTx).
  + (** X  closure **)
    let x. assume HxX: x :e X.
    prove x :e closure_of X Tx D.
    claim Hcliff: x :e closure_of X Tx D <-> (forall U :e Tx, x :e U -> U :/\: D <> Empty).
    { exact (closure_characterization X Tx D x HTx HxX). }
    claim Hneigh: forall U :e Tx, x :e U -> U :/\: D <> Empty.
    { let U. assume HU: U :e Tx. assume HxU: x :e U.
    claim HUgen: U :e generated_topology X B.
    { rewrite HgenEq. exact HU. }
    claim Href: forall z :e U, exists b :e B, z :e b /\ b c= U.
    { exact (SepE2 (Power X) (fun U0:set => forall z :e U0, exists b :e B, z :e b /\ b c= U0) U HUgen). }
    claim Hexb: exists b :e B, x :e b /\ b c= U.
    { exact (Href x HxU). }
    apply Hexb.
    let b. assume Hbpair.
    claim HbB: b :e B.
    { exact (andEL (b :e B) (x :e b /\ b c= U) Hbpair). }
    claim Hbprop: x :e b /\ b c= U.
    { exact (andER (b :e B) (x :e b /\ b c= U) Hbpair). }
    claim Hxb: x :e b.
    { exact (andEL (x :e b) (b c= U) Hbprop). }
    claim HbsubU: b c= U.
    { exact (andER (x :e b) (b c= U) Hbprop). }
    claim Hbne: b <> Empty.
    { assume HbE: b = Empty.
      claim HxEmp: x :e Empty.
      { rewrite <- HbE. exact Hxb. }
      exact (EmptyE x HxEmp False). }
    claim Hb1: b :e B1.
    { exact (SepI B (fun b0:set => b0 <> Empty) b HbB Hbne). }
    claim Hpickb: pick b :e b.
    { exact (Eps_i_ax (fun x0 => x0 :e b) x Hxb). }
    claim HpickU: pick b :e U.
    { exact (HbsubU (pick b) Hpickb). }
    claim HpickD: pick b :e D.
    { exact (ReplI B1 pick b Hb1). }
    prove U :/\: D <> Empty.
    assume HUD: U :/\: D = Empty.
    claim Hwd: pick b :e U :/\: D.
    { exact (binintersectI U D (pick b) HpickU HpickD). }
    claim HwdE: pick b :e Empty.
    { rewrite <- HUD. exact Hwd. }
    exact (EmptyE (pick b) HwdE False).
    }
    exact (iffER (x :e closure_of X Tx D) (forall U :e Tx, x :e U -> U :/\: D <> Empty) Hcliff Hneigh).
Qed.

(** from 30 Example 3: Sorgenfrey line countability properties **) 
(** LATEX VERSION: Sorgenfrey line is first countable, separable, Lindelf, but not second countable. **)
Theorem Sorgenfrey_line_countability :
  first_countable_space Sorgenfrey_line Sorgenfrey_topology /\
  dense_in rational_numbers Sorgenfrey_line Sorgenfrey_topology /\
  Lindelof_space Sorgenfrey_line Sorgenfrey_topology /\
  ~ second_countable_space Sorgenfrey_line Sorgenfrey_topology.
prove first_countable_space Sorgenfrey_line Sorgenfrey_topology /\
  dense_in rational_numbers Sorgenfrey_line Sorgenfrey_topology /\
  Lindelof_space Sorgenfrey_line Sorgenfrey_topology /\
  ~ second_countable_space Sorgenfrey_line Sorgenfrey_topology.
admit. (** [x,x+1/n) basis at x; rationals dense; Lindelf by special argument; uncountably many disjoint opens prevent 2nd countability **)
Qed.

(** placeholders for later refinement of product/separation constructions **) 
(** LATEX VERSION: Sorgenfrey plane topology = product of two Sorgenfrey lines. **)
Definition Sorgenfrey_plane_topology : set :=
  product_topology Sorgenfrey_line Sorgenfrey_topology Sorgenfrey_line Sorgenfrey_topology.
(** LATEX VERSION: One-point sets closed predicate (T1-like helper). **)
Definition one_point_sets_closed : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\ forall x:set, x :e X -> closed_in X Tx {x}.

(** from 31 Definition: regular and normal spaces **)
(** LATEX VERSION: Regular space: points and closed sets can be separated by disjoint open sets. **)
Definition regular_space : set -> set -> prop := fun X Tx =>
  one_point_sets_closed X Tx /\
  forall x:set, x :e X ->
    forall F:set, closed_in X Tx F -> x /:e F ->
      exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty.

(** LATEX VERSION: Normal space: disjoint closed sets can be separated by disjoint opens. **)
Definition normal_space : set -> set -> prop := fun X Tx =>
  one_point_sets_closed X Tx /\
  forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
    exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.

(** Helper: discrete topology is normal **)
Theorem discrete_normal_space : forall X:set,
  normal_space X (discrete_topology X).
let X.
prove normal_space X (discrete_topology X).
claim HTx: topology_on X (discrete_topology X).
{ exact (discrete_topology_on X). }
prove one_point_sets_closed X (discrete_topology X) /\
  forall A B:set, closed_in X (discrete_topology X) A -> closed_in X (discrete_topology X) B -> A :/\: B = Empty ->
    exists U V:set, U :e discrete_topology X /\ V :e discrete_topology X /\ A c= U /\ B c= V /\ U :/\: V = Empty.
apply andI.
- (** one_point_sets_closed **)
  prove topology_on X (discrete_topology X) /\ forall x:set, x :e X -> closed_in X (discrete_topology X) {x}.
  apply andI.
  - exact HTx.
  - let x. assume HxX: x :e X.
    prove closed_in X (discrete_topology X) {x}.
    set U := X :\: {x}.
    claim HUsub: U c= X.
    { apply setminus_Subq. }
    claim HUopen: U :e discrete_topology X.
    { exact (discrete_open_all X U HUsub). }
    claim HclosedComp: closed_in X (discrete_topology X) (X :\: U).
    { exact (closed_of_open_complement X (discrete_topology X) U HTx HUopen). }
    claim HsingSub: {x} c= X.
    { exact (singleton_subset x X HxX). }
    claim Heq: X :\: U = {x}.
    { claim HUdef: U = X :\: {x}.
      { reflexivity. }
      rewrite HUdef.
      exact (setminus_setminus_eq X {x} HsingSub). }
    rewrite <- Heq.
    exact HclosedComp.
- (** separation of disjoint closed sets **)
  let A B.
  assume HA: closed_in X (discrete_topology X) A.
  assume HB: closed_in X (discrete_topology X) B.
  assume Hdisj: A :/\: B = Empty.
  prove exists U V:set,
    U :e discrete_topology X /\ V :e discrete_topology X /\ A c= U /\ B c= V /\ U :/\: V = Empty.
  witness A.
  witness B.
  claim HAsub: A c= X.
  { exact (closed_in_subset X (discrete_topology X) A HA). }
  claim HBsub: B c= X.
  { exact (closed_in_subset X (discrete_topology X) B HB). }
  claim HAopen: A :e discrete_topology X.
  { exact (discrete_open_all X A HAsub). }
  claim HBopen: B :e discrete_topology X.
  { exact (discrete_open_all X B HBsub). }
  apply andI.
  - prove ((A :e discrete_topology X /\ B :e discrete_topology X) /\ A c= A) /\ B c= B.
    apply andI.
    + prove (A :e discrete_topology X /\ B :e discrete_topology X) /\ A c= A.
      apply andI.
      * apply andI.
        - exact HAopen.
        - exact HBopen.
      * exact (Subq_ref A).
    + exact (Subq_ref B).
  - exact Hdisj.
Qed.

(** from 31: regular implies Hausdorff, normal implies regular **)
(** LATEX VERSION: It is clear that a regular space is Hausdorff, and that a normal space is regular. **)
Theorem regular_space_implies_Hausdorff : forall X Tx:set,
  regular_space X Tx -> Hausdorff_space X Tx.
let X Tx.
assume Hreg: regular_space X Tx.
prove Hausdorff_space X Tx.
claim HT1: one_point_sets_closed X Tx.
{ exact (andEL (one_point_sets_closed X Tx)
               (forall x:set, x :e X ->
                 forall F:set, closed_in X Tx F -> x /:e F ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty)
               Hreg). }
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x:set, x :e X -> closed_in X Tx {x})
               HT1). }
claim Hsing: forall x:set, x :e X -> closed_in X Tx {x}.
{ exact (andER (topology_on X Tx)
               (forall x:set, x :e X -> closed_in X Tx {x})
               HT1). }
claim HSepReg:
  forall x:set, x :e X ->
    forall F:set, closed_in X Tx F -> x /:e F ->
      exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty.
{ exact (andER (one_point_sets_closed X Tx)
               (forall x:set, x :e X ->
                 forall F:set, closed_in X Tx F -> x /:e F ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty)
               Hreg). }
prove topology_on X Tx /\
      forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
        exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
apply andI.
- exact HTx.
- let x1 x2.
  assume Hx1X: x1 :e X.
  assume Hx2X: x2 :e X.
  assume Hneq: x1 <> x2.
  prove exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
  claim Hcl: closed_in X Tx {x2}.
  { exact (Hsing x2 Hx2X). }
  claim Hx1not: x1 /:e {x2}.
  { assume Hx1in: x1 :e {x2}.
    claim Heq: x1 = x2.
    { exact (SingE x2 x1 Hx1in). }
    exact (Hneq Heq). }
  claim Hex: exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ {x2} c= V /\ U :/\: V = Empty.
  { exact (HSepReg x1 Hx1X {x2} Hcl Hx1not). }
  set U0 := Eps_i (fun U:set => exists V:set,
    U :e Tx /\ V :e Tx /\ x1 :e U /\ {x2} c= V /\ U :/\: V = Empty).
  claim HU0ex: exists V:set,
    U0 :e Tx /\ V :e Tx /\ x1 :e U0 /\ {x2} c= V /\ U0 :/\: V = Empty.
  { exact (Eps_i_ex (fun U:set => exists V:set,
      U :e Tx /\ V :e Tx /\ x1 :e U /\ {x2} c= V /\ U :/\: V = Empty) Hex). }
  set V0 := Eps_i (fun V:set => U0 :e Tx /\ V :e Tx /\ x1 :e U0 /\ {x2} c= V /\ U0 :/\: V = Empty).
  claim HV0prop: U0 :e Tx /\ V0 :e Tx /\ x1 :e U0 /\ {x2} c= V0 /\ U0 :/\: V0 = Empty.
  { exact (Eps_i_ex (fun V:set => U0 :e Tx /\ V :e Tx /\ x1 :e U0 /\ {x2} c= V /\ U0 :/\: V = Empty)
                    HU0ex). }
  claim H1234: (((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) /\ {x2} c= V0).
  { exact (andEL ((((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) /\ {x2} c= V0))
                 (U0 :/\: V0 = Empty)
                 HV0prop). }
  claim HdisjUV: U0 :/\: V0 = Empty.
  { exact (andER ((((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) /\ {x2} c= V0))
                 (U0 :/\: V0 = Empty)
                 HV0prop). }
  claim H123: ((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0).
  { exact (andEL ((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0)
                 ({x2} c= V0)
                 H1234). }
  claim H12: (U0 :e Tx /\ V0 :e Tx).
  { exact (andEL (U0 :e Tx /\ V0 :e Tx) (x1 :e U0) H123). }
  claim HUx1: x1 :e U0.
  { exact (andER (U0 :e Tx /\ V0 :e Tx) (x1 :e U0) H123). }
  claim HVsub: {x2} c= V0.
  { exact (andER ((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) ({x2} c= V0) H1234). }
  claim Hx2V0: x2 :e V0.
  { apply HVsub. exact (SingI x2). }
  witness U0.
  witness V0.
  apply and5I.
  - exact (andEL (U0 :e Tx) (V0 :e Tx) H12).
  - exact (andER (U0 :e Tx) (V0 :e Tx) H12).
  - exact HUx1.
  - exact Hx2V0.
  - exact HdisjUV.
Qed.

Theorem normal_space_implies_regular : forall X Tx:set,
  normal_space X Tx -> regular_space X Tx.
let X Tx.
assume Hnorm: normal_space X Tx.
prove regular_space X Tx.
claim HT1: one_point_sets_closed X Tx.
{ exact (andEL (one_point_sets_closed X Tx)
               (forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty)
               Hnorm). }
claim Hsing: forall x:set, x :e X -> closed_in X Tx {x}.
{ exact (andER (topology_on X Tx)
               (forall x:set, x :e X -> closed_in X Tx {x})
               HT1). }
claim HSepNorm:
  forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
    exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.
{ exact (andER (one_point_sets_closed X Tx)
               (forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty)
               Hnorm). }
prove one_point_sets_closed X Tx /\
      forall x:set, x :e X ->
        forall F:set, closed_in X Tx F -> x /:e F ->
          exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty.
apply andI.
- exact HT1.
- let x. assume HxX: x :e X.
  let F. assume HFcl: closed_in X Tx F.
  assume HxnotF: x /:e F.
  prove exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty.
  claim Hclx: closed_in X Tx {x}.
  { exact (Hsing x HxX). }
  claim Hdisj: {x} :/\: F = Empty.
  { apply Empty_Subq_eq.
    let z. assume Hz: z :e {x} :/\: F.
    prove z :e Empty.
    claim Hz1: z :e {x}.
    { exact (binintersectE1 {x} F z Hz). }
    claim Hz2: z :e F.
    { exact (binintersectE2 {x} F z Hz). }
    claim Hzx: z = x.
    { exact (SingE x z Hz1). }
    claim HxinF: x :e F.
    { rewrite <- Hzx. exact Hz2. }
    apply FalseE.
    exact (HxnotF HxinF). }
  claim Hex: exists U V:set, U :e Tx /\ V :e Tx /\ {x} c= U /\ F c= V /\ U :/\: V = Empty.
  { exact (HSepNorm {x} F Hclx HFcl Hdisj). }
  set U0 := Eps_i (fun U:set => exists V:set,
    U :e Tx /\ V :e Tx /\ {x} c= U /\ F c= V /\ U :/\: V = Empty).
  claim HU0ex: exists V:set,
    U0 :e Tx /\ V :e Tx /\ {x} c= U0 /\ F c= V /\ U0 :/\: V = Empty.
  { exact (Eps_i_ex (fun U:set => exists V:set,
      U :e Tx /\ V :e Tx /\ {x} c= U /\ F c= V /\ U :/\: V = Empty) Hex). }
  set V0 := Eps_i (fun V:set => U0 :e Tx /\ V :e Tx /\ {x} c= U0 /\ F c= V /\ U0 :/\: V = Empty).
  claim HV0prop: U0 :e Tx /\ V0 :e Tx /\ {x} c= U0 /\ F c= V0 /\ U0 :/\: V0 = Empty.
  { exact (Eps_i_ex (fun V:set => U0 :e Tx /\ V :e Tx /\ {x} c= U0 /\ F c= V /\ U0 :/\: V = Empty)
                    HU0ex). }
  claim H1234: (((U0 :e Tx /\ V0 :e Tx) /\ {x} c= U0) /\ F c= V0).
  { exact (andEL ((((U0 :e Tx /\ V0 :e Tx) /\ {x} c= U0) /\ F c= V0))
                 (U0 :/\: V0 = Empty)
                 HV0prop). }
  claim HdisjUV: U0 :/\: V0 = Empty.
  { exact (andER ((((U0 :e Tx /\ V0 :e Tx) /\ {x} c= U0) /\ F c= V0))
                 (U0 :/\: V0 = Empty)
                 HV0prop). }
  claim H123: ((U0 :e Tx /\ V0 :e Tx) /\ {x} c= U0).
  { exact (andEL ((U0 :e Tx /\ V0 :e Tx) /\ {x} c= U0)
                 (F c= V0)
                 H1234). }
  claim H12: (U0 :e Tx /\ V0 :e Tx).
  { exact (andEL (U0 :e Tx /\ V0 :e Tx) ({x} c= U0) H123). }
  claim Hsubx: {x} c= U0.
  { exact (andER (U0 :e Tx /\ V0 :e Tx) ({x} c= U0) H123). }
  claim HFsub: F c= V0.
  { exact (andER ((U0 :e Tx /\ V0 :e Tx) /\ {x} c= U0) (F c= V0) H1234). }
  claim HxU0: x :e U0.
  { apply Hsubx. exact (SingI x). }
  witness U0.
  witness V0.
  apply and5I.
  - exact (andEL (U0 :e Tx) (V0 :e Tx) H12).
  - exact (andER (U0 :e Tx) (V0 :e Tx) H12).
  - exact HxU0.
  - exact HFsub.
  - exact HdisjUV.
Qed.

(** LATEX VERSION: Families of Hausdorff/regular/completely regular spaces (helpers). **)
Definition Hausdorff_spaces_family : set -> set -> prop := fun I Xi =>
  forall i:set, i :e I -> Hausdorff_space (product_component Xi i) (product_component_topology Xi i).
Definition regular_spaces_family : set -> set -> prop := fun I Xi =>
  forall i:set, i :e I -> regular_space (product_component Xi i) (product_component_topology Xi i).
(** LATEX VERSION: Uncountable set helper. **)
Definition uncountable_set : set -> prop := fun X => ~ countable_set X.
(** LATEX VERSION: Well-ordered set helper. **)
Definition well_ordered_set : set -> prop := fun X =>
  exists alpha:set, ordinal alpha /\ equip X alpha.
(** LATEX VERSION: Completely regular family helper. **)
Definition completely_regular_spaces_family : set -> set -> prop := fun I Xi =>
  forall i:set, i :e I -> topology_on (product_component Xi i) (product_component_topology Xi i).
(** LATEX VERSION: Separating family of functions (embedding setup). **)
Definition separating_family_of_functions : set -> set -> set -> set -> prop :=
  fun X Tx F J =>
    topology_on X Tx /\ F c= function_space X J /\
    (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
       exists f:set, f :e F /\ apply_fun f x1 <> apply_fun f x2).
(** LATEX VERSION: Embedding predicate. **)
(** FIXED: Definition was incomplete - only required continuous injection, not homeomorphism onto image.
    Was: function_on f X Y /\ continuous_map X Tx Y Ty f /\ injective
         (continuous injection, but NOT necessarily a homeomorphism onto its image!)
    Now: homeomorphism X Tx (image_of f X) (subspace_topology Y Ty (image_of f X)) f
         (f is a homeomorphism from X to f(X) with subspace topology)
    This is the correct definition: an embedding is a map that is a homeomorphism onto its image. **)
Definition embedding_of : set -> set -> set -> set -> set -> prop := fun X Tx Y Ty f =>
  homeomorphism X Tx (image_of f X) (subspace_topology Y Ty (image_of f X)) f.
(** LATEX VERSION: Power and unit-interval cubes helpers; metrizability predicate. **)
Definition power_real : set -> set := fun J => function_space J R.
Definition unit_interval_power : set -> set := fun J => function_space J unit_interval.
Definition metrizable : set -> set -> prop := fun X Tx =>
  exists d:set, metric_on X d /\ metric_topology X d = Tx.

(** from 30 Example 4: product of Lindelf spaces need not be Lindelf **) 
(** LATEX VERSION: The product of two Lindelf Sorgenfrey lines (the Sorgenfrey plane) is not Lindelf. **)
Theorem Sorgenfrey_plane_not_Lindelof :
  ~ Lindelof_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology.
prove ~ Lindelof_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology.
admit. (** antidiagonal is discrete uncountable closed; cover requires uncountably many opens **)
Qed.

(** from 30 Example 5: subspace of Lindelf space need not be Lindelf **) 
(** LATEX VERSION: A subspace of a Lindelf space can fail to be Lindelf (ordered square strip example). **)
Theorem ordered_square_subspace_not_Lindelof :
  Lindelof_space ordered_square ordered_square_topology /\
  ~ Lindelof_space ordered_square_open_strip ordered_square_subspace_topology.
prove Lindelof_space ordered_square ordered_square_topology /\ ~ Lindelof_space ordered_square_open_strip ordered_square_subspace_topology.
admit. (** ordered square compact hence Lindelf; but subspace strip contains uncountable discrete closed **)
Qed.

(** from 31 Lemma 31.1: closure-neighborhood reformulations of regular/normal **) 
(** LATEX VERSION: Lemma 31.1: characterizations of regular/normal via closures and neighborhoods (assuming T1). **)
Theorem regular_normal_via_closure : forall X Tx:set,
  topology_on X Tx ->
  (one_point_sets_closed X Tx -> (regular_space X Tx <->
     forall x U:set, x :e X -> U :e Tx -> x :e U -> exists V:set, V :e Tx /\ x :e V /\ closure_of X Tx V c= U)) /\
  (one_point_sets_closed X Tx -> (normal_space X Tx <->
     forall A U:set, closed_in X Tx A -> U :e Tx -> A c= U -> exists V:set, V :e Tx /\ A c= V /\ closure_of X Tx V c= U)).
let X Tx.
assume HTx: topology_on X Tx.
prove (one_point_sets_closed X Tx -> (regular_space X Tx <->
     forall x U:set, x :e X -> U :e Tx -> x :e U -> exists V:set, V :e Tx /\ x :e V /\ closure_of X Tx V c= U)) /\
  (one_point_sets_closed X Tx -> (normal_space X Tx <->
     forall A U:set, closed_in X Tx A -> U :e Tx -> A c= U -> exists V:set, V :e Tx /\ A c= V /\ closure_of X Tx V c= U)).
apply andI.
- (** Regular part **)
  assume HT1: one_point_sets_closed X Tx.
  prove regular_space X Tx <->
       forall x U:set, x :e X -> U :e Tx -> x :e U ->
         exists V:set, V :e Tx /\ x :e V /\ closure_of X Tx V c= U.
  apply iffI.
  * assume Hreg: regular_space X Tx.
    prove forall x U:set, x :e X -> U :e Tx -> x :e U ->
         exists V:set, V :e Tx /\ x :e V /\ closure_of X Tx V c= U.
    claim HSepReg:
      forall x:set, x :e X ->
        forall F:set, closed_in X Tx F -> x /:e F ->
          exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty.
    { exact (andER (one_point_sets_closed X Tx)
                   (forall x:set, x :e X ->
                     forall F:set, closed_in X Tx F -> x /:e F ->
                       exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty)
                   Hreg). }
    let x U.
    assume HxX: x :e X.
    assume HU: U :e Tx.
    assume HxU: x :e U.
    set B := X :\: U.
    claim HBcl: closed_in X Tx B.
    { exact (closed_of_open_complement X Tx U HTx HU). }
    claim HxnotB: x /:e B.
    { assume HxB: x :e B.
      claim HxnotU: x /:e U.
      { exact (setminusE2 X U x HxB). }
      exact (HxnotU HxU). }
    claim Hex: exists V W:set, V :e Tx /\ W :e Tx /\ x :e V /\ B c= W /\ V :/\: W = Empty.
    { exact (HSepReg x HxX B HBcl HxnotB). }
    set V0 := Eps_i (fun V:set => exists W:set, V :e Tx /\ W :e Tx /\ x :e V /\ B c= W /\ V :/\: W = Empty).
    claim HV0ex: exists W:set, V0 :e Tx /\ W :e Tx /\ x :e V0 /\ B c= W /\ V0 :/\: W = Empty.
    { exact (Eps_i_ex (fun V:set => exists W:set, V :e Tx /\ W :e Tx /\ x :e V /\ B c= W /\ V :/\: W = Empty) Hex). }
    set W0 := Eps_i (fun W:set => V0 :e Tx /\ W :e Tx /\ x :e V0 /\ B c= W /\ V0 :/\: W = Empty).
    claim HW0prop: V0 :e Tx /\ W0 :e Tx /\ x :e V0 /\ B c= W0 /\ V0 :/\: W0 = Empty.
    { exact (Eps_i_ex (fun W:set => V0 :e Tx /\ W :e Tx /\ x :e V0 /\ B c= W /\ V0 :/\: W = Empty)
                      HV0ex). }
    claim H1234: (((V0 :e Tx /\ W0 :e Tx) /\ x :e V0) /\ B c= W0).
    { exact (andEL ((((V0 :e Tx /\ W0 :e Tx) /\ x :e V0) /\ B c= W0))
                   (V0 :/\: W0 = Empty)
                   HW0prop). }
    claim HdisjVW: V0 :/\: W0 = Empty.
    { exact (andER ((((V0 :e Tx /\ W0 :e Tx) /\ x :e V0) /\ B c= W0))
                   (V0 :/\: W0 = Empty)
                   HW0prop). }
    claim H123: ((V0 :e Tx /\ W0 :e Tx) /\ x :e V0).
    { exact (andEL ((V0 :e Tx /\ W0 :e Tx) /\ x :e V0) (B c= W0) H1234). }
    claim H12: (V0 :e Tx /\ W0 :e Tx).
    { exact (andEL (V0 :e Tx /\ W0 :e Tx) (x :e V0) H123). }
    claim HV0Tx: V0 :e Tx.
    { exact (andEL (V0 :e Tx) (W0 :e Tx) H12). }
    claim HW0Tx: W0 :e Tx.
    { exact (andER (V0 :e Tx) (W0 :e Tx) H12). }
    claim HxV0: x :e V0.
    { exact (andER (V0 :e Tx /\ W0 :e Tx) (x :e V0) H123). }
    claim HBsubW0: B c= W0.
    { exact (andER ((V0 :e Tx /\ W0 :e Tx) /\ x :e V0) (B c= W0) H1234). }
    claim HdisjWV: W0 :/\: V0 = Empty.
    { apply Empty_Subq_eq.
      let z. assume Hz: z :e W0 :/\: V0.
      prove z :e Empty.
      claim HzW: z :e W0.
      { exact (binintersectE1 W0 V0 z Hz). }
      claim HzV: z :e V0.
      { exact (binintersectE2 W0 V0 z Hz). }
      claim HzVW: z :e V0 :/\: W0.
      { exact (binintersectI V0 W0 z HzV HzW). }
      claim HzE: z :e Empty.
      { rewrite <- HdisjVW. exact HzVW. }
      exact HzE. }
	    claim HclV0subU: closure_of X Tx V0 c= U.
	    { let z. assume Hzcl: z :e closure_of X Tx V0.
	      prove z :e U.
	      claim HzX: z :e X.
	      { exact (SepE1 X (fun z0:set => forall N:set, N :e Tx -> z0 :e N -> N :/\: V0 <> Empty) z Hzcl). }
	      apply xm (z :e U).
	      - assume HzU: z :e U.
	        exact HzU.
	      - assume HznotU: z /:e U.
	        claim HzB: z :e B.
	        { exact (setminusI X U z HzX HznotU). }
	        claim HzW0: z :e W0.
	        { exact (HBsubW0 z HzB). }
	        claim Hcliff: z :e closure_of X Tx V0 <-> (forall N :e Tx, z :e N -> N :/\: V0 <> Empty).
	        { exact (closure_characterization X Tx V0 z HTx HzX). }
	        claim Hneigh: forall N :e Tx, z :e N -> N :/\: V0 <> Empty.
	        { exact (iffEL (z :e closure_of X Tx V0)
	                       (forall N :e Tx, z :e N -> N :/\: V0 <> Empty)
	                       Hcliff Hzcl). }
	        claim Hcontr: W0 :/\: V0 <> Empty.
	        { exact (Hneigh W0 HW0Tx HzW0). }
	        apply FalseE.
	        exact (Hcontr HdisjWV). }
	    witness V0.
	    apply andI.
	    - apply andI.
	      + exact HV0Tx.
      + exact HxV0.
    - exact HclV0subU.
  * assume Hcrit:
      forall x U:set, x :e X -> U :e Tx -> x :e U ->
        exists V:set, V :e Tx /\ x :e V /\ closure_of X Tx V c= U.
    prove regular_space X Tx.
    prove one_point_sets_closed X Tx /\
         forall x:set, x :e X ->
           forall F:set, closed_in X Tx F -> x /:e F ->
             exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty.
    apply andI.
    - exact HT1.
    - let x. assume HxX: x :e X.
      let F. assume HFcl: closed_in X Tx F.
      assume HxnotF: x /:e F.
      prove exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty.
      set U0 := X :\: F.
      claim Hop0: open_in X Tx U0.
      { exact (open_of_closed_complement X Tx F HFcl). }
      claim HU0Tx: U0 :e Tx.
      { exact (andER (topology_on X Tx) (U0 :e Tx) Hop0). }
      claim HxU0: x :e U0.
      { exact (setminusI X F x HxX HxnotF). }
      claim HexV: exists V:set, V :e Tx /\ x :e V /\ closure_of X Tx V c= U0.
      { exact (Hcrit x U0 HxX HU0Tx HxU0). }
      set V0 := Eps_i (fun V:set => V :e Tx /\ x :e V /\ closure_of X Tx V c= U0).
	      claim HV0prop: V0 :e Tx /\ x :e V0 /\ closure_of X Tx V0 c= U0.
	      { exact (Eps_i_ex (fun V:set => V :e Tx /\ x :e V /\ closure_of X Tx V c= U0) HexV). }
	      claim HV0TxHx: V0 :e Tx /\ x :e V0.
	      { exact (andEL (V0 :e Tx /\ x :e V0) (closure_of X Tx V0 c= U0) HV0prop). }
	      claim HV0Tx: V0 :e Tx.
	      { exact (andEL (V0 :e Tx) (x :e V0) HV0TxHx). }
	      claim HxV0: x :e V0.
	      { exact (andER (V0 :e Tx) (x :e V0) HV0TxHx). }
	      claim Hclsub: closure_of X Tx V0 c= U0.
	      { exact (andER (V0 :e Tx /\ x :e V0) (closure_of X Tx V0 c= U0) HV0prop). }
      claim HTsub: Tx c= Power X.
      { exact (topology_subset_axiom X Tx HTx). }
      claim HV0subX: V0 c= X.
      { exact (PowerE X V0 (HTsub V0 HV0Tx)). }
      claim HclV0cl: closed_in X Tx (closure_of X Tx V0).
      { exact (closure_is_closed X Tx V0 HTx HV0subX). }
      set W0 := X :\: closure_of X Tx V0.
      claim HopW: open_in X Tx W0.
      { exact (open_of_closed_complement X Tx (closure_of X Tx V0) HclV0cl). }
      claim HW0Tx: W0 :e Tx.
      { exact (andER (topology_on X Tx) (W0 :e Tx) HopW). }
	      claim HFsubW0: F c= W0.
	      { let z. assume HzF: z :e F.
	        prove z :e W0.
	        claim HFsubX: F c= X.
	        { exact (closed_in_subset X Tx F HFcl). }
	        claim HzX: z :e X.
	        { exact (HFsubX z HzF). }
	        apply xm (z :e closure_of X Tx V0).
	        - assume Hzcl: z :e closure_of X Tx V0.
	          claim HzU0: z :e U0.
	          { exact (Hclsub z Hzcl). }
	          claim HznotF2: z /:e F.
	          { exact (setminusE2 X F z HzU0). }
	          apply FalseE.
	          exact (HznotF2 HzF).
	        - assume Hznotcl: z /:e closure_of X Tx V0.
	          exact (setminusI X (closure_of X Tx V0) z HzX Hznotcl).
	        }
      claim HVsubcl: V0 c= closure_of X Tx V0.
      { exact (subset_of_closure X Tx V0 HTx HV0subX). }
      claim Hdisj: V0 :/\: W0 = Empty.
      { apply Empty_Subq_eq.
        let z. assume Hz: z :e V0 :/\: W0.
        prove z :e Empty.
        claim HzV: z :e V0.
        { exact (binintersectE1 V0 W0 z Hz). }
        claim HzW: z :e W0.
        { exact (binintersectE2 V0 W0 z Hz). }
        claim Hzcl: z :e closure_of X Tx V0.
        { exact (HVsubcl z HzV). }
        claim Hznotcl: z /:e closure_of X Tx V0.
        { exact (setminusE2 X (closure_of X Tx V0) z HzW). }
        apply FalseE.
        exact (Hznotcl Hzcl). }
      witness V0.
      witness W0.
      apply andI.
      - apply andI.
        + apply andI.
          * apply andI.
            { exact HV0Tx. }
            { exact HW0Tx. }
          * exact HxV0.
        + exact HFsubW0.
      - exact Hdisj.

- (** Normal part **)
  assume HT1: one_point_sets_closed X Tx.
  prove normal_space X Tx <->
       forall A U:set, closed_in X Tx A -> U :e Tx -> A c= U ->
         exists V:set, V :e Tx /\ A c= V /\ closure_of X Tx V c= U.
  apply iffI.
  * assume Hnorm: normal_space X Tx.
    prove forall A U:set, closed_in X Tx A -> U :e Tx -> A c= U ->
         exists V:set, V :e Tx /\ A c= V /\ closure_of X Tx V c= U.
    claim HSepNorm:
      forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
        exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.
    { exact (andER (one_point_sets_closed X Tx)
                   (forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
                     exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty)
                   Hnorm). }
    let A U.
    assume HAcl: closed_in X Tx A.
    assume HU: U :e Tx.
    assume HAsubU: A c= U.
    set B := X :\: U.
    claim HBcl: closed_in X Tx B.
    { exact (closed_of_open_complement X Tx U HTx HU). }
    claim HABdisj: A :/\: B = Empty.
    { apply Empty_Subq_eq.
      let z. assume Hz: z :e A :/\: B.
      prove z :e Empty.
      claim HzA: z :e A.
      { exact (binintersectE1 A B z Hz). }
      claim HzB: z :e B.
      { exact (binintersectE2 A B z Hz). }
      claim HzU: z :e U.
      { exact (HAsubU z HzA). }
      claim HznotU: z /:e U.
      { exact (setminusE2 X U z HzB). }
      apply FalseE.
      exact (HznotU HzU). }
    claim Hex: exists V W:set, V :e Tx /\ W :e Tx /\ A c= V /\ B c= W /\ V :/\: W = Empty.
    { exact (HSepNorm A B HAcl HBcl HABdisj). }
    set V0 := Eps_i (fun V:set => exists W:set, V :e Tx /\ W :e Tx /\ A c= V /\ B c= W /\ V :/\: W = Empty).
    claim HV0ex: exists W:set, V0 :e Tx /\ W :e Tx /\ A c= V0 /\ B c= W /\ V0 :/\: W = Empty.
    { exact (Eps_i_ex (fun V:set => exists W:set, V :e Tx /\ W :e Tx /\ A c= V /\ B c= W /\ V :/\: W = Empty) Hex). }
    set W0 := Eps_i (fun W:set => V0 :e Tx /\ W :e Tx /\ A c= V0 /\ B c= W /\ V0 :/\: W = Empty).
    claim HW0prop: V0 :e Tx /\ W0 :e Tx /\ A c= V0 /\ B c= W0 /\ V0 :/\: W0 = Empty.
    { exact (Eps_i_ex (fun W:set => V0 :e Tx /\ W :e Tx /\ A c= V0 /\ B c= W /\ V0 :/\: W = Empty)
                      HV0ex). }
    claim H1234: (((V0 :e Tx /\ W0 :e Tx) /\ A c= V0) /\ B c= W0).
    { exact (andEL ((((V0 :e Tx /\ W0 :e Tx) /\ A c= V0) /\ B c= W0))
                   (V0 :/\: W0 = Empty)
                   HW0prop). }
    claim HdisjVW: V0 :/\: W0 = Empty.
    { exact (andER ((((V0 :e Tx /\ W0 :e Tx) /\ A c= V0) /\ B c= W0))
                   (V0 :/\: W0 = Empty)
                   HW0prop). }
    claim H123: ((V0 :e Tx /\ W0 :e Tx) /\ A c= V0).
    { exact (andEL ((V0 :e Tx /\ W0 :e Tx) /\ A c= V0) (B c= W0) H1234). }
    claim H12: (V0 :e Tx /\ W0 :e Tx).
    { exact (andEL (V0 :e Tx /\ W0 :e Tx) (A c= V0) H123). }
    claim HV0Tx: V0 :e Tx.
    { exact (andEL (V0 :e Tx) (W0 :e Tx) H12). }
    claim HW0Tx: W0 :e Tx.
    { exact (andER (V0 :e Tx) (W0 :e Tx) H12). }
    claim HAsubV0: A c= V0.
    { exact (andER (V0 :e Tx /\ W0 :e Tx) (A c= V0) H123). }
    claim HBsubW0: B c= W0.
    { exact (andER ((V0 :e Tx /\ W0 :e Tx) /\ A c= V0) (B c= W0) H1234). }
    claim HdisjWV: W0 :/\: V0 = Empty.
    { apply Empty_Subq_eq.
      let z. assume Hz: z :e W0 :/\: V0.
      prove z :e Empty.
      claim HzW: z :e W0.
      { exact (binintersectE1 W0 V0 z Hz). }
      claim HzV: z :e V0.
      { exact (binintersectE2 W0 V0 z Hz). }
      claim HzVW: z :e V0 :/\: W0.
      { exact (binintersectI V0 W0 z HzV HzW). }
      claim HzE: z :e Empty.
      { rewrite <- HdisjVW. exact HzVW. }
      exact HzE. }
	    claim HclV0subU: closure_of X Tx V0 c= U.
	    { let z. assume Hzcl: z :e closure_of X Tx V0.
	      prove z :e U.
	      claim HzX: z :e X.
	      { exact (SepE1 X (fun z0:set => forall N:set, N :e Tx -> z0 :e N -> N :/\: V0 <> Empty) z Hzcl). }
	      apply xm (z :e U).
	      - assume HzU: z :e U.
	        exact HzU.
	      - assume HznotU: z /:e U.
	        claim HzB: z :e B.
	        { exact (setminusI X U z HzX HznotU). }
	        claim HzW0: z :e W0.
	        { exact (HBsubW0 z HzB). }
	        claim Hcliff: z :e closure_of X Tx V0 <-> (forall N :e Tx, z :e N -> N :/\: V0 <> Empty).
	        { exact (closure_characterization X Tx V0 z HTx HzX). }
	        claim Hneigh: forall N :e Tx, z :e N -> N :/\: V0 <> Empty.
	        { exact (iffEL (z :e closure_of X Tx V0)
	                       (forall N :e Tx, z :e N -> N :/\: V0 <> Empty)
	                       Hcliff Hzcl). }
	        claim Hcontr: W0 :/\: V0 <> Empty.
	        { exact (Hneigh W0 HW0Tx HzW0). }
	        apply FalseE.
	        exact (Hcontr HdisjWV). }
	    witness V0.
	    apply andI.
	    - apply andI.
      + exact HV0Tx.
      + exact HAsubV0.
    - exact HclV0subU.
  * assume Hcrit:
      forall A U:set, closed_in X Tx A -> U :e Tx -> A c= U ->
        exists V:set, V :e Tx /\ A c= V /\ closure_of X Tx V c= U.
    prove normal_space X Tx.
    prove one_point_sets_closed X Tx /\
         forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
           exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.
    apply andI.
    - exact HT1.
    - let A. let B.
      assume HAcl: closed_in X Tx A.
      assume HBcl: closed_in X Tx B.
      assume Hdisj: A :/\: B = Empty.
      prove exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.
      set U0 := X :\: B.
      claim Hop0: open_in X Tx U0.
      { exact (open_of_closed_complement X Tx B HBcl). }
      claim HU0Tx: U0 :e Tx.
      { exact (andER (topology_on X Tx) (U0 :e Tx) Hop0). }
	      claim HAsubU0: A c= U0.
	      { let z. assume HzA: z :e A.
	        prove z :e U0.
	        claim HAsubX: A c= X.
	        { exact (closed_in_subset X Tx A HAcl). }
	        claim HzX: z :e X.
	        { exact (HAsubX z HzA). }
	        apply xm (z :e B).
	        - assume HzB: z :e B.
	          claim HzAB: z :e A :/\: B.
	          { exact (binintersectI A B z HzA HzB). }
	          claim HzE: z :e Empty.
	          { rewrite <- Hdisj. exact HzAB. }
	          apply FalseE.
	          exact (EmptyE z HzE False).
	        - assume HznotB: z /:e B.
	          exact (setminusI X B z HzX HznotB). }
      claim HexV: exists V:set, V :e Tx /\ A c= V /\ closure_of X Tx V c= U0.
      { exact (Hcrit A U0 HAcl HU0Tx HAsubU0). }
	      set V0 := Eps_i (fun V:set => V :e Tx /\ A c= V /\ closure_of X Tx V c= U0).
	      claim HV0prop: V0 :e Tx /\ A c= V0 /\ closure_of X Tx V0 c= U0.
	      { exact (Eps_i_ex (fun V:set => V :e Tx /\ A c= V /\ closure_of X Tx V c= U0) HexV). }
	      claim HV0TxHA: V0 :e Tx /\ A c= V0.
	      { exact (andEL (V0 :e Tx /\ A c= V0) (closure_of X Tx V0 c= U0) HV0prop). }
	      claim HV0Tx: V0 :e Tx.
	      { exact (andEL (V0 :e Tx) (A c= V0) HV0TxHA). }
	      claim HAsubV0: A c= V0.
	      { exact (andER (V0 :e Tx) (A c= V0) HV0TxHA). }
	      claim Hclsub: closure_of X Tx V0 c= U0.
	      { exact (andER (V0 :e Tx /\ A c= V0) (closure_of X Tx V0 c= U0) HV0prop). }
      claim HTsub: Tx c= Power X.
      { exact (topology_subset_axiom X Tx HTx). }
      claim HV0subX: V0 c= X.
      { exact (PowerE X V0 (HTsub V0 HV0Tx)). }
      claim HclV0cl: closed_in X Tx (closure_of X Tx V0).
      { exact (closure_is_closed X Tx V0 HTx HV0subX). }
      set W0 := X :\: closure_of X Tx V0.
      claim HopW: open_in X Tx W0.
      { exact (open_of_closed_complement X Tx (closure_of X Tx V0) HclV0cl). }
      claim HW0Tx: W0 :e Tx.
      { exact (andER (topology_on X Tx) (W0 :e Tx) HopW). }
	      claim HBsubW0: B c= W0.
	      { let z. assume HzB: z :e B.
	        prove z :e W0.
	        claim HBsubX: B c= X.
	        { exact (closed_in_subset X Tx B HBcl). }
	        claim HzX: z :e X.
	        { exact (HBsubX z HzB). }
	        apply xm (z :e closure_of X Tx V0).
	        - assume Hzcl: z :e closure_of X Tx V0.
	          claim HzU0: z :e U0.
	          { exact (Hclsub z Hzcl). }
	          claim HznotB: z /:e B.
	          { exact (setminusE2 X B z HzU0). }
	          apply FalseE.
	          exact (HznotB HzB).
	        - assume Hznotcl: z /:e closure_of X Tx V0.
	          exact (setminusI X (closure_of X Tx V0) z HzX Hznotcl). }
      claim HVsubcl: V0 c= closure_of X Tx V0.
      { exact (subset_of_closure X Tx V0 HTx HV0subX). }
      claim HdisjVW: V0 :/\: W0 = Empty.
      { apply Empty_Subq_eq.
        let z. assume Hz: z :e V0 :/\: W0.
        prove z :e Empty.
        claim HzV: z :e V0.
        { exact (binintersectE1 V0 W0 z Hz). }
        claim HzW: z :e W0.
        { exact (binintersectE2 V0 W0 z Hz). }
        claim Hzcl: z :e closure_of X Tx V0.
        { exact (HVsubcl z HzV). }
        claim Hznotcl: z /:e closure_of X Tx V0.
        { exact (setminusE2 X (closure_of X Tx V0) z HzW). }
        apply FalseE.
        exact (Hznotcl Hzcl). }
		      witness V0.
		      witness W0.
		      apply andI.
		      - apply andI.
		        + apply andI.
		          - apply andI.
		            + exact HV0Tx.
		            + exact HW0Tx.
		          - exact HAsubV0.
		        + exact HBsubW0.
		      - exact HdisjVW.
		Qed.

(** from 31 Theorem 31.2: subspaces/products preserve Hausdorff and regular **) 
(** LATEX VERSION: Hausdorff/regular properties preserved under subspaces and products (with factorwise assumptions). **)
Theorem separation_axioms_subspace_product : forall X Tx:set,
  topology_on X Tx ->
  (forall Y:set, Y c= X -> Hausdorff_space X Tx -> Hausdorff_space Y (subspace_topology X Tx Y)) /\
  (forall I Xi:set, Hausdorff_spaces_family I Xi -> Hausdorff_space (product_space I Xi) (product_topology_full I Xi)) /\
  (forall Y:set, Y c= X -> regular_space X Tx -> regular_space Y (subspace_topology X Tx Y)) /\
  (forall I Xi:set, regular_spaces_family I Xi -> regular_space (product_space I Xi) (product_topology_full I Xi)).
	let X Tx.
	assume HTx: topology_on X Tx.
	prove (forall Y:set, Y c= X -> Hausdorff_space X Tx -> Hausdorff_space Y (subspace_topology X Tx Y)) /\
	  (forall I Xi:set, Hausdorff_spaces_family I Xi -> Hausdorff_space (product_space I Xi) (product_topology_full I Xi)) /\
	  (forall Y:set, Y c= X -> regular_space X Tx -> regular_space Y (subspace_topology X Tx Y)) /\
	  (forall I Xi:set, regular_spaces_family I Xi -> regular_space (product_space I Xi) (product_topology_full I Xi)).
	apply andI.
	- apply andI.
	  + apply andI.
	    - let Y. assume HYsub: Y c= X.
	      assume HH: Hausdorff_space X Tx.
	      prove Hausdorff_space Y (subspace_topology X Tx Y).
	      exact (ex17_12_subspace_Hausdorff X Tx Y HH HYsub).
	    - admit. (** product_topology_full Hausdorff: pending; use cylinder neighborhoods and pointwise separation **)
		  + let Y. assume HYsub: Y c= X.
		    assume Hreg: regular_space X Tx.
		    prove one_point_sets_closed Y (subspace_topology X Tx Y) /\
		      forall y0:set, y0 :e Y ->
		        forall F0:set, closed_in Y (subspace_topology X Tx Y) F0 -> y0 /:e F0 ->
		          exists U V:set, U :e subspace_topology X Tx Y /\ V :e subspace_topology X Tx Y /\ y0 :e U /\ F0 c= V /\ U :/\: V = Empty.
		    claim HTy: topology_on Y (subspace_topology X Tx Y).
		    { exact (subspace_topology_is_topology X Tx Y HTx HYsub). }
	    claim HT1X: one_point_sets_closed X Tx.
	    { exact (andEL (one_point_sets_closed X Tx)
	                   (forall x:set, x :e X ->
	                     forall F:set, closed_in X Tx F -> x /:e F ->
	                       exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty)
	                   Hreg). }
	    claim HsingX: forall x:set, x :e X -> closed_in X Tx {x}.
	    { exact (andER (topology_on X Tx) (forall x:set, x :e X -> closed_in X Tx {x}) HT1X). }
	    claim HsepX:
	      forall x:set, x :e X ->
	        forall F:set, closed_in X Tx F -> x /:e F ->
	          exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty.
	    { exact (andER (one_point_sets_closed X Tx)
	                   (forall x:set, x :e X ->
	                     forall F:set, closed_in X Tx F -> x /:e F ->
	                       exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty)
	                   Hreg). }
		    apply andI.
			    - prove topology_on Y (subspace_topology X Tx Y) /\
			        forall y:set, y :e Y -> closed_in Y (subspace_topology X Tx Y) {y}.
			      apply andI.
			      + exact HTy.
			      + let y. assume HyY: y :e Y.
			        prove closed_in Y (subspace_topology X Tx Y) {y}.
		        claim HyX: y :e X.
		        { exact (HYsub y HyY). }
	        apply (iffER (closed_in Y (subspace_topology X Tx Y) {y})
	                     (exists C:set, closed_in X Tx C /\ {y} = C :/\: Y)
	                     (closed_in_subspace_iff_intersection X Tx Y {y} HTx HYsub)).
	        witness {y}.
	        apply andI.
	        - exact (HsingX y HyX).
	        - apply set_ext.
	          + let z. assume Hz: z :e {y}.
	            prove z :e {y} :/\: Y.
	            claim Hzeq: z = y.
	            { exact (SingE y z Hz). }
	            rewrite Hzeq.
	            exact (binintersectI {y} Y y (SingI y) HyY).
	          + let z. assume Hz: z :e {y} :/\: Y.
	            prove z :e {y}.
	            exact (binintersectE1 {y} Y z Hz).
		    - let y. assume HyY: y :e Y.
		      let F. assume HFcl: closed_in Y (subspace_topology X Tx Y) F.
		      assume HynotF: y /:e F.
		      prove exists U V:set, U :e subspace_topology X Tx Y /\ V :e subspace_topology X Tx Y /\ y :e U /\ F c= V /\ U :/\: V = Empty.
		      claim HyX: y :e X.
		      { exact (HYsub y HyY). }
	      claim HexC: exists C:set, closed_in X Tx C /\ F = C :/\: Y.
	      { exact (iffEL (closed_in Y (subspace_topology X Tx Y) F)
	                     (exists C:set, closed_in X Tx C /\ F = C :/\: Y)
	                     (closed_in_subspace_iff_intersection X Tx Y F HTx HYsub)
	                     HFcl). }
		      set C0 := Eps_i (fun C:set => closed_in X Tx C /\ F = C :/\: Y).
		      claim HC0prop: closed_in X Tx C0 /\ F = C0 :/\: Y.
		      { exact (Eps_i_ex (fun C:set => closed_in X Tx C /\ F = C :/\: Y) HexC). }
	      claim HC0cl: closed_in X Tx C0.
	      { exact (andEL (closed_in X Tx C0) (F = C0 :/\: Y) HC0prop). }
	      claim HFeq: F = C0 :/\: Y.
	      { exact (andER (closed_in X Tx C0) (F = C0 :/\: Y) HC0prop). }
	      claim HynotC0: y /:e C0.
	      { assume HyC0: y :e C0.
	        prove False.
	        claim HyF: y :e F.
	        { rewrite HFeq.
	          exact (binintersectI C0 Y y HyC0 HyY). }
	        exact (HynotF HyF). }
		      claim HexUV: exists U V:set, U :e Tx /\ V :e Tx /\ y :e U /\ C0 c= V /\ U :/\: V = Empty.
		      { exact (HsepX y HyX C0 HC0cl HynotC0). }
		      set Ux := Eps_i (fun U:set =>
		        exists V:set, U :e Tx /\ V :e Tx /\ y :e U /\ C0 c= V /\ U :/\: V = Empty).
		      claim HUxprop: exists V:set, Ux :e Tx /\ V :e Tx /\ y :e Ux /\ C0 c= V /\ Ux :/\: V = Empty.
		      { exact (Eps_i_ex (fun U:set =>
		               exists V:set, U :e Tx /\ V :e Tx /\ y :e U /\ C0 c= V /\ U :/\: V = Empty) HexUV). }
		      set Vx := Eps_i (fun V:set => Ux :e Tx /\ V :e Tx /\ y :e Ux /\ C0 c= V /\ Ux :/\: V = Empty).
		      claim HVxprop: Ux :e Tx /\ Vx :e Tx /\ y :e Ux /\ C0 c= Vx /\ Ux :/\: Vx = Empty.
		      { exact (Eps_i_ex (fun V:set => Ux :e Tx /\ V :e Tx /\ y :e Ux /\ C0 c= V /\ Ux :/\: V = Empty) HUxprop). }
		      claim H1234: ((Ux :e Tx /\ Vx :e Tx) /\ y :e Ux) /\ C0 c= Vx.
		      { exact (andEL (((Ux :e Tx /\ Vx :e Tx) /\ y :e Ux) /\ C0 c= Vx)
		                     (Ux :/\: Vx = Empty)
		                     HVxprop). }
		      claim HdisjUV: Ux :/\: Vx = Empty.
		      { exact (andER (((Ux :e Tx /\ Vx :e Tx) /\ y :e Ux) /\ C0 c= Vx)
		                     (Ux :/\: Vx = Empty)
		                     HVxprop). }
		      claim H123: (Ux :e Tx /\ Vx :e Tx) /\ y :e Ux.
		      { exact (andEL ((Ux :e Tx /\ Vx :e Tx) /\ y :e Ux) (C0 c= Vx) H1234). }
		      claim HC0subVx: C0 c= Vx.
		      { exact (andER ((Ux :e Tx /\ Vx :e Tx) /\ y :e Ux) (C0 c= Vx) H1234). }
		      claim H12: Ux :e Tx /\ Vx :e Tx.
		      { exact (andEL (Ux :e Tx /\ Vx :e Tx) (y :e Ux) H123). }
		      claim HyUx: y :e Ux.
		      { exact (andER (Ux :e Tx /\ Vx :e Tx) (y :e Ux) H123). }
		      claim HUxTx: Ux :e Tx.
		      { exact (andEL (Ux :e Tx) (Vx :e Tx) H12). }
		      claim HVxTx: Vx :e Tx.
		      { exact (andER (Ux :e Tx) (Vx :e Tx) H12). }
		      set U0 := Ux :/\: Y.
		      set V0 := Vx :/\: Y.
		      witness U0.
		      witness V0.
		      apply andI.
		      - apply andI.
		        + apply andI.
		          - apply andI.
		            + prove U0 :e subspace_topology X Tx Y.
		              claim HU0subY: U0 c= Y.
		              { exact (binintersect_Subq_2 Ux Y). }
		              claim HU0pow: U0 :e Power Y.
		              { exact (PowerI Y U0 HU0subY). }
		              claim HU0ex: exists V :e Tx, U0 = V :/\: Y.
		              { witness Ux.
		                apply andI.
		                - exact HUxTx.
		                - reflexivity. }
		              exact (SepI (Power Y) (fun U:set => exists V :e Tx, U = V :/\: Y) U0 HU0pow HU0ex).
		            + prove V0 :e subspace_topology X Tx Y.
		              claim HV0subY: V0 c= Y.
		              { exact (binintersect_Subq_2 Vx Y). }
		              claim HV0pow: V0 :e Power Y.
		              { exact (PowerI Y V0 HV0subY). }
		              claim HV0ex: exists V :e Tx, V0 = V :/\: Y.
		              { witness Vx.
		                apply andI.
		                - exact HVxTx.
		                - reflexivity. }
		              exact (SepI (Power Y) (fun U:set => exists V :e Tx, U = V :/\: Y) V0 HV0pow HV0ex).
		          - exact (binintersectI Ux Y y HyUx HyY).
		        + let z. assume HzF: z :e F.
		          prove z :e V0.
		          claim HzCY: z :e C0 :/\: Y.
		          { rewrite <- HFeq. exact HzF. }
		          claim HzC0: z :e C0.
		          { exact (binintersectE1 C0 Y z HzCY). }
		          claim HzY: z :e Y.
		          { exact (binintersectE2 C0 Y z HzCY). }
		          claim HzVx: z :e Vx.
		          { exact (HC0subVx z HzC0). }
		          exact (binintersectI Vx Y z HzVx HzY).
		      - apply Empty_Subq_eq.
		        let z. assume Hz: z :e U0 :/\: V0.
		        prove z :e Empty.
		        claim HzU0: z :e U0.
		        { exact (binintersectE1 U0 V0 z Hz). }
		        claim HzV0: z :e V0.
		        { exact (binintersectE2 U0 V0 z Hz). }
		        claim HzUx: z :e Ux.
		        { exact (binintersectE1 Ux Y z HzU0). }
		        claim HzVx: z :e Vx.
		        { exact (binintersectE1 Vx Y z HzV0). }
		        claim HzUV: z :e Ux :/\: Vx.
		        { exact (binintersectI Ux Vx z HzUx HzVx). }
		        rewrite <- HdisjUV.
		        exact HzUV.
	- admit. (** product_topology_full regular: pending; coordinatewise separation using regularity of factors **)
Qed.

(** from 31 Example 1 setup: R_K space **) 
Definition R_K : set := R.

(** from 31 Example 1: R_K Hausdorff but not regular **) 
(** LATEX VERSION: The K-topology on  is Hausdorff but not regular. **)
Theorem RK_Hausdorff_not_regular :
  Hausdorff_space R_K R_K_topology /\ ~ regular_space R_K R_K_topology.
prove Hausdorff_space R_K R_K_topology /\ ~ regular_space R_K R_K_topology.
apply andI.
- (** Hausdorff part follows from earlier theorem about R_K_topology **)
  claim HRKeq: R_K = R.
  { reflexivity. }
  rewrite HRKeq.
  exact R_K_topology_Hausdorff.
- (** Not regular: standard counterexample at 0 using closed set K_set; pending full formal proof. **)
  admit.
Qed.

(** from 31 Example 2: Sorgenfrey line normal **) 
(** LATEX VERSION: The Sorgenfrey line is normal. **)
Theorem Sorgenfrey_line_normal : normal_space Sorgenfrey_line Sorgenfrey_topology.
prove normal_space Sorgenfrey_line Sorgenfrey_topology.
admit. (** for disjoint closed sets A,B use half-open intervals to separate; regularity proof extends **)
Qed.

(** from 31 Example 3: Sorgenfrey plane not normal **) 
(** LATEX VERSION: The Sorgenfrey plane is regular but not normal. **)
Theorem Sorgenfrey_plane_not_normal :
  regular_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology /\
  ~ normal_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology.
prove regular_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology /\
  ~ normal_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology.
admit. (** regular by product; antidiagonal H={(x,-x):xR} closed, discrete subspace; uncountable discrete closed not normal **)
Qed.

(** from 32 Theorem 32.1: regular space with countable basis is normal **) 
(** LATEX VERSION: Regular + second countable  normal (Theorem 32.1). **)
Theorem regular_countable_basis_normal : forall X Tx:set,
  regular_space X Tx -> second_countable_space X Tx -> normal_space X Tx.
let X Tx.
assume Hreg: regular_space X Tx.
assume Hscc: second_countable_space X Tx.
prove normal_space X Tx.
admit. (** use countable basis to separate disjoint closed sets; enumerate basis elements, build separating opens inductively **)
Qed.

(** from 32 Theorem 32.4: well-ordered sets are normal in order topology **) 
(** LATEX VERSION: Well-ordered sets with the order topology are normal. **)
Theorem well_ordered_sets_normal : forall X:set,
  well_ordered_set X -> normal_space X (order_topology X).
let X.
assume Hwo: well_ordered_set X.
prove normal_space X (order_topology X).
admit. (** use well-ordering to construct separating neighborhoods; for disjoint closed A,B, use rays and intervals **)
Qed.
(** from 32 Theorem 32.2: metrizable spaces are normal **) 
(** LATEX VERSION: Every metrizable space is normal. **)
Theorem metrizable_spaces_normal : forall X d:set,
  metric_on X d -> normal_space X (metric_topology X d).
let X d.
assume Hd: metric_on X d.
prove normal_space X (metric_topology X d).
admit. (** for disjoint closed A,B, use distance functions: U={x:d(x,A)<d(x,B)}, V={x:d(x,B)<d(x,A)} disjoint open **)
Qed.

(** from 32 Theorem 32.3: compact Hausdorff spaces are normal **) 
(** LATEX VERSION: Compact Hausdorff  normal (Theorem 32.3). **)
Theorem compact_Hausdorff_normal : forall X Tx:set,
  compact_space X Tx -> Hausdorff_space X Tx -> normal_space X Tx.
let X Tx.
assume Hcomp: compact_space X Tx.
assume HH: Hausdorff_space X Tx.
prove normal_space X Tx.
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (forall Fam:set, open_cover_of X Tx Fam -> has_finite_subcover X Tx Fam) Hcomp). }
claim HT1: one_point_sets_closed X Tx.
{ prove topology_on X Tx /\ forall x:set, x :e X -> closed_in X Tx {x}.
  apply andI.
  - exact HTx.
  - let x. assume HxX: x :e X.
    exact (Hausdorff_singletons_closed X Tx x HH HxX). }
prove one_point_sets_closed X Tx /\
  forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
    exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.
apply andI.
- exact HT1.
- let A B.
  assume HAcl: closed_in X Tx A.
  assume HBcl: closed_in X Tx B.
  assume Hdisj: A :/\: B = Empty.
  prove exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.
  claim HAsubX: A c= X.
  { exact (closed_in_subset X Tx A HAcl). }
  claim HBsubX: B c= X.
  { exact (closed_in_subset X Tx B HBcl). }
  claim HcompA: compact_space A (subspace_topology X Tx A).
  { exact (closed_subspace_compact X Tx A Hcomp HAcl). }
  claim HcompB: compact_space B (subspace_topology X Tx B).
  { exact (closed_subspace_compact X Tx B Hcomp HBcl). }

  (** For each aA, separate a from compact B. **)
  set Uof := fun a:set =>
    Eps_i (fun U:set => exists V:set, U :e Tx /\ V :e Tx /\ a :e U /\ B c= V /\ U :/\: V = Empty).
  set Vof := fun a:set =>
    Eps_i (fun V:set => Uof a :e Tx /\ V :e Tx /\ a :e Uof a /\ B c= V /\ Uof a :/\: V = Empty).

  claim UVprop: forall a:set, a :e A ->
    Uof a :e Tx /\ (Vof a :e Tx /\ (a :e Uof a /\ (B c= Vof a /\ Uof a :/\: Vof a = Empty))).
  { let a. assume HaA: a :e A.
    claim HaX: a :e X.
    { exact (HAsubX a HaA). }
    claim HanotB: a /:e B.
    { assume HaB: a :e B.
      claim HaAB: a :e A :/\: B.
      { exact (binintersectI A B a HaA HaB). }
      claim HaE: a :e Empty.
      { rewrite <- Hdisj. exact HaAB. }
      apply FalseE.
      exact (EmptyE a HaE False). }
    claim HexUV: exists U V:set, U :e Tx /\ V :e Tx /\ a :e U /\ B c= V /\ U :/\: V = Empty.
    { exact (Hausdorff_separate_point_compact_set X Tx B a HH HBsubX HcompB HaX HanotB). }
    claim HUof: exists V:set, Uof a :e Tx /\ V :e Tx /\ a :e Uof a /\ B c= V /\ Uof a :/\: V = Empty.
    { exact (Eps_i_ex (fun U:set => exists V:set, U :e Tx /\ V :e Tx /\ a :e U /\ B c= V /\ U :/\: V = Empty) HexUV). }
    claim HVof: Uof a :e Tx /\ Vof a :e Tx /\ a :e Uof a /\ B c= Vof a /\ Uof a :/\: Vof a = Empty.
    { exact (Eps_i_ex (fun V:set => Uof a :e Tx /\ V :e Tx /\ a :e Uof a /\ B c= V /\ Uof a :/\: V = Empty) HUof). }
    (** Repackage the left-associated 5-way conjunction into a right-associated form. **)
    claim H1234: ((Uof a :e Tx /\ Vof a :e Tx) /\ a :e Uof a) /\ B c= Vof a.
    { exact (andEL (((Uof a :e Tx /\ Vof a :e Tx) /\ a :e Uof a) /\ B c= Vof a)
                   (Uof a :/\: Vof a = Empty)
                   HVof). }
    claim H5: Uof a :/\: Vof a = Empty.
    { exact (andER (((Uof a :e Tx /\ Vof a :e Tx) /\ a :e Uof a) /\ B c= Vof a)
                   (Uof a :/\: Vof a = Empty)
                   HVof). }
    claim H123: (Uof a :e Tx /\ Vof a :e Tx) /\ a :e Uof a.
    { exact (andEL ((Uof a :e Tx /\ Vof a :e Tx) /\ a :e Uof a)
                   (B c= Vof a)
                   H1234). }
    claim H4: B c= Vof a.
    { exact (andER ((Uof a :e Tx /\ Vof a :e Tx) /\ a :e Uof a)
                   (B c= Vof a)
                   H1234). }
    claim H12: Uof a :e Tx /\ Vof a :e Tx.
    { exact (andEL (Uof a :e Tx /\ Vof a :e Tx)
                   (a :e Uof a)
                   H123). }
    claim H3: a :e Uof a.
    { exact (andER (Uof a :e Tx /\ Vof a :e Tx)
                   (a :e Uof a)
                   H123). }
    claim HUofTx: Uof a :e Tx.
    { exact (andEL (Uof a :e Tx) (Vof a :e Tx) H12). }
    claim HVofTx: Vof a :e Tx.
    { exact (andER (Uof a :e Tx) (Vof a :e Tx) H12). }
    apply andI.
    - exact HUofTx.
	    - apply andI.
	      + exact HVofTx.
	      + apply andI.
	        * exact H3.
	        * apply andI.
	          - exact H4.
	          - exact H5. }

  (** Cover A by opens Uof a. **)
  set Fam := {Uof a|a :e A}.
  claim HFamSub: Fam c= Tx.
  { let U. assume HU: U :e Fam.
    apply (ReplE_impred A (fun a:set => Uof a) U HU (U :e Tx)).
    let a. assume HaA: a :e A.
    assume HUeq: U = Uof a.
    claim HUofTx: Uof a :e Tx.
    { exact (andEL (Uof a :e Tx)
                   (Vof a :e Tx /\ (a :e Uof a /\ (B c= Vof a /\ Uof a :/\: Vof a = Empty)))
                   (UVprop a HaA)). }
    rewrite HUeq.
    exact HUofTx. }
  claim HAcov: A c= Union Fam.
  { let a. assume HaA: a :e A.
    prove a :e Union Fam.
    claim HaU: a :e Uof a.
    { exact (andEL (a :e Uof a)
                   (B c= Vof a /\ Uof a :/\: Vof a = Empty)
                   (andER (Vof a :e Tx)
                          (a :e Uof a /\ (B c= Vof a /\ Uof a :/\: Vof a = Empty))
                          (andER (Uof a :e Tx)
                                 (Vof a :e Tx /\ (a :e Uof a /\ (B c= Vof a /\ Uof a :/\: Vof a = Empty)))
                                 (UVprop a HaA)))). }
    claim HUinFam: Uof a :e Fam.
    { exact (ReplI A (fun a0:set => Uof a0) a HaA). }
    exact (UnionI Fam a (Uof a) HaU HUinFam). }

  (** Use compactness of A to extract a finite subcover from Fam. **)
  claim HcoverProp: forall Fam0:set, (Fam0 c= Tx /\ A c= Union Fam0) -> has_finite_subcover A Tx Fam0.
  { claim Hequiv:
      (compact_space A (subspace_topology X Tx A) <->
        forall Fam0:set, (Fam0 c= Tx /\ A c= Union Fam0) -> has_finite_subcover A Tx Fam0).
    { exact (compact_subspace_via_ambient_covers X Tx A HTx HAsubX). }
    exact (iffEL (compact_space A (subspace_topology X Tx A))
                 (forall Fam0:set, (Fam0 c= Tx /\ A c= Union Fam0) -> has_finite_subcover A Tx Fam0)
                 Hequiv HcompA). }

  claim Hfin: has_finite_subcover A Tx Fam.
  { exact (HcoverProp Fam (andI (Fam c= Tx) (A c= Union Fam) HFamSub HAcov)). }
  apply Hfin.
  let G. assume HG: G c= Fam /\ finite G /\ A c= Union G.
  claim HGleft: G c= Fam /\ finite G.
  { exact (andEL (G c= Fam /\ finite G) (A c= Union G) HG). }
  claim HGsubFam: G c= Fam.
  { exact (andEL (G c= Fam) (finite G) HGleft). }
  claim HGfin: finite G.
  { exact (andER (G c= Fam) (finite G) HGleft). }
  claim HAcovG: A c= Union G.
  { exact (andER (G c= Fam /\ finite G) (A c= Union G) HG). }
  claim HGsubTx: G c= Tx.
  { let U. assume HU: U :e G.
    prove U :e Tx.
    claim HUfam: U :e Fam.
    { exact (HGsubFam U HU). }
    exact (HFamSub U HUfam). }

  (** Define U = union of the finite subcover G. **)
  set U := Union G.
  claim HUtx: U :e Tx.
  { exact (topology_union_closed X Tx G HTx HGsubTx). }

  (** Pick an index a(U) for each UG with U = Uof a(U). **)
  set Wof := fun U0:set => Eps_i (fun a:set => a :e A /\ U0 = Uof a).
  claim Wof_spec: forall U0:set, U0 :e G -> Wof U0 :e A /\ U0 = Uof (Wof U0).
  { let U0. assume HU0G: U0 :e G.
    claim HU0Fam: U0 :e Fam.
    { exact (HGsubFam U0 HU0G). }
    claim Hexa: exists a:set, a :e A /\ U0 = Uof a.
    { apply (ReplE_impred A (fun a0:set => Uof a0) U0 HU0Fam (exists a:set, a :e A /\ U0 = Uof a)).
      let a. assume HaA: a :e A.
      assume HU0eq: U0 = Uof a.
      witness a.
      apply andI.
      - exact HaA.
      - exact HU0eq. }
    apply Hexa.
    let a. assume HaPair: a :e A /\ U0 = Uof a.
    exact (Eps_i_ax (fun a0:set => a0 :e A /\ U0 = Uof a0) a HaPair). }

  (** Define the corresponding family of V's and take their finite intersection. **)
  set GV := {Vof (Wof U0)|U0 :e G}.
  claim HGVfin: finite GV.
  { exact (Repl_finite (fun U0:set => Vof (Wof U0)) G HGfin). }
  claim HGVsubTx: GV c= Tx.
  { let V. assume HV: V :e GV.
    apply (ReplE_impred G (fun U0:set => Vof (Wof U0)) V HV (V :e Tx)).
    let U0. assume HU0G: U0 :e G.
    assume HVe: V = Vof (Wof U0).
    claim HWofA: Wof U0 :e A.
    { exact (andEL (Wof U0 :e A) (U0 = Uof (Wof U0)) (Wof_spec U0 HU0G)). }
    claim HVofTx: Vof (Wof U0) :e Tx.
    { exact (andEL (Vof (Wof U0) :e Tx)
                   (Wof U0 :e Uof (Wof U0) /\ (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty))
                   (andER (Uof (Wof U0) :e Tx)
                          (Vof (Wof U0) :e Tx /\ (Wof U0 :e Uof (Wof U0) /\ (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty)))
                          (UVprop (Wof U0) HWofA))). }
    rewrite HVe.
    exact HVofTx. }

  set V := intersection_of_family X GV.
  claim HVtx: V :e Tx.
  { claim HGVpow: GV :e Power Tx.
    { apply PowerI.
      exact HGVsubTx. }
    exact (finite_intersection_in_topology X Tx GV HTx HGVpow HGVfin). }

  (** B is contained in V since each Vof a contains B. **)
  claim HBsubV: B c= V.
  { let b. assume HbB: b :e B.
    prove b :e V.
    claim HbPred: forall U1:set, U1 :e GV -> b :e U1.
    { let W. assume HW: W :e GV.
      prove b :e W.
      apply (ReplE_impred G (fun U0:set => Vof (Wof U0)) W HW (b :e W)).
      let U0. assume HU0G: U0 :e G.
      assume HWeq: W = Vof (Wof U0).
      claim HWofA: Wof U0 :e A.
      { exact (andEL (Wof U0 :e A) (U0 = Uof (Wof U0)) (Wof_spec U0 HU0G)). }
      claim HUV1:
        Vof (Wof U0) :e Tx /\
        (Wof U0 :e Uof (Wof U0) /\ (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty)).
      { exact (andER (Uof (Wof U0) :e Tx)
                     (Vof (Wof U0) :e Tx /\ (Wof U0 :e Uof (Wof U0) /\ (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty)))
                     (UVprop (Wof U0) HWofA)). }
      claim HUV2:
        Wof U0 :e Uof (Wof U0) /\ (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty).
      { exact (andER (Vof (Wof U0) :e Tx)
                     (Wof U0 :e Uof (Wof U0) /\ (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty))
                     HUV1). }
      claim HUV3: B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty.
      { exact (andER (Wof U0 :e Uof (Wof U0))
                     (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty)
                     HUV2). }
      claim HBsubVof: B c= Vof (Wof U0).
      { exact (andEL (B c= Vof (Wof U0))
                     (Uof (Wof U0) :/\: Vof (Wof U0) = Empty)
                     HUV3). }
      rewrite HWeq.
      exact (HBsubVof b HbB). }
    exact (SepI X (fun x:set => forall U1:set, U1 :e GV -> x :e U1) b (HBsubX b HbB) HbPred). }

  (** U and V are disjoint. **)
  claim HUVdisj: U :/\: V = Empty.
  { apply Empty_Subq_eq.
    let z. assume Hz: z :e U :/\: V.
    prove z :e Empty.
    claim HzU: z :e U.
    { exact (binintersectE1 U V z Hz). }
    claim HzV: z :e V.
    { exact (binintersectE2 U V z Hz). }
    apply (UnionE_impred G z HzU (z :e Empty)).
    let U0. assume HzU0: z :e U0.
    assume HU0G: U0 :e G.
    claim HWofA: Wof U0 :e A.
    { exact (andEL (Wof U0 :e A) (U0 = Uof (Wof U0)) (Wof_spec U0 HU0G)). }
    claim HU0eq: U0 = Uof (Wof U0).
    { exact (andER (Wof U0 :e A) (U0 = Uof (Wof U0)) (Wof_spec U0 HU0G)). }
    claim HVinGV: Vof (Wof U0) :e GV.
    { exact (ReplI G (fun U1:set => Vof (Wof U1)) U0 HU0G). }
    claim HzVof: z :e Vof (Wof U0).
    { exact (SepE2 X (fun x:set => forall U1:set, U1 :e GV -> x :e U1) z HzV (Vof (Wof U0)) HVinGV). }
    claim HzUof: z :e Uof (Wof U0).
    { rewrite <- HU0eq. exact HzU0. }
    claim Hdisj0: Uof (Wof U0) :/\: Vof (Wof U0) = Empty.
    { claim HUV1:
        Vof (Wof U0) :e Tx /\
        (Wof U0 :e Uof (Wof U0) /\ (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty)).
      { exact (andER (Uof (Wof U0) :e Tx)
                     (Vof (Wof U0) :e Tx /\ (Wof U0 :e Uof (Wof U0) /\ (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty)))
                     (UVprop (Wof U0) HWofA)). }
      claim HUV2:
        Wof U0 :e Uof (Wof U0) /\ (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty).
      { exact (andER (Vof (Wof U0) :e Tx)
                     (Wof U0 :e Uof (Wof U0) /\ (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty))
                     HUV1). }
      claim HUV3: B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty.
      { exact (andER (Wof U0 :e Uof (Wof U0))
                     (B c= Vof (Wof U0) /\ Uof (Wof U0) :/\: Vof (Wof U0) = Empty)
                     HUV2). }
      exact (andER (B c= Vof (Wof U0))
                   (Uof (Wof U0) :/\: Vof (Wof U0) = Empty)
                   HUV3). }
    claim HzUV0: z :e Uof (Wof U0) :/\: Vof (Wof U0).
    { exact (binintersectI (Uof (Wof U0)) (Vof (Wof U0)) z HzUof HzVof). }
    rewrite <- Hdisj0.
    exact HzUV0. }

  (** Build the final neighborhoods. **)
  witness U.
  witness V.
  apply andI.
  - apply andI.
    - apply andI.
      - apply andI.
        - exact HUtx.
        - exact HVtx.
      - exact HAcovG.
    - exact HBsubV.
  - exact HUVdisj.
Qed.

(** from 32 Example 1: uncountable product of R not normal **) 
(** LATEX VERSION: An uncountable product of  with product topology need not be normal. **)
Theorem uncountable_product_R_not_normal : forall J:set,
  uncountable_set J -> ~ normal_space (product_space J (const_space_family J R R_standard_topology)) (product_topology_full J (const_space_family J R R_standard_topology)).
let J.
assume HJ: uncountable_set J.
prove ~ normal_space (product_space J (const_space_family J R R_standard_topology)) (product_topology_full J (const_space_family J R R_standard_topology)).
admit. (** construct disjoint closed sets that cannot be separated by disjoint open sets; use diagonal argument **)
Qed.

(** from 32 Example 2: SOmega x SbarOmega not normal **)
(** LATEX VERSION: Product S_S_ gives a non-normal example. **)
(** FIXED: Product of two spaces should use binary product_topology, not general product_space.
    Was: R^{S_Omega  Sbar_Omega} (product indexed by S_Omega  Sbar_Omega with each factor R)
    Now: S_Omega  Sbar_Omega (Cartesian product with product topology) **)
Definition S_Omega : set := omega.
Definition Sbar_Omega : set := Power omega.
Definition SOmega_topology : set := discrete_topology S_Omega.
Definition SbarOmega_topology : set := discrete_topology Sbar_Omega.

Theorem SOmega_SbarOmega_not_normal :
  normal_space S_Omega SOmega_topology /\ normal_space Sbar_Omega SbarOmega_topology /\
  ~ normal_space (setprod S_Omega Sbar_Omega) (product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology).
prove normal_space S_Omega SOmega_topology /\ normal_space Sbar_Omega SbarOmega_topology /\
  ~ normal_space (setprod S_Omega Sbar_Omega) (product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology).
apply andI.
- prove normal_space S_Omega SOmega_topology /\ normal_space Sbar_Omega SbarOmega_topology.
  apply andI.
  * claim HSO: SOmega_topology = discrete_topology S_Omega.
    { reflexivity. }
    rewrite HSO.
    exact (discrete_normal_space S_Omega).
  * claim HSb: SbarOmega_topology = discrete_topology Sbar_Omega.
    { reflexivity. }
    rewrite HSb.
    exact (discrete_normal_space Sbar_Omega).
- admit. (** product gives a non-normal example **)
Qed.

(** from 33 Theorem 33.1 (Urysohn lemma): continuous function separating closed sets in normal space **)
(** LATEX VERSION: Urysohn lemma: In a normal space, disjoint closed sets can be separated by continuous f: X[a,b]. **)
(** FIXED: Urysohn lemma was missing separation conditions.
    Was: exists f continuous from X to [a,b] (trivially true - any constant function works!)
    Now: exists f continuous with f(A)=a and f(B)=b (actually separates A from B)
    The comment says "separated by continuous f", so f must map A to a and B to b. **)
Definition closed_interval : set -> set -> set := fun a b =>
  {x :e R | ~(Rlt x a) /\ ~(Rlt b x)}.

Theorem Urysohn_lemma : forall X Tx A B a b:set,
  normal_space X Tx -> closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
  exists f:set, continuous_map X Tx (closed_interval a b) (order_topology (closed_interval a b)) f /\
    (forall x:set, x :e A -> apply_fun f x = a) /\
    (forall x:set, x :e B -> apply_fun f x = b).
let X Tx A B a b.
assume Hnorm: normal_space X Tx.
assume HA: closed_in X Tx A.
assume HB: closed_in X Tx B.
assume Hdisj: A :/\: B = Empty.
prove exists f:set, continuous_map X Tx (closed_interval a b) (order_topology (closed_interval a b)) f /\
    (forall x:set, x :e A -> apply_fun f x = a) /\
    (forall x:set, x :e B -> apply_fun f x = b).
admit. (** construct nested opens indexed by rationals; define f via supremum of rationals; verify continuity
        aby: In_5Fno2cycle order_topologyf order_topology_on_Zplus_discrete binintersectf conj_myprob_10080_1_20251124_041615 Hausdorff_5Fspace_def ex17_10_order_topology_Hausdorff closed_inf . **)
Qed.

(** from 33 Definition: completely regular space **) 
(** LATEX VERSION: Completely regular (Tikhonov) spaces admit continuous [0,1]-valued functions separating point and closed set. **)
Definition completely_regular_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall x:set, x :e X ->
    forall F:set, closed_in X Tx F -> x /:e F ->
      exists f:set,
        continuous_map X Tx R R_standard_topology f /\
        apply_fun f x = 0 /\ forall y:set, y :e F -> apply_fun f y = 1.

(** Helper: any function is continuous from a discrete domain **)
Theorem continuous_from_discrete : forall X Y Ty f:set,
  topology_on Y Ty ->
  function_on f X Y ->
  continuous_map X (discrete_topology X) Y Ty f.
let X Y Ty f.
assume HTy: topology_on Y Ty.
assume Hfun: function_on f X Y.
prove continuous_map X (discrete_topology X) Y Ty f.
claim HTx: topology_on X (discrete_topology X).
{ exact (discrete_topology_on X). }
prove topology_on X (discrete_topology X) /\ topology_on Y Ty /\ function_on f X Y /\
  forall V:set, V :e Ty -> preimage_of X f V :e discrete_topology X.
apply andI.
- prove (topology_on X (discrete_topology X) /\ topology_on Y Ty) /\ function_on f X Y.
  apply andI.
  * apply andI.
    - exact HTx.
    - exact HTy.
  * exact Hfun.
- let V. assume HV: V :e Ty.
  prove preimage_of X f V :e discrete_topology X.
  claim Hsub: preimage_of X f V c= X.
  { let x. assume Hx: x :e preimage_of X f V.
    exact (SepE1 X (fun u => apply_fun f u :e V) x Hx). }
  exact (discrete_open_all X (preimage_of X f V) Hsub).
Qed.

(** Helper: congruence for tuple coordinates **)
Theorem tuple_2_0_congr : forall a b c d:set, (a,b) = (c,d) -> a = c.
let a b c d.
assume Heq: (a,b) = (c,d).
prove a = c.
rewrite <- (tuple_2_0_eq a b) at 1.
rewrite <- (tuple_2_0_eq c d).
rewrite Heq.
reflexivity.
Qed.

Theorem tuple_2_1_congr : forall a b c d:set, (a,b) = (c,d) -> b = d.
let a b c d.
assume Heq: (a,b) = (c,d).
prove b = d.
rewrite <- (tuple_2_1_eq a b) at 1.
rewrite <- (tuple_2_1_eq c d).
rewrite Heq.
reflexivity.
Qed.

(** Helper: projections from membership in const_fun graphs **)
Theorem const_fun_pair_first : forall A x a y:set, (a,y) :e const_fun A x -> a :e A.
let A x a y.
assume H: (a,y) :e const_fun A x.
prove a :e A.
apply (ReplE_impred A (fun a0:set => (a0,x)) (a,y) H (a :e A)).
let a0. assume Ha0: a0 :e A.
assume Heq: (a,y) = (a0,x).
claim Ha: a = a0.
{ exact (tuple_2_0_congr a y a0 x Heq). }
rewrite Ha.
exact Ha0.
Qed.

Theorem const_fun_pair_second : forall A x a y:set, (a,y) :e const_fun A x -> y = x.
let A x a y.
assume H: (a,y) :e const_fun A x.
prove y = x.
apply (ReplE_impred A (fun a0:set => (a0,x)) (a,y) H (y = x)).
let a0. assume _: a0 :e A.
assume Heq: (a,y) = (a0,x).
exact (tuple_2_1_congr a y a0 x Heq).
Qed.

(** Helper: discrete topology is completely regular **)
Theorem discrete_completely_regular_space : forall X:set,
  completely_regular_space X (discrete_topology X).
let X.
prove completely_regular_space X (discrete_topology X).
claim HTx: topology_on X (discrete_topology X).
{ exact (discrete_topology_on X). }
prove topology_on X (discrete_topology X) /\
  forall x:set, x :e X ->
    forall F:set, closed_in X (discrete_topology X) F -> x /:e F ->
      exists f:set,
        continuous_map X (discrete_topology X) R R_standard_topology f /\
        apply_fun f x = 0 /\ forall y:set, y :e F -> apply_fun f y = 1.
apply andI.
- exact HTx.
- let x. assume HxX: x :e X.
  let F. assume HFcl: closed_in X (discrete_topology X) F.
  assume HxnotF: x /:e F.
  prove exists f:set,
    continuous_map X (discrete_topology X) R R_standard_topology f /\
    apply_fun f x = 0 /\ forall y:set, y :e F -> apply_fun f y = 1.
  claim HFsubX: F c= X.
  { exact (closed_in_subset X (discrete_topology X) F HFcl). }
  set A0 := X :\: F.
  claim HA0def: A0 = X :\: F.
  { reflexivity. }
  set f := (const_fun A0 0) :\/: (const_fun F 1).
  witness f.
  claim HRtop: topology_on R R_standard_topology.
  { exact R_standard_topology_is_topology. }
  claim H0R: 0 :e R.
  { exact real_0. }
  claim H1R: 1 :e R.
  { exact real_1. }

  claim Happ0: forall z:set, z :e X -> z /:e F -> apply_fun f z = 0.
  { let z. assume HzX: z :e X.
    assume HznotF: z /:e F.
    prove apply_fun f z = 0.
    claim HzA0: z :e A0.
    { rewrite HA0def.
      exact (setminusI X F z HzX HznotF). }
    claim Hpair0: (z,0) :e f.
    { apply binunionI1.
      exact (ReplI A0 (fun a0:set => (a0,0)) z HzA0). }
    claim Hzgraph: (z, apply_fun f z) :e f.
    { exact (Eps_i_ax (fun y:set => (z,y) :e f) 0 Hpair0). }
    apply (binunionE' (const_fun A0 0) (const_fun F 1) (z, apply_fun f z) (apply_fun f z = 0)).
    - assume Hleft: (z, apply_fun f z) :e const_fun A0 0.
      exact (const_fun_pair_second A0 0 z (apply_fun f z) Hleft).
    - assume Hright: (z, apply_fun f z) :e const_fun F 1.
      claim HzF: z :e F.
      { exact (const_fun_pair_first F 1 z (apply_fun f z) Hright). }
      apply FalseE.
      exact (HznotF HzF).
    - exact Hzgraph. }

  claim Happ1: forall z:set, z :e X -> z :e F -> apply_fun f z = 1.
  { let z. assume HzX: z :e X.
    assume HzF: z :e F.
    prove apply_fun f z = 1.
    claim Hpair1: (z,1) :e f.
    { apply binunionI2.
      exact (ReplI F (fun a0:set => (a0,1)) z HzF). }
    claim Hzgraph: (z, apply_fun f z) :e f.
    { exact (Eps_i_ax (fun y:set => (z,y) :e f) 1 Hpair1). }
    apply (binunionE' (const_fun A0 0) (const_fun F 1) (z, apply_fun f z) (apply_fun f z = 1)).
    - assume Hleft: (z, apply_fun f z) :e const_fun A0 0.
      claim HzA0: z :e A0.
      { exact (const_fun_pair_first A0 0 z (apply_fun f z) Hleft). }
      claim HznotF: z /:e F.
      { claim HzXF: z :e X :\: F.
        { rewrite <- HA0def.
          exact HzA0. }
        exact (setminusE2 X F z HzXF). }
      apply FalseE.
      exact (HznotF HzF).
    - assume Hright: (z, apply_fun f z) :e const_fun F 1.
      exact (const_fun_pair_second F 1 z (apply_fun f z) Hright).
    - exact Hzgraph. }

  claim Hfun: function_on f X R.
  { let z. assume HzX: z :e X.
    prove apply_fun f z :e R.
    apply (xm (z :e F)).
    - assume HzF: z :e F.
      claim Hz1: apply_fun f z = 1.
      { exact (Happ1 z HzX HzF). }
      rewrite Hz1.
      exact H1R.
    - assume HznotF: z /:e F.
      claim Hz0: apply_fun f z = 0.
      { exact (Happ0 z HzX HznotF). }
      rewrite Hz0.
      exact H0R. }

  claim Hcont: continuous_map X (discrete_topology X) R R_standard_topology f.
  { exact (continuous_from_discrete X R R_standard_topology f HRtop Hfun). }

  claim Hfx0: apply_fun f x = 0.
  { exact (Happ0 x HxX HxnotF). }
  claim HfF1: forall y:set, y :e F -> apply_fun f y = 1.
  { let y. assume HyF: y :e F.
    claim HyX: y :e X.
    { exact (HFsubX y HyF). }
    exact (Happ1 y HyX HyF). }

  apply andI.
  * prove continuous_map X (discrete_topology X) R R_standard_topology f /\ apply_fun f x = 0.
    apply andI.
    - exact Hcont.
    - exact Hfx0.
  * exact HfF1.
Qed.

(** Helper: discrete topology is Hausdorff **)
Theorem discrete_Hausdorff_space : forall X:set,
  Hausdorff_space X (discrete_topology X).
let X.
prove Hausdorff_space X (discrete_topology X).
claim HTx: topology_on X (discrete_topology X).
{ exact (discrete_topology_on X). }
prove topology_on X (discrete_topology X) /\
  forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
    exists U V:set, U :e discrete_topology X /\ V :e discrete_topology X /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
apply andI.
- exact HTx.
- let x1 x2.
  assume Hx1X: x1 :e X.
  assume Hx2X: x2 :e X.
  assume Hneq: x1 <> x2.
  prove exists U V:set,
    U :e discrete_topology X /\ V :e discrete_topology X /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
  witness {x1}.
  witness {x2}.
  claim HUopen: {x1} :e discrete_topology X.
  { claim Hsx1: {x1} c= X.
    { exact (singleton_subset x1 X Hx1X). }
    exact (discrete_open_all X {x1} Hsx1). }
  claim HVopen: {x2} :e discrete_topology X.
  { claim Hsx2: {x2} c= X.
    { exact (singleton_subset x2 X Hx2X). }
    exact (discrete_open_all X {x2} Hsx2). }
  claim Hdisj: {x1} :/\: {x2} = Empty.
  { apply Empty_Subq_eq.
    let z. assume Hz: z :e {x1} :/\: {x2}.
    prove z :e Empty.
    claim Hz1: z :e {x1}.
    { exact (binintersectE1 {x1} {x2} z Hz). }
    claim Hz2: z :e {x2}.
    { exact (binintersectE2 {x1} {x2} z Hz). }
    claim Hzx1: z = x1.
    { exact (SingE x1 z Hz1). }
    claim Hzx2: z = x2.
    { exact (SingE x2 z Hz2). }
    claim Hx1x2: x1 = x2.
    { rewrite <- Hzx1.
      rewrite <- Hzx2.
      reflexivity. }
    apply FalseE.
    exact (Hneq Hx1x2). }
  apply and5I.
  - exact HUopen.
  - exact HVopen.
  - exact (SingI x1).
  - exact (SingI x2).
  - exact Hdisj.
Qed.

(** from 33 Definition: Tychonoff space **) 
(** LATEX VERSION: Tychonoff = completely regular and Hausdorff. **)
Definition Tychonoff_space : set -> set -> prop := fun X Tx =>
  completely_regular_space X Tx /\ Hausdorff_space X Tx.

(** from 33 Theorem 33.2: subspaces/products of completely regular spaces **) 
(** LATEX VERSION: Subspaces and products of completely regular spaces remain completely regular. **)
Theorem completely_regular_subspace_product : forall X Tx:set,
  topology_on X Tx ->
  (forall Y:set, Y c= X -> completely_regular_space X Tx -> completely_regular_space Y (subspace_topology X Tx Y)) /\
  (forall I Xi:set, completely_regular_spaces_family I Xi -> completely_regular_space (product_space I Xi) (product_topology_full I Xi)).
let X Tx.
assume HTx: topology_on X Tx.
prove (forall Y:set, Y c= X -> completely_regular_space X Tx -> completely_regular_space Y (subspace_topology X Tx Y)) /\
  (forall I Xi:set, completely_regular_spaces_family I Xi -> completely_regular_space (product_space I Xi) (product_topology_full I Xi)).
apply andI.
- (** subspaces **)
  let Y. assume HYsub: Y c= X.
  assume HcrX: completely_regular_space X Tx.
  prove completely_regular_space Y (subspace_topology X Tx Y).
  claim HsepX:
    forall x:set, x :e X ->
      forall F:set, closed_in X Tx F -> x /:e F ->
        exists f:set, continuous_map X Tx R R_standard_topology f /\
          apply_fun f x = 0 /\ forall y:set, y :e F -> apply_fun f y = 1.
  { exact (andER (topology_on X Tx)
                 (forall x:set, x :e X ->
                   forall F:set, closed_in X Tx F -> x /:e F ->
                     exists f:set,
                       continuous_map X Tx R R_standard_topology f /\
                       apply_fun f x = 0 /\ forall y:set, y :e F -> apply_fun f y = 1)
                 HcrX). }
  claim HTsub: topology_on Y (subspace_topology X Tx Y).
  { exact (subspace_topology_is_topology X Tx Y HTx HYsub). }
  prove topology_on Y (subspace_topology X Tx Y) /\
    forall y:set, y :e Y ->
      forall F:set, closed_in Y (subspace_topology X Tx Y) F -> y /:e F ->
        exists f:set,
          continuous_map Y (subspace_topology X Tx Y) R R_standard_topology f /\
          apply_fun f y = 0 /\ forall z:set, z :e F -> apply_fun f z = 1.
  apply andI.
  * exact HTsub.
  * let y. assume HyY: y :e Y.
    let F. assume HFcl: closed_in Y (subspace_topology X Tx Y) F.
    assume HynotF: y /:e F.
    prove exists f:set,
      continuous_map Y (subspace_topology X Tx Y) R R_standard_topology f /\
      apply_fun f y = 0 /\ forall z:set, z :e F -> apply_fun f z = 1.
    claim HexC: exists C:set, closed_in X Tx C /\ F = C :/\: Y.
    { exact (iffEL (closed_in Y (subspace_topology X Tx Y) F)
                   (exists C:set, closed_in X Tx C /\ F = C :/\: Y)
                   (closed_in_subspace_iff_intersection X Tx Y F HTx HYsub)
                   HFcl). }
    apply HexC.
    let C. assume HCpair.
    claim HCcl: closed_in X Tx C.
    { exact (andEL (closed_in X Tx C) (F = C :/\: Y) HCpair). }
    claim HFeq: F = C :/\: Y.
    { exact (andER (closed_in X Tx C) (F = C :/\: Y) HCpair). }
    claim HyX: y :e X.
    { exact (HYsub y HyY). }
    claim HyNotC: y /:e C.
    { assume HyC: y :e C.
      claim HyCY: y :e C :/\: Y.
      { exact (binintersectI C Y y HyC HyY). }
      claim HyF: y :e F.
      { rewrite HFeq.
        exact HyCY. }
      exact (HynotF HyF). }
    claim Hexf: exists f:set,
      continuous_map X Tx R R_standard_topology f /\
      apply_fun f y = 0 /\ forall z:set, z :e C -> apply_fun f z = 1.
    { exact (HsepX y HyX C HCcl HyNotC). }
    apply Hexf.
    let f. assume Hfprop.
    witness f.
    claim Hfleft: continuous_map X Tx R R_standard_topology f /\ apply_fun f y = 0.
    { exact (andEL (continuous_map X Tx R R_standard_topology f /\ apply_fun f y = 0)
                   (forall z:set, z :e C -> apply_fun f z = 1)
                   Hfprop). }
    claim Hfcont: continuous_map X Tx R R_standard_topology f.
    { exact (andEL (continuous_map X Tx R R_standard_topology f) (apply_fun f y = 0) Hfleft). }
    claim Hfy0: apply_fun f y = 0.
    { exact (andER (continuous_map X Tx R R_standard_topology f) (apply_fun f y = 0) Hfleft). }
    claim HfC: forall z:set, z :e C -> apply_fun f z = 1.
    { exact (andER (continuous_map X Tx R R_standard_topology f /\ apply_fun f y = 0)
                   (forall z:set, z :e C -> apply_fun f z = 1)
                   Hfprop). }
    apply andI.
    + prove continuous_map Y (subspace_topology X Tx Y) R R_standard_topology f /\ apply_fun f y = 0.
      apply andI.
      - exact (continuous_on_subspace X Tx R R_standard_topology f Y HTx HYsub Hfcont).
      - exact Hfy0.
    + let z. assume HzF: z :e F.
      prove apply_fun f z = 1.
      claim HzCY: z :e C :/\: Y.
      { rewrite <- HFeq.
        exact HzF. }
      claim HzC: z :e C.
      { exact (binintersectE1 C Y z HzCY). }
      exact (HfC z HzC).
- (** products **)
  admit. (** use component functions and product topology **)
Qed.

(** from 33 Example 1: products giving completely regular but not normal spaces **) 
(** LATEX VERSION: Sorgenfrey plane is completely regular but not normal. **)
Theorem Sorgenfrey_plane_completely_regular_not_normal :
  completely_regular_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology /\
  ~ normal_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology.
prove completely_regular_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology /\
  ~ normal_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology.
apply andI.
- admit. (** product of completely regular spaces is completely regular **)
- claim Hnot: ~ normal_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology.
  { exact (andER (regular_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology)
                 (~ normal_space (setprod Sorgenfrey_line Sorgenfrey_line) Sorgenfrey_plane_topology)
                 (Sorgenfrey_plane_not_normal)). }
  exact Hnot.
Qed.

(** from 33 Example 1 cont.: SOmega x SbarOmega completely regular not normal **)
(** LATEX VERSION: Another example of completely regular but non-normal product. **)
(** FIXED: Same issue - topology must match the space S_Omega  Sbar_Omega, not R^{S_Omega  Sbar_Omega}.
    Was: topology on R^{S_Omega  Sbar_Omega} applied to space S_Omega  Sbar_Omega (mismatch!)
    Now: product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology **)
Theorem SOmega_SbarOmega_completely_regular_not_normal :
  completely_regular_space (setprod S_Omega Sbar_Omega) (product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology) /\
  ~ normal_space (setprod S_Omega Sbar_Omega) (product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology).
prove completely_regular_space (setprod S_Omega Sbar_Omega) (product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology) /\
  ~ normal_space (setprod S_Omega Sbar_Omega) (product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology).
apply andI.
- admit. (** product of completely regular spaces is completely regular **)
- claim Hnot:
    ~ normal_space (setprod S_Omega Sbar_Omega) (product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology).
  { exact (andER (normal_space S_Omega SOmega_topology /\ normal_space Sbar_Omega SbarOmega_topology)
                 (~ normal_space (setprod S_Omega Sbar_Omega) (product_topology S_Omega SOmega_topology Sbar_Omega SbarOmega_topology))
                 (SOmega_SbarOmega_not_normal)). }
  exact Hnot.
Qed.

(** from 34 Theorem 34.1: Urysohn metrization theorem **) 
(** LATEX VERSION: Regular second-countable spaces are metrizable (Urysohn). **)
Theorem Urysohn_metrization_theorem : forall X Tx:set,
  regular_space X Tx -> second_countable_space X Tx -> exists d:set, metric_on X d /\ metric_topology X d = Tx.
let X Tx.
assume Hreg: regular_space X Tx.
assume Hscc: second_countable_space X Tx.
prove exists d:set, metric_on X d /\ metric_topology X d = Tx.
admit. (** embed into Hilbert cube via countable family of Urysohn functions; induce metric from product **)
Qed.

(** from 34 Theorem 34.2: Imbedding via separating family of functions **) 
(** LATEX VERSION: Embedding into product of reals via separating family of continuous functions. **)
Theorem embedding_via_functions : forall X Tx:set,
  topology_on X Tx -> one_point_sets_closed X Tx ->
  forall F J:set, separating_family_of_functions X Tx F J ->
    exists Fmap:set, embedding_of X Tx (power_real J) (product_topology_full J (const_space_family J R R_standard_topology)) Fmap.
let X Tx.
assume HTx: topology_on X Tx.
assume Hclosed: one_point_sets_closed X Tx.
let F J.
assume Hsep: separating_family_of_functions X Tx F J.
prove exists Fmap:set, embedding_of X Tx (power_real J) (product_topology_full J (const_space_family J R R_standard_topology)) Fmap.
admit. (** evaluation map Fmap(x) = (f_j(x))_jJ separates points; gives embedding into product
        aby: conj_myprob_10141_1_20251124_102528 separation_subspace_limit_points ReplSepE . **)
Qed.

(** from 34 Corollary 34.3: completely regular iff embeds in [0,1]^J **) 
(** LATEX VERSION: Completely regular iff embeds into a Tychonoff cube [0,1]^J. **)
Theorem completely_regular_iff_embeds_in_cube : forall X Tx:set,
  (completely_regular_space X Tx <->
    exists J:set, exists Fmap:set, embedding_of X Tx (unit_interval_power J) (product_topology_full J (const_space_family J unit_interval (subspace_topology R R_standard_topology unit_interval))) Fmap).
let X Tx.
prove (completely_regular_space X Tx <->
    exists J:set, exists Fmap:set, embedding_of X Tx (unit_interval_power J) (product_topology_full J (const_space_family J unit_interval (subspace_topology R R_standard_topology unit_interval))) Fmap).
admit. (** forward: use separating family to build embedding; reverse: subspace of product inherits complete regularity **)
Qed.

(** from 35 Theorem 35.1: Tietze extension theorem **) 
(** LATEX VERSION: Tietze extension theorem for normal spaces and intervals. **)
Theorem Tietze_extension_interval : forall X Tx A a b f:set,
  normal_space X Tx -> closed_in X Tx A ->
  continuous_map A (subspace_topology X Tx A) (closed_interval a b) (order_topology (closed_interval a b)) f ->
  exists g:set, continuous_map X Tx (closed_interval a b) (order_topology (closed_interval a b)) g /\
    (forall x:set, x :e A -> apply_fun g x = apply_fun f x).
let X Tx A a b f.
assume Hnorm: normal_space X Tx.
assume HA: closed_in X Tx A.
assume Hf: continuous_map A (subspace_topology X Tx A) (closed_interval a b) (order_topology (closed_interval a b)) f.
prove exists g:set, continuous_map X Tx (closed_interval a b) (order_topology (closed_interval a b)) g /\
    (forall x:set, x :e A -> apply_fun g x = apply_fun f x).
admit. (** iteratively extend by 1/3 steps using Urysohn; limit gives continuous extension
        aby: binintersectf normal_spacef conj_myprob_10159_1_20251124_102542 Subq_def Subq_5Fbinunion_5Feq ex17_7_counterexample_union_closure order_topologyf Rlt_def closed_intervalf prop_ext_2 . **)
Qed.

Theorem Tietze_extension_real : forall X Tx A f:set,
  normal_space X Tx -> closed_in X Tx A ->
  continuous_map A (subspace_topology X Tx A) R R_standard_topology f ->
  exists g:set, continuous_map X Tx R R_standard_topology g /\
    (forall x:set, x :e A -> apply_fun g x = apply_fun f x).
let X Tx A f.
assume Hnorm: normal_space X Tx.
assume HA: closed_in X Tx A.
assume Hf: continuous_map A (subspace_topology X Tx A) R R_standard_topology f.
prove exists g:set, continuous_map X Tx R R_standard_topology g /\
    (forall x:set, x :e A -> apply_fun g x = apply_fun f x).
admit. (** use Tietze extension on bounded intervals; compose with homeomorphism R  (-1,1)
        aby: binintersectf normal_spacef conj_myprob_10167_1_20251124_102606 Subq_def Subq_5Fbinunion_5Feq ex17_7_counterexample_union_closure prop_ext_2 . **)
Qed.

(** from 36 Definition: m-manifold **) 
(** LATEX VERSION: An m-manifold is Hausdorff and second countable (dimension suppressed here). **)
Definition m_manifold : set -> set -> prop := fun X Tx => Hausdorff_space X Tx /\ second_countable_space X Tx.

(** from 36 Definition: partition of unity dominated by a cover **) 
(** LATEX VERSION: Partition of unity subordinate to an open cover (dominated). **)
Definition partition_of_unity_dominated : set -> set -> set -> prop := fun X Tx U =>
  topology_on X Tx /\ open_cover X Tx U /\
  exists P:set,
    P c= function_space X R /\
    (forall f:set, f :e P -> continuous_map X Tx R R_standard_topology f) /\
    (forall x:set, x :e X ->
      exists F:set, finite F /\ F c= P /\
        (forall f:set, f :e P -> apply_fun f x <> 0 -> f :e F) /\
        (forall f:set, f :e F ->
           exists u:set, u :e U /\ {y :e X|apply_fun f y <> 0} c= u)).

(** from 36 Theorem 36.1: existence of finite partition of unity on normal space **) 
(** LATEX VERSION: On a normal space, every finite open cover has a partition of unity subordinate to it. **)
Theorem finite_partition_of_unity_exists : forall X Tx U:set,
  normal_space X Tx -> finite U -> open_cover X Tx U -> exists P:set, partition_of_unity_dominated X Tx U.
let X Tx U.
assume Hnorm: normal_space X Tx.
assume Hfin: finite U.
assume Hcover: open_cover X Tx U.
prove exists P:set, partition_of_unity_dominated X Tx U.
admit. (** use normality to shrink cover; construct Urysohn functions with support in shrunken sets; normalize sum **)
Qed.

(** from 36 Theorem: compact manifold embeds in Euclidean space **) 
(** LATEX VERSION: Any compact manifold embeds in some Euclidean space. **)
Theorem compact_manifold_embeds_in_Euclidean : forall X Tx:set,
  m_manifold X Tx -> compact_space X Tx -> exists N:set, exists e:set,
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e.
let X Tx.
assume Hman: m_manifold X Tx.
assume Hcomp: compact_space X Tx.
prove exists N:set, exists e:set,
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e.
admit. (** Whitney embedding theorem: use local charts and partition of unity to embed into R^(2m+1)
        aby: conj_myprob_10194_1_20251124_092918 binintersectf Hausdorff_5Fspace_def m_manifoldf In_5Fno2cycle Hausdorff_5Fseparate_5Fpoint_5Fcompact_5Fset . **)
Qed.

(** from 37 Theorem: Tychonoff theorem **)
(** LATEX VERSION: Arbitrary product of compact spaces is compact (Tychonoff). **)
(** FIXED: Quantifier scope error - i should be restricted to index set.
    Was: forall i:set, compact_space ... (i ranges over ALL sets!)
    Now: forall i:set, i :e I -> compact_space ... (i restricted to index set I)
    Only need component spaces indexed by I to be compact. **)
Theorem Tychonoff_theorem : forall I Xi:set,
  (forall i:set, i :e I -> compact_space (product_component Xi i) (product_component_topology Xi i)) ->
  compact_space (product_space I Xi) (product_topology_full I Xi).
let I Xi.
assume Hcomp: forall i:set, i :e I -> compact_space (product_component Xi i) (product_component_topology Xi i).
prove compact_space (product_space I Xi) (product_topology_full I Xi).
admit. (** use Alexander subbasis theorem; canonical projections compact; finite subcover from finitely many coordinates **)
Qed.

(** from 38 Definition: Stone-Cech compactification and universal property **) 
(** LATEX VERSION: Stoneech compactification X defined via universal property; placeholder representation. **)
Definition Stone_Cech_compactification : set -> set -> set := fun X Tx =>
  {p :e Power (Power (Power X)) |
    exists Y Ty e:set,
      p = setprod (setprod Y Ty) e /\
      compact_space Y Ty /\ Hausdorff_space Y Ty /\ embedding_of X Tx Y Ty e}.
Theorem Stone_Cech_universal_property : forall X Tx:set,
  Tychonoff_space X Tx ->
  compact_space (Stone_Cech_compactification X Tx) (Stone_Cech_compactification X Tx) /\
  Hausdorff_space (Stone_Cech_compactification X Tx) (Stone_Cech_compactification X Tx).
let X Tx.
assume HT: Tychonoff_space X Tx.
prove compact_space (Stone_Cech_compactification X Tx) (Stone_Cech_compactification X Tx) /\
  Hausdorff_space (Stone_Cech_compactification X Tx) (Stone_Cech_compactification X Tx).
admit. (** Stone-ech compactification via closure in [0,1]^C(X,[0,1]); Tychonoff theorem gives compactness; product Hausdorff
        aby: completely_regular_spacef binintersectf Hausdorff_5Fspace_def Tychonoff_5Fspace_def conj_myprob_10216_1_20251124_093005 In_5Fno2cycle ex17_7_counterexample_union_closure not_all_ex_demorgan_i ex17_1_topology_from_closed_sets ex17_3_product_of_closed_sets_closed ex17_13_diagonal_closed_iff_Hausdorff . **)
Qed.

(** from 39 Definition: locally finite family and refinement **) 
(** LATEX VERSION: Refinement and locally finite families/bases (NagataSmirnov context). **)
Definition refine_of : set -> set -> prop := fun V U =>
  forall v:set, v :e V -> exists u:set, u :e U /\ v c= u.
Definition locally_finite_family : set -> set -> set -> prop := fun X Tx F =>
  topology_on X Tx /\
  forall x:set, x :e X ->
    exists N:set, N :e Tx /\ x :e N /\
      exists S:set, finite S /\ S c= F /\
        forall A:set, A :e F -> A :/\: N <> Empty -> A :e S.
Definition locally_finite_basis : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  exists B:set, basis_on X B /\ locally_finite_family X Tx B.
Definition sigma_locally_finite_basis : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  exists Fams:set, countable_set Fams /\
    Fams c= Power (Power X) /\
    (forall F:set, F :e Fams -> locally_finite_family X Tx F) /\
    basis_on X (Union Fams) /\
    forall b:set, b :e Union Fams -> b :e Tx.

(** from 40 Nagata-Smirnov metrization theorem **) 
(** LATEX VERSION: NagataSmirnov: A regular space with a -locally-finite basis is metrizable. **)
Theorem Nagata_Smirnov_metrization : forall X Tx:set,
  regular_space X Tx -> sigma_locally_finite_basis X Tx -> metrizable X Tx.
let X Tx.
assume Hreg: regular_space X Tx.
assume Hbasis: sigma_locally_finite_basis X Tx.
prove metrizable X Tx.
admit. (** construct metric using locally finite basis; distance via covering number from countable family **)
Qed.

(** from 41 Definition: paracompact space **) 
(** LATEX VERSION: Paracompact = every open cover has a locally finite open refinement. **)
Definition paracompact_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall U:set, open_cover X Tx U ->
    exists V:set, open_cover X Tx V /\ locally_finite_family X Tx V /\ refine_of V U.

(** from 41 Theorem: existence of locally finite refinements **) 
(** LATEX VERSION: Any paracompact space admits a locally finite open refinement of every open cover. **)
Theorem locally_finite_refinement : forall X Tx U:set,
  paracompact_space X Tx -> open_cover X Tx U -> exists V:set, open_cover X Tx V /\ locally_finite_family X Tx V.
let X Tx U.
assume Hpara: paracompact_space X Tx.
assume Hcover: open_cover X Tx U.
prove exists V:set, open_cover X Tx V /\ locally_finite_family X Tx V.
(** Extract the forall from paracompact definition **)
claim Hforall: forall U0:set, open_cover X Tx U0 ->
    exists V:set, open_cover X Tx V /\ locally_finite_family X Tx V /\ refine_of V U0.
{ exact (andER (topology_on X Tx)
               (forall U0:set, open_cover X Tx U0 ->
                  exists V:set, open_cover X Tx V /\ locally_finite_family X Tx V /\ refine_of V U0)
               Hpara). }
(** Apply to U and extract V **)
claim Hexists: exists V:set, open_cover X Tx V /\ locally_finite_family X Tx V /\ refine_of V U.
{ exact (Hforall U Hcover). }
apply Hexists.
let V. assume HV.
witness V.
(** Extract just the first two conjuncts, dropping refine_of **)
exact (andEL (open_cover X Tx V /\ locally_finite_family X Tx V) (refine_of V U) HV).
Qed.

(** from 41 Theorem: paracompact Hausdorff implies normal **) 
(** LATEX VERSION: Paracompact Hausdorff spaces are normal. **)
Theorem paracompact_Hausdorff_normal : forall X Tx:set,
  paracompact_space X Tx -> Hausdorff_space X Tx -> normal_space X Tx.
let X Tx.
assume Hpara: paracompact_space X Tx.
assume HH: Hausdorff_space X Tx.
prove normal_space X Tx.
admit. (** use locally finite refinement to separate closed sets; shrinking lemma gives nested opens
        aby: binintersectf Hausdorff_5Fspace_def conj_myprob_10265_1_20251124_093116 In_5Fno2cycle ReplI Sing_5Ffinite not_ex_all_demorgan_i ex17_7_counterexample_union_closure finite_sets_closed_in_Hausdorff normal_spacef . **)
Qed.

(** from 42 Smirnov metrization theorem **) 
(** LATEX VERSION: Smirnov metrization: regular spaces with a locally finite basis are metrizable. **)
Theorem Smirnov_metrization : forall X Tx:set,
  regular_space X Tx -> locally_finite_basis X Tx -> metrizable X Tx.
let X Tx.
assume Hreg: regular_space X Tx.
assume Hbasis: locally_finite_basis X Tx.
prove metrizable X Tx.
admit. (** similar to Nagata-Smirnov; locally finite basis gives -locally-finite structure by partitioning **)
Qed.

(** helper: Cauchy sequence in a metric space **)
(** LATEX VERSION: Cauchy sequence definition (metric). **)
(** FIXED: Cauchy sequence must be a function (uses apply_fun seq m), not just a subset.
    Was: seq c= X (any subset)
    Now: sequence_on seq X (function omega  X)
    ALSO FIXED: N c= omega condition is always true, doesn't relate N to m,n.
    Was: N c= omega (always true for N :e omega, doesn't constrain m,n!)
    Now: N c= m /\ N c= n (means mN and nN using von Neumann ordering)
    ALSO FIXED: Metric application syntax and missing positive epsilon constraint.
    Was: Rlt (d (apply_fun seq m) (apply_fun seq n)) eps with eps :e R
    Now: Rlt (apply_fun d (apply_fun seq m, apply_fun seq n)) eps with Rlt 0 eps **)
Definition cauchy_sequence : set -> set -> set -> prop := fun X d seq =>
  metric_on X d /\ sequence_on seq X /\
  forall eps:set, eps :e R /\ Rlt 0 eps ->
    exists N:set, N :e omega /\
      forall m n:set, m :e omega -> n :e omega -> N c= m -> N c= n ->
        Rlt (apply_fun d (apply_fun seq m, apply_fun seq n)) eps.

(** Helper: cauchy_sequence plus totality of the metric graph on XX **)
Definition cauchy_sequence_total : set -> set -> set -> prop := fun X d seq =>
  metric_on_total X d /\ sequence_on seq X /\
  forall eps:set, eps :e R /\ Rlt 0 eps ->
    exists N:set, N :e omega /\
      forall m n:set, m :e omega -> n :e omega -> N c= m -> N c= n ->
        Rlt (apply_fun d (apply_fun seq m, apply_fun seq n)) eps.

Theorem cauchy_sequence_total_imp : forall X d seq:set,
  cauchy_sequence_total X d seq -> cauchy_sequence X d seq.
let X d seq. assume H.
claim Hleft: metric_on_total X d /\ sequence_on seq X.
{ exact (andEL (metric_on_total X d /\ sequence_on seq X)
               (forall eps:set, eps :e R /\ Rlt 0 eps ->
                 exists N:set, N :e omega /\
                   forall m n:set, m :e omega -> n :e omega -> N c= m -> N c= n ->
                     Rlt (apply_fun d (apply_fun seq m, apply_fun seq n)) eps)
               H). }
claim Hmt: metric_on_total X d.
{ exact (andEL (metric_on_total X d) (sequence_on seq X) Hleft). }
claim Hseq: sequence_on seq X.
{ exact (andER (metric_on_total X d) (sequence_on seq X) Hleft). }
claim Htail: forall eps:set, eps :e R /\ Rlt 0 eps ->
  exists N:set, N :e omega /\
    forall m n:set, m :e omega -> n :e omega -> N c= m -> N c= n ->
      Rlt (apply_fun d (apply_fun seq m, apply_fun seq n)) eps.
{ exact (andER (metric_on_total X d /\ sequence_on seq X)
               (forall eps:set, eps :e R /\ Rlt 0 eps ->
                 exists N:set, N :e omega /\
                   forall m n:set, m :e omega -> n :e omega -> N c= m -> N c= n ->
                     Rlt (apply_fun d (apply_fun seq m, apply_fun seq n)) eps)
               H). }
prove metric_on X d /\ sequence_on seq X /\
  forall eps:set, eps :e R /\ Rlt 0 eps ->
    exists N:set, N :e omega /\
      forall m n:set, m :e omega -> n :e omega -> N c= m -> N c= n ->
        Rlt (apply_fun d (apply_fun seq m, apply_fun seq n)) eps.
apply andI.
- apply andI.
  + exact (metric_on_total_imp_metric_on X d Hmt).
  + exact Hseq.
- exact Htail.
Qed.

(** from 43 Definition: complete metric space **) 
(** LATEX VERSION: Completeness: every Cauchy sequence converges. **)
(** FIXED: Same issue - seq must be a function, not just a subset.
    cauchy_sequence now requires sequence_on seq X, so seq c= X is redundant and wrong. **)
Definition complete_metric_space : set -> set -> prop := fun X d =>
  metric_on X d /\
  forall seq:set, sequence_on seq X -> cauchy_sequence X d seq ->
    exists x:set, converges_to X (metric_topology X d) seq x.

(** Helper: complete_metric_space plus totality of the metric graph on XX **)
Definition complete_metric_space_total : set -> set -> prop := fun X d =>
  metric_on_total X d /\
  forall seq:set, sequence_on seq X -> cauchy_sequence_total X d seq ->
    exists x:set, converges_to X (metric_topology X d) seq x.
(** FIXED: Wrong syntax for ordered pairs in metric definition.
    Was: p = setprod (setprod x y) 0 (trying to use setprod for tuples - wrong!)
    Now: Proper ordered pair notation for function representation
    Discrete metric: d(x,y) = 0 if x=y, 1 if xy
    Using famunion to construct over all pairs **)
Definition discrete_metric : set -> set := fun X =>
  famunion X (fun x => {((x,y), If_i (x = y) 0 1) | y :e X}).
(** helper: placeholder metric on euclidean_space n **) 
Definition euclidean_metric : set -> set := fun n => discrete_metric (euclidean_space n).

(** helper: bounded product metric on R^omega **) 
(** LATEX VERSION: Bounded product metric on R^ (placeholder). **)
Definition bounded_product_metric : set -> set := fun J => discrete_metric (power_real J).

(** from 43 Lemma 43.1: Cauchy with convergent subsequence converges **) 
(** LATEX VERSION: In a metric space, a Cauchy sequence with a convergent subsequence converges to the same limit. **)
Theorem Cauchy_with_convergent_subsequence_converges : forall X d seq x:set,
  metric_on X d -> cauchy_sequence X d seq ->
  (exists subseq:set, subseq c= seq /\ converges_to X (metric_topology X d) subseq x) ->
  converges_to X (metric_topology X d) seq x.
let X d seq x.
assume Hd: metric_on X d.
assume Hcauchy: cauchy_sequence X d seq.
assume Hsub: exists subseq:set, subseq c= seq /\ converges_to X (metric_topology X d) subseq x.
prove converges_to X (metric_topology X d) seq x.
admit. (** for eps>0, use Cauchy to get N; use subseq convergence to get N; for n>max(N,N), d(seq_n,x) < eps **)
Qed.

(** from 43 Theorem 43.2: Euclidean space is complete **) 
(** LATEX VERSION: Euclidean spaces are complete metric spaces. **)
Theorem Euclidean_space_complete : forall k:set,
  complete_metric_space (euclidean_space k) (euclidean_metric k).
let k.
prove complete_metric_space (euclidean_space k) (euclidean_metric k).
admit. (** Cauchy in R^k is Cauchy coordinatewise; R complete; product of complete is complete **)
Qed.

(** from 43 Lemma 43.3: product convergence via projections **) 
(** LATEX VERSION: Convergence in a product metric topology iff coordinatewise convergence. **)
Theorem product_sequence_convergence_iff_coordinates : forall X J:set,
  X = product_space J (const_space_family J R R_standard_topology) ->
  forall seq x:set,
    converges_to X (product_topology_full J (const_space_family J R R_standard_topology)) seq x <->
    (forall j:set, j :e J ->
    converges_to (product_component (const_space_family J R R_standard_topology) j)
                   (product_component_topology (const_space_family J R R_standard_topology) j)
                   (Repl seq (fun s => apply_fun s j))
                   (apply_fun x j)).
let X J.
assume HX: X = product_space J (const_space_family J R R_standard_topology).
let seq x.
prove converges_to X (product_topology_full J (const_space_family J R R_standard_topology)) seq x <->
    (forall j:set, j :e J ->
    converges_to (product_component (const_space_family J R R_standard_topology) j)
                   (product_component_topology (const_space_family J R R_standard_topology) j)
                   (Repl seq (fun s => apply_fun s j))
                   (apply_fun x j)).
admit. (** convergence in product topology iff projection _j(seq)  _j(x) for all j; use subbasis characterization **)
Qed.

(** from 43 Theorem 43.4: complete metric on R^omega **) 
(** LATEX VERSION: The bounded product metric makes R^ complete. **)
Theorem product_Romega_complete : complete_metric_space (power_real omega) (bounded_product_metric omega).
prove complete_metric_space (power_real omega) (bounded_product_metric omega).
admit. (** Cauchy in product metric means Cauchy coordinatewise; R complete; bounded metric ensures convergence **)
Qed.

(** from 44 Theorem: space-filling curve existence **) 
(** LATEX VERSION: Existence of a continuous surjection from [0,1] onto the unit square (Peano curve). **)
Definition unit_square : set := setprod unit_interval unit_interval.
Definition unit_square_topology : set := product_topology unit_interval R_standard_topology unit_interval R_standard_topology.
Theorem space_filling_curve : exists f:set, continuous_map unit_interval R_standard_topology unit_square unit_square_topology f.
prove exists f:set, continuous_map unit_interval R_standard_topology unit_square unit_square_topology f.
admit. (** construct Peano curve via iterative midpoint subdivision; limit of continuous approximations is continuous **)
Qed.

(** from 45 Definition: sequential compactness **)
(** LATEX VERSION: Sequentially compact: every sequence has a convergent subsequence/limit in X. **)
(** FIXED: Definition was wrong - said "every sequence converges" instead of
    "every sequence has a convergent subsequence".
    Was: forall seq, sequence_on seq X -> exists x, converges_to X Tx seq x
         (every sequence converges - would make X trivial!)
    Now: forall seq, sequence_on seq X -> exists subseq x, subseq c= seq /\ converges_to X Tx subseq x
         (every sequence has a convergent subsequence) **)
Definition sequentially_compact : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall seq:set, sequence_on seq X ->
    exists subseq:set, exists x:set, subseq c= seq /\ converges_to X Tx subseq x.

(** from 45 Theorem: compactness in metric spaces equivalences **) 
(** LATEX VERSION: In metric spaces, compact  sequentially compact. **)
Theorem compact_metric_equivalences : forall X d:set,
  metric_on X d ->
  (compact_space X (metric_topology X d) <-> sequentially_compact X (metric_topology X d)).
let X d.
assume Hd: metric_on X d.
prove compact_space X (metric_topology X d) <-> sequentially_compact X (metric_topology X d).
admit. (** compactseq compact: Lebesgue number lemma; seq compactcompact: construct finite cover from seq compactness **)
Qed.

(** from 46 Definition: pointwise and compact convergence topologies **) 
(** LATEX VERSION: Topologies of pointwise and compact convergence on function spaces (placeholders). **)
Definition pointwise_convergence_topology : set -> set -> set -> set -> set :=
  fun X Tx Y Ty => generated_topology (function_space X Y) Empty.
Definition compact_convergence_topology : set -> set -> set -> set -> set :=
  fun X Tx Y Ty => generated_topology (function_space X Y) Empty.
(** FIXED: Quantifier structure was wrong - required ALL f to map U into V, not just those with f(x) in V.
    Was: forall V, (exists f0 with f0(x)  V) -> exists U such that (forall f  F, f(U)  V)
         This says: if ANY function maps x into V, then ALL functions map U into V (too strong!)
    Now: forall V, exists U such that (forall f  F, f(x)  V -> f(U)  V)
         This is correct equicontinuity: U works uniformly for all f that map x into V. **)
Definition equicontinuous_family : set -> set -> set -> set -> set -> prop :=
  fun X Tx Y Ty F =>
    topology_on X Tx /\ topology_on Y Ty /\ F c= function_space X Y /\
    forall x:set, x :e X ->
      forall V:set, V :e Ty ->
        exists U:set, U :e Tx /\ x :e U /\
          forall f:set, f :e F -> apply_fun f x :e V ->
            forall y:set, y :e U -> apply_fun f y :e V.
Definition relatively_compact_in_compact_convergence : set -> set -> set -> set -> set -> prop :=
  fun X Tx Y Ty F =>
    topology_on X Tx /\ topology_on Y Ty /\ F c= function_space X Y /\
    compact_space F (compact_convergence_topology X Tx Y Ty).

(** from 47 Ascoli theorem **) 
(** LATEX VERSION: AscoliArzel theorem (placeholder statement) on compact convergence. **)
Theorem Ascoli_theorem : forall X Tx Y Ty F:set,
  compact_space X Tx -> Hausdorff_space Y Ty ->
  equicontinuous_family X Tx Y Ty F -> relatively_compact_in_compact_convergence X Tx Y Ty F.
let X Tx Y Ty F.
assume Hcomp: compact_space X Tx.
assume HH: Hausdorff_space Y Ty.
assume Heq: equicontinuous_family X Tx Y Ty F.
prove relatively_compact_in_compact_convergence X Tx Y Ty F.
admit. (** equicontinuity + compactness gives uniform convergence bounds; diagonal argument extracts convergent subsequence
        aby: Hausdorff_5Fspace_def conj_myprob_10385_1_20251124_032135 In_5Fno2cycle not_ex_all_demorgan_i equicontinuous_familyf relatively_compact_in_compact_convergencef . **)
Qed.

(** helper: intersection over a family within a universe X **) 
(** LATEX VERSION: Intersection_over_family X Fam collects points lying in every member of Fam. **)
Definition intersection_over_family : set -> set -> set :=
  fun X Fam => {x :e X|forall U:set, U :e Fam -> x :e U}.

(** from 48 Definition: Baire space **)
(** LATEX VERSION: A Baire space is one where countable intersections of dense open sets are dense. **)
Definition Baire_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall U:set,
    U c= Tx -> countable_set U ->
    (forall u:set, u :e U -> u :e Tx /\ dense_in u X Tx) ->
    dense_in (intersection_over_family X U) X Tx.

(** from 48 Lemma 48.1: dense G_delta characterization of Baire space **)
(** LATEX VERSION: Equivalent dense G_ characterization of Baire spaces. **)
(** NOTE: This theorem is now trivial since the definition was corrected to take both X and Tx. **)
Theorem Baire_space_dense_Gdelta : forall X Tx:set,
  Baire_space X Tx <-> Baire_space X Tx.
let X Tx.
apply iffI.
- assume H. exact H.
- assume H. exact H.
Qed.

(** from 48 Theorem: Baire category theorem for complete metric spaces **)
(** LATEX VERSION: Complete metric spaces are Baire. **)
Theorem Baire_category_complete_metric : forall X d:set,
  complete_metric_space X d -> Baire_space X (metric_topology X d).
let X d.
assume Hcomp.
prove Baire_space X (metric_topology X d).
admit. (** Baire category theorem: complete metric spaces are Baire **)
Qed.

(** from 48 Theorem: compact Hausdorff spaces are Baire spaces **)
(** LATEX VERSION: Compact Hausdorff spaces are Baire. **)
Theorem Baire_category_compact_Hausdorff : forall X Tx:set,
  compact_space X Tx -> Hausdorff_space X Tx -> Baire_space X Tx.
let X Tx.
assume Hcomp HHaus.
prove Baire_space X Tx.
admit. (** Baire category theorem: compact Hausdorff spaces are Baire **)
Qed.

(** from 48 Theorem: Baire category theorem general version **)
(** LATEX VERSION: General Baire category consequence: nonempty open sets in Baire space. **)
(** FIXED: Corrected Baire_space to take both X and Tx parameters. **)
Theorem Baire_category_theorem : forall X Tx:set,
  Baire_space X Tx -> forall U:set, open_in X Tx U -> U <> Empty.
let X Tx.
assume HBaire.
let U.
assume Hopen.
prove U <> Empty.
admit. (** Baire category theorem: dense G_delta sets are nonempty **)
Qed.

(** from 49 Definition: differentiability and nowhere-differentiable function **) 
(** LATEX VERSION: A function is differentiable at x if the difference quotient (f(x+h)-f(x))/h tends to a limit as h0 (with x+h in the domain); nowhere differentiable means differentiable at no point. **)
Definition differentiable_at : set -> set -> prop := fun f x =>
  function_on f unit_interval R /\ x :e unit_interval /\
  exists L:set, L :e R /\
    forall eps:set, eps :e R -> Rlt 0 eps ->
      exists delta:set, delta :e R /\ Rlt 0 delta /\
        forall h:set, h :e R ->
          ~(h = 0) ->
          Rlt 0 (Abs h) ->
          Rlt (Abs h) delta ->
          (add_SNo x h) :e unit_interval ->
          Rlt (Abs (add_SNo
                      (div_SNo (add_SNo (apply_fun f (add_SNo x h)) (minus_SNo (apply_fun f x))) h)
                      (minus_SNo L))) eps.
Definition nowhere_differentiable : set -> prop := fun f =>
  function_on f unit_interval R /\ forall x:set, x :e unit_interval -> ~ differentiable_at f x.

(** from 49 Existence: nowhere-differentiable function **) 
(** LATEX VERSION: Existence of a continuous nowhere-differentiable function. **)
Theorem nowhere_differentiable_function_exists :
  exists f:set,
    continuous_map unit_interval (subspace_topology R R_standard_topology unit_interval) R R_standard_topology f /\
    nowhere_differentiable f.
prove exists f:set,
    continuous_map unit_interval (subspace_topology R R_standard_topology unit_interval) R R_standard_topology f /\
    nowhere_differentiable f.
admit. (** 49: existence of continuous nowhere-differentiable function **)
Qed.

(** helper: finite cardinality via equip to an ordinal **) 
(** LATEX VERSION: Cardinality_exact/at_most helper predicates for dimension theory. **)
Definition cardinality_exact : set -> set -> prop := fun S n =>
  ordinal n /\ equip S n.
Definition cardinality_at_most : set -> set -> prop := fun S n =>
  ordinal n /\ exists k:set, ordinal k /\ k c= n /\ equip S k.

(** from 50 Definition: order of a collection of subsets **) 
(** LATEX VERSION: A collection A has order m+1 if some point lies in m+1 elements of A,
   and no point lies in more than m+1 elements of A. **)
Definition collection_has_order_at_m_plus_one : set -> set -> set -> prop :=
  fun X A m =>
    ordinal m /\
    (exists x:set, x :e X /\
      exists Fam:set, Fam c= A /\ finite Fam /\
        cardinality_exact Fam (ordsucc m) /\
        forall U:set, U :e Fam -> x :e U) /\
    forall x:set, x :e X ->
      cardinality_at_most {U :e A|x :e U} (ordsucc m).

(** from 50 Definition (derived): order at most m+1 **) 
(** LATEX VERSION: A collection A has order at most m+1 if no point lies in more than m+1 elements of A. **)
Definition collection_has_order_at_most_m_plus_one : set -> set -> set -> prop :=
  fun X A m =>
    ordinal m /\
    forall x:set, x :e X ->
      cardinality_at_most {U :e A|x :e U} (ordsucc m).

(** from 50 Definition: covering dimension and finite dimensionality **)
(** LATEX VERSION: For a topological space (X,Tx), we write dim(X)  n if for every open cover A of X\n+   there exists an open cover B refining A that has order at most n+1. **)
(** Helper: refinement of covers (as families of subsets) **)
(** LATEX VERSION: B refines A if every element of B is contained in some element of A. **)
Definition refines_cover : set -> set -> prop := fun B A =>
  forall U:set, U :e B -> exists V:set, V :e A /\ U c= V.

Definition covering_dimension : set -> set -> set -> prop := fun X Tx n =>
  topology_on X Tx /\ n :e omega /\
    forall A:set, open_cover_of X Tx A ->
      exists B:set,
        open_cover_of X Tx B /\
        refines_cover B A /\
        collection_has_order_at_most_m_plus_one X B n.
(** LATEX VERSION: X is finite dimensional if dim(X)  m for some m. **)
Definition finite_dimensional_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  exists m:set, m :e omega /\
    forall A:set, open_cover_of X Tx A ->
      exists B:set,
        open_cover_of X Tx B /\
        refines_cover B A /\
        collection_has_order_at_most_m_plus_one X B m.

(** from 50 Theorem: compact subspace of R^n has dimension at most n **) 
(** LATEX VERSION: Compact subspace of ^n has covering dimension  n. **)
Theorem compact_subspace_Rn_dimension_le : forall N X:set,
  X c= (euclidean_space N) ->
  compact_space X (subspace_topology (euclidean_space N) (euclidean_topology N) X) ->
  covering_dimension X (subspace_topology (euclidean_space N) (euclidean_topology N) X) N.
let N X.
assume HXsub.
assume Hcomp.
prove covering_dimension X (subspace_topology (euclidean_space N) (euclidean_topology N) X) N.
admit. (** compact subspace of R^n has dimension  n **)
Qed.

(** from 50 Theorem: compact m-manifold has dimension at most m **) 
(** LATEX VERSION: Compact m-manifold has covering dimension  m. **)
Theorem compact_manifold_dimension_le : forall X Tx m:set,
  m_manifold X Tx -> compact_space X Tx -> covering_dimension X Tx m.
let X Tx m.
assume Hman Hcomp.
prove covering_dimension X Tx m.
admit. (** compact m-manifold has dimension  m **)
Qed.

(** from 50 Theorem (Menger-Nbeling): compact metrizable space of dimension m embeds in R^{2m+1} **) 
(** LATEX VERSION: MengerNbeling embedding theorem (placeholder). **)
Theorem Menger_Nobeling_embedding : forall X Tx m:set,
  compact_space X Tx -> metrizable X Tx -> covering_dimension X Tx m ->
  exists N:set, exists e:set,
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e.
let X Tx m.
assume Hcomp Hmet Hdim.
prove exists N:set, exists e:set,
  embedding_of X Tx (euclidean_space N) (euclidean_topology N) e.
admit. (** Menger-Nbeling: compact metrizable dim-m embeds in some R^N **)
Qed.

(** from 50 Theorem 50.1: dimension of closed subspace bounded by ambient **) 
(** LATEX VERSION: Dimension of a closed subspace does not exceed that of the ambient space. **)
Theorem dimension_closed_subspace_le : forall X Tx Y n:set,
  covering_dimension X Tx n -> closed_in X Tx Y ->
  covering_dimension Y (subspace_topology X Tx Y) n.
let X Tx Y n.
assume HX HY.
prove covering_dimension Y (subspace_topology X Tx Y) n.
admit. (** Theorem 50.1: closed subspace dimension  ambient dimension **)
Qed.

(** from 50 Theorem 50.2: dimension of union of closed sets is max **)
(** LATEX VERSION: If X = Y  Z where Y,Z are closed in X, then dim(X)  max(dim(Y),dim(Z)) (and in fact equality holds for finite-dimensional spaces). **)
Theorem dimension_union_closed_max : forall X Tx Y Z n:set,
  topology_on X Tx ->
  Y c= X -> Z c= X ->
  closed_in X Tx Y -> closed_in X Tx Z ->
  covering_dimension Y (subspace_topology X Tx Y) n ->
  covering_dimension Z (subspace_topology X Tx Z) n ->
  covering_dimension (Y :\/: Z) (subspace_topology X Tx (Y :\/: Z)) n.
let X Tx Y Z n.
assume HTx HYsub HZsub HYcl HZcl HYdim HZdim.
prove covering_dimension (Y :\/: Z) (subspace_topology X Tx (Y :\/: Z)) n.
admit. (** Theorem 50.2: union dimension bound (placeholder) **)
Qed.

(** from 50 Corollary 50.3: finite union of closed finite-dimensional sets **)
(** LATEX VERSION: If X is a finite union of closed subspaces each of dimension  n, then X has dimension  n. **)
Theorem dimension_finite_union_closed_max : forall X Tx Fam n:set,
  topology_on X Tx ->
  finite Fam ->
  (forall Y:set, Y :e Fam -> Y c= X /\ closed_in X Tx Y /\ covering_dimension Y (subspace_topology X Tx Y) n) ->
  covering_dimension (Union Fam) (subspace_topology X Tx (Union Fam)) n.
let X Tx Fam n.
assume HTx Hfin Hall.
prove covering_dimension (Union Fam) (subspace_topology X Tx (Union Fam)) n.
admit. (** Corollary 50.3: finite union bound (placeholder) **)
Qed.

(** from 50 Example 4: compact 1-manifold has dimension 1 **)
(** LATEX VERSION: Every compact 1-manifold X has topological dimension 1. **)
Theorem compact_1_manifold_dimension_1 : forall X Tx:set,
  compact_space X Tx -> m_manifold X Tx -> covering_dimension X Tx (Sing Empty).
let X Tx.
assume Hcomp Hman.
admit. (** requires full 1-manifold theory and dimension computation **)
Qed.

(** from 50 Example 5: compact 2-manifold has dimension at most 2 **)
(** LATEX VERSION: Every compact 2-manifold X has topological dimension at most 2. **)
Definition two : set := Sing (Sing Empty).
Theorem compact_2_manifold_dimension_le_2 : forall X Tx:set,
  compact_space X Tx -> m_manifold X Tx -> covering_dimension X Tx two.
let X Tx.
assume Hcomp Hman.
admit. (** requires proper dimension theory **)
Qed.

(** from 50 Example 6: arcs and linear graphs **)
(** LATEX VERSION: An arc is a space homeomorphic to [0,1]; a linear graph is a finite union of arcs meeting at most at common endpoints. **)
Definition arc : set -> set -> prop := fun X Tx =>
  exists f:set, homeomorphism unit_interval R_standard_topology X Tx f.

(** Helper: arc is a topological space **)
Theorem arc_is_topological_space : forall X Tx:set,
  arc X Tx -> topology_on X Tx.
let X Tx.
assume Harc.
apply Harc.
let f.
assume Hhom.
claim Hcont: continuous_map unit_interval R_standard_topology X Tx f.
{ exact (andEL (continuous_map unit_interval R_standard_topology X Tx f)
               (exists g:set, continuous_map X Tx unit_interval R_standard_topology g /\
                 (forall x:set, x :e unit_interval -> apply_fun g (apply_fun f x) = x) /\
                 (forall y:set, y :e X -> apply_fun f (apply_fun g y) = y))
               Hhom). }
claim Habc: (topology_on unit_interval R_standard_topology /\ topology_on X Tx) /\ function_on f unit_interval X.
{ exact (andEL ((topology_on unit_interval R_standard_topology /\ topology_on X Tx) /\ function_on f unit_interval X)
               (forall V:set, V :e Tx -> preimage_of unit_interval f V :e R_standard_topology)
               Hcont). }
claim Hab: topology_on unit_interval R_standard_topology /\ topology_on X Tx.
{ exact (andEL (topology_on unit_interval R_standard_topology /\ topology_on X Tx)
               (function_on f unit_interval X)
               Habc). }
exact (andER (topology_on unit_interval R_standard_topology) (topology_on X Tx) Hab).
Qed.

Definition end_points_of_arc : set -> set -> set -> set -> prop := fun X Tx p q =>
  arc X Tx /\
  p :e X /\ q :e X /\
  p <> q /\
  connected_space (X :\: (Sing p)) Tx /\
  connected_space (X :\: (Sing q)) Tx.

Definition linear_graph : set -> set -> prop := fun G Tg =>
  Hausdorff_space G Tg /\
  exists Arcs:set,
    finite Arcs /\
    (forall A:set, A :e Arcs ->
      exists Ta:set, arc A Ta /\ A c= G) /\
    G = Union Arcs /\
    (forall A B:set, A :e Arcs -> B :e Arcs -> A <> B ->
      exists p:set, (A :/\: B = Empty \/ A :/\: B = Sing p)).

(** from 50 Example 6: linear graphs have dimension 1 **)
(** LATEX VERSION: A linear graph G has topological dimension 1. **)
Theorem linear_graph_dimension_1 : forall G Tg:set,
  linear_graph G Tg -> covering_dimension G Tg (Sing Empty).
let G Tg.
assume Hlin.
admit. (** Example 6: linear graphs have topological dimension 1 (placeholder) **)
Qed.

(** from 50 Example 7: general position in R^3 (preliminary) **)
(** LATEX VERSION: In R^3, points are in general position if no three are collinear and no four are coplanar. **)
Definition collinear_in_R3 : set -> set -> set -> prop := fun p q r =>
  p :e R /\ q :e R /\ r :e R /\
  exists t1 t2:set, t1 :e R /\ t2 :e R /\
    (exists a b:set, a :e R /\ b :e R /\
      r = a :\: (b :\: (p :\: (q :\: p)))).

Definition coplanar_in_R3 : set -> set -> set -> set -> prop := fun p q r s =>
  p :e R /\ q :e R /\ r :e R /\ s :e R /\
  exists A B C D:set, A :e R /\ B :e R /\ C :e R /\ D :e R /\
    True. (** placeholder for plane equation **)

(** from 50: geometrically independent (affinely independent) points in R^N **)
(** LATEX VERSION: Points {x,...,x} in R^N are geometrically independent if ax=0 and a=0 imply all a=0. **)
(** stub: actual condition needs vector space operations **)
Definition geometrically_independent : set -> prop := fun S =>
  S c= R.

(** from 50: plane determined by geometrically independent points **)
(** LATEX VERSION: The plane P determined by geometrically independent points {x,...,x} is the set of all x = tx where t=1. **)
(** stub: needs proper formulation of affine combination **)
Definition affine_plane : set -> set := fun S =>
  {x :e R | exists tcoeffs:set,
    (forall s:set, s :e S -> exists t:set, t :e R /\ (s,t) :e tcoeffs) /\
    True}.

(** from 50: k-plane in R^N **)
(** LATEX VERSION: A k-plane in R^N is the affine plane determined by k+1 geometrically independent points. **)
Definition k_plane : set -> set -> prop := fun k P =>
  k :e omega /\
  exists S:set,
    geometrically_independent S /\
    finite S /\
    (exists kp1:set, kp1 = k :\/: (Sing k) /\ equip S kp1) /\
    P = affine_plane S.

(** from 50: general position in R^N **)
(** LATEX VERSION: A set A in R^N is in general position if every subset with N+1 points is geometrically independent. **)
Definition general_position_RN : set -> set -> prop := fun N A =>
  N :e omega /\
  A c= R /\
  forall S:set, S c= A ->
    (forall Np1:set, Np1 = N :\/: (Sing N) ->
      (exists f:set -> set, inj S Np1 f) -> geometrically_independent S).

(** from 50 Lemma 50.4: approximation in general position **)
(** LATEX VERSION: Given finite {x,...,x} in R^N and >0, there exists {y,...,y} in general position with |x-y|< for all i. **)
(** stub: proper ordering and metric conditions need to be formulated **)
Theorem finite_set_approximation_general_position : forall N:set, forall pts:set, forall delta:set,
  N :e omega ->
  finite pts ->
  pts c= R ->
  delta :e R ->
  exists pts':set,
    general_position_RN N pts' /\
    finite pts' /\
    equip pts pts'.
let N pts delta.
assume HN Hfin Hpts Hdelta.
prove exists pts':set,
  general_position_RN N pts' /\
  finite pts' /\
  equip pts pts'.
admit. (** Lemma 50.4: approximate finite set by one in general position **)
Qed.

(** from 50 Theorem 50.5: Menger-Nbeling embedding theorem **)
(** LATEX VERSION: Every compact metrizable space X of topological dimension m can be embedded in R^{2m+1}. **)
(** FIXED: Dimension calculation error.
    Was: N = m  m  {} = m  {} = m+1 (successor of m, not 2m+1!)
    Now: N = add_nat (mul_nat two m) 1 = 2m+1 (correct dimension)
    The comment says R^{2m+1}, so need to compute 2m+1 using add_nat and mul_nat.
    Using two from line 17259 and 1 = Sing Empty. **)
Theorem Menger_Nobeling_embedding_full : forall X Tx m:set,
  compact_space X Tx ->
  metrizable X Tx ->
  covering_dimension X Tx m ->
  m :e omega ->
  exists N:set, exists e:set,
    N = add_nat (mul_nat two m) (Sing Empty) /\
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e.
let X Tx m.
assume Hcomp Hmet Hdim Hm.
prove exists N:set, exists e:set,
  N = add_nat (mul_nat two m) (Sing Empty) /\
  embedding_of X Tx (euclidean_space N) (euclidean_topology N) e.
admit. (** Theorem 50.5: Menger-Nbeling embedding in R^{2m+1} **)
Qed.

(** from 50 Theorem 50.6: compact subspace of R^N has dimension at most N **)
(** LATEX VERSION: Every compact subspace of R^N has topological dimension at most N. **)
Theorem compact_subspace_RN_dimension_le_N : forall X N:set,
  N :e omega ->
  X c= (euclidean_space N) ->
  compact_space X (subspace_topology (euclidean_space N) (euclidean_topology N) X) ->
  covering_dimension X (subspace_topology (euclidean_space N) (euclidean_topology N) X) N.
let X N.
assume HN Hsub Hcomp.
prove covering_dimension X (subspace_topology (euclidean_space N) (euclidean_topology N) X) N.
admit. (** Theorem 50.6: compact subspace of R^N has dimension  N **)
Qed.

(** from 50 Corollary 50.7: compact m-manifold has dimension at most m **)
(** LATEX VERSION: Every compact m-manifold has topological dimension at most m. **)
Theorem compact_m_manifold_dimension_le_m : forall X Tx m:set,
  m :e omega ->
  compact_space X Tx ->
  m_manifold X Tx ->
  covering_dimension X Tx m.
let X Tx m.
assume Hm Hcomp Hman.
prove covering_dimension X Tx m.
admit. (** Corollary 50.7: compact m-manifold has dimension  m **)
Qed.

(** from 50 Corollary 50.8: compact m-manifold embeds in R^{2m+1} **)
(** LATEX VERSION: Every compact m-manifold can be embedded in R^{2m+1}. **)
(** FIXED: Same dimension error as previous theorem.
    Was: N = m  m  {} = m+1 (not 2m+1!)
    Now: N = add_nat (mul_nat two m) (Sing Empty) = 2m+1 **)
Theorem compact_m_manifold_embeds_R2mp1 : forall X Tx m:set,
  m :e omega ->
  compact_space X Tx ->
  m_manifold X Tx ->
  exists N:set, exists e:set,
    N = add_nat (mul_nat two m) (Sing Empty) /\
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e.
let X Tx m.
assume Hm Hcomp Hman.
prove exists N:set, exists e:set,
  N = add_nat (mul_nat two m) (Sing Empty) /\
  embedding_of X Tx (euclidean_space N) (euclidean_topology N) e.
admit. (** Corollary 50.8: compact m-manifold embeds in R^{2m+1} **)
Qed.

(** from 50 Corollary 50.9: compact metrizable embeds in R^N iff finite dimensional **)
(** LATEX VERSION: A compact metrizable space X can be embedded in R^N for some N iff X has finite topological dimension. **)
Theorem compact_metrizable_embeds_iff_finite_dim : forall X Tx:set,
  compact_space X Tx ->
  metrizable X Tx ->
  ((exists N:set, exists e:set,
    N :e omega /\
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e)
  <->
  finite_dimensional_space X Tx).
let X Tx.
assume HC: compact_space X Tx.
assume HM: metrizable X Tx.
prove (exists N:set, exists e:set, N :e omega /\ embedding_of X Tx (euclidean_space N) (euclidean_topology N) e) <-> finite_dimensional_space X Tx.
admit. (** Corollary 50.9: embedding iff finite dimensional **)
Qed.

(** from Supplementary Exercises: locally m-euclidean space **)
(** LATEX VERSION: A space X is locally m-euclidean if each point has a neighborhood homeomorphic to an open set of R^m. **)
Definition locally_m_euclidean : set -> set -> set -> prop := fun X Tx m =>
  m :e omega /\
  topology_on X Tx /\
  forall x:set, x :e X ->
    exists U:set, exists V:set, exists f:set,
      open_in X Tx U /\
      x :e U /\
      V c= (euclidean_space m) /\
      open_in (euclidean_space m) (euclidean_topology m) V /\
      homeomorphism U (subspace_topology X Tx U) V (subspace_topology (euclidean_space m) (euclidean_topology m) V) f.

(** from Supplementary Exercises: Locally Euclidean Spaces: locally m-euclidean implies T1 **)
(** LATEX VERSION: Such a space X automatically satisfies the T1 axiom. **)
Theorem euclidean_space_Hausdorff : forall m:set,
  Hausdorff_space (euclidean_space m) (euclidean_topology m).
let m.
prove Hausdorff_space (euclidean_space m) (euclidean_topology m).
(** Obtain Hausdorffness of product_topology_full from 31 Theorem 31.2 (currently admitted). **)
claim HRtop: topology_on R R_standard_topology.
{ exact R_standard_topology_is_topology_local. }
claim Hall:
  (forall Y:set, Y c= R -> Hausdorff_space R R_standard_topology -> Hausdorff_space Y (subspace_topology R R_standard_topology Y)) /\
  (forall I Xi:set, Hausdorff_spaces_family I Xi -> Hausdorff_space (product_space I Xi) (product_topology_full I Xi)) /\
  (forall Y:set, Y c= R -> regular_space R R_standard_topology -> regular_space Y (subspace_topology R R_standard_topology Y)) /\
  (forall I Xi:set, regular_spaces_family I Xi -> regular_space (product_space I Xi) (product_topology_full I Xi)).
{ exact (separation_axioms_subspace_product R R_standard_topology HRtop). }
claim H123: ((forall Y:set, Y c= R -> Hausdorff_space R R_standard_topology -> Hausdorff_space Y (subspace_topology R R_standard_topology Y)) /\
             (forall I Xi:set, Hausdorff_spaces_family I Xi -> Hausdorff_space (product_space I Xi) (product_topology_full I Xi))) /\
            (forall Y:set, Y c= R -> regular_space R R_standard_topology -> regular_space Y (subspace_topology R R_standard_topology Y)).
{ exact (andEL (((forall Y:set, Y c= R -> Hausdorff_space R R_standard_topology -> Hausdorff_space Y (subspace_topology R R_standard_topology Y)) /\
                 (forall I Xi:set, Hausdorff_spaces_family I Xi -> Hausdorff_space (product_space I Xi) (product_topology_full I Xi))) /\
                (forall Y:set, Y c= R -> regular_space R R_standard_topology -> regular_space Y (subspace_topology R R_standard_topology Y)))
               (forall I Xi:set, regular_spaces_family I Xi -> regular_space (product_space I Xi) (product_topology_full I Xi))
               Hall). }
claim H12:
  (forall Y:set, Y c= R -> Hausdorff_space R R_standard_topology -> Hausdorff_space Y (subspace_topology R R_standard_topology Y)) /\
  (forall I Xi:set, Hausdorff_spaces_family I Xi -> Hausdorff_space (product_space I Xi) (product_topology_full I Xi)).
{ exact (andEL ((forall Y:set, Y c= R -> Hausdorff_space R R_standard_topology -> Hausdorff_space Y (subspace_topology R R_standard_topology Y)) /\
                (forall I Xi:set, Hausdorff_spaces_family I Xi -> Hausdorff_space (product_space I Xi) (product_topology_full I Xi)))
               (forall Y:set, Y c= R -> regular_space R R_standard_topology -> regular_space Y (subspace_topology R R_standard_topology Y))
               H123). }
claim Hprod:
  forall I Xi:set, Hausdorff_spaces_family I Xi -> Hausdorff_space (product_space I Xi) (product_topology_full I Xi).
{ exact (andER (forall Y:set, Y c= R -> Hausdorff_space R R_standard_topology -> Hausdorff_space Y (subspace_topology R R_standard_topology Y))
               (forall I Xi:set, Hausdorff_spaces_family I Xi -> Hausdorff_space (product_space I Xi) (product_topology_full I Xi))
               H12). }
claim Hfam: Hausdorff_spaces_family m (const_space_family m R R_standard_topology).
{ let i. assume Hi: i :e m.
  prove Hausdorff_space (product_component (const_space_family m R R_standard_topology) i)
                       (product_component_topology (const_space_family m R R_standard_topology) i).
  rewrite (product_component_def (const_space_family m R R_standard_topology) i).
  rewrite (product_component_topology_def (const_space_family m R R_standard_topology) i).
  rewrite (const_space_family_apply m R R_standard_topology i Hi).
  (** reduce the components of the tuple (R, R_standard_topology) **)
  rewrite (tuple_2_0_eq R R_standard_topology).
  rewrite (tuple_2_1_eq R R_standard_topology).
  exact R_standard_topology_Hausdorff. }
exact (Hprod m (const_space_family m R R_standard_topology) Hfam).
Qed.

(** helper: Euclidean spaces are T1 **)
(** LATEX VERSION: Euclidean spaces satisfy the T1 axiom (finite sets are closed). **)
Theorem euclidean_space_T1 : forall m:set,
  T1_space (euclidean_space m) (euclidean_topology m).
let m.
prove T1_space (euclidean_space m) (euclidean_topology m).
claim HH: Hausdorff_space (euclidean_space m) (euclidean_topology m).
{ exact (euclidean_space_Hausdorff m). }
claim Htop: topology_on (euclidean_space m) (euclidean_topology m).
{ exact (andEL (topology_on (euclidean_space m) (euclidean_topology m))
               (forall x1 x2:set, x1 :e euclidean_space m -> x2 :e euclidean_space m -> x1 <> x2 ->
                 exists U V:set, U :e euclidean_topology m /\ V :e euclidean_topology m /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
               HH). }
prove topology_on (euclidean_space m) (euclidean_topology m) /\
      forall F:set, F c= euclidean_space m -> finite F -> closed_in (euclidean_space m) (euclidean_topology m) F.
apply andI.
- exact Htop.
- let F. assume HFsub: F c= euclidean_space m. assume HFfin: finite F.
  exact (finite_sets_closed_in_Hausdorff (euclidean_space m) (euclidean_topology m) HH F HFsub HFfin).
Qed.

Theorem locally_m_euclidean_implies_T1 : forall X Tx m:set,
  locally_m_euclidean X Tx m -> T1_space X Tx.
let X Tx m.
assume Hloc: locally_m_euclidean X Tx m.
prove T1_space X Tx.
(** Use lemma_T1_singletons_closed, reducing to showing that each singleton is closed. **)
claim Hloc_parts: (m :e omega /\ topology_on X Tx) /\ (forall x0:set, x0 :e X ->
  exists U0:set, exists V0:set, exists f0:set,
    open_in X Tx U0 /\ x0 :e U0 /\ V0 c= (euclidean_space m) /\
    open_in (euclidean_space m) (euclidean_topology m) V0 /\
    homeomorphism U0 (subspace_topology X Tx U0) V0 (subspace_topology (euclidean_space m) (euclidean_topology m) V0) f0).
{ exact Hloc. }
claim Htop: topology_on X Tx.
{ claim HmTop: m :e omega /\ topology_on X Tx.
  { exact (andEL (m :e omega /\ topology_on X Tx)
                 (forall x0:set, x0 :e X ->
                   exists U0:set, exists V0:set, exists f0:set,
                     open_in X Tx U0 /\ x0 :e U0 /\ V0 c= (euclidean_space m) /\
                     open_in (euclidean_space m) (euclidean_topology m) V0 /\
                     homeomorphism U0 (subspace_topology X Tx U0) V0 (subspace_topology (euclidean_space m) (euclidean_topology m) V0) f0)
                 Hloc_parts). }
  exact (andER (m :e omega) (topology_on X Tx) HmTop). }
claim Hcharts: forall x0:set, x0 :e X ->
  exists U0:set, exists V0:set, exists f0:set,
    open_in X Tx U0 /\ x0 :e U0 /\ V0 c= (euclidean_space m) /\
    open_in (euclidean_space m) (euclidean_topology m) V0 /\
    homeomorphism U0 (subspace_topology X Tx U0) V0 (subspace_topology (euclidean_space m) (euclidean_topology m) V0) f0.
{ exact (andER (m :e omega /\ topology_on X Tx)
               (forall x0:set, x0 :e X ->
                 exists U0:set, exists V0:set, exists f0:set,
                   open_in X Tx U0 /\ x0 :e U0 /\ V0 c= (euclidean_space m) /\
                   open_in (euclidean_space m) (euclidean_topology m) V0 /\
                   homeomorphism U0 (subspace_topology X Tx U0) V0 (subspace_topology (euclidean_space m) (euclidean_topology m) V0) f0)
               Hloc_parts). }
apply (iffER (T1_space X Tx)
             (forall x0:set, x0 :e X -> closed_in X Tx {x0})
             (lemma_T1_singletons_closed X Tx Htop)).
prove forall x0:set, x0 :e X -> closed_in X Tx {x0}.
let x0. assume Hx0X: x0 :e X.
prove closed_in X Tx {x0}.
(** It is enough to show X\\{x0} is open, and then {x0} = X\\(X\\{x0}). **)
claim HsingSub: {x0} c= X.
{ let y. assume Hy: y :e {x0}.
  claim Hyeq: y = x0.
  { exact (SingE x0 y Hy). }
  rewrite Hyeq. exact Hx0X. }
claim Hsep_x0: forall y:set, y :e X -> y <> x0 -> exists W:set, W :e Tx /\ y :e W /\ x0 /:e W.
{ let y. assume HyX: y :e X. assume Hyneq: y <> x0.
  apply (Hcharts y HyX).
  let U. assume HexVf.
  apply HexVf.
  let V. assume Hexf.
  apply Hexf.
  let f. assume Hprops.
  (** split the chart properties **)
  claim Hleft: (((open_in X Tx U /\ y :e U) /\ V c= (euclidean_space m)) /\
               open_in (euclidean_space m) (euclidean_topology m) V).
  { exact (andEL ((((open_in X Tx U /\ y :e U) /\ V c= (euclidean_space m)) /\
                 open_in (euclidean_space m) (euclidean_topology m) V))
                (homeomorphism U (subspace_topology X Tx U) V
                  (subspace_topology (euclidean_space m) (euclidean_topology m) V) f)
                Hprops). }
  claim Hhomeo: homeomorphism U (subspace_topology X Tx U) V
    (subspace_topology (euclidean_space m) (euclidean_topology m) V) f.
  { exact (andER ((((open_in X Tx U /\ y :e U) /\ V c= (euclidean_space m)) /\
                 open_in (euclidean_space m) (euclidean_topology m) V))
                (homeomorphism U (subspace_topology X Tx U) V
                  (subspace_topology (euclidean_space m) (euclidean_topology m) V) f)
                Hprops). }
  claim Hmid: ((open_in X Tx U /\ y :e U) /\ V c= (euclidean_space m)).
  { exact (andEL ((open_in X Tx U /\ y :e U) /\ V c= (euclidean_space m))
                 (open_in (euclidean_space m) (euclidean_topology m) V)
                 Hleft). }
  claim HVopen: open_in (euclidean_space m) (euclidean_topology m) V.
  { exact (andER ((open_in X Tx U /\ y :e U) /\ V c= (euclidean_space m))
                 (open_in (euclidean_space m) (euclidean_topology m) V)
                 Hleft). }
  claim Hpair: open_in X Tx U /\ y :e U.
  { exact (andEL (open_in X Tx U /\ y :e U) (V c= (euclidean_space m)) Hmid). }
  claim HVsub: V c= (euclidean_space m).
  { exact (andER (open_in X Tx U /\ y :e U) (V c= (euclidean_space m)) Hmid). }
  claim HUopen: open_in X Tx U.
  { exact (andEL (open_in X Tx U) (y :e U) Hpair). }
  claim HyU: y :e U.
  { exact (andER (open_in X Tx U) (y :e U) Hpair). }
  (** If x0 not in U, take W=U. Otherwise refine inside U via the chart. **)
  apply (xm (x0 :e U)).
  - assume Hx0U: x0 :e U.
    (** Extract that U is open in X and belongs to Tx. **)
    claim HUinTx: U :e Tx.
    { exact (andER (topology_on X Tx) (U :e Tx) HUopen). }
    (** Subspace topology on U is a topology. **)
    claim HUsubX: U c= X.
    { exact (open_in_subset X Tx U HUopen). }
    claim HTU: topology_on U (subspace_topology X Tx U).
    { exact (subspace_topology_is_topology X Tx U Htop HUsubX). }
    (** f is continuous and hence a function on U -> V. **)
    claim Hcontf: continuous_map U (subspace_topology X Tx U) V
      (subspace_topology (euclidean_space m) (euclidean_topology m) V) f.
    { exact (andEL (continuous_map U (subspace_topology X Tx U) V
                    (subspace_topology (euclidean_space m) (euclidean_topology m) V) f)
                   (exists g:set,
                     continuous_map V (subspace_topology (euclidean_space m) (euclidean_topology m) V) U
                       (subspace_topology X Tx U) g /\
                     (forall u:set, u :e U -> apply_fun g (apply_fun f u) = u) /\
                     (forall v:set, v :e V -> apply_fun f (apply_fun g v) = v))
                   Hhomeo). }
    claim Hfunf: function_on f U V.
    { claim Htmp: (topology_on U (subspace_topology X Tx U) /\ topology_on V (subspace_topology (euclidean_space m) (euclidean_topology m) V)) /\ function_on f U V.
      { exact (andEL ((topology_on U (subspace_topology X Tx U) /\ topology_on V (subspace_topology (euclidean_space m) (euclidean_topology m) V)) /\ function_on f U V)
                     (forall V1:set, V1 :e subspace_topology (euclidean_space m) (euclidean_topology m) V ->
                       preimage_of U f V1 :e subspace_topology X Tx U)
                     Hcontf). }
      exact (andER (topology_on U (subspace_topology X Tx U) /\ topology_on V (subspace_topology (euclidean_space m) (euclidean_topology m) V))
                   (function_on f U V)
                   Htmp). }
    claim Hfx0V: apply_fun f x0 :e V.
    { exact (Hfunf x0 Hx0U). }
    claim HfyV: apply_fun f y :e V.
    { exact (Hfunf y HyU). }
    (** V is T1 (as an open subspace of Euclidean space). **)
    claim HT1E: T1_space (euclidean_space m) (euclidean_topology m).
    { exact (euclidean_space_T1 m). }
    claim HT1V: T1_space V (subspace_topology (euclidean_space m) (euclidean_topology m) V).
    { claim HtopE: topology_on (euclidean_space m) (euclidean_topology m).
      { exact (andEL (topology_on (euclidean_space m) (euclidean_topology m))
                     (forall F:set, F c= euclidean_space m -> finite F -> closed_in (euclidean_space m) (euclidean_topology m) F)
                     HT1E). }
      exact (subspace_T1 (euclidean_space m) (euclidean_topology m) V HtopE HVsub HT1E). }
    (** Use V \\ {f(x0)} as an open neighborhood of f(y) when f(y) != f(x0). **)
    claim Hinj: forall u1 u2:set, u1 :e U -> u2 :e U -> apply_fun f u1 = apply_fun f u2 -> u1 = u2.
    { let u1 u2. assume Hu1U: u1 :e U. assume Hu2U: u2 :e U. assume Heq: apply_fun f u1 = apply_fun f u2.
      exact (homeomorphism_injective U (subspace_topology X Tx U) V
               (subspace_topology (euclidean_space m) (euclidean_topology m) V) f
               Hhomeo u1 u2 Hu1U Hu2U Heq). }
	    claim Hneqf: apply_fun f y <> apply_fun f x0.
	    { assume Heqf: apply_fun f y = apply_fun f x0.
	      claim Hyx0: y = x0.
	      { exact (Hinj y x0 HyU Hx0U Heqf). }
	      exact (Hyneq Hyx0). }
    set O := V :\: {apply_fun f x0}.
    claim HOopen: O :e subspace_topology (euclidean_space m) (euclidean_topology m) V.
    { exact (T1_singleton_complement_open V
              (subspace_topology (euclidean_space m) (euclidean_topology m) V)
              (apply_fun f x0)
              HT1V Hfx0V). }
    claim HfyO: apply_fun f y :e O.
    { apply setminusI.
      - exact HfyV.
      - assume Hsing: apply_fun f y :e {apply_fun f x0}.
        claim Heqf: apply_fun f y = apply_fun f x0.
        { exact (SingE (apply_fun f x0) (apply_fun f y) Hsing). }
        exact (Hneqf Heqf). }
    (** Preimage of O is open in the subspace topology on U. **)
    claim Hpreimg_open: preimage_of U f O :e subspace_topology X Tx U.
    { claim Hpreimg_axiom: forall V1:set,
        V1 :e subspace_topology (euclidean_space m) (euclidean_topology m) V ->
        preimage_of U f V1 :e subspace_topology X Tx U.
      { exact (andER ((topology_on U (subspace_topology X Tx U) /\
                       topology_on V (subspace_topology (euclidean_space m) (euclidean_topology m) V)) /\
                      function_on f U V)
                     (forall V1:set, V1 :e subspace_topology (euclidean_space m) (euclidean_topology m) V ->
                       preimage_of U f V1 :e subspace_topology X Tx U)
                     Hcontf). }
      exact (Hpreimg_axiom O HOopen). }
    (** Turn this into an open set in X using open_in_subspace_iff and closure under intersections. **)
    claim Hpreimg_sub: preimage_of U f O c= U.
    { let z. assume Hz: z :e preimage_of U f O.
      exact (SepE1 U (fun u:set => apply_fun f u :e O) z Hz). }
    claim Hpreimg_open_in: open_in U (subspace_topology X Tx U) (preimage_of U f O).
    { prove topology_on U (subspace_topology X Tx U) /\ preimage_of U f O :e subspace_topology X Tx U.
      apply andI.
      - exact HTU.
      - exact Hpreimg_open. }
    (** Use open_in_subspace_iff to obtain a V0Tx with preimage = V0U. **)
    claim HexV0: exists V0 :e Tx, preimage_of U f O = V0 :/\: U.
    { exact (iffEL (open_in U (subspace_topology X Tx U) (preimage_of U f O))
                   (exists V0 :e Tx, preimage_of U f O = V0 :/\: U)
                   (open_in_subspace_iff X Tx U (preimage_of U f O) Htop HUsubX Hpreimg_sub)
                   Hpreimg_open_in). }
    apply HexV0.
    let V0. assume HV0conj: V0 :e Tx /\ preimage_of U f O = V0 :/\: U.
    claim HV0Tx: V0 :e Tx.
    { exact (andEL (V0 :e Tx) (preimage_of U f O = V0 :/\: U) HV0conj). }
    claim HeqW: preimage_of U f O = V0 :/\: U.
    { exact (andER (V0 :e Tx) (preimage_of U f O = V0 :/\: U) HV0conj). }
    (** V0  U is open in X and separates y from x0. **)
    witness (V0 :/\: U).
    apply andI.
	    - (** (V0  U)  Tx and y  (V0  U) **)
	      apply andI.
	      + (** (V0  U)  Tx by closure under intersections **)
	        exact (topology_binintersect_closed X Tx V0 U Htop HV0Tx HUinTx).
	      + (** y  (V0  U) **)
	        rewrite <- HeqW.
	        prove y :e preimage_of U f O.
	        prove y :e {u :e U | apply_fun f u :e O}.
	        apply (SepI U (fun u:set => apply_fun f u :e O) y HyU).
	        exact HfyO.
	    - (** x0  (V0  U) **)
	      assume Hx0W: x0 :e (V0 :/\: U).
	      claim Hx0Pre: x0 :e preimage_of U f O.
	      { rewrite HeqW. exact Hx0W. }
	      claim Hfx0O: apply_fun f x0 :e O.
	      { exact (SepE2 U (fun u:set => apply_fun f u :e O) x0 Hx0Pre). }
	      claim HnotSing: apply_fun f x0 /:e {apply_fun f x0}.
	      { exact (setminusE2 V {apply_fun f x0} (apply_fun f x0) Hfx0O). }
	      exact (HnotSing (SingI (apply_fun f x0))).
	  - assume Hx0notU: ~(x0 :e U).
	    witness U.
	    apply andI.
	    - apply andI.
	      + exact (andER (topology_on X Tx) (U :e Tx) HUopen).
	      + exact HyU.
	    - exact Hx0notU.
}
claim Hcomp_open: X :\: {x0} :e Tx.
{ set UFam := {W :e Power X |
    exists y:set, y :e X /\ y <> x0 /\ W :e Tx /\ y :e W /\ x0 /:e W}.
  claim HUFamSub: UFam c= Tx.
  { let W. assume HW: W :e UFam.
    claim HWpred: exists y:set, y :e X /\ y <> x0 /\ W :e Tx /\ y :e W /\ x0 /:e W.
    { exact (SepE2 (Power X)
                   (fun W0:set => exists y:set, y :e X /\ y <> x0 /\ W0 :e Tx /\ y :e W0 /\ x0 /:e W0)
                   W
                   HW). }
    apply HWpred.
    let y. assume Hy_conj: y :e X /\ y <> x0 /\ W :e Tx /\ y :e W /\ x0 /:e W.
    claim H0: (((y :e X /\ y <> x0) /\ W :e Tx) /\ y :e W).
    { exact (andEL ((((y :e X /\ y <> x0) /\ W :e Tx) /\ y :e W)) (x0 /:e W) Hy_conj). }
    claim H1: (y :e X /\ y <> x0) /\ W :e Tx.
    { exact (andEL ((y :e X /\ y <> x0) /\ W :e Tx) (y :e W) H0). }
    exact (andER (y :e X /\ y <> x0) (W :e Tx) H1). }
  claim HUnionOpen: Union UFam :e Tx.
  { exact (topology_union_closed X Tx UFam Htop HUFamSub). }
  claim HUnionEq: Union UFam = X :\: {x0}.
  { apply set_ext.
    - let z. assume Hz: z :e Union UFam.
      prove z :e X :\: {x0}.
      apply (UnionE_impred UFam z Hz (z :e X :\: {x0})).
      let W. assume HzW: z :e W. assume HW: W :e UFam.
      claim HWpow: W :e Power X.
      { exact (SepE1 (Power X)
                     (fun W0:set => exists y:set, y :e X /\ y <> x0 /\ W0 :e Tx /\ y :e W0 /\ x0 /:e W0)
                     W
                     HW). }
      claim HWsubX: W c= X.
      { exact (PowerE X W HWpow). }
      claim HzX: z :e X.
      { exact (HWsubX z HzW). }
      claim HWpred: exists y:set, y :e X /\ y <> x0 /\ W :e Tx /\ y :e W /\ x0 /:e W.
      { exact (SepE2 (Power X)
                     (fun W0:set => exists y:set, y :e X /\ y <> x0 /\ W0 :e Tx /\ y :e W0 /\ x0 /:e W0)
                     W
                     HW). }
      apply HWpred.
      let y. assume Hy_conj: y :e X /\ y <> x0 /\ W :e Tx /\ y :e W /\ x0 /:e W.
      claim Hx0NotW: x0 /:e W.
      { exact (andER ((((y :e X /\ y <> x0) /\ W :e Tx) /\ y :e W)) (x0 /:e W) Hy_conj). }
      claim HznotSing: z /:e {x0}.
      { assume HzSing: z :e {x0}.
        claim Hzeq: z = x0.
        { exact (SingE x0 z HzSing). }
        claim Hx0W: x0 :e W.
        { rewrite <- Hzeq. exact HzW. }
        exact (Hx0NotW Hx0W). }
      exact (setminusI X {x0} z HzX HznotSing).
    - let z. assume Hz: z :e X :\: {x0}.
      prove z :e Union UFam.
      claim HzX: z :e X.
      { exact (setminusE1 X {x0} z Hz). }
      claim HznotSing: z /:e {x0}.
      { exact (setminusE2 X {x0} z Hz). }
      claim Hzneq: z <> x0.
      { assume Hzeq: z = x0.
        claim HzSing: z :e {x0}.
        { rewrite Hzeq. exact (SingI x0). }
        exact (HznotSing HzSing). }
      claim HexW: exists W:set, W :e Tx /\ z :e W /\ x0 /:e W.
      { exact (Hsep_x0 z HzX Hzneq). }
      apply HexW.
      let W. assume HWconj: W :e Tx /\ z :e W /\ x0 /:e W.
      claim HW0: W :e Tx /\ z :e W.
      { exact (andEL (W :e Tx /\ z :e W) (x0 /:e W) HWconj). }
      claim HWTx: W :e Tx.
      { exact (andEL (W :e Tx) (z :e W) HW0). }
      claim HzW: z :e W.
      { exact (andER (W :e Tx) (z :e W) HW0). }
      claim Hx0notW: x0 /:e W.
      { exact (andER (W :e Tx /\ z :e W) (x0 /:e W) HWconj). }
      claim HTsub: Tx c= Power X.
      { exact (topology_subset_axiom X Tx Htop). }
      claim HWpow: W :e Power X.
      { exact (HTsub W HWTx). }
      claim HWUFam: W :e UFam.
      { apply (SepI (Power X)
                    (fun W0:set => exists y:set, y :e X /\ y <> x0 /\ W0 :e Tx /\ y :e W0 /\ x0 /:e W0)
                    W
                    HWpow).
	        witness z.
	        (** show z witnesses the predicate **)
	        apply andI.
	        - (** (((z :e X /\ z <> x0) /\ W :e Tx) /\ z :e W) **)
	          apply andI.
	          + (** (z :e X /\ z <> x0) /\ W :e Tx **)
	            apply andI.
	            * (** z :e X /\ z <> x0 **)
	              apply andI.
	              - exact HzX.
	              - exact Hzneq.
	            * exact HWTx.
	          + exact HzW.
	        - exact Hx0notW.
	      }
      exact (UnionI UFam z W HzW HWUFam).
  }
  rewrite <- HUnionEq.
  exact HUnionOpen. }
prove topology_on X Tx /\ ({x0} c= X /\ exists U :e Tx, {x0} = X :\: U).
apply andI.
- exact Htop.
- apply andI.
  + exact HsingSub.
  + witness (X :\: {x0}).
	    apply andI.
	    * exact Hcomp_open.
	    * rewrite (setminus_setminus_eq X {x0} HsingSub).
	      reflexivity.
Qed.

(** from 50 Exercise 1: discrete space has dimension 0 **)
(** LATEX VERSION: Every discrete space has topological dimension 0. **)
Theorem ex50_1_discrete_dimension_0 : forall X Tx:set,
  Tx = discrete_topology X ->
  topology_on X Tx ->
  covering_dimension X Tx Empty.
let X Tx.
assume HTxdisc HTxtop.
admit. (** Exercise 1: discrete spaces have dimension 0 (placeholder) **)
Qed.

(** from 50 Exercise 2: connected T1 space with >1 point has dimension 1 **)
(** LATEX VERSION: Any connected T space with more than one point has dimension at least 1. **)
Theorem ex50_2_connected_T1_dimension_ge_1 : forall X Tx:set,
  connected_space X Tx ->
  T1_space X Tx ->
  (exists x y:set, x :e X /\ y :e X /\ x <> y) ->
  covering_dimension X Tx Empty -> False.
let X Tx.
assume Hconn HT1 Hdist Hdim0.
prove False.
admit. (** connected T1 with >1 point cannot have dimension 0 **)
Qed.

(** from 50 Exercise 3: topologist's sine curve has dimension 1 **)
(** LATEX VERSION: The topologist's sine curve has topological dimension 1. **)
Theorem ex50_3_sine_curve_dimension_1 : forall X Tx:set,
  X = R (** stub: actual definition of topologist's sine curve needed **) ->
  covering_dimension X Tx (Sing Empty).
let X Tx.
assume HX.
prove covering_dimension X Tx (Sing Empty).
admit. (** topologist's sine curve has dimension 1 **)
Qed.

(** from 50 Exercise 4: specific points in general position in R **)
(** LATEX VERSION: Show that 0, , , , and (1,1,1) are in general position in R. **)
Theorem ex50_4_points_general_position_R3 : forall zero e1 e2 e3 ones:set,
  zero = R (** stub: need ordered tuple (0,0,0) **) ->
  e1 = R (** stub: need ordered tuple (1,0,0) **) ->
  e2 = R (** stub: need ordered tuple (0,1,0) **) ->
  e3 = R (** stub: need ordered tuple (0,0,1) **) ->
  ones = R (** stub: need ordered tuple (1,1,1) **) ->
  general_position_RN (Sing (Sing (Sing Empty))) {zero, e1, e2, e3, ones}.
let zero e1 e2 e3 ones.
assume Hz He1 He2 He3 Hones.
prove general_position_RN (Sing (Sing (Sing Empty))) {zero, e1, e2, e3, ones}.
admit. (** verify geometric independence of these 5 points in R **)
Qed.

(** from 50 Exercise 5: embedding theorem for m=1 maps to linear graph **)
(** LATEX VERSION: For m=1, the map g in the embedding theorem proof maps X onto a linear graph in R. **)
Theorem ex50_5_embedding_m1_linear_graph : forall X Tx:set,
  covering_dimension X Tx (Sing Empty) ->
  compact_space X Tx ->
  metrizable X Tx ->
  exists g:set,
    (forall x:set, x :e X -> apply_fun g x :e (euclidean_space (Sing (Sing (Sing Empty))))) /\
    linear_graph (apply_fun g X) R_standard_topology.
let X Tx.
assume Hdim Hcomp Hmet.
prove exists g:set,
  (forall x:set, x :e X -> apply_fun g x :e (euclidean_space (Sing (Sing (Sing Empty))))) /\
  linear_graph (apply_fun g X) R_standard_topology.
admit. (** embedding for m=1 produces linear graph in R **)
Qed.

(** from 50 Exercise 6: locally compact Hausdorff with countable basis embeds in R^{2m+1} **)
(** LATEX VERSION: A locally compact Hausdorff space with countable basis whose compact subspaces have dimension m is homeomorphic to a closed subspace of R^{2m+1}. **)
(** FIXED: Dimension error - should be 2m+1, not m+1. **)
Theorem ex50_6_locally_compact_embeds : forall X Tx m:set,
  m :e omega ->
  locally_compact X Tx ->
  Hausdorff_space X Tx ->
  second_countable_space X Tx ->
  (forall C:set, C c= X -> compact_space C (subspace_topology X Tx C) -> covering_dimension C (subspace_topology X Tx C) m) ->
  exists N:set, exists e:set,
    N = add_nat (mul_nat two m) (Sing Empty) /\
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e /\
    closed_in (euclidean_space N) (euclidean_topology N) (apply_fun e X).
let X Tx m.
assume Hm Hlc HHaus Hsec Hdim.
prove exists N:set, exists e:set,
  N = add_nat (mul_nat two m) (Sing Empty) /\
  embedding_of X Tx (euclidean_space N) (euclidean_topology N) e /\
  closed_in (euclidean_space N) (euclidean_topology N) (apply_fun e X).
admit. (** extends Theorem 50.6 to locally compact case **)
Qed.

(** from 50 Exercise 7: every m-manifold embeds in R^{2m+1} as closed subspace **)
(** LATEX VERSION: Every m-manifold can be embedded in R^{2m+1} as a closed subspace. **)
(** FIXED: Dimension error - should be 2m+1, not m+1. **)
Theorem ex50_7_manifold_closed_embedding : forall X Tx m:set,
  m :e omega ->
  m_manifold X Tx ->
  exists N:set, exists e:set,
    N = add_nat (mul_nat two m) (Sing Empty) /\
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e /\
    closed_in (euclidean_space N) (euclidean_topology N) (apply_fun e X).
let X Tx m.
assume Hm Hman.
prove exists N:set, exists e:set,
  N = add_nat (mul_nat two m) (Sing Empty) /\
  embedding_of X Tx (euclidean_space N) (euclidean_topology N) e /\
  closed_in (euclidean_space N) (euclidean_topology N) (apply_fun e X).
admit. (** every manifold embeds in R^{2m+1} as closed subspace **)
Qed.

(** from 50 Exercise 8: sigma-compact Hausdorff with compact subspaces of dimension m has dimension m **)
(** LATEX VERSION: A -compact Hausdorff space whose compact subspaces have dimension m has dimension m. **)
(** FIXED: Union condition was wrong - had nonsensical filtering.
    Was: X = Union {C :e Fam | exists U:set, open_in X Tx U /\ C c= U}
         (filters Fam by "C is contained in some open set" - almost always true, nonsensical)
    Now: X = Union Fam
         (correctly: X is the union of the compact sets in Fam)
    Sigma-compact means: countable union of compact subsets. **)
Definition sigma_compact : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  exists Fam:set,
    countable Fam /\
    (forall C:set, C :e Fam -> C c= X /\ compact_space C (subspace_topology X Tx C)) /\
    X = Union Fam.

Theorem ex50_8_sigma_compact_dimension : forall X Tx m:set,
  m :e omega ->
  sigma_compact X Tx ->
  Hausdorff_space X Tx ->
  (forall C:set, C c= X -> compact_space C (subspace_topology X Tx C) -> covering_dimension C (subspace_topology X Tx C) m) ->
  covering_dimension X Tx m.
let X Tx m.
assume Hm Hsig HHaus Hdim.
prove covering_dimension X Tx m.
admit. (** sigma-compact: dimension equals sup of compact subspace dimensions **)
Qed.

(** from 50 Exercise 9: every m-manifold has dimension m **)
(** LATEX VERSION: Every m-manifold has topological dimension at most m. **)
Theorem ex50_9_manifold_dimension_le_m : forall X Tx m:set,
  m :e omega ->
  m_manifold X Tx ->
  covering_dimension X Tx m.
let X Tx m.
assume Hm Hman.
admit. (** requires full manifold dimension theory **)
Qed.

(** from 50 Exercise 10: closed subspace of R^N has dimension N **)
(** LATEX VERSION: Every closed subspace of R^N has topological dimension at most N. **)
Theorem ex50_10_closed_subspace_RN_dimension : forall X N:set,
  N :e omega ->
  X c= (euclidean_space N) ->
  closed_in (euclidean_space N) (euclidean_topology N) X ->
  covering_dimension X (subspace_topology (euclidean_space N) (euclidean_topology N) X) N.
let X N.
assume HN Hsub Hclosed.
admit. (** follows from Theorem 50.6 generalized **)
Qed.

(** from 50 Exercise 11: embedding in R^N characterization **)
(** LATEX VERSION: A space X can be embedded as a closed subspace of R^N for some N iff X is locally compact Hausdorff with countable basis and finite dimension. **)
Theorem ex50_11_embedding_characterization : forall X Tx:set,
  (exists N:set, exists e:set,
    N :e omega /\
    embedding_of X Tx (euclidean_space N) (euclidean_topology N) e /\
    closed_in (euclidean_space N) (euclidean_topology N) (apply_fun e X))
  <->
  (locally_compact X Tx /\ Hausdorff_space X Tx /\ second_countable_space X Tx /\ finite_dimensional_space X Tx).
let X Tx.
prove (exists N:set, exists e:set,
  N :e omega /\
  embedding_of X Tx (euclidean_space N) (euclidean_topology N) e /\
  closed_in (euclidean_space N) (euclidean_topology N) (apply_fun e X))
<->
(locally_compact X Tx /\ Hausdorff_space X Tx /\ second_countable_space X Tx /\ finite_dimensional_space X Tx).
admit. (** characterization of embeddable spaces: combines previous results **)
Qed.

(** from Supplementary Exercises Exercise 1: locally m-euclidean implies locally compact and locally metrizable **)
(** LATEX VERSION: If X is locally m-euclidean, then X is locally compact and locally metrizable. **)
(** helper: local metrizability **)
(** LATEX VERSION: A space is locally metrizable if each point has a neighborhood whose subspace topology is induced by some metric. **)
Definition locally_metrizable_space : set -> set -> prop := fun X Tx =>
  topology_on X Tx /\
  forall x:set, x :e X ->
    exists N:set, N :e Tx /\ x :e N /\
      exists d:set, metric_on N d /\ subspace_topology X Tx N = metric_topology N d.

Theorem supp_ex_locally_euclidean_1 : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  locally_compact X Tx /\ locally_metrizable_space X Tx.
let X Tx m.
assume Hloc.
admit. (** each point has nbhd homeomorphic to open in R^m, which is locally compact **)
Qed.

(** from Supplementary Exercises Exercise 2: implications among conditions **)
(** LATEX VERSION: For locally m-euclidean X: (i) compact Hausdorff  (ii) m-manifold  (iii) metrizable  (iv) normal  (v) Hausdorff. **)
Theorem supp_ex_locally_euclidean_2_i_implies_ii : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  compact_space X Tx ->
  Hausdorff_space X Tx ->
  m_manifold X Tx.
let X Tx m.
assume Hloc Hcomp HHaus.
prove m_manifold X Tx.
admit. (** need to show compact Hausdorff implies second countable **)
Qed.

Theorem supp_ex_locally_euclidean_2_ii_implies_iii : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  m_manifold X Tx ->
  metrizable X Tx.
let X Tx m.
assume Hloc Hman.
prove metrizable X Tx.
admit. (** manifold is second countable locally euclidean, hence metrizable **)
Qed.

Theorem supp_ex_locally_euclidean_2_iii_implies_iv : forall X Tx:set,
  metrizable X Tx ->
  normal_space X Tx.
let X Tx.
assume Hmet.
prove normal_space X Tx.
(** Unpack metrizability: Tx = metric_topology X d for some metric d. **)
apply Hmet.
let d. assume HdPair.
claim Hd: metric_on X d.
{ exact (andEL (metric_on X d) (metric_topology X d = Tx) HdPair). }
claim Heq: metric_topology X d = Tx.
{ exact (andER (metric_on X d) (metric_topology X d = Tx) HdPair). }
claim Hnorm: normal_space X (metric_topology X d).
{ exact (metrizable_spaces_normal X d Hd). }
rewrite <- Heq.
exact Hnorm.
Qed.

(** helper: normal + T1 implies Hausdorff **)
Theorem normal_T1_implies_Hausdorff : forall X Tx:set,
  normal_space X Tx -> T1_space X Tx -> Hausdorff_space X Tx.
let X Tx.
  assume Hnorm: normal_space X Tx.
  assume HT1: T1_space X Tx.
  prove Hausdorff_space X Tx.
  claim HT1part: one_point_sets_closed X Tx.
  { exact (andEL (one_point_sets_closed X Tx)
                 (forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty)
                 Hnorm). }
  claim HTx: topology_on X Tx.
  { exact (andEL (topology_on X Tx)
                 (forall x:set, x :e X -> closed_in X Tx {x})
                 HT1part). }
  claim Hsing:
  forall x:set, x :e X -> closed_in X Tx {x}.
  { exact (iffEL (T1_space X Tx)
               (forall x:set, x :e X -> closed_in X Tx {x})
               (lemma_T1_singletons_closed X Tx HTx) HT1). }
prove topology_on X Tx /\
      forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
        exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
apply andI.
- exact HTx.
- let x1 x2.
  assume Hx1X: x1 :e X.
  assume Hx2X: x2 :e X.
  assume Hneq: x1 <> x2.
  prove exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
  claim Hcl1: closed_in X Tx {x1}.
  { exact (Hsing x1 Hx1X). }
  claim Hcl2: closed_in X Tx {x2}.
  { exact (Hsing x2 Hx2X). }
  claim Hdisj: {x1} :/\: {x2} = Empty.
  { apply Empty_Subq_eq.
    let z. assume Hz: z :e {x1} :/\: {x2}.
    prove z :e Empty.
    claim Hz1: z :e {x1}.
    { exact (binintersectE1 {x1} {x2} z Hz). }
    claim Hz2: z :e {x2}.
    { exact (binintersectE2 {x1} {x2} z Hz). }
    claim Hzx1: z = x1.
    { exact (SingE x1 z Hz1). }
    claim Hzx2: z = x2.
    { exact (SingE x2 z Hz2). }
    claim Hx1x2: x1 = x2.
    { rewrite <- Hzx1. rewrite Hzx2. reflexivity. }
    apply FalseE.
    exact (Hneq Hx1x2). }
  claim Hsep:
    forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
      exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.
  { exact (andER (one_point_sets_closed X Tx)
                 (forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty)
                 Hnorm). }
  claim HexUV:
    exists U V:set, U :e Tx /\ V :e Tx /\ {x1} c= U /\ {x2} c= V /\ U :/\: V = Empty.
  { exact (Hsep {x1} {x2} Hcl1 Hcl2 Hdisj). }
  set U0 := Eps_i (fun U:set => exists V:set,
    U :e Tx /\ V :e Tx /\ {x1} c= U /\ {x2} c= V /\ U :/\: V = Empty).
  claim HU0ex: exists V:set,
    U0 :e Tx /\ V :e Tx /\ {x1} c= U0 /\ {x2} c= V /\ U0 :/\: V = Empty.
  { exact (Eps_i_ex (fun U:set => exists V:set,
      U :e Tx /\ V :e Tx /\ {x1} c= U /\ {x2} c= V /\ U :/\: V = Empty)
      HexUV). }
  set V0 := Eps_i (fun V:set => U0 :e Tx /\ V :e Tx /\ {x1} c= U0 /\ {x2} c= V /\ U0 :/\: V = Empty).
  claim HV0prop: U0 :e Tx /\ V0 :e Tx /\ {x1} c= U0 /\ {x2} c= V0 /\ U0 :/\: V0 = Empty.
  { exact (Eps_i_ex (fun V:set => U0 :e Tx /\ V :e Tx /\ {x1} c= U0 /\ {x2} c= V /\ U0 :/\: V = Empty)
      HU0ex). }
  (** Unpack the left-associative 5-way conjunction HV0prop into its components. **)
  claim H1234: (((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0) /\ {x2} c= V0).
  { exact (andEL ((((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0) /\ {x2} c= V0))
                 (U0 :/\: V0 = Empty)
                 HV0prop). }
  claim HdisjUV: U0 :/\: V0 = Empty.
  { exact (andER ((((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0) /\ {x2} c= V0))
                 (U0 :/\: V0 = Empty)
                 HV0prop). }
  claim H123: ((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0).
  { exact (andEL ((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0)
                 ({x2} c= V0)
                 H1234). }
  claim Hs2: {x2} c= V0.
  { exact (andER ((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0)
                 ({x2} c= V0)
                 H1234). }
  claim Hab: U0 :e Tx /\ V0 :e Tx.
  { exact (andEL (U0 :e Tx /\ V0 :e Tx)
                 ({x1} c= U0)
                 H123). }
  claim HU0Tx: U0 :e Tx.
  { exact (andEL (U0 :e Tx) (V0 :e Tx) Hab). }
  claim HV0Tx: V0 :e Tx.
  { exact (andER (U0 :e Tx) (V0 :e Tx) Hab). }
  claim Hs1: {x1} c= U0.
  { exact (andER (U0 :e Tx /\ V0 :e Tx)
                 ({x1} c= U0)
                 H123). }
  claim Hx1U0: x1 :e U0.
  { exact (Hs1 x1 (SingI x1)). }
  claim Hx2V0: x2 :e V0.
  { exact (Hs2 x2 (SingI x2)). }
  witness U0.
  witness V0.
  apply andI.
  - apply andI.
    + apply andI.
      * apply andI.
        { exact HU0Tx. }
        { exact HV0Tx. }
      * exact Hx1U0.
    + exact Hx2V0.
  - exact HdisjUV.
Qed.

(** from Supplementary Exercises Exercise 2: (iv) normal  (v) Hausdorff, for locally m-euclidean X **)
(** LATEX VERSION: For locally m-euclidean X, normality implies Hausdorff. **)
Theorem supp_ex_locally_euclidean_2_iv_implies_v : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  normal_space X Tx ->
  Hausdorff_space X Tx.
let X Tx m.
assume Hloc: locally_m_euclidean X Tx m.
assume Hnorm: normal_space X Tx.
prove Hausdorff_space X Tx.
claim HT1: T1_space X Tx.
{ exact (locally_m_euclidean_implies_T1 X Tx m Hloc). }
exact (normal_T1_implies_Hausdorff X Tx Hnorm HT1).
Qed.

(** from Supplementary Exercises Exercise 3: R is locally 1-euclidean satisfies (ii) not (i) **)
(** LATEX VERSION: R is locally 1-euclidean and satisfies (ii) but not (i). **)
Theorem supp_ex_locally_euclidean_3 :
  locally_m_euclidean R R_standard_topology (Sing Empty) /\
  m_manifold R R_standard_topology /\
  ~ (compact_space R R_standard_topology /\ Hausdorff_space R R_standard_topology).
prove locally_m_euclidean R R_standard_topology (Sing Empty) /\
      m_manifold R R_standard_topology /\
      ~ (compact_space R R_standard_topology /\ Hausdorff_space R R_standard_topology).
admit. (** R is locally 1-euclidean and a manifold, but not compact Hausdorff **)
Qed.

(** from Supplementary Exercises Exercise 4: RR dictionary order is locally 1-euclidean satisfies (iii) not (ii) **)
(** LATEX VERSION: RR in dictionary order topology is locally 1-euclidean and satisfies (iii) but not (ii). **)
Theorem supp_ex_locally_euclidean_4 : forall Tdict:set,
  Tdict = R (** stub: dictionary order topology on RR **) ->
  locally_m_euclidean R Tdict (Sing Empty) /\
  metrizable R Tdict /\
  ~ m_manifold R Tdict.
let Tdict.
assume HTdict.
prove locally_m_euclidean R Tdict (Sing Empty) /\
      metrizable R Tdict /\
      ~ m_manifold R Tdict.
admit. (** dictionary order topology: locally euclidean, metrizable, not second countable **)
Qed.

(** from Supplementary Exercises Exercise 5: long line is locally 1-euclidean satisfies (iv) not (iii) **)
(** LATEX VERSION: The long line is locally 1-euclidean and satisfies (iv) but not (iii). **)
Theorem supp_ex_locally_euclidean_5 : forall L TL:set,
  L = R (** stub: long line **) ->
  TL = R (** stub: long line topology **) ->
  locally_m_euclidean L TL (Sing Empty) /\
  normal_space L TL /\
  ~ metrizable L TL.
let L TL.
assume HL HTL.
prove locally_m_euclidean L TL (Sing Empty) /\
      normal_space L TL /\
      ~ metrizable L TL.
admit. (** long line: locally euclidean, normal, not metrizable **)
Qed.

(** from Supplementary Exercises Exercise 7: Hausdorff iff completely regular **)
(** LATEX VERSION: For locally m-euclidean X: X is Hausdorff iff X is completely regular. **)
Theorem supp_ex_locally_euclidean_7 : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  (Hausdorff_space X Tx <-> completely_regular_space X Tx).
let X Tx m.
assume Hloc.
prove Hausdorff_space X Tx <-> completely_regular_space X Tx.
admit. (** locally euclidean: Hausdorff iff completely regular **)
Qed.

(** from Supplementary Exercises Exercise 8: metrizable iff paracompact Hausdorff **)
(** LATEX VERSION: For locally m-euclidean X: X is metrizable iff X is paracompact Hausdorff. **)
Theorem supp_ex_locally_euclidean_8 : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  (metrizable X Tx <-> (paracompact_space X Tx /\ Hausdorff_space X Tx)).
let X Tx m.
assume Hloc.
prove metrizable X Tx <-> (paracompact_space X Tx /\ Hausdorff_space X Tx).
admit. (** locally euclidean: metrizable iff paracompact Hausdorff **)
Qed.

(** from Supplementary Exercises Exercise 9: metrizable implies components are m-manifolds **)
(** LATEX VERSION: If locally m-euclidean X is metrizable, then each component of X is an m-manifold. **)
(** stub: need proper definition of component **)
Theorem supp_ex_locally_euclidean_9 : forall X Tx m:set,
  locally_m_euclidean X Tx m ->
  metrizable X Tx ->
  forall C:set, C c= X ->
    m_manifold C (subspace_topology X Tx C).
let X Tx m.
assume Hloc Hmet.
let C.
assume HC.
prove m_manifold C (subspace_topology X Tx C).
admit. (** components of metrizable locally euclidean are manifolds **)
Qed.

(** helper: G_delta subset coded via countable intersection of open sets **)
Definition Gdelta_in : set -> set -> set -> prop := fun X Tx A =>
  exists Fam:set, countable Fam /\
    (forall U :e Fam, open_in X Tx U) /\
    Intersection_Fam X Fam = A.

(** helper: open map - images of open sets are open **)
(** FIXED: apply_fun f U doesn't make sense - apply_fun is for elements, not sets.
    Was: apply_fun f U (applying f to set U - wrong!)
    Now: image_of f U = {f(x) | x  U} (image of set U under f)
    Using image_of from line 15049. **)
Definition open_map : set -> set -> set -> set -> set -> prop :=
  fun X Tx Y Ty f =>
    topology_on X Tx /\ topology_on Y Ty /\ function_on f X Y /\
    forall U:set, U :e Tx -> image_of f U :e Ty.

(** helper: simple topological group structure **)
Definition topological_group : set -> set -> prop := fun G Tg =>
  topology_on G Tg /\
  exists mult inv e:set,
    function_on mult (setprod G G) G /\
    function_on inv G G /\
    e :e G /\
    continuous_map (setprod G G) (product_topology G Tg G Tg) G Tg mult /\
    continuous_map G Tg G Tg inv.

(** helper: separated subsets predicate **)
Definition separated_subsets : set -> set -> set -> set -> prop := fun X Tx A B =>
  closure_of X Tx A :/\: B = Empty /\ A :/\: closure_of X Tx B = Empty.

(** helper: completely normal predicate **)
Definition completely_normal_space : set -> set -> prop := fun X Tx =>
  normal_space X Tx /\
  (forall A B:set, separated_subsets X Tx A B -> exists U V:set,
      open_in X Tx U /\ open_in X Tx V /\ A c= U /\ B c= V /\ U :/\: V = Empty).

(** helper: linear continuum predicate (order topology with least upper bound property) **)
Definition linear_continuum : set -> set -> prop := fun X Tx =>
  exists less:set -> set -> prop,
    Tx = order_topology X /\
    (forall A:set, A c= X -> A <> Empty ->
      (exists upper:set, upper :e X /\ forall a:set, a :e A -> less a upper) ->
      exists lub:set, lub :e X /\
        (forall a:set, a :e A -> less a lub \/ a = lub) /\
        (forall bound:set, bound :e X -> (forall a:set, a :e A -> less a bound \/ a = bound) -> less lub bound \/ lub = bound)).

(** from 30 Exercise 1a: one-point sets are G_delta in first-countable T1 **)
(** LATEX VERSION: In a first-countable T space, every one-point set is a G_ set. **)
Theorem ex30_1a_onepoint_Gdelta_firstcountable_T1 : forall X Tx x:set,
  first_countable_space X Tx ->
  T1_space X Tx ->
  x :e X ->
  Gdelta_in X Tx (Sing x).
let X Tx x.
assume H1: first_countable_space X Tx.
assume H2: T1_space X Tx.
assume H3: x :e X.
prove Gdelta_in X Tx (Sing x).
admit. (** use countable neighborhood basis at x; each nbhd in T1 contains {x} by closedness **)
Qed.

(** from 30 Exercise 1b: space with G_delta points but not first-countable **)
(** LATEX VERSION: There exists a space where every one-point set is G_ but which doesn't satisfy the first countability axiom. **)
Theorem ex30_1b_Gdelta_not_firstcountable_exists :
  exists X:set, exists Tx:set,
    topology_on X Tx /\
    (forall x:set, x :e X -> Gdelta_in X Tx (Sing x)) /\
    ~ first_countable_space X Tx.
prove exists X:set, exists Tx:set,
  topology_on X Tx /\
  (forall x:set, x :e X -> Gdelta_in X Tx (Sing x)) /\
  ~ first_countable_space X Tx.
admit. (** cocountable topology on uncountable set; points are G_delta but no countable nbhd basis **)
Qed.
(** from 30 Exercise 2: every basis contains countable basis when space has one **)
(** LATEX VERSION: If X has a countable basis, then every basis for X contains a countable basis. **)
Theorem ex30_2_basis_contains_countable : forall X Tx:set, forall Basis:set,
  second_countable_space X Tx ->
  basis_on X Basis ->
  exists CountableSub:set,
    CountableSub c= Basis /\
    countable CountableSub /\
    basis_on X CountableSub.
let X Tx Basis.
assume H1: second_countable_space X Tx.
assume H2: basis_on X Basis.
prove exists CountableSub:set, CountableSub c= Basis /\ countable CountableSub /\ basis_on X CountableSub.
admit. (** let B be countable basis for Tx; for each B_i select basis element from Basis refining it **)
Qed.
(** from 30 Exercise 3: uncountable subset has uncountably many limit points **)
(** LATEX VERSION: If X has countable basis and A is uncountable subset, then uncountably many points of A are limit points. **)
(** FIXED: limit_point_of parameter order error.
    Was: limit_point_of x A X Tx (wrong order!)
    Now: limit_point_of X Tx A x (correct: space, topology, set, point)
    Definition at line 13115 has signature: X Tx A x. **)
Theorem ex30_3_uncountably_many_limit_points : forall X Tx A:set,
  second_countable_space X Tx ->
  A c= X ->
  ~ countable A ->
  ~ countable {x :e A | limit_point_of X Tx A x}.
let X Tx A.
assume H1: second_countable_space X Tx.
assume H2: A c= X.
assume H3: ~ countable A.
prove ~ countable {x :e A | limit_point_of X Tx A x}.
admit. (** if only countably many limit points, then A is union of countable set and isolated points; contradiction **)
Qed.
(** from 30 Exercise 4: compact metrizable implies second countable **)
(** LATEX VERSION: Every compact metrizable space has a countable basis. **)
Theorem ex30_4_compact_metrizable_second_countable : forall X Tx d:set,
  compact_space X Tx ->
  metrizable X Tx ->
  metric_on X d ->
  Tx = metric_topology X d ->
  second_countable_space X Tx.
let X Tx d.
assume H1: compact_space X Tx.
assume H2: metrizable X Tx.
assume H3: metric_on X d.
assume H4: Tx = metric_topology X d.
prove second_countable_space X Tx.
admit. (** for each n cover by 1/n-balls, extract finite subcover, countable union gives basis **)
Qed.
(** from 30 Exercise 5a: metrizable with countable dense has countable basis **)
(** LATEX VERSION: Every metrizable space with a countable dense subset has a countable basis. **)
Theorem ex30_5a_metrizable_countable_dense_second_countable : forall X Tx:set,
  metrizable X Tx ->
  (exists D:set, D c= X /\ countable D /\ dense_in D X Tx) ->
  second_countable_space X Tx.
let X Tx.
assume Hmet: metrizable X Tx.
assume Hdense: exists D:set, D c= X /\ countable D /\ dense_in D X Tx.
prove second_countable_space X Tx.
admit. (** balls of radius 1/n around dense points form countable basis **)
Qed.

(** from 30 Exercise 5b: metrizable Lindelof has countable basis **)
(** LATEX VERSION: Every metrizable Lindelf space has a countable basis. **)
Theorem ex30_5b_metrizable_Lindelof_second_countable : forall X Tx:set,
  metrizable X Tx ->
  Lindelof_space X Tx ->
  second_countable_space X Tx.
let X Tx.
assume Hmet: metrizable X Tx.
assume Hlin: Lindelof_space X Tx.
prove second_countable_space X Tx.
admit. (** use metric balls and Lindelof to get countable basis **)
Qed.
(** from 30 Exercise 6a: R_l not metrizable **)
(** LATEX VERSION: The Sorgenfrey line _ is not metrizable. **)
Theorem ex30_6a_Rl_not_metrizable :
  ~ metrizable R R_lower_limit_topology.
prove ~ metrizable R R_lower_limit_topology.
admit. (** R_l^2 has uncountable discrete subspace; metrizable would imply separable **)
Qed.

(** from 30 Exercise 6b: ordered square not metrizable **)
(** LATEX VERSION: The ordered square is not metrizable. **)
Theorem ex30_6b_ordered_square_not_metrizable : forall Tx:set,
  Tx = R (** stub: order topology on ordered square **) ->
  ~ metrizable ordered_square Tx.
let Tx.
assume H: Tx = R.
prove ~ metrizable ordered_square Tx.
admit. (** anti-diagonal is closed discrete uncountable; metrizable separable spaces have countable closed discrete subsets **)
Qed.
(** from 30 Exercise 7: countability axioms for S_Omega and Sbar_Omega **)
(** LATEX VERSION: Determine which countability axioms S_ and S_ satisfy. **)
(** stub: need actual topologies for S_Omega and Sbar_Omega **)
Theorem ex30_7_SOmega_Sbar_Omega_countability : forall Tx_SO Tx_SbarO:set,
  Tx_SO = SOmega_topology ->
  Tx_SbarO = SbarOmega_topology ->
  (first_countable_space S_Omega Tx_SO /\
   second_countable_space S_Omega Tx_SO /\
   Lindelof_space S_Omega Tx_SO /\
   (exists D:set, D c= S_Omega /\ countable D /\ dense_in D S_Omega Tx_SO)) /\
  (first_countable_space Sbar_Omega Tx_SbarO /\
   ~ second_countable_space Sbar_Omega Tx_SbarO /\
   ~ Lindelof_space Sbar_Omega Tx_SbarO /\
   ~ (exists D:set, D c= Sbar_Omega /\ countable D /\ dense_in D Sbar_Omega Tx_SbarO)).
let Tx_SO Tx_SbarO.
assume H1: Tx_SO = SOmega_topology.
assume H2: Tx_SbarO = SbarOmega_topology.
prove (first_countable_space S_Omega Tx_SO /\ second_countable_space S_Omega Tx_SO /\ Lindelof_space S_Omega Tx_SO /\ (exists D:set, D c= S_Omega /\ countable D /\ dense_in D S_Omega Tx_SO)) /\ (first_countable_space Sbar_Omega Tx_SbarO /\ ~ second_countable_space Sbar_Omega Tx_SbarO /\ ~ Lindelof_space Sbar_Omega Tx_SbarO /\ ~ (exists D:set, D c= Sbar_Omega /\ countable D /\ dense_in D Sbar_Omega Tx_SbarO)).
admit. (** S_Omega countable metrizable; Sbar_Omega first-countable but uncountable limit point blocks second-countability **)
Qed.
(** from 30 Exercise 8: countability axioms for R^omega uniform topology **)
(** LATEX VERSION: Determine which countability axioms R^ satisfies in the uniform topology. **)
Theorem ex30_8_Romega_uniform_countability : forall Tx:set,
  Tx = R (** stub: R^omega with uniform topology **) ->
  first_countable_space R Tx /\
  ~ second_countable_space R Tx /\
  ~ Lindelof_space R Tx /\
  ~ (exists D:set, D c= R /\ countable D /\ dense_in D R Tx).
let Tx.
assume H: Tx = R.
prove first_countable_space R Tx /\ ~ second_countable_space R Tx /\ ~ Lindelof_space R Tx /\ ~ (exists D:set, D c= R /\ countable D /\ dense_in D R Tx).
admit. (** uniform metric balls give countable nbhd basis; uncountable disjoint open sets show not Lindelof **)
Qed.
(** from 30 Exercise 9a: closed subspace of Lindelof is Lindelof **)
(** LATEX VERSION: If A is closed in Lindelf space X, then A is Lindelf. **)
Theorem ex30_9a_closed_Lindelof : forall X Tx A:set,
  Lindelof_space X Tx ->
  closed_in X Tx A ->
  Lindelof_space A (subspace_topology X Tx A).
let X Tx A.
assume Hlin: Lindelof_space X Tx.
assume Hcl: closed_in X Tx A.
prove Lindelof_space A (subspace_topology X Tx A).
admit. (** open cover of A extends to open cover of X, use Lindelof property **)
Qed.

(** from 30 Exercise 9b: dense subspace need not have countable dense subset **)
(** LATEX VERSION: If X has countable dense subset, dense subspace A need not have one. **)
Theorem ex30_9b_dense_not_countable_dense :
  exists X:set, exists Tx:set, exists A:set,
    (exists D:set, D c= X /\ countable D /\ dense_in D X Tx) /\
    dense_in A X Tx /\
    ~ (exists DA:set, DA c= A /\ countable DA /\ dense_in DA A (subspace_topology X Tx A)).
prove exists X:set, exists Tx:set, exists A:set,
  (exists D:set, D c= X /\ countable D /\ dense_in D X Tx) /\
  dense_in A X Tx /\
  ~ (exists DA:set, DA c= A /\ countable DA /\ dense_in DA A (subspace_topology X Tx A)).
admit. (** R with usual topology and Q dense; take A = R \ Q which is also dense but has no countable dense subset **)
Qed.

(** from 30 Exercise 10: countable product has countable dense if factors do **)
(** LATEX VERSION: If X is countable product of spaces with countable dense subsets, then X has one. **)
Theorem ex30_10_product_countable_dense : forall Idx:set, forall Fam:set,
  countable Idx ->
  (forall i:set, i :e Idx ->
    exists Xi:set, exists Txi:set, exists Di:set,
      apply_fun Fam i = setprod Xi Txi /\
      Di c= Xi /\ countable Di /\ dense_in Di Xi Txi) ->
  exists D:set,
    D c= product_space Idx Fam /\
    countable D /\
    dense_in D (product_space Idx Fam) (product_topology_full Idx Fam).
let Idx Fam.
assume H1: countable Idx.
assume H2: forall i:set, i :e Idx -> exists Xi:set, exists Txi:set, exists Di:set, apply_fun Fam i = setprod Xi Txi /\ Di c= Xi /\ countable Di /\ dense_in Di Xi Txi.
prove exists D:set, D c= product_space Idx Fam /\ countable D /\ dense_in D (product_space Idx Fam) (product_topology_full Idx Fam).
admit. (** countable product of countable sets is countable; finitely-varying sequences form dense subset **)
Qed.

(** from 30 Exercise 11a: continuous image of Lindelof is Lindelof **)
(** LATEX VERSION: If f:XY continuous and X Lindelf, then f(X) is Lindelf. **)
(** FIXED: apply_fun f X should be image_of f X (image of set under function).
    apply_fun is for elements; image_of is for sets. **)
Theorem ex30_11a_image_Lindelof : forall X Tx Y Ty f:set,
  Lindelof_space X Tx ->
  continuous_map X Tx Y Ty f ->
  Lindelof_space (image_of f X) (subspace_topology Y Ty (image_of f X)).
let X Tx Y Ty f.
assume H1: Lindelof_space X Tx.
assume H2: continuous_map X Tx Y Ty f.
prove Lindelof_space (image_of f X) (subspace_topology Y Ty (image_of f X)).
admit. (** preimages of cover give countable subcover; apply f to get countable subcover of image **)
Qed.

(** from 30 Exercise 11b: continuous image of separable is separable **)
(** LATEX VERSION: If f:XY continuous and X has countable dense subset, then f(X) does too. **)
(** FIXED: apply_fun f X should be image_of f X (same error pattern). **)
Theorem ex30_11b_image_countable_dense : forall X Tx Y Ty f:set,
  (exists D:set, D c= X /\ countable D /\ dense_in D X Tx) ->
  continuous_map X Tx Y Ty f ->
  exists Df:set,
    Df c= (image_of f X) /\
    countable Df /\
    dense_in Df (image_of f X) (subspace_topology Y Ty (image_of f X)).
let X Tx Y Ty f.
assume H1: exists D:set, D c= X /\ countable D /\ dense_in D X Tx.
assume H2: continuous_map X Tx Y Ty f.
prove exists Df:set, Df c= (image_of f X) /\ countable Df /\ dense_in Df (image_of f X) (subspace_topology Y Ty (image_of f X)).
admit. (** image f(D) is countable and dense in f(X) **)
Qed.

(** from 30 Exercise 12a: open continuous map preserves first countability **)
(** LATEX VERSION: If f:XY is continuous open and X first-countable, then f(X) is too. **)
(** FIXED: apply_fun f X should be image_of f X (same error pattern). **)
Theorem ex30_12a_open_map_first_countable : forall X Tx Y Ty f:set,
  first_countable_space X Tx ->
  continuous_map X Tx Y Ty f ->
  open_map X Tx Y Ty f ->
  first_countable_space (image_of f X) (subspace_topology Y Ty (image_of f X)).
let X Tx Y Ty f.
assume H1: first_countable_space X Tx.
assume H2: continuous_map X Tx Y Ty f.
assume H3: open_map X Tx Y Ty f.
prove first_countable_space (image_of f X) (subspace_topology Y Ty (image_of f X)).
admit. (** for y in f(X), take preimage x, use countable nbhd basis at x, apply f to get countable nbhd basis at y **)
Qed.

(** from 30 Exercise 12b: open continuous map preserves second countability **)
(** LATEX VERSION: If f:XY is continuous open and X second-countable, then f(X) is too. **)
(** FIXED: apply_fun f X should be image_of f X (same error pattern). **)
Theorem ex30_12b_open_map_second_countable : forall X Tx Y Ty f:set,
  second_countable_space X Tx ->
  continuous_map X Tx Y Ty f ->
  open_map X Tx Y Ty f ->
  second_countable_space (image_of f X) (subspace_topology Y Ty (image_of f X)).
let X Tx Y Ty f.
assume H1: second_countable_space X Tx.
assume H2: continuous_map X Tx Y Ty f.
assume H3: open_map X Tx Y Ty f.
prove second_countable_space (image_of f X) (subspace_topology Y Ty (image_of f X)).
admit. (** image of countable basis is countable basis for f(X) **)
Qed.
(** from 30 Exercise 13: disjoint open sets countable when dense countable **)
(** LATEX VERSION: If X has countable dense subset, every collection of disjoint open sets in X is countable. **)
Theorem ex30_13_disjoint_open_sets_countable : forall X Tx:set,
  (exists D:set, D c= X /\ countable D /\ dense_in D X Tx) ->
  forall Fam:set,
    (forall U:set, U :e Fam -> open_in X Tx U) ->
    (forall U V:set, U :e Fam -> V :e Fam -> U <> V -> U :/\: V = Empty) ->
    countable Fam.
let X Tx.
assume H1: exists D:set, D c= X /\ countable D /\ dense_in D X Tx.
let Fam.
assume H2: forall U:set, U :e Fam -> open_in X Tx U.
assume H3: forall U V:set, U :e Fam -> V :e Fam -> U <> V -> U :/\: V = Empty.
prove countable Fam.
admit. (** each open set contains point from D; disjointness gives injection from Fam to D **)
Qed.
(** from 30 Exercise 14: product of Lindelof with compact is Lindelof **)
(** LATEX VERSION: If X is Lindelf and Y is compact, then X  Y is Lindelf. **)
Theorem ex30_14_product_Lindelof_compact : forall X Tx Y Ty Idx Fam:set,
  Lindelof_space X Tx ->
  compact_space Y Ty ->
  Lindelof_space (product_space Idx Fam) (product_topology_full Idx Fam).
let X Tx Y Ty Idx Fam.
assume H1: Lindelof_space X Tx.
assume H2: compact_space Y Ty.
prove Lindelof_space (product_space Idx Fam) (product_topology_full Idx Fam).
admit. (** use tube lemma and Lindelof property of X **)
Qed.
(** from 30 Exercise 15: C(I,R) uniform topology countable dense subset **)
(** LATEX VERSION: C(I,) with uniform metric has countable dense subset and countable basis. **)
Theorem ex30_15_CI_has_countable_dense_uniform :
  exists CI:set, exists TCI:set, exists D:set,
    D c= CI /\ countable D /\ dense_in D CI TCI /\
    second_countable_space CI TCI.
prove exists CI:set, exists TCI:set, exists D:set, D c= CI /\ countable D /\ dense_in D CI TCI /\ second_countable_space CI TCI.
admit. (** piecewise linear functions with rational breakpoints dense in uniform metric; metrizable separable implies second-countable **)
Qed.
(** from 30 Exercise 16a: product R^I where I=[0,1] has countable dense subset **)
(** LATEX VERSION: The product space ^I, where I=[0,1], has a countable dense subset. **)
Theorem ex30_16a_product_RI_countable_dense :
  exists Idx:set, exists Fam:set, exists D:set,
    D c= product_space Idx Fam /\
    countable D /\
    dense_in D (product_space Idx Fam) (product_topology_full Idx Fam).
prove exists Idx:set, exists Fam:set, exists D:set, D c= product_space Idx Fam /\ countable D /\ dense_in D (product_space Idx Fam) (product_topology_full Idx Fam).
admit. (** finitely-varying sequences with rational values give countable dense subset **)
Qed.

(** from 30 Exercise 16b: large product does not have countable dense subset **)
(** LATEX VERSION: If J has cardinality > (), then ^J does not have countable dense subset. **)
Theorem ex30_16b_large_product_no_countable_dense : forall J:set,
  atleastp (Power omega) J ->
  ~ equip J (Power omega) ->
  forall Fam:set,
    ~ (exists D:set,
        D c= product_space J Fam /\
        countable D /\
        dense_in D (product_space J Fam) (product_topology_full J Fam)).
let J.
assume H1: atleastp (Power omega) J.
assume H2: ~ equip J (Power omega).
let Fam.
prove ~ (exists D:set, D c= product_space J Fam /\ countable D /\ dense_in D (product_space J Fam) (product_topology_full J Fam)).
admit. (** cardinality argument: dense subset must distinguish uncountably many functions **)
Qed.
(** from 30 Exercise 17: Romega box topology countability axioms **)
(** LATEX VERSION: ^ with box topology, subspace ^ (rationals ending in infinite 0s): which countability axioms? **)
Theorem ex30_17_Romega_box_countability :
  exists Romega:set, exists BoxTop:set, exists Qinf:set, exists SubTop:set,
    SubTop = subspace_topology Romega BoxTop Qinf /\
    (first_countable_space Qinf SubTop \/ ~ first_countable_space Qinf SubTop) /\
    (second_countable_space Qinf SubTop \/ ~ second_countable_space Qinf SubTop) /\
    (Lindelof_space Qinf SubTop \/ ~ Lindelof_space Qinf SubTop) /\
    ((exists D:set, D c= Qinf /\ countable D /\ dense_in D Qinf SubTop) \/
     ~ (exists D:set, D c= Qinf /\ countable D /\ dense_in D Qinf SubTop)).
prove exists Romega:set, exists BoxTop:set, exists Qinf:set, exists SubTop:set, SubTop = subspace_topology Romega BoxTop Qinf /\ (first_countable_space Qinf SubTop \/ ~ first_countable_space Qinf SubTop) /\ (second_countable_space Qinf SubTop \/ ~ second_countable_space Qinf SubTop) /\ (Lindelof_space Qinf SubTop \/ ~ Lindelof_space Qinf SubTop) /\ ((exists D:set, D c= Qinf /\ countable D /\ dense_in D Qinf SubTop) \/ ~ (exists D:set, D c= Qinf /\ countable D /\ dense_in D Qinf SubTop)).
admit. (** Q^inf has countable dense subset; first-countable; not second-countable **)
Qed.
(** from 30 Exercise 18: first-countable topological group with dense/Lindelof implies countable basis **)
(** LATEX VERSION: If G is first-countable topological group with countable dense subset or Lindelf, then G has countable basis. **)
Theorem ex30_18_first_countable_group_countable_basis : forall G Tg:set,
  topological_group G Tg ->
  first_countable_space G Tg ->
  ((exists D:set, D c= G /\ countable D /\ dense_in D G Tg) \/ Lindelof_space G Tg) ->
  second_countable_space G Tg.
let G Tg.
assume H1: topological_group G Tg.
assume H2: first_countable_space G Tg.
assume H3: (exists D:set, D c= G /\ countable D /\ dense_in D G Tg) \/ Lindelof_space G Tg.
prove second_countable_space G Tg.
admit. (** countable nbhd basis at identity translates to global basis via group multiplication **)
Qed.

(** from 31 Exercise 1: regular implies disjoint closures of neighborhoods **)
(** LATEX VERSION: If X is regular, every pair of points have neighborhoods whose closures are disjoint. **)
Theorem ex31_1_regular_disjoint_closure_neighborhoods : forall X Tx x y:set,
  regular_space X Tx ->
  x :e X ->
  y :e X ->
  x <> y ->
  exists U V:set,
    open_in X Tx U /\ open_in X Tx V /\
    x :e U /\ y :e V /\
    closure_of X Tx U :/\: closure_of X Tx V = Empty.
let X Tx x y.
assume Hreg: regular_space X Tx.
assume Hx: x :e X.
assume Hy: y :e X.
assume Hneq: x <> y.
prove exists U V:set, open_in X Tx U /\ open_in X Tx V /\ x :e U /\ y :e V /\ closure_of X Tx U :/\: closure_of X Tx V = Empty.
claim HT1: one_point_sets_closed X Tx.
{ exact (andEL (one_point_sets_closed X Tx)
               (forall x:set, x :e X ->
                 forall F:set, closed_in X Tx F -> x /:e F ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty)
               Hreg). }
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x:set, x :e X -> closed_in X Tx {x})
               HT1). }
claim Hsing: forall t:set, t :e X -> closed_in X Tx {t}.
{ exact (andER (topology_on X Tx)
               (forall x:set, x :e X -> closed_in X Tx {x})
               HT1). }
claim HSepReg:
  forall t:set, t :e X ->
    forall F:set, closed_in X Tx F -> t /:e F ->
      exists U V:set, U :e Tx /\ V :e Tx /\ t :e U /\ F c= V /\ U :/\: V = Empty.
{ exact (andER (one_point_sets_closed X Tx)
               (forall x:set, x :e X ->
                 forall F:set, closed_in X Tx F -> x /:e F ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty)
               Hreg). }

(** Step 1: separate x from the closed singleton {y}. **)
claim Hcly: closed_in X Tx {y}.
{ exact (Hsing y Hy). }
claim Hxnoty: x /:e {y}.
{ assume Hxy: x :e {y}.
  claim Heq: x = y.
  { exact (SingE y x Hxy). }
  exact (Hneq Heq). }
claim Hex1: exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ {y} c= V /\ U :/\: V = Empty.
{ exact (HSepReg x Hx {y} Hcly Hxnoty). }
set U0 := Eps_i (fun U:set => exists V:set, U :e Tx /\ V :e Tx /\ x :e U /\ {y} c= V /\ U :/\: V = Empty).
claim HU0ex: exists V:set, U0 :e Tx /\ V :e Tx /\ x :e U0 /\ {y} c= V /\ U0 :/\: V = Empty.
{ exact (Eps_i_ex (fun U:set => exists V:set, U :e Tx /\ V :e Tx /\ x :e U /\ {y} c= V /\ U :/\: V = Empty) Hex1). }
set V0 := Eps_i (fun V:set => U0 :e Tx /\ V :e Tx /\ x :e U0 /\ {y} c= V /\ U0 :/\: V = Empty).
claim HV0prop: U0 :e Tx /\ V0 :e Tx /\ x :e U0 /\ {y} c= V0 /\ U0 :/\: V0 = Empty.
{ exact (Eps_i_ex (fun V:set => U0 :e Tx /\ V :e Tx /\ x :e U0 /\ {y} c= V /\ U0 :/\: V = Empty) HU0ex). }
claim H1234: (((U0 :e Tx /\ V0 :e Tx) /\ x :e U0) /\ {y} c= V0).
{ exact (andEL ((((U0 :e Tx /\ V0 :e Tx) /\ x :e U0) /\ {y} c= V0))
               (U0 :/\: V0 = Empty)
               HV0prop). }
claim Hdisj0: U0 :/\: V0 = Empty.
{ exact (andER ((((U0 :e Tx /\ V0 :e Tx) /\ x :e U0) /\ {y} c= V0))
               (U0 :/\: V0 = Empty)
               HV0prop). }
claim H123: ((U0 :e Tx /\ V0 :e Tx) /\ x :e U0).
{ exact (andEL ((U0 :e Tx /\ V0 :e Tx) /\ x :e U0)
               ({y} c= V0)
               H1234). }
claim H12: (U0 :e Tx /\ V0 :e Tx).
{ exact (andEL (U0 :e Tx /\ V0 :e Tx) (x :e U0) H123). }
claim HU0Tx: U0 :e Tx.
{ exact (andEL (U0 :e Tx) (V0 :e Tx) H12). }
claim HV0Tx: V0 :e Tx.
{ exact (andER (U0 :e Tx) (V0 :e Tx) H12). }
claim HxU0: x :e U0.
{ exact (andER (U0 :e Tx /\ V0 :e Tx) (x :e U0) H123). }
claim HysubV0: {y} c= V0.
{ exact (andER ((U0 :e Tx /\ V0 :e Tx) /\ x :e U0) ({y} c= V0) H1234). }
claim HyV0: y :e V0.
{ apply HysubV0. exact (SingI y). }

(** Step 2: show y is not in closure(U0). **)
claim Hcliffy: y :e closure_of X Tx U0 <-> (forall W :e Tx, y :e W -> W :/\: U0 <> Empty).
{ exact (closure_characterization X Tx U0 y HTx Hy). }
claim HyNotClU0: y /:e closure_of X Tx U0.
  { assume HyCl: y :e closure_of X Tx U0.
    claim Hneigh: forall W :e Tx, y :e W -> W :/\: U0 <> Empty.
  { exact (iffEL (y :e closure_of X Tx U0)
                 (forall W :e Tx, y :e W -> W :/\: U0 <> Empty)
                 Hcliffy HyCl). }
  claim Hempty: V0 :/\: U0 = Empty.
  { apply Empty_Subq_eq.
    let z. assume Hz: z :e V0 :/\: U0.
    prove z :e Empty.
    claim HzV: z :e V0.
    { exact (binintersectE1 V0 U0 z Hz). }
    claim HzU: z :e U0.
    { exact (binintersectE2 V0 U0 z Hz). }
    claim HzUV: z :e U0 :/\: V0.
    { exact (binintersectI U0 V0 z HzU HzV). }
    claim HzE: z :e Empty.
    { rewrite <- Hdisj0. exact HzUV. }
    exact HzE. }
  claim Hcontr: V0 :/\: U0 <> Empty.
  { exact (Hneigh V0 HV0Tx HyV0). }
  apply FalseE.
  apply FalseE.
  apply FalseE.
  exact (Hcontr Hempty). }

(** Step 3: separate y from the closed set closure(U0). **)
claim HTsub: Tx c= Power X.
{ exact (topology_subset_axiom X Tx HTx). }
claim HU0sub: U0 c= X.
{ exact (PowerE X U0 (HTsub U0 HU0Tx)). }
claim HclU0: closed_in X Tx (closure_of X Tx U0).
{ exact (closure_is_closed X Tx U0 HTx HU0sub). }
claim Hex2: exists U V:set,
  U :e Tx /\ V :e Tx /\ y :e U /\ closure_of X Tx U0 c= V /\ U :/\: V = Empty.
{ exact (HSepReg y Hy (closure_of X Tx U0) HclU0 HyNotClU0). }
set U1 := Eps_i (fun U:set => exists V:set,
  U :e Tx /\ V :e Tx /\ y :e U /\ closure_of X Tx U0 c= V /\ U :/\: V = Empty).
claim HU1ex: exists V:set,
  U1 :e Tx /\ V :e Tx /\ y :e U1 /\ closure_of X Tx U0 c= V /\ U1 :/\: V = Empty.
{ exact (Eps_i_ex (fun U:set => exists V:set,
    U :e Tx /\ V :e Tx /\ y :e U /\ closure_of X Tx U0 c= V /\ U :/\: V = Empty) Hex2). }
set V1 := Eps_i (fun V:set => U1 :e Tx /\ V :e Tx /\ y :e U1 /\ closure_of X Tx U0 c= V /\ U1 :/\: V = Empty).
claim HV1prop: U1 :e Tx /\ V1 :e Tx /\ y :e U1 /\ closure_of X Tx U0 c= V1 /\ U1 :/\: V1 = Empty.
{ exact (Eps_i_ex (fun V:set => U1 :e Tx /\ V :e Tx /\ y :e U1 /\ closure_of X Tx U0 c= V /\ U1 :/\: V = Empty)
                  HU1ex). }
claim H1234b: (((U1 :e Tx /\ V1 :e Tx) /\ y :e U1) /\ closure_of X Tx U0 c= V1).
{ exact (andEL ((((U1 :e Tx /\ V1 :e Tx) /\ y :e U1) /\ closure_of X Tx U0 c= V1))
               (U1 :/\: V1 = Empty)
               HV1prop). }
claim Hdisj1: U1 :/\: V1 = Empty.
{ exact (andER ((((U1 :e Tx /\ V1 :e Tx) /\ y :e U1) /\ closure_of X Tx U0 c= V1))
               (U1 :/\: V1 = Empty)
               HV1prop). }
claim H123b: ((U1 :e Tx /\ V1 :e Tx) /\ y :e U1).
{ exact (andEL ((U1 :e Tx /\ V1 :e Tx) /\ y :e U1)
               (closure_of X Tx U0 c= V1)
               H1234b). }
claim H12b: (U1 :e Tx /\ V1 :e Tx).
{ exact (andEL (U1 :e Tx /\ V1 :e Tx) (y :e U1) H123b). }
claim HU1Tx: U1 :e Tx.
{ exact (andEL (U1 :e Tx) (V1 :e Tx) H12b). }
claim HV1Tx: V1 :e Tx.
{ exact (andER (U1 :e Tx) (V1 :e Tx) H12b). }
claim HyU1: y :e U1.
{ exact (andER (U1 :e Tx /\ V1 :e Tx) (y :e U1) H123b). }
claim HclU0subV1: closure_of X Tx U0 c= V1.
{ exact (andER ((U1 :e Tx /\ V1 :e Tx) /\ y :e U1) (closure_of X Tx U0 c= V1) H1234b). }

(** Step 4: closures of U0 and U1 are disjoint. **)
claim Hcliff: forall z:set, z :e X ->
  (z :e closure_of X Tx U1 <-> (forall W :e Tx, z :e W -> W :/\: U1 <> Empty)).
{ let z. assume HzX: z :e X.
  exact (closure_characterization X Tx U1 z HTx HzX). }
claim Hcldisj: closure_of X Tx U0 :/\: closure_of X Tx U1 = Empty.
{ apply Empty_Subq_eq.
  let z. assume Hz: z :e closure_of X Tx U0 :/\: closure_of X Tx U1.
  prove z :e Empty.
  claim Hzcl0: z :e closure_of X Tx U0.
  { exact (binintersectE1 (closure_of X Tx U0) (closure_of X Tx U1) z Hz). }
  claim Hzcl1: z :e closure_of X Tx U1.
  { exact (binintersectE2 (closure_of X Tx U0) (closure_of X Tx U1) z Hz). }
  claim HzX: z :e X.
  { exact (SepE1 X (fun z0:set => forall W:set, W :e Tx -> z0 :e W -> W :/\: U0 <> Empty) z Hzcl0). }
  claim HzV1: z :e V1.
  { apply HclU0subV1. exact Hzcl0. }
  claim Hneigh: forall W :e Tx, z :e W -> W :/\: U1 <> Empty.
  { exact (iffEL (z :e closure_of X Tx U1)
                 (forall W :e Tx, z :e W -> W :/\: U1 <> Empty)
                 (Hcliff z HzX) Hzcl1). }
  claim Hcontr: V1 :/\: U1 <> Empty.
  { exact (Hneigh V1 HV1Tx HzV1). }
  claim Hempty: V1 :/\: U1 = Empty.
  { apply Empty_Subq_eq.
    let w. assume Hw: w :e V1 :/\: U1.
    prove w :e Empty.
    claim HwV: w :e V1.
    { exact (binintersectE1 V1 U1 w Hw). }
    claim HwU: w :e U1.
    { exact (binintersectE2 V1 U1 w Hw). }
    claim HwUV: w :e U1 :/\: V1.
    { exact (binintersectI U1 V1 w HwU HwV). }
	    claim HwE: w :e Empty.
	    { rewrite <- Hdisj1. exact HwUV. }
	    exact HwE. }
	  apply FalseE.
	  exact (Hcontr Hempty). }

witness U0.
witness U1.
apply and5I.
- exact (andI (topology_on X Tx) (U0 :e Tx) HTx HU0Tx).
- exact (andI (topology_on X Tx) (U1 :e Tx) HTx HU1Tx).
- exact HxU0.
- exact HyU1.
- exact Hcldisj.
Qed.
(** from 31 Exercise 2: normal implies disjoint closures for closed sets **)
(** LATEX VERSION: If X is normal, every pair of disjoint closed sets have neighborhoods whose closures are disjoint. **)
Theorem ex31_2_normal_disjoint_closure_neighborhoods : forall X Tx A B:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  closed_in X Tx B ->
  A :/\: B = Empty ->
  exists U V:set,
    open_in X Tx U /\ open_in X Tx V /\
    A c= U /\ B c= V /\
    closure_of X Tx U :/\: closure_of X Tx V = Empty.
let X Tx A B.
assume Hnorm: normal_space X Tx.
assume HA: closed_in X Tx A.
assume HB: closed_in X Tx B.
assume Hdisj: A :/\: B = Empty.
prove exists U V:set, open_in X Tx U /\ open_in X Tx V /\ A c= U /\ B c= V /\ closure_of X Tx U :/\: closure_of X Tx V = Empty.
claim HT1: one_point_sets_closed X Tx.
{ exact (andEL (one_point_sets_closed X Tx)
               (forall A0 B0:set, closed_in X Tx A0 -> closed_in X Tx B0 -> A0 :/\: B0 = Empty ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ A0 c= U /\ B0 c= V /\ U :/\: V = Empty)
               Hnorm). }
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall x:set, x :e X -> closed_in X Tx {x})
               HT1). }
claim HSepNorm:
  forall A0 B0:set, closed_in X Tx A0 -> closed_in X Tx B0 -> A0 :/\: B0 = Empty ->
    exists U V:set, U :e Tx /\ V :e Tx /\ A0 c= U /\ B0 c= V /\ U :/\: V = Empty.
{ exact (andER (one_point_sets_closed X Tx)
               (forall A0 B0:set, closed_in X Tx A0 -> closed_in X Tx B0 -> A0 :/\: B0 = Empty ->
                 exists U V:set, U :e Tx /\ V :e Tx /\ A0 c= U /\ B0 c= V /\ U :/\: V = Empty)
               Hnorm). }

(** Step 1: separate A and B by disjoint open sets U0 and V0. **)
claim Hex1: exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.
{ exact (HSepNorm A B HA HB Hdisj). }
set U0 := Eps_i (fun U:set => exists V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty).
claim HU0ex: exists V:set, U0 :e Tx /\ V :e Tx /\ A c= U0 /\ B c= V /\ U0 :/\: V = Empty.
{ exact (Eps_i_ex (fun U:set => exists V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty) Hex1). }
set V0 := Eps_i (fun V:set => U0 :e Tx /\ V :e Tx /\ A c= U0 /\ B c= V /\ U0 :/\: V = Empty).
claim HV0prop: U0 :e Tx /\ V0 :e Tx /\ A c= U0 /\ B c= V0 /\ U0 :/\: V0 = Empty.
{ exact (Eps_i_ex (fun V:set => U0 :e Tx /\ V :e Tx /\ A c= U0 /\ B c= V /\ U0 :/\: V = Empty) HU0ex). }
claim H1234: (((U0 :e Tx /\ V0 :e Tx) /\ A c= U0) /\ B c= V0).
{ exact (andEL ((((U0 :e Tx /\ V0 :e Tx) /\ A c= U0) /\ B c= V0))
               (U0 :/\: V0 = Empty)
               HV0prop). }
claim Hdisj0: U0 :/\: V0 = Empty.
{ exact (andER ((((U0 :e Tx /\ V0 :e Tx) /\ A c= U0) /\ B c= V0))
               (U0 :/\: V0 = Empty)
               HV0prop). }
claim H123: ((U0 :e Tx /\ V0 :e Tx) /\ A c= U0).
{ exact (andEL ((U0 :e Tx /\ V0 :e Tx) /\ A c= U0)
               (B c= V0)
               H1234). }
claim H12: (U0 :e Tx /\ V0 :e Tx).
{ exact (andEL (U0 :e Tx /\ V0 :e Tx) (A c= U0) H123). }
claim HU0Tx: U0 :e Tx.
{ exact (andEL (U0 :e Tx) (V0 :e Tx) H12). }
claim HV0Tx: V0 :e Tx.
{ exact (andER (U0 :e Tx) (V0 :e Tx) H12). }
claim HAsub: A c= U0.
{ exact (andER (U0 :e Tx /\ V0 :e Tx) (A c= U0) H123). }
claim HBsub: B c= V0.
{ exact (andER ((U0 :e Tx /\ V0 :e Tx) /\ A c= U0) (B c= V0) H1234). }

(** Step 2: show B is disjoint from closure(U0). **)
claim HTsub: Tx c= Power X.
{ exact (topology_subset_axiom X Tx HTx). }
claim HU0subX: U0 c= X.
{ exact (PowerE X U0 (HTsub U0 HU0Tx)). }
claim HclU0: closed_in X Tx (closure_of X Tx U0).
{ exact (closure_is_closed X Tx U0 HTx HU0subX). }
claim Hcliff0: forall z:set, z :e X ->
  (z :e closure_of X Tx U0 <-> (forall W :e Tx, z :e W -> W :/\: U0 <> Empty)).
{ let z. assume HzX: z :e X.
  exact (closure_characterization X Tx U0 z HTx HzX). }
claim HclU0_disj_V0: closure_of X Tx U0 :/\: V0 = Empty.
{ apply Empty_Subq_eq.
  let z. assume Hz: z :e closure_of X Tx U0 :/\: V0.
  prove z :e Empty.
  claim Hzcl: z :e closure_of X Tx U0.
  { exact (binintersectE1 (closure_of X Tx U0) V0 z Hz). }
  claim HzV: z :e V0.
  { exact (binintersectE2 (closure_of X Tx U0) V0 z Hz). }
  claim HzX: z :e X.
  { exact (SepE1 X (fun z0:set => forall W:set, W :e Tx -> z0 :e W -> W :/\: U0 <> Empty) z Hzcl). }
  claim Hneigh: forall W :e Tx, z :e W -> W :/\: U0 <> Empty.
  { exact (iffEL (z :e closure_of X Tx U0)
                 (forall W :e Tx, z :e W -> W :/\: U0 <> Empty)
                 (Hcliff0 z HzX) Hzcl). }
  claim Hcontr: V0 :/\: U0 <> Empty.
  { exact (Hneigh V0 HV0Tx HzV). }
  claim Hempty: V0 :/\: U0 = Empty.
  { apply Empty_Subq_eq.
    let w. assume Hw: w :e V0 :/\: U0.
    prove w :e Empty.
    claim HwV: w :e V0.
    { exact (binintersectE1 V0 U0 w Hw). }
    claim HwU: w :e U0.
    { exact (binintersectE2 V0 U0 w Hw). }
    claim HwUV: w :e U0 :/\: V0.
    { exact (binintersectI U0 V0 w HwU HwV). }
    claim HwE: w :e Empty.
    { rewrite <- Hdisj0. exact HwUV. }
    exact HwE. }
  apply FalseE.
  exact (Hcontr Hempty). }
claim HBcldisj: B :/\: closure_of X Tx U0 = Empty.
{ apply Empty_Subq_eq.
  let z. assume Hz: z :e B :/\: closure_of X Tx U0.
  prove z :e Empty.
  claim HzB: z :e B.
  { exact (binintersectE1 B (closure_of X Tx U0) z Hz). }
  claim Hzcl: z :e closure_of X Tx U0.
  { exact (binintersectE2 B (closure_of X Tx U0) z Hz). }
  claim HzV0: z :e V0.
  { apply HBsub. exact HzB. }
  claim HzclV0: z :e closure_of X Tx U0 :/\: V0.
  { exact (binintersectI (closure_of X Tx U0) V0 z Hzcl HzV0). }
  claim HzE: z :e Empty.
  { rewrite <- HclU0_disj_V0. exact HzclV0. }
  exact HzE. }

(** Step 3: separate B from closure(U0), then conclude closures are disjoint. **)
claim Hex2: exists U V:set,
  U :e Tx /\ V :e Tx /\ B c= U /\ closure_of X Tx U0 c= V /\ U :/\: V = Empty.
{ exact (HSepNorm B (closure_of X Tx U0) HB HclU0 HBcldisj). }
set U1 := Eps_i (fun U:set => exists V:set,
  U :e Tx /\ V :e Tx /\ B c= U /\ closure_of X Tx U0 c= V /\ U :/\: V = Empty).
claim HU1ex: exists V:set,
  U1 :e Tx /\ V :e Tx /\ B c= U1 /\ closure_of X Tx U0 c= V /\ U1 :/\: V = Empty.
{ exact (Eps_i_ex (fun U:set => exists V:set,
    U :e Tx /\ V :e Tx /\ B c= U /\ closure_of X Tx U0 c= V /\ U :/\: V = Empty) Hex2). }
set V1 := Eps_i (fun V:set => U1 :e Tx /\ V :e Tx /\ B c= U1 /\ closure_of X Tx U0 c= V /\ U1 :/\: V = Empty).
claim HV1prop: U1 :e Tx /\ V1 :e Tx /\ B c= U1 /\ closure_of X Tx U0 c= V1 /\ U1 :/\: V1 = Empty.
{ exact (Eps_i_ex (fun V:set => U1 :e Tx /\ V :e Tx /\ B c= U1 /\ closure_of X Tx U0 c= V /\ U1 :/\: V = Empty)
                  HU1ex). }
claim H1234b: (((U1 :e Tx /\ V1 :e Tx) /\ B c= U1) /\ closure_of X Tx U0 c= V1).
{ exact (andEL ((((U1 :e Tx /\ V1 :e Tx) /\ B c= U1) /\ closure_of X Tx U0 c= V1))
               (U1 :/\: V1 = Empty)
               HV1prop). }
claim Hdisj1: U1 :/\: V1 = Empty.
{ exact (andER ((((U1 :e Tx /\ V1 :e Tx) /\ B c= U1) /\ closure_of X Tx U0 c= V1))
               (U1 :/\: V1 = Empty)
               HV1prop). }
claim H123b: ((U1 :e Tx /\ V1 :e Tx) /\ B c= U1).
{ exact (andEL ((U1 :e Tx /\ V1 :e Tx) /\ B c= U1)
               (closure_of X Tx U0 c= V1)
               H1234b). }
claim H12b: (U1 :e Tx /\ V1 :e Tx).
{ exact (andEL (U1 :e Tx /\ V1 :e Tx) (B c= U1) H123b). }
claim HU1Tx: U1 :e Tx.
{ exact (andEL (U1 :e Tx) (V1 :e Tx) H12b). }
claim HV1Tx: V1 :e Tx.
{ exact (andER (U1 :e Tx) (V1 :e Tx) H12b). }
claim HBsubU1: B c= U1.
{ exact (andER (U1 :e Tx /\ V1 :e Tx) (B c= U1) H123b). }
claim HclU0subV1: closure_of X Tx U0 c= V1.
{ exact (andER ((U1 :e Tx /\ V1 :e Tx) /\ B c= U1) (closure_of X Tx U0 c= V1) H1234b). }

claim Hcliff1: forall z:set, z :e X ->
  (z :e closure_of X Tx U1 <-> (forall W :e Tx, z :e W -> W :/\: U1 <> Empty)).
{ let z. assume HzX: z :e X.
  exact (closure_characterization X Tx U1 z HTx HzX). }
claim Hcldisj: closure_of X Tx U0 :/\: closure_of X Tx U1 = Empty.
{ apply Empty_Subq_eq.
  let z. assume Hz: z :e closure_of X Tx U0 :/\: closure_of X Tx U1.
  prove z :e Empty.
  claim Hzcl0: z :e closure_of X Tx U0.
  { exact (binintersectE1 (closure_of X Tx U0) (closure_of X Tx U1) z Hz). }
  claim Hzcl1: z :e closure_of X Tx U1.
  { exact (binintersectE2 (closure_of X Tx U0) (closure_of X Tx U1) z Hz). }
  claim HzX: z :e X.
  { exact (SepE1 X (fun z0:set => forall W:set, W :e Tx -> z0 :e W -> W :/\: U0 <> Empty) z Hzcl0). }
  claim HzV1: z :e V1.
  { apply HclU0subV1. exact Hzcl0. }
  claim Hneigh: forall W :e Tx, z :e W -> W :/\: U1 <> Empty.
  { exact (iffEL (z :e closure_of X Tx U1)
                 (forall W :e Tx, z :e W -> W :/\: U1 <> Empty)
                 (Hcliff1 z HzX) Hzcl1). }
  claim Hcontr: V1 :/\: U1 <> Empty.
  { exact (Hneigh V1 HV1Tx HzV1). }
  claim Hempty: V1 :/\: U1 = Empty.
  { apply Empty_Subq_eq.
    let w. assume Hw: w :e V1 :/\: U1.
    prove w :e Empty.
    claim HwV: w :e V1.
    { exact (binintersectE1 V1 U1 w Hw). }
    claim HwU: w :e U1.
    { exact (binintersectE2 V1 U1 w Hw). }
    claim HwUV: w :e U1 :/\: V1.
    { exact (binintersectI U1 V1 w HwU HwV). }
    claim HwE: w :e Empty.
    { rewrite <- Hdisj1. exact HwUV. }
    exact HwE. }
  apply FalseE.
  exact (Hcontr Hempty). }

witness U0.
witness U1.
apply and5I.
- exact (andI (topology_on X Tx) (U0 :e Tx) HTx HU0Tx).
- exact (andI (topology_on X Tx) (U1 :e Tx) HTx HU1Tx).
- exact HAsub.
- exact HBsubU1.
- exact Hcldisj.
Qed.
(** from 31 Exercise 3: every order topology regular **)
(** LATEX VERSION: Every order topology is regular. **)
Theorem ex31_3_order_topology_regular : forall X:set,
  regular_space X (order_topology X).
let X.
prove regular_space X (order_topology X).
admit. (** order topologies are regular by construction **)
Qed.
(** from 31 Exercise 4: comparing finer/coarser separation axioms **)
(** LATEX VERSION: Let X have two topologies T and T', with T'  T. Compare separation properties. **)
Theorem ex31_4_comparison_topologies_separation : forall X Tx Tx':set,
  topology_on X Tx ->
  topology_on X Tx' ->
  Tx c= Tx' ->
  ((Hausdorff_space X Tx -> Hausdorff_space X Tx') /\
   (regular_space X Tx -> Hausdorff_space X Tx') /\
   (normal_space X Tx -> Hausdorff_space X Tx')).
let X Tx Tx'.
assume HTx: topology_on X Tx.
assume HTx': topology_on X Tx'.
assume Hfiner: Tx c= Tx'.
claim Hhaus_finer: Hausdorff_space X Tx -> Hausdorff_space X Tx'.
{ assume HH: Hausdorff_space X Tx.
  prove Hausdorff_space X Tx'.
  claim HSep: forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
    exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
  { exact (andER (topology_on X Tx)
                 (forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty)
                 HH). }
  prove topology_on X Tx' /\
        forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
          exists U V:set, U :e Tx' /\ V :e Tx' /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
  apply andI.
  - exact HTx'.
  - let x1 x2.
    assume Hx1X: x1 :e X.
    assume Hx2X: x2 :e X.
    assume Hneq: x1 <> x2.
    prove exists U V:set, U :e Tx' /\ V :e Tx' /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
    claim Hex: exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
    { exact (HSep x1 x2 Hx1X Hx2X Hneq). }
    set U0 := Eps_i (fun U:set => exists V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty).
    claim HU0ex: exists V:set, U0 :e Tx /\ V :e Tx /\ x1 :e U0 /\ x2 :e V /\ U0 :/\: V = Empty.
    { exact (Eps_i_ex (fun U:set => exists V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty) Hex). }
    set V0 := Eps_i (fun V:set => U0 :e Tx /\ V :e Tx /\ x1 :e U0 /\ x2 :e V /\ U0 :/\: V = Empty).
    claim HV0prop: U0 :e Tx /\ V0 :e Tx /\ x1 :e U0 /\ x2 :e V0 /\ U0 :/\: V0 = Empty.
    { exact (Eps_i_ex (fun V:set => U0 :e Tx /\ V :e Tx /\ x1 :e U0 /\ x2 :e V /\ U0 :/\: V = Empty) HU0ex). }
    claim H1234: (((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) /\ x2 :e V0).
    { exact (andEL ((((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) /\ x2 :e V0))
                   (U0 :/\: V0 = Empty)
                   HV0prop). }
    claim HdisjUV: U0 :/\: V0 = Empty.
    { exact (andER ((((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) /\ x2 :e V0))
                   (U0 :/\: V0 = Empty)
                   HV0prop). }
    claim H123: ((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0).
    { exact (andEL ((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0)
                   (x2 :e V0)
                   H1234). }
    claim H12: (U0 :e Tx /\ V0 :e Tx).
    { exact (andEL (U0 :e Tx /\ V0 :e Tx)
                   (x1 :e U0)
                   H123). }
    claim HUx1: x1 :e U0.
    { exact (andER (U0 :e Tx /\ V0 :e Tx)
                   (x1 :e U0)
                   H123). }
    claim HVx2: x2 :e V0.
    { exact (andER ((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0)
                   (x2 :e V0)
                   H1234). }
    claim HU0Tx': U0 :e Tx'.
    { apply Hfiner. exact (andEL (U0 :e Tx) (V0 :e Tx) H12). }
    claim HV0Tx': V0 :e Tx'.
    { apply Hfiner. exact (andER (U0 :e Tx) (V0 :e Tx) H12). }
    witness U0.
    witness V0.
    apply and5I.
    - exact HU0Tx'.
    - exact HV0Tx'.
    - exact HUx1.
    - exact HVx2.
    - exact HdisjUV. }
apply and3I.
- exact Hhaus_finer.
- prove regular_space X Tx -> Hausdorff_space X Tx'.
  assume Hreg: regular_space X Tx.
  claim HT1: one_point_sets_closed X Tx.
  { exact (andEL (one_point_sets_closed X Tx)
                 (forall x:set, x :e X ->
                   forall F:set, closed_in X Tx F -> x /:e F ->
                     exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty)
                 Hreg). }
  claim Hsing: forall x:set, x :e X -> closed_in X Tx {x}.
  { exact (andER (topology_on X Tx) (forall x:set, x :e X -> closed_in X Tx {x}) HT1). }
  claim HSepReg:
    forall x:set, x :e X ->
      forall F:set, closed_in X Tx F -> x /:e F ->
        exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty.
  { exact (andER (one_point_sets_closed X Tx)
                 (forall x:set, x :e X ->
                   forall F:set, closed_in X Tx F -> x /:e F ->
                     exists U V:set, U :e Tx /\ V :e Tx /\ x :e U /\ F c= V /\ U :/\: V = Empty)
                 Hreg). }
  claim HHcoarse: Hausdorff_space X Tx.
  { prove topology_on X Tx /\
          forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
            exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
    apply andI.
    - exact (andEL (topology_on X Tx) (forall x:set, x :e X -> closed_in X Tx {x}) HT1).
    - let x1 x2.
      assume Hx1X: x1 :e X.
      assume Hx2X: x2 :e X.
      assume Hneq: x1 <> x2.
      prove exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
      claim Hcl: closed_in X Tx {x2}.
      { exact (Hsing x2 Hx2X). }
      claim Hx1not: x1 /:e {x2}.
      { assume Hx1in: x1 :e {x2}.
        claim Heq: x1 = x2.
        { exact (SingE x2 x1 Hx1in). }
        exact (Hneq Heq). }
      claim Hex: exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ {x2} c= V /\ U :/\: V = Empty.
      { exact (HSepReg x1 Hx1X {x2} Hcl Hx1not). }
      set U0 := Eps_i (fun U:set => exists V:set,
        U :e Tx /\ V :e Tx /\ x1 :e U /\ {x2} c= V /\ U :/\: V = Empty).
      claim HU0ex: exists V:set,
        U0 :e Tx /\ V :e Tx /\ x1 :e U0 /\ {x2} c= V /\ U0 :/\: V = Empty.
      { exact (Eps_i_ex (fun U:set => exists V:set,
          U :e Tx /\ V :e Tx /\ x1 :e U /\ {x2} c= V /\ U :/\: V = Empty) Hex). }
      set V0 := Eps_i (fun V:set => U0 :e Tx /\ V :e Tx /\ x1 :e U0 /\ {x2} c= V /\ U0 :/\: V = Empty).
      claim HV0prop: U0 :e Tx /\ V0 :e Tx /\ x1 :e U0 /\ {x2} c= V0 /\ U0 :/\: V0 = Empty.
      { exact (Eps_i_ex (fun V:set => U0 :e Tx /\ V :e Tx /\ x1 :e U0 /\ {x2} c= V /\ U0 :/\: V = Empty)
                        HU0ex). }
      claim H1234: (((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) /\ {x2} c= V0).
      { exact (andEL ((((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) /\ {x2} c= V0))
                     (U0 :/\: V0 = Empty)
                     HV0prop). }
      claim HdisjUV: U0 :/\: V0 = Empty.
      { exact (andER ((((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) /\ {x2} c= V0))
                     (U0 :/\: V0 = Empty)
                     HV0prop). }
      claim H123: ((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0).
      { exact (andEL ((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0)
                     ({x2} c= V0)
                     H1234). }
      claim H12: (U0 :e Tx /\ V0 :e Tx).
      { exact (andEL (U0 :e Tx /\ V0 :e Tx) (x1 :e U0) H123). }
      claim HUx1: x1 :e U0.
      { exact (andER (U0 :e Tx /\ V0 :e Tx) (x1 :e U0) H123). }
      claim HVsub: {x2} c= V0.
      { exact (andER ((U0 :e Tx /\ V0 :e Tx) /\ x1 :e U0) ({x2} c= V0) H1234). }
      claim Hx2V0: x2 :e V0.
      { apply HVsub. exact (SingI x2). }
      witness U0.
      witness V0.
      apply and5I.
      - exact (andEL (U0 :e Tx) (V0 :e Tx) H12).
      - exact (andER (U0 :e Tx) (V0 :e Tx) H12).
      - exact HUx1.
      - exact Hx2V0.
      - exact HdisjUV. }
  exact (Hhaus_finer HHcoarse).
- prove normal_space X Tx -> Hausdorff_space X Tx'.
  assume Hnorm: normal_space X Tx.
  claim HT1: one_point_sets_closed X Tx.
  { exact (andEL (one_point_sets_closed X Tx)
                 (forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty)
                 Hnorm). }
  claim Hsing: forall x:set, x :e X -> closed_in X Tx {x}.
  { exact (andER (topology_on X Tx) (forall x:set, x :e X -> closed_in X Tx {x}) HT1). }
  claim HSepNorm:
    forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
      exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty.
  { exact (andER (one_point_sets_closed X Tx)
                 (forall A B:set, closed_in X Tx A -> closed_in X Tx B -> A :/\: B = Empty ->
                   exists U V:set, U :e Tx /\ V :e Tx /\ A c= U /\ B c= V /\ U :/\: V = Empty)
                 Hnorm). }
  claim HHcoarse: Hausdorff_space X Tx.
  { prove topology_on X Tx /\
          forall x1 x2:set, x1 :e X -> x2 :e X -> x1 <> x2 ->
            exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
    apply andI.
    - exact (andEL (topology_on X Tx) (forall x:set, x :e X -> closed_in X Tx {x}) HT1).
    - let x1 x2.
      assume Hx1X: x1 :e X.
      assume Hx2X: x2 :e X.
      assume Hneq: x1 <> x2.
      prove exists U V:set, U :e Tx /\ V :e Tx /\ x1 :e U /\ x2 :e V /\ U :/\: V = Empty.
      claim Hcl1: closed_in X Tx {x1}.
      { exact (Hsing x1 Hx1X). }
      claim Hcl2: closed_in X Tx {x2}.
      { exact (Hsing x2 Hx2X). }
      claim Hdisj: {x1} :/\: {x2} = Empty.
      { apply Empty_Subq_eq.
        let z. assume Hz: z :e {x1} :/\: {x2}.
        prove z :e Empty.
        claim Hz1: z :e {x1}.
        { exact (binintersectE1 {x1} {x2} z Hz). }
        claim Hz2: z :e {x2}.
        { exact (binintersectE2 {x1} {x2} z Hz). }
        claim Hzx1: z = x1.
        { exact (SingE x1 z Hz1). }
        claim Hzx2: z = x2.
        { exact (SingE x2 z Hz2). }
        claim Hx1x2: x1 = x2.
        { rewrite <- Hzx1. rewrite Hzx2. reflexivity. }
        apply FalseE.
        exact (Hneq Hx1x2). }
      claim Hex: exists U V:set,
        U :e Tx /\ V :e Tx /\ {x1} c= U /\ {x2} c= V /\ U :/\: V = Empty.
      { exact (HSepNorm {x1} {x2} Hcl1 Hcl2 Hdisj). }
      set U0 := Eps_i (fun U:set => exists V:set,
        U :e Tx /\ V :e Tx /\ {x1} c= U /\ {x2} c= V /\ U :/\: V = Empty).
      claim HU0ex: exists V:set,
        U0 :e Tx /\ V :e Tx /\ {x1} c= U0 /\ {x2} c= V /\ U0 :/\: V = Empty.
      { exact (Eps_i_ex (fun U:set => exists V:set,
          U :e Tx /\ V :e Tx /\ {x1} c= U /\ {x2} c= V /\ U :/\: V = Empty) Hex). }
      set V0 := Eps_i (fun V:set => U0 :e Tx /\ V :e Tx /\ {x1} c= U0 /\ {x2} c= V /\ U0 :/\: V = Empty).
      claim HV0prop: U0 :e Tx /\ V0 :e Tx /\ {x1} c= U0 /\ {x2} c= V0 /\ U0 :/\: V0 = Empty.
      { exact (Eps_i_ex (fun V:set => U0 :e Tx /\ V :e Tx /\ {x1} c= U0 /\ {x2} c= V /\ U0 :/\: V = Empty)
                        HU0ex). }
      claim H1234: (((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0) /\ {x2} c= V0).
      { exact (andEL ((((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0) /\ {x2} c= V0))
                     (U0 :/\: V0 = Empty)
                     HV0prop). }
      claim HdisjUV: U0 :/\: V0 = Empty.
      { exact (andER ((((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0) /\ {x2} c= V0))
                     (U0 :/\: V0 = Empty)
                     HV0prop). }
      claim H123: ((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0).
      { exact (andEL ((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0)
                     ({x2} c= V0)
                     H1234). }
      claim H12: (U0 :e Tx /\ V0 :e Tx).
      { exact (andEL (U0 :e Tx /\ V0 :e Tx) ({x1} c= U0) H123). }
      claim Hsub1: {x1} c= U0.
      { exact (andER (U0 :e Tx /\ V0 :e Tx) ({x1} c= U0) H123). }
      claim Hsub2: {x2} c= V0.
      { exact (andER ((U0 :e Tx /\ V0 :e Tx) /\ {x1} c= U0) ({x2} c= V0) H1234). }
      claim Hx1U0: x1 :e U0.
      { apply Hsub1. exact (SingI x1). }
      claim Hx2V0: x2 :e V0.
      { apply Hsub2. exact (SingI x2). }
      witness U0.
      witness V0.
      apply and5I.
      - exact (andEL (U0 :e Tx) (V0 :e Tx) H12).
      - exact (andER (U0 :e Tx) (V0 :e Tx) H12).
      - exact Hx1U0.
      - exact Hx2V0.
      - exact HdisjUV. }
  exact (Hhaus_finer HHcoarse).
Qed.
(** from 31 Exercise 5: equalizer of continuous maps into Hausdorff is closed **)
(** LATEX VERSION: Let f,g: X  Y be continuous, Y Hausdorff. Then {x | f(x) = g(x)} is closed in X. **)
Theorem ex31_5_equalizer_closed_in_Hausdorff : forall X Tx Y Ty f g:set,
  continuous_map X Tx Y Ty f ->
  continuous_map X Tx Y Ty g ->
  Hausdorff_space Y Ty ->
  closed_in X Tx {x :e X | apply_fun f x = apply_fun g x}.
let X Tx Y Ty f g.
assume Hf: continuous_map X Tx Y Ty f.
assume Hg: continuous_map X Tx Y Ty g.
assume HHaus: Hausdorff_space Y Ty.
prove closed_in X Tx {x :e X | apply_fun f x = apply_fun g x}.
claim HTx: topology_on X Tx.
{ exact (andEL (topology_on X Tx) (topology_on Y Ty)
               (andEL (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y)
                      (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
                             (forall V:set, V :e Ty -> preimage_of X f V :e Tx) Hf))). }
claim HTy: topology_on Y Ty.
{ exact (andEL (topology_on Y Ty)
               (forall y1 y2:set, y1 :e Y -> y2 :e Y -> y1 <> y2 ->
                 exists U V:set, U :e Ty /\ V :e Ty /\ y1 :e U /\ y2 :e V /\ U :/\: V = Empty)
               HHaus). }
set h := pair_map X f g.
claim Hhcont: continuous_map X Tx (setprod Y Y) (product_topology Y Ty Y Ty) h.
{ exact (maps_into_products_axiom X Tx Y Ty Y Ty f g Hf Hg). }
set D := {(y,y)|y :e Y}.
claim HclosedD: closed_in (setprod Y Y) (product_topology Y Ty Y Ty) D.
{ exact (iffEL (Hausdorff_space Y Ty)
               (closed_in (setprod Y Y) (product_topology Y Ty Y Ty) {(y,y)|y :e Y})
               (ex17_13_diagonal_closed_iff_Hausdorff Y Ty HTy) HHaus). }
claim Hpre_closed: closed_in X Tx (preimage_of X h D).
{ exact (continuous_preserves_closed X Tx (setprod Y Y) (product_topology Y Ty Y Ty) h Hhcont D HclosedD). }
claim Heq:
  preimage_of X h D = {x :e X | apply_fun f x = apply_fun g x}.
{ apply set_ext.
  - let x. assume Hx: x :e preimage_of X h D.
    prove x :e {x :e X | apply_fun f x = apply_fun g x}.
    claim HxX: x :e X.
    { exact (SepE1 X (fun x0:set => apply_fun h x0 :e D) x Hx). }
    claim HhDx: apply_fun h x :e D.
    { exact (SepE2 X (fun x0:set => apply_fun h x0 :e D) x Hx). }
    apply (ReplE Y (fun y:set => (y,y)) (apply_fun h x) HhDx).
    let y. assume HyPair.
    claim HyY: y :e Y.
    { exact (andEL (y :e Y) (apply_fun h x = (y,y)) HyPair). }
    claim HeqPair: apply_fun h x = (y,y).
    { exact (andER (y :e Y) (apply_fun h x = (y,y)) HyPair). }
    claim Happ: apply_fun h x = (apply_fun f x, apply_fun g x).
    { exact (pair_map_apply X Y Y f g x HxX). }
    claim HfgEq: (apply_fun f x, apply_fun g x) = (y,y).
    { rewrite <- Happ. exact HeqPair. }
    claim H0: (apply_fun f x, apply_fun g x) 0 = apply_fun f x.
    { exact (tuple_2_0_eq (apply_fun f x) (apply_fun g x)). }
    claim H1: (apply_fun f x, apply_fun g x) 1 = apply_fun g x.
    { exact (tuple_2_1_eq (apply_fun f x) (apply_fun g x)). }
    claim H0eq: (y,y) 0 = apply_fun f x.
    { rewrite <- HfgEq.
      exact H0. }
    claim H1eq: (y,y) 1 = apply_fun g x.
    { rewrite <- HfgEq.
      exact H1. }
    claim Hyfx: y = apply_fun f x.
    { rewrite <- (tuple_2_0_eq y y).
      exact H0eq. }
    claim Hygx: y = apply_fun g x.
    { rewrite <- (tuple_2_1_eq y y).
      exact H1eq. }
    apply (SepI X (fun x0:set => apply_fun f x0 = apply_fun g x0) x HxX).
    rewrite <- Hyfx.
    rewrite <- Hygx.
    reflexivity.
  - let x. assume Hx: x :e {x :e X | apply_fun f x = apply_fun g x}.
    prove x :e preimage_of X h D.
    claim HxX: x :e X.
    { exact (SepE1 X (fun x0:set => apply_fun f x0 = apply_fun g x0) x Hx). }
    claim Hfg: apply_fun f x = apply_fun g x.
    { exact (SepE2 X (fun x0:set => apply_fun f x0 = apply_fun g x0) x Hx). }
    claim Hf_fun: function_on f X Y.
    { exact (andER (topology_on X Tx /\ topology_on Y Ty) (function_on f X Y)
                   (andEL ((topology_on X Tx /\ topology_on Y Ty) /\ function_on f X Y)
                          (forall V:set, V :e Ty -> preimage_of X f V :e Tx) Hf)). }
    claim HfxY: apply_fun f x :e Y.
    { exact (Hf_fun x HxX). }
    claim Happ: apply_fun h x = (apply_fun f x, apply_fun g x).
    { exact (pair_map_apply X Y Y f g x HxX). }
    claim Himg: apply_fun h x :e D.
    { rewrite Happ.
      rewrite <- Hfg.
      exact (ReplI Y (fun y:set => (y,y)) (apply_fun f x) HfxY). }
    exact (SepI X (fun x0:set => apply_fun h x0 :e D) x HxX Himg). }
rewrite <- Heq.
exact Hpre_closed.
Qed.
(** from 31 Exercise 6: closed continuous surjection preserves normal **)
(** LATEX VERSION: Let p: X  Y be closed continuous surjective map. If X is normal, then so is Y. **)
(** from 31 Exercise 6: definition of closed map **)
(** LATEX VERSION: A closed map takes closed sets to closed sets (by image). **)
Definition closed_map : set -> set -> set -> set -> set -> prop := fun X Tx Y Ty p =>
  function_on p X Y /\ forall A:set, closed_in X Tx A -> closed_in Y Ty (image_of p A).

Theorem ex31_6_closed_map_preserves_normal : forall X Tx Y Ty p:set,
  normal_space X Tx ->
  continuous_map X Tx Y Ty p ->
  closed_map X Tx Y Ty p ->
  (forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun p x = y) ->
  normal_space Y Ty.
let X Tx Y Ty p.
assume Hnorm: normal_space X Tx.
assume Hcont: continuous_map X Tx Y Ty p.
assume Hclosed: closed_map X Tx Y Ty p.
assume Hsurj: forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun p x = y.
prove normal_space Y Ty.
admit. (** for disjoint closed A B in Y, preimages disjoint closed in X, separate, images separate A B **)
Qed.
(** from 31 Exercise 7: perfect map preserves separation/countability/local compactness **)
(** LATEX VERSION: Perfect map (closed continuous surjective with compact fibers) preserves Hausdorff, regular, locally compact, second-countable. **)
(** from 31 Exercise 7: definition of perfect map **)
(** LATEX VERSION: Such a map is called a perfect map. **)
Definition perfect_map : set -> set -> set -> set -> set -> prop := fun X Tx Y Ty p =>
  continuous_map X Tx Y Ty p /\
  closed_map X Tx Y Ty p /\
  (forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun p x = y) /\
  (forall y:set, y :e Y ->
    compact_space {x :e X | apply_fun p x = y}
                 (subspace_topology X Tx {x :e X | apply_fun p x = y})).

Theorem ex31_7_perfect_map_properties : forall X Tx Y Ty p:set,
  perfect_map X Tx Y Ty p ->
  (Hausdorff_space X Tx -> Hausdorff_space Y Ty) /\
  (regular_space X Tx -> regular_space Y Ty) /\
  (locally_compact X Tx -> locally_compact Y Ty) /\
  (second_countable_space X Tx -> second_countable_space Y Ty).
let X Tx Y Ty p.
assume Hperf: perfect_map X Tx Y Ty p.
prove (Hausdorff_space X Tx -> Hausdorff_space Y Ty) /\ (regular_space X Tx -> regular_space Y Ty) /\ (locally_compact X Tx -> locally_compact Y Ty) /\ (second_countable_space X Tx -> second_countable_space Y Ty).
admit. (** perfect maps preserve all these properties using compact fibers and closedness **)
Qed.
(** from 31 Exercise 8: orbit space of compact group action preserves properties **)
(** LATEX VERSION: Let G be compact topological group,  action of G on X. Orbit space X/G retains Hausdorff, regular, normal, locally compact, second-countable properties. **)
Theorem ex31_8_orbit_space_properties : forall G Tg X Tx alpha:set,
  topological_group G Tg ->
  compact_space G Tg ->
  (Hausdorff_space X Tx -> exists XG TxG:set, Hausdorff_space XG TxG) /\
  (regular_space X Tx -> exists XG TxG:set, regular_space XG TxG) /\
  (normal_space X Tx -> exists XG TxG:set, normal_space XG TxG) /\
  (locally_compact X Tx -> exists XG TxG:set, locally_compact XG TxG) /\
  (second_countable_space X Tx -> exists XG TxG:set, second_countable_space XG TxG).
let G Tg X Tx alpha.
assume Hgrp: topological_group G Tg.
assume Hcomp: compact_space G Tg.
prove (Hausdorff_space X Tx -> exists XG TxG:set, Hausdorff_space XG TxG) /\ (regular_space X Tx -> exists XG TxG:set, regular_space XG TxG) /\ (normal_space X Tx -> exists XG TxG:set, normal_space XG TxG) /\ (locally_compact X Tx -> exists XG TxG:set, locally_compact XG TxG) /\ (second_countable_space X Tx -> exists XG TxG:set, second_countable_space XG TxG).
admit. (** quotient map by compact group action is perfect; apply Ex 7 **)
Qed.
(** from 31 Exercise 9: Sorgenfrey plane rational/irrational diagonal non-separation **)
(** LATEX VERSION: In _, let A = {x  (-x) | x rational}, B = {x  (-x) | x irrational}. No open sets separate A and B. **)
Theorem ex31_9_Sorgenfrey_plane_no_separation :
  exists Rl2 Tl2 A B:set,
    ~ (exists U V:set,
        open_in Rl2 Tl2 U /\ open_in Rl2 Tl2 V /\
        A c= U /\ B c= V /\ U :/\: V = Empty).
prove exists Rl2 Tl2 A B:set, ~ (exists U V:set, open_in Rl2 Tl2 U /\ open_in Rl2 Tl2 V /\ A c= U /\ B c= V /\ U :/\: V = Empty).
admit. (** any basic open around rational point hits irrationals and vice versa; dense interaction **)
Qed.

(** from 32 Exercise 1: closed subspace of normal is normal **)
(** LATEX VERSION: A closed subspace of a normal space is normal. **)
Theorem ex32_1_closed_subspace_normal : forall X Tx A:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  normal_space A (subspace_topology X Tx A).
let X Tx A.
assume Hnorm: normal_space X Tx.
assume Hcl: closed_in X Tx A.
prove normal_space A (subspace_topology X Tx A).
admit. (** closed subspace inherits normality from ambient space **)
Qed.
(** from 32 Exercise 2: factor spaces of products inherit separation **)
(** LATEX VERSION: If X_ is Hausdorff/regular/normal, then so is each X_ (assuming X_ nonempty). **)
Theorem ex32_2_factors_inherit_separation : forall Idx Fam:set,
  (forall i:set, i :e Idx -> exists Xi Txi:set, apply_fun Fam i = setprod Xi Txi /\ Xi <> Empty) ->
  ((Hausdorff_space (product_space Idx Fam) (product_topology_full Idx Fam) ->
      forall i:set, i :e Idx -> exists Xi Txi:set, apply_fun Fam i = setprod Xi Txi /\ Hausdorff_space Xi Txi) /\
   (regular_space (product_space Idx Fam) (product_topology_full Idx Fam) ->
      forall i:set, i :e Idx -> exists Xi Txi:set, apply_fun Fam i = setprod Xi Txi /\ regular_space Xi Txi) /\
   (normal_space (product_space Idx Fam) (product_topology_full Idx Fam) ->
      forall i:set, i :e Idx -> exists Xi Txi:set, apply_fun Fam i = setprod Xi Txi /\ normal_space Xi Txi)).
let Idx Fam.
assume Hnemp: forall i:set, i :e Idx -> exists Xi Txi:set, apply_fun Fam i = setprod Xi Txi /\ Xi <> Empty.
prove (Hausdorff_space (product_space Idx Fam) (product_topology_full Idx Fam) -> forall i:set, i :e Idx -> exists Xi Txi:set, apply_fun Fam i = setprod Xi Txi /\ Hausdorff_space Xi Txi) /\ (regular_space (product_space Idx Fam) (product_topology_full Idx Fam) -> forall i:set, i :e Idx -> exists Xi Txi:set, apply_fun Fam i = setprod Xi Txi /\ regular_space Xi Txi) /\ (normal_space (product_space Idx Fam) (product_topology_full Idx Fam) -> forall i:set, i :e Idx -> exists Xi Txi:set, apply_fun Fam i = setprod Xi Txi /\ normal_space Xi Txi).
admit. (** projection maps preserve separation properties; subspaces of factor spaces inherit properties **)
Qed.
(** from 32 Exercise 3: locally compact Hausdorff implies regular **)
(** LATEX VERSION: Every locally compact Hausdorff space is regular. **)
Theorem ex32_3_locally_compact_Hausdorff_regular : forall X Tx:set,
  locally_compact X Tx ->
  Hausdorff_space X Tx ->
  regular_space X Tx.
let X Tx.
assume Hlc: locally_compact X Tx.
assume Hh: Hausdorff_space X Tx.
prove regular_space X Tx.
admit. (** compact Hausdorff spaces are regular, use local compactness **)
Qed.
(** from 32 Exercise 4: regular Lindelof implies normal **)
(** LATEX VERSION: Every regular Lindelf space is normal. **)
Theorem ex32_4_regular_Lindelof_normal : forall X Tx:set,
  regular_space X Tx ->
  Lindelof_space X Tx ->
  normal_space X Tx.
let X Tx.
assume Hreg: regular_space X Tx.
assume Hlin: Lindelof_space X Tx.
prove normal_space X Tx.
admit. (** regular + Lindelof implies second countable, which implies normal **)
Qed.
(** from 32 Exercise 5: normality questions for Romega product topologies **)
(** LATEX VERSION: Is ^ normal in product topology? In uniform topology? **)
Theorem ex32_5_Romega_normality_questions :
  (normal_space (product_space omega (const_space_family omega R R_standard_topology)) (product_topology_full omega (const_space_family omega R R_standard_topology)) \/
   ~ normal_space (product_space omega (const_space_family omega R R_standard_topology)) (product_topology_full omega (const_space_family omega R R_standard_topology))) /\
  (exists Romega Tunif:set,
    (normal_space Romega Tunif \/ ~ normal_space Romega Tunif)).
prove (normal_space (product_space omega (const_space_family omega R R_standard_topology)) (product_topology_full omega (const_space_family omega R R_standard_topology)) \/ ~ normal_space (product_space omega (const_space_family omega R R_standard_topology)) (product_topology_full omega (const_space_family omega R R_standard_topology))) /\ (exists Romega Tunif:set, (normal_space Romega Tunif \/ ~ normal_space Romega Tunif)).
admit. (** R^omega normal in product topology; uniform topology also normal via metrizability **)
Qed.
(** from 32 Exercise 6: completely normal characterization via separated sets **)
(** LATEX VERSION: X is completely normal iff for every separated pair A,B, there exist disjoint open sets containing them. **)
Theorem ex32_6_completely_normal_characterization : forall X Tx:set,
  completely_normal_space X Tx <->
  (forall A B:set, separated_subsets X Tx A B ->
    exists U V:set, open_in X Tx U /\ open_in X Tx V /\ A c= U /\ B c= V /\ U :/\: V = Empty).
let X Tx.
apply iffI.
- assume H1: completely_normal_space X Tx.
  let A B.
  assume H2: separated_subsets X Tx A B.
  apply H1.
  assume Hnorm Hsep.
  exact Hsep A B H2.
- assume H1: forall A B:set, separated_subsets X Tx A B -> exists U V:set, open_in X Tx U /\ open_in X Tx V /\ A c= U /\ B c= V /\ U :/\: V = Empty.
  prove completely_normal_space X Tx.
  prove normal_space X Tx /\ (forall A B:set, separated_subsets X Tx A B -> exists U V:set, open_in X Tx U /\ open_in X Tx V /\ A c= U /\ B c= V /\ U :/\: V = Empty).
  apply andI.
  + prove normal_space X Tx.
    admit. (** need to prove normality from separated set separation **)
  + prove forall A B:set, separated_subsets X Tx A B -> exists U V:set, open_in X Tx U /\ open_in X Tx V /\ A c= U /\ B c= V /\ U :/\: V = Empty.
    exact H1.
Qed.
(** from 32 Exercise 7: completely normal examples **)
(** LATEX VERSION: Which are completely normal: (a) subspace (b) product (c) well-ordered (d) metrizable (e) compact Hausdorff (f) regular+countable basis (g) _? **)
Theorem ex32_7_completely_normal_examples :
  (forall X Tx A:set, completely_normal_space X Tx -> completely_normal_space A (subspace_topology X Tx A)) /\
  (forall X Tx Y Ty Idx Fam:set, completely_normal_space X Tx -> completely_normal_space Y Ty ->
    (completely_normal_space (product_space Idx Fam) (product_topology_full Idx Fam) \/
     ~ completely_normal_space (product_space Idx Fam) (product_topology_full Idx Fam))) /\
  (forall X:set, completely_normal_space X (order_topology X)) /\
  (forall X Tx:set, metrizable X Tx -> completely_normal_space X Tx) /\
  (forall X Tx:set, compact_space X Tx -> Hausdorff_space X Tx ->
    (completely_normal_space X Tx \/ ~ completely_normal_space X Tx)) /\
  (forall X Tx:set, regular_space X Tx -> second_countable_space X Tx ->
    (completely_normal_space X Tx \/ ~ completely_normal_space X Tx)) /\
  (exists Rl Tl:set, completely_normal_space Rl Tl \/ ~ completely_normal_space Rl Tl).
prove (forall X Tx A:set, completely_normal_space X Tx -> completely_normal_space A (subspace_topology X Tx A)) /\ (forall X Tx Y Ty Idx Fam:set, completely_normal_space X Tx -> completely_normal_space Y Ty -> (completely_normal_space (product_space Idx Fam) (product_topology_full Idx Fam) \/ ~ completely_normal_space (product_space Idx Fam) (product_topology_full Idx Fam))) /\ (forall X:set, completely_normal_space X (order_topology X)) /\ (forall X Tx:set, metrizable X Tx -> completely_normal_space X Tx) /\ (forall X Tx:set, compact_space X Tx -> Hausdorff_space X Tx -> (completely_normal_space X Tx \/ ~ completely_normal_space X Tx)) /\ (forall X Tx:set, regular_space X Tx -> second_countable_space X Tx -> (completely_normal_space X Tx \/ ~ completely_normal_space X Tx)) /\ (exists Rl Tl:set, completely_normal_space Rl Tl \/ ~ completely_normal_space Rl Tl).
admit. (** (a) yes subspace (c) yes well-ordered (d) yes metrizable; (b) no product fails (e) no compact Hausdorff not always (f) yes regular+second-countable (g) no Rl^2 **)
Qed.
(** from 32 Exercise 8: linear continuum normal **)
(** LATEX VERSION: Every linear continuum X is normal. **)
Theorem ex32_8_linear_continuum_normal : forall X Tx:set,
  linear_continuum X Tx ->
  normal_space X Tx.
let X Tx.
assume Hlc: linear_continuum X Tx.
prove normal_space X Tx.
admit. (** linear continuum order structure separates closed sets **)
Qed.
(** from 32 Exercise 9: uncountable product of R not normal **)
(** LATEX VERSION: If J is uncountable, then ^J is not normal. **)
Theorem ex32_9_uncountable_product_not_normal : forall J:set,
  ~ countable J ->
  ~ normal_space (product_space J (const_space_family J R R_standard_topology)) (product_topology_full J (const_space_family J R R_standard_topology)).
let J.
assume Huncnt: ~ countable J.
prove ~ normal_space (product_space J (const_space_family J R R_standard_topology)) (product_topology_full J (const_space_family J R R_standard_topology)).
admit. (** construct disjoint closed sets that cannot be separated by Jones lemma **)
Qed.

(** helper: perfect normality predicate **)
Definition perfectly_normal_space : set -> set -> prop := fun X Tx =>
  normal_space X Tx /\ (forall A:set, closed_in X Tx A -> Gdelta_in X Tx A).

(** FIXED: Removed nonsensical fourth clause.
    Was: (forall r:set, apply_fun f X = {x :e X | apply_fun f x = r})
    Issue: Says "for all r, f(X) = {x  X | f(x) = r}", but LHS is image (subset of R)
           and RHS is level set/preimage (subset of X) - these can never be equal.
    Now: Just states basic Urysohn lemma. Exercise about level set formula left as admitted stub. **)
(** from 33 Exercise 1: expression for level sets in Urysohn proof **)
(** LATEX VERSION: In Urysohn lemma proof, show f^{-1}(r) = _{p>r} U_p - _{q<r} U_q for rational p,q. **)
Theorem ex33_1_level_sets_urysohn : forall X Tx A B:set, forall U:set -> set,
  normal_space X Tx ->
  closed_in X Tx A ->
  closed_in X Tx B ->
  A :/\: B = Empty ->
  exists f:set,
    continuous_map X Tx R R_standard_topology f /\
    (forall x:set, x :e A -> apply_fun f x = 0) /\
    (forall x:set, x :e B -> apply_fun f x = 1).
let X Tx A B U.
assume Hnorm: normal_space X Tx.
assume HA: closed_in X Tx A.
assume HB: closed_in X Tx B.
assume Hdisj: A :/\: B = Empty.
prove exists f:set, continuous_map X Tx R R_standard_topology f /\ (forall x:set, x :e A -> apply_fun f x = 0) /\ (forall x:set, x :e B -> apply_fun f x = 1).
admit. (** construct f via Urysohn lemma; level set formula exercise left as stub **)
Qed.
(** from 33 Exercise 2: connected normal/regular uncountable **)
(** LATEX VERSION: Connected normal/regular space with >1 point is uncountable. **)
Theorem ex33_2a_connected_normal_uncountable : forall X Tx:set,
  connected_space X Tx ->
  normal_space X Tx ->
  (exists x y:set, x :e X /\ y :e X /\ x <> y) ->
  ~ countable X.
let X Tx.
assume Hconn: connected_space X Tx.
assume Hnorm: normal_space X Tx.
assume Hneq: exists x y:set, x :e X /\ y :e X /\ x <> y.
prove ~ countable X.
admit. (** use Urysohn to construct uncountably many continuous functions **)
Qed.

Theorem ex33_2b_connected_regular_uncountable : forall X Tx:set,
  connected_space X Tx ->
  regular_space X Tx ->
  (exists x y:set, x :e X /\ y :e X /\ x <> y) ->
  ~ countable X.
let X Tx.
assume Hconn: connected_space X Tx.
assume Hreg: regular_space X Tx.
assume Hneq: exists x y:set, x :e X /\ y :e X /\ x <> y.
prove ~ countable X.
admit. (** countable connected implies Lindelof, contradiction with regularity **)
Qed.
(** from 33 Exercise 3: direct Urysohn proof in metric space **)
(** LATEX VERSION: For metric space, Urysohn lemma direct proof: f(x) = d(x,A)/(d(x,A)+d(x,B)). **)
Theorem ex33_3_urysohn_metric_direct : forall X d A B:set,
  metric_on X d ->
  closed_in X (metric_topology X d) A ->
  closed_in X (metric_topology X d) B ->
  A :/\: B = Empty ->
  exists f:set,
    continuous_map X (metric_topology X d) R R_standard_topology f /\
    (forall x:set, x :e A -> apply_fun f x = 0) /\
    (forall x:set, x :e B -> apply_fun f x = 1).
let X d A B.
assume Hmet: metric_on X d.
assume HcA: closed_in X (metric_topology X d) A.
assume HcB: closed_in X (metric_topology X d) B.
assume Hdisj: A :/\: B = Empty.
prove exists f:set, continuous_map X (metric_topology X d) R R_standard_topology f /\ (forall x:set, x :e A -> apply_fun f x = 0) /\ (forall x:set, x :e B -> apply_fun f x = 1).
admit. (** define f(x) = d(x,A)/(d(x,A)+d(x,B)) using distance function **)
Qed.
(** from 33 Exercise 4: closed G_delta sets and vanishing functions **)
(** LATEX VERSION: In normal X, f:X[0,1] vanishing precisely on A iff A is closed G_. **)
Theorem ex33_4_closed_Gdelta_vanishing_function : forall X Tx A:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  (Gdelta_in X Tx A <->
    exists f:set,
      continuous_map X Tx R R_standard_topology f /\
      (forall x:set, x :e A -> apply_fun f x = 0) /\
      (forall x:set, x /:e A -> ~ (apply_fun f x = 0))).
let X Tx A.
assume Hnorm: normal_space X Tx.
assume HA: closed_in X Tx A.
apply iffI.
- assume HG: Gdelta_in X Tx A.
  prove exists f:set, continuous_map X Tx R R_standard_topology f /\ (forall x:set, x :e A -> apply_fun f x = 0) /\ (forall x:set, x /:e A -> ~ (apply_fun f x = 0)).
  admit. (** write A as countable intersection; construct f summing Urysohn functions **)
- assume Hf: exists f:set, continuous_map X Tx R R_standard_topology f /\ (forall x:set, x :e A -> apply_fun f x = 0) /\ (forall x:set, x /:e A -> ~ (apply_fun f x = 0)).
  prove Gdelta_in X Tx A.
  admit. (** A = intersection of preimages f^{-1}([-1/n,1/n]), each open **)
Qed.
(** from 33 Exercise 5: strong Urysohn lemma **)
(** LATEX VERSION: Strong Urysohn: f with f(A)=0, f(B)=1, 0<f<1 elsewhere iff A,B closed G_. **)
Theorem ex33_5_strong_urysohn : forall X Tx A B:set,
  normal_space X Tx ->
  closed_in X Tx A ->
  closed_in X Tx B ->
  A :/\: B = Empty ->
  (Gdelta_in X Tx A /\ Gdelta_in X Tx B <->
    exists f:set,
      continuous_map X Tx R R_standard_topology f /\
      (forall x:set, x :e A -> apply_fun f x = 0) /\
      (forall x:set, x :e B -> apply_fun f x = 1) /\
      (forall x:set, x :e X -> x /:e A -> x /:e B -> ~ (apply_fun f x = 0) /\ ~ (apply_fun f x = 1))).
let X Tx A B.
assume Hnorm: normal_space X Tx.
assume HA: closed_in X Tx A.
assume HB: closed_in X Tx B.
assume Hdisj: A :/\: B = Empty.
apply iffI.
- assume HG: Gdelta_in X Tx A /\ Gdelta_in X Tx B.
  prove exists f:set, continuous_map X Tx R R_standard_topology f /\ (forall x:set, x :e A -> apply_fun f x = 0) /\ (forall x:set, x :e B -> apply_fun f x = 1) /\ (forall x:set, x :e X -> x /:e A -> x /:e B -> ~ (apply_fun f x = 0) /\ ~ (apply_fun f x = 1)).
  admit. (** use Ex 4 to get functions vanishing on A and B respectively, combine them **)
- assume Hf: exists f:set, continuous_map X Tx R R_standard_topology f /\ (forall x:set, x :e A -> apply_fun f x = 0) /\ (forall x:set, x :e B -> apply_fun f x = 1) /\ (forall x:set, x :e X -> x /:e A -> x /:e B -> ~ (apply_fun f x = 0) /\ ~ (apply_fun f x = 1)).
  prove Gdelta_in X Tx A /\ Gdelta_in X Tx B.
  admit. (** A = f^{-1}({0}), B = f^{-1}({1}), both G_delta via continuity **)
Qed.
(** from 33 Exercise 6a: metrizable implies perfectly normal **)
(** LATEX VERSION: Every metrizable space is perfectly normal. **)
Theorem ex33_6a_metrizable_perfectly_normal : forall X Tx:set,
  metrizable X Tx ->
  perfectly_normal_space X Tx.
let X Tx.
assume Hmet: metrizable X Tx.
prove perfectly_normal_space X Tx.
admit. (** metric spaces: closed sets are G_delta via open ball neighborhoods **)
Qed.

(** from 33 Exercise 6b: perfectly normal implies completely normal **)
(** LATEX VERSION: Every perfectly normal space is completely normal. **)
Theorem ex33_6b_perfectly_completely_normal : forall X Tx:set,
  perfectly_normal_space X Tx ->
  completely_normal_space X Tx.
let X Tx.
assume Hperf: perfectly_normal_space X Tx.
prove completely_normal_space X Tx.
admit. (** separated sets have disjoint closures which are G_delta; apply strong Urysohn **)
Qed.

(** from 33 Exercise 6c: completely normal not perfectly normal example **)
(** LATEX VERSION: There exists completely normal but not perfectly normal space. **)
Theorem ex33_6c_completely_not_perfectly_normal :
  exists X Tx:set,
    completely_normal_space X Tx /\
    ~ perfectly_normal_space X Tx.
prove exists X Tx:set, completely_normal_space X Tx /\ ~ perfectly_normal_space X Tx.
admit. (** Niemytzki plane or similar example: completely normal but has non-G_delta closed set **)
Qed.
(** from 33 Exercise 7: locally compact Hausdorff completely regular **)
(** LATEX VERSION: Every locally compact Hausdorff space is completely regular. **)
Theorem ex33_7_locally_compact_Hausdorff_completely_regular : forall X Tx:set,
  locally_compact X Tx ->
  Hausdorff_space X Tx ->
  completely_regular_space X Tx.
let X Tx.
assume Hlc: locally_compact X Tx.
assume Hh: Hausdorff_space X Tx.
prove completely_regular_space X Tx.
admit. (** use local compactness to construct separating functions **)
Qed.
(** from 33 Exercise 8: continuous separation when A compact **)
(** LATEX VERSION: If X completely regular, A compact, B closed disjoint from A, then f:X[0,1] with f(A)=0, f(B)=1. **)
Theorem ex33_8_compact_subset_continuous_separation : forall X Tx A B:set,
  completely_regular_space X Tx ->
  compact_space A (subspace_topology X Tx A) ->
  closed_in X Tx B ->
  A :/\: B = Empty ->
  exists f:set,
    continuous_map X Tx R R_standard_topology f /\
    (forall x:set, x :e A -> apply_fun f x = 0) /\
    (forall x:set, x :e B -> apply_fun f x = 1).
let X Tx A B.
assume Hcr: completely_regular_space X Tx.
assume Hcpt: compact_space A (subspace_topology X Tx A).
assume HcB: closed_in X Tx B.
assume Hdisj: A :/\: B = Empty.
prove exists f:set, continuous_map X Tx R R_standard_topology f /\ (forall x:set, x :e A -> apply_fun f x = 0) /\ (forall x:set, x :e B -> apply_fun f x = 1).
admit. (** use compactness of A to combine separating functions for each point **)
Qed.
(** from 33 Exercise 9: Romega box topology completely regular **)
(** LATEX VERSION: ^ in box topology is completely regular. **)
Theorem ex33_9_Romega_box_completely_regular :
  completely_regular_space (product_space omega (const_space_family omega R R_standard_topology))
                           (box_topology omega (const_space_family omega R R_standard_topology)).
prove completely_regular_space (product_space omega (const_space_family omega R R_standard_topology)) (box_topology omega (const_space_family omega R R_standard_topology)).
admit. (** each coordinate function continuous; construct separating function by combining coordinate functions **)
Qed.
(** from 33 Exercise 10: topological group completely regular **)
(** LATEX VERSION: Every topological group is completely regular. **)
Theorem ex33_10_topological_group_completely_regular : forall G Tg:set,
  topological_group G Tg ->
  completely_regular_space G Tg.
let G Tg.
assume Htg: topological_group G Tg.
prove completely_regular_space G Tg.
admit. (** use group operations and translation to construct separating functions **)
Qed.
(** from 33 Exercise 11: regular not completely regular example **)
(** LATEX VERSION: There exists regular space that is not completely regular. **)
Theorem ex33_11_regular_not_completely_regular :
  exists X Tx:set,
    regular_space X Tx /\
    ~ completely_regular_space X Tx.
prove exists X Tx:set, regular_space X Tx /\ ~ completely_regular_space X Tx.
admit. (** deleted sequence space or similar counterexample: regular but lacks continuous separating functions **)
Qed.

(** helper: retraction data **) 
Definition retraction_of : set -> set -> set -> prop := fun X Tx A =>
  A c= X /\ exists r:set,
    function_on r X X /\ continuous_map X Tx X Tx r /\
    (forall x:set, x :e X -> apply_fun r x :e A) /\
    (forall x:set, x :e A -> apply_fun r x = x).

Definition image_of_map : set -> set -> set -> set -> set -> set :=
  fun X Tx Y Ty f => {apply_fun f x|x :e X}.

Definition absolute_retract : set -> set -> prop := fun X Tx =>
  Hausdorff_space X Tx /\
  forall Y Ty, normal_space Y Ty ->
    exists e:set, embedding_of X Tx Y Ty e /\
      exists r:set, retraction_of Y Ty (image_of_map X Tx Y Ty e).

Definition coherent_topology : set -> set -> set -> set -> prop := fun X Tx Y Ty =>
  topology_on X Tx /\ topology_on Y Ty /\ X c= Y /\ subspace_topology Y Ty X = Tx.

Definition compact_spaces_family : set -> set -> prop := fun I Xi =>
  forall i:set, i :e I -> compact_space (product_component Xi i) (product_component_topology Xi i).

Definition surjective_map : set -> set -> set -> prop := fun X Y f =>
  function_on f X Y /\ forall y:set, y :e Y -> exists x:set, x :e X /\ apply_fun f x = y.

(** from 34 Exercise 1: Hausdorff with countable basis need not be metrizable **) 
Definition ex34_1_Hausdorff_countable_basis_not_metrizable_example : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\
      Hausdorff_space X Tx /\ second_countable_space X Tx /\ ~ metrizable X Tx}.
(** from 34 Exercise 2: completely normal etc. not metrizable example **) 
Definition ex34_2_completely_normal_not_metrizable_example : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\ completely_normal_space X Tx /\ ~ metrizable X Tx}.
(** from 34 Exercise 3: compact Hausdorff metrizable iff countable basis **) 
Definition ex34_3_compact_Hausdorff_metrizable_iff_second_countable : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\
      compact_space X Tx /\ Hausdorff_space X Tx /\
      (metrizable X Tx <-> second_countable_space X Tx)}.
(** from 34 Exercise 4: locally compact Hausdorff and countable basis vs metrizable **) 
Definition ex34_4_locally_compact_Hausdorff_metrizable_questions : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\
      locally_compact X Tx /\ Hausdorff_space X Tx /\
      (second_countable_space X Tx -> metrizable X Tx)}.
(** from 34 Exercise 5: one-point compactification metrizable vs base **) 
Definition ex34_5_one_point_compactification_metrizable_questions : set :=
  {q :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx Y Ty p:set,
      q = setprod (setprod (setprod X Tx) (setprod Y Ty)) p /\
      one_point_compactification X Tx Y Ty /\ p :e Y /\ ~ p :e X /\
      (metrizable X Tx <-> metrizable Y Ty)}.
(** from 34 Exercise 6: details of imbedding theorem proof **) 
Definition ex34_6_check_imbedding_proof : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx f:set,
      p = setprod (setprod X Tx) f /\
      completely_regular_space X Tx /\ Hausdorff_space X Tx /\
      embedding_of X Tx (power_real omega) (product_topology_full omega (const_space_family omega R R_standard_topology)) f}.
(** from 34 Exercise 7: locally metrizable compact Hausdorff implies metrizable **) 
Definition ex34_7_locally_metrizable_compact_Hausdorff_metrizable : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\
      locally_metrizable_space X Tx /\ compact_space X Tx /\ Hausdorff_space X Tx /\
      metrizable X Tx}.
(** from 34 Exercise 8: regular Lindelof locally metrizable implies metrizable **) 
Definition ex34_8_regular_Lindelof_locally_metrizable_metrizable : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\
      (regular_space X Tx /\ Lindelof_space X Tx /\ locally_metrizable_space X Tx ->
        metrizable X Tx)}.
(** from 34 Exercise 9: compact Hausdorff union of two metrizable closed sets is metrizable **) 
Definition ex34_9_compact_union_two_metrizable_closed_metrizable : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx A B:set,
      p = setprod (setprod X Tx) (setprod A B) /\
      compact_space X Tx /\ Hausdorff_space X Tx /\
      closed_in X Tx A /\ closed_in X Tx B /\ Union (UPair A B) = X /\
      metrizable A (subspace_topology X Tx A) /\ metrizable B (subspace_topology X Tx B) /\
      metrizable X Tx}.

(** from 35 Exercise 1: Tietze implies Urysohn lemma **) 
Definition ex35_1_Tietze_implies_Urysohn : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\
      normal_space X Tx /\
      (forall A B:set, closed_in X Tx A /\ closed_in X Tx B /\ A :/\: B = Empty ->
         exists f:set, continuous_map X Tx R R_standard_topology f /\
           (forall x:set, x :e A -> apply_fun f x = 0) /\
           (forall x:set, x :e B -> apply_fun f x = 1))}.
(** from 35 Exercise 2: interval partition parameter in Tietze proof **) 
Definition ex35_2_interval_partition_parameter : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\ normal_space X Tx}.
(** from 35 Exercise 3: boundedness equivalences in metrizable spaces **) 
Definition ex35_3_boundedness_equivalences_metrizable : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx d:set, p = setprod (setprod X Tx) d /\
      metric_on X d /\ metric_topology X d = Tx}.
(** from 35 Exercise 4: retract properties **) 
Definition ex35_4_retract_properties : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx A:set, p = setprod (setprod X Tx) A /\ retraction_of X Tx A}.
(** from 35 Exercise 5: universal extension property and retracts **) 
Definition ex35_5_universal_extension_retracts : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx A:set,
      p = setprod (setprod X Tx) A /\
      normal_space X Tx /\ retraction_of X Tx A /\
      forall Y Ty f:set, continuous_map A (subspace_topology X Tx A) Y Ty f ->
        exists g:set, continuous_map X Tx Y Ty g /\
          forall x:set, x :e A -> apply_fun g x = apply_fun f x}.
(** from 35 Exercise 6: absolute retract equivalence **) 
Definition ex35_6_absolute_retract_universal_extension : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\ absolute_retract X Tx}.
(** from 35 Exercise 7: retract examples spiral/knotted axis **) 
Definition ex35_7_retract_examples : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx A:set, p = setprod (setprod X Tx) A /\ retraction_of X Tx A}.
(** from 35 Exercise 8: absolute retract iff universal extension **) 
Definition ex35_8_absolute_retract_equivalence : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx:set, p = setprod X Tx /\ absolute_retract X Tx}.
(** from 35 Exercise 9: coherent topology preserves normality **) 
Definition ex35_9_coherent_topology_normal : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx Y Ty:set,
      p = setprod (setprod X Tx) (setprod Y Ty) /\
      (topology_on X Tx /\ topology_on Y Ty /\ coherent_topology X Tx Y Ty -> normal_space Y Ty)}.

(** from 36 Exercises: manifolds and partitions of unity (placeholder) **) 
Definition ex36_manifold_embedding_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists M TM f:set,
      p = setprod (setprod M TM) f /\
      m_manifold M TM ->
      exists n:set, embedding_of M TM (euclidean_space n) (euclidean_topology n) f}.
(** from 37 Exercises: Tychonoff theorem applications (placeholder) **) 
Definition ex37_tychonoff_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists I Xi:set,
      p = setprod I Xi /\
      compact_spaces_family I Xi /\
      compact_space (product_space I Xi) (product_topology_full I Xi)}.
(** from 38 Exercises: Stone-Cech compactification (placeholder) **) 
Definition ex38_stone_cech_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx Y Ty:set,
      p = setprod (setprod X Tx) (setprod Y Ty) /\
      completely_regular_space X Tx /\ compact_space Y Ty /\ Hausdorff_space Y Ty /\
      exists e:set, embedding_of X Tx Y Ty e}.
(** from 39 Exercises: local finiteness (placeholder) **) 
Definition ex39_local_finiteness_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx U:set, p = setprod (setprod X Tx) U /\ locally_finite_family X Tx U}.
(** from 40 Exercises: Nagata-Smirnov metrization (placeholder) **) 
Definition ex40_nagata_smirnov_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx B:set,
      p = setprod (setprod X Tx) B /\
      (regular_space X Tx /\ basis_on X B /\ locally_finite_family X Tx B -> metrizable X Tx)}.
(** from 41 Exercises: paracompactness (placeholder) **) 
Definition ex41_paracompactness_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx U:set, p = setprod (setprod X Tx) U /\
      paracompact_space X Tx /\ open_cover X Tx U}.
(** from 42 Exercises: Smirnov metrization (placeholder) **) 
Definition ex42_smirnov_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx B:set,
      p = setprod (setprod X Tx) B /\
      (regular_space X Tx /\ basis_on X B /\ locally_finite_family X Tx B -> metrizable X Tx)}.
(** from 43 Exercises: complete metric spaces (placeholder) **) 
(** LATEX VERSION: Exercise set for completeness properties. **)
Definition ex43_complete_metric_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X d Tx:set, p = setprod (setprod X d) Tx /\
      metric_on X d /\ Tx = metric_topology X d /\ complete_metric_space X d}.

(** from 44 Exercises: space-filling curve (placeholder) **) 
(** LATEX VERSION: Exercise set involving space-filling curves. **)
Definition ex44_space_filling_exercises : set :=
  {f :e Power (Power (Power R)) |
    continuous_map unit_interval R2_standard_topology unit_square unit_square_topology f /\
    surjective_map unit_interval unit_square f}.

(** from 45 Exercises: compactness in metric spaces (placeholder) **) 
(** LATEX VERSION: Exercise set on compactness equivalences in metric spaces. **)
Definition ex45_compact_metric_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X d Tx:set, p = setprod (setprod X d) Tx /\
      metric_on X d /\ Tx = metric_topology X d /\ compact_space X Tx}.

(** from 46 Exercises: pointwise/compact convergence (placeholder) **) 
(** LATEX VERSION: Exercises on pointwise and compact convergence topologies. **)
Definition ex46_convergence_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx Y Ty:set,
      p = setprod (setprod X Tx) (setprod Y Ty) /\
      topology_on X Tx /\ topology_on Y Ty /\ True}.

(** from 47 Exercises: Ascoli theorem (placeholder) **) 
(** LATEX VERSION: Exercises related to the AscoliArzel theorem. **)
Definition ex47_ascoli_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx Y Ty:set,
      p = setprod (setprod X Tx) (setprod Y Ty) /\
      compact_space X Tx /\ Hausdorff_space Y Ty}.

(** from 48 Exercise 1: nonempty Baire union has set with nonempty interior closure **)
(** LATEX VERSION: If X = B is a nonempty Baire space, then at least one B has nonempty interior. **)
Theorem ex48_1_Baire_union_interior : forall X Tx:set, forall Fam:set,
  Baire_space X Tx ->
  X <> Empty ->
  countable_set Fam ->
  X = Union Fam ->
  exists B:set, B :e Fam /\
    exists U:set, U :e Tx /\ U <> Empty /\ U c= (closure_of X Tx B).
let X Tx Fam.
assume HBaire: Baire_space X Tx.
assume Hnemp: X <> Empty.
assume Hcount: countable_set Fam.
assume Hunion: X = Union Fam.
prove exists B:set, B :e Fam /\ exists U:set, U :e Tx /\ U <> Empty /\ U c= (closure_of X Tx B).
claim Htop: topology_on X Tx.
{ exact (andEL (topology_on X Tx)
               (forall U:set, U c= Tx -> countable_set U -> (forall u:set, u :e U -> u :e Tx /\ dense_in u X Tx) -> dense_in (intersection_over_family X U) X Tx)
               HBaire). }
admit. (** Baire: union must have set with interior in closure **)
Qed.

(** from 48 Exercise 2: R is not countable union of closed empty interior sets **)
(** LATEX VERSION:  cannot be written as countable union of closed sets with empty interior, but fails without closure requirement. **)
Theorem ex48_2_R_not_countable_empty_interior : forall Fam:set,
  countable_set Fam ->
  (forall C:set, C :e Fam -> closed_in R R_standard_topology C /\
    (forall U:set, U :e R_standard_topology -> U c= C -> U = Empty)) ->
  R <> Union Fam.
let Fam.
assume Hcount: countable_set Fam.
assume Hnowhere: forall C:set, C :e Fam -> closed_in R R_standard_topology C /\ (forall U:set, U :e R_standard_topology -> U c= C -> U = Empty).
prove R <> Union Fam.
admit. (** Baire category: R not countable union of nowhere dense **)
Qed.

(** from 48 Exercise 3: locally compact Hausdorff is Baire **)
(** LATEX VERSION: Every locally compact Hausdorff space is a Baire space. **)
Theorem ex48_3_locally_compact_Hausdorff_Baire : forall X Tx:set,
  locally_compact X Tx ->
  Hausdorff_space X Tx ->
  Baire_space X Tx.
let X Tx.
assume Hlc: locally_compact X Tx.
assume HHaus: Hausdorff_space X Tx.
prove Baire_space X Tx.
admit. (** locally compact Hausdorff spaces are Baire **)
Qed.

(** from 48 Exercise 4: locally Baire implies Baire **)
(** LATEX VERSION: If every point has a neighborhood that is Baire, then X is Baire. **)
Theorem ex48_4_locally_Baire_implies_Baire : forall X Tx:set,
  topology_on X Tx ->
  (forall x:set, x :e X ->
    exists U:set, U :e Tx /\ x :e U /\
      Baire_space U (subspace_topology X Tx U)) ->
  Baire_space X Tx.
let X Tx.
assume Htop: topology_on X Tx.
assume Hlocal: forall x:set, x :e X -> exists U:set, U :e Tx /\ x :e U /\ Baire_space U (subspace_topology X Tx U).
prove Baire_space X Tx.
admit. (** local Baire property implies global Baire **)
Qed.

(** from 48 Exercise 5: G_delta in compact Hausdorff or complete metric is Baire **)
(** LATEX VERSION: If Y is G_ in X, and X is compact Hausdorff or complete metric, then Y is Baire in subspace topology. **)
Theorem ex48_5_Gdelta_Baire : forall X Tx Y:set,
  (compact_space X Tx /\ Hausdorff_space X Tx) ->
  (exists Fam:set, countable_set Fam /\
    (forall W:set, W :e Fam -> W :e Tx) /\
    Y = intersection_over_family X Fam) ->
  Baire_space Y (subspace_topology X Tx Y).
let X Tx Y.
assume Hcomp: compact_space X Tx /\ Hausdorff_space X Tx.
assume HGdelta: exists Fam:set, countable_set Fam /\ (forall W:set, W :e Fam -> W :e Tx) /\ Y = intersection_over_family X Fam.
prove Baire_space Y (subspace_topology X Tx Y).
admit. (** G_delta in compact Hausdorff is Baire **)
Qed.

(** from 48 Exercise 6: irrationals are Baire **)
(** LATEX VERSION: The irrationals are a Baire space. **)
Theorem ex48_6_irrationals_Baire :
  Baire_space (R :\: Q) (subspace_topology R R_standard_topology (R :\: Q)).
prove Baire_space (R :\: Q) (subspace_topology R R_standard_topology (R :\: Q)).
admit. (** irrationals form a Baire space **)
Qed.

(** from 48 Exercise 7a: continuity set is G_delta **)
(** LATEX VERSION: For f:, the set C of continuity points is G_. **)
Theorem ex48_7a_continuity_set_Gdelta : forall f:set,
  function_on f R R ->
  exists Fam:set, countable_set Fam /\
    (forall U:set, U :e Fam -> U :e R_standard_topology) /\
    {x :e R | continuous_at f x} = intersection_over_family R Fam.
let f.
assume Hf: function_on f R R.
prove exists Fam:set, countable_set Fam /\ (forall U:set, U :e Fam -> U :e R_standard_topology) /\ {x :e R | continuous_at f x} = intersection_over_family R Fam.
admit. (** continuity points form G_delta set **)
Qed.

(** from 48 Exercise 7b: countable dense not G_delta **)
(** LATEX VERSION: Countable dense D   is not G_. **)
Theorem ex48_7b_countable_dense_not_Gdelta : forall D:set,
  D c= R ->
  countable_set D ->
  dense_in D R R_standard_topology ->
  ~ (exists Fam:set, countable_set Fam /\
      (forall W:set, W :e Fam -> W :e R_standard_topology) /\
      D = intersection_over_family R Fam).
let D.
assume Hsub: D c= R.
assume Hcount: countable_set D.
assume Hdense: dense_in D R R_standard_topology.
prove ~ (exists Fam:set, countable_set Fam /\ (forall W:set, W :e Fam -> W :e R_standard_topology) /\ D = intersection_over_family R Fam).
admit. (** countable dense subset not G_delta **)
Qed.

(** from 48 Exercise 7: no function continuous precisely on countable dense set **)
(** LATEX VERSION: If D is countable dense in , no f: is continuous precisely on D. **)
Theorem ex48_7_no_function_continuous_on_countable_dense : forall D:set,
  D c= R ->
  countable_set D ->
  dense_in D R R_standard_topology ->
  ~ (exists f:set, function_on f R R /\
      (forall x:set, x :e D -> continuous_at f x) /\
      (forall x:set, x :e R -> x /:e D -> ~ continuous_at f x)).
let D.
assume Hsub: D c= R.
assume Hcount: countable_set D.
assume Hdense: dense_in D R R_standard_topology.
prove ~ (exists f:set, function_on f R R /\ (forall x:set, x :e D -> continuous_at f x) /\ (forall x:set, x :e R -> x /:e D -> ~ continuous_at f x)).
admit. (** no function continuous precisely on countable dense **)
Qed.

(** from 48 Exercise 8: pointwise limit continuous uncountably many points **)
(** LATEX VERSION: If f: continuous with f(x)f(x) for all x, then f is continuous at uncountably many points. **)
Theorem ex48_8_pointwise_limit_continuity : forall fn:set, forall f:set,
  (forall n:set, n :e omega ->
    continuous_map R R_standard_topology R R_standard_topology (apply_fun fn n)) ->
  function_on f R R ->
  (forall x:set, x :e R ->
    exists limval:set, limval :e R /\
      forall eps:set, eps :e R -> True) ->
  ~ countable_set {x :e R | continuous_at f x}.
let fn f.
assume Hfn: forall n:set, n :e omega -> continuous_map R R_standard_topology R R_standard_topology (apply_fun fn n).
assume Hf: function_on f R R.
assume Hlim: forall x:set, x :e R -> exists limval:set, limval :e R /\ forall eps:set, eps :e R -> True.
prove ~ countable_set {x :e R | continuous_at f x}.
admit. (** pointwise limit has uncountably many continuity points **)
Qed.

(** from 48 Exercise 9: Thomae function **)
(** LATEX VERSION: Define f(x)=1/n for rationals, f(x)=0 for irrationals. Then f is continuous at irrationals. **)
Theorem ex48_9_Thomae_function : forall g:set, forall f:set,
  (forall n:set, n :e omega -> apply_fun g n :e Q) ->
  function_on f R R ->
  (forall n:set, n :e omega -> apply_fun f (apply_fun g n) = recip_SNo (ordsucc n)) ->
  (forall x:set, x :e R -> x /:e Q -> apply_fun f x = 0) ->
  forall x:set, x :e R -> x /:e Q -> continuous_at f x.
let g f.
assume Hg: forall n:set, n :e omega -> apply_fun g n :e Q.
assume Hf: function_on f R R.
assume Hfg: forall n:set, n :e omega -> apply_fun f (apply_fun g n) = recip_SNo (ordsucc n).
assume Hfirr: forall x:set, x :e R -> x /:e Q -> apply_fun f x = 0.
let x.
assume Hx: x :e R.
assume Hirr: x /:e Q.
prove continuous_at f x.
admit. (** Thomae function continuous at irrationals **)
Qed.

(** from 48 Exercise 10: uniform boundedness principle **)
(** LATEX VERSION: Uniform boundedness: if X complete metric and C(X,) pointwise bounded, then uniformly bounded on some nonempty open set. **)
Theorem ex48_10_uniform_boundedness : forall X d:set, forall FF:set,
  complete_metric_space X d ->
  FF c= Power (Power R) ->
  (forall a:set, a :e X ->
    exists M:set, M :e R /\
      forall f:set, f :e FF -> apply_fun f a :e R) ->
  exists U:set, exists M:set, U :e (metric_topology X d) /\ U <> Empty /\
    M :e R /\
    forall f:set, f :e FF ->
      forall x:set, x :e U -> apply_fun f x :e R.
let X d FF.
assume Hcomplete: complete_metric_space X d.
assume HFF: FF c= Power (Power R).
assume Hbound: forall a:set, a :e X -> exists M:set, M :e R /\ forall f:set, f :e FF -> apply_fun f a :e R.
prove exists U:set, exists M:set, U :e (metric_topology X d) /\ U <> Empty /\ M :e R /\ forall f:set, f :e FF -> forall x:set, x :e U -> apply_fun f x :e R.
admit. (** uniform boundedness principle for complete metric **)
Qed.

(** from 48 Exercise 11: is R_l a Baire space **)
(** LATEX VERSION: Determine whether _ is a Baire space. **)
(** STUB: This theorem needs proper lower limit topology definition. **)
Theorem ex48_11_Rl_Baire : forall Tl:set,
  Tl = R (** stub: lower limit topology **) ->
  Baire_space R Tl.
let Tl.
assume HTl: Tl = R.
prove Baire_space R Tl.
admit. (** _ is a Baire space **)
Qed.

(** from 49 Exercise 1: verify properties of example functions **)
(** LATEX VERSION: Check the stated properties of the functions f, g, and k of Example 1. **)
(** stub: Example 1 functions f, g, k not fully formalized **)
Theorem ex49_1_verify_example_functions : forall f g k:set,
  f = R (** stub: Example 1 function f **) ->
  g = R (** stub: Example 1 function g **) ->
  k = R (** stub: Example 1 function k **) ->
  continuous_map R R_standard_topology R R_standard_topology f /\
  continuous_map R R_standard_topology R R_standard_topology g /\
  continuous_map R R_standard_topology R R_standard_topology k.
let f g k.
assume Hf: f = R.
assume Hg: g = R.
assume Hk: k = R.
prove continuous_map R R_standard_topology R R_standard_topology f /\ continuous_map R R_standard_topology R R_standard_topology g /\ continuous_map R R_standard_topology R R_standard_topology k.
admit. (** verify properties from 49 Example 1 **)
Qed.

(** from 49 Exercise 2: construct continuous function in U_n with bounded values **)
(** LATEX VERSION: Given n and , define continuous f:I such that fU and |f(x)| for all x. **)
(** stub: U_n not defined (related to nowhere-differentiable construction) **)
Theorem ex49_2_construct_bounded_function : forall n:set, forall eps:set,
  n :e omega ->
  eps :e R ->
  exists f:set,
    continuous_map unit_interval R_standard_topology R R_standard_topology f /\
    (forall x:set, x :e unit_interval -> apply_fun f x :e R) /\
    True. (** stub: need U_n membership and bound condition **)
let n eps.
assume Hn: n :e omega.
assume Heps: eps :e R.
prove exists f:set, continuous_map unit_interval R_standard_topology R R_standard_topology f /\ (forall x:set, x :e unit_interval -> apply_fun f x :e R) /\ True.
admit. (** construct bounded continuous function in U_n **)
Qed.

(** from 50 Exercises: dimension theory introduction (placeholder) **) 
(** LATEX VERSION: Exercises introducing dimension theory concepts. **)
Definition ex50_dimension_exercises : set :=
  {p :e Power (Power (Power (Power (Power (Power R))))) |
    exists X Tx n:set,
      p = setprod (setprod X Tx) n /\ topology_on X Tx /\ ordinal n}.
